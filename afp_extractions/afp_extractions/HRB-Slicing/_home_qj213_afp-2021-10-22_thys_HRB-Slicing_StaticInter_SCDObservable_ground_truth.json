{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/SCDObservable.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma matched_bracket_assms_variant:\n  assumes \"n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V'\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\" and \"matched n\\<^sub>2 ns' n\\<^sub>3\" \n  and \"n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or> n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\"\n  and \"call_of_return_node (parent_node n\\<^sub>4) (parent_node n\\<^sub>1)\"\n  obtains a a' where \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  and \"sourcenode a = parent_node n\\<^sub>1\" and \"targetnode a = parent_node n\\<^sub>2\"\n  and \"sourcenode a' = parent_node n\\<^sub>3\" and \"targetnode a' = parent_node n\\<^sub>4\"", "lemma [intro]:\"\\<forall>n \\<in> S. valid_SDG_node n \\<Longrightarrow> \\<forall>n \\<in> \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub>. valid_node n\"", "lemma Exit_HRB_Slice:\n  assumes \"n \\<in> \\<lfloor>HRB_slice {CFG_node (_Exit_)}\\<rfloor>\\<^bsub>CFG\\<^esub>\" shows \"n = (_Exit_)\"", "lemma Exit_in_obs_intra_slice_node:\n  assumes \"(_Exit_) \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"CFG_node (_Exit_) \\<in> S\"", "lemma obs_intra_postdominate:\n  assumes \"n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<not> method_exit n\"\n  shows \"n postdominates n'\"", "lemma obs_intra_singleton_disj: \n  assumes \"valid_node n\"\n  shows \"(\\<exists>m. obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}) \\<or> \n         obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\"", "lemma obs_intra_finite:\"valid_node n \\<Longrightarrow> finite (obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\"", "lemma obs_intra_singleton:\"valid_node n \\<Longrightarrow> card (obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<le> 1\"", "lemma obs_intra_singleton_element:\n  \"m \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\"", "lemma obs_intra_the_element: \n  \"m \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow> (THE m. m \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) = m\"", "lemma obs_singleton_element:\n  assumes \"ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<forall>n \\<in> set (tl ns). return_node n\"\n  shows \"obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}\"", "lemma obs_finite:\"\\<forall>n \\<in> set (tl ns). return_node n \n  \\<Longrightarrow> finite (obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\"", "lemma obs_singleton:\"\\<forall>n \\<in> set (tl ns). return_node n \n  \\<Longrightarrow> card (obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<le> 1\"", "lemma obs_the_element: \n  \"\\<lbrakk>ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \\<forall>n \\<in> set (tl ns). return_node n\\<rbrakk> \n  \\<Longrightarrow> (THE ms. ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) = ms\""], "translations": [["", "lemma matched_bracket_assms_variant:\n  assumes \"n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V'\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\" and \"matched n\\<^sub>2 ns' n\\<^sub>3\" \n  and \"n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or> n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\"\n  and \"call_of_return_node (parent_node n\\<^sub>4) (parent_node n\\<^sub>1)\"\n  obtains a a' where \"valid_edge a\" and \"a' \\<in> get_return_edges a\"\n  and \"sourcenode a = parent_node n\\<^sub>1\" and \"targetnode a = parent_node n\\<^sub>2\"\n  and \"sourcenode a' = parent_node n\\<^sub>3\" and \"targetnode a' = parent_node n\\<^sub>4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a a'.\n        \\<lbrakk>valid_edge a; a' \\<in> get_return_edges a;\n         sourcenode a = parent_node n\\<^sub>1;\n         targetnode a = parent_node n\\<^sub>2;\n         sourcenode a' = parent_node n\\<^sub>3;\n         targetnode a' = parent_node n\\<^sub>4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "from \\<open>n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or> n\\<^sub>1 -p:V'\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V'\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2", "obtain a Q r fs where \"valid_edge a\" \n    and \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"parent_node n\\<^sub>1 = sourcenode a\"\n    and \"parent_node n\\<^sub>2 = targetnode a\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -p\\<rightarrow>\\<^bsub>call\\<^esub> n\\<^sub>2 \\<or>\n  n\\<^sub>1 -p:V'\\<rightarrow>\\<^bsub>in\\<^esub> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>a Q r fs.\n        \\<lbrakk>valid_edge a;\n         kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         parent_node n\\<^sub>1 = sourcenode a;\n         parent_node n\\<^sub>2 = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  parent_node n\\<^sub>1 = sourcenode a\n  parent_node n\\<^sub>2 = targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "from \\<open>n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or> n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4", "obtain a' Q' f'\n    where \"valid_edge a'\" and \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n    and \"parent_node n\\<^sub>3 = sourcenode a'\" and \"parent_node n\\<^sub>4 = targetnode a'\""], ["proof (prove)\nusing this:\n  n\\<^sub>3 -p\\<rightarrow>\\<^bsub>ret\\<^esub> n\\<^sub>4 \\<or>\n  n\\<^sub>3 -p:V\\<rightarrow>\\<^bsub>out\\<^esub> n\\<^sub>4\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' f'.\n        \\<lbrakk>valid_edge a';\n         kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         parent_node n\\<^sub>3 = sourcenode a';\n         parent_node n\\<^sub>4 = targetnode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:SDG_edge.cases)"], ["proof (state)\nthis:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  parent_node n\\<^sub>3 = sourcenode a'\n  parent_node n\\<^sub>4 = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "obtain ax where \"valid_edge ax\" and \"\\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n    and \"a' \\<in> get_return_edges ax\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax;\n         \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> get_return_edges ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule return_needs_call,fastforce+)"], ["proof (state)\nthis:\n  valid_edge ax\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "from \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>\\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"targetnode a = targetnode ax\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. targetnode a = targetnode ax", "by(fastforce dest:same_proc_call_unique_target)"], ["proof (state)\nthis:\n  targetnode a = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "from \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges ax\\<close> \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  a' \\<in> get_return_edges ax\n  valid_edge ax", "have \"call_of_return_node (targetnode a') (sourcenode ax)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  a' \\<in> get_return_edges ax\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode ax)", "by(fastforce simp:return_node_def call_of_return_node_def)"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode ax)\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "with \\<open>call_of_return_node (parent_node n\\<^sub>4) (parent_node n\\<^sub>1)\\<close> \n    \\<open>parent_node n\\<^sub>4 = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node (parent_node n\\<^sub>4) (parent_node n\\<^sub>1)\n  parent_node n\\<^sub>4 = targetnode a'\n  call_of_return_node (targetnode a') (sourcenode ax)", "have \"sourcenode ax = parent_node n\\<^sub>1\""], ["proof (prove)\nusing this:\n  call_of_return_node (parent_node n\\<^sub>4) (parent_node n\\<^sub>1)\n  parent_node n\\<^sub>4 = targetnode a'\n  call_of_return_node (targetnode a') (sourcenode ax)\n\ngoal (1 subgoal):\n 1. sourcenode ax = parent_node n\\<^sub>1", "by fastforce"], ["proof (state)\nthis:\n  sourcenode ax = parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "with \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close> \\<open>targetnode a = targetnode ax\\<close>\n    \\<open>parent_node n\\<^sub>2 = targetnode a\\<close> \\<open>parent_node n\\<^sub>3 = sourcenode a'\\<close> \n    \\<open>parent_node n\\<^sub>4 = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  targetnode a = targetnode ax\n  parent_node n\\<^sub>2 = targetnode a\n  parent_node n\\<^sub>3 = sourcenode a'\n  parent_node n\\<^sub>4 = targetnode a'\n  sourcenode ax = parent_node n\\<^sub>1", "show \"\\<exists>a a'. valid_edge a \\<and> a' \\<in> get_return_edges a \\<and>\n    sourcenode a = parent_node n\\<^sub>1 \\<and> targetnode a = parent_node n\\<^sub>2 \\<and>\n    sourcenode a' = parent_node n\\<^sub>3 \\<and> targetnode a' = parent_node n\\<^sub>4\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  targetnode a = targetnode ax\n  parent_node n\\<^sub>2 = targetnode a\n  parent_node n\\<^sub>3 = sourcenode a'\n  parent_node n\\<^sub>4 = targetnode a'\n  sourcenode ax = parent_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>a a'.\n       valid_edge a \\<and>\n       a' \\<in> get_return_edges a \\<and>\n       sourcenode a = parent_node n\\<^sub>1 \\<and>\n       targetnode a = parent_node n\\<^sub>2 \\<and>\n       sourcenode a' = parent_node n\\<^sub>3 \\<and>\n       targetnode a' = parent_node n\\<^sub>4", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>a a'.\n     valid_edge a \\<and>\n     a' \\<in> get_return_edges a \\<and>\n     sourcenode a = parent_node n\\<^sub>1 \\<and>\n     targetnode a = parent_node n\\<^sub>2 \\<and>\n     sourcenode a' = parent_node n\\<^sub>3 \\<and>\n     targetnode a' = parent_node n\\<^sub>4\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Observable set of standard control dependence is at most a singleton\\<close>"], ["", "definition SDG_to_CFG_set :: \"'node SDG_node set \\<Rightarrow> 'node set\" (\"\\<lfloor>_\\<rfloor>\\<^bsub>CFG\\<^esub>\")\n  where \"\\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<equiv> {m. CFG_node m \\<in> S}\""], ["", "lemma [intro]:\"\\<forall>n \\<in> S. valid_SDG_node n \\<Longrightarrow> \\<forall>n \\<in> \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub>. valid_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball S valid_SDG_node \\<Longrightarrow>\n    Ball \\<lfloor>S\\<rfloor>\\<^bsub>CFG\\<^esub> valid_node", "by(fastforce simp:SDG_to_CFG_set_def)"], ["", "lemma Exit_HRB_Slice:\n  assumes \"n \\<in> \\<lfloor>HRB_slice {CFG_node (_Exit_)}\\<rfloor>\\<^bsub>CFG\\<^esub>\" shows \"n = (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = (_Exit_)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = (_Exit_)", "from \\<open>n \\<in> \\<lfloor>HRB_slice {CFG_node (_Exit_)}\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> \\<lfloor>HRB_slice {CFG_node (_Exit_)}\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"CFG_node n \\<in> HRB_slice {CFG_node (_Exit_)}\""], ["proof (prove)\nusing this:\n  n \\<in> \\<lfloor>HRB_slice {CFG_node (_Exit_)}\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. CFG_node n \\<in> HRB_slice {CFG_node (_Exit_)}", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  CFG_node n \\<in> HRB_slice {CFG_node (_Exit_)}\n\ngoal (1 subgoal):\n 1. n = (_Exit_)", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node n \\<in> HRB_slice {CFG_node (_Exit_)}\n\ngoal (1 subgoal):\n 1. n = (_Exit_)", "proof(induct \"CFG_node n\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node n \\<in> sum_SDG_slice1 nx;\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "case (phase1 nx)"], ["proof (state)\nthis:\n  CFG_node n \\<in> sum_SDG_slice1 nx\n  nx \\<in> {CFG_node (_Exit_)}\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node n \\<in> sum_SDG_slice1 nx;\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "from \\<open>nx \\<in> {CFG_node (_Exit_)}\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> {CFG_node (_Exit_)}", "have \"nx = CFG_node (_Exit_)\""], ["proof (prove)\nusing this:\n  nx \\<in> {CFG_node (_Exit_)}\n\ngoal (1 subgoal):\n 1. nx = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  nx = CFG_node (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node n \\<in> sum_SDG_slice1 nx;\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "with \\<open>CFG_node n \\<in> sum_SDG_slice1 nx\\<close>"], ["proof (chain)\npicking this:\n  CFG_node n \\<in> sum_SDG_slice1 nx\n  nx = CFG_node (_Exit_)", "have \"CFG_node n = CFG_node (_Exit_) \\<or> \n      (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\""], ["proof (prove)\nusing this:\n  CFG_node n \\<in> sum_SDG_slice1 nx\n  nx = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. CFG_node n = CFG_node (_Exit_) \\<or>\n    (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))", "by(induct rule:sum_SDG_slice1.induct) auto"], ["proof (state)\nthis:\n  CFG_node n = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node n \\<in> sum_SDG_slice1 nx;\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "then"], ["proof (chain)\npicking this:\n  CFG_node n = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node n = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\n\ngoal (1 subgoal):\n 1. n = (_Exit_)", "by(fastforce dest:Exit_no_sum_SDG_edge_target)"], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "case (phase2 nx n' n'' p)"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  CFG_node n \\<in> sum_SDG_slice2 n'\n  nx \\<in> {CFG_node (_Exit_)}\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "from \\<open>nx \\<in> {CFG_node (_Exit_)}\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> {CFG_node (_Exit_)}", "have \"nx = CFG_node (_Exit_)\""], ["proof (prove)\nusing this:\n  nx \\<in> {CFG_node (_Exit_)}\n\ngoal (1 subgoal):\n 1. nx = CFG_node (_Exit_)", "by simp"], ["proof (state)\nthis:\n  nx = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "with \\<open>n' \\<in> sum_SDG_slice1 nx\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> sum_SDG_slice1 nx\n  nx = CFG_node (_Exit_)", "have \"n' = CFG_node (_Exit_) \\<or> \n      (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\""], ["proof (prove)\nusing this:\n  n' \\<in> sum_SDG_slice1 nx\n  nx = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. n' = CFG_node (_Exit_) \\<or>\n    (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))", "by(induct rule:sum_SDG_slice1.induct) auto"], ["proof (state)\nthis:\n  n' = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "hence \"n' = CFG_node (_Exit_)\""], ["proof (prove)\nusing this:\n  n' = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\n\ngoal (1 subgoal):\n 1. n' = CFG_node (_Exit_)", "by(fastforce dest:Exit_no_sum_SDG_edge_target)"], ["proof (state)\nthis:\n  n' = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "with \\<open>CFG_node n \\<in> sum_SDG_slice2 n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node n \\<in> sum_SDG_slice2 n'\n  n' = CFG_node (_Exit_)", "have \"CFG_node n = CFG_node (_Exit_) \\<or> \n      (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\""], ["proof (prove)\nusing this:\n  CFG_node n \\<in> sum_SDG_slice2 n'\n  n' = CFG_node (_Exit_)\n\ngoal (1 subgoal):\n 1. CFG_node n = CFG_node (_Exit_) \\<or>\n    (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))", "by(induct rule:sum_SDG_slice2.induct) auto"], ["proof (state)\nthis:\n  CFG_node n = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node n \\<in> sum_SDG_slice2 n';\n        nx \\<in> {CFG_node (_Exit_)}\\<rbrakk>\n       \\<Longrightarrow> n = (_Exit_)", "then"], ["proof (chain)\npicking this:\n  CFG_node n = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))", "show ?thesis"], ["proof (prove)\nusing this:\n  CFG_node n = CFG_node (_Exit_) \\<or>\n  (\\<exists>n Vopt popt b. sum_SDG_edge n Vopt popt b (CFG_node (_Exit_)))\n\ngoal (1 subgoal):\n 1. n = (_Exit_)", "by(fastforce dest:Exit_no_sum_SDG_edge_target)"], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_in_obs_intra_slice_node:\n  assumes \"(_Exit_) \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"CFG_node (_Exit_) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "let ?S' = \"\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "from \\<open>(_Exit_) \\<in> obs_intra n' ?S'\\<close>"], ["proof (chain)\npicking this:\n  (_Exit_)\n  \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"n' -as\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\"\n    and \"\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> ?S'\" and \"(_Exit_) \\<in> ?S'\""], ["proof (prove)\nusing this:\n  (_Exit_)\n  \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n' -as\\<rightarrow>\\<^sub>\\<iota>* (_Exit_);\n         \\<forall>nx\\<in>set (sourcenodes as).\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         (_Exit_)\n         \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obs_intraE)"], ["proof (state)\nthis:\n  n' -as\\<rightarrow>\\<^sub>\\<iota>* (_Exit_)\n  \\<forall>nx\\<in>set (sourcenodes as).\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (_Exit_) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "from \\<open>(_Exit_) \\<in> ?S'\\<close>"], ["proof (chain)\npicking this:\n  (_Exit_) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"CFG_node (_Exit_) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  (_Exit_) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> HRB_slice S", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  CFG_node (_Exit_) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "proof(induct \"CFG_node (_Exit_)\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (_Exit_) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "case (phase1 nx)"], ["proof (state)\nthis:\n  CFG_node (_Exit_) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (_Exit_) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "thus ?case"], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "by(induct \"CFG_node (_Exit_)\" rule:sum_SDG_slice1.induct,\n        auto dest:Exit_no_sum_SDG_edge_source)"], ["proof (state)\nthis:\n  CFG_node (_Exit_) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "case (phase2 nx n' n'' p)"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "from \\<open>CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'\\<close> \\<open>n' \\<in> sum_SDG_slice1 nx\\<close> \\<open>nx \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'\n  n' \\<in> sum_SDG_slice1 nx\n  nx \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  CFG_node (_Exit_) \\<in> sum_SDG_slice2 n'\n  n' \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. CFG_node (_Exit_) \\<in> S", "apply(induct n\\<equiv>\"CFG_node (_Exit_)\" rule:sum_SDG_slice2.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>valid_SDG_node n'; n' = CFG_node (_Exit_);\n     n' \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n    \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 2. \\<And>n'.\n       \\<lbrakk>CFG_node (_Exit_) s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n' \\<in> sum_SDG_slice2 n';\n        \\<lbrakk>n' = CFG_node (_Exit_); n' \\<in> sum_SDG_slice1 nx;\n         nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        n' \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 3. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        n' \\<in> sum_SDG_slice2 n';\n        \\<lbrakk>n' = CFG_node (_Exit_); n' \\<in> sum_SDG_slice1 nx;\n         nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        n' \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 4. \\<And>p n'.\n       \\<lbrakk>CFG_node (_Exit_) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> n';\n        n' \\<in> sum_SDG_slice2 n';\n        \\<lbrakk>n' = CFG_node (_Exit_); n' \\<in> sum_SDG_slice1 nx;\n         nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        n' \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 5. \\<And>p V n'.\n       \\<lbrakk>CFG_node (_Exit_) s-p:V\\<rightarrow>\\<^bsub>out\\<^esub> n';\n        n' \\<in> sum_SDG_slice2 n';\n        \\<lbrakk>n' = CFG_node (_Exit_); n' \\<in> sum_SDG_slice1 nx;\n         nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        n' \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 6. \\<And>p n'.\n       \\<lbrakk>CFG_node (_Exit_) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n' \\<in> sum_SDG_slice2 n';\n        \\<lbrakk>n' = CFG_node (_Exit_); n' \\<in> sum_SDG_slice1 nx;\n         nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        n' \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "apply(auto dest:Exit_no_sum_SDG_edge_source)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n' = CFG_node (_Exit_);\n     CFG_node (_Exit_) \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n    \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "apply(hypsubst_thin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CFG_node (_Exit_) \\<in> sum_SDG_slice1 nx; nx \\<in> S\\<rbrakk>\n    \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "apply(induct n\\<equiv>\"CFG_node (_Exit_)\" rule:sum_SDG_slice1.induct)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>valid_SDG_node nx; nx = CFG_node (_Exit_); nx \\<in> S\\<rbrakk>\n    \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 2. \\<And>n'.\n       \\<lbrakk>CFG_node (_Exit_) s\\<longrightarrow>\\<^bsub>cd\\<^esub> n';\n        n' \\<in> sum_SDG_slice1 nx;\n        \\<lbrakk>n' = CFG_node (_Exit_); nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 3. \\<And>V n'.\n       \\<lbrakk>CFG_node (_Exit_) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n';\n        n' \\<in> sum_SDG_slice1 nx;\n        \\<lbrakk>n' = CFG_node (_Exit_); nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 4. \\<And>p n'.\n       \\<lbrakk>CFG_node (_Exit_) s-p\\<rightarrow>\\<^bsub>call\\<^esub> n';\n        n' \\<in> sum_SDG_slice1 nx;\n        \\<lbrakk>n' = CFG_node (_Exit_); nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 5. \\<And>p V n'.\n       \\<lbrakk>CFG_node (_Exit_) s-p:V\\<rightarrow>\\<^bsub>in\\<^esub> n';\n        n' \\<in> sum_SDG_slice1 nx;\n        \\<lbrakk>n' = CFG_node (_Exit_); nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S\n 6. \\<And>p n'.\n       \\<lbrakk>CFG_node (_Exit_) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> n';\n        n' \\<in> sum_SDG_slice1 nx;\n        \\<lbrakk>n' = CFG_node (_Exit_); nx \\<in> S\\<rbrakk>\n        \\<Longrightarrow> CFG_node (_Exit_) \\<in> S;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (_Exit_) \\<in> S", "apply(auto dest:Exit_no_sum_SDG_edge_source)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  CFG_node (_Exit_) \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_node (_Exit_) \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_intra_postdominate:\n  assumes \"n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<not> method_exit n\"\n  shows \"n postdominates n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n postdominates n'", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "assume \"\\<not> n postdominates n'\""], ["proof (state)\nthis:\n  \\<not> n postdominates n'\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "from \\<open>n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. valid_node n", "by(fastforce dest:in_obs_intra_valid)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>\\<not> method_exit n\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit n\n  valid_node n", "have \"n postdominates n\""], ["proof (prove)\nusing this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit n\n  valid_node n\n\ngoal (1 subgoal):\n 1. n postdominates n", "by(fastforce intro:postdominate_refl)"], ["proof (state)\nthis:\n  n postdominates n\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "from \\<open>n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"n' -as\\<rightarrow>\\<^sub>\\<iota>* n\"\n    and all_notinS:\"\\<forall>n' \\<in> set(sourcenodes as). n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    and \"n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n' -as\\<rightarrow>\\<^sub>\\<iota>* n;\n         \\<forall>n'\\<in>set (sourcenodes as).\n            n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obs_intraE)"], ["proof (state)\nthis:\n  n' -as\\<rightarrow>\\<^sub>\\<iota>* n\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "from \\<open>n postdominates n\\<close> \\<open>\\<not> n postdominates n'\\<close> \\<open>n' -as\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  n postdominates n\n  \\<not> n postdominates n'\n  n' -as\\<rightarrow>\\<^sub>\\<iota>* n", "obtain as' a as'' where [simp]:\"as = as'@a#as''\"\n    and \"valid_edge a\" and \"\\<not> n postdominates (sourcenode a)\"\n    and \"n postdominates (targetnode a)\"  and \"intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  n postdominates n\n  \\<not> n postdominates n'\n  n' -as\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. (\\<And>as' a as''.\n        \\<lbrakk>as = as' @ a # as''; valid_edge a;\n         \\<not> n postdominates sourcenode a; n postdominates targetnode a;\n         intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:postdominate_path_branch simp:intra_path_def)"], ["proof (state)\nthis:\n  as = as' @ a # as''\n  valid_edge a\n  \\<not> n postdominates sourcenode a\n  n postdominates targetnode a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "from \\<open>n' -as\\<rightarrow>\\<^sub>\\<iota>* n\\<close>"], ["proof (chain)\npicking this:\n  n' -as\\<rightarrow>\\<^sub>\\<iota>* n", "have \"sourcenode a -a#as''\\<rightarrow>\\<^sub>\\<iota>* n\""], ["proof (prove)\nusing this:\n  n' -as\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as''\\<rightarrow>\\<^sub>\\<iota>* n", "by(fastforce elim:path_split intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a # as''\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>\\<not> n postdominates (sourcenode a)\\<close> \\<open>valid_edge a\\<close> \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  \\<not> n postdominates sourcenode a\n  valid_edge a\n  valid_node n\n  sourcenode a -a # as''\\<rightarrow>\\<^sub>\\<iota>* n", "obtain asx pex where \"sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\" \n    and \"n \\<notin> set(sourcenodes asx)\""], ["proof (prove)\nusing this:\n  \\<not> n postdominates sourcenode a\n  valid_edge a\n  valid_node n\n  sourcenode a -a # as''\\<rightarrow>\\<^sub>\\<iota>* n\n\ngoal (1 subgoal):\n 1. (\\<And>asx pex.\n        \\<lbrakk>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex; n \\<notin> set (sourcenodes asx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  n \\<notin> set (sourcenodes asx)\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "have \"asx \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asx \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. asx = [] \\<Longrightarrow> False", "assume \"asx = []\""], ["proof (state)\nthis:\n  asx = []\n\ngoal (1 subgoal):\n 1. asx = [] \\<Longrightarrow> False", "with \\<open>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = []", "have \"sourcenode a = pex\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = []\n\ngoal (1 subgoal):\n 1. sourcenode a = pex", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a = pex\n\ngoal (1 subgoal):\n 1. asx = [] \\<Longrightarrow> False", "from \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  method_exit pex", "show False"], ["proof (prove)\nusing this:\n  method_exit pex\n\ngoal (1 subgoal):\n 1. False", "proof(rule method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"pex = (_Exit_)\""], ["proof (state)\nthis:\n  pex = (_Exit_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>sourcenode a = pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = pex\n  pex = (_Exit_)", "have \"sourcenode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  sourcenode a = pex\n  pex = (_Exit_)\n\ngoal (1 subgoal):\n 1. sourcenode a = (_Exit_)", "by simp"], ["proof (state)\nthis:\n  sourcenode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. pex = (_Exit_) \\<Longrightarrow> False\n 2. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Exit_)", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "fix a' Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"pex = sourcenode a'\" and \"valid_edge a'\" and \"kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  pex = sourcenode a'\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>pex = sourcenode a; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>\n        \\<open>sourcenode a = pex\\<close> \\<open>pex = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a = pex\n  pex = sourcenode a'", "show False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a = pex\n  pex = sourcenode a'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  asx \\<noteq> []", "obtain ax asx' where [simp]:\"asx = ax#asx'\""], ["proof (prove)\nusing this:\n  asx \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>ax asx'.\n        asx = ax # asx' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases asx) auto"], ["proof (state)\nthis:\n  asx = ax # asx'\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = ax # asx'", "have \"sourcenode a -ax#asx'\\<rightarrow>* pex\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  asx = ax # asx'\n\ngoal (1 subgoal):\n 1. sourcenode a -ax # asx'\\<rightarrow>* pex", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -ax # asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "hence \"valid_edge ax\" and [simp]:\"sourcenode a = sourcenode ax\"\n    and \"targetnode ax -asx'\\<rightarrow>* pex\""], ["proof (prove)\nusing this:\n  sourcenode a -ax # asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. valid_edge ax &&&\n    sourcenode a = sourcenode ax &&& targetnode ax -asx'\\<rightarrow>* pex", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode ax -asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode ax -asx'\\<rightarrow>* pex", "have \"targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode ax -asx'\\<rightarrow>* pex\n\ngoal (1 subgoal):\n 1. targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>valid_edge ax\\<close> \\<open>n \\<notin> set(sourcenodes asx)\\<close> \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  n \\<notin> set (sourcenodes asx)\n  method_exit pex\n  targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"\\<not> n postdominates targetnode ax\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  n \\<notin> set (sourcenodes asx)\n  method_exit pex\n  targetnode ax -asx'\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates targetnode ax", "by(fastforce simp:postdominate_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<not> n postdominates targetnode ax\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "from \\<open>n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> all_notinS"], ["proof (chain)\npicking this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"n \\<notin> set (sourcenodes (a#as''))\""], ["proof (prove)\nusing this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. n \\<notin> set (sourcenodes (a # as''))", "by(fastforce elim:obs_intra.cases simp:sourcenodes_def)"], ["proof (state)\nthis:\n  n \\<notin> set (sourcenodes (a # as''))\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "from \\<open>sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"intra_kind (kind ax)\""], ["proof (prove)\nusing this:\n  sourcenode a -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax)", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>sourcenode a -a#as''\\<rightarrow>\\<^sub>\\<iota>* n\\<close> \\<open>n postdominates (targetnode a)\\<close> \n    \\<open>\\<not> n postdominates targetnode ax\\<close> \\<open>valid_edge ax\\<close> \n    \\<open>n \\<notin> set (sourcenodes (a#as''))\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -a # as''\\<rightarrow>\\<^sub>\\<iota>* n\n  n postdominates targetnode a\n  \\<not> n postdominates targetnode ax\n  valid_edge ax\n  n \\<notin> set (sourcenodes (a # as''))\n  intra_kind (kind a)\n  intra_kind (kind ax)", "have \"(sourcenode a) controls n\""], ["proof (prove)\nusing this:\n  sourcenode a -a # as''\\<rightarrow>\\<^sub>\\<iota>* n\n  n postdominates targetnode a\n  \\<not> n postdominates targetnode ax\n  valid_edge ax\n  n \\<notin> set (sourcenodes (a # as''))\n  intra_kind (kind a)\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. sourcenode a controls n", "by(fastforce simp:control_dependence_def)"], ["proof (state)\nthis:\n  sourcenode a controls n\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "hence \"CFG_node (sourcenode a) s\\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n\""], ["proof (prove)\nusing this:\n  sourcenode a controls n\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) s\\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n", "by(fastforce intro:sum_SDG_cdep_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) s\\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with \\<open>n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) s\\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  n \\<in> obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) s\\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node n\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(auto elim!:obs_intraE combine_SDG_slices.cases \n            intro:combine_SDG_slices.intros sum_SDG_slice1.intros \n                  sum_SDG_slice2.intros simp:HRB_slice_def SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> n postdominates n' \\<Longrightarrow> False", "with all_notinS"], ["proof (chain)\npicking this:\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_intra_singleton_disj: \n  assumes \"valid_node n\"\n  shows \"(\\<exists>m. obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}) \\<or> \n         obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m}) \\<or>\n    obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "assume \"\\<not> ((\\<exists>m. obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}) \\<or> \n             obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {})\""], ["proof (state)\nthis:\n  \\<not> ((\\<exists>m.\n              obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n              {m}) \\<or>\n          obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {})\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "hence \"\\<exists>nx nx'. nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and> \n    nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and> nx \\<noteq> nx'\""], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>m.\n              obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n              {m}) \\<or>\n          obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {})\n\ngoal (1 subgoal):\n 1. \\<exists>nx nx'.\n       nx \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n       nx'\n       \\<in> obs_intra n\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n       nx \\<noteq> nx'", "by auto"], ["proof (state)\nthis:\n  \\<exists>nx nx'.\n     nx \\<in> obs_intra n\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     nx'\n     \\<in> obs_intra n\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     nx \\<noteq> nx'\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>nx nx'.\n     nx \\<in> obs_intra n\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     nx'\n     \\<in> obs_intra n\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     nx \\<noteq> nx'", "obtain nx nx' where \"nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" \n    and \"nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"nx \\<noteq> nx'\""], ["proof (prove)\nusing this:\n  \\<exists>nx nx'.\n     nx \\<in> obs_intra n\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     nx'\n     \\<in> obs_intra n\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     nx \\<noteq> nx'\n\ngoal (1 subgoal):\n 1. (\\<And>nx nx'.\n        \\<lbrakk>nx \\<in> obs_intra n\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         nx'\n         \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         nx \\<noteq> nx'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> nx'\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "from \\<open>nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"n -as\\<rightarrow>\\<^sub>\\<iota>* nx\" \n    and all:\"\\<forall>n' \\<in> set(sourcenodes as). n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" \n    and \"nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>\\<^sub>\\<iota>* nx;\n         \\<forall>n'\\<in>set (sourcenodes as).\n            n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obs_intraE)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* nx\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "from \\<open>n -as\\<rightarrow>\\<^sub>\\<iota>* nx\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* nx", "have \"n -as\\<rightarrow>* nx\" and \"\\<forall>a \\<in> set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>\\<^sub>\\<iota>* nx\n\ngoal (1 subgoal):\n 1. n -as\\<rightarrow>* nx &&& \\<forall>a\\<in>set as. intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* nx\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "hence \"valid_node nx\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* nx\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. valid_node nx", "by(fastforce dest:path_valid_node)"], ["proof (state)\nthis:\n  valid_node nx\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "with \\<open>nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_node nx", "have \"obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\""], ["proof (prove)\nusing this:\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_node nx\n\ngoal (1 subgoal):\n 1. obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}", "by -(rule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "with \\<open>n -as\\<rightarrow>* nx\\<close> \\<open>nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n    \\<open>nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>nx \\<noteq> nx'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* nx\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> nx'\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}", "have \"as \\<noteq> []\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* nx\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> nx'\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\n\ngoal (1 subgoal):\n 1. as \\<noteq> []", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "with \\<open>n -as\\<rightarrow>* nx\\<close> \\<open>nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n    \\<open>nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>nx \\<noteq> nx'\\<close> \n    \\<open>obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\\<close> \\<open>\\<forall>a \\<in> set as. intra_kind (kind a)\\<close> all"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* nx\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> nx'\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  as \\<noteq> []", "have \"\\<exists>a as' as''. n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and> targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* nx \\<and>\n                     valid_edge a \\<and> as = as'@a#as'' \\<and> intra_kind (kind a) \\<and>\n                     obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx} \\<and> \n                    (\\<not> (\\<exists>m. obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m} \\<or> \n                       obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}))\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* nx\n  nx \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> nx'\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>a as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n       targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* nx \\<and>\n       valid_edge a \\<and>\n       as = as' @ a # as'' \\<and>\n       intra_kind (kind a) \\<and>\n       obs_intra (targetnode a)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {nx} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "proof(induct arbitrary:nx' rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})\n 2. \\<And>n'' as n' a n nx'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>nx'.\n           \\<lbrakk>n' \\<in> obs_intra n''\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            nx'\n            \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            n' \\<noteq> nx';\n            obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {n'};\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n'\\<in>set (sourcenodes as).\n               n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            as \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a as' as''.\n                                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                                a \\<and>\n                                targetnode\n                                 a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                                valid_edge a \\<and>\n                                as = as' @ a # as'' \\<and>\n                                intra_kind (kind a) \\<and>\n                                obs_intra (targetnode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {n'} \\<and>\n                                (\\<nexists>m.\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {m} \\<or>\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {});\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n' \\<noteq> nx';\n        obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {n'};\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes (a # as)).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          aa \\<and>\n                            targetnode\n                             aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            valid_edge aa \\<and>\n                            a # as = as' @ aa # as'' \\<and>\n                            intra_kind (kind aa) \\<and>\n                            obs_intra (targetnode aa)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n'} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  \\<lbrakk>n' \\<in> obs_intra n''\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?nx'\n   \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   n' \\<noteq> ?nx';\n   obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n   \\<forall>a\\<in>set as. intra_kind (kind a);\n   \\<forall>n'\\<in>set (sourcenodes as).\n      n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a as' as''.\n                       n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       a \\<and>\n                       targetnode\n                        a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                       valid_edge a \\<and>\n                       as = as' @ a # as'' \\<and>\n                       intra_kind (kind a) \\<and>\n                       obs_intra (targetnode a)\n                        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                       {n'} \\<and>\n                       (\\<nexists>m.\n                           obs_intra (sourcenode a)\n                            \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                           {m} \\<or>\n                           obs_intra (sourcenode a)\n                            \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                           {})\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> nx'\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n  \\<forall>n'\\<in>set (sourcenodes (a # as)).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  a # as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})\n 2. \\<And>n'' as n' a n nx'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>nx'.\n           \\<lbrakk>n' \\<in> obs_intra n''\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            nx'\n            \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            n' \\<noteq> nx';\n            obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {n'};\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n'\\<in>set (sourcenodes as).\n               n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            as \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a as' as''.\n                                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                                a \\<and>\n                                targetnode\n                                 a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                                valid_edge a \\<and>\n                                as = as' @ a # as'' \\<and>\n                                intra_kind (kind a) \\<and>\n                                obs_intra (targetnode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {n'} \\<and>\n                                (\\<nexists>m.\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {m} \\<or>\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {});\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n' \\<noteq> nx';\n        obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {n'};\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes (a # as)).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          aa \\<and>\n                            targetnode\n                             aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            valid_edge aa \\<and>\n                            a # as = as' @ aa # as'' \\<and>\n                            intra_kind (kind aa) \\<and>\n                            obs_intra (targetnode aa)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n'} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "note IH = \\<open>\\<And>nx'. \\<lbrakk>n' \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \n                       nx' \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; n' \\<noteq> nx'; \n                       obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n                       \\<forall>a\\<in>set as. intra_kind (kind a);\n                       \\<forall>n'\\<in>set (sourcenodes as). n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; as \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> \\<exists>a as' as''. n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and> targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n        valid_edge a \\<and> as = as'@a#as'' \\<and> intra_kind (kind a) \\<and>\n        obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'} \\<and>\n        (\\<not> (\\<exists>m. obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m} \\<or> \n           obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}))\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n' \\<in> obs_intra n''\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   ?nx'\n   \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   n' \\<noteq> ?nx';\n   obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n   \\<forall>a\\<in>set as. intra_kind (kind a);\n   \\<forall>n'\\<in>set (sourcenodes as).\n      n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a as' as''.\n                       n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       a \\<and>\n                       targetnode\n                        a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                       valid_edge a \\<and>\n                       as = as' @ a # as'' \\<and>\n                       intra_kind (kind a) \\<and>\n                       obs_intra (targetnode a)\n                        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                       {n'} \\<and>\n                       (\\<nexists>m.\n                           obs_intra (sourcenode a)\n                            \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                           {m} \\<or>\n                           obs_intra (sourcenode a)\n                            \\<lfloor>HRB_slice\nS\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                           {})\n\ngoal (2 subgoals):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})\n 2. \\<And>n'' as n' a n nx'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>nx'.\n           \\<lbrakk>n' \\<in> obs_intra n''\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            nx'\n            \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            n' \\<noteq> nx';\n            obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {n'};\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n'\\<in>set (sourcenodes as).\n               n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            as \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a as' as''.\n                                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                                a \\<and>\n                                targetnode\n                                 a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                                valid_edge a \\<and>\n                                as = as' @ a # as'' \\<and>\n                                intra_kind (kind a) \\<and>\n                                obs_intra (targetnode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {n'} \\<and>\n                                (\\<nexists>m.\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {m} \\<or>\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {});\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n' \\<noteq> nx';\n        obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {n'};\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes (a # as)).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          aa \\<and>\n                            targetnode\n                             aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            valid_edge aa \\<and>\n                            a # as = as' @ aa # as'' \\<and>\n                            intra_kind (kind aa) \\<and>\n                            obs_intra (targetnode aa)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n'} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "note more_than_one = \\<open>n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>n' \\<noteq> nx'\\<close>"], ["proof (state)\nthis:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> nx'\n\ngoal (2 subgoals):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})\n 2. \\<And>n'' as n' a n nx'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>nx'.\n           \\<lbrakk>n' \\<in> obs_intra n''\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            nx'\n            \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            n' \\<noteq> nx';\n            obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {n'};\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n'\\<in>set (sourcenodes as).\n               n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            as \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a as' as''.\n                                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                                a \\<and>\n                                targetnode\n                                 a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                                valid_edge a \\<and>\n                                as = as' @ a # as'' \\<and>\n                                intra_kind (kind a) \\<and>\n                                obs_intra (targetnode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {n'} \\<and>\n                                (\\<nexists>m.\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {m} \\<or>\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {});\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n' \\<noteq> nx';\n        obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {n'};\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes (a # as)).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          aa \\<and>\n                            targetnode\n                             aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            valid_edge aa \\<and>\n                            a # as = as' @ aa # as'' \\<and>\n                            intra_kind (kind aa) \\<and>\n                            obs_intra (targetnode aa)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n'} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "from \\<open>\\<forall>a\\<in>set (a#as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"\\<forall>a\\<in>set as. intra_kind (kind a)\" and \"intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a) &&& intra_kind (kind a)", "by simp_all"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n  intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})\n 2. \\<And>n'' as n' a n nx'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>nx'.\n           \\<lbrakk>n' \\<in> obs_intra n''\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            nx'\n            \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            n' \\<noteq> nx';\n            obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {n'};\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n'\\<in>set (sourcenodes as).\n               n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            as \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a as' as''.\n                                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                                a \\<and>\n                                targetnode\n                                 a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                                valid_edge a \\<and>\n                                as = as' @ a # as'' \\<and>\n                                intra_kind (kind a) \\<and>\n                                obs_intra (targetnode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {n'} \\<and>\n                                (\\<nexists>m.\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {m} \\<or>\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {});\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n' \\<noteq> nx';\n        obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {n'};\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes (a # as)).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          aa \\<and>\n                            targetnode\n                             aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            valid_edge aa \\<and>\n                            a # as = as' @ aa # as'' \\<and>\n                            intra_kind (kind aa) \\<and>\n                            obs_intra (targetnode aa)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n'} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "from \\<open>\\<forall>n'\\<in>set (sourcenodes (a#as)). n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n'\\<in>set (sourcenodes (a # as)).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have all:\"\\<forall>n'\\<in>set (sourcenodes as). n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>n'\\<in>set (sourcenodes (a # as)).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<in>set (sourcenodes as).\n       n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})\n 2. \\<And>n'' as n' a n nx'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>nx'.\n           \\<lbrakk>n' \\<in> obs_intra n''\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            nx'\n            \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            n' \\<noteq> nx';\n            obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {n'};\n            \\<forall>a\\<in>set as. intra_kind (kind a);\n            \\<forall>n'\\<in>set (sourcenodes as).\n               n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n            as \\<noteq> []\\<rbrakk>\n           \\<Longrightarrow> \\<exists>a as' as''.\n                                n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                                a \\<and>\n                                targetnode\n                                 a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                                valid_edge a \\<and>\n                                as = as' @ a # as'' \\<and>\n                                intra_kind (kind a) \\<and>\n                                obs_intra (targetnode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {n'} \\<and>\n                                (\\<nexists>m.\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {m} \\<or>\n                                    obs_intra (sourcenode a)\n                                     \\<lfloor>HRB_slice\n         S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                    {});\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n' \\<noteq> nx';\n        obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {n'};\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes (a # as)).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        a # as \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          aa \\<and>\n                            targetnode\n                             aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                            valid_edge aa \\<and>\n                            a # as = as' @ aa # as'' \\<and>\n                            intra_kind (kind aa) \\<and>\n                            obs_intra (targetnode aa)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n'} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode aa)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "proof(cases \"as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "with \\<open>n'' -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>* n'\n  as = []", "have [simp]:\"n'' = n'\""], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>* n'\n  as = []\n\ngoal (1 subgoal):\n 1. n'' = n'", "by(fastforce elim:path.cases)"], ["proof (state)\nthis:\n  n'' = n'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "from more_than_one \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> nx'\n  sourcenode a = n", "have \"\\<not> (\\<exists>m. obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m} \\<or> \n               obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {})\""], ["proof (prove)\nusing this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> nx'\n  sourcenode a = n\n\ngoal (1 subgoal):\n 1. \\<nexists>m.\n       obs_intra (sourcenode a)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {m} \\<or>\n       obs_intra (sourcenode a)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {}", "by auto"], ["proof (state)\nthis:\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})\n 2. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "with \\<open>targetnode a = n''\\<close> \\<open>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\\<close>\n        \\<open>sourcenode a = n\\<close> True \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = n''\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  sourcenode a = n\n  as = []\n  valid_edge a\n  intra_kind (kind a)\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}", "show ?thesis"], ["proof (prove)\nusing this:\n  targetnode a = n''\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  sourcenode a = n\n  as = []\n  valid_edge a\n  intra_kind (kind a)\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n\ngoal (1 subgoal):\n 1. \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "apply(rule_tac x=\"a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>targetnode a = n'';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n     sourcenode a = n; as = []; valid_edge a; intra_kind (kind a);\n     \\<nexists>m.\n        obs_intra (sourcenode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m} \\<or>\n        obs_intra (sourcenode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       a \\<and>\n                         targetnode\n                          a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge a \\<and>\n                         a # as = as' @ a # as'' \\<and>\n                         intra_kind (kind a) \\<and>\n                         obs_intra (targetnode a)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>targetnode a = n'';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n     sourcenode a = n; as = []; valid_edge a; intra_kind (kind a);\n     \\<nexists>m.\n        obs_intra (sourcenode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m} \\<or>\n        obs_intra (sourcenode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         n -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                      a \\<and>\n                         targetnode\n                          a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge a \\<and>\n                         a # as = [] @ a # as'' \\<and>\n                         intra_kind (kind a) \\<and>\n                         obs_intra (targetnode a)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>targetnode a = n'';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n     sourcenode a = n; as = []; valid_edge a; intra_kind (kind a);\n     \\<nexists>m.\n        obs_intra (sourcenode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m} \\<or>\n        obs_intra (sourcenode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n    \\<Longrightarrow> n -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n                      targetnode a -[]\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                      valid_edge a \\<and>\n                      a # as = [] @ [a] \\<and>\n                      intra_kind (kind a) \\<and>\n                      obs_intra (targetnode a)\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                      {n'} \\<and>\n                      (\\<nexists>m.\n                          obs_intra (sourcenode a)\n                           \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                          {m} \\<or>\n                          obs_intra (sourcenode a)\n                           \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                          {})", "by(auto intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>aa as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n     targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge aa \\<and>\n     a # as = as' @ aa # as'' \\<and>\n     intra_kind (kind aa) \\<and>\n     obs_intra (targetnode aa)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "from \\<open>n'' -as\\<rightarrow>* n'\\<close> \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'\""], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>* n'\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "with all"], ["proof (chain)\npicking this:\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'", "have subset:\"obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<subseteq> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>n'\\<in>set (sourcenodes as).\n     n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'\n\ngoal (1 subgoal):\n 1. obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n    \\<subseteq> obs_intra n''\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(rule path_obs_intra_subset)"], ["proof (state)\nthis:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "proof(cases \"obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})\n 2. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "case True"], ["proof (state)\nthis:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})\n 2. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "with \\<open>n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close>\n          \\<open>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\\<close> \\<open>intra_kind (kind a)\\<close> more_than_one"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  intra_kind (kind a)\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> nx'\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  intra_kind (kind a)\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> nx'\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "apply(rule_tac x=\"a\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'; valid_edge a;\n     sourcenode a = n; targetnode a = n'';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n     intra_kind (kind a);\n     n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     n' \\<noteq> nx';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       a \\<and>\n                         targetnode\n                          a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge a \\<and>\n                         a # as = as' @ a # as'' \\<and>\n                         intra_kind (kind a) \\<and>\n                         obs_intra (targetnode a)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'; valid_edge a;\n     sourcenode a = n; targetnode a = n'';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n     intra_kind (kind a);\n     n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     n' \\<noteq> nx';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         n -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                      a \\<and>\n                         targetnode\n                          a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge a \\<and>\n                         a # as = [] @ a # as'' \\<and>\n                         intra_kind (kind a) \\<and>\n                         obs_intra (targetnode a)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode a)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "apply(rule_tac x=\"as\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n'' -as\\<rightarrow>\\<^sub>\\<iota>* n'; valid_edge a;\n     sourcenode a = n; targetnode a = n'';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'};\n     intra_kind (kind a);\n     n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     nx' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     n' \\<noteq> nx';\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> n -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n                      targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                      valid_edge a \\<and>\n                      a # as = [] @ a # as \\<and>\n                      intra_kind (kind a) \\<and>\n                      obs_intra (targetnode a)\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                      {n'} \\<and>\n                      (\\<nexists>m.\n                          obs_intra (sourcenode a)\n                           \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                          {m} \\<or>\n                          obs_intra (sourcenode a)\n                           \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                          {})", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>aa as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n     targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge aa \\<and>\n     a # as = as' @ aa # as'' \\<and>\n     intra_kind (kind aa) \\<and>\n     obs_intra (targetnode aa)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "case False"], ["proof (state)\nthis:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "with subset"], ["proof (chain)\npicking this:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<subset> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n    \\<subset> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subset> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "with \\<open>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subset> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain ni where \"n' \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n          and \"ni \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"n' \\<noteq> ni\""], ["proof (prove)\nusing this:\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subset> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>ni.\n        \\<lbrakk>n' \\<in> obs_intra n''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         ni \\<in> obs_intra n''\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         n' \\<noteq> ni\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n' \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ni \\<in> obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' \\<noteq> ni\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "from IH[OF this \\<open>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\\<close> \n          \\<open>\\<forall>a\\<in>set as. intra_kind (kind a)\\<close> all \\<open>as \\<noteq> []\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>a as' as''.\n     n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n     targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge a \\<and>\n     as = as' @ a # as'' \\<and>\n     intra_kind (kind a) \\<and>\n     obs_intra (targetnode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})", "obtain a' as' as''\n          where \"n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\" \n          and hyps:\"targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\" \"valid_edge a'\" \"as = as'@a'#as''\" \n            \"intra_kind (kind a')\" \"obs_intra (targetnode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\"\n            \"\\<not> (\\<exists>m. obs_intra (sourcenode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m} \\<or> \n                                obs_intra (sourcenode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {})\""], ["proof (prove)\nusing this:\n  \\<exists>a as' as''.\n     n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n     targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge a \\<and>\n     as = as' @ a # as'' \\<and>\n     intra_kind (kind a) \\<and>\n     obs_intra (targetnode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal (1 subgoal):\n 1. (\\<And>as' a' as''.\n        \\<lbrakk>n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a';\n         targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'; valid_edge a';\n         as = as' @ a' # as''; intra_kind (kind a');\n         obs_intra (targetnode a')\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {n'};\n         \\<nexists>m.\n            obs_intra (sourcenode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {m} \\<or>\n            obs_intra (sourcenode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_edge a'\n  as = as' @ a' # as''\n  intra_kind (kind a')\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {n'}\n  \\<nexists>m.\n     obs_intra (sourcenode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "from \\<open>n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \n          \\<open>targetnode a = n''\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>intra_kind (kind a')\\<close>"], ["proof (chain)\npicking this:\n  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  intra_kind (kind a)\n  intra_kind (kind a')", "have \"n -a#as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\""], ["proof (prove)\nusing this:\n  n'' -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  intra_kind (kind a)\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "by(fastforce intro:path.Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n             \\<subseteq> obs_intra n''\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     obs_intra n' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     obs_intra n'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>aa as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       aa \\<and>\n                         targetnode\n                          aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge aa \\<and>\n                         a # as = as' @ aa # as'' \\<and>\n                         intra_kind (kind aa) \\<and>\n                         obs_intra (targetnode aa)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode aa)\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "with hyps"], ["proof (chain)\npicking this:\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_edge a'\n  as = as' @ a' # as''\n  intra_kind (kind a')\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {n'}\n  \\<nexists>m.\n     obs_intra (sourcenode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n  n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'", "show ?thesis"], ["proof (prove)\nusing this:\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n'\n  valid_edge a'\n  as = as' @ a' # as''\n  intra_kind (kind a')\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {n'}\n  \\<nexists>m.\n     obs_intra (sourcenode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n  n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\n\ngoal (1 subgoal):\n 1. \\<exists>aa as' as''.\n       n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n       targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n       valid_edge aa \\<and>\n       a # as = as' @ aa # as'' \\<and>\n       intra_kind (kind aa) \\<and>\n       obs_intra (targetnode aa)\n        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n       {n'} \\<and>\n       (\\<nexists>m.\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {m} \\<or>\n           obs_intra (sourcenode aa)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n           {})", "apply(rule_tac x=\"a'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n     valid_edge a'; as = as' @ a' # as''; intra_kind (kind a');\n     obs_intra (targetnode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'};\n     \\<nexists>m.\n        obs_intra (sourcenode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m} \\<or>\n        obs_intra (sourcenode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {};\n     n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       a' \\<and>\n                         targetnode\n                          a' -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge a' \\<and>\n                         a # as = as' @ a' # as'' \\<and>\n                         intra_kind (kind a') \\<and>\n                         obs_intra (targetnode a')\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode a')\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode a')\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "apply(rule_tac x=\"a#as'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n     valid_edge a'; as = as' @ a' # as''; intra_kind (kind a');\n     obs_intra (targetnode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'};\n     \\<nexists>m.\n        obs_intra (sourcenode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m} \\<or>\n        obs_intra (sourcenode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {};\n     n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         n -a #\n                            as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                       a' \\<and>\n                         targetnode\n                          a' -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                         valid_edge a' \\<and>\n                         a # as = (a # as') @ a' # as'' \\<and>\n                         intra_kind (kind a') \\<and>\n                         obs_intra (targetnode a')\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {n'} \\<and>\n                         (\\<nexists>m.\n                             obs_intra (sourcenode a')\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {m} \\<or>\n                             obs_intra (sourcenode a')\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                             {})", "apply(rule_tac x=\"as''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* n';\n     valid_edge a'; as = as' @ a' # as''; intra_kind (kind a');\n     obs_intra (targetnode a')\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'};\n     \\<nexists>m.\n        obs_intra (sourcenode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {m} \\<or>\n        obs_intra (sourcenode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {};\n     n -a # as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a'\\<rbrakk>\n    \\<Longrightarrow> n -a #\n                         as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                    a' \\<and>\n                      targetnode\n                       a' -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n                      valid_edge a' \\<and>\n                      a # as = (a # as') @ a' # as'' \\<and>\n                      intra_kind (kind a') \\<and>\n                      obs_intra (targetnode a')\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                      {n'} \\<and>\n                      (\\<nexists>m.\n                          obs_intra (sourcenode a')\n                           \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                          {m} \\<or>\n                          obs_intra (sourcenode a')\n                           \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                          {})", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>aa as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n     targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge aa \\<and>\n     a # as = as' @ aa # as'' \\<and>\n     intra_kind (kind aa) \\<and>\n     obs_intra (targetnode aa)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>aa as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n     targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge aa \\<and>\n     a # as = as' @ aa # as'' \\<and>\n     intra_kind (kind aa) \\<and>\n     obs_intra (targetnode aa)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>aa as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode aa \\<and>\n     targetnode aa -as''\\<rightarrow>\\<^sub>\\<iota>* n' \\<and>\n     valid_edge aa \\<and>\n     a # as = as' @ aa # as'' \\<and>\n     intra_kind (kind aa) \\<and>\n     obs_intra (targetnode aa)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {n'} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode aa)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal (1 subgoal):\n 1. \\<And>n nx'.\n       \\<lbrakk>valid_node n;\n        n \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        nx'\n        \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        n \\<noteq> nx';\n        obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n};\n        \\<forall>a\\<in>set []. intra_kind (kind a);\n        \\<forall>n'\\<in>set (sourcenodes []).\n           n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a as' as''.\n                            n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode\n                          a \\<and>\n                            targetnode\n                             a -as''\\<rightarrow>\\<^sub>\\<iota>* n \\<and>\n                            valid_edge a \\<and>\n                            [] = as' @ a # as'' \\<and>\n                            intra_kind (kind a) \\<and>\n                            obs_intra (targetnode a)\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                            {n} \\<and>\n                            (\\<nexists>m.\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {m} \\<or>\n                                obs_intra (sourcenode a)\n                                 \\<lfloor>HRB_slice\n     S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                                {})", "qed simp"], ["proof (state)\nthis:\n  \\<exists>a as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n     targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* nx \\<and>\n     valid_edge a \\<and>\n     as = as' @ a # as'' \\<and>\n     intra_kind (kind a) \\<and>\n     obs_intra (targetnode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {nx} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>a as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n     targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* nx \\<and>\n     valid_edge a \\<and>\n     as = as' @ a # as'' \\<and>\n     intra_kind (kind a) \\<and>\n     obs_intra (targetnode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {nx} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})", "obtain a as' as'' where \"valid_edge a\" and \"intra_kind (kind a)\"\n    and \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\"\n    and more_than_one:\"\\<not> (\\<exists>m. obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m} \\<or> \n                         obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {})\""], ["proof (prove)\nusing this:\n  \\<exists>a as' as''.\n     n -as'\\<rightarrow>\\<^sub>\\<iota>* sourcenode a \\<and>\n     targetnode a -as''\\<rightarrow>\\<^sub>\\<iota>* nx \\<and>\n     valid_edge a \\<and>\n     as = as' @ a # as'' \\<and>\n     intra_kind (kind a) \\<and>\n     obs_intra (targetnode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {nx} \\<and>\n     (\\<nexists>m.\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m} \\<or>\n         obs_intra (sourcenode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; intra_kind (kind a);\n         obs_intra (targetnode a)\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {nx};\n         \\<nexists>m.\n            obs_intra (sourcenode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {m} \\<or>\n            obs_intra (sourcenode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a\n  intra_kind (kind a)\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> sourcenode a\n           \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume \"\\<not> sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  \\<not> sourcenode a\n         \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> sourcenode a\n           \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "hence \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<not> sourcenode a\n         \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> sourcenode a\n           \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. \\<not> sourcenode a\n           \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with more_than_one"], ["proof (chain)\npicking this:\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<subseteq> \n        obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n    \\<subseteq> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_subset)"], ["proof (state)\nthis:\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "with \\<open>obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. nx \\<in> obs_intra (sourcenode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "with more_than_one"], ["proof (chain)\npicking this:\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain m \n    where \"m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"nx \\<noteq> m\""], ["proof (prove)\nusing this:\n  \\<nexists>m.\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {m} \\<or>\n     obs_intra (sourcenode a)\n      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> obs_intra (sourcenode a)\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         nx \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "from \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. valid_node m", "by(fastforce dest:in_obs_intra_valid)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "from \\<open>obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}", "have \"valid_node nx\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n\ngoal (1 subgoal):\n 1. valid_node nx", "by(fastforce dest:in_obs_intra_valid)"], ["proof (state)\nthis:\n  valid_node nx\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>m.\n                obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                {m}) \\<or>\n            obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n            {}) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"m postdominates (sourcenode a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m postdominates sourcenode a \\<Longrightarrow> False\n 2. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  m postdominates sourcenode a\n\ngoal (2 subgoals):\n 1. m postdominates sourcenode a \\<Longrightarrow> False\n 2. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "with \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m postdominates sourcenode a", "have \"m postdominates nx\""], ["proof (prove)\nusing this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. m postdominates nx", "by(fastforce intro:postdominate_inner_path_targetnode elim:obs_intraE)"], ["proof (state)\nthis:\n  m postdominates nx\n\ngoal (2 subgoals):\n 1. m postdominates sourcenode a \\<Longrightarrow> False\n 2. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "with \\<open>nx \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  nx \\<noteq> m\n  m postdominates nx", "have \"\\<not> nx postdominates m\""], ["proof (prove)\nusing this:\n  nx \\<noteq> m\n  m postdominates nx\n\ngoal (1 subgoal):\n 1. \\<not> nx postdominates m", "by(fastforce dest:postdominate_antisym)"], ["proof (state)\nthis:\n  \\<not> nx postdominates m\n\ngoal (2 subgoals):\n 1. m postdominates sourcenode a \\<Longrightarrow> False\n 2. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "with \\<open>valid_node nx\\<close> \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node nx\n  valid_node m\n  \\<not> nx postdominates m", "obtain asx pex where \"m -asx\\<rightarrow>\\<^sub>\\<iota>* pex\"\n      and \"method_exit pex\" and \"nx \\<notin> set(sourcenodes asx)\""], ["proof (prove)\nusing this:\n  valid_node nx\n  valid_node m\n  \\<not> nx postdominates m\n\ngoal (1 subgoal):\n 1. (\\<And>asx pex.\n        \\<lbrakk>m -asx\\<rightarrow>\\<^sub>\\<iota>* pex; method_exit pex;\n         nx \\<notin> set (sourcenodes asx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:postdominate_def)"], ["proof (state)\nthis:\n  m -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n  nx \\<notin> set (sourcenodes asx)\n\ngoal (2 subgoals):\n 1. m postdominates sourcenode a \\<Longrightarrow> False\n 2. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "have \"\\<not> nx postdominates (sourcenode a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> nx postdominates sourcenode a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. nx postdominates sourcenode a \\<Longrightarrow> False", "assume \"nx postdominates sourcenode a\""], ["proof (state)\nthis:\n  nx postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. nx postdominates sourcenode a \\<Longrightarrow> False", "from \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain asx' where \"sourcenode a -asx'\\<rightarrow>\\<^sub>\\<iota>* m\" and \"nx \\<notin> set(sourcenodes asx')\""], ["proof (prove)\nusing this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>sourcenode a -asx'\\<rightarrow>\\<^sub>\\<iota>* m;\n         nx \\<notin> set (sourcenodes asx')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:obs_intraE)"], ["proof (state)\nthis:\n  sourcenode a -asx'\\<rightarrow>\\<^sub>\\<iota>* m\n  nx \\<notin> set (sourcenodes asx')\n\ngoal (1 subgoal):\n 1. nx postdominates sourcenode a \\<Longrightarrow> False", "with \\<open>m -asx\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  m -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  sourcenode a -asx'\\<rightarrow>\\<^sub>\\<iota>* m\n  nx \\<notin> set (sourcenodes asx')", "have \"sourcenode a -asx'@asx\\<rightarrow>\\<^sub>\\<iota>* pex\""], ["proof (prove)\nusing this:\n  m -asx\\<rightarrow>\\<^sub>\\<iota>* pex\n  sourcenode a -asx'\\<rightarrow>\\<^sub>\\<iota>* m\n  nx \\<notin> set (sourcenodes asx')\n\ngoal (1 subgoal):\n 1. sourcenode a -asx' @ asx\\<rightarrow>\\<^sub>\\<iota>* pex", "by(fastforce intro:path_Append simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -asx' @ asx\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. nx postdominates sourcenode a \\<Longrightarrow> False", "with \\<open>nx \\<notin> set(sourcenodes asx)\\<close> \\<open>nx \\<notin> set(sourcenodes asx')\\<close> \n        \\<open>nx postdominates sourcenode a\\<close> \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  nx \\<notin> set (sourcenodes asx)\n  nx \\<notin> set (sourcenodes asx')\n  nx postdominates sourcenode a\n  method_exit pex\n  sourcenode a -asx' @ asx\\<rightarrow>\\<^sub>\\<iota>* pex", "show False"], ["proof (prove)\nusing this:\n  nx \\<notin> set (sourcenodes asx)\n  nx \\<notin> set (sourcenodes asx')\n  nx postdominates sourcenode a\n  method_exit pex\n  sourcenode a -asx' @ asx\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:sourcenodes_def postdominate_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> nx postdominates sourcenode a\n\ngoal (2 subgoals):\n 1. m postdominates sourcenode a \\<Longrightarrow> False\n 2. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"method_exit nx\")"], ["proof (state)\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  method_exit nx\n\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "from \\<open>m postdominates nx\\<close>"], ["proof (chain)\npicking this:\n  m postdominates nx", "obtain xs where \"nx -xs\\<rightarrow>\\<^sub>\\<iota>* m\""], ["proof (prove)\nusing this:\n  m postdominates nx\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        nx -xs\\<rightarrow>\\<^sub>\\<iota>* m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule postdominate_implies_inner_path)"], ["proof (state)\nthis:\n  nx -xs\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "with True"], ["proof (chain)\npicking this:\n  method_exit nx\n  nx -xs\\<rightarrow>\\<^sub>\\<iota>* m", "have \"nx = m\""], ["proof (prove)\nusing this:\n  method_exit nx\n  nx -xs\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. nx = m", "by(fastforce dest!:method_exit_inner_path simp:intra_path_def)"], ["proof (state)\nthis:\n  nx = m\n\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>nx \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  nx \\<noteq> m\n  nx = m", "show False"], ["proof (prove)\nusing this:\n  nx \\<noteq> m\n  nx = m\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> method_exit nx\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit nx", "have \"nx postdominates sourcenode a\""], ["proof (prove)\nusing this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit nx\n\ngoal (1 subgoal):\n 1. nx postdominates sourcenode a", "by(rule obs_intra_postdominate)"], ["proof (state)\nthis:\n  nx postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>\\<not> nx postdominates (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> nx postdominates sourcenode a\n  nx postdominates sourcenode a", "show False"], ["proof (prove)\nusing this:\n  \\<not> nx postdominates sourcenode a\n  nx postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> m postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. \\<not> m postdominates sourcenode a \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"method_exit m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. method_exit m \\<Longrightarrow> False\n 2. \\<not> method_exit m \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  method_exit m\n\ngoal (2 subgoals):\n 1. method_exit m \\<Longrightarrow> False\n 2. \\<not> method_exit m \\<Longrightarrow> False", "from \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain xs where \"sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\" and \"nx \\<notin> set(sourcenodes xs)\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m;\n         nx \\<notin> set (sourcenodes xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:obs_intraE)"], ["proof (state)\nthis:\n  sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\n  nx \\<notin> set (sourcenodes xs)\n\ngoal (2 subgoals):\n 1. method_exit m \\<Longrightarrow> False\n 2. \\<not> method_exit m \\<Longrightarrow> False", "obtain x' xs' where [simp]:\"xs = x'#xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\n  xs = []", "have [simp]:\"sourcenode a = m\""], ["proof (prove)\nusing this:\n  sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\n  xs = []\n\ngoal (1 subgoal):\n 1. sourcenode a = m", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a = m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a = m", "have \"m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(metis obs_intraE)"], ["proof (state)\nthis:\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\""], ["proof (prove)\nusing this:\n  valid_node m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "by(rule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>nx \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "have False"], ["proof (prove)\nusing this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>x' xs'. xs = x' # xs' \\<Longrightarrow> thesis;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed blast"], ["proof (state)\nthis:\n  xs = x' # xs'\n\ngoal (2 subgoals):\n 1. method_exit m \\<Longrightarrow> False\n 2. \\<not> method_exit m \\<Longrightarrow> False", "from \\<open>sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m", "have \"sourcenode a = sourcenode x'\" \n        and \"valid_edge x'\" and \"targetnode x' -xs'\\<rightarrow>\\<^sub>\\<iota>* m\"\n        and \"intra_kind (kind x')\""], ["proof (prove)\nusing this:\n  sourcenode a -xs\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. (sourcenode a = sourcenode x' &&& valid_edge x') &&&\n    targetnode x' -xs'\\<rightarrow>\\<^sub>\\<iota>* m &&&\n    intra_kind (kind x')", "by(auto elim:path_split_Cons simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a = sourcenode x'\n  valid_edge x'\n  targetnode x' -xs'\\<rightarrow>\\<^sub>\\<iota>* m\n  intra_kind (kind x')\n\ngoal (2 subgoals):\n 1. method_exit m \\<Longrightarrow> False\n 2. \\<not> method_exit m \\<Longrightarrow> False", "from \\<open>targetnode x' -xs'\\<rightarrow>\\<^sub>\\<iota>* m\\<close> \\<open>nx \\<notin> set(sourcenodes xs)\\<close> \\<open>valid_edge x'\\<close> \n        \\<open>valid_node m\\<close> True"], ["proof (chain)\npicking this:\n  targetnode x' -xs'\\<rightarrow>\\<^sub>\\<iota>* m\n  nx \\<notin> set (sourcenodes xs)\n  valid_edge x'\n  valid_node m\n  method_exit m", "have \"\\<not> nx postdominates (targetnode x')\""], ["proof (prove)\nusing this:\n  targetnode x' -xs'\\<rightarrow>\\<^sub>\\<iota>* m\n  nx \\<notin> set (sourcenodes xs)\n  valid_edge x'\n  valid_node m\n  method_exit m\n\ngoal (1 subgoal):\n 1. \\<not> nx postdominates targetnode x'", "by(fastforce simp:postdominate_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<not> nx postdominates targetnode x'\n\ngoal (2 subgoals):\n 1. method_exit m \\<Longrightarrow> False\n 2. \\<not> method_exit m \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"method_exit nx\")"], ["proof (state)\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  method_exit nx\n\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "from \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"get_proc m = get_proc nx\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. get_proc m = get_proc nx", "by(fastforce elim:obs_intraE dest:intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc m = get_proc nx\n\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>method_exit m\\<close> \\<open>method_exit nx\\<close>"], ["proof (chain)\npicking this:\n  method_exit m\n  method_exit nx\n  get_proc m = get_proc nx", "have \"m = nx\""], ["proof (prove)\nusing this:\n  method_exit m\n  method_exit nx\n  get_proc m = get_proc nx\n\ngoal (1 subgoal):\n 1. m = nx", "by(rule method_exit_unique)"], ["proof (state)\nthis:\n  m = nx\n\ngoal (2 subgoals):\n 1. method_exit nx \\<Longrightarrow> False\n 2. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>nx \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  nx \\<noteq> m\n  m = nx", "show False"], ["proof (prove)\nusing this:\n  nx \\<noteq> m\n  m = nx\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> method_exit nx\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n  \\<not> method_exit nx", "have \"nx postdominates (targetnode a)\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n  \\<not> method_exit nx\n\ngoal (1 subgoal):\n 1. nx postdominates targetnode a", "by(fastforce intro:obs_intra_postdominate)"], ["proof (state)\nthis:\n  nx postdominates targetnode a\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "from \\<open>obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}", "obtain ys where \"targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx\" \n          and \"\\<forall>nx' \\<in> set(sourcenodes ys). nx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n          and \"nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {nx}\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx;\n         \\<forall>nx'\\<in>set (sourcenodes ys).\n            nx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:obs_intraE)"], ["proof (state)\nthis:\n  targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx\n  \\<forall>nx'\\<in>set (sourcenodes ys).\n     nx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "hence \"nx \\<notin> set(sourcenodes ys)\""], ["proof (prove)\nusing this:\n  targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx\n  \\<forall>nx'\\<in>set (sourcenodes ys).\n     nx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. nx \\<notin> set (sourcenodes ys)", "by fastforce"], ["proof (state)\nthis:\n  nx \\<notin> set (sourcenodes ys)\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "have \"sourcenode a \\<noteq> nx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> nx", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a = nx \\<Longrightarrow> False", "assume \"sourcenode a = nx\""], ["proof (state)\nthis:\n  sourcenode a = nx\n\ngoal (1 subgoal):\n 1. sourcenode a = nx \\<Longrightarrow> False", "from \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(erule obs_intraE)"], ["proof (state)\nthis:\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a = nx \\<Longrightarrow> False", "with \\<open>valid_node nx\\<close>"], ["proof (chain)\npicking this:\n  valid_node nx\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\""], ["proof (prove)\nusing this:\n  valid_node nx\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}", "by -(erule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\n\ngoal (1 subgoal):\n 1. sourcenode a = nx \\<Longrightarrow> False", "with \\<open>sourcenode a = nx\\<close> \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n            \\<open>nx \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = nx\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}", "show False"], ["proof (prove)\nusing this:\n  sourcenode a = nx\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n  obs_intra nx \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {nx}\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> nx\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>nx \\<notin> set(sourcenodes ys)\\<close>"], ["proof (chain)\npicking this:\n  nx \\<notin> set (sourcenodes ys)\n  sourcenode a \\<noteq> nx", "have \"nx \\<notin> set(sourcenodes (a#ys))\""], ["proof (prove)\nusing this:\n  nx \\<notin> set (sourcenodes ys)\n  sourcenode a \\<noteq> nx\n\ngoal (1 subgoal):\n 1. nx \\<notin> set (sourcenodes (a # ys))", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  nx \\<notin> set (sourcenodes (a # ys))\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx\n  intra_kind (kind a)", "have \"sourcenode a -a#ys\\<rightarrow>\\<^sub>\\<iota>* nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -ys\\<rightarrow>\\<^sub>\\<iota>* nx\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. sourcenode a -a # ys\\<rightarrow>\\<^sub>\\<iota>* nx", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a # ys\\<rightarrow>\\<^sub>\\<iota>* nx\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "from \\<open>sourcenode a -a#ys\\<rightarrow>\\<^sub>\\<iota>* nx\\<close> \\<open>nx \\<notin> set(sourcenodes (a#ys))\\<close>\n          \\<open>intra_kind (kind a)\\<close> \\<open>nx postdominates (targetnode a)\\<close>\n          \\<open>valid_edge x'\\<close> \\<open>intra_kind (kind x')\\<close> \\<open>\\<not> nx postdominates (targetnode x')\\<close>\n          \\<open>sourcenode a = sourcenode x'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -a # ys\\<rightarrow>\\<^sub>\\<iota>* nx\n  nx \\<notin> set (sourcenodes (a # ys))\n  intra_kind (kind a)\n  nx postdominates targetnode a\n  valid_edge x'\n  intra_kind (kind x')\n  \\<not> nx postdominates targetnode x'\n  sourcenode a = sourcenode x'", "have \"(sourcenode a) controls nx\""], ["proof (prove)\nusing this:\n  sourcenode a -a # ys\\<rightarrow>\\<^sub>\\<iota>* nx\n  nx \\<notin> set (sourcenodes (a # ys))\n  intra_kind (kind a)\n  nx postdominates targetnode a\n  valid_edge x'\n  intra_kind (kind x')\n  \\<not> nx postdominates targetnode x'\n  sourcenode a = sourcenode x'\n\ngoal (1 subgoal):\n 1. sourcenode a controls nx", "by(fastforce simp:control_dependence_def)"], ["proof (state)\nthis:\n  sourcenode a controls nx\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "hence \"CFG_node (sourcenode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node nx\""], ["proof (prove)\nusing this:\n  sourcenode a controls nx\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node nx", "by(fastforce intro:SDG_cdep_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node nx\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node nx", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) \\<longrightarrow>\\<^bsub>cd\\<^esub> CFG_node nx\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce elim!:combine_SDG_slices.cases\n                       dest:SDG_edge_sum_SDG_edge cdep_slice1 cdep_slice2 \n                      intro:combine_SDG_slices.intros\n                       simp:HRB_slice_def SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. \\<not> method_exit nx \\<Longrightarrow> False", "with \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>nx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>nx \\<noteq> m\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}", "show False"], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nx \\<noteq> m\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> method_exit m \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> method_exit m \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> method_exit m\n\ngoal (1 subgoal):\n 1. \\<not> method_exit m \\<Longrightarrow> False", "with \\<open>m \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit m", "have \"m postdominates (sourcenode a)\""], ["proof (prove)\nusing this:\n  m \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit m\n\ngoal (1 subgoal):\n 1. m postdominates sourcenode a", "by(rule obs_intra_postdominate)"], ["proof (state)\nthis:\n  m postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. \\<not> method_exit m \\<Longrightarrow> False", "with \\<open>\\<not> m postdominates (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> m postdominates sourcenode a\n  m postdominates sourcenode a", "show False"], ["proof (prove)\nusing this:\n  \\<not> m postdominates sourcenode a\n  m postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_intra_finite:\"valid_node n \\<Longrightarrow> finite (obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node n \\<Longrightarrow>\n    finite (obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(fastforce dest:obs_intra_singleton_disj[of _ S])"], ["", "lemma obs_intra_singleton:\"valid_node n \\<Longrightarrow> card (obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node n \\<Longrightarrow>\n    card (obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n    \\<le> 1", "by(fastforce dest:obs_intra_singleton_disj[of _ S])"], ["", "lemma obs_intra_singleton_element:\n  \"m \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> obs_intra n\n             \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> obs_intra n\n             \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "apply(frule in_obs_intra_valid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> obs_intra n\n                      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     valid_node n\\<rbrakk>\n    \\<Longrightarrow> obs_intra n\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                      {m}", "apply(drule obs_intra_singleton_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> obs_intra n\n                      \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     (\\<exists>m.\n         obs_intra n \\<lfloor>HRB_slice ?S2\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         {m}) \\<or>\n     obs_intra n \\<lfloor>HRB_slice ?S2\\<rfloor>\\<^bsub>CFG\\<^esub> =\n     {}\\<rbrakk>\n    \\<Longrightarrow> obs_intra n\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                      {m}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma obs_intra_the_element: \n  \"m \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow> (THE m. m \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> obs_intra n\n             \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    (THE m.\n        m \\<in> obs_intra n\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) =\n    m", "by(fastforce dest:obs_intra_singleton_element)"], ["", "lemma obs_singleton_element:\n  assumes \"ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<forall>n \\<in> set (tl ns). return_node n\"\n  shows \"obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "from \\<open>ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>\\<forall>n \\<in> set (tl ns). return_node n\\<close>"], ["proof (chain)\npicking this:\n  ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ns)) return_node", "obtain nsx n nsx' n' where \"ns = nsx@n#nsx'\" and \"ms = n'#nsx'\"\n    and split:\"n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    \"\\<forall>nx \\<in> set nsx'. \\<exists>nx'. call_of_return_node nx nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    \"\\<forall>xs x xs'. nsx = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n    \\<longrightarrow> (\\<exists>x'' \\<in> set (xs'@[n]). \\<exists>nx. call_of_return_node x'' nx \\<and> \n                                   nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ns)) return_node\n\ngoal (1 subgoal):\n 1. (\\<And>nsx n nsx' n'.\n        \\<lbrakk>ns = nsx @ n # nsx'; ms = n' # nsx';\n         n' \\<in> obs_intra n\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>nx\\<in>set nsx'.\n            \\<exists>nx'.\n               call_of_return_node nx nx' \\<and>\n               nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>xs x xs'.\n            nsx = xs @ x # xs' \\<and>\n            obs_intra x\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (xs' @ [n]).\n                \\<exists>nx.\n                   call_of_return_node x'' nx \\<and>\n                   nx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  ns = nsx @ n # nsx'\n  ms = n' # nsx'\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set nsx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     nsx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [n]).\n         \\<exists>nx.\n            call_of_return_node x'' nx \\<and>\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "from \\<open>n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\""], ["proof (prove)\nusing this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}", "by(fastforce intro!:obs_intra_singleton_element)"], ["proof (state)\nthis:\n  obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "{"], ["proof (state)\nthis:\n  obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "assume \"xs \\<noteq> ms\" and \"xs \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  xs \\<noteq> ms\n  xs \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "from \\<open>xs \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>\\<forall>n \\<in> set (tl ns). return_node n\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ns)) return_node", "obtain zs z zs' z' where \"ns = zs@z#zs'\" and \"xs = z'#zs'\"\n      and \"z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n      and \"\\<forall>z' \\<in> set zs'. \\<exists>nx'. call_of_return_node z' nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n      and \"\\<forall>xs x xs'. zs = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n      \\<longrightarrow> (\\<exists>x'' \\<in> set (xs'@[z]). \\<exists>nx. call_of_return_node x'' nx \\<and> \n                                     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  xs \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ns)) return_node\n\ngoal (1 subgoal):\n 1. (\\<And>zs z zs' z'.\n        \\<lbrakk>ns = zs @ z # zs'; xs = z' # zs';\n         z' \\<in> obs_intra z\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>z'\\<in>set zs'.\n            \\<exists>nx'.\n               call_of_return_node z' nx' \\<and>\n               nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>xs x xs'.\n            zs = xs @ x # xs' \\<and>\n            obs_intra x\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (xs' @ [z]).\n                \\<exists>nx.\n                   call_of_return_node x'' nx \\<and>\n                   nx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  ns = zs @ z # zs'\n  xs = z' # zs'\n  z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>z'\\<in>set zs'.\n     \\<exists>nx'.\n        call_of_return_node z' nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     zs = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [z]).\n         \\<exists>nx.\n            call_of_return_node x'' nx \\<and>\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "with \\<open>ns = nsx@n#nsx'\\<close> split"], ["proof (chain)\npicking this:\n  ns = nsx @ n # nsx'\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set nsx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     nsx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [n]).\n         \\<exists>nx.\n            call_of_return_node x'' nx \\<and>\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  ns = zs @ z # zs'\n  xs = z' # zs'\n  z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>z'\\<in>set zs'.\n     \\<exists>nx'.\n        call_of_return_node z' nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     zs = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [z]).\n         \\<exists>nx.\n            call_of_return_node x'' nx \\<and>\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"nsx = zs \\<and> n = z \\<and> nsx' = zs'\""], ["proof (prove)\nusing this:\n  ns = nsx @ n # nsx'\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set nsx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     nsx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [n]).\n         \\<exists>nx.\n            call_of_return_node x'' nx \\<and>\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  ns = zs @ z # zs'\n  xs = z' # zs'\n  z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>z'\\<in>set zs'.\n     \\<exists>nx'.\n        call_of_return_node z' nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     zs = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [z]).\n         \\<exists>nx.\n            call_of_return_node x'' nx \\<and>\n            nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. nsx = zs \\<and> n = z \\<and> nsx' = zs'", "by -(rule obs_split_det[of _ _ _ _ _ _ \"\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"],fastforce+)"], ["proof (state)\nthis:\n  nsx = zs \\<and> n = z \\<and> nsx' = zs'\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "with \\<open>obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\\<close> \\<open>z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nsx = zs \\<and> n = z \\<and> nsx' = zs'", "have \"z' = n'\""], ["proof (prove)\nusing this:\n  obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {n'}\n  z' \\<in> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  nsx = zs \\<and> n = z \\<and> nsx' = zs'\n\ngoal (1 subgoal):\n 1. z' = n'", "by simp"], ["proof (state)\nthis:\n  z' = n'\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "with \\<open>xs \\<noteq> ms\\<close> \\<open>ms = n'#nsx'\\<close> \\<open>xs = z'#zs'\\<close> \\<open>nsx = zs \\<and> n = z \\<and> nsx' = zs'\\<close>"], ["proof (chain)\npicking this:\n  xs \\<noteq> ms\n  ms = n' # nsx'\n  xs = z' # zs'\n  nsx = zs \\<and> n = z \\<and> nsx' = zs'\n  z' = n'", "have False"], ["proof (prove)\nusing this:\n  xs \\<noteq> ms\n  ms = n' # nsx'\n  xs = z' # zs'\n  nsx = zs \\<and> n = z \\<and> nsx' = zs'\n  z' = n'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xs2 \\<noteq> ms;\n   ?xs2\n   \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "with \\<open>ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<lbrakk>?xs2 \\<noteq> ms;\n   ?xs2\n   \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<lbrakk>?xs2 \\<noteq> ms;\n   ?xs2\n   \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}", "by fastforce"], ["proof (state)\nthis:\n  obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_finite:\"\\<forall>n \\<in> set (tl ns). return_node n \n  \\<Longrightarrow> finite (obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (tl ns)) return_node \\<Longrightarrow>\n    finite (obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(cases \"obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\",auto dest:obs_singleton_element[of _ _ S])"], ["", "lemma obs_singleton:\"\\<forall>n \\<in> set (tl ns). return_node n \n  \\<Longrightarrow> card (obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (tl ns)) return_node \\<Longrightarrow>\n    card (obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<le> 1", "by(cases \"obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\",auto dest:obs_singleton_element[of _ _ S])"], ["", "lemma obs_the_element: \n  \"\\<lbrakk>ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \\<forall>n \\<in> set (tl ns). return_node n\\<rbrakk> \n  \\<Longrightarrow> (THE ms. ms \\<in> obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) = ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ms \\<in> obs ns\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     Ball (set (tl ns)) return_node\\<rbrakk>\n    \\<Longrightarrow> (THE ms.\n                          ms \\<in> obs ns\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub>) =\n                      ms", "by(cases \"obs ns \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\",auto dest:obs_singleton_element[of _ _ S])"], ["", "end"], ["", "end"]]}