{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/WeakSimulation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma call_node_notin_slice_return_node_neither:\n  assumes \"call_of_return_node n n'\" and \"n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma edge_obs_intra_slice_eq:\nassumes \"valid_edge a\" and \"intra_kind (kind a)\" and \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n         obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma intra_edge_obs_slice:\n  assumes \"ms \\<noteq> []\" and \"ms'' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" \n  and \"intra_kind (kind a)\" \n  and disj:\"(\\<exists>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> \n                               m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"hd ms = sourcenode a\" and \"ms' = targetnode a#tl ms\" \n  and \"\\<forall>n \\<in> set (tl ms'). return_node n\"\n  shows \"ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma silent_move_valid_nodes:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); \\<forall>m \\<in> set ms'. valid_node m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m \\<in> set ms. valid_node m\"", "lemma silent_move_return_node:\n  \"S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow> \\<forall>m \\<in> set (tl ms'). return_node m\"", "lemma silent_move_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\"", "lemma silent_move_obs_slice:\n  \"\\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \n    \\<forall>n \\<in> set (tl ms'). return_node n\\<rbrakk>\n  \\<Longrightarrow> msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"", "lemma silent_move_empty_obs_slice:\n  assumes \"S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\" and \"obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\"\n  shows \"obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\"", "lemma silent_moves_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\"", "lemma silent_moves_Append:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s''); S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"", "lemma silent_moves_split:\n  assumes \"S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"\n  obtains ms'' s'' where \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n  and \"S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"", "lemma valid_nodes_silent_moves:\n  \"\\<lbrakk>S,f\\<turnstile> (ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); \\<forall>m \\<in> set ms. valid_node m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m \\<in> set ms'. valid_node m\"", "lemma return_nodes_silent_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); \\<forall>m \\<in> set (tl ms). return_node m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m \\<in> set (tl ms'). return_node m\"", "lemma silent_moves_intra_path:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); \\<forall>a \\<in> set as. intra_kind(kind a)\\<rbrakk>\n  \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\"", "lemma silent_moves_nodestack_notempty: \n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); ms \\<noteq> []\\<rbrakk> \\<Longrightarrow> ms' \\<noteq> []\"", "lemma silent_moves_obs_slice:\n  \"\\<lbrakk>S,kind \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \n  \\<forall>n \\<in> set (tl ms'). return_node n\\<rbrakk>\n  \\<Longrightarrow> mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and> (\\<forall>n \\<in> set (tl ms). return_node n)\"", "lemma silent_moves_empty_obs_slice:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<rbrakk>\n  \\<Longrightarrow> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\"", "lemma silent_moves_preds_transfers:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"\n  shows \"preds (map f as) s\" and \"transfers (map f as) s = s'\"", "lemma silent_moves_intra_path_obs:\n  assumes \"m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"length s = length (m#msx')\"\n  and \"\\<forall>m \\<in> set msx'. return_node m\"\n  obtains as' where \"S,slice_kind S \\<turnstile> (m#msx',s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\"", "lemma silent_moves_intra_path_no_obs:\n  assumes \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" and \"method_exit m'\"\n  and \"get_proc m = get_proc m'\" and \"valid_node m\" and \"length s = length (m#msx')\"\n  and \"\\<forall>m \\<in> set msx'. return_node m\"\n  obtains as where \"S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\"", "lemma silent_moves_vpa_path:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" \n  and \"ms = targetnodes rs\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\"\n  shows \"m -as\\<rightarrow>* m'\" and \"valid_path_aux cs as\"", "lemma observable_move_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\"", "lemma observable_moves_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\"", "lemma observable_move_notempty:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s'); as = []\\<rbrakk> \\<Longrightarrow> False\"", "lemma silent_move_observable_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow> (ms',s'); S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a#as\\<Rightarrow> (ms',s')\"", "lemma silent_append_observable_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s''); S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow> (ms',s')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow> (ms',s')\"", "lemma observable_moves_preds_transfers:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\"\n  shows \"preds (map f as) s\" and \"transfers (map f as) s = s'\"", "lemma observable_move_vpa_path:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms,s) -a\\<rightarrow> (m'#ms',s'); valid_node m; \n    \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); ms = targetnodes rs;\n    valid_return_list rs m; length rs = length cs\\<rbrakk> \\<Longrightarrow> valid_path_aux cs [a]\"", "lemma rvE:\n  assumes rv:\"V \\<in> rv S n\"\n  obtains as n' where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"\n  and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n  and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n    \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\"", "lemma rv_parent_node:\n  \"parent_node n = parent_node n' \\<Longrightarrow> rv (S::'node SDG_node set) n = rv S n'\"", "lemma obs_intra_empty_rv_empty:\n  assumes \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" shows \"rv S (CFG_node m) = {}\"", "lemma eq_obs_intra_in_rv:\n  assumes obs_eq:\"obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n                  obs_intra (parent_node n') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"x \\<in> rv S n\" shows \"x \\<in> rv S n'\"", "lemma closed_eq_obs_eq_rvs:\n  fixes S :: \"'node SDG_node set\"\n  assumes obs_eq:\"obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n  obs_intra (parent_node n') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"rv S n = rv S n'\"", "lemma closed_eq_obs_eq_rvs':\n  fixes S :: \"'node SDG_node set\"\n  assumes obs_eq:\"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs_intra m' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"rv S (CFG_node m) = rv S (CFG_node m')\"", "lemma rv_branching_edges_slice_kinds_False:\n  assumes \"valid_edge a\" and \"valid_edge ax\" \n  and \"sourcenode a = sourcenode ax\" and \"targetnode a \\<noteq> targetnode ax\"\n  and \"intra_kind (kind a)\" and \"intra_kind (kind ax)\"\n  and \"preds (slice_kinds S (a#as)) s\" \n  and \"preds (slice_kinds S (ax#asx)) s'\"\n  and \"length s = length s'\" and \"snd (hd s) = snd (hd s')\"\n  and \"\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\"\n  shows False", "lemma rv_edge_slice_kinds:\n  assumes \"valid_edge a\" and \"intra_kind (kind a)\"\n  and \"\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\"\n  and \"preds (slice_kinds S (a#as)) s\" and \"preds (slice_kinds S (a#asx)) s'\"\n  shows \"\\<forall>V\\<in>rv S (CFG_node (targetnode a)). \n  state_val (transfer (slice_kind S a) s) V = \n  state_val (transfer (slice_kind S a) s') V\"", "lemma WS_silent_move:\n  assumes \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\" and \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  shows \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"", "lemma WS_silent_moves:\n  \"\\<lbrakk>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1'); ((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<rbrakk>\n  \\<Longrightarrow> ((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"", "lemma WS_observable_move:\n  assumes \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  and \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\" and \"s\\<^sub>1' \\<noteq> []\"\n  obtains as where \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\"\n  and \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\"", "lemma WS_weak_sim:\n  assumes \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" \n  and \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (ms\\<^sub>1',s\\<^sub>1')\" and \"s\\<^sub>1' \\<noteq> []\"\n  obtains as' where \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)) \\<in> WS S\"\n  and \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'@[last as]\\<Rightarrow> \n                          (ms\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)\"", "theorem WS_is_weak_sim:\"is_weak_sim (WS S) S\""], "translations": [["", "lemma call_node_notin_slice_return_node_neither:\n  assumes \"call_of_return_node n n'\" and \"n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>call_of_return_node n n'\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node n n'", "obtain a a' where \"return_node n\"\n    and \"valid_edge a\" and \"n' = sourcenode a\"\n    and \"valid_edge a'\" and \"a' \\<in> get_return_edges a\" \n    and \"n = targetnode a'\""], ["proof (prove)\nusing this:\n  call_of_return_node n n'\n\ngoal (1 subgoal):\n 1. (\\<And>a a'.\n        \\<lbrakk>return_node n; valid_edge a; n' = sourcenode a;\n         valid_edge a'; a' \\<in> get_return_edges a;\n         n = targetnode a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:call_of_return_node_def)"], ["proof (state)\nthis:\n  return_node n\n  valid_edge a\n  n' = sourcenode a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  n = targetnode a'\n\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain Q p r fs \n    where \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "have \"CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:sum_SDG_call_summary_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume \"n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. n \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>n = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  n = targetnode a'\n  n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"CFG_node (targetnode a') \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  n = targetnode a'\n  n \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a') \\<in> HRB_slice S", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. n \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "hence \"CFG_node (sourcenode a) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "proof(induct \"CFG_node (targetnode a')\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "case (phase1 nx)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "with \\<open>CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx\n  nx \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_refl sum_slice1 \n                              simp:HRB_slice_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "case (phase2 nx n' n'' p')"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "from \\<open>CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\\<close> \n        \\<open>CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  valid_edge a", "have \"CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  valid_edge a\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'", "by(fastforce intro:sum_slice2)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "with \\<open>n' \\<in> sum_SDG_slice1 nx\\<close> \\<open>n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close> \\<open>nx \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  nx \\<in> S\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  nx \\<in> S\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_Return_parent_node\n                              simp:HRB_slice_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. n \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>n' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = sourcenode a\n  CFG_node (sourcenode a) \\<in> HRB_slice S", "show False"], ["proof (prove)\nusing this:\n  n' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = sourcenode a\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. False", "by(simp add:SDG_to_CFG_set_def HRB_slice_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma edge_obs_intra_slice_eq:\nassumes \"valid_edge a\" and \"intra_kind (kind a)\" and \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n         obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from assms"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<subseteq>\n                   obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n    \\<subseteq> obs_intra (sourcenode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_subset)"], ["proof (state)\nthis:\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "{"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"x \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    and \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (state)\nthis:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "proof(cases \"method_exit x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "case True"], ["proof (state)\nthis:\n  method_exit x\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "then"], ["proof (chain)\npicking this:\n  valid_node (targetnode a)", "obtain asx where \"targetnode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        targetnode\n         a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "then"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as pex where \"targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as pex.\n        \\<lbrakk>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "hence \"get_proc pex = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (1 subgoal):\n 1. get_proc pex = get_proc (targetnode a)", "by -(rule intra_path_get_procs[THEN sym])"], ["proof (state)\nthis:\n  get_proc pex = get_proc (targetnode a)\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "also"], ["proof (state)\nthis:\n  get_proc pex = get_proc (targetnode a)\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"\\<dots> = get_proc (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (sourcenode a)", "by -(rule get_proc_intra[THEN sym])"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc (sourcenode a)\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "also"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc (sourcenode a)\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "from \\<open>x \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> True"], ["proof (chain)\npicking this:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  method_exit x", "have \"\\<dots> = get_proc x\""], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  method_exit x\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc x", "by(fastforce elim:obs_intraE intro:intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc x\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "finally"], ["proof (chain)\npicking this:\n  get_proc pex = get_proc x", "have \"pex = x\""], ["proof (prove)\nusing this:\n  get_proc pex = get_proc x\n\ngoal (1 subgoal):\n 1. pex = x", "using \\<open>method_exit pex\\<close> True"], ["proof (prove)\nusing this:\n  get_proc pex = get_proc x\n  method_exit pex\n  method_exit x\n\ngoal (1 subgoal):\n 1. pex = x", "by -(rule method_exit_unique)"], ["proof (state)\nthis:\n  pex = x\n\ngoal (2 subgoals):\n 1. method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n 2. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "with \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  pex = x", "show ?thesis"], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  pex = x\n\ngoal (1 subgoal):\n 1. \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n\ngoal (1 subgoal):\n 1. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "case False"], ["proof (state)\nthis:\n  \\<not> method_exit x\n\ngoal (1 subgoal):\n 1. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "with \\<open>x \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit x", "have \"x postdominates (sourcenode a)\""], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> method_exit x\n\ngoal (1 subgoal):\n 1. x postdominates sourcenode a", "by(rule obs_intra_postdominate)"], ["proof (state)\nthis:\n  x postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>x \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x postdominates sourcenode a", "have \"x postdominates (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x postdominates sourcenode a\n\ngoal (1 subgoal):\n 1. x postdominates targetnode a", "by(fastforce elim:postdominate_inner_path_targetnode path_edge obs_intraE \n                    simp:intra_path_def sourcenodes_def)"], ["proof (state)\nthis:\n  x postdominates targetnode a\n\ngoal (1 subgoal):\n 1. \\<not> method_exit x \\<Longrightarrow>\n    \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x postdominates targetnode a\n\ngoal (1 subgoal):\n 1. \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "by(fastforce elim:postdominate_implies_inner_path)"], ["proof (state)\nthis:\n  \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "then"], ["proof (chain)\npicking this:\n  \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x", "obtain as where \"targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\""], ["proof (prove)\nusing this:\n  \\<exists>as. targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>x \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (sourcenode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(erule obs_intraE)"], ["proof (state)\nthis:\n  x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>x' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>. \\<exists>as'. targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and> \n      (\\<forall>a' \\<in> set (sourcenodes as'). a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "proof(cases \"\\<exists>a' \\<in> set (sourcenodes as). a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set (sourcenodes as).\n       a' \\<in> \\<lfloor>HRB_slice\n                          S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "case True"], ["proof (state)\nthis:\n  \\<exists>a'\\<in>set (sourcenodes as).\n     a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set (sourcenodes as).\n       a' \\<in> \\<lfloor>HRB_slice\n                          S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>a'\\<in>set (sourcenodes as).\n     a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain zs z zs' where \"sourcenodes as = zs@z#zs'\"\n        and \"z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<forall>z' \\<in> set zs. z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<exists>a'\\<in>set (sourcenodes as).\n     a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>zs z zs'.\n        \\<lbrakk>sourcenodes as = zs @ z # zs';\n         z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>z'\\<in>set zs.\n            z' \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule split_list_first_propE)"], ["proof (state)\nthis:\n  sourcenodes as = zs @ z # zs'\n  z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>z'\\<in>set zs.\n     z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set (sourcenodes as).\n       a' \\<in> \\<lfloor>HRB_slice\n                          S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = zs @ z # zs'\n  z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>z'\\<in>set zs.\n     z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain ys y ys'\n        where \"sourcenodes ys = zs\" and \"as = ys@y#ys'\"\n        and \"sourcenode y = z\""], ["proof (prove)\nusing this:\n  sourcenodes as = zs @ z # zs'\n  z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>z'\\<in>set zs.\n     z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>ys y ys'.\n        \\<lbrakk>sourcenodes ys = zs; as = ys @ y # ys';\n         sourcenode y = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  sourcenodes ys = zs\n  as = ys @ y # ys'\n  sourcenode y = z\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set (sourcenodes as).\n       a' \\<in> \\<lfloor>HRB_slice\n                          S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "from \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\\<close> \\<open>as = ys@y#ys'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n  as = ys @ y # ys'", "have \"targetnode a -ys@y#ys'\\<rightarrow>* x\" and \"\\<forall>y' \\<in> set ys. intra_kind (kind y')\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n  as = ys @ y # ys'\n\ngoal (1 subgoal):\n 1. targetnode a -ys @ y # ys'\\<rightarrow>* x &&&\n    \\<forall>y'\\<in>set ys. intra_kind (kind y')", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a -ys @ y # ys'\\<rightarrow>* x\n  \\<forall>y'\\<in>set ys. intra_kind (kind y')\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set (sourcenodes as).\n       a' \\<in> \\<lfloor>HRB_slice\n                          S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "from \\<open>targetnode a -ys@y#ys'\\<rightarrow>* x\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -ys @ y # ys'\\<rightarrow>* x", "have \"targetnode a -ys\\<rightarrow>* sourcenode y\""], ["proof (prove)\nusing this:\n  targetnode a -ys @ y # ys'\\<rightarrow>* x\n\ngoal (1 subgoal):\n 1. targetnode a -ys\\<rightarrow>* sourcenode y", "by(rule path_split)"], ["proof (state)\nthis:\n  targetnode a -ys\\<rightarrow>* sourcenode y\n\ngoal (2 subgoals):\n 1. \\<exists>a'\\<in>set (sourcenodes as).\n       a' \\<in> \\<lfloor>HRB_slice\n                          S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with \\<open>\\<forall>y' \\<in> set ys. intra_kind (kind y')\\<close> \\<open>sourcenode y = z\\<close>\n        \\<open>\\<forall>z' \\<in> set zs. z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>sourcenodes ys = zs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>y'\\<in>set ys. intra_kind (kind y')\n  sourcenode y = z\n  \\<forall>z'\\<in>set zs.\n     z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenodes ys = zs\n  targetnode a -ys\\<rightarrow>* sourcenode y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>y'\\<in>set ys. intra_kind (kind y')\n  sourcenode y = z\n  \\<forall>z'\\<in>set zs.\n     z' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  z \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenodes ys = zs\n  targetnode a -ys\\<rightarrow>* sourcenode y\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n     \\<exists>as'.\n        targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n        (\\<forall>a'\\<in>set (sourcenodes as').\n            a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n             a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n               a' \\<in> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\\<close> \\<open>x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n  x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n             a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "show ?thesis"], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* x\n  x \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<not> (\\<exists>a'\\<in>set (sourcenodes as).\n             a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n       \\<exists>as'.\n          targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n          (\\<forall>a'\\<in>set (sourcenodes as').\n              a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n     \\<exists>as'.\n        targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n        (\\<forall>a'\\<in>set (sourcenodes as').\n            a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n     \\<exists>as'.\n        targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n        (\\<forall>a'\\<in>set (sourcenodes as').\n            a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "hence \"\\<exists>y. y \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>.\n     \\<exists>as'.\n        targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* x' \\<and>\n        (\\<forall>a'\\<in>set (sourcenodes as').\n            a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       y \\<in> obs_intra (targetnode a)\n                \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:obs_intra_elem)"], ["proof (state)\nthis:\n  \\<exists>y.\n     y \\<in> obs_intra (targetnode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  \\<exists>y.\n     y \\<in> obs_intra (targetnode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have False"], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  \\<exists>y.\n     y \\<in> obs_intra (targetnode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2\n           \\<in> obs_intra (sourcenode a)\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   obs_intra (targetnode a)\n    \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<subseteq>\n        obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_node (sourcenode a)\n  \\<lbrakk>?x2\n           \\<in> obs_intra (sourcenode a)\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   obs_intra (targetnode a)\n    \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<subseteq> obs_intra (sourcenode a)\n               \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_node (sourcenode a)\n  \\<lbrakk>?x2\n           \\<in> obs_intra (sourcenode a)\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   obs_intra (targetnode a)\n    \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\") \n                 (auto dest!:obs_intra_singleton_disj)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma intra_edge_obs_slice:\n  assumes \"ms \\<noteq> []\" and \"ms'' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"valid_edge a\" \n  and \"intra_kind (kind a)\" \n  and disj:\"(\\<exists>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> \n                               m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"hd ms = sourcenode a\" and \"ms' = targetnode a#tl ms\" \n  and \"\\<forall>n \\<in> set (tl ms'). return_node n\"\n  shows \"ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms'' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>\\<forall>n \\<in> set (tl ms'). return_node n\\<close>"], ["proof (chain)\npicking this:\n  ms'' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node", "obtain msx m msx' mx m' where \"ms' = msx@m#msx'\" and \"ms'' = mx#msx'\"\n    and \"mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    and \"\\<forall>nx \\<in> set msx'. \\<exists>nx'. call_of_return_node nx nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    and imp:\"\\<forall>xs x xs'. msx = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n    \\<longrightarrow> (\\<exists>x'' \\<in> set (xs'@[m]). \\<exists>mx. call_of_return_node x'' mx \\<and> \n                                   mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  ms'' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. (\\<And>msx m msx' mx.\n        \\<lbrakk>ms' = msx @ m # msx'; ms'' = mx # msx';\n         mx \\<in> obs_intra m\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>nx\\<in>set msx'.\n            \\<exists>nx'.\n               call_of_return_node nx nx' \\<and>\n               nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>xs x xs'.\n            msx = xs @ x # xs' \\<and>\n            obs_intra x\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (xs' @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  ms' = msx @ m # msx'\n  ms'' = mx # msx'\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>\\<forall>nx \\<in> set msx'. \\<exists>nx'. call_of_return_node nx nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      disj \\<open>ms' = msx@m#msx'\\<close> \\<open>hd ms = sourcenode a\\<close> \\<open>ms' = targetnode a#tl ms\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = msx @ m # msx'\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  msx = []", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = msx @ m # msx'\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  msx = []\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms) auto"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms' = msx@m#msx'\\<close> \\<open>ms' = targetnode a#tl ms\\<close> Nil"], ["proof (chain)\npicking this:\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  msx = []", "have \"m = targetnode a\""], ["proof (prove)\nusing this:\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  msx = []\n\ngoal (1 subgoal):\n 1. m = targetnode a", "by simp"], ["proof (state)\nthis:\n  m = targetnode a\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = targetnode a", "have \"mx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = targetnode a\n\ngoal (1 subgoal):\n 1. mx \\<in> obs_intra (sourcenode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:edge_obs_intra_subset)"], ["proof (state)\nthis:\n  mx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms' = msx@m#msx'\\<close> Nil \\<open>ms' = targetnode a # tl ms\\<close> \n      \\<open>hd ms = sourcenode a\\<close> \\<open>ms \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms' = msx @ m # msx'\n  msx = []\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n  ms \\<noteq> []", "have \"ms = []@sourcenode a#msx'\""], ["proof (prove)\nusing this:\n  ms' = msx @ m # msx'\n  msx = []\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n  ms \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms = [] @ sourcenode a # msx'", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = [] @ sourcenode a # msx'\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms'' = mx#msx'\\<close> \\<open>mx \\<in> obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>  \n      \\<open>\\<forall>nx \\<in> set msx'. \\<exists>nx'. call_of_return_node nx nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> Nil"], ["proof (chain)\npicking this:\n  ms'' = mx # msx'\n  mx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = []\n  ms = [] @ sourcenode a # msx'", "show ?thesis"], ["proof (prove)\nusing this:\n  ms'' = mx # msx'\n  mx \\<in> obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = []\n  ms = [] @ sourcenode a # msx'\n\ngoal (1 subgoal):\n 1. ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro!:obsI)"], ["proof (state)\nthis:\n  ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (Cons x xs)"], ["proof (state)\nthis:\n  msx = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms' = msx@m#msx'\\<close> \\<open>ms' = targetnode a # tl ms\\<close>"], ["proof (chain)\npicking this:\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  msx = x # xs", "have \"msx = targetnode a#xs\""], ["proof (prove)\nusing this:\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  msx = x # xs\n\ngoal (1 subgoal):\n 1. msx = targetnode a # xs", "by simp"], ["proof (state)\nthis:\n  msx = targetnode a # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from Cons \\<open>ms' = msx@m#msx'\\<close> \\<open>ms' = targetnode a # tl ms\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  msx = x # xs\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a", "have \"ms = (sourcenode a#xs)@m#msx'\""], ["proof (prove)\nusing this:\n  msx = x # xs\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n\ngoal (1 subgoal):\n 1. ms = (sourcenode a # xs) @ m # msx'", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = (sourcenode a # xs) @ m # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from disj \\<open>ms = (sourcenode a#xs)@m#msx'\\<close> \n      \\<open>\\<forall>nx \\<in> set msx'. \\<exists>nx'. call_of_return_node nx nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms = (sourcenode a # xs) @ m # msx'\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have disj2:\"(\\<exists>m \\<in> set (xs@[m]). \\<exists>m'. call_of_return_node m m' \\<and> \n                            m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms = (sourcenode a # xs) @ m # msx'\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<exists>m\\<in>set (xs @ [m]).\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set (xs @ [m]).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "hence \"\\<forall>zs z zs'. sourcenode a#xs = zs@z#zs' \\<and> obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n      \\<longrightarrow> (\\<exists>z'' \\<in> set (zs'@[m]). \\<exists>mx. call_of_return_node z'' mx \\<and> \n                                   mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set (xs @ [m]).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>zs z zs'.\n       sourcenode a # xs = zs @ z # zs' \\<and>\n       obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>z''\\<in>set (zs' @ [m]).\n           \\<exists>mx.\n              call_of_return_node z'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "proof(cases \"hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     hd ms\n     \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "case True"], ["proof (state)\nthis:\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     hd ms\n     \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     hd ms\n     \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n        obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_slice_eq)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     hd ms\n     \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n 2. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with imp \\<open>msx = targetnode a#xs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = targetnode a # xs\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = targetnode a # xs\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>zs z zs'.\n       sourcenode a # xs = zs @ z # zs' \\<and>\n       obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>z''\\<in>set (zs' @ [m]).\n           \\<exists>mx.\n              call_of_return_node z'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by auto(case_tac zs,fastforce,erule_tac x=\"targetnode a#list\" in allE,fastforce)"], ["proof (state)\nthis:\n  \\<forall>zs z zs'.\n     sourcenode a # xs = zs @ z # zs' \\<and>\n     obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>z''\\<in>set (zs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node z'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "case False"], ["proof (state)\nthis:\n  \\<not> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with \\<open>hd ms = sourcenode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  valid_edge a\n  \\<not> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  valid_edge a\n  \\<not> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "from False disj2"], ["proof (chain)\npicking this:\n  \\<not> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (xs @ [m]).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>m \\<in> set (xs@[m]). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<not> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (xs @ [m]).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (xs @ [m]).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (xs @ [m]).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>m\\<in>set (xs @ [m]).\n                 \\<exists>m'.\n                    call_of_return_node m m' \\<and>\n                    m' \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n             hd ms\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     \\<not> hd ms\n            \\<notin> \\<lfloor>HRB_slice\n                               S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>zs z zs'.\n                         sourcenode a # xs = zs @ z # zs' \\<and>\n                         obs_intra z\n                          \\<lfloor>HRB_slice\n                                    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                         {} \\<longrightarrow>\n                         (\\<exists>z''\\<in>set (zs' @ [m]).\n                             \\<exists>mx.\n                                call_of_return_node z'' mx \\<and>\n                                mx \\<notin> \\<lfloor>HRB_slice\n                S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "with imp \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\\<close>\n        \\<open>msx = targetnode a#xs\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n  msx = targetnode a # xs\n  \\<exists>m\\<in>set (xs @ [m]).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n  msx = targetnode a # xs\n  \\<exists>m\\<in>set (xs @ [m]).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>zs z zs'.\n       sourcenode a # xs = zs @ z # zs' \\<and>\n       obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>z''\\<in>set (zs' @ [m]).\n           \\<exists>mx.\n              call_of_return_node z'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by auto(case_tac zs,fastforce,erule_tac x=\"targetnode a#list\" in allE,fastforce)"], ["proof (state)\nthis:\n  \\<forall>zs z zs'.\n     sourcenode a # xs = zs @ z # zs' \\<and>\n     obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>z''\\<in>set (zs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node z'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>zs z zs'.\n     sourcenode a # xs = zs @ z # zs' \\<and>\n     obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>z''\\<in>set (zs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node z'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms' = msx@m#msx'\\<close> \\<open>ms' = targetnode a # tl ms\\<close> \\<open>hd ms = sourcenode a\\<close>\n      \\<open>ms'' = mx#msx'\\<close> \\<open>mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n      \\<open>\\<forall>nx \\<in> set msx'. \\<exists>nx'. call_of_return_node nx nx' \\<and> nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>ms = (sourcenode a#xs)@m#msx'\\<close>"], ["proof (chain)\npicking this:\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n  ms'' = mx # msx'\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms = (sourcenode a # xs) @ m # msx'\n  \\<forall>zs z zs'.\n     sourcenode a # xs = zs @ z # zs' \\<and>\n     obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>z''\\<in>set (zs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node z'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "show ?thesis"], ["proof (prove)\nusing this:\n  ms' = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n  ms'' = mx # msx'\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>nx\\<in>set msx'.\n     \\<exists>nx'.\n        call_of_return_node nx nx' \\<and>\n        nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms = (sourcenode a # xs) @ m # msx'\n  \\<forall>zs z zs'.\n     sourcenode a # xs = zs @ z # zs' \\<and>\n     obs_intra z \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>z''\\<in>set (zs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node z'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(simp del:obs.simps)(rule obsI,auto)"], ["proof (state)\nthis:\n  ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ms'' \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Silent moves\\<close>"], ["", "inductive silent_move :: \n  \"'node SDG_node set \\<Rightarrow> ('edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind) \\<Rightarrow> 'node list \\<Rightarrow> \n  (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'edge \\<Rightarrow> 'node list \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\n(\"_,_ \\<turnstile> '(_,_') -_\\<rightarrow>\\<^sub>\\<tau> '(_,_')\" [51,50,0,0,50,0,0] 51) \n\nwhere silent_move_intra:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a; intra_kind(kind a);\n    (\\<exists>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \\<forall>m \\<in> set (tl ms). return_node m;\n    length s' = length s; length ms = length s;\n    hd ms = sourcenode a; ms' = (targetnode a)#tl ms\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\"\n\n  | silent_move_call:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; \n    valid_edge a'; a' \\<in> get_return_edges a;\n    (\\<exists>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \\<forall>m \\<in> set (tl ms). return_node m;\n    length ms = length s; length s' = Suc(length s); \n    hd ms = sourcenode a; ms' = (targetnode a)#(targetnode a')#tl ms\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\"\n\n  | silent_move_return:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'; \n    \\<exists>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n    \\<forall>m \\<in> set (tl ms). return_node m; length ms = length s; length s = Suc(length s');\n    s' \\<noteq> []; hd ms = sourcenode a; hd(tl ms) = targetnode a; ms' = tl ms\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["", "lemma silent_move_valid_nodes:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); \\<forall>m \\<in> set ms'. valid_node m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m \\<in> set ms. valid_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n     Ball (set ms') valid_node\\<rbrakk>\n    \\<Longrightarrow> Ball (set ms) valid_node", "by(induct rule:silent_move.induct)(case_tac ms,auto)+"], ["", "lemma silent_move_return_node:\n  \"S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow> \\<forall>m \\<in> set (tl ms'). return_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n    Ball (set (tl ms')) return_node", "proof(induct rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "case (silent_move_intra f a s s' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "thus ?case"], ["proof (prove)\nusing this:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms')) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms')) return_node\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "case (silent_move_call f a s s' Q r p fs a' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "from \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"return_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. return_node (targetnode a')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "with \\<open>\\<forall>m\\<in>set (tl ms). return_node m\\<close> \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms)) return_node\n  ms' = targetnode a # targetnode a' # tl ms\n  return_node (targetnode a')", "show ?case"], ["proof (prove)\nusing this:\n  Ball (set (tl ms)) return_node\n  ms' = targetnode a # targetnode a' # tl ms\n  return_node (targetnode a')\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms')) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "case (silent_move_return f a s s' Q p f' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set (tl ms')) return_node", "thus ?case"], ["proof (prove)\nusing this:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms')) return_node", "by(cases \"tl ms\") auto"], ["proof (state)\nthis:\n  Ball (set (tl ms')) return_node\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_move_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length ms = length s\n 2. length ms' = length s'", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"length ms = length s \\<and> length ms' = length s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "proof(induct rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "case (silent_move_intra f a s s' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>pred (f a) s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>length ms = length s\\<close> \\<open>ms' = targetnode a # tl ms\\<close>\n      \\<open>length s' = length s\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  ms' = targetnode a # tl ms\n  length s' = length s", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length s\n  ms' = targetnode a # tl ms\n  length s' = length s\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "case (silent_move_call f a s s' Q r p fs a' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>pred (f a) s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>length ms = length s\\<close> \\<open>length s' = Suc (length s)\\<close> \n      \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  length s' = Suc (length s)\n  ms' = targetnode a # targetnode a' # tl ms", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length s\n  length s' = Suc (length s)\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "case (silent_move_return f a s s' Q p f' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>length ms = length s\\<close> \\<open>length s = Suc (length s')\\<close> \\<open>ms' = tl ms\\<close> \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  length s = Suc (length s')\n  ms' = tl ms\n  s' \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length s\n  length s = Suc (length s')\n  ms' = tl ms\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (2 subgoals):\n 1. length ms = length s\n 2. length ms' = length s'", "thus \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\nusing this:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "by simp_all"], ["proof (state)\nthis:\n  length ms = length s\n  length ms' = length s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_move_obs_slice:\n  \"\\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \n    \\<forall>n \\<in> set (tl ms'). return_node n\\<rbrakk>\n  \\<Longrightarrow> msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n     msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     Ball (set (tl ms')) return_node\\<rbrakk>\n    \\<Longrightarrow> msx\n                      \\<in> obs ms\n                             \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(induct S f\\<equiv>\"kind\" ms s a ms' s' rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (silent_move_intra a s s' ms n\\<^sub>c ms')"], ["proof (state)\nthis:\n  pred (kind a) s\n  transfer (kind a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>pred (kind a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (kind a) s\n  length ms = length s", "have \"ms \\<noteq> []\""], ["proof (prove)\nusing this:\n  pred (kind a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. ms \\<noteq> []", "by(cases s) auto"], ["proof (state)\nthis:\n  ms \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with silent_move_intra"], ["proof (chain)\npicking this:\n  pred (kind a) s\n  transfer (kind a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n  ms \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  pred (kind a) s\n  transfer (kind a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n  ms \\<noteq> []\n\ngoal (1 subgoal):\n 1. msx\n    \\<in> obs ms \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(rule intra_edge_obs_slice)"], ["proof (state)\nthis:\n  msx \\<in> obs ms \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (silent_move_call a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (kind a) s\n  transfer (kind a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "note disj = \\<open>(\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> \n    m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"return_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. return_node (targetnode a')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  valid_edge a'\n  return_node (targetnode a')", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  valid_edge a'\n  return_node (targetnode a')\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>pred (kind a) s\\<close> \\<open>length ms = length s\\<close>"], ["proof (chain)\npicking this:\n  pred (kind a) s\n  length ms = length s", "have \"ms \\<noteq> []\""], ["proof (prove)\nusing this:\n  pred (kind a) s\n  length ms = length s\n\ngoal (1 subgoal):\n 1. ms \\<noteq> []", "by(cases s) auto"], ["proof (state)\nthis:\n  ms \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from disj"], ["proof (chain)\npicking this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd ms = sourcenode a\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms = sourcenode a\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>call_of_return_node (targetnode a') (sourcenode a)\\<close>\n      \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node (targetnode a') (sourcenode a)\n  ms' = targetnode a # targetnode a' # tl ms\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>n' \\<in> set (tl ms'). \\<exists>nx. call_of_return_node n' nx \\<and> nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  call_of_return_node (targetnode a') (sourcenode a)\n  ms' = targetnode a # targetnode a' # tl ms\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>n'\\<in>set (tl ms').\n       \\<exists>nx.\n          call_of_return_node n' nx \\<and>\n          nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>n'\\<in>set (tl ms').\n     \\<exists>nx.\n        call_of_return_node n' nx \\<and>\n        nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # tl ms\n  \\<exists>n'\\<in>set (tl ms').\n     \\<exists>nx.\n        call_of_return_node n' nx \\<and>\n        nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"msx \\<in> obs (targetnode a' # tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # tl ms\n  \\<exists>n'\\<in>set (tl ms').\n     \\<exists>nx.\n        call_of_return_node n' nx \\<and>\n        nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. msx\n    \\<in> obs (targetnode a' # tl ms)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  msx\n  \\<in> obs (targetnode a' # tl ms)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"valid_edge a''\" and [simp]:\"sourcenode a'' = sourcenode a\"\n      and [simp]:\"targetnode a'' = targetnode a'\" and \"intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         targetnode a'' = targetnode a'; intra_kind (kind a'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>\\<forall>m\\<in>set (tl ms'). return_node m\\<close> \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms')) return_node\n  ms' = targetnode a # targetnode a' # tl ms", "have \"\\<forall>m\\<in>set (tl ms). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms')) return_node\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms)) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms)) return_node\n\ngoal (2 subgoals):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. hd ms\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms \\<noteq> []\\<close> \\<open>msx \\<in> obs (targetnode a'#tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>valid_edge a''\\<close> \\<open>intra_kind(kind a'')\\<close> disj\n      \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms \\<noteq> []\n  msx\n  \\<in> obs (targetnode a' # tl ms)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a''\n  intra_kind (kind a'')\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms = sourcenode a\n  Ball (set (tl ms)) return_node", "show ?case"], ["proof (prove)\nusing this:\n  ms \\<noteq> []\n  msx\n  \\<in> obs (targetnode a' # tl ms)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a''\n  intra_kind (kind a'')\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms = sourcenode a\n  Ball (set (tl ms)) return_node\n\ngoal (1 subgoal):\n 1. msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(rule intra_edge_obs_slice,fastforce+)"], ["proof (state)\nthis:\n  msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms \\<noteq> []\\<close> \\<open>msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  ms \\<noteq> []\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # tl ms\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  ms \\<noteq> []\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # tl ms\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms) auto"], ["proof (state)\nthis:\n  msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case (silent_move_return a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (kind a) s\n  transfer (kind a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>length ms = length s\\<close> \\<open>length s = Suc (length s')\\<close> \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []", "have \"ms \\<noteq> []\" and \"tl ms \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms \\<noteq> [] &&& tl ms \\<noteq> []", "by(auto simp:length_Suc_conv)"], ["proof (state)\nthis:\n  ms \\<noteq> []\n  tl ms \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>\\<exists>m\\<in>set (tl ms).\n    \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>tl ms \\<noteq> []\\<close> \\<open>hd (tl ms) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms \\<noteq> []\n  hd (tl ms) = targetnode a", "have \"(\\<exists>m'. call_of_return_node (targetnode a) m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    (\\<exists>m\\<in>set (tl (tl ms)). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms \\<noteq> []\n  hd (tl ms) = targetnode a\n\ngoal (1 subgoal):\n 1. (\\<exists>m'.\n        call_of_return_node (targetnode a) m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n    (\\<exists>m\\<in>set (tl (tl ms)).\n        \\<exists>m'.\n           call_of_return_node m m' \\<and>\n           m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by(cases \"tl ms\") auto"], ["proof (state)\nthis:\n  (\\<exists>m'.\n      call_of_return_node (targetnode a) m' \\<and>\n      m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  (\\<exists>m\\<in>set (tl (tl ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "hence \"obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  (\\<exists>m'.\n      call_of_return_node (targetnode a) m' \\<and>\n      m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  (\\<exists>m\\<in>set (tl (tl ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>m'.\n       call_of_return_node (targetnode a) m' \\<and>\n       m' \\<notin> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"\\<exists>m'. call_of_return_node (targetnode a) m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  \\<exists>m'.\n     call_of_return_node (targetnode a) m' \\<and>\n     m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m'.\n       call_of_return_node (targetnode a) m' \\<and>\n       m' \\<notin> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>tl ms \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  tl ms \\<noteq> []", "have \"hd (tl ms) \\<in> set (tl ms)\""], ["proof (prove)\nusing this:\n  tl ms \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (tl ms) \\<in> set (tl ms)", "by simp"], ["proof (state)\nthis:\n  hd (tl ms) \\<in> set (tl ms)\n\ngoal (2 subgoals):\n 1. \\<exists>m'.\n       call_of_return_node (targetnode a) m' \\<and>\n       m' \\<notin> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>hd (tl ms) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  hd (tl ms) = targetnode a\n  hd (tl ms) \\<in> set (tl ms)", "have \"targetnode a \\<in> set (tl ms)\""], ["proof (prove)\nusing this:\n  hd (tl ms) = targetnode a\n  hd (tl ms) \\<in> set (tl ms)\n\ngoal (1 subgoal):\n 1. targetnode a \\<in> set (tl ms)", "by simp"], ["proof (state)\nthis:\n  targetnode a \\<in> set (tl ms)\n\ngoal (2 subgoals):\n 1. \\<exists>m'.\n       call_of_return_node (targetnode a) m' \\<and>\n       m' \\<notin> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms \\<noteq> []\\<close> \n      \\<open>\\<exists>m'. call_of_return_node (targetnode a) m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  ms \\<noteq> []\n  \\<exists>m'.\n     call_of_return_node (targetnode a) m' \\<and>\n     m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  targetnode a \\<in> set (tl ms)", "have \"\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> \n      m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ms \\<noteq> []\n  \\<exists>m'.\n     call_of_return_node (targetnode a) m' \\<and>\n     m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  targetnode a \\<in> set (tl ms)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl ms).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms) auto"], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<exists>m'.\n       call_of_return_node (targetnode a) m' \\<and>\n       m' \\<notin> \\<lfloor>HRB_slice\n                             S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms \\<noteq> []\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  ms \\<noteq> []\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms) auto"], ["proof (state)\nthis:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"\\<exists>m\\<in>set (tl (tl ms)). \\<exists>m'. call_of_return_node m m' \\<and> \n      m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  \\<exists>m\\<in>set (tl (tl ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>set (tl (tl ms)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<notin> \\<lfloor>HRB_slice\n                                S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms \\<noteq> []\\<close> \\<open>tl ms \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms \\<noteq> []\n  tl ms \\<noteq> []\n  \\<exists>m\\<in>set (tl (tl ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  ms \\<noteq> []\n  tl ms \\<noteq> []\n  \\<exists>m\\<in>set (tl (tl ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms,auto simp:Let_def)(case_tac list,auto)+"], ["proof (state)\nthis:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node\\<rbrakk>\n       \\<Longrightarrow> msx\n                         \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms' = tl ms\\<close> \\<open>msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  ms' = tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  ms' = tl ms\n  msx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs (tl ms) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  msx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_move_empty_obs_slice:\n  assumes \"S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\" and \"obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\"\n  shows \"obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\""], ["proof (state)\nthis:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}", "obtain xs where \"xs \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        xs \\<in> obs ms\n                  \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"\\<forall>m \\<in> set (tl ms). return_node m\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms)) return_node", "by(fastforce elim!:silent_move.cases simp:call_of_return_node_def)"], ["proof (state)\nthis:\n  Ball (set (tl ms)) return_node\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    False", "with \\<open>xs \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  xs \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node", "obtain msx m msx' m' where assms:\"ms = msx@m#msx'\" \"xs = m'#msx'\"\n    \"m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" \n    \"\\<forall>mx \\<in> set msx'. \\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    \"\\<forall>xs x xs'. msx = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\n    \\<longrightarrow> (\\<exists>x'' \\<in> set (xs'@[m]). \\<exists>mx. call_of_return_node x'' mx \\<and> \n                              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  xs \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n\ngoal (1 subgoal):\n 1. (\\<And>msx m msx' m'.\n        \\<lbrakk>ms = msx @ m # msx'; xs = m' # msx';\n         m' \\<in> obs_intra m\n                   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>mx\\<in>set msx'.\n            \\<exists>mx'.\n               call_of_return_node mx mx' \\<and>\n               mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         \\<forall>xs x xs'.\n            msx = xs @ x # xs' \\<and>\n            obs_intra x\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (xs' @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  ms = msx @ m # msx'\n  xs = m' # msx'\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close> \\<open>obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close> assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  ms = msx @ m # msx'\n  xs = m' # msx'\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "show False"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  ms = msx @ m # msx'\n  xs = m' # msx'\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. False", "proof(induct rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "case (silent_move_intra f a s s' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  ms = msx @ m # msx'\n  xs = m' # msx'\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note disj = \\<open>(\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> \n      m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note msx = \\<open>\\<forall>xs x xs'. msx = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> \n      (\\<exists>x''\\<in>set (xs' @ [m]). \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note msx' = \\<open>\\<forall>mx\\<in>set msx'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms = msx @ m # msx'\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  msx = []", "have [simp]:\"m = sourcenode a\"\n        and \"tl ms = msx'\""], ["proof (prove)\nusing this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  msx = []\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& tl ms = msx'", "by simp_all"], ["proof (state)\nthis:\n  m = sourcenode a\n  tl ms = msx'\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from Nil \\<open>ms' = targetnode a # tl ms\\<close> \\<open>ms = msx @ m # msx'\\<close>"], ["proof (chain)\npicking this:\n  msx = []\n  ms' = targetnode a # tl ms\n  ms = msx @ m # msx'", "have \"ms' = msx @ targetnode a # msx'\""], ["proof (prove)\nusing this:\n  msx = []\n  ms' = targetnode a # tl ms\n  ms = msx @ m # msx'\n\ngoal (1 subgoal):\n 1. ms' = msx @ targetnode a # msx'", "by simp"], ["proof (state)\nthis:\n  ms' = msx @ targetnode a # msx'\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from msx' disj \\<open>tl ms = msx'\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms = msx'\n  hd ms = sourcenode a", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms = msx'\n  hd ms = sourcenode a\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_slice_eq)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m' \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' \\<in> obs_intra (targetnode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  m' \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from msx Nil"], ["proof (chain)\npicking this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = []", "have \"\\<forall>xs x xs'. msx = xs@x#xs' \\<and>  \n        obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> \n        (\\<exists>x''\\<in>set (xs' @ [targetnode a]). \\<exists>mx. call_of_return_node x'' mx \\<and> \n        mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = []\n\ngoal (1 subgoal):\n 1. \\<forall>xs x xs'.\n       msx = xs @ x # xs' \\<and>\n       obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>x''\\<in>set (xs' @ [targetnode a]).\n           \\<exists>mx.\n              call_of_return_node x'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [targetnode a]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>m' \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> msx' \n        \\<open>ms' = msx @ targetnode a # msx'\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = msx @ targetnode a # msx'\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [targetnode a]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"m'#msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = msx @ targetnode a # msx'\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [targetnode a]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule obsI)"], ["proof (state)\nthis:\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "case (Cons y ys)"], ["proof (state)\nthis:\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms = msx @ m # msx'\\<close> \\<open>ms' = targetnode a # tl ms\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n  msx = y # ys", "have \"ms' = targetnode a # ys @ m # msx'\" and \"y = sourcenode a\" \n        and \"tl ms = ys @ m # msx'\""], ["proof (prove)\nusing this:\n  ms = msx @ m # msx'\n  ms' = targetnode a # tl ms\n  hd ms = sourcenode a\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. ms' = targetnode a # ys @ m # msx' &&&\n    y = sourcenode a &&& tl ms = ys @ m # msx'", "by simp_all"], ["proof (state)\nthis:\n  ms' = targetnode a # ys @ m # msx'\n  y = sourcenode a\n  tl ms = ys @ m # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  ms' = targetnode a # ys @ m # msx'\n  y = sourcenode a\n  tl ms = ys @ m # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "assume \"x \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  x \\<in> obs_intra (targetnode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "from this True"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(rule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> False"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n            obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_slice_eq)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "with \\<open>x \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> obs_intra (targetnode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (targetnode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> obs_intra (targetnode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with msx Cons \\<open>y = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n  y = sourcenode a\n  ?x2\n  \\<in> obs_intra (targetnode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}", "have \"\\<forall>xs x xs'. targetnode a # ys = xs@x#xs' \\<and> \n        obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> (\\<exists>x''\\<in>set (xs' @ [m]). \n        \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n  y = sourcenode a\n  ?x2\n  \\<in> obs_intra (targetnode a)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<forall>xs x xs'.\n       targetnode a # ys = xs @ x # xs' \\<and>\n       obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>x''\\<in>set (xs' @ [m]).\n           \\<exists>mx.\n              call_of_return_node x'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x xs'.\n       \\<lbrakk>\\<forall>xs x xs'.\n                   sourcenode a # ys = xs @ x # xs' \\<and>\n                   obs_intra x\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>mx.\n                       call_of_return_node m mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                   (\\<exists>x''\\<in>set xs'.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        targetnode a # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs x xs'.\n       \\<lbrakk>\\<forall>xs x xs'.\n                   sourcenode a # ys = xs @ x # xs' \\<and>\n                   obs_intra x\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>mx.\n                       call_of_return_node m mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                   (\\<exists>x''\\<in>set xs'.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        targetnode a # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>xs x xs' a list.\n       \\<lbrakk>\\<forall>xs x xs'.\n                   sourcenode a # ys = xs @ x # xs' \\<and>\n                   obs_intra x\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>mx.\n                       call_of_return_node m mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                   (\\<exists>x''\\<in>set xs'.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        targetnode a # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>xs x xs'.\n                   sourcenode a # ys = xs @ x # xs' \\<and>\n                   obs_intra x\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>x''\\<in>set xs'.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        \\<forall>x''\\<in>set ys.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx.\n           call_of_return_node m mx \\<longrightarrow>\n           mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xa \\<in> obs_intra (targetnode a)\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs' list xa.\n       \\<lbrakk>\\<forall>xs xa xs'a.\n                   sourcenode a # list @ x # xs' = xs @ xa # xs'a \\<and>\n                   obs_intra xa\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>x''\\<in>set xs'a.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # list @ x # xs'; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        ys = list @ x # xs';\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx.\n           call_of_return_node m mx \\<longrightarrow>\n           mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xa \\<in> obs_intra x\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>msx = sourcenode a # ys; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        \\<forall>x''\\<in>set ys.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx.\n           call_of_return_node m mx \\<longrightarrow>\n           mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xa \\<in> obs_intra (targetnode a)\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>x xs'.\n           sourcenode a # ys = [] @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x xs' list xa.\n       \\<lbrakk>\\<forall>xs xa xs'a.\n                   sourcenode a # list @ x # xs' = xs @ xa # xs'a \\<and>\n                   obs_intra xa\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>x''\\<in>set xs'a.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # list @ x # xs'; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        ys = list @ x # xs';\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx.\n           call_of_return_node m mx \\<longrightarrow>\n           mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xa \\<in> obs_intra x\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs' list xa.\n       \\<lbrakk>\\<forall>xs xa xs'a.\n                   sourcenode a # list @ x # xs' = xs @ xa # xs'a \\<and>\n                   obs_intra xa\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                   {} \\<longrightarrow>\n                   (\\<exists>x''\\<in>set xs'a.\n                       \\<exists>mx.\n                          call_of_return_node x'' mx \\<and>\n                          mx \\<notin> \\<lfloor>HRB_slice\n          S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # list @ x # xs'; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        ys = list @ x # xs';\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx.\n           call_of_return_node m mx \\<longrightarrow>\n           mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xa \\<in> obs_intra x\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x=\"sourcenode a # list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs' list xa.\n       \\<lbrakk>msx = sourcenode a # list @ x # xs'; y = sourcenode a;\n        \\<And>x.\n           x \\<in> obs_intra (targetnode a)\n                    \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n           obs_intra (sourcenode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {};\n        ys = list @ x # xs';\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx.\n           call_of_return_node m mx \\<longrightarrow>\n           mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xa \\<in> obs_intra x\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xa xs'a.\n           sourcenode a # list @ x # xs' =\n           (sourcenode a # list) @ xa # xs'a \\<and>\n           obs_intra xa\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set xs'a.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     targetnode a # ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> msx' \n        \\<open>ms' = targetnode a # ys @ m # msx'\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # ys @ m # msx'\n  \\<forall>xs x xs'.\n     targetnode a # ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"m'#msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # ys @ m # msx'\n  \\<forall>xs x xs'.\n     targetnode a # ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(rule obsI,auto)"], ["proof (state)\nthis:\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "case (silent_move_call f a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  ms = msx @ m # msx'\n  xs = m' # msx'\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note disj = \\<open>(\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> \n      m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or> hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note msx = \\<open>\\<forall>xs x xs'. msx = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> \n      (\\<exists>x''\\<in>set (xs' @ [m]). \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note msx' = \\<open>\\<forall>mx\\<in>set msx'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"valid_edge a''\"\n      and \"sourcenode a'' = sourcenode a\" and \"targetnode a'' = targetnode a'\"\n      and \"intra_kind (kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         targetnode a'' = targetnode a'; intra_kind (kind a'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(fastforce simp:call_of_return_node_def return_node_def)"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms = msx @ m # msx'\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  msx = []", "have [simp]:\"m = sourcenode a\"\n        and \"tl ms = msx'\""], ["proof (prove)\nusing this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  msx = []\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& tl ms = msx'", "by simp_all"], ["proof (state)\nthis:\n  m = sourcenode a\n  tl ms = msx'\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from Nil \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close> \\<open>ms = msx @ m # msx'\\<close>"], ["proof (chain)\npicking this:\n  msx = []\n  ms' = targetnode a # targetnode a' # tl ms\n  ms = msx @ m # msx'", "have \"ms' = targetnode a # targetnode a' # msx'\""], ["proof (prove)\nusing this:\n  msx = []\n  ms' = targetnode a # targetnode a' # tl ms\n  ms = msx @ m # msx'\n\ngoal (1 subgoal):\n 1. ms' = targetnode a # targetnode a' # msx'", "by simp"], ["proof (state)\nthis:\n  ms' = targetnode a # targetnode a' # msx'\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from msx' disj \\<open>tl ms = msx'\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms = msx'\n  hd ms = sourcenode a", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms = msx'\n  hd ms = sourcenode a\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from \\<open>valid_edge a''\\<close> \\<open>intra_kind (kind a'')\\<close> \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>sourcenode a'' = sourcenode a\\<close> \\<open>targetnode a'' = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  intra_kind (kind a'')\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'", "have \"obs_intra (targetnode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n         obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  intra_kind (kind a'')\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:edge_obs_intra_slice_eq)"], ["proof (state)\nthis:\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m' \\<in> obs_intra (targetnode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' \\<in> obs_intra (targetnode a')\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  m' \\<in> obs_intra (targetnode a')\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from this msx'"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra (targetnode a')\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m'#msx' \\<in> obs (targetnode a'#msx') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra (targetnode a')\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' # msx'\n    \\<in> obs (targetnode a' # msx')\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:obsI)"], ["proof (state)\nthis:\n  m' # msx'\n  \\<in> obs (targetnode a' # msx')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from \\<open>call_of_return_node (targetnode a') (sourcenode a)\\<close>\n        \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  call_of_return_node (targetnode a') (sourcenode a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<exists>m' \\<in> set (targetnode a'#msx').\n        \\<exists>mx. call_of_return_node m' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  call_of_return_node (targetnode a') (sourcenode a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>m'\\<in>set (targetnode a' # msx').\n       \\<exists>mx.\n          call_of_return_node m' mx \\<and>\n          mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>m'\\<in>set (targetnode a' # msx').\n     \\<exists>mx.\n        call_of_return_node m' mx \\<and>\n        mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>m'#msx' \\<in> obs (targetnode a'#msx') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m' # msx'\n  \\<in> obs (targetnode a' # msx')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<exists>m'\\<in>set (targetnode a' # msx').\n     \\<exists>mx.\n        call_of_return_node m' mx \\<and>\n        mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m'#msx' \\<in> obs (targetnode a#targetnode a'#msx') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' # msx'\n  \\<in> obs (targetnode a' # msx')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<exists>m'\\<in>set (targetnode a' # msx').\n     \\<exists>mx.\n        call_of_return_node m' mx \\<and>\n        mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' # msx'\n    \\<in> obs (targetnode a # targetnode a' # msx')\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  m' # msx'\n  \\<in> obs (targetnode a # targetnode a' # msx')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms' = targetnode a # targetnode a' # msx'\\<close> \\<open>obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  ms' = targetnode a # targetnode a' # msx'\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx'\n  \\<in> obs (targetnode a # targetnode a' # msx')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  ms' = targetnode a # targetnode a' # msx'\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx'\n  \\<in> obs (targetnode a # targetnode a' # msx')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "case (Cons y ys)"], ["proof (state)\nthis:\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms = msx @ m # msx'\\<close> \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close> \n        \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms = msx @ m # msx'\n  ms' = targetnode a # targetnode a' # tl ms\n  hd ms = sourcenode a\n  msx = y # ys", "have \"ms' = targetnode a # targetnode a' # ys @ m # msx'\" \n        and \"y = sourcenode a\" and \"tl ms = ys @ m # msx'\""], ["proof (prove)\nusing this:\n  ms = msx @ m # msx'\n  ms' = targetnode a # targetnode a' # tl ms\n  hd ms = sourcenode a\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. ms' = targetnode a # targetnode a' # ys @ m # msx' &&&\n    y = sourcenode a &&& tl ms = ys @ m # msx'", "by simp_all"], ["proof (state)\nthis:\n  ms' = targetnode a # targetnode a' # ys @ m # msx'\n  y = sourcenode a\n  tl ms = ys @ m # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> \n          (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n          \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "hence imp:\"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow>\n          (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n          \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "."], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"obs_intra (targetnode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> \n            (\\<exists>x''\\<in>set (ys @ [m]). \\<exists>mx. call_of_return_node x'' mx \\<and> \n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs_intra (targetnode a')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. obs_intra (targetnode a')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "with imp msx Cons \\<open>y = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n  y = sourcenode a\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"\\<forall>xs x xs'. targetnode a # targetnode a' # ys = xs@x#xs' \\<and> \n            obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> (\\<exists>x''\\<in>set (xs' @ [m]). \n            \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n  y = sourcenode a\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {} \\<longrightarrow>\n  (\\<exists>x''\\<in>set (ys @ [m]).\n      \\<exists>mx.\n         call_of_return_node x'' mx \\<and>\n         mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<forall>xs x xs'.\n       targetnode a # targetnode a' # ys = xs @ x # xs' \\<and>\n       obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>x''\\<in>set (xs' @ [m]).\n           \\<exists>mx.\n              call_of_return_node x'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x xs'.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs x xs'.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>xs x xs' a list.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x xs' a list.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs x xs' a list.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = a # list; list = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. \\<And>xs x xs' a list aaa lista.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = a # list; list = aaa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x xs' a list aaa lista.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set ys.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs x xs'.\n           sourcenode a # ys = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # ys; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set ys.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        targetnode a # targetnode a' # ys = xs @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        xs = a # list; list = aaa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs' lista.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node x mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set lista \\<union> set xs'.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        \\<forall>xs xa xs'a.\n           sourcenode a # lista @ x # xs' = xs @ xa # xs'a \\<and>\n           obs_intra xa\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'a.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # lista @ x # xs'; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>mx.\n            call_of_return_node x mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set lista \\<union> set xs'.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        ys = lista @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply(erule_tac x=\"sourcenode a # lista\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs' lista.\n       \\<lbrakk>obs_intra (targetnode a)\n                 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n                {} \\<longrightarrow>\n                (\\<exists>mx.\n                    call_of_return_node (targetnode a') mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node m mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>mx.\n                    call_of_return_node x mx \\<and>\n                    mx \\<notin> \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n                (\\<exists>x''\\<in>set lista \\<union> set xs'.\n                    \\<exists>mx.\n                       call_of_return_node x'' mx \\<and>\n                       mx \\<notin> \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        msx = sourcenode a # lista @ x # xs'; y = sourcenode a;\n        obs_intra (targetnode a')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {} \\<longrightarrow>\n        (\\<exists>mx.\n            call_of_return_node m mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>mx.\n            call_of_return_node x mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice\n                                  S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        (\\<exists>x''\\<in>set lista \\<union> set xs'.\n            \\<exists>mx.\n               call_of_return_node x'' mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        ys = lista @ x # xs';\n        obs_intra x\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n        {};\n        \\<forall>x''\\<in>set xs'.\n           \\<forall>mx.\n              call_of_return_node x'' mx \\<longrightarrow>\n              mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xa xs'a.\n           sourcenode a # lista @ x # xs' =\n           (sourcenode a # lista) @ xa # xs'a \\<and>\n           obs_intra xa\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>mx.\n               call_of_return_node m mx \\<and>\n               mx \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n           (\\<exists>x''\\<in>set xs'a.\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mx.\n                            call_of_return_node m mx \\<and>\n                            mx \\<notin> \\<lfloor>HRB_slice\n            S\\<rfloor>\\<^bsub>CFG\\<^esub>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     targetnode a # targetnode a' # ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (2 subgoals):\n 1. obs_intra (targetnode a')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "with \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> msx' \n            \\<open>ms' = targetnode a # targetnode a' # ys @ m # msx'\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # ys @ m # msx'\n  \\<forall>xs x xs'.\n     targetnode a # targetnode a' # ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"m'#msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = targetnode a # targetnode a' # ys @ m # msx'\n  \\<forall>xs x xs'.\n     targetnode a # targetnode a' # ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by -(rule obsI,auto)"], ["proof (state)\nthis:\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. obs_intra (targetnode a')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<longrightarrow>\n    (\\<exists>x''\\<in>set (ys @ [m]).\n        \\<exists>mx.\n           call_of_return_node x'' mx \\<and>\n           mx \\<notin> \\<lfloor>HRB_slice\n                                 S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<Longrightarrow>\n    False\n 2. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "with \\<open>obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  \\<not> (obs_intra (targetnode a')\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n          {} \\<longrightarrow>\n          (\\<exists>x''\\<in>set (ys @ [m]).\n              \\<exists>mx.\n                 call_of_return_node x'' mx \\<and>\n                 mx \\<notin> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "hence \"obs_intra (targetnode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\"\n            and all:\"\\<forall>x''\\<in>set (ys @ [m]). \\<forall>mx. call_of_return_node x'' mx \\<longrightarrow> \n            mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<not> (obs_intra (targetnode a')\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n          {} \\<longrightarrow>\n          (\\<exists>x''\\<in>set (ys @ [m]).\n              \\<exists>mx.\n                 call_of_return_node x'' mx \\<and>\n                 mx \\<notin> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>))\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} &&&\n    \\<forall>x''\\<in>set (ys @ [m]).\n       \\<forall>mx.\n          call_of_return_node x'' mx \\<longrightarrow>\n          mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce+"], ["proof (state)\nthis:\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  \\<forall>x''\\<in>set (ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "from this True"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(rule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "with \\<open>sourcenode a'' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a'' = sourcenode a\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  sourcenode a'' = sourcenode a\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "with \\<open>valid_edge a''\\<close> \\<open>intra_kind (kind a'')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  intra_kind (kind a'')\n  sourcenode a'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a'') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n              obs_intra (sourcenode a'') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  intra_kind (kind a'')\n  sourcenode a'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a'')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a'')\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_slice_eq)"], ["proof (state)\nthis:\n  obs_intra (targetnode a'')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a'')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "with \\<open>obs_intra (targetnode a') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\\<close> \n              \\<open>sourcenode a'' = sourcenode a\\<close> \\<open>targetnode a'' = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  obs_intra (targetnode a'')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a'')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  obs_intra (targetnode a')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  obs_intra (targetnode a'')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a'')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a')\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "with msx Cons \\<open>y = sourcenode a\\<close> all"], ["proof (chain)\npicking this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n  y = sourcenode a\n  \\<forall>x''\\<in>set (ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}", "show False"], ["proof (prove)\nusing this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n  y = sourcenode a\n  \\<forall>x''\\<in>set (ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. False", "by simp blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  \\<not> (obs_intra (targetnode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n          {} \\<longrightarrow>\n          (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n              \\<exists>mx.\n                 call_of_return_node x'' mx \\<and>\n                 mx \\<notin> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "hence \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {}\"\n          and all:\"\\<forall>x''\\<in>set (targetnode a' # ys @ [m]). \n          \\<forall>mx. call_of_return_node x'' mx \\<longrightarrow> mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<not> (obs_intra (targetnode a)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n          {} \\<longrightarrow>\n          (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n              \\<exists>mx.\n                 call_of_return_node x'' mx \\<and>\n                 mx \\<notin> \\<lfloor>HRB_slice\n S\\<rfloor>\\<^bsub>CFG\\<^esub>))\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} &&&\n    \\<forall>x''\\<in>set (targetnode a' # ys @ [m]).\n       \\<forall>mx.\n          call_of_return_node x'' mx \\<longrightarrow>\n          mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce+"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  \\<forall>x''\\<in>set (targetnode a' # ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "with Cons \\<open>y = sourcenode a\\<close> msx"], ["proof (chain)\npicking this:\n  msx = y # ys\n  y = sourcenode a\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  \\<forall>x''\\<in>set (targetnode a' # ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  msx = y # ys\n  y = sourcenode a\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  \\<forall>x''\\<in>set (targetnode a' # ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {}", "by auto blast"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "from \\<open>call_of_return_node (targetnode a') (sourcenode a)\\<close> all"], ["proof (chain)\npicking this:\n  call_of_return_node (targetnode a') (sourcenode a)\n  \\<forall>x''\\<in>set (targetnode a' # ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  call_of_return_node (targetnode a') (sourcenode a)\n  \\<forall>x''\\<in>set (targetnode a' # ys @ [m]).\n     \\<forall>mx.\n        call_of_return_node x'' mx \\<longrightarrow>\n        mx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "from this \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(rule n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. \\<not> (obs_intra (targetnode a)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n            {} \\<longrightarrow>\n            (\\<exists>x''\\<in>set (targetnode a' # ys @ [m]).\n                \\<exists>mx.\n                   call_of_return_node x'' mx \\<and>\n                   mx \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>)) \\<Longrightarrow>\n    False", "with \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}", "show False"], ["proof (prove)\nusing this:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "case (silent_move_return f a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  ms = msx @ m # msx'\n  xs = m' # msx'\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note msx = \\<open>\\<forall>xs x xs'. msx = xs@x#xs' \\<and> obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow> \n      (\\<exists>x''\\<in>set (xs' @ [m]). \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "note msx' = \\<open>\\<forall>mx\\<in>set msx'. \\<exists>mx'. call_of_return_node mx mx' \\<and> \n      mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms;\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        ms = msx @ m # msx'; xs = m' # msx';\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>mx\\<in>set msx'.\n           \\<exists>mx'.\n              call_of_return_node mx mx' \\<and>\n              mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           msx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [m]).\n               \\<exists>mx.\n                  call_of_return_node x'' mx \\<and>\n                  mx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms = msx @ m # msx'\\<close> \\<open>hd ms = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  msx = []", "have  \"tl ms = msx'\""], ["proof (prove)\nusing this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  msx = []\n\ngoal (1 subgoal):\n 1. tl ms = msx'", "by simp"], ["proof (state)\nthis:\n  tl ms = msx'\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow> False\n 2. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>\\<exists>m\\<in>set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        msx'"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms = msx'", "show False"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms = msx'\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "case (Cons y ys)"], ["proof (state)\nthis:\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>ms = msx @ m # msx'\\<close> \\<open>hd ms = sourcenode a\\<close> \\<open>ms' = tl ms\\<close>"], ["proof (chain)\npicking this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  ms' = tl ms\n  msx = y # ys", "have \"ms' = ys @ m # msx'\" and \"y = sourcenode a\""], ["proof (prove)\nusing this:\n  ms = msx @ m # msx'\n  hd ms = sourcenode a\n  ms' = tl ms\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. ms' = ys @ m # msx' &&& y = sourcenode a", "by simp_all"], ["proof (state)\nthis:\n  ms' = ys @ m # msx'\n  y = sourcenode a\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "from msx Cons"], ["proof (chain)\npicking this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys", "have \"\\<forall>xs x xs'. ys = xs@x#xs' \\<and> \n        obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq> {} \\<longrightarrow>  (\\<exists>x''\\<in>set (xs' @ [m]). \n        \\<exists>mx. call_of_return_node x'' mx \\<and> mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<forall>xs x xs'.\n     msx = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  msx = y # ys\n\ngoal (1 subgoal):\n 1. \\<forall>xs x xs'.\n       ys = xs @ x # xs' \\<and>\n       obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n       {} \\<longrightarrow>\n       (\\<exists>x''\\<in>set (xs' @ [m]).\n           \\<exists>mx.\n              call_of_return_node x'' mx \\<and>\n              mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "by auto (erule_tac x=\"y # xs\" in allE,auto)"], ["proof (state)\nthis:\n  \\<forall>xs x xs'.\n     ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> msx' \\<open>ms' = ys @ m # msx'\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = ys @ m # msx'\n  \\<forall>xs x xs'.\n     ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have \"m'#msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>mx\\<in>set msx'.\n     \\<exists>mx'.\n        call_of_return_node mx mx' \\<and>\n        mx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms' = ys @ m # msx'\n  \\<forall>xs x xs'.\n     ys = xs @ x # xs' \\<and>\n     obs_intra x \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n     {} \\<longrightarrow>\n     (\\<exists>x''\\<in>set (xs' @ [m]).\n         \\<exists>mx.\n            call_of_return_node x'' mx \\<and>\n            mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule obsI)"], ["proof (state)\nthis:\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a list. msx = a # list \\<Longrightarrow> False", "with \\<open>obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  m' # msx' \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive silent_moves :: \n  \"'node SDG_node set \\<Rightarrow> ('edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind) \\<Rightarrow> 'node list \\<Rightarrow> \n  (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'edge list \\<Rightarrow> 'node list \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\n(\"_,_ \\<turnstile> '(_,_') =_\\<Rightarrow>\\<^sub>\\<tau> '(_,_')\" [51,50,0,0,50,0,0] 51)\n\n  where silent_moves_Nil: \"length ms = length s \\<Longrightarrow> S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms,s)\"\n\n  | silent_moves_Cons:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s'); S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<rbrakk> \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a#as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\""], ["", "lemma silent_moves_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length ms = length s\n 2. length ms' = length s'", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"length ms = length s \\<and> length ms' = length s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       length ms = length s \\<Longrightarrow>\n       length ms = length s \\<and> length ms = length s\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        length ms' = length s' \\<and> length ms'' = length s''\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and>\n                         length ms'' = length s''", "case (silent_moves_Cons S f ms s a ms' s' as ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  length ms' = length s' \\<and> length ms'' = length s''\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       length ms = length s \\<Longrightarrow>\n       length ms = length s \\<and> length ms = length s\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        length ms' = length s' \\<and> length ms'' = length s''\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and>\n                         length ms'' = length s''", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "by(rule silent_move_equal_length)+"], ["proof (state)\nthis:\n  length ms = length s\n  length ms' = length s'\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       length ms = length s \\<Longrightarrow>\n       length ms = length s \\<and> length ms = length s\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        length ms' = length s' \\<and> length ms'' = length s''\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and>\n                         length ms'' = length s''", "with \\<open>length ms' = length s' \\<and> length ms'' = length s''\\<close>"], ["proof (chain)\npicking this:\n  length ms' = length s' \\<and> length ms'' = length s''\n  length ms = length s\n  length ms' = length s'", "show ?case"], ["proof (prove)\nusing this:\n  length ms' = length s' \\<and> length ms'' = length s''\n  length ms = length s\n  length ms' = length s'\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms'' = length s''", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms'' = length s''\n\ngoal (1 subgoal):\n 1. \\<And>ms s S f.\n       length ms = length s \\<Longrightarrow>\n       length ms = length s \\<and> length ms = length s", "qed simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (2 subgoals):\n 1. length ms = length s\n 2. length ms' = length s'", "thus \"length ms = length s\" \"length ms' = length s'\""], ["proof (prove)\nusing this:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "by simp_all"], ["proof (state)\nthis:\n  length ms = length s\n  length ms' = length s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_Append:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s''); S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n    \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as @\n         as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "by(induct rule:silent_moves.induct)(auto intro:silent_moves.intros)"], ["", "lemma silent_moves_split:\n  assumes \"S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"\n  obtains ms'' s'' where \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n  and \"S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms'' s''.\n        \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n         S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ms'' s''.\n       S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n       S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "from \\<open>S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "show \"\\<exists>ms'' s''. S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and> S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<exists>ms'' s''.\n       S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n       S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "proof(induct as arbitrary:ms s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s.\n       S,f \\<turnstile> (ms,s) =[] @\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n       \\<exists>ms'' s''.\n          S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n          S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n 2. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "case Nil"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (2 subgoals):\n 1. \\<And>ms s.\n       S,f \\<turnstile> (ms,s) =[] @\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n       \\<exists>ms'' s''.\n          S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n          S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n 2. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "from \\<open>S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"length ms = length s\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s", "by(fastforce intro:silent_moves_equal_length)"], ["proof (state)\nthis:\n  length ms = length s\n\ngoal (2 subgoals):\n 1. \\<And>ms s.\n       S,f \\<turnstile> (ms,s) =[] @\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n       \\<exists>ms'' s''.\n          S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n          S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n 2. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "hence \"S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms,s)\""], ["proof (prove)\nusing this:\n  length ms = length s\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms,s)", "by(rule silent_moves_Nil)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms,s)\n\ngoal (2 subgoals):\n 1. \\<And>ms s.\n       S,f \\<turnstile> (ms,s) =[] @\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n       \\<exists>ms'' s''.\n          S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n          S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n 2. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "with \\<open>S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms,s)", "show ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =[] @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms,s)\n\ngoal (1 subgoal):\n 1. \\<exists>ms'' s''.\n       S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n       S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (ms,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "case (Cons ax asx)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (?ms,?s) =asx @\n                             as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (?ms,?s) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms,s) =(ax # asx) @\n                           as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "note IH = \\<open>\\<And>ms s. S,f \\<turnstile> (ms,s) =asx @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n      \\<exists>ms'' s''. S,f \\<turnstile> (ms,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and> S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (state)\nthis:\n  S,f \\<turnstile> (?ms,?s) =asx @\n                             as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (?ms,?s) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "from \\<open>S,f \\<turnstile> (ms,s) =(ax # asx) @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =(ax # asx) @\n                           as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "obtain msx sx where \"S,f \\<turnstile> (ms,s) -ax\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\"\n      and \"S,f \\<turnstile> (msx,sx) =asx @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =(ax # asx) @\n                           as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>msx sx.\n        \\<lbrakk>S,f \\<turnstile> (ms,s) -ax\\<rightarrow>\\<^sub>\\<tau> (msx,sx);\n         S,f \\<turnstile> (msx,sx) =asx @\n                                    as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:silent_moves.cases)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) -ax\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,f \\<turnstile> (msx,sx) =asx @ as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "from IH[OF this(2)]"], ["proof (chain)\npicking this:\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "obtain ms'' s'' where \"S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\"\n      and \"S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["proof (prove)\nusing this:\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. (\\<And>ms'' s''.\n        \\<lbrakk>S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n         S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "from \\<open>S,f \\<turnstile> (ms,s) -ax\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\\<close> \\<open>S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -ax\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')", "have \"S,f \\<turnstile> (ms,s) =ax#asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -ax\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,f \\<turnstile> (msx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =ax # asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')", "by(rule silent_moves_Cons)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =ax # asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>a as ms s.\n       \\<lbrakk>\\<And>ms s.\n                   S,f \\<turnstile> (ms,s) =as @\n      as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s') \\<Longrightarrow>\n                   \\<exists>ms'' s''.\n                      S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                      S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms,s) =(a # as) @\n                                 as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ms'' s''.\n                            S,f \\<turnstile> (ms,s) =a #\n               as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n                            S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "with \\<open>S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms,s) =ax # asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')", "show ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms,s) =ax # asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<exists>ms'' s''.\n       S,f \\<turnstile> (ms,s) =ax #\n                                asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n       S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "by blast"], ["proof (state)\nthis:\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (ms,s) =ax #\n                              asx\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ms'' s''.\n     S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'') \\<and>\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_nodes_silent_moves:\n  \"\\<lbrakk>S,f\\<turnstile> (ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); \\<forall>m \\<in> set ms. valid_node m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m \\<in> set ms'. valid_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n     Ball (set ms) valid_node\\<rbrakk>\n    \\<Longrightarrow> Ball (set ms') valid_node", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms) valid_node\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        Ball (set ms') valid_node \\<Longrightarrow>\n        Ball (set ms'') valid_node;\n        Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms'') valid_node", "case (silent_moves_Cons S f ms s a ms' s' as ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  Ball (set ms') valid_node \\<Longrightarrow> Ball (set ms'') valid_node\n  Ball (set ms) valid_node\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms) valid_node\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        Ball (set ms') valid_node \\<Longrightarrow>\n        Ball (set ms'') valid_node;\n        Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms'') valid_node", "note IH = \\<open>\\<forall>m\\<in>set ms'. valid_node m \\<Longrightarrow> \\<forall>m\\<in>set ms''. valid_node m\\<close>"], ["proof (state)\nthis:\n  Ball (set ms') valid_node \\<Longrightarrow> Ball (set ms'') valid_node\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms) valid_node\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        Ball (set ms') valid_node \\<Longrightarrow>\n        Ball (set ms'') valid_node;\n        Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms'') valid_node", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close> \\<open>\\<forall>m\\<in>set ms. valid_node m\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  Ball (set ms) valid_node", "have \"\\<forall>m\\<in>set ms'. valid_node m\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  Ball (set ms) valid_node\n\ngoal (1 subgoal):\n 1. Ball (set ms') valid_node", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n     Ball (set ms) valid_node\\<rbrakk>\n    \\<Longrightarrow> Ball (set ms') valid_node", "apply(erule silent_move.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f aa s s' ms S ms'.\n       \\<lbrakk>Ball (set ms) valid_node; S = S; f = f; ms = ms; s = s;\n        a = aa; ms' = ms'; s' = s'; pred (f aa) s; transfer (f aa) s = s';\n        valid_edge aa; intra_kind (kind aa);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode aa;\n        ms' = targetnode aa # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms') valid_node\n 2. \\<And>f aa s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>Ball (set ms) valid_node; S = S; f = f; ms = ms; s = s;\n        a = aa; ms' = ms'; s' = s'; pred (f aa) s; transfer (f aa) s = s';\n        valid_edge aa; kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_edge a'; a' \\<in> get_return_edges aa;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode aa;\n        ms' = targetnode aa # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms') valid_node\n 3. \\<And>f aa s s' Q p f' ms S ms'.\n       \\<lbrakk>Ball (set ms) valid_node; S = S; f = f; ms = ms; s = s;\n        a = aa; ms' = ms'; s' = s'; pred (f aa) s; transfer (f aa) s = s';\n        valid_edge aa; kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode aa;\n        hd (tl ms) = targetnode aa; ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms') valid_node", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x m m'.\n       \\<lbrakk>Ball (set ms) valid_node; ms' = targetnode a # tl ms;\n        pred (f a) s; valid_edge a; intra_kind (kind a);\n        Ball (set (tl ms)) return_node;\n        length (transfer (f a) s) = length s; length ms = length s;\n        hd ms = sourcenode a; s' = transfer (f a) s; x \\<in> set (tl ms);\n        m \\<in> set (tl ms); call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> valid_node x\n 2. \\<And>x.\n       \\<lbrakk>Ball (set ms) valid_node; ms' = targetnode a # tl ms;\n        pred (f a) s; valid_edge a; intra_kind (kind a);\n        Ball (set (tl ms)) return_node;\n        length (transfer (f a) s) = length s; length ms = length s;\n        hd ms = sourcenode a; s' = transfer (f a) s; x \\<in> set (tl ms);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> valid_node x\n 3. \\<And>Q r p fs a' x m m'.\n       \\<lbrakk>Ball (set ms) valid_node;\n        ms' = targetnode a # targetnode a' # tl ms; pred (f a) s;\n        valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_edge a'; a' \\<in> get_return_edges a;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length (transfer (f a) s) = Suc (length s); hd ms = sourcenode a;\n        s' = transfer (f a) s; x \\<in> set (tl ms); m \\<in> set (tl ms);\n        call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> valid_node x\n 4. \\<And>Q r p fs a' x.\n       \\<lbrakk>Ball (set ms) valid_node;\n        ms' = targetnode a # targetnode a' # tl ms; pred (f a) s;\n        valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_edge a'; a' \\<in> get_return_edges a;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length (transfer (f a) s) = Suc (length s); hd ms = sourcenode a;\n        s' = transfer (f a) s; x \\<in> set (tl ms);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> valid_node x\n 5. \\<And>Q p f' m ma m'.\n       \\<lbrakk>Ball (set ms) valid_node; ms' = tl ms; pred (f a) s;\n        valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        Ball (set (tl ms)) return_node;\n        length ms = Suc (length (transfer (f a) s));\n        length s = Suc (length (transfer (f a) s));\n        transfer (f a) s \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; s' = transfer (f a) s;\n        m \\<in> set (tl ms); ma \\<in> set (tl ms); call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> valid_node ma", "by(cases ms,auto dest:get_return_edges_valid)+"], ["proof (state)\nthis:\n  Ball (set ms') valid_node\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms) valid_node\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        Ball (set ms') valid_node \\<Longrightarrow>\n        Ball (set ms'') valid_node;\n        Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms'') valid_node", "from IH[OF this]"], ["proof (chain)\npicking this:\n  Ball (set ms'') valid_node", "show ?case"], ["proof (prove)\nusing this:\n  Ball (set ms'') valid_node\n\ngoal (1 subgoal):\n 1. Ball (set ms'') valid_node", "."], ["proof (state)\nthis:\n  Ball (set ms'') valid_node\n\ngoal (1 subgoal):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; Ball (set ms) valid_node\\<rbrakk>\n       \\<Longrightarrow> Ball (set ms) valid_node", "qed simp"], ["", "lemma return_nodes_silent_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); \\<forall>m \\<in> set (tl ms). return_node m\\<rbrakk>\n  \\<Longrightarrow> \\<forall>m \\<in> set (tl ms'). return_node m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n     Ball (set (tl ms)) return_node\\<rbrakk>\n    \\<Longrightarrow> Ball (set (tl ms')) return_node", "by(induct rule:silent_moves.induct,auto dest:silent_move_return_node)"], ["", "lemma silent_moves_intra_path:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s'); \\<forall>a \\<in> set as. intra_kind(kind a)\\<rbrakk>\n  \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (m #\n                               ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s');\n     \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "proof(induct S f \"m#ms\" s as \"m'#ms'\" s' arbitrary:m\n  rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S f.\n       \\<lbrakk>length (m' # ms) = length s; ms = ms';\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m' = get_proc m'\n 2. \\<And>S f s a ms'a s' as s'' m.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "case (silent_moves_Cons S f sx a msx' sx' as s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s'')\n  \\<lbrakk>msx' = ?m # ms;\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ms = ms' \\<and> get_proc ?m = get_proc m'\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<And>s S f.\n       \\<lbrakk>length (m' # ms) = length s; ms = ms';\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m' = get_proc m'\n 2. \\<And>S f s a ms'a s' as s'' m.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "thus ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s'')\n  \\<lbrakk>msx' = ?m # ms;\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ms = ms' \\<and> get_proc ?m = get_proc m'\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. ms = ms' \\<and> get_proc m = get_proc m'", "proof(induct _ _ \"m # ms\" _ _ _ _ rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "case (silent_move_intra f a s s' n\\<^sub>c msx')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl (m # ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms)\n  \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length s' = length s\n  length (m # ms) = length s\n  hd (m # ms) = sourcenode a\n  msx' = targetnode a # tl (m # ms)\n  n\\<^sub>c,f \\<turnstile> (msx',s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              ms',s'')\n  \\<lbrakk>msx' = ?m # ms;\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ms = ms' \\<and> get_proc ?m = get_proc m'\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "note IH = \\<open>\\<And>m. \\<lbrakk>msx' = m # ms; \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n      \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ms;\n   \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> ms = ms' \\<and> get_proc ?m = get_proc m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "from \\<open>msx' = targetnode a # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  msx' = targetnode a # tl (m # ms)", "have \"msx' = targetnode a # ms\""], ["proof (prove)\nusing this:\n  msx' = targetnode a # tl (m # ms)\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # ms", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "from \\<open>\\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)", "have \"\\<forall>a\\<in>set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # as). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set as. intra_kind (kind a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "from IH[OF \\<open>msx' = targetnode a # ms\\<close> this]"], ["proof (chain)\npicking this:\n  ms = ms' \\<and> get_proc (targetnode a) = get_proc m'", "have \"ms = ms'\" and \"get_proc (targetnode a) = get_proc m'\""], ["proof (prove)\nusing this:\n  ms = ms' \\<and> get_proc (targetnode a) = get_proc m'\n\ngoal (1 subgoal):\n 1. ms = ms' &&& get_proc (targetnode a) = get_proc m'", "by simp_all"], ["proof (state)\nthis:\n  ms = ms'\n  get_proc (targetnode a) = get_proc m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "moreover"], ["proof (state)\nthis:\n  ms = ms'\n  get_proc (targetnode a) = get_proc m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "moreover"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "from \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd (m # ms) = sourcenode a", "have \"m = sourcenode a\""], ["proof (prove)\nusing this:\n  hd (m # ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m = sourcenode a", "by simp"], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "ultimately"], ["proof (chain)\npicking this:\n  ms = ms'\n  get_proc (targetnode a) = get_proc m'\n  get_proc (sourcenode a) = get_proc (targetnode a)\n  m = sourcenode a", "show ?case"], ["proof (prove)\nusing this:\n  ms = ms'\n  get_proc (targetnode a) = get_proc m'\n  get_proc (sourcenode a) = get_proc (targetnode a)\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. ms = ms' \\<and> get_proc m = get_proc m'", "using \\<open>ms = ms'\\<close>"], ["proof (prove)\nusing this:\n  ms = ms'\n  get_proc (targetnode a) = get_proc m'\n  get_proc (sourcenode a) = get_proc (targetnode a)\n  m = sourcenode a\n  ms = ms'\n\ngoal (1 subgoal):\n 1. ms = ms' \\<and> get_proc m = get_proc m'", "by simp"], ["proof (state)\nthis:\n  ms = ms' \\<and> get_proc m = get_proc m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m.\n           \\<lbrakk>ms'a = m # ms;\n            \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n           \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m = get_proc m'", "qed (auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  ms = ms' \\<and> get_proc m = get_proc m'\n\ngoal (1 subgoal):\n 1. \\<And>s S f.\n       \\<lbrakk>length (m' # ms) = length s; ms = ms';\n        \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> ms = ms' \\<and> get_proc m' = get_proc m'", "qed simp"], ["", "lemma silent_moves_nodestack_notempty: \n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); ms \\<noteq> []\\<rbrakk> \\<Longrightarrow> ms' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n     ms \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ms' \\<noteq> []", "apply(induct S f ms s as ms' s' rule:silent_moves.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s; ms \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ms \\<noteq> []\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        ms' \\<noteq> [] \\<Longrightarrow> ms'' \\<noteq> [];\n        ms \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ms'' \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        ms' \\<noteq> [] \\<Longrightarrow> False; ms \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule silent_move.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S f ms s a ms' s' as s'' fa aa sa s'a msa Sa ms'a.\n       \\<lbrakk>S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        ms' \\<noteq> [] \\<Longrightarrow> False; ms \\<noteq> []; S = Sa;\n        f = fa; ms = msa; s = sa; a = aa; ms' = ms'a; s' = s'a;\n        pred (fa aa) sa; transfer (fa aa) sa = s'a; valid_edge aa;\n        intra_kind (kind aa);\n        (\\<exists>m\\<in>set (tl msa).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd msa \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl msa)) return_node; length s'a = length sa;\n        length msa = length sa; hd msa = sourcenode aa;\n        ms'a = targetnode aa # tl msa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S f ms s a ms' s' as s'' fa aa sa s'a Q r p fs a' msa Sa ms'a.\n       \\<lbrakk>S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        ms' \\<noteq> [] \\<Longrightarrow> False; ms \\<noteq> []; S = Sa;\n        f = fa; ms = msa; s = sa; a = aa; ms' = ms'a; s' = s'a;\n        pred (fa aa) sa; transfer (fa aa) sa = s'a; valid_edge aa;\n        kind aa = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges aa;\n        (\\<exists>m\\<in>set (tl msa).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     Sa\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd msa \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl msa)) return_node; length msa = length sa;\n        length s'a = Suc (length sa); hd msa = sourcenode aa;\n        ms'a = targetnode aa # targetnode a' # tl msa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S f ms s a ms' s' as s'' fa aa sa s'a Q p f' msa Sa ms'a.\n       \\<lbrakk>S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        ms' \\<noteq> [] \\<Longrightarrow> False; ms \\<noteq> []; S = Sa;\n        f = fa; ms = msa; s = sa; a = aa; ms' = ms'a; s' = s'a;\n        pred (fa aa) sa; transfer (fa aa) sa = s'a; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl msa).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl msa)) return_node; length msa = length sa;\n        length sa = Suc (length s'a); s'a \\<noteq> [];\n        hd msa = sourcenode aa; hd (tl msa) = targetnode aa;\n        ms'a = tl msa\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as s'' fa aa sa Q p f' msa Sa m m'.\n       \\<lbrakk>Sa,fa \\<turnstile> (tl msa,transfer (fa aa)\n      sa) =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        tl msa \\<noteq> [] \\<Longrightarrow> False; msa \\<noteq> [];\n        pred (fa aa) sa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        Ball (set (tl msa)) return_node;\n        length msa = Suc (length (transfer (fa aa) sa));\n        length sa = Suc (length (transfer (fa aa) sa));\n        transfer (fa aa) sa \\<noteq> []; hd msa = sourcenode aa;\n        hd (tl msa) = targetnode aa; m \\<in> set (tl msa);\n        call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice\n                              Sa\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"tl msa\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>as s'' fa aa sa Q p f' msa Sa m m'.\n       \\<lbrakk>Sa,fa \\<turnstile> (tl msa,transfer (fa aa)\n      sa) =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        tl msa \\<noteq> [] \\<Longrightarrow> False; msa \\<noteq> [];\n        pred (fa aa) sa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        Ball (set (tl msa)) return_node;\n        length msa = Suc (length (transfer (fa aa) sa));\n        length sa = Suc (length (transfer (fa aa) sa));\n        transfer (fa aa) sa \\<noteq> []; hd msa = sourcenode aa;\n        hd (tl msa) = targetnode aa; m \\<in> set (tl msa);\n        call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        tl msa = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>as s'' fa aa sa Q p f' msa Sa m m' a list.\n       \\<lbrakk>Sa,fa \\<turnstile> (tl msa,transfer (fa aa)\n      sa) =as\\<Rightarrow>\\<^sub>\\<tau> ([],s'');\n        tl msa \\<noteq> [] \\<Longrightarrow> False; msa \\<noteq> [];\n        pred (fa aa) sa; valid_edge aa;\n        kind aa = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        Ball (set (tl msa)) return_node;\n        length msa = Suc (length (transfer (fa aa) sa));\n        length sa = Suc (length (transfer (fa aa) sa));\n        transfer (fa aa) sa \\<noteq> []; hd msa = sourcenode aa;\n        hd (tl msa) = targetnode aa; m \\<in> set (tl msa);\n        call_of_return_node m m';\n        m' \\<notin> \\<lfloor>HRB_slice Sa\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        tl msa = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "by auto"], ["", "lemma silent_moves_obs_slice:\n  \"\\<lbrakk>S,kind \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \n  \\<forall>n \\<in> set (tl ms'). return_node n\\<rbrakk>\n  \\<Longrightarrow> mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and> (\\<forall>n \\<in> set (tl ms). return_node n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n     mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     Ball (set (tl ms')) return_node\\<rbrakk>\n    \\<Longrightarrow> mx \\<in> obs ms\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                      Ball (set (tl ms)) return_node", "proof(induct S f\\<equiv>\"kind\" ms s as ms' s' rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S.\n       \\<lbrakk>length ms = length s;\n        mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node\n 2. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "case silent_moves_Nil"], ["proof (state)\nthis:\n  length ms_ = length s_\n  mx \\<in> obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms_)) return_node\n\ngoal (2 subgoals):\n 1. \\<And>ms s S.\n       \\<lbrakk>length ms = length s;\n        mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node\n 2. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "thus ?case"], ["proof (prove)\nusing this:\n  length ms_ = length s_\n  mx \\<in> obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms_)) return_node\n\ngoal (1 subgoal):\n 1. mx \\<in> obs ms_\n              \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n    Ball (set (tl ms_)) return_node", "by simp"], ["proof (state)\nthis:\n  mx \\<in> obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n  Ball (set (tl ms_)) return_node\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "case (silent_moves_Cons S ms s a ms' s' as ms'' s'')"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  \\<lbrakk>mx \\<in> obs ms''\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   Ball (set (tl ms'')) return_node\\<rbrakk>\n  \\<Longrightarrow> mx \\<in> obs ms'\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                    Ball (set (tl ms')) return_node\n  mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms'')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "note IH = \\<open>\\<lbrakk>mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; \\<forall>m\\<in>set (tl ms''). return_node m\\<rbrakk>\n    \\<Longrightarrow> mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and> (\\<forall>m\\<in>set (tl ms'). return_node m)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>mx \\<in> obs ms''\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   Ball (set (tl ms'')) return_node\\<rbrakk>\n  \\<Longrightarrow> mx \\<in> obs ms'\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                    Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "from IH[OF \\<open>mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>\\<forall>m\\<in>set (tl ms''). return_node m\\<close>]"], ["proof (chain)\npicking this:\n  mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n  Ball (set (tl ms')) return_node", "have \"mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"\\<forall>m\\<in>set (tl ms'). return_node m\""], ["proof (prove)\nusing this:\n  mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n  Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> &&&\n    Ball (set (tl ms')) return_node", "by simp_all"], ["proof (state)\nthis:\n  mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "with \\<open>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node", "have \"mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  mx \\<in> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n\ngoal (1 subgoal):\n 1. mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:silent_move_obs_slice)"], ["proof (state)\nthis:\n  mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "moreover"], ["proof (state)\nthis:\n  mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "from \\<open>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"\\<forall>m\\<in>set (tl ms). return_node m\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms)) return_node", "by(fastforce elim:silent_move.cases)"], ["proof (state)\nthis:\n  Ball (set (tl ms)) return_node\n\ngoal (1 subgoal):\n 1. \\<And>S ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,kind \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,kind \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        \\<lbrakk>mx \\<in> obs ms''\n                           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         Ball (set (tl ms'')) return_node\\<rbrakk>\n        \\<Longrightarrow> mx \\<in> obs ms'\n                                    \\<lfloor>HRB_slice\n        S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                          Ball (set (tl ms')) return_node;\n        mx \\<in> obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms'')) return_node\\<rbrakk>\n       \\<Longrightarrow> mx \\<in> obs ms\n                                   \\<lfloor>HRB_slice\n       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         Ball (set (tl ms)) return_node", "ultimately"], ["proof (chain)\npicking this:\n  mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node", "show ?case"], ["proof (prove)\nusing this:\n  mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms)) return_node\n\ngoal (1 subgoal):\n 1. mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n    Ball (set (tl ms)) return_node", "by simp"], ["proof (state)\nthis:\n  mx \\<in> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n  Ball (set (tl ms)) return_node\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_empty_obs_slice:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<rbrakk>\n  \\<Longrightarrow> obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n     obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> obs ms\n                       \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                      {}", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "case silent_moves_Nil"], ["proof (state)\nthis:\n  length ms_ = length s_\n  obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       \\<lbrakk>length ms = length s;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "thus ?case"], ["proof (prove)\nusing this:\n  length ms_ = length s_\n  obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "by simp"], ["proof (state)\nthis:\n  obs ms_ \\<lfloor>HRB_slice S_\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "case (silent_moves_Cons S f ms s a ms' s' as ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {} \\<Longrightarrow>\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "note IH = \\<open>obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {} \\<Longrightarrow> obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (state)\nthis:\n  obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {} \\<Longrightarrow>\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "from IH[OF \\<open>obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>]"], ["proof (chain)\npicking this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "have \"obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "by simp"], ["proof (state)\nthis:\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {} \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        obs ms'' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> obs ms\n                          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                         {}", "with \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "show ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "by -(rule silent_move_empty_obs_slice,fastforce)"], ["proof (state)\nthis:\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_preds_transfers:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"\n  shows \"preds (map f as) s\" and \"transfers (map f as) s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (map f as) s &&& transfers (map f as) s = s'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. preds (map f as) s\n 2. transfers (map f as) s = s'", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"preds (map f as) s \\<and> transfers (map f as) s = s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. preds (map f as) s \\<and> transfers (map f as) s = s'", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       length ms = length s \\<Longrightarrow>\n       preds (map f []) s \\<and> transfers (map f []) s = s\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s''", "case silent_moves_Nil"], ["proof (state)\nthis:\n  length ms_ = length s_\n\ngoal (2 subgoals):\n 1. \\<And>ms s S f.\n       length ms = length s \\<Longrightarrow>\n       preds (map f []) s \\<and> transfers (map f []) s = s\n 2. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s''", "thus ?case"], ["proof (prove)\nusing this:\n  length ms_ = length s_\n\ngoal (1 subgoal):\n 1. preds (map f_ []) s_ \\<and> transfers (map f_ []) s_ = s_", "by simp"], ["proof (state)\nthis:\n  preds (map f_ []) s_ \\<and> transfers (map f_ []) s_ = s_\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s''", "case (silent_moves_Cons S f ms s a ms' s' as ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'')\n  preds (map f as) s' \\<and> transfers (map f as) s' = s''\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s''", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"pred (f a) s\" and \"transfer (f a) s = s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. pred (f a) s &&& transfer (f a) s = s'", "by(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s a ms' s' as ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n        preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s''", "with \\<open>preds (map f as) s' \\<and> transfers (map f as) s' = s''\\<close>"], ["proof (chain)\npicking this:\n  preds (map f as) s' \\<and> transfers (map f as) s' = s''\n  pred (f a) s\n  transfer (f a) s = s'", "show ?case"], ["proof (prove)\nusing this:\n  preds (map f as) s' \\<and> transfers (map f as) s' = s''\n  pred (f a) s\n  transfer (f a) s = s'\n\ngoal (1 subgoal):\n 1. preds (map f (a # as)) s \\<and> transfers (map f (a # as)) s = s''", "by fastforce"], ["proof (state)\nthis:\n  preds (map f (a # as)) s \\<and> transfers (map f (a # as)) s = s''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  preds (map f as) s \\<and> transfers (map f as) s = s'\n\ngoal (2 subgoals):\n 1. preds (map f as) s\n 2. transfers (map f as) s = s'", "thus \"preds (map f as) s\" and \"transfers (map f as) s = s'\""], ["proof (prove)\nusing this:\n  preds (map f as) s \\<and> transfers (map f as) s = s'\n\ngoal (1 subgoal):\n 1. preds (map f as) s &&& transfers (map f as) s = s'", "by simp_all"], ["proof (state)\nthis:\n  preds (map f as) s\n  transfers (map f as) s = s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_intra_path_obs:\n  assumes \"m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" and \"length s = length (m#msx')\"\n  and \"\\<forall>m \\<in> set msx'. return_node m\"\n  obtains as' where \"S,slice_kind S \\<turnstile> (m#msx',s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        S,slice_kind\n           S \\<turnstile> (m #\n                           msx',s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                             msx',s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            msx',s)", "from \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n         m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule obs_intraE)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            msx',s)", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "obtain x where \"distance m m' x\" and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance m m' x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance m m' x\n  x \\<le> length as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            msx',s)", "from \\<open>distance m m' x\\<close> \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>length s = length (m#msx')\\<close> \\<open>\\<forall>m \\<in> set msx'. return_node m\\<close>"], ["proof (chain)\npicking this:\n  distance m m' x\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s = length (m # msx')\n  Ball (set msx') return_node", "show \"\\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  distance m m' x\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s = length (m # msx')\n  Ball (set msx') return_node\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "proof(induct x arbitrary:m s rule:nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix s::\"(('var \\<rightharpoonup> 'val) \\<times> 'ret) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "assume \"distance m m' 0\" and \"length s = length (m#msx')\""], ["proof (state)\nthis:\n  distance m m' 0\n  length s = length (m # msx')\n\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "then"], ["proof (chain)\npicking this:\n  distance m m' 0\n  length s = length (m # msx')", "obtain as' where \"m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"length as' = 0\""], ["proof (prove)\nusing this:\n  distance m m' 0\n  length s = length (m # msx')\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>m -as'\\<rightarrow>\\<^sub>\\<iota>* m';\n         length as' = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance.cases)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\n  length as' = 0\n\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "hence \"m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\n  length as' = 0\n\ngoal (1 subgoal):\n 1. m -[]\\<rightarrow>\\<^sub>\\<iota>* m'", "by(cases as) auto"], ["proof (state)\nthis:\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "hence [simp]:\"m = m'\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m = m'", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  m = m'\n\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with \\<open>length s = length (m#msx')\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  length (m # msx') = length s\n  m = m'", "have \"S,slice_kind S \\<turnstile> (m#msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m#msx',s)\""], ["proof (prove)\nusing this:\n  length (m # msx') = length s\n  m = m'\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (m #\n                       msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m # msx',s)", "by -(rule silent_moves_Nil)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (m # msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m # msx',s)\n\ngoal (2 subgoals):\n 1. \\<And>m s.\n       \\<lbrakk>distance m m' 0;\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "thus \"\\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m # msx',s)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (m #\n                        msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix x m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix s::\"(('var \\<rightharpoonup> 'val) \\<times> 'ret) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "assume \"distance m m' (Suc x)\" and \"m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n      and \"length s = length (m#msx')\" and \"\\<forall>m \\<in> set msx'. return_node m\"\n      and IH:\"\\<And>m s. \\<lbrakk>distance m m' x; m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                     length s = length (m#msx'); \\<forall>m \\<in> set msx'. return_node m\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (state)\nthis:\n  distance m m' (Suc x)\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s = length (m # msx')\n  Ball (set msx') return_node\n  \\<lbrakk>distance ?m m' x;\n   m' \\<in> obs_intra ?m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   length ?s = length (?m # msx'); Ball (set msx') return_node\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as.\n                       S,slice_kind\n                          S \\<turnstile> (?m #\n    msx',?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',?s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. valid_node m", "by(rule in_obs_intra_valid)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with \\<open>distance m m' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance m m' (Suc x)\n  valid_node m", "have \"m \\<noteq> m'\""], ["proof (prove)\nusing this:\n  distance m m' (Suc x)\n  valid_node m\n\ngoal (1 subgoal):\n 1. m \\<noteq> m'", "by(fastforce elim:distance.cases dest:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "have \"m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume isin:\"m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\""], ["proof (prove)\nusing this:\n  valid_node m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m \\<noteq> m'\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<noteq> m'\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "show False"], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m \\<noteq> m'\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>distance m m' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance m m' (Suc x)", "obtain a where \"valid_edge a\" and \"m = sourcenode a\"\n      and \"intra_kind(kind a)\" and \"distance (targetnode a) m' x\"\n      and target:\"targetnode a = (SOME mx. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               distance (targetnode a') m' x \\<and>\n                                               valid_edge a' \\<and> intra_kind (kind a') \\<and> \n                                               targetnode a' = mx)\""], ["proof (prove)\nusing this:\n  distance m m' (Suc x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; m = sourcenode a; intra_kind (kind a);\n         distance (targetnode a) m' x;\n         targetnode a =\n         (SOME mx.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m' x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule distance_successor_distance,simp+)"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a\n  intra_kind (kind a)\n  distance (targetnode a) m' x\n  targetnode a =\n  (SOME mx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = mx)\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\""], ["proof (prove)\nusing this:\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}", "by(rule obs_intra_singleton_element)"], ["proof (state)\nthis:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with \\<open>valid_edge a\\<close> \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close> \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  intra_kind (kind a)\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}", "have disj:\"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {} \\<or> \n               obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  intra_kind (kind a)\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m'}\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<or>\n    obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {m'}", "by -(drule_tac S=\"\\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" in edge_obs_intra_subset,auto)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {} \\<or>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {m'}\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>intra_kind(kind a)\\<close> \\<open>length s = length (m#msx')\\<close> \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n      \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  length s = length (m # msx')\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a", "have length:\"length (transfer (slice_kind S a) s) = length (targetnode a#msx')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  length s = length (m # msx')\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = length (targetnode a # msx')", "by(cases s)\n    (auto split:if_split_asm simp add:Let_def slice_kind_def intra_kind_def)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = length (targetnode a # msx')\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>distance (targetnode a) m' x\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) m' x", "obtain asx where \"targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\" \n      and \"length asx = x\" and \"\\<forall>as'. targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<longrightarrow> x \\<le> length as'\""], ["proof (prove)\nusing this:\n  distance (targetnode a) m' x\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m';\n         length asx = x;\n         \\<forall>as'.\n            targetnode\n             a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<longrightarrow>\n            x \\<le> length as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance.cases)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  length asx = x\n  \\<forall>as'.\n     targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<longrightarrow>\n     x \\<le> length as'\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain mx where \"mx \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>mx.\n        mx \\<in> obs_intra (targetnode a)\n                  \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule path_ex_obs_intra)"], ["proof (state)\nthis:\n  mx \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with disj"], ["proof (chain)\npicking this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {} \\<or>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {m'}\n  mx \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"m' \\<in> obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {} \\<or>\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {m'}\n  mx \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m' \\<in> obs_intra (targetnode a)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  m' \\<in> obs_intra (targetnode a)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from IH[OF \\<open>distance (targetnode a) m' x\\<close> this length \n      \\<open>\\<forall>m \\<in> set msx'. return_node m\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (targetnode a #\n                        msx',transfer (slice_kind S a)\n                              s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          msx',transfer (slice_kind S a) s)", "obtain asx' where moves:\"S,slice_kind S \\<turnstile> \n      (targetnode a#msx',transfer (slice_kind S a) s) =asx'\\<Rightarrow>\\<^sub>\\<tau> \n      (m'#msx',transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (targetnode a #\n                        msx',transfer (slice_kind S a)\n                              s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        S,slice_kind\n           S \\<turnstile> (targetnode a #\n                           msx',transfer (slice_kind S a)\n                                 s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               msx',transfer (slice_kind S a)\n                                     s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (targetnode a #\n                     msx',transfer (slice_kind S a)\n                           s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                         msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "have \"pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "proof(cases \"kind a\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix f"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = \\<Up>f\""], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  kind a = \\<Up>f", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by(fastforce intro:slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>length s = length (m#msx')\\<close>"], ["proof (chain)\npicking this:\n  length s = length (m # msx')\n  slice_kind S a = \\<Up>id", "show ?thesis"], ["proof (prove)\nusing this:\n  length s = length (m # msx')\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by(cases s) auto"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix Q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = (Q)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>distance (targetnode a) m' x\\<close>\n        \\<open>distance m m' (Suc x)\\<close> target"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m' x\n  distance m m' (Suc x)\n  targetnode a =\n  (SOME mx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = mx)\n  kind a = (Q)\\<^sub>\\<surd>", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  m' \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  distance (targetnode a) m' x\n  distance m m' (Suc x)\n  targetnode a =\n  (SOME mx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = mx)\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>length s = length (m#msx')\\<close>"], ["proof (chain)\npicking this:\n  length s = length (m # msx')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  length s = length (m # msx')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by(cases s) auto"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix Q r p fs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(simp add:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix Q p f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(simp add:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "hence \"pred (slice_kind S a) s\" and \"transfer (slice_kind S a) s = s\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s &&& transfer (slice_kind S a) s = s", "by simp_all"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close> \\<open>valid_edge a\\<close>\n      \\<open>intra_kind(kind a)\\<close> \\<open>length s = length (m#msx')\\<close> \\<open>\\<forall>m \\<in> set msx'. return_node m\\<close>"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  valid_edge a\n  intra_kind (kind a)\n  length s = length (m # msx')\n  Ball (set msx') return_node\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s", "have \"S,slice_kind S \\<turnstile> (sourcenode a#msx',s) -a\\<rightarrow>\\<^sub>\\<tau> \n                             (targetnode a#msx',transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  valid_edge a\n  intra_kind (kind a)\n  length s = length (m # msx')\n  Ball (set msx') return_node\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (sourcenode a #\n                       msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                       msx',transfer (slice_kind S a) s)", "by(fastforce intro:silent_move_intra)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (sourcenode a #\n                     msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with moves \\<open>transfer (slice_kind S a) s = s\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (targetnode a #\n                     msx',transfer (slice_kind S a)\n                           s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                         msx',transfer (slice_kind S a) s)\n  transfer (slice_kind S a) s = s\n  m = sourcenode a\n  S,slice_kind\n     S \\<turnstile> (sourcenode a #\n                     msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     msx',transfer (slice_kind S a) s)", "have \"S,slice_kind S \\<turnstile> (m#msx',s) =a#asx'\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (targetnode a #\n                     msx',transfer (slice_kind S a)\n                           s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                         msx',transfer (slice_kind S a) s)\n  transfer (slice_kind S a) s = s\n  m = sourcenode a\n  S,slice_kind\n     S \\<turnstile> (sourcenode a #\n                     msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (m #\n                       msx',s) =a #\n                                asx'\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "by(fastforce intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =a #\n                              asx'\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m s.\n       \\<lbrakk>\\<And>m s.\n                   \\<lbrakk>distance m m' nat;\n                    m' \\<in> obs_intra m\n                              \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat);\n        m' \\<in> obs_intra m\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "thus \"\\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =a #\n                              asx'\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (m #\n                        msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (m #\n                        msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_intra_path_no_obs:\n  assumes \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" and \"method_exit m'\"\n  and \"get_proc m = get_proc m'\" and \"valid_node m\" and \"length s = length (m#msx')\"\n  and \"\\<forall>m \\<in> set msx'. return_node m\"\n  obtains as where \"S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (m #\n                           msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            msx',s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "from \\<open>method_exit m'\\<close> \\<open>get_proc m = get_proc m'\\<close> \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  method_exit m'\n  get_proc m = get_proc m'\n  valid_node m", "obtain as where \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  method_exit m'\n  get_proc m = get_proc m'\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        m -as\\<rightarrow>\\<^sub>\\<iota>* m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule intra_path_to_matching_method_exit)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "then"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "obtain x where \"distance m m' x\" and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance m m' x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance m m' x\n  x \\<le> length as\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "from \\<open>distance m m' x\\<close> \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>\n    \\<open>length s = length (m#msx')\\<close> \\<open>\\<forall>m \\<in> set msx'. return_node m\\<close>"], ["proof (chain)\npicking this:\n  distance m m' x\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  length s = length (m # msx')\n  Ball (set msx') return_node", "show \"\\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  distance m m' x\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  length s = length (m # msx')\n  Ball (set msx') return_node\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "proof(induct x arbitrary:m as s rule:nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix s::\"(('var \\<rightharpoonup> 'val) \\<times> 'ret) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "assume \"distance m m' 0\" and \"length s = length (m#msx')\""], ["proof (state)\nthis:\n  distance m m' 0\n  length s = length (m # msx')\n\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "then"], ["proof (chain)\npicking this:\n  distance m m' 0\n  length s = length (m # msx')", "obtain as' where \"m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\" and \"length as' = 0\""], ["proof (prove)\nusing this:\n  distance m m' 0\n  length s = length (m # msx')\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>m -as'\\<rightarrow>\\<^sub>\\<iota>* m';\n         length as' = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance.cases)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\n  length as' = 0\n\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "hence \"m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>\\<^sub>\\<iota>* m'\n  length as' = 0\n\ngoal (1 subgoal):\n 1. m -[]\\<rightarrow>\\<^sub>\\<iota>* m'", "by(cases as) auto"], ["proof (state)\nthis:\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "hence [simp]:\"m = m'\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. m = m'", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  m = m'\n\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with \\<open>length s = length (m#msx')\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  length (m # msx') = length s\n  m = m'", "have \"S,slice_kind S \\<turnstile> (m#msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m#msx',s)\""], ["proof (prove)\nusing this:\n  length (m # msx') = length s\n  m = m'\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (m #\n                       msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m # msx',s)", "by(fastforce intro:silent_moves_Nil)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (m # msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m # msx',s)\n\ngoal (2 subgoals):\n 1. \\<And>m as s.\n       \\<lbrakk>distance m m' 0; m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n 2. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "thus \"\\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m # msx',s) =[]\\<Rightarrow>\\<^sub>\\<tau> (m # msx',s)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (m #\n                        msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix x m as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "fix s::\"(('var \\<rightharpoonup> 'val) \\<times> 'ret) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "assume \"distance m m' (Suc x)\" and \"m -as\\<rightarrow>\\<^sub>\\<iota>* m'\"\n      and \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\"\n      and \"length s = length (m#msx')\" and \"\\<forall>m \\<in> set msx'. return_node m\"\n      and IH:\"\\<And>m as s. \\<lbrakk>distance m m' x; m -as\\<rightarrow>\\<^sub>\\<iota>* m'; \n      obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}; length s = length (m#msx'); \n      \\<forall>m \\<in> set msx'. return_node m\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (state)\nthis:\n  distance m m' (Suc x)\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  length s = length (m # msx')\n  Ball (set msx') return_node\n  \\<lbrakk>distance ?m m' x; ?m -?as\\<rightarrow>\\<^sub>\\<iota>* m';\n   obs_intra ?m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n   length ?s = length (?m # msx'); Ball (set msx') return_node\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as.\n                       S,slice_kind\n                          S \\<turnstile> (?m #\n    msx',?s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',?s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. valid_node m", "by(fastforce intro:path_valid_node simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'", "have \"get_proc m = get_proc m'\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* m'\n\ngoal (1 subgoal):\n 1. get_proc m = get_proc m'", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc m = get_proc m'\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "have \"m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume \"m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\""], ["proof (prove)\nusing this:\n  valid_node m\n  m \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. m \\<in> \\<lfloor>HRB_slice\n                      S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}", "show False"], ["proof (prove)\nusing this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {m}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>distance m m' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance m m' (Suc x)", "obtain a where \"valid_edge a\" and \"m = sourcenode a\"\n      and \"intra_kind(kind a)\" and \"distance (targetnode a) m' x\"\n      and target:\"targetnode a = (SOME mx. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               distance (targetnode a') m' x \\<and>\n                                               valid_edge a' \\<and> intra_kind (kind a') \\<and> \n                                               targetnode a' = mx)\""], ["proof (prove)\nusing this:\n  distance m m' (Suc x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; m = sourcenode a; intra_kind (kind a);\n         distance (targetnode a) m' x;\n         targetnode a =\n         (SOME mx.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m' x \\<and>\n                valid_edge a' \\<and>\n                intra_kind (kind a') \\<and> targetnode a' = mx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule distance_successor_distance,simp+)"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a\n  intra_kind (kind a)\n  distance (targetnode a) m' x\n  targetnode a =\n  (SOME mx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = mx)\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>intra_kind(kind a)\\<close> \\<open>length s = length (m#msx')\\<close> \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n      \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  length s = length (m # msx')\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a", "have length:\"length (transfer (slice_kind S a) s) = length (targetnode a#msx')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  length s = length (m # msx')\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = length (targetnode a # msx')", "by(cases s)\n    (auto split:if_split_asm simp add:Let_def slice_kind_def intra_kind_def)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = length (targetnode a # msx')\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>distance (targetnode a) m' x\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) m' x", "obtain asx where \"targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\" \n      and \"length asx = x\" and \"\\<forall>as'. targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<longrightarrow> x \\<le> length as'\""], ["proof (prove)\nusing this:\n  distance (targetnode a) m' x\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m';\n         length asx = x;\n         \\<forall>as'.\n            targetnode\n             a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<longrightarrow>\n            x \\<le> length as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance.cases)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\n  length asx = x\n  \\<forall>as'.\n     targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* m' \\<longrightarrow>\n     x \\<le> length as'\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from \\<open>valid_edge a\\<close> \\<open>intra_kind(kind a)\\<close> \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n      \\<open>m = sourcenode a\\<close> \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {}", "by(fastforce dest:edge_obs_intra_subset)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "from IH[OF \\<open>distance (targetnode a) m' x\\<close> \\<open>targetnode a -asx\\<rightarrow>\\<^sub>\\<iota>* m'\\<close> this\n      length \\<open>\\<forall>m \\<in> set msx'. return_node m\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (targetnode a #\n                        msx',transfer (slice_kind S a)\n                              s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          msx',transfer (slice_kind S a) s)", "obtain as' \n      where moves:\"S,slice_kind S \\<turnstile> \n      (targetnode a#msx',transfer (slice_kind S a) s) =as'\\<Rightarrow>\\<^sub>\\<tau> \n      (m'#msx',transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (targetnode a #\n                        msx',transfer (slice_kind S a)\n                              s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                          msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        S,slice_kind\n           S \\<turnstile> (targetnode a #\n                           msx',transfer (slice_kind S a)\n                                 s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                              msx',transfer (slice_kind S a)\n                                    s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (targetnode a #\n                     msx',transfer (slice_kind S a)\n                           s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "have \"pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "proof(cases \"kind a\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix f"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = \\<Up>f\""], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  kind a = \\<Up>f", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by(fastforce intro:slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 4. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>length s = length (m#msx')\\<close>"], ["proof (chain)\npicking this:\n  length s = length (m # msx')\n  slice_kind S a = \\<Up>id", "show ?thesis"], ["proof (prove)\nusing this:\n  length s = length (m # msx')\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by(cases s) auto"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix Q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = (Q)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close>\n        \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close> \\<open>distance (targetnode a) m' x\\<close>\n        \\<open>distance m m' (Suc x)\\<close> \\<open>method_exit m'\\<close> \\<open>get_proc m = get_proc m'\\<close> target"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  distance (targetnode a) m' x\n  distance m m' (Suc x)\n  method_exit m'\n  get_proc m = get_proc m'\n  targetnode a =\n  (SOME mx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = mx)\n  kind a = (Q)\\<^sub>\\<surd>", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  distance (targetnode a) m' x\n  distance m m' (Suc x)\n  method_exit m'\n  get_proc m = get_proc m'\n  targetnode a =\n  (SOME mx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m' x \\<and>\n         valid_edge a' \\<and>\n         intra_kind (kind a') \\<and> targetnode a' = mx)\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_empty_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 3. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>length s = length (m#msx')\\<close>"], ["proof (chain)\npicking this:\n  length s = length (m # msx')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  length s = length (m # msx')\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by(cases s) auto"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix Q r p fs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(simp add:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       kind a =\n       x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "fix Q p f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "assume \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(simp add:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x41 x42 x43.\n       kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "hence \"pred (slice_kind S a) s\" and \"transfer (slice_kind S a) s = s\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s &&& transfer (slice_kind S a) s = s", "by simp_all"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with \\<open>m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>m = sourcenode a\\<close> \\<open>valid_edge a\\<close>\n      \\<open>intra_kind(kind a)\\<close> \\<open>length s = length (m#msx')\\<close> \\<open>\\<forall>m \\<in> set msx'. return_node m\\<close>"], ["proof (chain)\npicking this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  valid_edge a\n  intra_kind (kind a)\n  length s = length (m # msx')\n  Ball (set msx') return_node\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s", "have \"S,slice_kind S \\<turnstile> (sourcenode a#msx',s) -a\\<rightarrow>\\<^sub>\\<tau> \n                             (targetnode a#msx',transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  m \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  m = sourcenode a\n  valid_edge a\n  intra_kind (kind a)\n  length s = length (m # msx')\n  Ball (set msx') return_node\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (sourcenode a #\n                       msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                       msx',transfer (slice_kind S a) s)", "by(fastforce intro:silent_move_intra)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (sourcenode a #\n                     msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "with moves \\<open>transfer (slice_kind S a) s = s\\<close> \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (targetnode a #\n                     msx',transfer (slice_kind S a)\n                           s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        msx',transfer (slice_kind S a) s)\n  transfer (slice_kind S a) s = s\n  m = sourcenode a\n  S,slice_kind\n     S \\<turnstile> (sourcenode a #\n                     msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     msx',transfer (slice_kind S a) s)", "have \"S,slice_kind S \\<turnstile> (m#msx',s) =a#as'\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (targetnode a #\n                     msx',transfer (slice_kind S a)\n                           s) =as'\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                        msx',transfer (slice_kind S a) s)\n  transfer (slice_kind S a) s = s\n  m = sourcenode a\n  S,slice_kind\n     S \\<turnstile> (sourcenode a #\n                     msx',s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a #\n                     msx',transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (m #\n                       msx',s) =a #\n                                as'\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "by(fastforce intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal (1 subgoal):\n 1. \\<And>nat m as s.\n       \\<lbrakk>\\<And>m as s.\n                   \\<lbrakk>distance m m' nat;\n                    m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n                    obs_intra m\n                     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n                    {};\n                    length s = length (m # msx');\n                    Ball (set msx') return_node\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s);\n        distance m m' (Suc nat); m -as\\<rightarrow>\\<^sub>\\<iota>* m';\n        obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {};\n        length s = length (m # msx'); Ball (set msx') return_node\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (m #\n         msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)", "thus \"\\<exists>as. S,slice_kind S \\<turnstile> (m#msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#msx',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (m #\n                     msx',s) =a #\n                              as'\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (m #\n                          msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                           msx',s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (m #\n                        msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (m #\n                        msx',s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # msx',s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_vpa_path:\n  assumes \"S,f \\<turnstile> (m#ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m'#ms',s')\" and \"valid_node m\"\n  and \"\\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i)\" \n  and \"ms = targetnodes rs\" and \"valid_return_list rs m\"\n  and \"length rs = length cs\"\n  shows \"m -as\\<rightarrow>* m'\" and \"valid_path_aux cs as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m' &&& valid_path_aux cs as", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. m -as\\<rightarrow>* m'\n 2. valid_path_aux cs as", "from assms"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs", "have \"m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s')\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as", "proof(induct S f \"m#ms\" s as \"m'#ms'\" s' arbitrary:m cs ms rs\n      rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms' = targetnodes rs; valid_return_list rs m';\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m' -[]\\<rightarrow>* m' \\<and> valid_path_aux cs []\n 2. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "case (silent_moves_Nil msx sx n\\<^sub>c f)"], ["proof (state)\nthis:\n  length (m' # ms') = length msx\n  valid_node m'\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (f ! i)\n  ms' = targetnodes rs\n  valid_return_list rs m'\n  length rs = length f\n\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms' = targetnodes rs; valid_return_list rs m';\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m' -[]\\<rightarrow>* m' \\<and> valid_path_aux cs []\n 2. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_node m'\\<close>"], ["proof (chain)\npicking this:\n  valid_node m'", "have \"m' -[]\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_node m'\n\ngoal (1 subgoal):\n 1. m' -[]\\<rightarrow>* m'", "by (rule empty_path)"], ["proof (state)\nthis:\n  m' -[]\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>s S f cs rs.\n       \\<lbrakk>length (m' # ms') = length s; valid_node m';\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms' = targetnodes rs; valid_return_list rs m';\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m' -[]\\<rightarrow>* m' \\<and> valid_path_aux cs []\n 2. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "thus ?case"], ["proof (prove)\nusing this:\n  m' -[]\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m' -[]\\<rightarrow>* m' \\<and> valid_path_aux f []", "by fastforce"], ["proof (state)\nthis:\n  m' -[]\\<rightarrow>* m' \\<and> valid_path_aux f []\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "case (silent_moves_Cons S f sx a msx' sx' as s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. \\<And>S f s a ms'a s' as s'' m ms cs rs.\n       \\<lbrakk>S,f \\<turnstile> (m #\n                                  ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'a,s');\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms cs rs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "thus ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (m # ms,sx) -a\\<rightarrow>\\<^sub>\\<tau> (msx',sx')\n  S,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' # ms',s'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)", "proof(induct _ _ \"m # ms\" _ _ _ _ rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "case (silent_move_intra f a sx sx' n\\<^sub>c msx')"], ["proof (state)\nthis:\n  pred (f a) sx\n  transfer (f a) sx = sx'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl (m # ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms)\n  \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length sx' = length sx\n  length (m # ms) = length sx\n  hd (m # ms) = sourcenode a\n  msx' = targetnode a # tl (m # ms)\n  n\\<^sub>c,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               ms',s'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "note IH = \\<open>\\<And>m cs ms rs. \\<lbrakk>msx' = m # ms; valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); \n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n        \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>msx' = targetnode a # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  msx' = targetnode a # tl (m # ms)", "have \"msx' = targetnode a # ms\""], ["proof (prove)\nusing this:\n  msx' = targetnode a # tl (m # ms)\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # ms", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>valid_return_list rs m\\<close> \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"valid_return_list rs (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. valid_return_list rs (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       cs' @ c # cs'' = cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        get_proc (sourcenode a) = get_proc (targetnode a); m = sourcenode a;\n        rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply(erule_tac x=\"cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        m = sourcenode a; rs = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               cs' @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case cs' of [] \\<Rightarrow> sourcenode a\n    | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (case cs' of [] \\<Rightarrow> targetnode a\n                 | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>get_proc (sourcenode a) = get_proc (targetnode a);\n        m = sourcenode a; rs = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case cs' of [] \\<Rightarrow> sourcenode a\n                                   | a # list \\<Rightarrow>\n last (targetnodes cs'))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case cs' of [] \\<Rightarrow> sourcenode a\n                           | a # list \\<Rightarrow>\n                               last (targetnodes cs')) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode a\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs') auto"], ["proof (state)\nthis:\n  valid_return_list rs (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from IH[OF \\<open>msx' = targetnode a # ms\\<close> this \n        \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close>\n        \\<open>ms = targetnodes rs\\<close> \\<open>valid_return_list rs (targetnode a)\\<close>\n        \\<open>length rs = length cs\\<close>]"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m' \\<and> valid_path_aux cs as", "have \"targetnode a -as\\<rightarrow>* m'\" and \"valid_path_aux cs as\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. targetnode a -as\\<rightarrow>* m' &&& valid_path_aux cs as", "by simp_all"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>* m'\n  valid_path_aux cs as\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \n        \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n  hd (m # ms) = sourcenode a", "have \"m -a#as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n  hd (m # ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "moreover"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>intra_kind (kind a)\\<close> \\<open>valid_path_aux cs as\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  valid_path_aux cs as", "have \"valid_path_aux cs (a # as)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a # as)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_path_aux cs (a # as)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length s' = length s;\n        length (m # ms) = length s; hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 3. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "ultimately"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'\n  valid_path_aux cs (a # as)", "show ?case"], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n  valid_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "case (silent_move_call f a sx sx' Q r p fs a' n\\<^sub>c msx')"], ["proof (state)\nthis:\n  pred (f a) sx\n  transfer (f a) sx = sx'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl (m # ms)).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice\n                               n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd (m # ms)\n  \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length (m # ms) = length sx\n  length sx' = Suc (length sx)\n  hd (m # ms) = sourcenode a\n  msx' = targetnode a # targetnode a' # tl (m # ms)\n  n\\<^sub>c,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               ms',s'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "note IH = \\<open>\\<And>m cs ms rs. \\<lbrakk>msx' = m # ms; valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); \n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n        \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs", "have \"length (a'#rs) = length (a#cs)\""], ["proof (prove)\nusing this:\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. length (a' # rs) = length (a # cs)", "by simp"], ["proof (state)\nthis:\n  length (a' # rs) = length (a # cs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>msx' = targetnode a # targetnode a' # tl (m # ms)\\<close>"], ["proof (chain)\npicking this:\n  msx' = targetnode a # targetnode a' # tl (m # ms)", "have \"msx' = targetnode a # targetnode a' # ms\""], ["proof (prove)\nusing this:\n  msx' = targetnode a # targetnode a' # tl (m # ms)\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # targetnode a' # ms", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # targetnode a' # ms\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs", "have \"targetnode a' # ms = targetnodes (a' # rs)\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n\ngoal (1 subgoal):\n 1. targetnode a' # ms = targetnodes (a' # rs)", "by(simp add:targetnodes_def)"], ["proof (state)\nthis:\n  targetnode a' # ms = targetnodes (a' # rs)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc (targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "obtain Q' f' where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"get_proc (sourcenode a) = get_proc (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a')", "by(rule get_proc_get_return_edge)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>valid_return_list rs m\\<close> \\<open>hd (m # ms) = sourcenode a\\<close>\n        \\<open>get_proc (targetnode a) = p\\<close> \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  get_proc (targetnode a) = p\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a) = get_proc (targetnode a')", "have \"valid_return_list (a' # rs) (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  get_proc (targetnode a) = p\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  get_proc (sourcenode a) = get_proc (targetnode a')\n\ngoal (1 subgoal):\n 1. valid_return_list (a' # rs) (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>f';\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        m = sourcenode a; p = get_proc (targetnode a);\n        a' # rs = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(case_tac cs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>f';\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        m = sourcenode a; p = get_proc (targetnode a);\n        a' # rs = cs' @ c # cs''; cs' = []\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)\n 2. \\<And>cs' c cs'' a list.\n       \\<lbrakk>\\<forall>cs' c.\n                   (\\<exists>cs''. rs = cs' @ c # cs'') \\<longrightarrow>\n                   valid_edge c \\<and>\n                   (\\<exists>Q f.\n                       kind c =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>f';\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        m = sourcenode a; p = get_proc (targetnode a);\n        a' # rs = cs' @ c # cs''; cs' = a # list\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode a\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>\\<forall>cs' ca.\n                   (\\<exists>cs''a.\n                       list @ c # cs'' = cs' @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs' of [] \\<Rightarrow> sourcenode a\n            | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n        valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>f';\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        m = sourcenode a; p = get_proc (targetnode a);\n        rs = list @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply(erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>f';\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        m = sourcenode a; p = get_proc (targetnode a); rs = list @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               list @ c # cs'' = list @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case list of [] \\<Rightarrow> sourcenode a\n    | a # lista \\<Rightarrow> last (targetnodes list))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q f.\n                            kind c =\n                            Q\\<hookleftarrow>\\<^bsub>get_proc\n                (last (targetnodes (a' # list)))\\<^esub>f", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c cs'' list Q f.\n       \\<lbrakk>valid_edge a';\n        kind a' =\n        Q'\\<hookleftarrow>\\<^bsub>get_proc (targetnode a)\\<^esub>f';\n        get_proc (sourcenode a) = get_proc (targetnode a');\n        m = sourcenode a; p = get_proc (targetnode a); rs = list @ c # cs'';\n        valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (case list of\n                                   [] \\<Rightarrow> sourcenode a\n                                   | a # lista \\<Rightarrow>\n last (targetnodes list))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc\n                          (case list of [] \\<Rightarrow> sourcenode a\n                           | a # lista \\<Rightarrow>\n                               last (targetnodes list)) =\n                         get_proc (last (targetnodes (a' # list)))", "by(case_tac list)(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list (a' # rs) (targetnode a)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n        \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a", "have \"\\<forall>i<length (a'#rs). (a'#rs) ! i \\<in> get_return_edges ((a#cs) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a' # rs).\n       (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a' # rs).\n     (a' # rs) ! i \\<in> get_return_edges ((a # cs) ! i)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from IH[OF \\<open>msx' = targetnode a # targetnode a' # ms\\<close> \\<open>valid_node (targetnode a)\\<close> this \n        \\<open>targetnode a' # ms = targetnodes (a' # rs)\\<close> \n        \\<open>valid_return_list (a' # rs) (targetnode a)\\<close> \\<open>length (a'#rs) = length (a#cs)\\<close>]"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m' \\<and> valid_path_aux (a # cs) as", "have \"targetnode a -as\\<rightarrow>* m'\" and \"valid_path_aux (a # cs) as\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m' \\<and> valid_path_aux (a # cs) as\n\ngoal (1 subgoal):\n 1. targetnode a -as\\<rightarrow>* m' &&& valid_path_aux (a # cs) as", "by simp_all"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>* m'\n  valid_path_aux (a # cs) as\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \n        \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n  hd (m # ms) = sourcenode a", "have \"m -a#as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n  hd (m # ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "moreover"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_path_aux (a # cs) as\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux (a # cs) as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"valid_path_aux cs (a # as)\""], ["proof (prove)\nusing this:\n  valid_path_aux (a # cs) as\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs (a # as)\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl (m # ms)).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd (m # ms)\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s' = Suc (length s); hd (m # ms) = sourcenode a;\n        ms'a = targetnode a # targetnode a' # tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)\n 2. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "ultimately"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'\n  valid_path_aux cs (a # as)", "show ?case"], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n  valid_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "case (silent_move_return f a sx sx' Q p f' n\\<^sub>c msx')"], ["proof (state)\nthis:\n  pred (f a) sx\n  transfer (f a) sx = sx'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl (m # ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (m # ms))) return_node\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  msx' = tl (m # ms)\n  n\\<^sub>c,f \\<turnstile> (msx',sx') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                               ms',s'')\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "note IH = \\<open>\\<And>m cs ms rs. \\<lbrakk>msx' = m # ms; valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i); \n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n        \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>msx' = ?m # ?ms; valid_node ?m;\n   \\<forall>i<length ?rs. ?rs ! i \\<in> get_return_edges (?cs ! i);\n   ?ms = targetnodes ?rs; valid_return_list ?rs ?m;\n   length ?rs = length ?cs\\<rbrakk>\n  \\<Longrightarrow> ?m -as\\<rightarrow>* m' \\<and> valid_path_aux ?cs as\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>length (m # ms) = length sx\\<close> \\<open>length sx = Suc (length sx')\\<close> \n        \\<open>sx' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs\n  ms = x # xs", "obtain r' rs' where \"rs = r'#rs'\" \n        and \"x = targetnode r'\" and \"xs = targetnodes rs'\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n  ms = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; x = targetnode r';\n         xs = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  rs = r' # rs'\n  x = targetnode r'\n  xs = targetnodes rs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  rs = r' # rs'\n  x = targetnode r'\n  xs = targetnodes rs'", "obtain c' cs' where \"cs = c'#cs'\"\n        and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  rs = r' # rs'\n  x = targetnode r'\n  xs = targetnodes rs'\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>ms = x#xs\\<close> \\<open>length (m # ms) = length sx\\<close> \n        \\<open>length sx = Suc (length sx')\\<close>"], ["proof (chain)\npicking this:\n  ms = x # xs\n  length (m # ms) = length sx\n  length sx = Suc (length sx')", "have \"length sx' = Suc (length xs)\""], ["proof (prove)\nusing this:\n  ms = x # xs\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n\ngoal (1 subgoal):\n 1. length sx' = Suc (length xs)", "by simp"], ["proof (state)\nthis:\n  length sx' = Suc (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>ms = x#xs\\<close> \\<open>msx' = tl (m # ms)\\<close> \\<open>hd (tl (m # ms)) = targetnode a\\<close>\n        \\<open>length (m # ms) = length sx\\<close> \\<open>length sx = Suc (length sx')\\<close> \\<open>sx' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms = x # xs\n  msx' = tl (m # ms)\n  hd (tl (m # ms)) = targetnode a\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []", "have \"msx' = targetnode a#xs\""], ["proof (prove)\nusing this:\n  ms = x # xs\n  msx' = tl (m # ms)\n  hd (tl (m # ms)) = targetnode a\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. msx' = targetnode a # xs", "by simp"], ["proof (state)\nthis:\n  msx' = targetnode a # xs\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n        \\<open>rs = r'#rs'\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'", "have \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. r' \\<in> get_return_edges c'", "by fastforce"], ["proof (state)\nthis:\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>ms = x#xs\\<close> \\<open>hd (tl (m # ms)) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  ms = x # xs\n  hd (tl (m # ms)) = targetnode a", "have \"x = targetnode a\""], ["proof (prove)\nusing this:\n  ms = x # xs\n  hd (tl (m # ms)) = targetnode a\n\ngoal (1 subgoal):\n 1. x = targetnode a", "by simp"], ["proof (state)\nthis:\n  x = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>valid_return_list rs m\\<close> \\<open>rs = r'#rs'\\<close> \\<open>x = targetnode r'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  rs = r' # rs'\n  x = targetnode r'\n  x = targetnode a", "have \"valid_return_list rs' (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  rs = r' # rs'\n  x = targetnode r'\n  x = targetnode a\n\ngoal (1 subgoal):\n 1. valid_return_list rs' (targetnode a)", "apply(clarsimp simp:valid_return_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>\\<forall>cs'a ca.\n                   (\\<exists>cs''a.\n                       r' # cs' @ c # cs'' =\n                       cs'a @ ca # cs''a) \\<longrightarrow>\n                   valid_edge ca \\<and>\n                   (\\<exists>Q f.\n                       kind ca =\n                       Q\\<hookleftarrow>\\<^bsub>get_proc\n           (case cs'a of [] \\<Rightarrow> m\n            | a # list \\<Rightarrow> last (targetnodes cs'a))\\<^esub>f);\n        rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        x = targetnode r'; rs' = cs' @ c # cs''\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply(erule_tac x=\"r'#cs'\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs''.\n       \\<lbrakk>rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        x = targetnode r'; rs' = cs' @ c # cs'';\n        \\<forall>ca.\n           (\\<exists>cs''a.\n               r' # cs' @ c # cs'' =\n               (r' # cs') @ ca # cs''a) \\<longrightarrow>\n           valid_edge ca \\<and>\n           (\\<exists>Q f.\n               kind ca =\n               Q\\<hookleftarrow>\\<^bsub>get_proc\n   (case r' # cs' of [] \\<Rightarrow> m\n    | a # list \\<Rightarrow>\n        last (targetnodes (r' # cs')))\\<^esub>f)\\<rbrakk>\n       \\<Longrightarrow> valid_edge c \\<and>\n                         (\\<exists>Q f.\n                             kind c =\n                             Q\\<hookleftarrow>\\<^bsub>get_proc\n                 (case cs' of [] \\<Rightarrow> targetnode r'\n                  | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cs' c cs'' Q f.\n       \\<lbrakk>rs = r' # cs' @ c # cs''; targetnode a = targetnode r';\n        x = targetnode r'; rs' = cs' @ c # cs''; valid_edge c;\n        kind c =\n        Q\\<hookleftarrow>\\<^bsub>get_proc\n                                  (last\n                                    (targetnodes\n(r' # cs')))\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> get_proc (last (targetnodes (r' # cs'))) =\n                         get_proc\n                          (case cs' of [] \\<Rightarrow> targetnode r'\n                           | a # list \\<Rightarrow> last (targetnodes cs'))", "by(case_tac cs')(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  valid_return_list rs' (targetnode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n        \\<open>rs = r'#rs'\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n        and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from IH[OF \\<open>msx' = targetnode a#xs\\<close> \\<open>valid_node (targetnode a)\\<close> \n        \\<open>\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\\<close> \\<open>xs = targetnodes rs'\\<close>\n        \\<open>valid_return_list rs' (targetnode a)\\<close> \\<open>length rs' = length cs'\\<close>]"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m' \\<and> valid_path_aux cs' as", "have \"targetnode a -as\\<rightarrow>* m'\" and \"valid_path_aux cs' as\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m' \\<and> valid_path_aux cs' as\n\ngoal (1 subgoal):\n 1. targetnode a -as\\<rightarrow>* m' &&& valid_path_aux cs' as", "by simp_all"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>* m'\n  valid_path_aux cs' as\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \n        \\<open>hd (m # ms) = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n  hd (m # ms) = sourcenode a", "have \"m -a#as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n  hd (m # ms) = sourcenode a\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "moreover"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>ms = x#xs\\<close> \\<open>hd (tl (m # ms)) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  ms = x # xs\n  hd (tl (m # ms)) = targetnode a", "have \"x = targetnode a\""], ["proof (prove)\nusing this:\n  ms = x # xs\n  hd (tl (m # ms)) = targetnode a\n\ngoal (1 subgoal):\n 1. x = targetnode a", "by simp"], ["proof (state)\nthis:\n  x = targetnode a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "from \\<open>valid_return_list rs m\\<close> \\<open>hd (m # ms) = sourcenode a\\<close> \n        \\<open>rs = r'#rs'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  rs = r' # rs'", "have \"get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n        method_exit (sourcenode r') \\<and> valid_edge r'\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  rs = r' # rs'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n    method_exit (sourcenode r') \\<and> valid_edge r'", "apply(clarsimp simp:valid_return_list_def method_exit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cs' c.\n                (\\<exists>cs''. r' # rs' = cs' @ c # cs'') \\<longrightarrow>\n                valid_edge c \\<and>\n                (\\<exists>Q f.\n                    kind c =\n                    Q\\<hookleftarrow>\\<^bsub>get_proc\n        (case cs' of [] \\<Rightarrow> sourcenode a\n         | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n     rs = r' # rs'; m = sourcenode a\\<rbrakk>\n    \\<Longrightarrow> get_proc (sourcenode a) =\n                      get_proc (sourcenode r') \\<and>\n                      (sourcenode r' = (_Exit_) \\<or>\n                       (\\<exists>a.\n                           sourcenode r' = sourcenode a \\<and>\n                           valid_edge a \\<and>\n                           (\\<exists>Q p f.\n                               kind a =\n                               Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))) \\<and>\n                      valid_edge r'", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = r' # rs'; m = sourcenode a;\n     \\<forall>c.\n        (\\<exists>cs''. r' # rs' = [] @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case [] of [] \\<Rightarrow> sourcenode a\n | a # list \\<Rightarrow> last (targetnodes []))\\<^esub>f)\\<rbrakk>\n    \\<Longrightarrow> get_proc (sourcenode a) =\n                      get_proc (sourcenode r') \\<and>\n                      (sourcenode r' = (_Exit_) \\<or>\n                       (\\<exists>a.\n                           sourcenode r' = sourcenode a \\<and>\n                           valid_edge a \\<and>\n                           (\\<exists>Q p f.\n                               kind a =\n                               Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))) \\<and>\n                      valid_edge r'", "by(auto dest:get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n  method_exit (sourcenode r') \\<and> valid_edge r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "hence \"get_proc (sourcenode a) = get_proc (sourcenode r')\"\n        and \"method_exit (sourcenode r')\" and \"valid_edge r'\""], ["proof (prove)\nusing this:\n  get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n  method_exit (sourcenode r') \\<and> valid_edge r'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (sourcenode r') &&&\n    method_exit (sourcenode r') &&& valid_edge r'", "by simp_all"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (sourcenode r')\n  method_exit (sourcenode r')\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>method_exit (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode a)\n  get_proc (sourcenode a) = get_proc (sourcenode r')\n  method_exit (sourcenode r')\n  valid_edge r'", "have \"sourcenode r' = sourcenode a\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode a)\n  get_proc (sourcenode a) = get_proc (sourcenode r')\n  method_exit (sourcenode r')\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. sourcenode r' = sourcenode a", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode r' = sourcenode a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>valid_edge a\\<close> \\<open>valid_edge r'\\<close> \\<open>x = targetnode r'\\<close> \\<open>x = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge r'\n  x = targetnode r'\n  x = targetnode a\n  sourcenode r' = sourcenode a", "have \"r' = a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge r'\n  x = targetnode r'\n  x = targetnode a\n  sourcenode r' = sourcenode a\n\ngoal (1 subgoal):\n 1. r' = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  r' = a\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "with \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>valid_path_aux cs' as\\<close> \\<open>cs = c'#cs'\\<close> \n        \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  r' \\<in> get_return_edges c'\n  valid_path_aux cs' as\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  r' = a", "have \"valid_path_aux cs (a # as)\""], ["proof (prove)\nusing this:\n  r' \\<in> get_return_edges c'\n  valid_path_aux cs' as\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  r' = a\n\ngoal (1 subgoal):\n 1. valid_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' S ms'a.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl (m # ms))) return_node; length (m # ms) = length s;\n        length s = Suc (length s'); s' \\<noteq> [];\n        hd (m # ms) = sourcenode a; hd (tl (m # ms)) = targetnode a;\n        ms'a = tl (m # ms);\n        S,f \\<turnstile> (ms'a,s') =as\\<Rightarrow>\\<^sub>\\<tau> (m' #\n                            ms',s'');\n        \\<And>m ms rs cs.\n           \\<lbrakk>ms'a = m # ms; valid_node m;\n            \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n            ms = targetnodes rs; valid_return_list rs m;\n            length rs = length cs\\<rbrakk>\n           \\<Longrightarrow> m -as\\<rightarrow>* m' \\<and>\n                             valid_path_aux cs as;\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> m -a # as\\<rightarrow>* m' \\<and>\n                         valid_path_aux cs (a # as)", "ultimately"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'\n  valid_path_aux cs (a # as)", "show ?case"], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n  valid_path_aux cs (a # as)\n\ngoal (1 subgoal):\n 1. m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)", "by simp"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m -a # as\\<rightarrow>* m' \\<and> valid_path_aux cs (a # as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\n\ngoal (2 subgoals):\n 1. m -as\\<rightarrow>* m'\n 2. valid_path_aux cs as", "thus \"m -as\\<rightarrow>* m'\" and \"valid_path_aux cs as\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>* m' \\<and> valid_path_aux cs as\n\ngoal (1 subgoal):\n 1. m -as\\<rightarrow>* m' &&& valid_path_aux cs as", "by simp_all"], ["proof (state)\nthis:\n  m -as\\<rightarrow>* m'\n  valid_path_aux cs as\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Observable moves\\<close>"], ["", "inductive observable_move ::\n  \"'node SDG_node set \\<Rightarrow> ('edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind) \\<Rightarrow> 'node list \\<Rightarrow> \n   (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'edge \\<Rightarrow> 'node list \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\n(\"_,_ \\<turnstile> '(_,_') -_\\<rightarrow> '(_,_')\" [51,50,0,0,50,0,0] 51) \n \n  where observable_move_intra:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a; intra_kind(kind a); \n    \\<forall>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n    hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; length s' = length s; length ms = length s;\n    hd ms = sourcenode a; ms' = (targetnode a)#tl ms\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\"\n\n  | observable_move_call:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a; kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; \n    valid_edge a'; a' \\<in> get_return_edges a;\n    \\<forall>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n    hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>; length ms = length s; length s' = Suc(length s); \n    hd ms = sourcenode a; ms' = (targetnode a)#(targetnode a')#tl ms\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\"\n\n  | observable_move_return:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a; kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'; \n    \\<forall>m \\<in> set (tl ms). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n    length ms = length s; length s = Suc(length s'); s' \\<noteq> [];\n    hd ms = sourcenode a; hd(tl ms) = targetnode a; ms' = tl ms\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\""], ["", "inductive observable_moves :: \n  \"'node SDG_node set \\<Rightarrow> ('edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind) \\<Rightarrow> 'node list \\<Rightarrow> \n   (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> 'edge list \\<Rightarrow> 'node list \\<Rightarrow> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list \\<Rightarrow> bool\"\n(\"_,_ \\<turnstile> '(_,_') =_\\<Rightarrow> '(_,_')\" [51,50,0,0,50,0,0] 51) \n\n  where observable_moves_snoc:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s'); S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk> \n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as@[a]\\<Rightarrow> (ms'',s'')\""], ["", "lemma observable_move_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length ms = length s\n 2. length ms' = length s'", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')", "have \"length ms = length s \\<and> length ms' = length s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "proof(induct rule:observable_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "case (observable_move_intra f a s s' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s' = length s\n  length ms = length s\n  hd ms = sourcenode a\n  ms' = targetnode a # tl ms\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>pred (f a) s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 3. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>length ms = length s\\<close> \\<open>ms' = targetnode a # tl ms\\<close>\n      \\<open>length s' = length s\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  ms' = targetnode a # tl ms\n  length s' = length s", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length s\n  ms' = targetnode a # tl ms\n  length s' = length s\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "case (observable_move_call f a s s' Q r p fs a' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s' = Suc (length s)\n  hd ms = sourcenode a\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>pred (f a) s\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  pred (f a) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s) auto"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'\n 2. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>length ms = length s\\<close> \\<open>length s' = Suc (length s)\\<close> \n      \\<open>ms' = targetnode a # targetnode a' # tl ms\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  length s' = Suc (length s)\n  ms' = targetnode a # targetnode a' # tl ms", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length s\n  length s' = Suc (length s)\n  ms' = targetnode a # targetnode a' # tl ms\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "case (observable_move_return f a s s' Q p f' ms S ms')"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms = length s\n  length s = Suc (length s')\n  s' \\<noteq> []\n  hd ms = sourcenode a\n  hd (tl ms) = targetnode a\n  ms' = tl ms\n\ngoal (1 subgoal):\n 1. \\<And>f a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a;\n        ms' = tl ms\\<rbrakk>\n       \\<Longrightarrow> length ms = length s \\<and> length ms' = length s'", "from \\<open>length ms = length s\\<close> \\<open>length s = Suc (length s')\\<close> \\<open>ms' = tl ms\\<close> \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms = length s\n  length s = Suc (length s')\n  ms' = tl ms\n  s' \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  length ms = length s\n  length s = Suc (length s')\n  ms' = tl ms\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length ms = length s \\<and> length ms' = length s'", "by simp"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (2 subgoals):\n 1. length ms = length s\n 2. length ms' = length s'", "thus \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\nusing this:\n  length ms = length s \\<and> length ms' = length s'\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "by simp_all"], ["proof (state)\nthis:\n  length ms = length s\n  length ms' = length s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_moves_equal_length:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\" \n  shows \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "using \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close>"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "proof(induct rule:observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms = length s\n 2. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms'' = length s''", "case (observable_moves_snoc S f ms s as ms' s' a ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n\ngoal (2 subgoals):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms = length s\n 2. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms'' = length s''", "from \\<open>S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')", "have \"length ms' = length s'\" \"length ms'' = length s''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. length ms' = length s' &&& length ms'' = length s''", "by(rule observable_move_equal_length)+"], ["proof (state)\nthis:\n  length ms' = length s'\n  length ms'' = length s''\n\ngoal (2 subgoals):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms = length s\n 2. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms'' = length s''", "moreover"], ["proof (state)\nthis:\n  length ms' = length s'\n  length ms'' = length s''\n\ngoal (2 subgoals):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms = length s\n 2. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms'' = length s''", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"length ms = length s\" and \"length ms' = length s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms' = length s'", "by(rule silent_moves_equal_length)+"], ["proof (state)\nthis:\n  length ms = length s\n  length ms' = length s'\n\ngoal (2 subgoals):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms = length s\n 2. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> length ms'' = length s''", "ultimately"], ["proof (chain)\npicking this:\n  length ms' = length s'\n  length ms'' = length s''\n  length ms = length s\n  length ms' = length s'", "show \"length ms = length s\" \"length ms'' = length s''\""], ["proof (prove)\nusing this:\n  length ms' = length s'\n  length ms'' = length s''\n  length ms = length s\n  length ms' = length s'\n\ngoal (1 subgoal):\n 1. length ms = length s &&& length ms'' = length s''", "by simp_all"], ["proof (state)\nthis:\n  length ms = length s\n  length ms'' = length s''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_move_notempty:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s'); as = []\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s');\n     as = []\\<rbrakk>\n    \\<Longrightarrow> False", "by(induct rule:observable_moves.induct,simp)"], ["", "lemma silent_move_observable_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow> (ms',s'); S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a#as\\<Rightarrow> (ms',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms'',s'') =as\\<Rightarrow> (ms',s');\n     S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (ms'',s'')\\<rbrakk>\n    \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a # as\\<Rightarrow> (ms',s')", "proof(induct rule:observable_moves.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f msa sa as ms' s' aa ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (msa,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -aa\\<rightarrow> (ms'',s'');\n        S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msa,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a #\n            as @ [aa]\\<Rightarrow> (ms'',s'')", "case (observable_moves_snoc S f msx sx as ms' s' a' ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (msx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') -a'\\<rightarrow> (ms'',s'')\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\n\ngoal (1 subgoal):\n 1. \\<And>S f msa sa as ms' s' aa ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (msa,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -aa\\<rightarrow> (ms'',s'');\n        S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msa,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a #\n            as @ [aa]\\<Rightarrow> (ms'',s'')", "from \\<open>S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\\<close> \\<open>S,f \\<turnstile> (msx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,f \\<turnstile> (msx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"S,f \\<turnstile> (ms,s) =a#as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msx,sx)\n  S,f \\<turnstile> (msx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "by(fastforce intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. \\<And>S f msa sa as ms' s' aa ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (msa,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -aa\\<rightarrow> (ms'',s'');\n        S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msa,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a #\n            as @ [aa]\\<Rightarrow> (ms'',s'')", "with \\<open>S,f \\<turnstile> (ms',s') -a'\\<rightarrow> (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms',s') -a'\\<rightarrow> (ms'',s'')\n  S,f \\<turnstile> (ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"S,f \\<turnstile> (ms,s) =(a#as)@[a']\\<Rightarrow> (ms'',s'')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms',s') -a'\\<rightarrow> (ms'',s'')\n  S,f \\<turnstile> (ms,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =(a # as) @ [a']\\<Rightarrow> (ms'',s'')", "by(fastforce intro:observable_moves.observable_moves_snoc)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =(a # as) @ [a']\\<Rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>S f msa sa as ms' s' aa ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (msa,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -aa\\<rightarrow> (ms'',s'');\n        S,f \\<turnstile> (ms,s) -a\\<rightarrow>\\<^sub>\\<tau> (msa,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (ms,s) =a #\n            as @ [aa]\\<Rightarrow> (ms'',s'')", "thus ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =(a # as) @ [a']\\<Rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (ms,s) =a # as @ [a']\\<Rightarrow> (ms'',s'')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =a # as @ [a']\\<Rightarrow> (ms'',s'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_append_observable_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s''); S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow> (ms',s')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as@as'\\<Rightarrow> (ms',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms'',s'');\n     S,f \\<turnstile> (ms'',s'') =as'\\<Rightarrow> (ms',s')\\<rbrakk>\n    \\<Longrightarrow> S,f \\<turnstile> (ms,s) =as @\n         as'\\<Rightarrow> (ms',s')", "by(induct rule:silent_moves.induct)(auto elim:silent_move_observable_moves)"], ["", "lemma observable_moves_preds_transfers:\n  assumes \"S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\"\n  shows \"preds (map f as) s\" and \"transfers (map f as) s = s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preds (map f as) s &&& transfers (map f as) s = s'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. preds (map f as) s\n 2. transfers (map f as) s = s'", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')", "have \"preds (map f as) s \\<and> transfers (map f as) s = s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow> (ms',s')\n\ngoal (1 subgoal):\n 1. preds (map f as) s \\<and> transfers (map f as) s = s'", "proof(induct rule:observable_moves.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s''", "case (observable_moves_snoc S f ms s as ms' s' a ms'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s''", "from \\<open>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')", "have \"preds (map f as) s\" and \"transfers (map f as) s = s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n\ngoal (1 subgoal):\n 1. preds (map f as) s &&& transfers (map f as) s = s'", "by(rule silent_moves_preds_transfers)+"], ["proof (state)\nthis:\n  preds (map f as) s\n  transfers (map f as) s = s'\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s''", "from \\<open>S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')", "have \"pred (f a) s'\" and \"transfer (f a) s' = s''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\n\ngoal (1 subgoal):\n 1. pred (f a) s' &&& transfer (f a) s' = s''", "by(auto elim:observable_move.cases)"], ["proof (state)\nthis:\n  pred (f a) s'\n  transfer (f a) s' = s''\n\ngoal (1 subgoal):\n 1. \\<And>S f ms s as ms' s' a ms'' s''.\n       \\<lbrakk>S,f \\<turnstile> (ms,s) =as\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n        S,f \\<turnstile> (ms',s') -a\\<rightarrow> (ms'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s''", "with \\<open>preds (map f as) s\\<close> \\<open>transfers (map f as) s = s'\\<close>"], ["proof (chain)\npicking this:\n  preds (map f as) s\n  transfers (map f as) s = s'\n  pred (f a) s'\n  transfer (f a) s' = s''", "show ?case"], ["proof (prove)\nusing this:\n  preds (map f as) s\n  transfers (map f as) s = s'\n  pred (f a) s'\n  transfer (f a) s' = s''\n\ngoal (1 subgoal):\n 1. preds (map f (as @ [a])) s \\<and> transfers (map f (as @ [a])) s = s''", "by(simp add:preds_split transfers_split)"], ["proof (state)\nthis:\n  preds (map f (as @ [a])) s \\<and> transfers (map f (as @ [a])) s = s''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  preds (map f as) s \\<and> transfers (map f as) s = s'\n\ngoal (2 subgoals):\n 1. preds (map f as) s\n 2. transfers (map f as) s = s'", "thus \"preds (map f as) s\" and \"transfers (map f as) s = s'\""], ["proof (prove)\nusing this:\n  preds (map f as) s \\<and> transfers (map f as) s = s'\n\ngoal (1 subgoal):\n 1. preds (map f as) s &&& transfers (map f as) s = s'", "by simp_all"], ["proof (state)\nthis:\n  preds (map f as) s\n  transfers (map f as) s = s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_move_vpa_path:\n  \"\\<lbrakk>S,f \\<turnstile> (m#ms,s) -a\\<rightarrow> (m'#ms',s'); valid_node m; \n    \\<forall>i < length rs. rs!i \\<in> get_return_edges (cs!i); ms = targetnodes rs;\n    valid_return_list rs m; length rs = length cs\\<rbrakk> \\<Longrightarrow> valid_path_aux cs [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (m # ms,s) -a\\<rightarrow> (m' # ms',s');\n     valid_node m;\n     \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n     ms = targetnodes rs; valid_return_list rs m;\n     length rs = length cs\\<rbrakk>\n    \\<Longrightarrow> valid_path_aux cs [a]", "proof(induct S f \"m#ms\" s a \"m'#ms'\" s' rule:observable_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "case (observable_move_return f a sx sx' Q p f' n\\<^sub>c)"], ["proof (state)\nthis:\n  pred (f a) sx\n  transfer (f a) sx = sx'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl (m # ms)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice n\\<^sub>c\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []\n  hd (m # ms) = sourcenode a\n  hd (tl (m # ms)) = targetnode a\n  m' # ms' = tl (m # ms)\n  valid_node m\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  ms = targetnodes rs\n  valid_return_list rs m\n  length rs = length cs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "from \\<open>length (m # ms) = length sx\\<close> \\<open>length sx = Suc (length sx')\\<close> \n    \\<open>sx' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []", "obtain x xs where \"ms = x#xs\""], ["proof (prove)\nusing this:\n  length (m # ms) = length sx\n  length sx = Suc (length sx')\n  sx' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. ms = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ms) auto"], ["proof (state)\nthis:\n  ms = x # xs\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "with \\<open>ms = targetnodes rs\\<close>"], ["proof (chain)\npicking this:\n  ms = targetnodes rs\n  ms = x # xs", "obtain r' rs' where \"rs = r'#rs'\" \n    and \"x = targetnode r'\"     and \"xs = targetnodes rs'\""], ["proof (prove)\nusing this:\n  ms = targetnodes rs\n  ms = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>r' rs'.\n        \\<lbrakk>rs = r' # rs'; x = targetnode r';\n         xs = targetnodes rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:targetnodes_def)"], ["proof (state)\nthis:\n  rs = r' # rs'\n  x = targetnode r'\n  xs = targetnodes rs'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "with \\<open>length rs = length cs\\<close>"], ["proof (chain)\npicking this:\n  length rs = length cs\n  rs = r' # rs'\n  x = targetnode r'\n  xs = targetnodes rs'", "obtain c' cs' where \"cs = c'#cs'\"\n    and \"length rs' = length cs'\""], ["proof (prove)\nusing this:\n  length rs = length cs\n  rs = r' # rs'\n  x = targetnode r'\n  xs = targetnodes rs'\n\ngoal (1 subgoal):\n 1. (\\<And>c' cs'.\n        \\<lbrakk>cs = c' # cs'; length rs' = length cs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cs) auto"], ["proof (state)\nthis:\n  cs = c' # cs'\n  length rs' = length cs'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "from \\<open>\\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\\<close> \n    \\<open>rs = r'#rs'\\<close> \\<open>cs = c'#cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'", "have \"\\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\"\n    and \"r' \\<in> get_return_edges c'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i)\n  rs = r' # rs'\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i) &&&\n    r' \\<in> get_return_edges c'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length rs'. rs' ! i \\<in> get_return_edges (cs' ! i)\n  r' \\<in> get_return_edges c'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "from \\<open>ms = x#xs\\<close> \\<open>hd (tl (m # ms)) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  ms = x # xs\n  hd (tl (m # ms)) = targetnode a", "have \"x = targetnode a\""], ["proof (prove)\nusing this:\n  ms = x # xs\n  hd (tl (m # ms)) = targetnode a\n\ngoal (1 subgoal):\n 1. x = targetnode a", "by simp"], ["proof (state)\nthis:\n  x = targetnode a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode a)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode a)\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "from \\<open>valid_return_list rs m\\<close> \\<open>hd (m # ms) = sourcenode a\\<close> \n    \\<open>rs = r'#rs'\\<close>"], ["proof (chain)\npicking this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  rs = r' # rs'", "have \"get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n    method_exit (sourcenode r') \\<and> valid_edge r'\""], ["proof (prove)\nusing this:\n  valid_return_list rs m\n  hd (m # ms) = sourcenode a\n  rs = r' # rs'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n    method_exit (sourcenode r') \\<and> valid_edge r'", "apply(clarsimp simp:valid_return_list_def method_exit_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cs' c.\n                (\\<exists>cs''. r' # rs' = cs' @ c # cs'') \\<longrightarrow>\n                valid_edge c \\<and>\n                (\\<exists>Q f.\n                    kind c =\n                    Q\\<hookleftarrow>\\<^bsub>get_proc\n        (case cs' of [] \\<Rightarrow> sourcenode a\n         | a # list \\<Rightarrow> last (targetnodes cs'))\\<^esub>f);\n     rs = r' # rs'; m = sourcenode a\\<rbrakk>\n    \\<Longrightarrow> get_proc (sourcenode a) =\n                      get_proc (sourcenode r') \\<and>\n                      (sourcenode r' = (_Exit_) \\<or>\n                       (\\<exists>a.\n                           sourcenode r' = sourcenode a \\<and>\n                           valid_edge a \\<and>\n                           (\\<exists>Q p f.\n                               kind a =\n                               Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))) \\<and>\n                      valid_edge r'", "apply(erule_tac x=\"[]\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs = r' # rs'; m = sourcenode a;\n     \\<forall>c.\n        (\\<exists>cs''. r' # rs' = [] @ c # cs'') \\<longrightarrow>\n        valid_edge c \\<and>\n        (\\<exists>Q f.\n            kind c =\n            Q\\<hookleftarrow>\\<^bsub>get_proc\n(case [] of [] \\<Rightarrow> sourcenode a\n | a # list \\<Rightarrow> last (targetnodes []))\\<^esub>f)\\<rbrakk>\n    \\<Longrightarrow> get_proc (sourcenode a) =\n                      get_proc (sourcenode r') \\<and>\n                      (sourcenode r' = (_Exit_) \\<or>\n                       (\\<exists>a.\n                           sourcenode r' = sourcenode a \\<and>\n                           valid_edge a \\<and>\n                           (\\<exists>Q p f.\n                               kind a =\n                               Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f))) \\<and>\n                      valid_edge r'", "by(auto dest:get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n  method_exit (sourcenode r') \\<and> valid_edge r'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "hence \"get_proc (sourcenode a) = get_proc (sourcenode r')\"\n    and \"method_exit (sourcenode r')\" and \"valid_edge r'\""], ["proof (prove)\nusing this:\n  get_proc (sourcenode a) = get_proc (sourcenode r') \\<and>\n  method_exit (sourcenode r') \\<and> valid_edge r'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (sourcenode r') &&&\n    method_exit (sourcenode r') &&& valid_edge r'", "by simp_all"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (sourcenode r')\n  method_exit (sourcenode r')\n  valid_edge r'\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "with \\<open>method_exit (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode a)\n  get_proc (sourcenode a) = get_proc (sourcenode r')\n  method_exit (sourcenode r')\n  valid_edge r'", "have \"sourcenode r' = sourcenode a\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode a)\n  get_proc (sourcenode a) = get_proc (sourcenode r')\n  method_exit (sourcenode r')\n  valid_edge r'\n\ngoal (1 subgoal):\n 1. sourcenode r' = sourcenode a", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode r' = sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "with \\<open>valid_edge a\\<close> \\<open>valid_edge r'\\<close> \\<open>x = targetnode r'\\<close> \\<open>x = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge r'\n  x = targetnode r'\n  x = targetnode a\n  sourcenode r' = sourcenode a", "have \"r' = a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge r'\n  x = targetnode r'\n  x = targetnode a\n  sourcenode r' = sourcenode a\n\ngoal (1 subgoal):\n 1. r' = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  r' = a\n\ngoal (3 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 3. \\<And>f a s s' Q p f' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s = Suc (length s');\n        s' \\<noteq> []; hd (m # ms) = sourcenode a;\n        hd (tl (m # ms)) = targetnode a; m' # ms' = tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "with \\<open>r' \\<in> get_return_edges c'\\<close> \\<open>cs = c'#cs'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  r' \\<in> get_return_edges c'\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  r' = a", "show ?case"], ["proof (prove)\nusing this:\n  r' \\<in> get_return_edges c'\n  cs = c' # cs'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  r' = a\n\ngoal (1 subgoal):\n 1. valid_path_aux cs [a]", "by simp"], ["proof (state)\nthis:\n  valid_path_aux cs [a]\n\ngoal (2 subgoals):\n 1. \\<And>f a s s' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length (m # ms) = length s;\n        hd (m # ms) = sourcenode a; m' # ms' = targetnode a # tl (m # ms);\n        valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]\n 2. \\<And>f a s s' Q r p fs a' S.\n       \\<lbrakk>pred (f a) s; transfer (f a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl (m # ms)).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd (m # ms) \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length (m # ms) = length s; length s' = Suc (length s);\n        hd (m # ms) = sourcenode a;\n        m' # ms' = targetnode a # targetnode a' # tl (m # ms); valid_node m;\n        \\<forall>i<length rs. rs ! i \\<in> get_return_edges (cs ! i);\n        ms = targetnodes rs; valid_return_list rs m;\n        length rs = length cs\\<rbrakk>\n       \\<Longrightarrow> valid_path_aux cs [a]", "qed(auto simp:intra_kind_def)"], ["", "subsection \\<open>Relevant variables\\<close>"], ["", "inductive_set relevant_vars ::\n  \"'node SDG_node set \\<Rightarrow> 'node SDG_node \\<Rightarrow> 'var set\" (\"rv _\")\nfor S :: \"'node SDG_node set\" and n :: \"'node SDG_node\"\n\nwhere rvI:\n  \"\\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'; n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n    \\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n  \\<Longrightarrow> V \\<in> rv S n\""], ["", "lemma rvE:\n  assumes rv:\"V \\<in> rv S n\"\n  obtains as n' where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"\n  and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n  and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n    \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>parent_node\n                  n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rv"], ["proof (prove)\nusing this:\n  V \\<in> rv S n\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>parent_node\n                  n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(atomize_elim,auto elim!:relevant_vars.cases)"], ["", "lemma rv_parent_node:\n  \"parent_node n = parent_node n' \\<Longrightarrow> rv (S::'node SDG_node set) n = rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent_node n = parent_node n' \\<Longrightarrow> rv S n = rv S n'", "by(fastforce elim:rvE intro:rvI)"], ["", "lemma obs_intra_empty_rv_empty:\n  assumes \"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\" shows \"rv S (CFG_node m) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S (CFG_node m) = {}", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<noteq> {} \\<Longrightarrow> False", "assume \"rv S (CFG_node m) \\<noteq> {}\""], ["proof (state)\nthis:\n  rv S (CFG_node m) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  rv S (CFG_node m) \\<noteq> {}", "obtain x where \"x \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  rv S (CFG_node m) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> rv S (CFG_node m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> rv S (CFG_node m)", "obtain n' as where \"m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" and \"n' \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  x \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<noteq> {} \\<Longrightarrow> False", "hence \"parent_node n' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. parent_node n' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:valid_SDG_node_in_slice_parent_node_in_slice \n                 simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  parent_node n' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<noteq> {} \\<Longrightarrow> False", "with \\<open>m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  parent_node n' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain mx where \"mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  parent_node n' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>mx.\n        mx \\<in> obs_intra m\n                  \\<lfloor>HRB_slice\n                            S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule path_ex_obs_intra)"], ["proof (state)\nthis:\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<noteq> {} \\<Longrightarrow> False", "with \\<open>obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show False"], ["proof (prove)\nusing this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  mx \\<in> obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_obs_intra_in_rv:\n  assumes obs_eq:\"obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n                  obs_intra (parent_node n') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"x \\<in> rv S n\" shows \"x \\<in> rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>x \\<in> rv S n\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> rv S n", "obtain as n''\n    where \"parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\" and \"n'' \\<in> HRB_slice S\" \n    and \"x \\<in> Use\\<^bsub>SDG\\<^esub> n''\" \n    and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n      \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  x \\<in> rv S n\n\ngoal (1 subgoal):\n 1. (\\<And>as n''.\n        \\<lbrakk>parent_node\n                  n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n         n'' \\<in> HRB_slice S; x \\<in> Use\\<^bsub>SDG\\<^esub> n'';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            x \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S\n  x \\<in> Use\\<^bsub>SDG\\<^esub> n''\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "have \"valid_node (parent_node n'')\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n'')", "by(fastforce dest:path_valid_node simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_node (parent_node n'')\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close> \\<open>n'' \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S", "have \"\\<exists>nx as' as''. parent_node nx \\<in> obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and> \n                      parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n                      parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and> as = as'@as''\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>nx as' as''.\n       parent_node nx\n       \\<in> obs_intra (parent_node n)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n       parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n       parent_node\n        nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n       as = as' @ as''", "proof(cases \"\\<forall>nx. parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow> nx \\<notin> HRB_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<forall>nx.\n        parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n        nx \\<notin> HRB_slice S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''\n 2. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "case True"], ["proof (state)\nthis:\n  \\<forall>nx.\n     parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n     nx \\<notin> HRB_slice S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<forall>nx.\n        parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n        nx \\<notin> HRB_slice S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''\n 2. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close> \\<open>n'' \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S\n  \\<forall>nx.\n     parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n     nx \\<notin> HRB_slice S", "have \"parent_node n'' \\<in> obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S\n  \\<forall>nx.\n     parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n     nx \\<notin> HRB_slice S\n\ngoal (1 subgoal):\n 1. parent_node n''\n    \\<in> obs_intra (parent_node n)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:obs_intra_elem valid_SDG_node_in_slice_parent_node_in_slice \n                   simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  parent_node n''\n  \\<in> obs_intra (parent_node n)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<forall>nx.\n        parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n        nx \\<notin> HRB_slice S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''\n 2. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "with \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close> \\<open>valid_node (parent_node n'')\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  valid_node (parent_node n'')\n  parent_node n''\n  \\<in> obs_intra (parent_node n)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  valid_node (parent_node n'')\n  parent_node n''\n  \\<in> obs_intra (parent_node n)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>nx as' as''.\n       parent_node nx\n       \\<in> obs_intra (parent_node n)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n       parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n       parent_node\n        nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n       as = as' @ as''", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  \\<exists>nx as' as''.\n     parent_node nx\n     \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n     parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n     as = as' @ as''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>nx.\n             parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n             nx \\<notin> HRB_slice S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "hence \"\\<exists>nx. parent_node nx \\<in> set (sourcenodes as) \\<and> nx \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>nx.\n             parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n             nx \\<notin> HRB_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>nx.\n       parent_node nx \\<in> set (sourcenodes as) \\<and> nx \\<in> HRB_slice S", "by simp"], ["proof (state)\nthis:\n  \\<exists>nx.\n     parent_node nx \\<in> set (sourcenodes as) \\<and> nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "hence \"\\<exists>mx \\<in> set (sourcenodes as). \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  \\<exists>nx.\n     parent_node nx \\<in> set (sourcenodes as) \\<and> nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>mx\\<in>set (sourcenodes as).\n       \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>mx\\<in>set (sourcenodes as).\n     \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>mx\\<in>set (sourcenodes as).\n     \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S", "obtain mx ms ms' where \"sourcenodes as = ms@mx#ms'\"\n      and \"\\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\"\n      and all:\"\\<forall>x \\<in> set ms. \\<not> (\\<exists>nx. x = parent_node nx \\<and> nx \\<in> HRB_slice S)\""], ["proof (prove)\nusing this:\n  \\<exists>mx\\<in>set (sourcenodes as).\n     \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. (\\<And>ms mx ms'.\n        \\<lbrakk>sourcenodes as = ms @ mx # ms';\n         \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S;\n         \\<forall>x\\<in>set ms.\n            \\<nexists>nx.\n               x = parent_node nx \\<and> nx \\<in> HRB_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_first_propE)"], ["proof (state)\nthis:\n  sourcenodes as = ms @ mx # ms'\n  \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\n  \\<forall>x\\<in>set ms.\n     \\<nexists>nx. x = parent_node nx \\<and> nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "then"], ["proof (chain)\npicking this:\n  sourcenodes as = ms @ mx # ms'\n  \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\n  \\<forall>x\\<in>set ms.\n     \\<nexists>nx. x = parent_node nx \\<and> nx \\<in> HRB_slice S", "obtain nx' where \"mx = parent_node nx'\" and \"nx' \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  sourcenodes as = ms @ mx # ms'\n  \\<exists>nx. mx = parent_node nx \\<and> nx \\<in> HRB_slice S\n  \\<forall>x\\<in>set ms.\n     \\<nexists>nx. x = parent_node nx \\<and> nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. (\\<And>nx'.\n        \\<lbrakk>mx = parent_node nx'; nx' \\<in> HRB_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mx = parent_node nx'\n  nx' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "from \\<open>sourcenodes as = ms@mx#ms'\\<close>"], ["proof (chain)\npicking this:\n  sourcenodes as = ms @ mx # ms'", "obtain as' a' as'' where \"ms = sourcenodes as'\"\n      and [simp]:\"as = as'@a'#as''\" and \"sourcenode a' = mx\""], ["proof (prove)\nusing this:\n  sourcenodes as = ms @ mx # ms'\n\ngoal (1 subgoal):\n 1. (\\<And>as' a' as''.\n        \\<lbrakk>ms = sourcenodes as'; as = as' @ a' # as'';\n         sourcenode a' = mx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  ms = sourcenodes as'\n  as = as' @ a' # as''\n  sourcenode a' = mx\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "from all \\<open>ms = sourcenodes as'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set ms.\n     \\<nexists>nx. x = parent_node nx \\<and> nx \\<in> HRB_slice S\n  ms = sourcenodes as'", "have \"\\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ms.\n     \\<nexists>nx. x = parent_node nx \\<and> nx \\<in> HRB_slice S\n  ms = sourcenodes as'\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes as').\n       nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "from \\<open>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close> \\<open>sourcenode a' = mx\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  sourcenode a' = mx", "have \"parent_node n  -as'\\<rightarrow>\\<^sub>\\<iota>* mx\" and \"valid_edge a'\" and \"intra_kind(kind a')\"\n      and \"targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  sourcenode a' = mx\n\ngoal (1 subgoal):\n 1. (parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx &&&\n     valid_edge a') &&&\n    intra_kind (kind a') &&&\n    targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "by(fastforce dest:path_split simp:intra_path_def)+"], ["proof (state)\nthis:\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "with \\<open>sourcenode a' = mx\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = mx\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "have \"mx -a'#as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  sourcenode a' = mx\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  valid_edge a'\n  intra_kind (kind a')\n  targetnode a' -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. mx -a' # as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  mx -a' # as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "from \\<open>parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\\<close> \\<open>mx = parent_node nx'\\<close> \\<open>nx' \\<in> HRB_slice S\\<close>\n      \\<open>\\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>ms = sourcenodes as'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  mx = parent_node nx'\n  nx' \\<in> HRB_slice S\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms = sourcenodes as'", "have \"mx \\<in> obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  mx = parent_node nx'\n  nx' \\<in> HRB_slice S\n  \\<forall>nx\\<in>set (sourcenodes as').\n     nx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms = sourcenodes as'\n\ngoal (1 subgoal):\n 1. mx \\<in> obs_intra (parent_node n)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:obs_intra_elem valid_SDG_node_in_slice_parent_node_in_slice\n                   simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  mx \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent_node n -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n     n'' \\<in> HRB_slice S;\n     \\<not> (\\<forall>nx.\n                parent_node nx \\<in> set (sourcenodes as) \\<longrightarrow>\n                nx \\<notin> HRB_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         parent_node nx\n                         \\<in> obs_intra (parent_node n)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n                         parent_node\n                          n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                        nx \\<and>\n                         parent_node\n                          nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                          n'' \\<and>\n                         as = as' @ as''", "with \\<open>parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\\<close> \\<open>mx -a'#as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>\n      \\<open>mx = parent_node nx'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  mx -a' # as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  mx = parent_node nx'\n  mx \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* mx\n  mx -a' # as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  mx = parent_node nx'\n  mx \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>nx as' as''.\n       parent_node nx\n       \\<in> obs_intra (parent_node n)\n              \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n       parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n       parent_node\n        nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n       as = as' @ as''", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>nx as' as''.\n     parent_node nx\n     \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n     parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n     as = as' @ as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nx as' as''.\n     parent_node nx\n     \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n     parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n     as = as' @ as''\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>nx as' as''.\n     parent_node nx\n     \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n     parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n     as = as' @ as''", "obtain nx as' as'' \n    where \"parent_node nx \\<in> obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    and \"parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\" \n    and \"parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\" and [simp]:\"as = as'@as''\""], ["proof (prove)\nusing this:\n  \\<exists>nx as' as''.\n     parent_node nx\n     \\<in> obs_intra (parent_node n)\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<and>\n     parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx \\<and>\n     parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'' \\<and>\n     as = as' @ as''\n\ngoal (1 subgoal):\n 1. (\\<And>nx as' as''.\n        \\<lbrakk>parent_node nx\n                 \\<in> obs_intra (parent_node n)\n                        \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n'';\n         as = as' @ as''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  parent_node nx\n  \\<in> obs_intra (parent_node n)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  as = as' @ as''\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>parent_node nx \\<in> obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> obs_eq"], ["proof (chain)\npicking this:\n  parent_node nx\n  \\<in> obs_intra (parent_node n)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (parent_node n)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (parent_node n')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"parent_node nx \\<in> obs_intra (parent_node n') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  parent_node nx\n  \\<in> obs_intra (parent_node n)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (parent_node n)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (parent_node n')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. parent_node nx\n    \\<in> obs_intra (parent_node n')\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by auto"], ["proof (state)\nthis:\n  parent_node nx\n  \\<in> obs_intra (parent_node n')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "then"], ["proof (chain)\npicking this:\n  parent_node nx\n  \\<in> obs_intra (parent_node n')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain asx where \"parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\" \n    and \"\\<forall>ni \\<in> set(sourcenodes asx). ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\" \n    and \"parent_node nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  parent_node nx\n  \\<in> obs_intra (parent_node n')\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>parent_node\n                  n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         \\<forall>ni\\<in>set (sourcenodes asx).\n            ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         parent_node nx\n         \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obs_intraE)"], ["proof (state)\nthis:\n  parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  \\<forall>ni\\<in>set (sourcenodes asx).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node nx \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n    \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes as'') \n    \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\""], ["proof (prove)\nusing this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni \\<in> set (sourcenodes as'') \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes as'') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>\\<forall>ni \\<in> set(sourcenodes asx). ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n    \\<open>parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes asx).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "have \"\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes asx) \n    \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes asx).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "proof(induct asx arbitrary:n')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes []).\n                   ni \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes []) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n 2. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "case Nil"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes []).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes []).\n                   ni \\<notin> \\<lfloor>HRB_slice\n   S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes []) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n 2. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes []).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni \\<in> set (sourcenodes []) \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes []) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "case (Cons ax' asx')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx').\n              ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   parent_node ?n' -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ni.\n                       valid_SDG_node ni \\<and>\n                       parent_node ni\n                       \\<in> set (sourcenodes asx') \\<longrightarrow>\n                       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' -ax' # asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "note IH = \\<open>\\<And>n'. \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx'). ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n      parent_node n' -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n      \\<Longrightarrow> \\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes asx') \n              \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx').\n              ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n   parent_node ?n' -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ni.\n                       valid_SDG_node ni \\<and>\n                       parent_node ni\n                       \\<in> set (sourcenodes asx') \\<longrightarrow>\n                       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "from \\<open>parent_node n' -ax'#asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' -ax' # asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "have \"parent_node n' -[]@ax'#asx'\\<rightarrow>* parent_node nx\" \n      and \"\\<forall>a \\<in> set (ax'#asx'). intra_kind(kind a)\""], ["proof (prove)\nusing this:\n  parent_node n' -ax' # asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. parent_node n' -[] @ ax' # asx'\\<rightarrow>* parent_node nx &&&\n    \\<forall>a\\<in>set (ax' # asx'). intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  parent_node n' -[] @ ax' # asx'\\<rightarrow>* parent_node nx\n  \\<forall>a\\<in>set (ax' # asx'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "hence \"targetnode ax' -asx'\\<rightarrow>* parent_node nx\" and \"valid_edge ax'\"\n      and \"parent_node n' = sourcenode ax'\""], ["proof (prove)\nusing this:\n  parent_node n' -[] @ ax' # asx'\\<rightarrow>* parent_node nx\n  \\<forall>a\\<in>set (ax' # asx'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. targetnode ax' -asx'\\<rightarrow>* parent_node nx &&&\n    valid_edge ax' &&& parent_node n' = sourcenode ax'", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  targetnode ax' -asx'\\<rightarrow>* parent_node nx\n  valid_edge ax'\n  parent_node n' = sourcenode ax'\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "with \\<open>\\<forall>a \\<in> set (ax'#asx'). intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (ax' # asx'). intra_kind (kind a)\n  targetnode ax' -asx'\\<rightarrow>* parent_node nx\n  valid_edge ax'\n  parent_node n' = sourcenode ax'", "have path:\"parent_node (CFG_node (targetnode ax')) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (ax' # asx'). intra_kind (kind a)\n  targetnode ax' -asx'\\<rightarrow>* parent_node nx\n  valid_edge ax'\n  parent_node n' = sourcenode ax'\n\ngoal (1 subgoal):\n 1. parent_node\n     (CFG_node\n       (targetnode ax')) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "by(simp add:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (CFG_node\n     (targetnode ax')) -asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "from \\<open>\\<forall>ni\\<in>set (sourcenodes (ax'#asx')). ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have all:\"\\<forall>ni\\<in>set (sourcenodes asx'). ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n      and \"sourcenode ax' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')).\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes asx').\n       ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> &&&\n    sourcenode ax' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes asx').\n     ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode ax' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "from IH[OF all path]"], ["proof (chain)\npicking this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "have \"\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes asx') \n               \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni \\<in> set (sourcenodes asx') \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "."], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "with \\<open>\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes as'') \n               \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes as'') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "have all:\"\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes (asx'@as'')) \n                   \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes as'') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni\n       \\<in> set (sourcenodes (asx' @ as'')) \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx' @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "from \\<open>parent_node n' -ax'#asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close> \n      \\<open>parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' -ax' # asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "have path:\"parent_node n' -ax'#asx'@as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  parent_node n' -ax' # asx'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. parent_node\n     n' -ax' # asx' @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "by(fastforce intro:path_Append[of _ \"ax'#asx'\",simplified] simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   n' -ax' # asx' @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "have \"\\<forall>nx'. parent_node nx' = sourcenode ax' \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>nx'.\n       parent_node nx' = sourcenode ax' \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx'.\n       parent_node nx' = sourcenode ax' \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "fix nx'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx'.\n       parent_node nx' = sourcenode ax' \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "show \"parent_node nx' = sourcenode ax' \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent_node nx' = sourcenode ax' \\<longrightarrow>\n    x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. parent_node nx' = sourcenode ax' \\<Longrightarrow>\n    x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "assume \"parent_node nx' = sourcenode ax'\""], ["proof (state)\nthis:\n  parent_node nx' = sourcenode ax'\n\ngoal (1 subgoal):\n 1. parent_node nx' = sourcenode ax' \\<Longrightarrow>\n    x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "show \"x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "assume \"x \\<in> Def\\<^bsub>SDG\\<^esub> nx'\""], ["proof (state)\nthis:\n  x \\<in> Def\\<^bsub>SDG\\<^esub> nx'\n\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "from \\<open>parent_node n' = sourcenode ax'\\<close> \\<open>parent_node nx' = sourcenode ax'\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' = sourcenode ax'\n  parent_node nx' = sourcenode ax'", "have \"parent_node nx' = parent_node n'\""], ["proof (prove)\nusing this:\n  parent_node n' = sourcenode ax'\n  parent_node nx' = sourcenode ax'\n\ngoal (1 subgoal):\n 1. parent_node nx' = parent_node n'", "by simp"], ["proof (state)\nthis:\n  parent_node nx' = parent_node n'\n\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "with \\<open>x \\<in> Def\\<^bsub>SDG\\<^esub> nx'\\<close> \\<open>x \\<in> Use\\<^bsub>SDG\\<^esub> n''\\<close> all path"], ["proof (chain)\npicking this:\n  x \\<in> Def\\<^bsub>SDG\\<^esub> nx'\n  x \\<in> Use\\<^bsub>SDG\\<^esub> n''\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx' @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  parent_node\n   n' -ax' # asx' @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node nx' = parent_node n'", "have \"nx' influences x in n''\""], ["proof (prove)\nusing this:\n  x \\<in> Def\\<^bsub>SDG\\<^esub> nx'\n  x \\<in> Use\\<^bsub>SDG\\<^esub> n''\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx' @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  parent_node\n   n' -ax' # asx' @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  parent_node nx' = parent_node n'\n\ngoal (1 subgoal):\n 1. nx' influences x in n''", "by(fastforce simp:data_dependence_def)"], ["proof (state)\nthis:\n  nx' influences x in n''\n\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "hence \"nx' s-x\\<rightarrow>\\<^sub>d\\<^sub>d n''\""], ["proof (prove)\nusing this:\n  nx' influences x in n''\n\ngoal (1 subgoal):\n 1. nx' s-x\\<rightarrow>\\<^sub>d\\<^sub>d n''", "by(rule sum_SDG_ddep_edge)"], ["proof (state)\nthis:\n  nx' s-x\\<rightarrow>\\<^sub>d\\<^sub>d n''\n\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "with \\<open>n'' \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  n'' \\<in> HRB_slice S\n  nx' s-x\\<rightarrow>\\<^sub>d\\<^sub>d n''", "have \"nx' \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  n'' \\<in> HRB_slice S\n  nx' s-x\\<rightarrow>\\<^sub>d\\<^sub>d n''\n\ngoal (1 subgoal):\n 1. nx' \\<in> HRB_slice S", "by(fastforce elim:combine_SDG_slices.cases \n                       intro:combine_SDG_slices.intros ddep_slice1 ddep_slice2 \n                        simp:HRB_slice_def)"], ["proof (state)\nthis:\n  nx' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "hence \"CFG_node (parent_node nx') \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  nx' \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (parent_node nx') \\<in> HRB_slice S", "by(rule valid_SDG_node_in_slice_parent_node_in_slice)"], ["proof (state)\nthis:\n  CFG_node (parent_node nx') \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. x \\<in> Def\\<^bsub>SDG\\<^esub> nx' \\<Longrightarrow> False", "with \\<open>sourcenode ax' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>parent_node n' = sourcenode ax'\\<close>\n            \\<open>parent_node nx' = sourcenode ax'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' = sourcenode ax'\n  parent_node nx' = sourcenode ax'\n  CFG_node (parent_node nx') \\<in> HRB_slice S", "show False"], ["proof (prove)\nusing this:\n  sourcenode ax' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' = sourcenode ax'\n  parent_node nx' = sourcenode ax'\n  CFG_node (parent_node nx') \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. False", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  parent_node nx' = sourcenode ax' \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>nx'.\n     parent_node nx' = sourcenode ax' \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> \\<lfloor>HRB_slice\n               S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n                    parent_node\n                     n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node\n                    nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni.\n  valid_SDG_node ni \\<and>\n  parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n  x \\<notin> Def\\<^bsub>SDG\\<^esub> ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        parent_node\n         n' -a # asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni.\n                            valid_SDG_node ni \\<and>\n                            parent_node ni\n                            \\<in> set (sourcenodes\n  (a # asx)) \\<longrightarrow>\n                            x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "with all"], ["proof (chain)\npicking this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx' @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>nx'.\n     parent_node nx' = sourcenode ax' \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx' @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>nx'.\n     parent_node nx' = sourcenode ax' \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> nx'\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni \\<in> set (sourcenodes (ax' # asx')) \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "by(auto simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (ax' # asx')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "with \\<open>\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes as'') \n             \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes as'') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "have all:\"\\<forall>ni. valid_SDG_node ni \\<and> parent_node ni \\<in> set (sourcenodes (asx@as'')) \n                 \\<longrightarrow> x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes as'') \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes asx) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. \\<forall>ni.\n       valid_SDG_node ni \\<and>\n       parent_node ni \\<in> set (sourcenodes (asx @ as'')) \\<longrightarrow>\n       x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "with \\<open>parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close> \n    \\<open>parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\\<close>"], ["proof (chain)\npicking this:\n  parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "have \"parent_node n' -asx@as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\""], ["proof (prove)\nusing this:\n  parent_node n' -asx\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  parent_node nx -as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. parent_node n' -asx @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''", "by(fastforce intro:path_Append simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node n' -asx @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from this \\<open>n'' \\<in> HRB_slice S\\<close> \\<open>x \\<in> Use\\<^bsub>SDG\\<^esub> n''\\<close> all"], ["proof (chain)\npicking this:\n  parent_node n' -asx @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S\n  x \\<in> Use\\<^bsub>SDG\\<^esub> n''\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni", "show \"x \\<in> rv S n'\""], ["proof (prove)\nusing this:\n  parent_node n' -asx @ as''\\<rightarrow>\\<^sub>\\<iota>* parent_node n''\n  n'' \\<in> HRB_slice S\n  x \\<in> Use\\<^bsub>SDG\\<^esub> n''\n  \\<forall>ni.\n     valid_SDG_node ni \\<and>\n     parent_node ni \\<in> set (sourcenodes (asx @ as'')) \\<longrightarrow>\n     x \\<notin> Def\\<^bsub>SDG\\<^esub> ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "by(rule rvI)"], ["proof (state)\nthis:\n  x \\<in> rv S n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_eq_obs_eq_rvs:\n  fixes S :: \"'node SDG_node set\"\n  assumes obs_eq:\"obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n  obs_intra (parent_node n') \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"rv S n = rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S n = rv S n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rv S n \\<subseteq> rv S n'\n 2. rv S n' \\<subseteq> rv S n", "show \"rv S n \\<subseteq> rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S n \\<subseteq> rv S n'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n \\<Longrightarrow> x \\<in> rv S n'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n \\<Longrightarrow> x \\<in> rv S n'", "assume \"x \\<in> rv S n\""], ["proof (state)\nthis:\n  x \\<in> rv S n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n \\<Longrightarrow> x \\<in> rv S n'", "with obs_eq"], ["proof (chain)\npicking this:\n  obs_intra (parent_node n)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (parent_node n')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S n", "show \"x \\<in> rv S n'\""], ["proof (prove)\nusing this:\n  obs_intra (parent_node n)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (parent_node n')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S n\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "by(rule eq_obs_intra_in_rv)"], ["proof (state)\nthis:\n  x \\<in> rv S n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rv S n \\<subseteq> rv S n'\n\ngoal (1 subgoal):\n 1. rv S n' \\<subseteq> rv S n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rv S n' \\<subseteq> rv S n", "show \"rv S n' \\<subseteq> rv S n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S n' \\<subseteq> rv S n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n' \\<Longrightarrow> x \\<in> rv S n", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n' \\<Longrightarrow> x \\<in> rv S n", "assume \"x \\<in> rv S n'\""], ["proof (state)\nthis:\n  x \\<in> rv S n'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n' \\<Longrightarrow> x \\<in> rv S n", "with obs_eq[THEN sym]"], ["proof (chain)\npicking this:\n  obs_intra (parent_node n')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S n'", "show \"x \\<in> rv S n\""], ["proof (prove)\nusing this:\n  obs_intra (parent_node n')\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (parent_node n) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S n'\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n", "by(rule eq_obs_intra_in_rv)"], ["proof (state)\nthis:\n  x \\<in> rv S n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rv S n' \\<subseteq> rv S n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_eq_obs_eq_rvs':\n  fixes S :: \"'node SDG_node set\"\n  assumes obs_eq:\"obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs_intra m' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"rv S (CFG_node m) = rv S (CFG_node m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S (CFG_node m) = rv S (CFG_node m')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rv S (CFG_node m) \\<subseteq> rv S (CFG_node m')\n 2. rv S (CFG_node m') \\<subseteq> rv S (CFG_node m)", "show \"rv S (CFG_node m) \\<subseteq> rv S (CFG_node m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S (CFG_node m) \\<subseteq> rv S (CFG_node m')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rv S (CFG_node m) \\<Longrightarrow>\n       x \\<in> rv S (CFG_node m')", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rv S (CFG_node m) \\<Longrightarrow>\n       x \\<in> rv S (CFG_node m')", "assume \"x \\<in> rv S (CFG_node m)\""], ["proof (state)\nthis:\n  x \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rv S (CFG_node m) \\<Longrightarrow>\n       x \\<in> rv S (CFG_node m')", "with obs_eq"], ["proof (chain)\npicking this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra m' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S (CFG_node m)", "show \"x \\<in> rv S (CFG_node m')\""], ["proof (prove)\nusing this:\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra m' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. x \\<in> rv S (CFG_node m')", "by -(rule eq_obs_intra_in_rv,auto)"], ["proof (state)\nthis:\n  x \\<in> rv S (CFG_node m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rv S (CFG_node m) \\<subseteq> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. rv S (CFG_node m') \\<subseteq> rv S (CFG_node m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rv S (CFG_node m') \\<subseteq> rv S (CFG_node m)", "show \"rv S (CFG_node m') \\<subseteq> rv S (CFG_node m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S (CFG_node m') \\<subseteq> rv S (CFG_node m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rv S (CFG_node m') \\<Longrightarrow>\n       x \\<in> rv S (CFG_node m)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rv S (CFG_node m') \\<Longrightarrow>\n       x \\<in> rv S (CFG_node m)", "assume \"x \\<in> rv S (CFG_node m')\""], ["proof (state)\nthis:\n  x \\<in> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rv S (CFG_node m') \\<Longrightarrow>\n       x \\<in> rv S (CFG_node m)", "with obs_eq[THEN sym]"], ["proof (chain)\npicking this:\n  obs_intra m' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S (CFG_node m')", "show \"x \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  obs_intra m' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra m \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x \\<in> rv S (CFG_node m')\n\ngoal (1 subgoal):\n 1. x \\<in> rv S (CFG_node m)", "by -(rule eq_obs_intra_in_rv,auto)"], ["proof (state)\nthis:\n  x \\<in> rv S (CFG_node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rv S (CFG_node m') \\<subseteq> rv S (CFG_node m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rv_branching_edges_slice_kinds_False:\n  assumes \"valid_edge a\" and \"valid_edge ax\" \n  and \"sourcenode a = sourcenode ax\" and \"targetnode a \\<noteq> targetnode ax\"\n  and \"intra_kind (kind a)\" and \"intra_kind (kind ax)\"\n  and \"preds (slice_kinds S (a#as)) s\" \n  and \"preds (slice_kinds S (ax#asx)) s'\"\n  and \"length s = length s'\" and \"snd (hd s) = snd (hd s')\"\n  and \"\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = sourcenode ax\\<close> \n    \\<open>targetnode a \\<noteq> targetnode ax\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode a \\<noteq> targetnode ax\n  intra_kind (kind a)\n  intra_kind (kind ax)", "obtain Q Q' where \"kind a = (Q)\\<^sub>\\<surd>\" and \"kind ax = (Q')\\<^sub>\\<surd>\"\n    and \"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode a \\<noteq> targetnode ax\n  intra_kind (kind a)\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>kind a = (Q)\\<^sub>\\<surd>; kind ax = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n  kind ax = (Q')\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n\ngoal (1 subgoal):\n 1. False", "from \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = sourcenode ax\\<close> \n    \\<open>targetnode a \\<noteq> targetnode ax\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode a \\<noteq> targetnode ax\n  intra_kind (kind a)\n  intra_kind (kind ax)", "obtain P P' where \"slice_kind S a = (P)\\<^sub>\\<surd>\" \n    and \"slice_kind S ax = (P')\\<^sub>\\<surd>\"\n    and \"\\<forall>s. (P s \\<longrightarrow> \\<not> P' s) \\<and> (P' s \\<longrightarrow> \\<not> P s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = sourcenode ax\n  targetnode a \\<noteq> targetnode ax\n  intra_kind (kind a)\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. (\\<And>P P'.\n        \\<lbrakk>slice_kind S a = (P)\\<^sub>\\<surd>;\n         slice_kind S ax = (P')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (P s \\<longrightarrow> \\<not> P' s) \\<and>\n            (P' s \\<longrightarrow> \\<not> P s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule slice_deterministic,auto)"], ["proof (state)\nthis:\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  \\<forall>s.\n     (P s \\<longrightarrow> \\<not> P' s) \\<and>\n     (P' s \\<longrightarrow> \\<not> P s)\n\ngoal (1 subgoal):\n 1. False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by -(rule slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>preds (slice_kinds S (a#as)) s\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \n      \\<open>slice_kind S a = (P)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  slice_kind S a = kind a", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  slice_kind S a = kind a\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from True \\<open>sourcenode a = sourcenode ax\\<close> \\<open>intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a = sourcenode ax\n  intra_kind (kind ax)", "have \"slice_kind S ax = kind ax\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a = sourcenode ax\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. slice_kind S ax = kind ax", "by(fastforce intro:slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S ax = kind ax\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>preds (slice_kinds S (ax#asx)) s'\\<close> \\<open>kind ax = (Q')\\<^sub>\\<surd>\\<close>\n      \\<open>slice_kind S ax = (P')\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (ax # asx)) s'\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  slice_kind S ax = kind ax", "have \"pred (kind ax) s'\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (ax # asx)) s'\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  slice_kind S ax = kind ax\n\ngoal (1 subgoal):\n 1. pred (kind ax) s'", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind ax) s'\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind ax = (Q')\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  pred (kind ax) s'", "have \"Q' (fst (hd s'))\""], ["proof (prove)\nusing this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  pred (kind ax) s'\n\ngoal (1 subgoal):\n 1. Q' (state_val s')", "by(cases s') auto"], ["proof (state)\nthis:\n  Q' (state_val s')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with True \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "have \"\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       V \\<in> rv S (CFG_node (sourcenode a))", "by(auto intro!:rvI CFG_Use_SDG_Use simp:sourcenodes_def SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))", "have \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "by blast"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>pred (kind ax) s'\\<close> \\<open>length s = length s'\\<close>\n      \\<open>snd (hd s) = snd (hd s')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\n  pred (kind ax) s'\n  length s = length s'\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\n  pred (kind ax) s'\n  length s = length s'\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(auto intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  pred (kind a) s'", "have \"Q (fst (hd s'))\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. Q (state_val s')", "by(cases s') auto"], ["proof (state)\nthis:\n  Q (state_val s')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>Q' (fst (hd s'))\\<close> \\<open>\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\\<close>"], ["proof (chain)\npicking this:\n  Q' (state_val s')\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q (state_val s')", "have False"], ["proof (prove)\nusing this:\n  Q' (state_val s')\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q (state_val s')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \\<open>slice_kind S a = (P)\\<^sub>\\<surd>\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  valid_edge a\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  valid_edge a\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)", "by(fastforce elim:kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>slice_kind S a = (P)\\<^sub>\\<surd>\\<close> \n      \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  preds (slice_kinds S (a # as)) s\n  P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)", "have \"P = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  preds (slice_kinds S (a # as)) s\n  P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>s. True)", "by(cases s)(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  P = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>sourcenode a = sourcenode ax\\<close> False"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode ax\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode ax\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind ax = (Q')\\<^sub>\\<surd>\\<close> \\<open>slice_kind S ax = (P')\\<^sub>\\<surd>\\<close> \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  valid_edge ax\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  valid_edge ax\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)", "by(fastforce elim:kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>slice_kind S ax = (P')\\<^sub>\\<surd>\\<close> \n      \\<open>preds (slice_kinds S (ax#asx)) s'\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  preds (slice_kinds S (ax # asx)) s'\n  P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)", "have \"P' = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  preds (slice_kinds S (ax # asx)) s'\n  P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. P' = (\\<lambda>s. True)", "by(cases s')(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>P = (\\<lambda>s. True)\\<close> \\<open>\\<forall>s. (P s \\<longrightarrow> \\<not> P' s) \\<and> (P' s \\<longrightarrow> \\<not> P s)\\<close>"], ["proof (chain)\npicking this:\n  P = (\\<lambda>s. True)\n  \\<forall>s.\n     (P s \\<longrightarrow> \\<not> P' s) \\<and>\n     (P' s \\<longrightarrow> \\<not> P s)\n  P' = (\\<lambda>s. True)", "have False"], ["proof (prove)\nusing this:\n  P = (\\<lambda>s. True)\n  \\<forall>s.\n     (P s \\<longrightarrow> \\<not> P' s) \\<and>\n     (P' s \\<longrightarrow> \\<not> P s)\n  P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rv_edge_slice_kinds:\n  assumes \"valid_edge a\" and \"intra_kind (kind a)\"\n  and \"\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\"\n  and \"preds (slice_kinds S (a#as)) s\" and \"preds (slice_kinds S (a#asx)) s'\"\n  shows \"\\<forall>V\\<in>rv S (CFG_node (targetnode a)). \n  state_val (transfer (slice_kind S a) s) V = \n  state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "assume \"V \\<in> rv S (CFG_node (targetnode a))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "from \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have \"s \\<noteq> []\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. s \\<noteq> []", "by(cases s,auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "from \\<open>preds (slice_kinds S (a#asx)) s'\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # asx)) s'", "have \"s' \\<noteq> []\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # asx)) s'\n\ngoal (1 subgoal):\n 1. s' \\<noteq> []", "by(cases s',auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "show \"state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"V \\<in> Def (sourcenode a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  V \\<in> Def (sourcenode a)\n\ngoal (2 subgoals):\n 1. V \\<in> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by -(rule slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = kind a", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = kind a\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>slice_kind S a = kind a\\<close> \n        \\<open>preds (slice_kinds S (a#asx)) s'\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = kind a\n  preds (slice_kinds S (a # asx)) s'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  slice_kind S a = kind a\n  preds (slice_kinds S (a # asx)) s'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with True \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "have \"\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       V \\<in> rv S (CFG_node (sourcenode a))", "by(auto intro!:rvI CFG_Use_SDG_Use simp:sourcenodes_def SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))", "have \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "by blast"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> this \\<open>pred (kind a) s\\<close> \\<open>pred (kind a) s'\\<close>\n        \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  pred (kind a) s\n  pred (kind a) s'\n  intra_kind (kind a)", "have \"\\<forall>V \\<in> Def (sourcenode a). \n        state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  pred (kind a) s\n  pred (kind a) s'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def (sourcenode a).\n       state_val (transfer (kind a) s) V =\n       state_val (transfer (kind a) s') V", "by -(rule CFG_intra_edge_transfer_uses_only_Use,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>V \\<in> Def (sourcenode a)\\<close> \\<open>slice_kind S a = kind a\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def (sourcenode a)\n  slice_kind S a = kind a\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> Def (sourcenode a)\n  slice_kind S a = kind a\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))", "obtain xs nx where \"targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\"\n        and \"nx \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> nx\"\n        and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes xs) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>xs nx.\n        \\<lbrakk>targetnode\n                  a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> \\<open>targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  intra_kind (kind a)", "have \"sourcenode a -a#xs \\<rightarrow>\\<^sub>\\<iota>* parent_node nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "by(fastforce intro:path.Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>V \\<in> Def (sourcenode a)\\<close> \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> nx\\<close> \\<open>valid_node (sourcenode a)\\<close>\n        \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes xs) \n        \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def (sourcenode a)\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  valid_node (sourcenode a)\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "have \"(CFG_node (sourcenode a)) influences V in nx\""], ["proof (prove)\nusing this:\n  V \\<in> Def (sourcenode a)\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  valid_node (sourcenode a)\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) influences V in nx", "by(fastforce intro:CFG_Def_SDG_Def simp:data_dependence_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) influences V in nx\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "hence \"(CFG_node (sourcenode a)) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) influences V in nx\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx", "by(rule sum_SDG_ddep_edge)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>nx \\<in> HRB_slice S\\<close> \\<open>(CFG_node (sourcenode a)) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> HRB_slice S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx", "have \"CFG_node (sourcenode a) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  nx \\<in> HRB_slice S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "proof(induct rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n nx.\n       \\<lbrakk>n \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p n.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        n \\<in> sum_SDG_slice2 n'; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "case (phase1 n nx')"], ["proof (state)\nthis:\n  n \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n\ngoal (2 subgoals):\n 1. \\<And>n nx.\n       \\<lbrakk>n \\<in> sum_SDG_slice1 nx; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p n.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        n \\<in> sum_SDG_slice2 n'; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "with \\<open>(CFG_node (sourcenode a)) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\n  n \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n", "show ?case"], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d nx\n  n \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(fastforce intro:intro:ddep_slice1 combine_SDG_slices.combSlice_refl \n                       simp:HRB_slice_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p n.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        n \\<in> sum_SDG_slice2 n'; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p n.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        n \\<in> sum_SDG_slice2 n'; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "case (phase2 nx' n' n'' p n)"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n \\<in> sum_SDG_slice2 n'\n  nx' \\<in> S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p n.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        n \\<in> sum_SDG_slice2 n'; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "from \\<open>(CFG_node (sourcenode a)) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<close> \\<open>n \\<in> sum_SDG_slice2 n'\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n  n \\<in> sum_SDG_slice2 n'", "have \"CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n  n \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'", "by(rule ddep_slice2)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p n.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        n \\<in> sum_SDG_slice2 n'; nx \\<in> S;\n        CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "with phase2"], ["proof (chain)\npicking this:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n \\<in> sum_SDG_slice2 n'\n  nx' \\<in> S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n \\<in> sum_SDG_slice2 n'\n  nx' \\<in> S\n  CFG_node (sourcenode a) s-V\\<rightarrow>\\<^sub>d\\<^sub>d n\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_Return_parent_node \n                       simp:HRB_slice_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with False"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) \\<in> HRB_slice S", "have False"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. False", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))", "obtain xs nx where \"targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\"\n      and \"nx \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> nx\"\n      and all:\"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes xs) \n                 \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>xs nx.\n        \\<lbrakk>targetnode\n                  a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> \\<open>targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  intra_kind (kind a)", "have \"sourcenode a -a#xs \\<rightarrow>\\<^sub>\\<iota>* parent_node nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "by(fastforce intro:path.Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from False all"], ["proof (chain)\npicking this:\n  V \\<notin> Def (sourcenode a)\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes (a#xs)) \n                 \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<notin> Def (sourcenode a)\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes xs) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' \\<in> set (sourcenodes (a # xs)) \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce dest:SDG_Def_parent_Def simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a # xs)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>sourcenode a -a#xs \\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close> \\<open>nx \\<in> HRB_slice S\\<close>\n      \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> nx\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a # xs)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a -a # xs\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a # xs)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "show ?thesis"], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"kind a\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V", "case(UpdateEdge f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>intra_kind (kind a); kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 3. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by(fastforce intro:slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from UpdateEdge \\<open>s \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f\n  s \\<noteq> []", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  kind a = \\<Up>f\n  s \\<noteq> []\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(cases s) auto"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>valid_edge a\\<close> \\<open>V \\<notin> Def (sourcenode a)\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  pred (kind a) s", "have \"state_val (transfer (kind a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = state_val s V", "by(fastforce intro:CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) V = state_val s V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from UpdateEdge \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f\n  s' \\<noteq> []", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  kind a = \\<Up>f\n  s' \\<noteq> []\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(cases s') auto"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>valid_edge a\\<close> \\<open>V \\<notin> Def (sourcenode a)\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  pred (kind a) s'", "have \"state_val (transfer (kind a) s') V = state_val s' V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s') V = state_val s' V", "by(fastforce intro:CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s') V = state_val s' V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\\<close>\n          \\<open>state_val (transfer (kind a) s) V = state_val s V\\<close>\n          \\<open>V \\<in> rv S (CFG_node (sourcenode a))\\<close> \\<open>slice_kind S a = kind a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  state_val (transfer (kind a) s) V = state_val s V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  slice_kind S a = kind a\n  state_val (transfer (kind a) s') V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  state_val (transfer (kind a) s) V = state_val s V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  slice_kind S a = kind a\n  state_val (transfer (kind a) s') V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by fastforce"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with UpdateEdge"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  kind a = \\<Up>f\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by -(rule slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\\<close>\n          \\<open>V \\<in> rv S (CFG_node (sourcenode a))\\<close> \\<open>s \\<noteq> []\\<close> \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  s \\<noteq> []\n  s' \\<noteq> []\n  slice_kind S a = \\<Up>id", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  s \\<noteq> []\n  s' \\<noteq> []\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by(cases s,auto,cases s',auto)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V", "case (PredicateEdge Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>intra_kind (kind a); kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 3. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with PredicateEdge \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (Q)\\<^sub>\\<surd>", "by(simp add:slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\\<close>\n          \\<open>V \\<in> rv S (CFG_node (sourcenode a))\\<close> \\<open>s \\<noteq> []\\<close> \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  s \\<noteq> []\n  s' \\<noteq> []\n  slice_kind S a = (Q)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  s \\<noteq> []\n  s' \\<noteq> []\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by(cases s,auto,cases s',auto)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with PredicateEdge \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  valid_edge a\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  valid_edge a\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        slice_kind S a = (Q')\\<^sub>\\<surd> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  slice_kind S a = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with\\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). state_val s V = state_val s' V\\<close>\n          \\<open>V \\<in> rv S (CFG_node (sourcenode a))\\<close> \\<open>s \\<noteq> []\\<close> \\<open>s' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  s \\<noteq> []\n  s' \\<noteq> []\n  slice_kind S a = (Q')\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     state_val s V = state_val s' V\n  V \\<in> rv S (CFG_node (sourcenode a))\n  s \\<noteq> []\n  s' \\<noteq> []\n  slice_kind S a = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by(cases s,auto,cases s',auto)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (2 subgoals):\n 1. \\<And>x31 x32 x33 x34.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x31:x32\\<hookrightarrow>\\<^bsub>x33\\<^esub>x34\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x41 x42 x43.\n       \\<lbrakk>intra_kind (kind a);\n        kind a = x41\\<hookleftarrow>\\<^bsub>x42\\<^esub>x43\\<rbrakk>\n       \\<Longrightarrow> state_val (transfer (slice_kind S a) s) V =\n                         state_val (transfer (slice_kind S a) s') V", "qed (auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The weak simulation relational set \\<open>WS\\<close>\\<close>"], ["", "inductive_set WS :: \"'node SDG_node set \\<Rightarrow> (('node list \\<times> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list) \\<times> \n  ('node list \\<times> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list)) set\"\nfor S :: \"'node SDG_node set\"\n  where WSI: \"\\<lbrakk>\\<forall>m \\<in> set ms. valid_node m; \\<forall>m' \\<in> set ms'. valid_node m'; \n  length ms = length s; length ms' = length s'; s \\<noteq> []; s' \\<noteq> []; ms = msx@mx#tl ms';\n  get_proc mx = get_proc (hd ms'); \n  \\<forall>m \\<in> set (tl ms'). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n  msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n  \\<forall>i < length ms'. snd (s!(length msx + i)) = snd (s'!i);\n  \\<forall>m \\<in> set (tl ms). return_node m;\n  \\<forall>i < length ms'. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms')!i)). \n    (fst (s!(length msx + i))) V = (fst (s'!i)) V;\n  obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ((ms,s),(ms',s')) \\<in> WS S\""], ["", "lemma WS_silent_move:\n  assumes \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\" and \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  shows \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "obtain msx mx\n    where WSE:\"\\<forall>m \\<in> set ms\\<^sub>1. valid_node m\" \"\\<forall>m \\<in> set ms\\<^sub>2. valid_node m\"\n    \"length ms\\<^sub>1 = length s\\<^sub>1\" \"length ms\\<^sub>2 = length s\\<^sub>2\" \"s\\<^sub>1 \\<noteq> []\" \"s\\<^sub>2 \\<noteq> []\" \n    \"ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\" \"get_proc mx = get_proc (hd ms\\<^sub>2)\"\n    \"\\<forall>m \\<in> set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    \"msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\"\n    \"\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\"\n    \"\\<forall>i < length ms\\<^sub>2. snd (s\\<^sub>1!(length msx + i)) = snd (s\\<^sub>2!i)\"\n    \"\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\"\n    \"obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>msx mx.\n        \\<lbrakk>Ball (set ms\\<^sub>1) valid_node;\n         Ball (set ms\\<^sub>2) valid_node;\n         length ms\\<^sub>1 = length s\\<^sub>1;\n         length ms\\<^sub>2 = length s\\<^sub>2; s\\<^sub>1 \\<noteq> [];\n         s\\<^sub>2 \\<noteq> []; ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2;\n         get_proc mx = get_proc (hd ms\\<^sub>2);\n         \\<forall>m\\<in>set (tl ms\\<^sub>2).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         msx \\<noteq> [] \\<longrightarrow>\n         (\\<exists>mx'.\n             call_of_return_node mx mx' \\<and>\n             mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n         Ball (set (tl ms\\<^sub>1)) return_node;\n         \\<forall>i<length ms\\<^sub>2.\n            snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n         \\<forall>i<length ms\\<^sub>2.\n            \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n               fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n         obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         obs ms\\<^sub>2\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS.cases)"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "{"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "assume \"\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\""], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(cases \"obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case True"], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (2 subgoals):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "have \"obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "by(rule silent_move_empty_obs_slice)"], ["proof (state)\nthis:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (2 subgoals):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n 2. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close>"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "case False"], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from this \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\\<close>"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  Ball (set (tl ms\\<^sub>1')) return_node", "obtain ms' where \"obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (1 subgoal):\n 1. (\\<And>ms'.\n        obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        {ms'} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:obs_singleton_element)"], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "hence \"ms' \\<in> obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\n\ngoal (1 subgoal):\n 1. ms'\n    \\<in> obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  ms' \\<in> obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\\<close> \\<open>ms' \\<in> obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n        \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\n  ms' \\<in> obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node", "have \"ms' \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\n  ms' \\<in> obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (1 subgoal):\n 1. ms'\n    \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:silent_move_obs_slice)"], ["proof (state)\nthis:\n  ms' \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from this \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>"], ["proof (chain)\npicking this:\n  ms' \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node", "have \"obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\""], ["proof (prove)\nusing this:\n  ms' \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}", "by(rule obs_singleton_element)"], ["proof (state)\nthis:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1'\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\\<close> \n        \\<open>obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}", "show ?thesis"], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {ms'}\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "}"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\\<close> WSE"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1')\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "proof(induct S f\\<equiv>\"kind\" ms\\<^sub>1 s\\<^sub>1 a ms\\<^sub>1' s\\<^sub>1' rule:silent_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (silent_move_intra a s\\<^sub>1 s\\<^sub>1' ms\\<^sub>1 S ms\\<^sub>1')"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  intra_kind (kind a)\n  (\\<exists>m\\<in>set (tl ms\\<^sub>1).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n  length s\\<^sub>1' = length s\\<^sub>1\n  length ms\\<^sub>1 = length s\\<^sub>1\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "note obs_eq = \\<open>\\<forall>a\\<in>set (tl ms\\<^sub>1'). return_node a \\<Longrightarrow>\n      obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>s\\<^sub>1 \\<noteq> []\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []", "obtain cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2 where [simp]:\"s\\<^sub>1 = cf\\<^sub>1#cfs\\<^sub>1\" \n    and [simp]:\"s\\<^sub>2 = cf\\<^sub>2#cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2.\n        \\<lbrakk>s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1;\n         s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>1,auto,cases s\\<^sub>2,fastforce+)"], ["proof (state)\nthis:\n  s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1\n  s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)", "obtain cf\\<^sub>1' where [simp]:\"s\\<^sub>1' = cf\\<^sub>1'#cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1'.\n        s\\<^sub>1' = cf\\<^sub>1' # cfs\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases cf\\<^sub>1,cases \"kind a\",auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  s\\<^sub>1' = cf\\<^sub>1' # cfs\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m \\<in> set ms\\<^sub>1. valid_node m\\<close> \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  valid_edge a", "have \"\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  valid_edge a\n\ngoal (1 subgoal):\n 1. Ball (set ms\\<^sub>1') valid_node", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1') valid_node\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1' = length s\\<^sub>1\\<close> \n      \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1' = length s\\<^sub>1\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1", "have \"length ms\\<^sub>1' = length s\\<^sub>1'\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1' = length s\\<^sub>1\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1' = length s\\<^sub>1'", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close> \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1", "have \"\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>1')) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from obs_eq[OF this]"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "."], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length s' = length s;\n        length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = []", "have [simp]:\"mx = sourcenode a\" and [simp]:\"tl ms\\<^sub>1 = tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = []\n\ngoal (1 subgoal):\n 1. mx = sourcenode a &&& tl ms\\<^sub>1 = tl ms\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  mx = sourcenode a\n  tl ms\\<^sub>1 = tl ms\\<^sub>2\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>(\\<exists>m\\<in>set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms\\<^sub>1).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms\\<^sub>1).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd ms\\<^sub>1 = sourcenode a\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 = sourcenode a\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1", "have \"ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a\\<close> \\<open>intra_kind(kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  get_proc (sourcenode a) = get_proc (targetnode a)", "have \"get_proc (targetnode a) = get_proc (hd ms\\<^sub>2)\""], ["proof (prove)\nusing this:\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = get_proc (hd ms\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  get_proc (targetnode a) = get_proc (hd ms\\<^sub>2)\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)", "have \"snd cf\\<^sub>1' = snd cf\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. snd cf\\<^sub>1' = snd cf\\<^sub>1", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  snd cf\\<^sub>1' = snd cf\\<^sub>1\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> Nil"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = []\n  snd cf\\<^sub>1' = snd cf\\<^sub>1", "have \"\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! i) = snd (s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = []\n  snd cf\\<^sub>1' = snd cf\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! i) = snd (s\\<^sub>2 ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! i) = snd (s\\<^sub>2 ! i)\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"\\<forall>V \\<in> rv S (CFG_node (targetnode a)). fst cf\\<^sub>1' V = fst cf\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "assume \"V \\<in> rv S (CFG_node (targetnode a))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (targetnode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = \n          obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (targetnode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule edge_obs_intra_slice_eq)"], ["proof (state)\nthis:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "hence \"rv S (CFG_node (targetnode a)) = rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  obs_intra (targetnode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. rv S (CFG_node (targetnode a)) = rv S (CFG_node (sourcenode a))", "by(rule closed_eq_obs_eq_rvs')"], ["proof (state)\nthis:\n  rv S (CFG_node (targetnode a)) = rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "with \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))\n  rv S (CFG_node (targetnode a)) = rv S (CFG_node (sourcenode a))", "have \"V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n  rv S (CFG_node (targetnode a)) = rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode a))", "by simp"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "then"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (sourcenode a))", "obtain as n' where \"sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" \n          and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n          and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n                     \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>sourcenode\n                  a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"V \\<notin> Def\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  sourcenode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<notin> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)", "apply(clarsimp simp:intra_path_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a\n             \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n     valid_edge a; n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n     \\<forall>n''.\n        valid_SDG_node n'' \\<and>\n        parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n        V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n     sourcenode a -as\\<rightarrow>* parent_node n';\n     \\<forall>a\\<in>set as. intra_kind (kind a);\n     V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule path.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>sourcenode a\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        valid_edge a; n' \\<in> HRB_slice S;\n        V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as. intra_kind (kind a);\n        V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a);\n        sourcenode a = n; as = []; parent_node n' = n; valid_node n\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n'' asa n'a a n.\n       \\<lbrakk>sourcenode a\n                \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        valid_edge a; n' \\<in> HRB_slice S;\n        V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as. intra_kind (kind a);\n        V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a);\n        sourcenode a = n; as = a # asa; parent_node n' = n'a;\n        n'' -asa\\<rightarrow>* n'a; valid_edge a; sourcenode a = n;\n        targetnode a = n''\\<rbrakk>\n       \\<Longrightarrow> False", "by(auto dest:valid_SDG_node_in_slice_parent_node_in_slice \n                  simp:sourcenodes_def SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  V \\<notin> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "with \\<open>V \\<notin> Def\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  valid_node (sourcenode a)", "have \"V \\<notin> Def (sourcenode a)\""], ["proof (prove)\nusing this:\n  V \\<notin> Def\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a)", "by(fastforce intro:CFG_Def_SDG_Def valid_SDG_CFG_node)"], ["proof (state)\nthis:\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  V \\<notin> Def (sourcenode a)", "have \"state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V", "by(fastforce intro:CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V", "have \"fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = fst cf\\<^sub>1 V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "from \\<open>V \\<in> rv S (CFG_node (sourcenode a))\\<close> \\<open>msx = []\\<close>\n          \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (sourcenode a))\n  msx = []\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "have \"fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (sourcenode a))\n  msx = []\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "with \\<open>fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\\<close>"], ["proof (chain)\npicking this:\n  fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\n  fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "show \"fst cf\\<^sub>1' V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\n  fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = fst cf\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     fst cf\\<^sub>1' V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        (fst (s\\<^sub>1 ! (length msx + i))) V = (fst (s\\<^sub>2 ! i)) V\\<close> Nil"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = []\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     fst cf\\<^sub>1' V = fst cf\\<^sub>2 V", "have \"\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>2) ! i)).\n        (fst (s\\<^sub>1' ! (length [] + i))) V = (fst (s\\<^sub>2 ! i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = []\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     fst cf\\<^sub>1' V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>2) ! i)).\n          fst (s\\<^sub>1' ! (length [] + i)) V = fst (s\\<^sub>2 ! i) V", "by auto (case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V = fst (s\\<^sub>2 ! i) V\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\\<close> \\<open>\\<forall>m \\<in> set ms\\<^sub>2. valid_node m\\<close>\n        \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>\n        \\<open>ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\\<close> \n        \\<open>get_proc (targetnode a) = get_proc (hd ms\\<^sub>2)\\<close>\n        \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>\n        \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! i) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  get_proc (targetnode a) = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! i) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V = fst (s\\<^sub>2 ! i) V", "show ?thesis"], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  get_proc (targetnode a) = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! i) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V = fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(auto intro!:WSI)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (Cons mx' msx')"], ["proof (state)\nthis:\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = mx' # msx'", "have [simp]:\"mx' = sourcenode a\" and [simp]:\"tl ms\\<^sub>1 = msx'@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. mx' = sourcenode a &&& tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  mx' = sourcenode a\n  tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1", "have \"ms\\<^sub>1' = ((targetnode a)#msx')@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = (targetnode a # msx') @ mx # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = (targetnode a # msx') @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'", "have rv:\"\\<forall>V\\<in>rv S (CFG_node mx).\n        (fst (s\\<^sub>1' ! length (targetnode a#msx'))) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length (targetnode a # msx')) V =\n       state_val s\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length (targetnode a # msx')) V =\n     state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> Cons \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx = mx' # msx'\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1", "have \"ms\\<^sub>1' = ((targetnode a)#msx')@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx = mx' # msx'\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = (targetnode a # msx') @ mx # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = (targetnode a # msx') @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = mx' # msx'", "have \"\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! (length msx + i)) = snd (s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       snd (s\\<^sub>1' ! (length msx + i)) = snd (s\\<^sub>2 ! i)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1' ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx) V = state_val s\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n        (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx) V = state_val s\\<^sub>2 V", "have \"\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2)!i)).\n             (fst (s\\<^sub>1'!(length (targetnode a # msx') + i))) V = (fst (s\\<^sub>2!i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n          fst (s\\<^sub>1' ! (length (targetnode a # msx') + i)) V =\n          fst (s\\<^sub>2 ! i) V", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length (targetnode a # msx') + i)) V =\n        fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>m\\<in>set ms\\<^sub>1'. valid_node m\\<close> \\<open>\\<forall>m\\<in>set ms\\<^sub>2. valid_node m\\<close>\n        \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \n        \\<open>ms\\<^sub>1' = ((targetnode a)#msx')@mx#tl ms\\<^sub>2\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\\<close> \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>\n        \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>\n        \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> Cons\n        \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = (targetnode a # msx') @ mx # tl ms\\<^sub>2\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = mx' # msx'\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length (targetnode a # msx') + i)) V =\n        fst (s\\<^sub>2 ! i) V", "show ?thesis"], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = (targetnode a # msx') @ mx # tl ms\\<^sub>2\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = mx' # msx'\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length (targetnode a # msx') + i)) V =\n        fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by -(rule WSI,clarsimp+,fastforce,clarsimp+)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (silent_move_call a s\\<^sub>1 s\\<^sub>1' Q r p fs a' ms\\<^sub>1 S ms\\<^sub>1')"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  (\\<exists>m\\<in>set (tl ms\\<^sub>1).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1' = Suc (length s\\<^sub>1)\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "note obs_eq = \\<open>\\<forall>a\\<in>set (tl ms\\<^sub>1'). return_node a \\<Longrightarrow>\n      obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>s\\<^sub>1 \\<noteq> []\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []", "obtain cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2 where [simp]:\"s\\<^sub>1 = cf\\<^sub>1#cfs\\<^sub>1\" \n      and [simp]:\"s\\<^sub>2 = cf\\<^sub>2#cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2.\n        \\<lbrakk>s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1;\n         s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>1,auto,cases s\\<^sub>2,fastforce+)"], ["proof (state)\nthis:\n  s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1\n  s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ins outs where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have [simp]:\"s\\<^sub>1' = (Map.empty(ins [:=] params fs (fst cf\\<^sub>1)), r) # cf\\<^sub>1 # cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' =\n    (Map.empty(ins [:=] params fs (fst cf\\<^sub>1)), r) #\n    cf\\<^sub>1 # cfs\\<^sub>1", "by simp(unfold formal_in_THE,simp)"], ["proof (state)\nthis:\n  s\\<^sub>1' =\n  (Map.empty(ins [:=] params fs (fst cf\\<^sub>1)), r) #\n  cf\\<^sub>1 # cfs\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1", "have \"length ms\\<^sub>1' = length s\\<^sub>1'\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1' = length s\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>m\\<in>set ms\\<^sub>1. valid_node m\\<close> \\<open>valid_edge a\\<close> \n      \\<open>ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1) valid_node\n  valid_edge a\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  valid_edge a'", "have \"\\<forall>m\\<in>set ms\\<^sub>1'. valid_node m\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1) valid_node\n  valid_edge a\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. Ball (set ms\\<^sub>1') valid_node", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1') valid_node\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a'\\<close> \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a", "have \"return_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. return_node (targetnode a')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  valid_edge a'\n  return_node (targetnode a')", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n  valid_edge a'\n  return_node (targetnode a')\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close> \\<open>return_node (targetnode a')\\<close>\n      \\<open>ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n  return_node (targetnode a')\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1", "have \"\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n  return_node (targetnode a')\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>1')) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from obs_eq[OF this]"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "."], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "by(erule_tac x=\"0\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        (\\<exists>m\\<in>set (tl ms).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<notin> \\<lfloor>HRB_slice\n                                     S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s' = Suc (length s); hd ms = sourcenode a;\n        ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = []", "have [simp]:\"mx = sourcenode a\" and [simp]:\"tl ms\\<^sub>1 = tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = []\n\ngoal (1 subgoal):\n 1. mx = sourcenode a &&& tl ms\\<^sub>1 = tl ms\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  mx = sourcenode a\n  tl ms\\<^sub>1 = tl ms\\<^sub>2\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>(\\<exists>m\\<in>set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n        hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms\\<^sub>1).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  (\\<exists>m\\<in>set (tl ms\\<^sub>1).\n      \\<exists>m'.\n         call_of_return_node m m' \\<and>\n         m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>) \\<or>\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by fastforce"], ["proof (state)\nthis:\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd ms\\<^sub>1 = sourcenode a\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 = sourcenode a\n  hd ms\\<^sub>1 \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = sourcenode a\"\n        and \"targetnode a'' = targetnode a'\" and \"intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         targetnode a'' = targetnode a'; intra_kind (kind a'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a''\\<close> \\<open>intra_kind(kind a'')\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a''\n  intra_kind (kind a'')", "have \"get_proc (sourcenode a'') = get_proc (targetnode a'')\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a'') = get_proc (targetnode a'')", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a'') = get_proc (targetnode a'')\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>sourcenode a'' = sourcenode a\\<close> \\<open>targetnode a'' = targetnode a'\\<close>\n        \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  get_proc (sourcenode a'') = get_proc (targetnode a'')", "have \"get_proc (targetnode a') = get_proc (hd ms\\<^sub>2)\""], ["proof (prove)\nusing this:\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  get_proc (sourcenode a'') = get_proc (targetnode a'')\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a') = get_proc (hd ms\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  get_proc (targetnode a') = get_proc (hd ms\\<^sub>2)\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a", "have \"CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')", "by(fastforce intro:sum_SDG_call_summary_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"targetnode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a'\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume \"targetnode a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  targetnode a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. targetnode a'\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "hence \"CFG_node (targetnode a') \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  targetnode a' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a') \\<in> HRB_slice S", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. targetnode a'\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "hence \"CFG_node (sourcenode a) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "proof(induct \"CFG_node (targetnode a')\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "case (phase1 nx)"], ["proof (state)\nthis:\n  CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "with \\<open>CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx\n  nx \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  CFG_node (targetnode a') \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_refl sum_slice1\n                                  simp:HRB_slice_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "case (phase2 nx n' n'' p')"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "from \\<open>CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\\<close> \n            \\<open>CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  valid_edge a", "have \"CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a') \\<in> sum_SDG_slice2 n'\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>sum\\<^esub> CFG_node (targetnode a')\n  valid_edge a\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'", "by(fastforce intro:sum_slice2)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a') \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> CFG_node (sourcenode a) \\<in> HRB_slice S", "with \\<open>n' \\<in> sum_SDG_slice1 nx\\<close> \\<open>n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close> \n            \\<open>nx \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  nx \\<in> S\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p'\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  nx \\<in> S\n  CFG_node (sourcenode a) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_Return_parent_node \n                         simp:HRB_slice_def)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. targetnode a'\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) \\<in> HRB_slice S", "show False"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. False", "by(simp add:SDG_to_CFG_set_def HRB_slice_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1", "have \"ms\\<^sub>1' = [targetnode a] @ targetnode a' # tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = [targetnode a] @ targetnode a' # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = [targetnode a] @ targetnode a' # tl ms\\<^sub>2\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> Nil"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = []", "have \"\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! (length [targetnode a] + i)) = snd (s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = []\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       snd (s\\<^sub>1' ! (length [targetnode a] + i)) = snd (s\\<^sub>2 ! i)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length [targetnode a] + i)) = snd (s\\<^sub>2 ! i)\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"\\<forall>V\\<in>rv S (CFG_node (targetnode a')). (fst (s\\<^sub>1' ! 1)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "assume \"V \\<in> rv S (CFG_node (targetnode a'))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where edge:\"valid_edge a''\" \"sourcenode a'' = sourcenode a\"\n          \"targetnode a'' = targetnode a'\" \"intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         targetnode a'' = targetnode a'; intra_kind (kind a'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "from \\<open>V \\<in> rv S (CFG_node (targetnode a'))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a'))", "obtain as n' where \"targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"\n          and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n          and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>targetnode\n                  a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "from \\<open>targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> edge"], ["proof (chain)\npicking this:\n  targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')", "have \"sourcenode a -a''#as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"V \\<notin> Def (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a)", "by(fastforce dest:call_source_Def_empty)"], ["proof (state)\nthis:\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "with \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close> \\<open>sourcenode a'' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a'' = sourcenode a\n  V \\<notin> Def (sourcenode a)", "have \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes (a''#as)) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a'' = sourcenode a\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce dest:SDG_Def_parent_Def simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "with \\<open>sourcenode a -a''#as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> \\<open>n' \\<in> HRB_slice S\\<close> \n          \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "from \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close> Nil"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = []", "have \"\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n       fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "with \\<open>V \\<in> rv S (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "have \"fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "thus \"(fst (s\\<^sub>1' ! 1)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n     fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n        (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> Nil"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = []\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n     fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V", "have \"\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((targetnode a' # tl ms\\<^sub>2)!i)).\n        (fst (s\\<^sub>1'!(length [targetnode a] + i))) V = (fst (s\\<^sub>2!i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = []\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n     fst (s\\<^sub>1' ! 1) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       \\<forall>V\\<in>rv S (CFG_node ((targetnode a' # tl ms\\<^sub>2) ! i)).\n          fst (s\\<^sub>1' ! (length [targetnode a] + i)) V =\n          fst (s\\<^sub>2 ! i) V", "by clarsimp(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a' # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length [targetnode a] + i)) V =\n        fst (s\\<^sub>2 ! i) V\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>m\\<in>set ms\\<^sub>1'. valid_node m\\<close> \\<open>\\<forall>m\\<in>set ms\\<^sub>2. valid_node m\\<close>\n        \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>ms\\<^sub>1' = [targetnode a] @ targetnode a' # tl ms\\<^sub>2\\<close>\n        \\<open>targetnode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>return_node (targetnode a')\\<close>\n        \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>get_proc (targetnode a') = get_proc (hd ms\\<^sub>2)\\<close>\n        \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\\<close> \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>call_of_return_node (targetnode a') (sourcenode a)\\<close>\n        \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! (length [targetnode a] + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms\\<^sub>1' = [targetnode a] @ targetnode a' # tl ms\\<^sub>2\n  targetnode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  return_node (targetnode a')\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  get_proc (targetnode a') = get_proc (hd ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>1')) return_node\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  call_of_return_node (targetnode a') (sourcenode a)\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length [targetnode a] + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a' # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length [targetnode a] + i)) V =\n        fst (s\\<^sub>2 ! i) V", "show ?thesis"], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms\\<^sub>1' = [targetnode a] @ targetnode a' # tl ms\\<^sub>2\n  targetnode a' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  return_node (targetnode a')\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  get_proc (targetnode a') = get_proc (hd ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>1')) return_node\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  call_of_return_node (targetnode a') (sourcenode a)\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length [targetnode a] + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a' # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length [targetnode a] + i)) V =\n        fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(auto intro!:WSI)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (Cons mx' msx')"], ["proof (state)\nthis:\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = mx' # msx'", "have [simp]:\"mx' = sourcenode a\" and [simp]:\"tl ms\\<^sub>1 = msx'@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. mx' = sourcenode a &&& tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  mx' = sourcenode a\n  tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1", "have \"ms\\<^sub>1' = (targetnode a # targetnode a' # msx')@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = (targetnode a # targetnode a' # msx') @ mx # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = (targetnode a # targetnode a' # msx') @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = mx' # msx'", "have \"\\<forall>i<length ms\\<^sub>2.\n        snd (s\\<^sub>1' ! (length (targetnode a # targetnode a' # msx') + i)) = snd (s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       snd (s\\<^sub>1' !\n            (length (targetnode a # targetnode a' # msx') + i)) =\n       snd (s\\<^sub>2 ! i)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length (targetnode a # targetnode a' # msx') + i)) =\n     snd (s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'", "have \"\\<forall>V\\<in>rv S (CFG_node mx). \n        (fst (s\\<^sub>1' ! length(targetnode a # targetnode a' # msx'))) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length (targetnode a # targetnode a' # msx')) V =\n       state_val s\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length (targetnode a # targetnode a' # msx')) V =\n     state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n        (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length (targetnode a # targetnode a' # msx')) V =\n     state_val s\\<^sub>2 V", "have \"\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2)!i)).\n        (fst (s\\<^sub>1'!(length (targetnode a # targetnode a' # msx') + i))) V = \n        (fst (s\\<^sub>2!i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length (targetnode a # targetnode a' # msx')) V =\n     state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n          fst (s\\<^sub>1' !\n               (length (targetnode a # targetnode a' # msx') + i))\n           V =\n          fst (s\\<^sub>2 ! i) V", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' !\n             (length (targetnode a # targetnode a' # msx') + i))\n         V =\n        fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>m\\<in>set ms\\<^sub>1'. valid_node m\\<close> \\<open>\\<forall>m\\<in>set ms\\<^sub>2. valid_node m\\<close>\n        \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \n        \\<open>ms\\<^sub>1' = (targetnode a # targetnode a' # msx')@mx#tl ms\\<^sub>2\\<close>\n        \\<open>return_node (targetnode a')\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>\n        \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> Cons\n        \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\\<close>\n        \\<open>\\<forall>i<length ms\\<^sub>2.\n        snd (s\\<^sub>1' ! (length (targetnode a # targetnode a' # msx') + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = (targetnode a # targetnode a' # msx') @ mx # tl ms\\<^sub>2\n  return_node (targetnode a')\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = mx' # msx'\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>1')) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length (targetnode a # targetnode a' # msx') + i)) =\n     snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' !\n             (length (targetnode a # targetnode a' # msx') + i))\n         V =\n        fst (s\\<^sub>2 ! i) V", "show ?thesis"], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = (targetnode a # targetnode a' # msx') @ mx # tl ms\\<^sub>2\n  return_node (targetnode a')\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx = mx' # msx'\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>1')) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length (targetnode a # targetnode a' # msx') + i)) =\n     snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' !\n             (length (targetnode a # targetnode a' # msx') + i))\n         V =\n        fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by -(rule WSI,clarsimp+,fastforce,clarsimp+)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (silent_move_return a s\\<^sub>1 s\\<^sub>1' Q p f' ms\\<^sub>1 S ms\\<^sub>1')"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<exists>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = Suc (length s\\<^sub>1')\n  s\\<^sub>1' \\<noteq> []\n  hd ms\\<^sub>1 = sourcenode a\n  hd (tl ms\\<^sub>1) = targetnode a\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "note obs_eq = \\<open>\\<forall>a\\<in>set (tl ms\\<^sub>1'). return_node a \\<Longrightarrow>\n      obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node \\<Longrightarrow>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>s\\<^sub>1 \\<noteq> []\\<close> \\<open>s\\<^sub>1' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>1' \\<noteq> []", "obtain cf\\<^sub>1 cfx\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>1' where [simp]:\"s\\<^sub>1 = cf\\<^sub>1#cfx\\<^sub>1#cfs\\<^sub>1\"\n      and \"s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1),snd cfx\\<^sub>1)#cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>1' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1 cfx\\<^sub>1 cfs\\<^sub>1.\n        \\<lbrakk>s\\<^sub>1 = cf\\<^sub>1 # cfx\\<^sub>1 # cfs\\<^sub>1;\n         s\\<^sub>1' =\n         (f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1), snd cfx\\<^sub>1) #\n         cfs\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>1,auto,case_tac list,fastforce+)"], ["proof (state)\nthis:\n  s\\<^sub>1 = cf\\<^sub>1 # cfx\\<^sub>1 # cfs\\<^sub>1\n  s\\<^sub>1' =\n  (f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1), snd cfx\\<^sub>1) # cfs\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>2 \\<noteq> []", "obtain cf\\<^sub>2 cfs\\<^sub>2 where [simp]:\"s\\<^sub>2 = cf\\<^sub>2#cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>2 cfs\\<^sub>2.\n        s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>2) auto"], ["proof (state)\nthis:\n  s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1", "have \"ms\\<^sub>1 \\<noteq> []\" and \"tl ms\\<^sub>1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1 \\<noteq> [] &&& tl ms\\<^sub>1 \\<noteq> []", "by(cases ms\\<^sub>1,auto)+"], ["proof (state)\nthis:\n  ms\\<^sub>1 \\<noteq> []\n  tl ms\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "obtain a' Q' r' fs' where \"valid_edge a'\" and \"kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\"\n      and \"a \\<in> get_return_edges a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q' r' fs'.\n        \\<lbrakk>valid_edge a';\n         kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         a \\<in> get_return_edges a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule return_needs_call,auto)"], ["proof (state)\nthis:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "then"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'", "obtain ins outs where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have \"f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1) = \n      (fst cfx\\<^sub>1)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1) =\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)", "by(rule CFG_return_edge_fun)"], ["proof (state)\nthis:\n  f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1) =\n  fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1),snd cfx\\<^sub>1)#cfs\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1' =\n  (f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1), snd cfx\\<^sub>1) # cfs\\<^sub>1\n  f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1) =\n  fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)", "have [simp]:\"s\\<^sub>1' = ((fst cfx\\<^sub>1)\n      (ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs),snd cfx\\<^sub>1)#cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  s\\<^sub>1' =\n  (f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1), snd cfx\\<^sub>1) # cfs\\<^sub>1\n  f' (fst cf\\<^sub>1) (fst cfx\\<^sub>1) =\n  fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' =\n    (fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n     map (fst cf\\<^sub>1) outs), snd cfx\\<^sub>1) #\n    cfs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' =\n  (fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs),\n   snd cfx\\<^sub>1) #\n  cfs\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m\\<in>set ms\\<^sub>1. valid_node m\\<close> \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = tl ms\\<^sub>1", "have \"\\<forall>m\\<in>set ms\\<^sub>1'. valid_node m\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. Ball (set ms\\<^sub>1') valid_node", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1') valid_node\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  ms\\<^sub>1' = tl ms\\<^sub>1", "have \"length ms\\<^sub>1' = length s\\<^sub>1'\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  ms\\<^sub>1' = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1' = length s\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>1). return_node m\\<close> \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close> \\<open>ms\\<^sub>1 \\<noteq> []\\<close> \\<open>tl ms\\<^sub>1 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  ms\\<^sub>1 \\<noteq> []\n  tl ms\\<^sub>1 \\<noteq> []", "have \"\\<forall>m\\<in>set (tl ms\\<^sub>1'). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  ms\\<^sub>1 \\<noteq> []\n  tl ms\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>1')) return_node", "by(cases ms\\<^sub>1)(auto,cases ms\\<^sub>1',auto)"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from obs_eq[OF this]"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "."], ["proof (state)\nthis:\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<exists>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms)) return_node; length ms = length s;\n        length s = Suc (length s'); s' \\<noteq> []; hd ms = sourcenode a;\n        hd (tl ms) = targetnode a; ms' = tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        Ball (set (tl ms')) return_node \\<Longrightarrow>\n        obs ms' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "proof(cases msx)"], ["proof (state)\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case Nil"], ["proof (state)\nthis:\n  msx = []\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = []", "have \"mx = sourcenode a\" and \"tl ms\\<^sub>1 = tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = []\n\ngoal (1 subgoal):\n 1. mx = sourcenode a &&& tl ms\\<^sub>1 = tl ms\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  mx = sourcenode a\n  tl ms\\<^sub>1 = tl ms\\<^sub>2\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<exists>m\\<in>set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  mx = sourcenode a\n  tl ms\\<^sub>1 = tl ms\\<^sub>2", "have False"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  mx = sourcenode a\n  tl ms\\<^sub>1 = tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. msx = [] \\<Longrightarrow>\n    ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by simp"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (Cons mx' msx')"], ["proof (state)\nthis:\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = mx' # msx'", "have [simp]:\"mx' = sourcenode a\" and [simp]:\"tl ms\\<^sub>1 = msx'@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  hd ms\\<^sub>1 = sourcenode a\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. mx' = sourcenode a &&& tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  mx' = sourcenode a\n  tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = tl ms\\<^sub>1", "have \"ms\\<^sub>1' = msx'@mx#tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = msx' @ mx # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = msx' @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close> \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>1). return_node m\\<close> Cons"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  Ball (set (tl ms\\<^sub>1)) return_node\n  msx = mx' # msx'\n  ms\\<^sub>1' = msx' @ mx # tl ms\\<^sub>2", "have \"\\<forall>m\\<in>set (tl ms\\<^sub>1'). return_node m\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  Ball (set (tl ms\\<^sub>1)) return_node\n  msx = mx' # msx'\n  ms\\<^sub>1' = msx' @ mx # tl ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>1')) return_node", "by(cases msx') auto"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = mx' # msx'", "have \"\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! (length msx' + i)) = snd (s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  msx = mx' # msx'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       snd (s\\<^sub>1' ! (length msx' + i)) = snd (s\\<^sub>2 ! i)", "by auto(case_tac i,auto,cases msx',auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length msx' + i)) = snd (s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        (fst (s\\<^sub>1 ! (length msx + i))) V = (fst (s\\<^sub>2 ! i)) V\\<close>\n        \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1' ! length msx')) V = state_val s\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "proof(cases msx')"], ["proof (state)\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "case Nil"], ["proof (state)\nthis:\n  msx' = []\n\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close>\n          \\<open>msx = mx'#msx'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n  msx' = []", "have rv:\"\\<forall>V\\<in>rv S (CFG_node mx). fst cfx\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n  msx' = []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx). fst cfx\\<^sub>1 V = fst cf\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx). fst cfx\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "from Nil \\<open>tl ms\\<^sub>1 = msx'@mx#tl ms\\<^sub>2\\<close> \\<open>hd (tl ms\\<^sub>1) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  msx' = []\n  tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2\n  hd (tl ms\\<^sub>1) = targetnode a", "have [simp]:\"mx = targetnode a\""], ["proof (prove)\nusing this:\n  msx' = []\n  tl ms\\<^sub>1 = msx' @ mx # tl ms\\<^sub>2\n  hd (tl ms\\<^sub>1) = targetnode a\n\ngoal (1 subgoal):\n 1. mx = targetnode a", "by simp"], ["proof (state)\nthis:\n  mx = targetnode a\n\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "from Cons \n          \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (chain)\npicking this:\n  msx = mx' # msx'\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "obtain mx'' where \"call_of_return_node mx mx''\" and \"mx'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  msx = mx' # msx'\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (\\<And>mx''.\n        \\<lbrakk>call_of_return_node mx mx'';\n         mx''\n         \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  call_of_return_node mx mx''\n  mx'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "hence \"mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  call_of_return_node mx mx''\n  mx'' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(rule call_node_notin_slice_return_node_neither)"], ["proof (state)\nthis:\n  mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "have \"\\<forall>V\\<in>rv S (CFG_node mx). \n          (fst cfx\\<^sub>1)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V = fst cf\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n        map (fst cf\\<^sub>1) outs) V =\n       fst cf\\<^sub>2 V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node mx) \\<Longrightarrow>\n       fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n        map (fst cf\\<^sub>1) outs) V =\n       fst cf\\<^sub>2 V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node mx) \\<Longrightarrow>\n       fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n        map (fst cf\\<^sub>1) outs) V =\n       fst cf\\<^sub>2 V", "assume \"V\\<in>rv S (CFG_node mx)\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node mx)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node mx) \\<Longrightarrow>\n       fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n        map (fst cf\\<^sub>1) outs) V =\n       fst cf\\<^sub>2 V", "show \"(fst cfx\\<^sub>1)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V = \n            fst cf\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "proof(cases \"V \\<in> set (ParamDefs (targetnode a))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "case True"], ["proof (state)\nthis:\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<in> set (ParamDefs (targetnode a))", "have \"V \\<in> Def (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<in> Def (targetnode a)", "by(fastforce intro:ParamDefs_in_Def)"], ["proof (state)\nthis:\n  V \\<in> Def (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<in> Def (targetnode a)", "have \"V \\<in> Def\\<^bsub>SDG\\<^esub> (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<in> Def (targetnode a)\n\ngoal (1 subgoal):\n 1. V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)", "by(auto intro!:CFG_Def_SDG_Def)"], ["proof (state)\nthis:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "from \\<open>V\\<in>rv S (CFG_node mx)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node mx)", "obtain as n' \n              where \"targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"\n              and \"n' \\<in> HRB_slice S\" \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n              and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n              \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node mx)\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>targetnode\n                  a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "from \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> \\<open>n' \\<in> HRB_slice S\\<close>\n              \\<open>mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain ax asx where \"as = ax#asx\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  mx \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>ax asx. as = ax # asx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:intra_path_def)(erule path.cases,\n                 auto dest:valid_SDG_node_in_slice_parent_node_in_slice \n                      simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  as = ax # asx\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "with \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as = ax # asx", "have \"targetnode a = sourcenode ax\" and \"valid_edge ax\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as = ax # asx\n\ngoal (1 subgoal):\n 1. targetnode a = sourcenode ax &&& valid_edge ax", "by(auto elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  targetnode a = sourcenode ax\n  valid_edge ax\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "with \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n              \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close> \\<open>as = ax#asx\\<close> \\<open>V \\<in> Def\\<^bsub>SDG\\<^esub> (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  as = ax # asx\n  V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n  targetnode a = sourcenode ax\n  valid_edge ax", "have False"], ["proof (prove)\nusing this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  as = ax # asx\n  V \\<in> Def\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n  targetnode a = sourcenode ax\n  valid_edge ax\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n   V =\n  fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "case False"], ["proof (state)\nthis:\n  V \\<notin> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "with \\<open>V\\<in>rv S (CFG_node mx)\\<close> rv"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node mx)\n  \\<forall>V\\<in>rv S (CFG_node mx). fst cfx\\<^sub>1 V = fst cf\\<^sub>2 V\n  V \\<notin> set (ParamDefs (targetnode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node mx)\n  \\<forall>V\\<in>rv S (CFG_node mx). fst cfx\\<^sub>1 V = fst cf\\<^sub>2 V\n  V \\<notin> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     V =\n    fst cf\\<^sub>2 V", "by(fastforce dest:fun_upds_notin[of  _ _ \"fst cfx\\<^sub>1\"])"], ["proof (state)\nthis:\n  fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n   V =\n  fst cf\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n   V =\n  fst cf\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n      map (fst cf\\<^sub>1) outs) V =\n     fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. msx' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n 2. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "with Nil \\<open>msx = mx'#msx'\\<close>"], ["proof (chain)\npicking this:\n  msx' = []\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n      map (fst cf\\<^sub>1) outs) V =\n     fst cf\\<^sub>2 V", "show ?thesis"], ["proof (prove)\nusing this:\n  msx' = []\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst cfx\\<^sub>1(ParamDefs (targetnode a) [:=]\n      map (fst cf\\<^sub>1) outs) V =\n     fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "case Cons"], ["proof (state)\nthis:\n  msx' = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>rv S (CFG_node mx).\n          fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close>\n          \\<open>msx = mx'#msx'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n  msx' = a_ # list_", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n  msx' = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1' ! length msx')) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "by(cases msx') auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n        (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> Cons"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V", "have \"\\<forall>i<length ms\\<^sub>2. \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        (fst (s\\<^sub>1' ! (length msx' + i))) V = (fst (s\\<^sub>2 ! i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  msx = mx' # msx'\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1' ! length msx') V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>2.\n       \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n          fst (s\\<^sub>1' ! (length msx' + i)) V = fst (s\\<^sub>2 ! i) V", "by clarsimp(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length msx' + i)) V = fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       msx = a # list \\<Longrightarrow>\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>\\<forall>m\\<in>set ms\\<^sub>1'. valid_node m\\<close> \\<open>\\<forall>m\\<in>set ms\\<^sub>2. valid_node m\\<close>\n        \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \n        \\<open>ms\\<^sub>1' = msx'@mx#tl ms\\<^sub>2\\<close> \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>1'). return_node m\\<close> Cons \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>\n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1' ! (length msx' + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = msx' @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1')) return_node\n  msx = mx' # msx'\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length msx' + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length msx' + i)) V = fst (s\\<^sub>2 ! i) V", "show ?thesis"], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1') valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>2 = length s\\<^sub>2\n  ms\\<^sub>1' = msx' @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1')) return_node\n  msx = mx' # msx'\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs ms\\<^sub>1' \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1' ! (length msx' + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1' ! (length msx' + i)) V = fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(auto intro!:WSI)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WS_silent_moves:\n  \"\\<lbrakk>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1'); ((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<rbrakk>\n  \\<Longrightarrow> ((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1',s\\<^sub>1');\n     ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\\<rbrakk>\n    \\<Longrightarrow> ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>2, s\\<^sub>2)\n                      \\<in> WS S", "by(induct S f\\<equiv>\"kind\" ms\\<^sub>1 s\\<^sub>1 as ms\\<^sub>1' s\\<^sub>1' rule:silent_moves.induct,\n  auto dest:WS_silent_move)"], ["", "lemma WS_observable_move:\n  assumes \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  and \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\" and \"s\\<^sub>1' \\<noteq> []\"\n  obtains as where \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\"\n  and \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n                  transfer (slice_kind S a) s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n             [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n      s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n           [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)", "from \\<open>((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "obtain msx mx\n    where assms:\"\\<forall>m \\<in> set ms\\<^sub>1. valid_node m\" \"\\<forall>m \\<in> set ms\\<^sub>2. valid_node m\"\n    \"length ms\\<^sub>1 = length s\\<^sub>1\" \"length ms\\<^sub>2 = length s\\<^sub>2\" \"s\\<^sub>1 \\<noteq> []\" \"s\\<^sub>2 \\<noteq> []\" \n    \"ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\" \"get_proc mx = get_proc (hd ms\\<^sub>2)\" \n    \"\\<forall>m \\<in> set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    \"msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\"\n    \"\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\"\n    \"\\<forall>i < length ms\\<^sub>2. snd (s\\<^sub>1!(length msx + i)) = snd (s\\<^sub>2!i)\"\n    \"\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\"\n    \"obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>msx mx.\n        \\<lbrakk>Ball (set ms\\<^sub>1) valid_node;\n         Ball (set ms\\<^sub>2) valid_node;\n         length ms\\<^sub>1 = length s\\<^sub>1;\n         length ms\\<^sub>2 = length s\\<^sub>2; s\\<^sub>1 \\<noteq> [];\n         s\\<^sub>2 \\<noteq> []; ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2;\n         get_proc mx = get_proc (hd ms\\<^sub>2);\n         \\<forall>m\\<in>set (tl ms\\<^sub>2).\n            \\<exists>m'.\n               call_of_return_node m m' \\<and>\n               m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n         msx \\<noteq> [] \\<longrightarrow>\n         (\\<exists>mx'.\n             call_of_return_node mx mx' \\<and>\n             mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n         Ball (set (tl ms\\<^sub>1)) return_node;\n         \\<forall>i<length ms\\<^sub>2.\n            snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n         \\<forall>i<length ms\\<^sub>2.\n            \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n               fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n         obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n         obs ms\\<^sub>2\n          \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS.cases)"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n           [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)", "from \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\\<close> assms"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "show \"\\<exists>as. ((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S \\<and>\n    S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @ [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n           [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)", "proof(induct S f\\<equiv>\"kind\" ms\\<^sub>1 s\\<^sub>1 a ms\\<^sub>1' s\\<^sub>1' rule:observable_move.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "case (observable_move_intra a s\\<^sub>1 s\\<^sub>1' ms\\<^sub>1 S ms\\<^sub>1')"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length s\\<^sub>1' = length s\\<^sub>1\n  length ms\\<^sub>1 = length s\\<^sub>1\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>s\\<^sub>1 \\<noteq> []\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []", "obtain cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2 where [simp]:\"s\\<^sub>1 = cf\\<^sub>1#cfs\\<^sub>1\" \n      and [simp]:\"s\\<^sub>2 = cf\\<^sub>2#cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2.\n        \\<lbrakk>s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1;\n         s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>1,auto,cases s\\<^sub>2,fastforce+)"], ["proof (state)\nthis:\n  s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1\n  s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>s\\<^sub>1 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  s\\<^sub>1 \\<noteq> []", "have [simp]:\"ms\\<^sub>1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  s\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1 \\<noteq> []", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  ms\\<^sub>1 \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []", "have [simp]:\"ms\\<^sub>2 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms\\<^sub>2 \\<noteq> []", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  ms\\<^sub>2 \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>hd ms\\<^sub>1 = sourcenode a\\<close> \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close>\n      \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have [simp]:\"mx = sourcenode a\" \"msx = []\" and [simp]:\"tl ms\\<^sub>2 = tl ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (mx = sourcenode a &&& msx = []) &&& tl ms\\<^sub>2 = tl ms\\<^sub>1", "by(cases msx,auto)+"], ["proof (state)\nthis:\n  mx = sourcenode a\n  msx = []\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"length ms\\<^sub>1 = length ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  mx = sourcenode a\n  msx = []\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1 = length ms\\<^sub>2", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  length ms\\<^sub>1 = length ms\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2", "have \"length s\\<^sub>1 = length s\\<^sub>2\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1 = length s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  length s\\<^sub>1 = length s\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\\<close> \n      \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n  hd ms\\<^sub>1 = sourcenode a", "have \"(hd ms\\<^sub>1#tl ms\\<^sub>1) \\<in> obs ([]@hd ms\\<^sub>1#tl ms\\<^sub>1) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n  hd ms\\<^sub>1 = sourcenode a\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1 # tl ms\\<^sub>1\n    \\<in> obs ([] @ hd ms\\<^sub>1 # tl ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms\\<^sub>1)(auto intro!:obsI)"], ["proof (state)\nthis:\n  hd ms\\<^sub>1 # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>1 # tl ms\\<^sub>1)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"ms\\<^sub>1 \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>1 # tl ms\\<^sub>1)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1\n    \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"ms\\<^sub>1 \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1\n    \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>ms\\<^sub>2 \\<noteq> []\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"length s\\<^sub>2 = length (hd ms\\<^sub>2#tl ms\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)", "by(fastforce dest!:hd_Cons_tl)"], ["proof (state)\nthis:\n  length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>1)) return_node", "have \"\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>2)) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>2)) return_node\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>ms\\<^sub>1 \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>2)) return_node", "have \"hd ms\\<^sub>1 \\<in> obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>2)) return_node\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1\n    \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(rule obsE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "fix nsx n nsx' n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"ms\\<^sub>2 = nsx @ n # nsx'\" and \"ms\\<^sub>1 = n' # nsx'\"\n        and \"n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  ms\\<^sub>1 = n' # nsx'\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms\\<^sub>2 = nsx @ n # nsx'\\<close> \\<open>ms\\<^sub>1 = n' # nsx'\\<close> \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  ms\\<^sub>1 = n' # nsx'\n  tl ms\\<^sub>2 = tl ms\\<^sub>1", "have [simp]:\"nsx = []\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  ms\\<^sub>1 = n' # nsx'\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. nsx = []", "by(cases nsx) auto"], ["proof (state)\nthis:\n  nsx = []\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms\\<^sub>2 = nsx @ n # nsx'\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  nsx = []", "have [simp]:\"n = hd ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  nsx = []\n\ngoal (1 subgoal):\n 1. n = hd ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  n = hd ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms\\<^sub>1 = n' # nsx'\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = n' # nsx'", "have [simp]:\"n' = hd ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = n' # nsx'\n\ngoal (1 subgoal):\n 1. n' = hd ms\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  n' = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = hd ms\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1\n    \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length s\\<^sub>2 = length (hd ms\\<^sub>2#tl ms\\<^sub>2)\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\\<close>"], ["proof (chain)\npicking this:\n  length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>2)) return_node\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"S,slice_kind S \\<turnstile> (hd ms\\<^sub>2#tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd ms\\<^sub>1#tl ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>2)) return_node\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (hd ms\\<^sub>2 #\n                           tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n        ms\\<^sub>1 #\n       tl ms\\<^sub>1,s\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves_intra_path_obs[of _ _ _ s\\<^sub>2 \"tl ms\\<^sub>2\"])"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "by(fastforce dest!:hd_Cons_tl)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "have \"\\<forall>V. V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a)) \n      \\<longrightarrow> V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<forall>V.\n       V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n (sourcenode a) \\<longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "by auto(rule rvI,auto simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))", "have \"\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:CFG_Use_SDG_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "have \"\\<forall>V \\<in> Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)", "have \"snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)", "by(erule_tac x=\"0\" in allE) auto"], ["proof (state)\nthis:\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)", "have \"pred (kind a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "using \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "by(fastforce intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close> \\<open>length s\\<^sub>1' = length s\\<^sub>1\\<close> \n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  length s\\<^sub>1' = length s\\<^sub>1\n  length ms\\<^sub>1 = length s\\<^sub>1", "have \"length ms\\<^sub>1' = length s\\<^sub>1'\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  length s\\<^sub>1' = length s\\<^sub>1\n  length ms\\<^sub>1 = length s\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1' = length s\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)", "obtain cf\\<^sub>1' where [simp]:\"s\\<^sub>1' = cf\\<^sub>1'#cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1'.\n        s\\<^sub>1' = cf\\<^sub>1' # cfs\\<^sub>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases cf\\<^sub>1,cases \"kind a\",auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  s\\<^sub>1' = cf\\<^sub>1' # cfs\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\\<^sub>2", "have \"pred (slice_kind S a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s\\<^sub>2", "by(simp add:slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close> \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'", "have \"length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)", "by(fastforce intro:length_transfer_kind_slice_kind)"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length s\\<^sub>1 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)", "have \"length s\\<^sub>2 = length (transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  length s\\<^sub>1 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. length s\\<^sub>2 = length (transfer (slice_kind S a) s\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  length s\\<^sub>2 = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>pred (slice_kind S a) s\\<^sub>2\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>\n      \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>\n      \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\\<close>"], ["proof (chain)\npicking this:\n  pred (slice_kind S a) s\\<^sub>2\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  Ball (set (tl ms\\<^sub>2)) return_node\n  length s\\<^sub>2 = length (transfer (slice_kind S a) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s\\<^sub>2\n  valid_edge a\n  intra_kind (kind a)\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  Ball (set (tl ms\\<^sub>2)) return_node\n  length s\\<^sub>2 = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                     (slice_kind S a) s\\<^sub>2)", "by(auto intro:observable_move.observable_move_intra)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n        [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "by(rule observable_moves_snoc)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set ms\\<^sub>1. valid_node m\\<close> \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  valid_edge a", "have \"\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  valid_edge a\n\ngoal (1 subgoal):\n 1. Ball (set ms\\<^sub>1') valid_node", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1') valid_node\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\\<close> \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>\n      \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>2)) return_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1", "have \"\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>2)) return_node\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>1')) return_node", "by fastforce"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>1')) return_node\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\\<close> \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  tl ms\\<^sub>2 = tl ms\\<^sub>1", "have \"ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # tl ms\\<^sub>1\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have cf2':\"\\<exists>cf\\<^sub>2'. transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2'#cfs\\<^sub>2 \\<and> snd cf\\<^sub>2' = snd cf\\<^sub>2\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>cf\\<^sub>2'.\n       transfer (slice_kind S a) s\\<^sub>2 =\n       cf\\<^sub>2' # cfs\\<^sub>2 \\<and>\n       snd cf\\<^sub>2' = snd cf\\<^sub>2", "by(cases cf\\<^sub>2)(auto dest:slice_intra_kind_in_slice simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfs\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = snd cf\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)", "have \"snd cf\\<^sub>1' = snd cf\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. snd cf\\<^sub>1' = snd cf\\<^sub>1", "by(auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  snd cf\\<^sub>1' = snd cf\\<^sub>1\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close>\n      \\<open>snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\\<close> \\<open>ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\\<close>\n      cf2' \\<open>length ms\\<^sub>1 = length ms\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfs\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = snd cf\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  snd cf\\<^sub>1' = snd cf\\<^sub>1", "have \"\\<forall>i<length ms\\<^sub>1'. snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfs\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = snd cf\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  snd cf\\<^sub>1' = snd cf\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>1'.\n       snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "have \"\\<forall>V \\<in> rv S (CFG_node (targetnode a)). \n      fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "assume \"V \\<in> rv S (CFG_node (targetnode a))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "show \"fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof(cases \"V \\<in> Def (sourcenode a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case True"], ["proof (state)\nthis:\n  V \\<in> Def (sourcenode a)\n\ngoal (2 subgoals):\n 1. V \\<in> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)", "have \"(\\<exists>f. kind a = \\<Up>f) \\<or> (\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<exists>f. kind a = \\<Up>f) \\<or>\n    (\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>)", "by(simp add:intra_kind_def)"], ["proof (state)\nthis:\n  (\\<exists>f. kind a = \\<Up>f) \\<or>\n  (\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>)\n\ngoal (2 subgoals):\n 1. V \\<in> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>f. kind a = \\<Up>f) \\<or>\n  (\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "assume \"\\<exists>f. kind a = \\<Up>f\""], ["proof (state)\nthis:\n  \\<exists>f. kind a = \\<Up>f\n\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. kind a = \\<Up>f", "obtain f' where \"kind a = \\<Up>f'\""], ["proof (prove)\nusing this:\n  \\<exists>f. kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. (\\<And>f'. kind a = \\<Up>f' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  kind a = \\<Up>f'\n\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = \\<Up>f'", "have \"s\\<^sub>1' = (f' (fst cf\\<^sub>1),snd cf\\<^sub>1) # cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = \\<Up>f'\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' = (f' (fst cf\\<^sub>1), snd cf\\<^sub>1) # cfs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' = (f' (fst cf\\<^sub>1), snd cf\\<^sub>1) # cfs\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = \\<Up>f'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = \\<Up>f'", "have \"slice_kind S a = \\<Up>f'\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = \\<Up>f'\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>f'", "by(fastforce dest:slice_intra_kind_in_slice simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>f'\n\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence \"transfer (slice_kind S a) s\\<^sub>2 = (f' (fst cf\\<^sub>2),snd cf\\<^sub>2) # cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  slice_kind S a = \\<Up>f'\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) s\\<^sub>2 =\n    (f' (fst cf\\<^sub>2), snd cf\\<^sub>2) # cfs\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s\\<^sub>2 =\n  (f' (fst cf\\<^sub>2), snd cf\\<^sub>2) # cfs\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>\\<forall>V \\<in> Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\\<close> \n            \\<open>intra_kind (kind a)\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2", "have \"\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s\\<^sub>1) V =\n            state_val (transfer (kind a) s\\<^sub>2) V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def (sourcenode a).\n       state_val (transfer (kind a) s\\<^sub>1) V =\n       state_val (transfer (kind a) s\\<^sub>2) V", "by -(erule CFG_intra_edge_transfer_uses_only_Use,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s\\<^sub>1) V =\n     state_val (transfer (kind a) s\\<^sub>2) V\n\ngoal (2 subgoals):\n 1. \\<exists>f. kind a = \\<Up>f \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>kind a = \\<Up>f'\\<close> \\<open>s\\<^sub>1' = (f' (fst cf\\<^sub>1),snd cf\\<^sub>1) # cfs\\<^sub>1\\<close> True\n            \\<open>transfer (slice_kind S a) s\\<^sub>2 = (f' (fst cf\\<^sub>2),snd cf\\<^sub>2) # cfs\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f'\n  s\\<^sub>1' = (f' (fst cf\\<^sub>1), snd cf\\<^sub>1) # cfs\\<^sub>1\n  V \\<in> Def (sourcenode a)\n  transfer (slice_kind S a) s\\<^sub>2 =\n  (f' (fst cf\\<^sub>2), snd cf\\<^sub>2) # cfs\\<^sub>2\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s\\<^sub>1) V =\n     state_val (transfer (kind a) s\\<^sub>2) V", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a = \\<Up>f'\n  s\\<^sub>1' = (f' (fst cf\\<^sub>1), snd cf\\<^sub>1) # cfs\\<^sub>1\n  V \\<in> Def (sourcenode a)\n  transfer (slice_kind S a) s\\<^sub>2 =\n  (f' (fst cf\\<^sub>2), snd cf\\<^sub>2) # cfs\\<^sub>2\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s\\<^sub>1) V =\n     state_val (transfer (kind a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "assume \"\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "then"], ["proof (chain)\npicking this:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "obtain Q where \"kind a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = (Q)\\<^sub>\\<surd>", "have \"s\\<^sub>1' = cf\\<^sub>1 # cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' = cf\\<^sub>1 # cfs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' = cf\\<^sub>1 # cfs\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>", "have \"slice_kind S a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (Q)\\<^sub>\\<surd>", "by(fastforce dest:slice_intra_kind_in_slice simp:intra_kind_def)"], ["proof (state)\nthis:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence \"transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2\""], ["proof (prove)\nusing this:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>\\<forall>V \\<in> Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\\<close> \n            \\<open>intra_kind (kind a)\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2", "have \"\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s\\<^sub>1) V =\n                                         state_val (transfer (kind a) s\\<^sub>2) V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def (sourcenode a).\n       state_val (transfer (kind a) s\\<^sub>1) V =\n       state_val (transfer (kind a) s\\<^sub>2) V", "by -(erule CFG_intra_edge_transfer_uses_only_Use,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s\\<^sub>1) V =\n     state_val (transfer (kind a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd> \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with True \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \\<open>s\\<^sub>1' = cf\\<^sub>1 # cfs\\<^sub>1\\<close>\n            \\<open>transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def (sourcenode a)\n  kind a = (Q)\\<^sub>\\<surd>\n  s\\<^sub>1' = cf\\<^sub>1 # cfs\\<^sub>1\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s\\<^sub>1) V =\n     state_val (transfer (kind a) s\\<^sub>2) V", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> Def (sourcenode a)\n  kind a = (Q)\\<^sub>\\<surd>\n  s\\<^sub>1' = cf\\<^sub>1 # cfs\\<^sub>1\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s\\<^sub>1) V =\n     state_val (transfer (kind a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case False"], ["proof (state)\nthis:\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  V \\<notin> Def (sourcenode a)", "have \"state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  pred (kind a) s\\<^sub>1\n  V \\<notin> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V", "by(fastforce intro:CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V", "have \"fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = fst cf\\<^sub>1 V", "by simp"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  intra_kind (kind a)", "have \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by(fastforce intro:slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from False \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> Def (sourcenode a)\n  valid_edge a\n  pred (kind a) s\\<^sub>2\n  intra_kind (kind a)", "have \"state_val (transfer (kind a) s\\<^sub>2) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  V \\<notin> Def (sourcenode a)\n  valid_edge a\n  pred (kind a) s\\<^sub>2\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s\\<^sub>2) V = state_val s\\<^sub>2 V", "by(fastforce intro:CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s\\<^sub>2) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>slice_kind S a = kind a\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = kind a\n  state_val (transfer (kind a) s\\<^sub>2) V = state_val s\\<^sub>2 V", "have \"state_val (transfer (slice_kind S a) s\\<^sub>2) V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  slice_kind S a = kind a\n  state_val (transfer (kind a) s\\<^sub>2) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) V = fst cf\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))", "obtain as' nx \n          where \"targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\" \n          and \"nx \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> nx\"\n          and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as') \n                     \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>as' nx.\n        \\<lbrakk>targetnode\n                  a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as') \n                    \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close> False"], ["proof (chain)\npicking this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  V \\<notin> Def (sourcenode a)\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have all:\"\\<forall>n''. valid_SDG_node n'' \\<and> \n          parent_node n'' \\<in> set (sourcenodes (a#as')) \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  V \\<notin> Def (sourcenode a)\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' \\<in> set (sourcenodes (a # as')) \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce dest:SDG_Def_parent_Def simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a # as')) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from  \\<open>valid_edge a\\<close> \\<open>targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\\<close> \n          \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  intra_kind (kind a)", "have \"sourcenode a -a#as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>nx \\<in> HRB_slice S\\<close> \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> nx\\<close> all"], ["proof (chain)\npicking this:\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a # as')) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "have \"V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a # as')) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a -a # as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a) \\<Longrightarrow>\n    fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>\\<forall>V \\<in> rv S (CFG_node mx). (fst (s\\<^sub>1!(length msx))) V = state_val s\\<^sub>2 V\\<close>\n          \\<open>state_val (transfer (slice_kind S a) s\\<^sub>2) V = fst cf\\<^sub>2 V\\<close>\n          \\<open>fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V = fst cf\\<^sub>2 V\n  fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\n  V \\<in> rv S (CFG_node (sourcenode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V = fst cf\\<^sub>2 V\n  fst cf\\<^sub>1' V = fst cf\\<^sub>1 V\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by fastforce"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> cf2' \n      \\<open>ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfs\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = snd cf\\<^sub>2\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1 = length s\\<^sub>2\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V", "have \"\\<forall>i<length ms\\<^sub>1'. \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1')!i)).\n      (fst (s\\<^sub>1'!(length [] + i))) V = (fst (transfer (slice_kind S a) s\\<^sub>2 ! i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfs\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = snd cf\\<^sub>2\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1 = length s\\<^sub>2\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     fst cf\\<^sub>1' V = state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>1'.\n       \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n          fst (s\\<^sub>1' ! (length [] + i)) V =\n          fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V", "by clarsimp(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>m \\<in> set ms\\<^sub>2. valid_node m\\<close> \\<open>\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\\<close> \n      \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\\<close>\n      \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1'). return_node m\\<close>\n      \\<open>ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\\<close> \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>\n      \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>\\<forall>i<length ms\\<^sub>1'. snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>2) valid_node\n  Ball (set ms\\<^sub>1') valid_node\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  Ball (set (tl ms\\<^sub>1')) return_node\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V", "have \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>2) valid_node\n  Ball (set ms\\<^sub>1') valid_node\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  Ball (set (tl ms\\<^sub>1')) return_node\n  ms\\<^sub>1' = [] @ targetnode a # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfer (slice_kind S a) s\\<^sub>2)\n    \\<in> WS S", "by(fastforce intro!:WSI)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S\n\ngoal (3 subgoals):\n 1. \\<And>a s s' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        intra_kind (kind a);\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length s' = length s; length ms = length s; hd ms = sourcenode a;\n        ms' = targetnode a # tl ms; Ball (set ms) valid_node;\n        Ball (set ms\\<^sub>2) valid_node; length ms = length s;\n        length ms\\<^sub>2 = length s\\<^sub>2; s \\<noteq> [];\n        s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 3. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S", "show ?case"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n           [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n      transfer (slice_kind S a) s\\<^sub>2)\n     \\<in> WS S \\<and>\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n         [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "case (observable_move_call a s\\<^sub>1 s\\<^sub>1' Q r p fs a' ms\\<^sub>1 S ms\\<^sub>1')"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1' = Suc (length s\\<^sub>1)\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>s\\<^sub>1 \\<noteq> []\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []", "obtain cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2 where [simp]:\"s\\<^sub>1 = cf\\<^sub>1#cfs\\<^sub>1\" \n      and [simp]:\"s\\<^sub>2 = cf\\<^sub>2#cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2.\n        \\<lbrakk>s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1;\n         s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>1,auto,cases s\\<^sub>2,fastforce+)"], ["proof (state)\nthis:\n  s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1\n  s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>s\\<^sub>1 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  s\\<^sub>1 \\<noteq> []", "have [simp]:\"ms\\<^sub>1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  s\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1 \\<noteq> []", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  ms\\<^sub>1 \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []", "have [simp]:\"ms\\<^sub>2 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms\\<^sub>2 \\<noteq> []", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  ms\\<^sub>2 \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>hd ms\\<^sub>1 = sourcenode a\\<close> \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close>\n      \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have [simp]:\"mx = sourcenode a\" \"msx = []\" and [simp]:\"tl ms\\<^sub>2 = tl ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (mx = sourcenode a &&& msx = []) &&& tl ms\\<^sub>2 = tl ms\\<^sub>1", "by(cases msx,auto)+"], ["proof (state)\nthis:\n  mx = sourcenode a\n  msx = []\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"length ms\\<^sub>1 = length ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  mx = sourcenode a\n  msx = []\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1 = length ms\\<^sub>2", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  length ms\\<^sub>1 = length ms\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2", "have \"length s\\<^sub>1 = length s\\<^sub>2\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1 = length s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  length s\\<^sub>1 = length s\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (sourcenode a)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {sourcenode a}", "by(fastforce intro!:n_in_obs_intra)"], ["proof (state)\nthis:\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>obs_intra (sourcenode a) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {sourcenode a}\\<close> \n      \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n  hd ms\\<^sub>1 = sourcenode a", "have \"(hd ms\\<^sub>1#tl ms\\<^sub>1) \\<in> obs ([]@hd ms\\<^sub>1#tl ms\\<^sub>1) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (sourcenode a)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {sourcenode a}\n  hd ms\\<^sub>1 = sourcenode a\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1 # tl ms\\<^sub>1\n    \\<in> obs ([] @ hd ms\\<^sub>1 # tl ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases ms\\<^sub>1)(auto intro!:obsI)"], ["proof (state)\nthis:\n  hd ms\\<^sub>1 # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>1 # tl ms\\<^sub>1)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"ms\\<^sub>1 \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>1 # tl ms\\<^sub>1)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1\n    \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"ms\\<^sub>1 \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1\n    \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>ms\\<^sub>2 \\<noteq> []\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"length s\\<^sub>2 = length (hd ms\\<^sub>2#tl ms\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)", "by(fastforce dest!:hd_Cons_tl)"], ["proof (state)\nthis:\n  length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>1)) return_node", "have \"\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n\ngoal (1 subgoal):\n 1. Ball (set (tl ms\\<^sub>2)) return_node", "by simp"], ["proof (state)\nthis:\n  Ball (set (tl ms\\<^sub>2)) return_node\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>ms\\<^sub>1 \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>2)) return_node", "have \"hd ms\\<^sub>1 \\<in> obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>2)) return_node\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1\n    \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(rule obsE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "fix nsx n nsx' n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"ms\\<^sub>2 = nsx @ n # nsx'\" and \"ms\\<^sub>1 = n' # nsx'\"\n        and \"n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  ms\\<^sub>1 = n' # nsx'\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms\\<^sub>2 = nsx @ n # nsx'\\<close> \\<open>ms\\<^sub>1 = n' # nsx'\\<close> \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  ms\\<^sub>1 = n' # nsx'\n  tl ms\\<^sub>2 = tl ms\\<^sub>1", "have [simp]:\"nsx = []\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  ms\\<^sub>1 = n' # nsx'\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. nsx = []", "by(cases nsx) auto"], ["proof (state)\nthis:\n  nsx = []\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms\\<^sub>2 = nsx @ n # nsx'\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  nsx = []", "have [simp]:\"n = hd ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 = nsx @ n # nsx'\n  nsx = []\n\ngoal (1 subgoal):\n 1. n = hd ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  n = hd ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms\\<^sub>1 = n' # nsx'\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = n' # nsx'", "have [simp]:\"n' = hd ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = n' # nsx'\n\ngoal (1 subgoal):\n 1. n' = hd ms\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  n' = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>2 = nsx @ n # nsx'; ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> hd ms\\<^sub>1\n                         \\<in> obs_intra (hd ms\\<^sub>2)\n                                \\<lfloor>HRB_slice\n    S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = hd ms\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1\n    \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length s\\<^sub>2 = length (hd ms\\<^sub>2#tl ms\\<^sub>2)\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\\<close>"], ["proof (chain)\npicking this:\n  length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>2)) return_node\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "obtain as where \"S,slice_kind S \\<turnstile> (hd ms\\<^sub>2#tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd ms\\<^sub>1#tl ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  length s\\<^sub>2 = length (hd ms\\<^sub>2 # tl ms\\<^sub>2)\n  Ball (set (tl ms\\<^sub>2)) return_node\n  hd ms\\<^sub>1\n  \\<in> obs_intra (hd ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (hd ms\\<^sub>2 #\n                           tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n        ms\\<^sub>1 #\n       tl ms\\<^sub>1,s\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:silent_moves_intra_path_obs[of _ _ _ s\\<^sub>2 \"tl ms\\<^sub>2\"])"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "by(fastforce dest!:hd_Cons_tl)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "have \"\\<forall>V. V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a)) \n      \\<longrightarrow> V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<forall>V.\n       V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n (sourcenode a) \\<longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "by auto(rule rvI,auto simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))", "have \"\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:CFG_Use_SDG_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "have \"\\<forall>V \\<in> Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)", "have \"snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)", "by(erule_tac x=\"0\" in allE) auto"], ["proof (state)\nthis:\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)", "have \"pred (kind a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "using \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "by(fastforce intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>ms\\<^sub>1' = (targetnode a)#(targetnode a')#tl ms\\<^sub>1\\<close> \\<open>length s\\<^sub>1' = Suc(length s\\<^sub>1)\\<close> \n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  length s\\<^sub>1' = Suc (length s\\<^sub>1)\n  length ms\\<^sub>1 = length s\\<^sub>1", "have \"length ms\\<^sub>1' = length s\\<^sub>1'\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  length s\\<^sub>1' = Suc (length s\\<^sub>1)\n  length ms\\<^sub>1 = length s\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1' = length s\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ins outs \n      where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"(THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "by(rule formal_in_THE)"], ["proof (state)\nthis:\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "have [simp]:\"s\\<^sub>1' = (Map.empty(ins [:=] params fs (fst cf\\<^sub>1)),r)#cf\\<^sub>1#cfs\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' =\n    (Map.empty(ins [:=] params fs (fst cf\\<^sub>1)), r) #\n    cf\\<^sub>1 # cfs\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' =\n  (Map.empty(ins [:=] params fs (fst cf\\<^sub>1)), r) #\n  cf\\<^sub>1 # cfs\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  valid_edge a", "have \"return_node (targetnode a')\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. return_node (targetnode a')", "by(fastforce simp:return_node_def)"], ["proof (state)\nthis:\n  return_node (targetnode a')\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  return_node (targetnode a')", "have \"call_of_return_node (targetnode a') (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  a' \\<in> get_return_edges a\n  return_node (targetnode a')\n\ngoal (1 subgoal):\n 1. call_of_return_node (targetnode a') (sourcenode a)", "by(simp add:call_of_return_node_def) blast"], ["proof (state)\nthis:\n  call_of_return_node (targetnode a') (sourcenode a)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\\<^sub>2\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"pred (slice_kind S a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\\<^sub>2\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s\\<^sub>2", "by(fastforce dest:slice_kind_Call_in_slice)"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close> \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'", "have \"length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)", "by(fastforce intro:length_transfer_kind_slice_kind)"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>pred (slice_kind S a) s\\<^sub>2\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n      \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close> \\<open>valid_edge a'\\<close>\n      \\<open>ms\\<^sub>1' = (targetnode a)#(targetnode a')#tl ms\\<^sub>1\\<close> \\<open>a' \\<in> get_return_edges a\\<close>\n      \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). return_node m\\<close>"], ["proof (chain)\npicking this:\n  pred (slice_kind S a) s\\<^sub>2\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  valid_edge a'\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  a' \\<in> get_return_edges a\n  Ball (set (tl ms\\<^sub>2)) return_node\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s\\<^sub>2\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  valid_edge a'\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  a' \\<in> get_return_edges a\n  Ball (set (tl ms\\<^sub>2)) return_node\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                     (slice_kind S a) s\\<^sub>2)", "by(auto intro:observable_move.observable_move_call)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n        [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "by(rule observable_moves_snoc)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set ms\\<^sub>1. valid_node m\\<close> \\<open>ms\\<^sub>1' = (targetnode a)#(targetnode a')#tl ms\\<^sub>1\\<close>\n      \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  valid_edge a\n  valid_edge a'", "have \"\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  valid_edge a\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. Ball (set ms\\<^sub>1') valid_node", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1') valid_node\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have cf2':\"\\<exists>cf\\<^sub>2'. transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2'#s\\<^sub>2 \\<and> snd cf\\<^sub>2' = r\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>cf\\<^sub>2'.\n       transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # s\\<^sub>2 \\<and>\n       snd cf\\<^sub>2' = r", "by(auto dest:slice_kind_Call_in_slice)"], ["proof (state)\nthis:\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # s\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = r\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> \n      \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>msx = []\\<close> \\<open>length ms\\<^sub>1 = length ms\\<^sub>2\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  msx = []\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # s\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = r", "have \"\\<forall>i<length ms\\<^sub>1'. snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  msx = []\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # s\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = r\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>1'.\n       snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "have \"\\<forall>V \\<in> rv S (CFG_node (targetnode a')). \n      V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n       V \\<in> rv S (CFG_node (sourcenode a))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "assume \"V \\<in> rv S (CFG_node (targetnode a'))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "then"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a'))", "obtain as n' where \"targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"\n        and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n        and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n        \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a'))\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>targetnode\n                  a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "from \\<open>valid_edge a\\<close> \\<open>a' \\<in> get_return_edges a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  a' \\<in> get_return_edges a", "obtain a'' where \"valid_edge a''\" and \"sourcenode a'' = sourcenode a\"\n        and \"targetnode a'' = targetnode a'\" and \"intra_kind(kind a'')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  a' \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a''.\n        \\<lbrakk>valid_edge a''; sourcenode a'' = sourcenode a;\n         targetnode a'' = targetnode a'; intra_kind (kind a'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "with \\<open>targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')", "have \"sourcenode a -a''#as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  targetnode a' -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  valid_edge a''\n  sourcenode a'' = sourcenode a\n  targetnode a'' = targetnode a'\n  intra_kind (kind a'')\n\ngoal (1 subgoal):\n 1. sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "from \\<open>sourcenode a'' = sourcenode a\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a'' = sourcenode a\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' = sourcenode a''\n        \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  sourcenode a'' = sourcenode a\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' = sourcenode a'' \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce dest:SDG_Def_parent_Def call_source_Def_empty)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' = sourcenode a'' \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "with \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n        \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' = sourcenode a'' \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes (a''#as)) \n        \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' = sourcenode a'' \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a')) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "with \\<open>sourcenode a -a''#as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> \\<open>n' \\<in> HRB_slice S\\<close>\n        \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "show \"V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a -a'' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a'' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "have \"\\<forall>V \\<in> rv S (CFG_node (targetnode a)). \n      (Map.empty(ins [:=] params fs (fst cf\\<^sub>1))) V = \n      state_val (transfer (slice_kind S a) s\\<^sub>2) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "assume \"V \\<in> rv S (CFG_node (targetnode a))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>(THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "have eq:\"fst (hd (transfer (slice_kind S a) s\\<^sub>2)) = \n        Map.empty(ins [:=] params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))", "by(auto dest:slice_kind_Call_in_slice)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "show \"(Map.empty(ins [:=] params fs (fst cf\\<^sub>1))) V = \n        state_val (transfer (slice_kind S a) s\\<^sub>2) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof(cases \"V \\<in> set ins\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case True"], ["proof (state)\nthis:\n  V \\<in> set ins\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "then"], ["proof (chain)\npicking this:\n  V \\<in> set ins", "obtain i where \"V = ins!i\" and \"i < length ins\""], ["proof (prove)\nusing this:\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>V = ins ! i; i < length ins\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:in_set_conv_nth)"], ["proof (state)\nthis:\n  V = ins ! i\n  i < length ins\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>\n          \\<open>i < length ins\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  i < length ins", "have \"valid_SDG_node (Formal_in (targetnode a,i))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  i < length ins\n\ngoal (1 subgoal):\n 1. valid_SDG_node (Formal_in (targetnode a, i))", "by fastforce"], ["proof (state)\nthis:\n  valid_SDG_node (Formal_in (targetnode a, i))\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_proc(targetnode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_proc (targetnode a) = p", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode a) = p\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_SDG_node (Formal_in (targetnode a,i))\\<close> \n          \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>V = ins!i\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (Formal_in (targetnode a, i))\n  (p, ins, outs) \\<in> set procs\n  V = ins ! i\n  get_proc (targetnode a) = p", "have \"V \\<in> Def\\<^bsub>SDG\\<^esub> (Formal_in (targetnode a,i))\""], ["proof (prove)\nusing this:\n  valid_SDG_node (Formal_in (targetnode a, i))\n  (p, ins, outs) \\<in> set procs\n  V = ins ! i\n  get_proc (targetnode a) = p\n\ngoal (1 subgoal):\n 1. V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i)", "by(fastforce intro:Formal_in_SDG_Def)"], ["proof (state)\nthis:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))", "obtain as' nx \n          where \"targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\" \n          and \"nx \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> nx\"\n          and \"\\<forall>n''. valid_SDG_node n'' \\<and> \n          parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>as' nx.\n        \\<lbrakk>targetnode\n                  a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_SDG_node (Formal_in (targetnode a,i))\\<close>\n          \\<open>V \\<in> Def\\<^bsub>SDG\\<^esub> (Formal_in (targetnode a,i))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (Formal_in (targetnode a, i))\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i)\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"targetnode a = parent_node nx\""], ["proof (prove)\nusing this:\n  valid_SDG_node (Formal_in (targetnode a, i))\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i)\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. targetnode a = parent_node nx", "apply(auto simp:intra_path_def sourcenodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        targetnode a -as'\\<rightarrow>* parent_node nx;\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        targetnode a = targetnode a; i < length ins;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "apply(erule path.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Q r p fs ins outs n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        targetnode a = targetnode a; i < length ins;\n        (p, ins, outs) \\<in> set procs; targetnode a = n; as' = [];\n        parent_node nx = n; valid_node n\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx\n 2. \\<And>a Q r p fs ins outs n'' as n' aaa n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        targetnode a = targetnode a; i < length ins;\n        (p, ins, outs) \\<in> set procs; targetnode a = n; as' = aaa # as;\n        parent_node nx = n'; n'' -as\\<rightarrow>* n'; valid_edge aaa;\n        sourcenode aaa = n; targetnode aaa = n''\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Q r p fs ins outs n'' as n' aaa n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        targetnode a = targetnode a; i < length ins;\n        (p, ins, outs) \\<in> set procs; targetnode a = n; as' = aaa # as;\n        parent_node nx = n'; n'' -as\\<rightarrow>* n'; valid_edge aaa;\n        sourcenode aaa = n; targetnode aaa = n''\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "apply(erule_tac x=\"Formal_in (targetnode a,i)\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Q r p fs ins outs n'' as n' aaa n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        targetnode a = targetnode a; i < length ins;\n        (p, ins, outs) \\<in> set procs; targetnode a = n; as' = aaa # as;\n        parent_node nx = n'; n'' -as\\<rightarrow>* n'; valid_edge aaa;\n        sourcenode aaa = n; targetnode aaa = n'';\n        valid_SDG_node (Formal_in (targetnode a, i)) \\<and>\n        parent_node (Formal_in (targetnode a, i))\n        \\<in> sourcenode ` set as' \\<longrightarrow>\n        V \\<notin> Def\\<^bsub>SDG\\<^esub> Formal_in\n     (targetnode a, i)\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "by fastforce"], ["proof (state)\nthis:\n  targetnode a = parent_node nx\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> nx\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  targetnode a = parent_node nx", "have \"V \\<in> Use (targetnode a)\""], ["proof (prove)\nusing this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  targetnode a = parent_node nx\n\ngoal (1 subgoal):\n 1. V \\<in> Use (targetnode a)", "by(fastforce intro:SDG_Use_parent_Use)"], ["proof (state)\nthis:\n  V \\<in> Use (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<in> Use (targetnode a)", "have \"V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<in> Use (targetnode a)\n\ngoal (1 subgoal):\n 1. V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)", "by(auto intro!:CFG_Use_SDG_Use)"], ["proof (state)\nthis:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>targetnode a = parent_node nx\\<close>[THEN sym] \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  parent_node nx = targetnode a\n  valid_edge a", "have \"parent_node (Formal_in (targetnode a,i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\""], ["proof (prove)\nusing this:\n  parent_node nx = targetnode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. parent_node\n     (Formal_in\n       (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (Formal_in\n     (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V \\<in> Def\\<^bsub>SDG\\<^esub> (Formal_in (targetnode a,i))\\<close> \n          \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (targetnode a))\\<close> \\<open>targetnode a = parent_node nx\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i)\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n  targetnode a = parent_node nx\n  parent_node\n   (Formal_in\n     (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "have \"Formal_in (targetnode a,i) influences V in (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Formal_in (targetnode a, i)\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n  targetnode a = parent_node nx\n  parent_node\n   (Formal_in\n     (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i) influences V in CFG_node (targetnode a)", "by(fastforce simp:data_dependence_def sourcenodes_def)"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i) influences V in CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence ddep:\"Formal_in (targetnode a,i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  Formal_in (targetnode a, i) influences V in CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. Formal_in\n     (targetnode a,\n      i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)", "by(rule sum_SDG_ddep_edge)"], ["proof (state)\nthis:\n  Formal_in\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>targetnode a = parent_node nx\\<close> \\<open>nx \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = parent_node nx\n  nx \\<in> HRB_slice S", "have \"CFG_node (targetnode a) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  targetnode a = parent_node nx\n  nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a) \\<in> HRB_slice S", "by(fastforce dest:valid_SDG_node_in_slice_parent_node_in_slice)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence \"Formal_in (targetnode a,i) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i) \\<in> HRB_slice S", "proof(induct \"CFG_node (targetnode a)\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S", "case (phase1 nx)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S", "with ddep"], ["proof (chain)\npicking this:\n  Formal_in\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  Formal_in\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i) \\<in> HRB_slice S", "by(fastforce intro:ddep_slice1 combine_SDG_slices.combSlice_refl \n                         simp:HRB_slice_def)"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S", "case (phase2 nx n' n'' p)"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\n  nx \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S", "from \\<open>CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\\<close> ddep"], ["proof (chain)\npicking this:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\n  Formal_in\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)", "have \"Formal_in (targetnode a,i) \\<in> sum_SDG_slice2 n'\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\n  Formal_in\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i) \\<in> sum_SDG_slice2 n'", "by(fastforce intro:ddep_slice2)"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_in (targetnode a, i) \\<in> HRB_slice S", "with \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close> \\<open>n' \\<in> sum_SDG_slice1 nx\\<close> \n            \\<open>nx \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n' \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n  Formal_in (targetnode a, i) \\<in> sum_SDG_slice2 n'", "show ?case"], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n' \\<in> sum_SDG_slice1 nx\n  nx \\<in> S\n  Formal_in (targetnode a, i) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_Return_parent_node                                  simp:HRB_slice_def)"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i) \\<in> HRB_slice S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have slice_kind:\"slice_kind S a = \n          Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S)\n    fs", "by(rule slice_kind_Call_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"length fs = length ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length fs = length ins", "by(rule CFG_call_edge_length)"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>Formal_in (targetnode a,i) \\<in> HRB_slice S\\<close>\n          \\<open>length fs = length ins\\<close> \\<open>i < length ins\\<close>"], ["proof (chain)\npicking this:\n  Formal_in (targetnode a, i) \\<in> HRB_slice S\n  length fs = length ins\n  i < length ins", "have cspp:\"(cspp (targetnode a) (HRB_slice S) fs)!i = fs!i\""], ["proof (prove)\nusing this:\n  Formal_in (targetnode a, i) \\<in> HRB_slice S\n  length fs = length ins\n  i < length ins\n\ngoal (1 subgoal):\n 1. cspp (targetnode a) (HRB_slice S) fs ! i = fs ! i", "by(fastforce intro:csppa_Formal_in_in_slice simp:cspp_def)"], ["proof (state)\nthis:\n  cspp (targetnode a) (HRB_slice S) fs ! i = fs ! i\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>i < length ins\\<close> \\<open>length fs = length ins\\<close>"], ["proof (chain)\npicking this:\n  i < length ins\n  length fs = length ins", "have \"(params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))!i = \n          ((cspp (targetnode a) (HRB_slice S) fs)!i) (fst cf\\<^sub>2)\""], ["proof (prove)\nusing this:\n  i < length ins\n  length fs = length ins\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n    (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf\\<^sub>2)", "by(fastforce intro:params_nth)"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf\\<^sub>2)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with cspp"], ["proof (chain)\npicking this:\n  cspp (targetnode a) (HRB_slice S) fs ! i = fs ! i\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf\\<^sub>2)", "have eq:\"(params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))!i =\n          (fs!i) (fst cf\\<^sub>2)\""], ["proof (prove)\nusing this:\n  cspp (targetnode a) (HRB_slice S) fs ! i = fs ! i\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf\\<^sub>2)\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n    (fs ! i) (fst cf\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n  (fs ! i) (fst cf\\<^sub>2)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"(THE ins. \\<exists>outs. (p,ins,outs) \\<in> set procs) = ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "by(rule formal_in_THE)"], ["proof (state)\nthis:\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with slice_kind"], ["proof (chain)\npicking this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins", "have \"fst (hd (transfer (slice_kind S a) s\\<^sub>2)) = \n          Map.empty(ins [:=] params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\""], ["proof (prove)\nusing this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  (THE ins. \\<exists>outs. (p, ins, outs) \\<in> set procs) = ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "moreover"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs) \\<in> set procs", "have \"distinct ins\""], ["proof (prove)\nusing this:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. distinct ins", "by(rule distinct_formal_ins)"], ["proof (state)\nthis:\n  distinct ins\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "ultimately"], ["proof (chain)\npicking this:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n  distinct ins", "have \"state_val (transfer (slice_kind S a) s\\<^sub>2) V = \n          (params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))!i\""], ["proof (prove)\nusing this:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n  distinct ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i", "using \\<open>V = ins!i\\<close> \\<open>i < length ins\\<close> \\<open>length fs = length ins\\<close>"], ["proof (prove)\nusing this:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n  distinct ins\n  V = ins ! i\n  i < length ins\n  length fs = length ins\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i", "by(fastforce intro:fun_upds_nth)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with eq"], ["proof (chain)\npicking this:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n  (fs ! i) (fst cf\\<^sub>2)\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i", "have 2:\"state_val (transfer (slice_kind S a) s\\<^sub>2) V = (fs!i) (fst cf\\<^sub>2)\""], ["proof (prove)\nusing this:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i =\n  (fs ! i) (fst cf\\<^sub>2)\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2) ! i\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n    (fs ! i) (fst cf\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  (fs ! i) (fst cf\\<^sub>2)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>V = ins!i\\<close> \\<open>i < length ins\\<close> \\<open>length fs = length ins\\<close>\n          \\<open>distinct ins\\<close>"], ["proof (chain)\npicking this:\n  V = ins ! i\n  i < length ins\n  length fs = length ins\n  distinct ins", "have \"Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = (params fs (fst cf\\<^sub>1))!i\""], ["proof (prove)\nusing this:\n  V = ins ! i\n  i < length ins\n  length fs = length ins\n  distinct ins\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    params fs (fst cf\\<^sub>1) ! i", "by(fastforce intro:fun_upds_nth)"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  params fs (fst cf\\<^sub>1) ! i\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>i < length ins\\<close> \\<open>length fs = length ins\\<close>"], ["proof (chain)\npicking this:\n  i < length ins\n  length fs = length ins\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  params fs (fst cf\\<^sub>1) ! i", "have 1:\"Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = (fs!i) (fst cf\\<^sub>1)\""], ["proof (prove)\nusing this:\n  i < length ins\n  length fs = length ins\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  params fs (fst cf\\<^sub>1) ! i\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    (fs ! i) (fst cf\\<^sub>1)", "by(fastforce intro:params_nth)"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  (fs ! i) (fst cf\\<^sub>1)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n          (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V", "have rv:\"\\<forall>V\\<in>rv S (CFG_node (sourcenode a)). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n       fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by(erule_tac x=\"0\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> \n          \\<open>i < length ins\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  i < length ins", "have \"\\<forall>V\\<in>(ParamUses (sourcenode a)!i). \n          V \\<in> Use\\<^bsub>SDG\\<^esub> (Actual_in (sourcenode a,i))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  i < length ins\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n       V \\<in> Use\\<^bsub>SDG\\<^esub> Actual_in (sourcenode a, i)", "by(fastforce intro:Actual_in_SDG_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> Actual_in (sourcenode a, i)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> Actual_in (sourcenode a, i)", "have \"\\<forall>V\\<in>(ParamUses (sourcenode a)!i). \n          V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> Actual_in (sourcenode a, i)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n       V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)", "by(auto intro!:CFG_Use_SDG_Use dest:SDG_Use_parent_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "moreover"], ["proof (state)\nthis:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"parent_node (CFG_node (sourcenode a)) -[]\\<rightarrow>\\<^sub>\\<iota>* \n          parent_node (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. parent_node\n     (CFG_node\n       (sourcenode\n         a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n        (CFG_node (sourcenode a))", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))", "have \"\\<forall>V\\<in>(ParamUses (sourcenode a)!i). V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n       V \\<in> rv S (CFG_node (sourcenode a))", "using \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n       V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:rvI simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with rv"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> rv S (CFG_node (sourcenode a))", "have \"\\<forall>V \\<in> (ParamUses (sourcenode a))!i. fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode a)).\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n       fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>i < length ins\\<close>\n          \\<open>(p,ins,outs) \\<in> set procs\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "have \"(params fs (fst cf\\<^sub>1))!i = (params fs (fst cf\\<^sub>2))!i\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. params fs (fst cf\\<^sub>1) ! i = params fs (fst cf\\<^sub>2) ! i", "by(fastforce dest!:CFG_call_edge_params)"], ["proof (state)\nthis:\n  params fs (fst cf\\<^sub>1) ! i = params fs (fst cf\\<^sub>2) ! i\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "moreover"], ["proof (state)\nthis:\n  params fs (fst cf\\<^sub>1) ! i = params fs (fst cf\\<^sub>2) ! i\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>i < length ins\\<close> \\<open>length fs = length ins\\<close>"], ["proof (chain)\npicking this:\n  i < length ins\n  length fs = length ins", "have \"(params fs (fst cf\\<^sub>1))!i = (fs!i) (fst cf\\<^sub>1)\" \n          and \"(params fs (fst cf\\<^sub>2))!i = (fs!i) (fst cf\\<^sub>2)\""], ["proof (prove)\nusing this:\n  i < length ins\n  length fs = length ins\n\ngoal (1 subgoal):\n 1. params fs (fst cf\\<^sub>1) ! i = (fs ! i) (fst cf\\<^sub>1) &&&\n    params fs (fst cf\\<^sub>2) ! i = (fs ! i) (fst cf\\<^sub>2)", "by(auto intro:params_nth)"], ["proof (state)\nthis:\n  params fs (fst cf\\<^sub>1) ! i = (fs ! i) (fst cf\\<^sub>1)\n  params fs (fst cf\\<^sub>2) ! i = (fs ! i) (fst cf\\<^sub>2)\n\ngoal (2 subgoals):\n 1. V \\<in> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "ultimately"], ["proof (chain)\npicking this:\n  params fs (fst cf\\<^sub>1) ! i = params fs (fst cf\\<^sub>2) ! i\n  params fs (fst cf\\<^sub>1) ! i = (fs ! i) (fst cf\\<^sub>1)\n  params fs (fst cf\\<^sub>2) ! i = (fs ! i) (fst cf\\<^sub>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  params fs (fst cf\\<^sub>1) ! i = params fs (fst cf\\<^sub>2) ! i\n  params fs (fst cf\\<^sub>1) ! i = (fs ! i) (fst cf\\<^sub>1)\n  params fs (fst cf\\<^sub>2) ! i = (fs ! i) (fst cf\\<^sub>2)\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "using 1 2"], ["proof (prove)\nusing this:\n  params fs (fst cf\\<^sub>1) ! i = params fs (fst cf\\<^sub>2) ! i\n  params fs (fst cf\\<^sub>1) ! i = (fs ! i) (fst cf\\<^sub>1)\n  params fs (fst cf\\<^sub>2) ! i = (fs ! i) (fst cf\\<^sub>2)\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  (fs ! i) (fst cf\\<^sub>1)\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  (fs ! i) (fst cf\\<^sub>2)\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by simp"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case False"], ["proof (state)\nthis:\n  V \\<notin> set ins\n\ngoal (1 subgoal):\n 1. V \\<notin> set ins \\<Longrightarrow>\n    Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with eq"], ["proof (chain)\npicking this:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n  V \\<notin> set ins", "show ?thesis"], ["proof (prove)\nusing this:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) = Map.empty(ins [:=]\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf\\<^sub>2))\n  V \\<notin> set ins\n\ngoal (1 subgoal):\n 1. Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by(fastforce simp:fun_upds_notin)"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n     state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n      (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> cf2' \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close>\n      \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>\n      \\<open>ms\\<^sub>1' = (targetnode a)#(targetnode a')#tl ms\\<^sub>1\\<close>\n      \\<open>\\<forall>V \\<in> rv S (CFG_node (targetnode a')). V \\<in> rv S (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # s\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = r\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n     V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n     state_val (transfer (slice_kind S a) s\\<^sub>2) V", "have \"\\<forall>i<length ms\\<^sub>1'. \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1')!i)).\n      (fst (s\\<^sub>1'!(length [] + i))) V = (fst (transfer (slice_kind S a) s\\<^sub>2!i)) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # s\\<^sub>2 \\<and>\n     snd cf\\<^sub>2' = r\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n     V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V =\n     state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>1'.\n       \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n          fst (s\\<^sub>1' ! (length [] + i)) V =\n          fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i V.\n       \\<lbrakk>\\<forall>i<Suc (length cfs\\<^sub>2).\n                   \\<forall>V\\<in>rv S\n                                   (CFG_node\n                                     ((sourcenode a # tl ms\\<^sub>1) ! i)).\n                      fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! i) V =\n                      fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! i) V;\n        length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        i < Suc (Suc (length cfs\\<^sub>2));\n        V \\<in> rv S\n                 (CFG_node\n                   ((targetnode a # targetnode a' # tl ms\\<^sub>1) !\n                    i))\\<rbrakk>\n       \\<Longrightarrow> fst (((Map.empty(ins [:=]\n                                params fs (fst cf\\<^sub>1)), r) #\n                               cf\\<^sub>1 # cfs\\<^sub>1) !\n                              i)\n                          V =\n                         fst (((a, r) # cf\\<^sub>2 # cfs\\<^sub>2) ! i) V", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i V.\n       \\<lbrakk>\\<forall>i<Suc (length cfs\\<^sub>2).\n                   \\<forall>V\\<in>rv S\n                                   (CFG_node\n                                     ((sourcenode a # tl ms\\<^sub>1) ! i)).\n                      fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! i) V =\n                      fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! i) V;\n        length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        i < Suc (Suc (length cfs\\<^sub>2));\n        V \\<in> rv S\n                 (CFG_node\n                   ((targetnode a # targetnode a' # tl ms\\<^sub>1) ! i));\n        i = 0\\<rbrakk>\n       \\<Longrightarrow> fst (((Map.empty(ins [:=]\n                                params fs (fst cf\\<^sub>1)), r) #\n                               cf\\<^sub>1 # cfs\\<^sub>1) !\n                              i)\n                          V =\n                         fst (((a, r) # cf\\<^sub>2 # cfs\\<^sub>2) ! i) V\n 2. \\<And>a i V nat.\n       \\<lbrakk>\\<forall>i<Suc (length cfs\\<^sub>2).\n                   \\<forall>V\\<in>rv S\n                                   (CFG_node\n                                     ((sourcenode a # tl ms\\<^sub>1) ! i)).\n                      fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! i) V =\n                      fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! i) V;\n        length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        i < Suc (Suc (length cfs\\<^sub>2));\n        V \\<in> rv S\n                 (CFG_node\n                   ((targetnode a # targetnode a' # tl ms\\<^sub>1) ! i));\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fst (((Map.empty(ins [:=]\n                                params fs (fst cf\\<^sub>1)), r) #\n                               cf\\<^sub>1 # cfs\\<^sub>1) !\n                              i)\n                          V =\n                         fst (((a, r) # cf\\<^sub>2 # cfs\\<^sub>2) ! i) V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a V nat.\n       \\<lbrakk>\\<forall>i<Suc (length cfs\\<^sub>2).\n                   \\<forall>V\\<in>rv S\n                                   (CFG_node\n                                     ((sourcenode a # tl ms\\<^sub>1) ! i)).\n                      fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! i) V =\n                      fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! i) V;\n        length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        nat < Suc (length cfs\\<^sub>2);\n        V \\<in> rv S\n                 (CFG_node ((targetnode a' # tl ms\\<^sub>1) ! nat))\\<rbrakk>\n       \\<Longrightarrow> fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n                         fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V", "apply(erule_tac x=\"nat\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a V nat.\n       \\<lbrakk>length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        nat < Suc (length cfs\\<^sub>2);\n        V \\<in> rv S (CFG_node ((targetnode a' # tl ms\\<^sub>1) ! nat));\n        nat < Suc (length cfs\\<^sub>2) \\<longrightarrow>\n        (\\<forall>V\\<in>rv S\n                         (CFG_node ((sourcenode a # tl ms\\<^sub>1) ! nat)).\n            fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n            fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V)\\<rbrakk>\n       \\<Longrightarrow> fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n                         fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V", "apply(case_tac nat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a V nat.\n       \\<lbrakk>length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        nat < Suc (length cfs\\<^sub>2);\n        V \\<in> rv S (CFG_node ((targetnode a' # tl ms\\<^sub>1) ! nat));\n        nat < Suc (length cfs\\<^sub>2) \\<longrightarrow>\n        (\\<forall>V\\<in>rv S\n                         (CFG_node ((sourcenode a # tl ms\\<^sub>1) ! nat)).\n            fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n            fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V);\n        nat = 0\\<rbrakk>\n       \\<Longrightarrow> fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n                         fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V\n 2. \\<And>a V nat nata.\n       \\<lbrakk>length ms\\<^sub>2 = Suc (length cfs\\<^sub>2);\n        length ms\\<^sub>1 = Suc (length cfs\\<^sub>2);\n        length cfs\\<^sub>1 = length cfs\\<^sub>2;\n        ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1;\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a')).\n           V \\<in> rv S (CFG_node (sourcenode a));\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           Map.empty(ins [:=] params fs (fst cf\\<^sub>1)) V = a V;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfs\\<^sub>2) =\n        (a, r) # cf\\<^sub>2 # cfs\\<^sub>2;\n        nat < Suc (length cfs\\<^sub>2);\n        V \\<in> rv S (CFG_node ((targetnode a' # tl ms\\<^sub>1) ! nat));\n        nat < Suc (length cfs\\<^sub>2) \\<longrightarrow>\n        (\\<forall>V\\<in>rv S\n                         (CFG_node ((sourcenode a # tl ms\\<^sub>1) ! nat)).\n            fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n            fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V);\n        nat = Suc nata\\<rbrakk>\n       \\<Longrightarrow> fst ((cf\\<^sub>1 # cfs\\<^sub>1) ! nat) V =\n                         fst ((cf\\<^sub>2 # cfs\\<^sub>2) ! nat) V", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>m \\<in> set ms\\<^sub>2. valid_node m\\<close> \\<open>\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\\<close> \n      \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\\<close>\n      \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>ms\\<^sub>1' = (targetnode a)#(targetnode a')#tl ms\\<^sub>1\\<close>\n      \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close> \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>return_node (targetnode a')\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>\n      \\<open>call_of_return_node (targetnode a') (sourcenode a)\\<close>\n      \\<open>\\<forall>i<length ms\\<^sub>1'. snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>2) valid_node\n  Ball (set ms\\<^sub>1') valid_node\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  return_node (targetnode a')\n  Ball (set (tl ms\\<^sub>1)) return_node\n  call_of_return_node (targetnode a') (sourcenode a)\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V", "have \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>2) valid_node\n  Ball (set ms\\<^sub>1') valid_node\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  ms\\<^sub>1' = targetnode a # targetnode a' # tl ms\\<^sub>1\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  return_node (targetnode a')\n  Ball (set (tl ms\\<^sub>1)) return_node\n  call_of_return_node (targetnode a') (sourcenode a)\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S (CFG_node ((targetnode a # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfer (slice_kind S a) s\\<^sub>2)\n    \\<in> WS S", "by(fastforce intro!:WSI)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S\n\ngoal (2 subgoals):\n 1. \\<And>a s s' Q r p fs a' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; valid_edge a';\n        a' \\<in> get_return_edges a;\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        hd ms \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s' = Suc (length s);\n        hd ms = sourcenode a; ms' = targetnode a # targetnode a' # tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)\n 2. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S", "show ?case"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n           [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n      transfer (slice_kind S a) s\\<^sub>2)\n     \\<in> WS S \\<and>\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n         [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "case (observable_move_return a s\\<^sub>1 s\\<^sub>1' Q p f' ms\\<^sub>1 S ms\\<^sub>1')"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = Suc (length s\\<^sub>1')\n  s\\<^sub>1' \\<noteq> []\n  hd ms\\<^sub>1 = sourcenode a\n  hd (tl ms\\<^sub>1) = targetnode a\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  Ball (set ms\\<^sub>1) valid_node\n  Ball (set ms\\<^sub>2) valid_node\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n  Ball (set (tl ms\\<^sub>1)) return_node\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>s\\<^sub>1 \\<noteq> []\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []", "obtain cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2 where [simp]:\"s\\<^sub>1 = cf\\<^sub>1#cfs\\<^sub>1\" \n      and [simp]:\"s\\<^sub>2 = cf\\<^sub>2#cfs\\<^sub>2\""], ["proof (prove)\nusing this:\n  s\\<^sub>1 \\<noteq> []\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cf\\<^sub>1 cfs\\<^sub>1 cf\\<^sub>2 cfs\\<^sub>2.\n        \\<lbrakk>s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1;\n         s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s\\<^sub>1,auto,cases s\\<^sub>2,fastforce+)"], ["proof (state)\nthis:\n  s\\<^sub>1 = cf\\<^sub>1 # cfs\\<^sub>1\n  s\\<^sub>2 = cf\\<^sub>2 # cfs\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>s\\<^sub>1 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  s\\<^sub>1 \\<noteq> []", "have [simp]:\"ms\\<^sub>1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  s\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1 \\<noteq> []", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  ms\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>s\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []", "have [simp]:\"ms\\<^sub>2 \\<noteq> []\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n  s\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. ms\\<^sub>2 \\<noteq> []", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  ms\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>hd ms\\<^sub>1 = sourcenode a\\<close> \\<open>ms\\<^sub>1 = msx@mx#tl ms\\<^sub>2\\<close>\n      \\<open>msx \\<noteq> [] \\<longrightarrow> (\\<exists>mx'. call_of_return_node mx mx' \\<and> mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)", "have [simp]:\"mx = sourcenode a\" \"msx = []\" and [simp]:\"tl ms\\<^sub>2 = tl ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  ms\\<^sub>1 = msx @ mx # tl ms\\<^sub>2\n  msx \\<noteq> [] \\<longrightarrow>\n  (\\<exists>mx'.\n      call_of_return_node mx mx' \\<and>\n      mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>)\n\ngoal (1 subgoal):\n 1. (mx = sourcenode a &&& msx = []) &&& tl ms\\<^sub>2 = tl ms\\<^sub>1", "by(cases msx,auto)+"], ["proof (state)\nthis:\n  mx = sourcenode a\n  msx = []\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "hence \"length ms\\<^sub>1 = length ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  mx = sourcenode a\n  msx = []\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1 = length ms\\<^sub>2", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  length ms\\<^sub>1 = length ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2", "have \"length s\\<^sub>1 = length s\\<^sub>2\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length ms\\<^sub>1 = length ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1 = length s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  length s\\<^sub>1 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "have \"\\<exists>as. S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "proof(cases \"obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "case True"], ["proof (state)\nthis:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  hd ms\\<^sub>1 = sourcenode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"method_exit (hd ms\\<^sub>1)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  hd ms\\<^sub>1 = sourcenode a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (hd ms\\<^sub>1)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (hd ms\\<^sub>1)\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "from \\<open>\\<forall>m\\<in>set ms\\<^sub>2. valid_node m\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>2) valid_node", "have \"valid_node (hd ms\\<^sub>2)\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>2) valid_node\n\ngoal (1 subgoal):\n 1. valid_node (hd ms\\<^sub>2)", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  valid_node (hd ms\\<^sub>2)\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  valid_node (hd ms\\<^sub>2)", "obtain asx where \"hd ms\\<^sub>2 -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node (hd ms\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        hd ms\\<^sub>2 -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:Exit_path)"], ["proof (state)\nthis:\n  hd ms\\<^sub>2 -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  hd ms\\<^sub>2 -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain as pex where \"hd ms\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* pex\" and \"method_exit pex\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>2 -asx\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>as pex.\n        \\<lbrakk>hd ms\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* pex;\n         method_exit pex\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:valid_Exit_path_intra_path)"], ["proof (state)\nthis:\n  hd ms\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* pex\n  method_exit pex\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "from \\<open>hd ms\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* pex\\<close>"], ["proof (chain)\npicking this:\n  hd ms\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* pex", "have \"get_proc (hd ms\\<^sub>2) = get_proc pex\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>2 -as\\<rightarrow>\\<^sub>\\<iota>* pex\n\ngoal (1 subgoal):\n 1. get_proc (hd ms\\<^sub>2) = get_proc pex", "by(rule intra_path_get_procs)"], ["proof (state)\nthis:\n  get_proc (hd ms\\<^sub>2) = get_proc pex\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  get_proc (hd ms\\<^sub>2) = get_proc pex", "have \"get_proc mx = get_proc pex\""], ["proof (prove)\nusing this:\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  get_proc (hd ms\\<^sub>2) = get_proc pex\n\ngoal (1 subgoal):\n 1. get_proc mx = get_proc pex", "by simp"], ["proof (state)\nthis:\n  get_proc mx = get_proc pex\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>method_exit (hd ms\\<^sub>1)\\<close> \\<open> hd ms\\<^sub>1 = sourcenode a\\<close> \\<open>method_exit pex\\<close>"], ["proof (chain)\npicking this:\n  method_exit (hd ms\\<^sub>1)\n  hd ms\\<^sub>1 = sourcenode a\n  method_exit pex\n  get_proc mx = get_proc pex", "have [simp]:\"pex = hd ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  method_exit (hd ms\\<^sub>1)\n  hd ms\\<^sub>1 = sourcenode a\n  method_exit pex\n  get_proc mx = get_proc pex\n\ngoal (1 subgoal):\n 1. pex = hd ms\\<^sub>1", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  pex = hd ms\\<^sub>1\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "from \\<open>obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {}\\<close> \\<open>method_exit pex\\<close>\n        \\<open>get_proc (hd ms\\<^sub>2) = get_proc pex\\<close> \\<open>valid_node (hd ms\\<^sub>2)\\<close>\n        \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>1). return_node m\\<close> \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit pex\n  get_proc (hd ms\\<^sub>2) = get_proc pex\n  valid_node (hd ms\\<^sub>2)\n  length ms\\<^sub>2 = length s\\<^sub>2\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>2 \\<noteq> []", "obtain as' \n        where \"S,slice_kind S \\<turnstile> (hd ms\\<^sub>2#tl ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (hd ms\\<^sub>1#tl ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {}\n  method_exit pex\n  get_proc (hd ms\\<^sub>2) = get_proc pex\n  valid_node (hd ms\\<^sub>2)\n  length ms\\<^sub>2 = length s\\<^sub>2\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        S,slice_kind\n           S \\<turnstile> (hd ms\\<^sub>2 #\n                           tl ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (hd\n         ms\\<^sub>1 #\n        tl ms\\<^sub>1,s\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:silent_moves_intra_path_no_obs[of _ _ _ s\\<^sub>2 \"tl ms\\<^sub>2\"]\n                     dest:hd_Cons_tl)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (hd\n   ms\\<^sub>1 #\n  tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (hd\n   ms\\<^sub>1 #\n  tl ms\\<^sub>1,s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (hd\n   ms\\<^sub>1 #\n  tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "by(fastforce dest!:hd_Cons_tl)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n 2. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "case False"], ["proof (state)\nthis:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}", "obtain x where \"x \\<in> obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> obs_intra (hd ms\\<^sub>2)\n                 \\<lfloor>HRB_slice\n                           S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "hence \"obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = {x}\""], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n    {x}", "by(rule obs_intra_singleton_element)"], ["proof (state)\nthis:\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {x}\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>2). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {x}", "have \"x#tl ms\\<^sub>1 \\<in> obs ([]@hd ms\\<^sub>2#tl ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>2).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  obs_intra (hd ms\\<^sub>2)\n   \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  {x}\n\ngoal (1 subgoal):\n 1. x # tl ms\\<^sub>1\n    \\<in> obs ([] @ hd ms\\<^sub>2 # tl ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce intro:obsI)"], ["proof (state)\nthis:\n  x # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>2 # tl ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  x # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>2 # tl ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"x#tl ms\\<^sub>1 \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  x # tl ms\\<^sub>1\n  \\<in> obs ([] @ hd ms\\<^sub>2 # tl ms\\<^sub>2)\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. x # tl ms\\<^sub>1\n    \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(fastforce dest:hd_Cons_tl simp del:obs.simps)"], ["proof (state)\nthis:\n  x # tl ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> = obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x # tl ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"x#tl ms\\<^sub>1 \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n  obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  x # tl ms\\<^sub>1\n  \\<in> obs ms\\<^sub>2 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. x # tl ms\\<^sub>1\n    \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  x # tl ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "from this \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>1). return_node m\\<close>"], ["proof (chain)\npicking this:\n  x # tl ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node", "have \"x \\<in> obs_intra (hd ms\\<^sub>1) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  x # tl ms\\<^sub>1\n  \\<in> obs ms\\<^sub>1 \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms\\<^sub>1)) return_node\n\ngoal (1 subgoal):\n 1. x \\<in> obs_intra (hd ms\\<^sub>1)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(rule obsE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>1 = nsx @ n # nsx'; x # tl ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> obs_intra (hd ms\\<^sub>1)\n                                  \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "fix nsx n nsx' n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>1 = nsx @ n # nsx'; x # tl ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> obs_intra (hd ms\\<^sub>1)\n                                  \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "assume \"ms\\<^sub>1 = nsx @ n # nsx'\" and \"x # tl ms\\<^sub>1 = n' # nsx'\"\n          and \"n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  ms\\<^sub>1 = nsx @ n # nsx'\n  x # tl ms\\<^sub>1 = n' # nsx'\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>1 = nsx @ n # nsx'; x # tl ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> obs_intra (hd ms\\<^sub>1)\n                                  \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>ms\\<^sub>1 = nsx @ n # nsx'\\<close> \\<open>x # tl ms\\<^sub>1 = n' # nsx'\\<close> \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = nsx @ n # nsx'\n  x # tl ms\\<^sub>1 = n' # nsx'\n  tl ms\\<^sub>2 = tl ms\\<^sub>1", "have [simp]:\"nsx = []\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = nsx @ n # nsx'\n  x # tl ms\\<^sub>1 = n' # nsx'\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. nsx = []", "by(cases nsx) auto"], ["proof (state)\nthis:\n  nsx = []\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>1 = nsx @ n # nsx'; x # tl ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> obs_intra (hd ms\\<^sub>1)\n                                  \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>ms\\<^sub>1 = nsx @ n # nsx'\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1 = nsx @ n # nsx'\n  nsx = []", "have [simp]:\"n = hd ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1 = nsx @ n # nsx'\n  nsx = []\n\ngoal (1 subgoal):\n 1. n = hd ms\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  n = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>1 = nsx @ n # nsx'; x # tl ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> obs_intra (hd ms\\<^sub>1)\n                                  \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "from \\<open>x # tl ms\\<^sub>1 = n' # nsx'\\<close>"], ["proof (chain)\npicking this:\n  x # tl ms\\<^sub>1 = n' # nsx'", "have [simp]:\"n' = x\""], ["proof (prove)\nusing this:\n  x # tl ms\\<^sub>1 = n' # nsx'\n\ngoal (1 subgoal):\n 1. n' = x", "by simp"], ["proof (state)\nthis:\n  n' = x\n\ngoal (1 subgoal):\n 1. \\<And>nsx n nsx' n'.\n       \\<lbrakk>ms\\<^sub>1 = nsx @ n # nsx'; x # tl ms\\<^sub>1 = n' # nsx';\n        n' \\<in> obs_intra n\n                  \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>nx\\<in>set nsx'.\n           \\<exists>nx'.\n              call_of_return_node nx nx' \\<and>\n              nx' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        \\<forall>xs x xs'.\n           nsx = xs @ x # xs' \\<and>\n           obs_intra x\n            \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n           {} \\<longrightarrow>\n           (\\<exists>x''\\<in>set (xs' @ [n]).\n               \\<exists>nx.\n                  call_of_return_node x'' nx \\<and>\n                  nx \\<notin> \\<lfloor>HRB_slice\n  S\\<rfloor>\\<^bsub>CFG\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> obs_intra (hd ms\\<^sub>1)\n                                  \\<lfloor>HRB_slice\n      S\\<rfloor>\\<^bsub>CFG\\<^esub>", "with \\<open>n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = x", "show ?thesis"], ["proof (prove)\nusing this:\n  n' \\<in> obs_intra n \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  n' = x\n\ngoal (1 subgoal):\n 1. x \\<in> obs_intra (hd ms\\<^sub>1)\n             \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  x \\<in> obs_intra (hd ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> obs_intra (hd ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "{"], ["proof (state)\nthis:\n  x \\<in> obs_intra (hd ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "fix m as"], ["proof (state)\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "assume \"hd ms\\<^sub>1 -as\\<rightarrow>\\<^sub>\\<iota>* m\""], ["proof (state)\nthis:\n  hd ms\\<^sub>1 -as\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "hence \"hd ms\\<^sub>1 -as\\<rightarrow>* m\" and \"\\<forall>a \\<in> set as. intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 -as\\<rightarrow>\\<^sub>\\<iota>* m\n\ngoal (1 subgoal):\n 1. hd ms\\<^sub>1 -as\\<rightarrow>* m &&&\n    \\<forall>a\\<in>set as. intra_kind (kind a)", "by(simp_all add:intra_path_def)"], ["proof (state)\nthis:\n  hd ms\\<^sub>1 -as\\<rightarrow>* m\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "hence \"m = hd ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  hd ms\\<^sub>1 -as\\<rightarrow>* m\n  \\<forall>a\\<in>set as. intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. m = hd ms\\<^sub>1", "proof(induct \"hd ms\\<^sub>1\" as m rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (hd ms\\<^sub>1);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> hd ms\\<^sub>1 = hd ms\\<^sub>1\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = hd ms\\<^sub>1;\n         \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> n' = hd ms\\<^sub>1;\n        valid_edge a; sourcenode a = hd ms\\<^sub>1; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> n' = hd ms\\<^sub>1", "case (Cons_path m'' as' m' a')"], ["proof (state)\nthis:\n  m'' -as'\\<rightarrow>* m'\n  \\<lbrakk>m'' = hd ms\\<^sub>1;\n   \\<forall>a\\<in>set as'. intra_kind (kind a)\\<rbrakk>\n  \\<Longrightarrow> m' = hd ms\\<^sub>1\n  valid_edge a'\n  sourcenode a' = hd ms\\<^sub>1\n  targetnode a' = m''\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (hd ms\\<^sub>1);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> hd ms\\<^sub>1 = hd ms\\<^sub>1\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = hd ms\\<^sub>1;\n         \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> n' = hd ms\\<^sub>1;\n        valid_edge a; sourcenode a = hd ms\\<^sub>1; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> n' = hd ms\\<^sub>1", "from \\<open>\\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)", "have \"intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a' # as'). intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a')", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (hd ms\\<^sub>1);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> hd ms\\<^sub>1 = hd ms\\<^sub>1\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = hd ms\\<^sub>1;\n         \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> n' = hd ms\\<^sub>1;\n        valid_edge a; sourcenode a = hd ms\\<^sub>1; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> n' = hd ms\\<^sub>1", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>valid_edge a'\\<close> \n            \\<open>sourcenode a' = hd ms\\<^sub>1\\<close> \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge a'\n  sourcenode a' = hd ms\\<^sub>1\n  hd ms\\<^sub>1 = sourcenode a\n  intra_kind (kind a')", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge a'\n  sourcenode a' = hd ms\\<^sub>1\n  hd ms\\<^sub>1 = sourcenode a\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:return_edges_only simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (hd ms\\<^sub>1);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> hd ms\\<^sub>1 = hd ms\\<^sub>1\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = hd ms\\<^sub>1;\n         \\<forall>a\\<in>set as. intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> n' = hd ms\\<^sub>1;\n        valid_edge a; sourcenode a = hd ms\\<^sub>1; targetnode a = n'';\n        \\<forall>a\\<in>set (a # as). intra_kind (kind a)\\<rbrakk>\n       \\<Longrightarrow> n' = hd ms\\<^sub>1", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. m' = hd ms\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  m' = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (hd ms\\<^sub>1);\n     \\<forall>a\\<in>set []. intra_kind (kind a)\\<rbrakk>\n    \\<Longrightarrow> hd ms\\<^sub>1 = hd ms\\<^sub>1", "qed simp"], ["proof (state)\nthis:\n  m = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "}"], ["proof (state)\nthis:\n  hd ms\\<^sub>1 -?as2\\<rightarrow>\\<^sub>\\<iota>* ?m2 \\<Longrightarrow>\n  ?m2 = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>x \\<in> obs_intra (hd ms\\<^sub>1) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> obs_intra (hd ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 -?as2\\<rightarrow>\\<^sub>\\<iota>* ?m2 \\<Longrightarrow>\n  ?m2 = hd ms\\<^sub>1", "have \"x = hd ms\\<^sub>1\""], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (hd ms\\<^sub>1)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 -?as2\\<rightarrow>\\<^sub>\\<iota>* ?m2 \\<Longrightarrow>\n  ?m2 = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. x = hd ms\\<^sub>1", "by(fastforce elim:obs_intraE)"], ["proof (state)\nthis:\n  x = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>x \\<in> obs_intra (hd ms\\<^sub>2) \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \n        \\<open>\\<forall>m\\<in>set (tl ms\\<^sub>1). return_node m\\<close> \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms\\<^sub>2 = length s\\<^sub>2\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>2 \\<noteq> []\n  x = hd ms\\<^sub>1", "obtain as where \"S,slice_kind S \\<turnstile> (hd ms\\<^sub>2#tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd ms\\<^sub>1#tl ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  x \\<in> obs_intra (hd ms\\<^sub>2)\n           \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  length ms\\<^sub>2 = length s\\<^sub>2\n  Ball (set (tl ms\\<^sub>1)) return_node\n  ms\\<^sub>2 \\<noteq> []\n  x = hd ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (hd ms\\<^sub>2 #\n                           tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n        ms\\<^sub>1 #\n       tl ms\\<^sub>1,s\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:silent_moves_intra_path_obs[of _ _ _ s\\<^sub>2 \"tl ms\\<^sub>2\"] \n                     dest:hd_Cons_tl)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "with \\<open>ms\\<^sub>2 \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ms\\<^sub>2 \\<noteq> []\n  S,slice_kind\n     S \\<turnstile> (hd ms\\<^sub>2 #\n                     tl ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (hd\n  ms\\<^sub>1 #\n tl ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "by(fastforce dest!:hd_Cons_tl)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. obs_intra (hd ms\\<^sub>2)\n     \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<noteq>\n    {} \\<Longrightarrow>\n    \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)", "obtain as where \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = Suc(length s\\<^sub>1')\\<close> \n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  length s\\<^sub>1 = Suc (length s\\<^sub>1')\n  length ms\\<^sub>1 = length s\\<^sub>1", "have \"length ms\\<^sub>1' = length s\\<^sub>1'\""], ["proof (prove)\nusing this:\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  length s\\<^sub>1 = Suc (length s\\<^sub>1')\n  length ms\\<^sub>1 = length s\\<^sub>1\n\ngoal (1 subgoal):\n 1. length ms\\<^sub>1' = length s\\<^sub>1'", "by simp"], ["proof (state)\nthis:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "obtain a'' Q' r' fs' where \"valid_edge a''\"\n      and \"kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\" and \"a \\<in> get_return_edges a''\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (\\<And>a'' Q' r' fs'.\n        \\<lbrakk>valid_edge a'';\n         kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs';\n         a \\<in> get_return_edges a''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule return_needs_call,auto)"], ["proof (state)\nthis:\n  valid_edge a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a''\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  valid_edge a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a''", "obtain ins outs where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a''\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length s\\<^sub>1 = Suc(length s\\<^sub>1')\\<close> \\<open>s\\<^sub>1' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  length s\\<^sub>1 = Suc (length s\\<^sub>1')\n  s\\<^sub>1' \\<noteq> []", "obtain cfx cfsx where [simp]:\"cfs\\<^sub>1 = cfx#cfsx\""], ["proof (prove)\nusing this:\n  length s\\<^sub>1 = Suc (length s\\<^sub>1')\n  s\\<^sub>1' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>cfx cfsx.\n        cfs\\<^sub>1 = cfx # cfsx \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases cfs\\<^sub>1) auto"], ["proof (state)\nthis:\n  cfs\\<^sub>1 = cfx # cfsx\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length s\\<^sub>1 = length s\\<^sub>2\n  cfs\\<^sub>1 = cfx # cfsx", "obtain cfx' cfsx' where [simp]:\"cfs\\<^sub>2 = cfx'#cfsx'\""], ["proof (prove)\nusing this:\n  length s\\<^sub>1 = length s\\<^sub>2\n  cfs\\<^sub>1 = cfx # cfsx\n\ngoal (1 subgoal):\n 1. (\\<And>cfx' cfsx'.\n        cfs\\<^sub>2 = cfx' # cfsx' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases cfs\\<^sub>2) auto"], ["proof (state)\nthis:\n  cfs\\<^sub>2 = cfx' # cfsx'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1 = length s\\<^sub>1", "have \"tl ms\\<^sub>1 = []@hd(tl ms\\<^sub>1)#tl(tl ms\\<^sub>1)\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1 = length s\\<^sub>1\n\ngoal (1 subgoal):\n 1. tl ms\\<^sub>1 = [] @ hd (tl ms\\<^sub>1) # tl (tl ms\\<^sub>1)", "by(auto simp:length_Suc_conv)"], ["proof (state)\nthis:\n  tl ms\\<^sub>1 = [] @ hd (tl ms\\<^sub>1) # tl (tl ms\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'", "have \"s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx),snd cfx)#cfsx\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx), snd cfx) # cfsx", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx), snd cfx) # cfsx\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have \"f' (fst cf\\<^sub>1) (fst cfx) = \n      (fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. f' (fst cf\\<^sub>1) (fst cfx) = fst cfx(ParamDefs (targetnode a) [:=]\n    map (fst cf\\<^sub>1) outs)", "by(rule CFG_return_edge_fun)"], ["proof (state)\nthis:\n  f' (fst cf\\<^sub>1) (fst cfx) = fst cfx(ParamDefs (targetnode a) [:=]\n  map (fst cf\\<^sub>1) outs)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx),snd cfx)#cfsx\\<close>"], ["proof (chain)\npicking this:\n  s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx), snd cfx) # cfsx\n  f' (fst cf\\<^sub>1) (fst cfx) = fst cfx(ParamDefs (targetnode a) [:=]\n  map (fst cf\\<^sub>1) outs)", "have [simp]:\"s\\<^sub>1' = \n      ((fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs),snd cfx)#cfsx\""], ["proof (prove)\nusing this:\n  s\\<^sub>1' = (f' (fst cf\\<^sub>1) (fst cfx), snd cfx) # cfsx\n  f' (fst cf\\<^sub>1) (fst cfx) = fst cfx(ParamDefs (targetnode a) [:=]\n  map (fst cf\\<^sub>1) outs)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' =\n    (fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs),\n     snd cfx) #\n    cfsx", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' =\n  (fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs),\n   snd cfx) #\n  cfsx\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "have \"pred (slice_kind S a) s\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s\\<^sub>2", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  valid_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "hence \"sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n\ngoal (1 subgoal):\n 1. sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "with \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "have \"\\<forall>V. V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a)) \n        \\<longrightarrow> V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<forall>V.\n       V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n (sourcenode a) \\<longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode a))", "by auto(rule rvI,auto simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "with \\<open>valid_node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  valid_node (sourcenode a)\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))", "have \"\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode a)\n  \\<forall>V.\n     V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node\n                                     (sourcenode a) \\<longrightarrow>\n     V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       V \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:CFG_Use_SDG_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "from \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n        (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"\\<forall>V\\<in>rv S (CFG_node mx). (fst (s\\<^sub>1 ! length msx)) V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node mx).\n       fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "by(cases ms\\<^sub>2) auto"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "with \\<open>\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V", "have \"\\<forall>V \\<in> Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node (sourcenode a))\n  \\<forall>V\\<in>rv S (CFG_node mx).\n     fst (s\\<^sub>1 ! length msx) V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)", "have \"snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)", "by(erule_tac x=\"0\" in allE) auto"], ["proof (state)\nthis:\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)", "have \"pred (kind a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "using \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). fst cf\\<^sub>1 V = fst cf\\<^sub>2 V\n  snd (hd s\\<^sub>1) = snd (hd s\\<^sub>2)\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "by(fastforce intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>2\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> \n        \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  pred (kind a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s\\<^sub>2", "by(fastforce dest:slice_kind_Return_in_slice)"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "with \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = (\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')\""], ["proof (prove)\nusing this:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'", "by -(rule slice_kind_Return)"], ["proof (state)\nthis:\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    pred (slice_kind S a) s\\<^sub>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close> \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'", "have \"length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  length s\\<^sub>1 = length s\\<^sub>2\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)", "by(fastforce intro:length_transfer_kind_slice_kind)"], ["proof (state)\nthis:\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>pred (slice_kind S a) s\\<^sub>2\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n      \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>hd ms\\<^sub>1 = sourcenode a\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>\n      \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close> \\<open>hd(tl ms\\<^sub>1) = targetnode a\\<close> \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>"], ["proof (chain)\npicking this:\n  pred (slice_kind S a) s\\<^sub>2\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  hd (tl ms\\<^sub>1) = targetnode a\n  Ball (set (tl ms\\<^sub>1)) return_node\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s\\<^sub>2\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  hd ms\\<^sub>1 = sourcenode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>1 = length s\\<^sub>2\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  hd (tl ms\\<^sub>1) = targetnode a\n  Ball (set (tl ms\\<^sub>1)) return_node\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                     (slice_kind S a) s\\<^sub>2)", "by(fastforce intro!:observable_move.observable_move_return)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (ms\\<^sub>1,s\\<^sub>2)\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (ms\\<^sub>1',transfer\n                                   (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n        [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "by(rule observable_moves_snoc)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set ms\\<^sub>1. valid_node m\\<close> \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = tl ms\\<^sub>1", "have \"\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>1) valid_node\n  ms\\<^sub>1' = tl ms\\<^sub>1\n\ngoal (1 subgoal):\n 1. Ball (set ms\\<^sub>1') valid_node", "by(cases ms\\<^sub>1) auto"], ["proof (state)\nthis:\n  Ball (set ms\\<^sub>1') valid_node\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>1' = length s\\<^sub>1'", "have \"ms\\<^sub>1' = []@hd ms\\<^sub>1'#tl ms\\<^sub>1'\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>1' = length s\\<^sub>1'\n\ngoal (1 subgoal):\n 1. ms\\<^sub>1' = [] @ hd ms\\<^sub>1' # tl ms\\<^sub>1'", "by(cases ms\\<^sub>1') auto"], ["proof (state)\nthis:\n  ms\\<^sub>1' = [] @ hd ms\\<^sub>1' # tl ms\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close>\n      \\<open>length ms\\<^sub>1 = length ms\\<^sub>2\\<close> \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1", "have \"snd cfx = snd cfx'\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n\ngoal (1 subgoal):\n 1. snd cfx = snd cfx'", "by(erule_tac x=\"1\" in allE) auto"], ["proof (state)\nthis:\n  snd cfx = snd cfx'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have cf2':\"\\<exists>cf\\<^sub>2'. transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2'#cfsx' \\<and> snd cf\\<^sub>2' = snd cfx'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<exists>cf\\<^sub>2'.\n       transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n       snd cf\\<^sub>2' = snd cfx'", "by(cases cfx',cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\",\n         auto dest:slice_kind_Return slice_kind_Return_in_slice)"], ["proof (state)\nthis:\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n     snd cf\\<^sub>2' = snd cfx'\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>i<length ms\\<^sub>2. snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\\<close> \n      \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>msx = []\\<close> \\<open>length ms\\<^sub>1 = length ms\\<^sub>2\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>snd cfx = snd cfx'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  msx = []\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  snd cfx = snd cfx'\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n     snd cf\\<^sub>2' = snd cfx'", "have \"\\<forall>i<length ms\\<^sub>1'. snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     snd (s\\<^sub>1 ! (length msx + i)) = snd (s\\<^sub>2 ! i)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  msx = []\n  length ms\\<^sub>1 = length ms\\<^sub>2\n  length ms\\<^sub>1 = length s\\<^sub>1\n  snd cfx = snd cfx'\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n     snd cf\\<^sub>2' = snd cfx'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>1'.\n       snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>\\<forall>i<length ms\\<^sub>2.\n                   snd ((cf\\<^sub>1 # cfx # cfsx) ! i) =\n                   snd ((cf\\<^sub>2 # cfx' # cfsx') ! i);\n        length ms\\<^sub>1' = Suc (length cfsx);\n        Suc (Suc (length cfsx)) = length ms\\<^sub>2;\n        length ms\\<^sub>1 = length ms\\<^sub>2; snd cfx = snd cfx';\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (a, snd cfx') # cfsx';\n        i < Suc (length cfsx)\\<rbrakk>\n       \\<Longrightarrow> snd (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx') #\n                               cfsx) !\n                              i) =\n                         snd (((a, snd cfx') # cfsx') ! i)", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i.\n       \\<lbrakk>\\<forall>i<length ms\\<^sub>2.\n                   snd ((cf\\<^sub>1 # cfx # cfsx) ! i) =\n                   snd ((cf\\<^sub>2 # cfx' # cfsx') ! i);\n        length ms\\<^sub>1' = Suc (length cfsx);\n        Suc (Suc (length cfsx)) = length ms\\<^sub>2;\n        length ms\\<^sub>1 = length ms\\<^sub>2; snd cfx = snd cfx';\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (a, snd cfx') # cfsx';\n        i < Suc (length cfsx); i = 0\\<rbrakk>\n       \\<Longrightarrow> snd (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx') #\n                               cfsx) !\n                              i) =\n                         snd (((a, snd cfx') # cfsx') ! i)\n 2. \\<And>a i nat.\n       \\<lbrakk>\\<forall>i<length ms\\<^sub>2.\n                   snd ((cf\\<^sub>1 # cfx # cfsx) ! i) =\n                   snd ((cf\\<^sub>2 # cfx' # cfsx') ! i);\n        length ms\\<^sub>1' = Suc (length cfsx);\n        Suc (Suc (length cfsx)) = length ms\\<^sub>2;\n        length ms\\<^sub>1 = length ms\\<^sub>2; snd cfx = snd cfx';\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (a, snd cfx') # cfsx';\n        i < Suc (length cfsx); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> snd (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx') #\n                               cfsx) !\n                              i) =\n                         snd (((a, snd cfx') # cfsx') ! i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nat.\n       \\<lbrakk>\\<forall>i<length ms\\<^sub>2.\n                   snd ((cf\\<^sub>1 # cfx # cfsx) ! i) =\n                   snd ((cf\\<^sub>2 # cfx' # cfsx') ! i);\n        length ms\\<^sub>1' = Suc (length cfsx);\n        Suc (Suc (length cfsx)) = length ms\\<^sub>2;\n        length ms\\<^sub>1 = length ms\\<^sub>2; snd cfx = snd cfx';\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (a, snd cfx') # cfsx';\n        nat < length cfsx\\<rbrakk>\n       \\<Longrightarrow> snd (cfsx ! nat) = snd (cfsx' ! nat)", "by(erule_tac x=\"Suc(Suc nat)\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<forall>m \\<in> set (tl (tl ms\\<^sub>1)). \n      \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>set (tl ms\\<^sub>1).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set (tl (tl ms\\<^sub>1)).\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(cases \"tl ms\\<^sub>1\") auto"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set (tl (tl ms\\<^sub>1)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "from \\<open>\\<forall>m \\<in> set (tl ms\\<^sub>1). return_node m\\<close>"], ["proof (chain)\npicking this:\n  Ball (set (tl ms\\<^sub>1)) return_node", "have \"\\<forall>m \\<in> set (tl (tl ms\\<^sub>1)). return_node m\""], ["proof (prove)\nusing this:\n  Ball (set (tl ms\\<^sub>1)) return_node\n\ngoal (1 subgoal):\n 1. Ball (set (tl (tl ms\\<^sub>1))) return_node", "by(cases \"tl ms\\<^sub>1\") auto"], ["proof (state)\nthis:\n  Ball (set (tl (tl ms\\<^sub>1))) return_node\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "have \"\\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n      (fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V = \n      state_val (transfer (slice_kind S a) s\\<^sub>2) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n       fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1))) \\<Longrightarrow>\n       fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1))) \\<Longrightarrow>\n       fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "assume \"V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1)))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1))) \\<Longrightarrow>\n       fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>hd(tl ms\\<^sub>1) = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  hd (tl ms\\<^sub>1) = targetnode a\n  V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)))", "have \"V\\<in>rv S (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  hd (tl ms\\<^sub>1) = targetnode a\n  V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)))\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (targetnode a))", "by simp"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1))) \\<Longrightarrow>\n       fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n       state_val (transfer (slice_kind S a) s\\<^sub>2) V", "show \"(fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V = \n        state_val (transfer (slice_kind S a) s\\<^sub>2) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof(cases \"V \\<in> set (ParamDefs (targetnode a))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case True"], ["proof (state)\nthis:\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "then"], ["proof (chain)\npicking this:\n  V \\<in> set (ParamDefs (targetnode a))", "obtain i where \"V = (ParamDefs (targetnode a))!i\" \n          and \"i < length(ParamDefs (targetnode a))\""], ["proof (prove)\nusing this:\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>V = ParamDefs (targetnode a) ! i;\n         i < length (ParamDefs (targetnode a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:in_set_conv_nth)"], ["proof (state)\nthis:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "moreover"], ["proof (state)\nthis:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have length:\"length(ParamDefs (targetnode a)) = length outs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (ParamDefs (targetnode a)) = length outs", "by(fastforce intro:ParamDefs_return_target_length)"], ["proof (state)\nthis:\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>\n          \\<open>i < length(ParamDefs (targetnode a))\\<close> \n          \\<open>length(ParamDefs (targetnode a)) = length outs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs", "have \"valid_SDG_node (Actual_out(targetnode a,i))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. valid_SDG_node (Actual_out (targetnode a, i))", "by fastforce"], ["proof (state)\nthis:\n  valid_SDG_node (Actual_out (targetnode a, i))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V = (ParamDefs (targetnode a))!i\\<close>"], ["proof (chain)\npicking this:\n  V = ParamDefs (targetnode a) ! i\n  valid_SDG_node (Actual_out (targetnode a, i))", "have \"V \\<in> Def\\<^bsub>SDG\\<^esub> (Actual_out(targetnode a,i))\""], ["proof (prove)\nusing this:\n  V = ParamDefs (targetnode a) ! i\n  valid_SDG_node (Actual_out (targetnode a, i))\n\ngoal (1 subgoal):\n 1. V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i)", "by(fastforce intro:Actual_out_SDG_Def)"], ["proof (state)\nthis:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))", "obtain as' nx \n          where \"targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\" \n          and \"nx \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> nx\"\n          and \"\\<forall>n''. valid_SDG_node n'' \\<and> \n                         parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>as' nx.\n        \\<lbrakk>targetnode\n                  a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx;\n         nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_SDG_node (Actual_out(targetnode a,i))\\<close>\n          \\<open>V \\<in> Def\\<^bsub>SDG\\<^esub> (Actual_out(targetnode a,i))\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (Actual_out (targetnode a, i))\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i)\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"targetnode a = parent_node nx\""], ["proof (prove)\nusing this:\n  valid_SDG_node (Actual_out (targetnode a, i))\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i)\n  targetnode a -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n  nx \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as') \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. targetnode a = parent_node nx", "apply(auto simp:intra_path_def sourcenodes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Q p f ins outs.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        targetnode a -as'\\<rightarrow>* parent_node nx;\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = targetnode a; (p, ins, outs) \\<in> set procs;\n        i < length outs\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "apply(erule path.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a Q p f ins outs n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = targetnode a; (p, ins, outs) \\<in> set procs;\n        i < length outs; targetnode a = n; as' = []; parent_node nx = n;\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx\n 2. \\<And>a Q p f ins outs n'' as n' aaa n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = targetnode a; (p, ins, outs) \\<in> set procs;\n        i < length outs; targetnode a = n; as' = aaa # as;\n        parent_node nx = n'; n'' -as\\<rightarrow>* n'; valid_edge aaa;\n        sourcenode aaa = n; targetnode aaa = n''\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Q p f ins outs n'' as n' aaa n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>n''.\n           valid_SDG_node n'' \\<and>\n           parent_node n'' \\<in> sourcenode ` set as' \\<longrightarrow>\n           V \\<notin> Def\\<^bsub>SDG\\<^esub> n'';\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = targetnode a; (p, ins, outs) \\<in> set procs;\n        i < length outs; targetnode a = n; as' = aaa # as;\n        parent_node nx = n'; n'' -as\\<rightarrow>* n'; valid_edge aaa;\n        sourcenode aaa = n; targetnode aaa = n''\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "apply(erule_tac x=\"(Actual_out(targetnode a,i))\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a Q p f ins outs n'' as n' aaa n.\n       \\<lbrakk>V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i);\n        nx \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> nx;\n        \\<forall>a\\<in>set as'. intra_kind (kind a); valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        targetnode a = targetnode a; (p, ins, outs) \\<in> set procs;\n        i < length outs; targetnode a = n; as' = aaa # as;\n        parent_node nx = n'; n'' -as\\<rightarrow>* n'; valid_edge aaa;\n        sourcenode aaa = n; targetnode aaa = n'';\n        valid_SDG_node (Actual_out (targetnode a, i)) \\<and>\n        parent_node (Actual_out (targetnode a, i))\n        \\<in> sourcenode ` set as' \\<longrightarrow>\n        V \\<notin> Def\\<^bsub>SDG\\<^esub> Actual_out\n     (targetnode a, i)\\<rbrakk>\n       \\<Longrightarrow> targetnode a = parent_node nx", "by fastforce"], ["proof (state)\nthis:\n  targetnode a = parent_node nx\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> nx\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  targetnode a = parent_node nx", "have \"V \\<in> Use (targetnode a)\""], ["proof (prove)\nusing this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> nx\n  targetnode a = parent_node nx\n\ngoal (1 subgoal):\n 1. V \\<in> Use (targetnode a)", "by(fastforce intro:SDG_Use_parent_Use)"], ["proof (state)\nthis:\n  V \\<in> Use (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<in> Use (targetnode a)", "have \"V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<in> Use (targetnode a)\n\ngoal (1 subgoal):\n 1. V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)", "by(auto intro!:CFG_Use_SDG_Use)"], ["proof (state)\nthis:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>targetnode a = parent_node nx\\<close>[THEN sym] \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  parent_node nx = targetnode a\n  valid_edge a", "have \"parent_node (Actual_out(targetnode a,i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\""], ["proof (prove)\nusing this:\n  parent_node nx = targetnode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. parent_node\n     (Actual_out\n       (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (Actual_out\n     (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V \\<in> Def\\<^bsub>SDG\\<^esub> (Actual_out(targetnode a,i))\\<close> \n          \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (targetnode a))\\<close> \\<open>targetnode a = parent_node nx\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i)\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n  targetnode a = parent_node nx\n  parent_node\n   (Actual_out\n     (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx", "have \"Actual_out(targetnode a,i) influences V in (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  V \\<in> Def\\<^bsub>SDG\\<^esub> Actual_out (targetnode a, i)\n  V \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (targetnode a)\n  targetnode a = parent_node nx\n  parent_node\n   (Actual_out\n     (targetnode a, i)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node nx\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) influences V in CFG_node (targetnode a)", "by(fastforce simp:data_dependence_def sourcenodes_def)"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) influences V in CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence ddep:\"Actual_out(targetnode a,i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d (CFG_node (targetnode a))\""], ["proof (prove)\nusing this:\n  Actual_out (targetnode a, i) influences V in CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. Actual_out\n     (targetnode a,\n      i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)", "by(rule sum_SDG_ddep_edge)"], ["proof (state)\nthis:\n  Actual_out\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>targetnode a = parent_node nx\\<close> \\<open>nx \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = parent_node nx\n  nx \\<in> HRB_slice S", "have \"CFG_node (targetnode a) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  targetnode a = parent_node nx\n  nx \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (targetnode a) \\<in> HRB_slice S", "by(fastforce dest:valid_SDG_node_in_slice_parent_node_in_slice)"], ["proof (state)\nthis:\n  CFG_node (targetnode a) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence \"Actual_out(targetnode a,i) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S", "proof(induct \"CFG_node (targetnode a)\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S", "case (phase1 nx')"], ["proof (state)\nthis:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S", "with ddep"], ["proof (chain)\npicking this:\n  Actual_out\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  Actual_out\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n  CFG_node (targetnode a) \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S", "by(fastforce intro: ddep_slice1 combine_SDG_slices.combSlice_refl\n                         simp:HRB_slice_def)"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S", "case (phase2 nx' n' n'' p)"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\n  nx' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S", "from \\<open>CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\\<close> ddep"], ["proof (chain)\npicking this:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\n  Actual_out\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)", "have \"Actual_out(targetnode a,i) \\<in> sum_SDG_slice2 n'\""], ["proof (prove)\nusing this:\n  CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'\n  Actual_out\n   (targetnode a,\n    i) s-V\\<rightarrow>\\<^sub>d\\<^sub>d CFG_node (targetnode a)\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'", "by(fastforce intro:ddep_slice2)"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        CFG_node (targetnode a) \\<in> sum_SDG_slice2 n'; nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Actual_out (targetnode a, i) \\<in> HRB_slice S", "with \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close> \\<open>n' \\<in> sum_SDG_slice1 nx'\\<close>\n            \\<open>nx' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n' \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'", "show ?case"], ["proof (prove)\nusing this:\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  n' \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_Return_parent_node\n                                  simp:HRB_slice_def)"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>valid_edge a''\\<close>\n          \\<open>kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\\<close> \\<open>a \\<in> get_return_edges a''\\<close>\n          \\<open>CFG_node (targetnode a) \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a''\n  CFG_node (targetnode a) \\<in> HRB_slice S", "have \"CFG_node (sourcenode a) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  valid_edge a''\n  kind a'' = Q':r'\\<hookrightarrow>\\<^bsub>p\\<^esub>fs'\n  a \\<in> get_return_edges a''\n  CFG_node (targetnode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. CFG_node (sourcenode a) \\<in> HRB_slice S", "by(rule call_return_nodes_in_slice)"], ["proof (state)\nthis:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "hence \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  CFG_node (sourcenode a) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by(simp add:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n          \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have slice_kind:\"slice_kind S a = \n          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. rspp (targetnode a) (HRB_slice S) outs cf' cf)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n   rspp (targetnode a) (HRB_slice S) outs cf' cf", "by(rule slice_kind_Return_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>Actual_out(targetnode a,i) \\<in> HRB_slice S\\<close>\n          \\<open>i < length(ParamDefs (targetnode a))\\<close> \\<open>valid_edge a\\<close>\n          \\<open>V = (ParamDefs (targetnode a))!i\\<close> length"], ["proof (chain)\npicking this:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n  i < length (ParamDefs (targetnode a))\n  valid_edge a\n  V = ParamDefs (targetnode a) ! i\n  length (ParamDefs (targetnode a)) = length outs", "have 2:\"rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V = \n          (fst cf\\<^sub>2)(outs!i)\""], ["proof (prove)\nusing this:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n  i < length (ParamDefs (targetnode a))\n  valid_edge a\n  V = ParamDefs (targetnode a) ! i\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V =\n    fst cf\\<^sub>2 (outs ! i)", "by(fastforce intro:rspp_Actual_out_in_slice)"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V =\n  fst cf\\<^sub>2 (outs ! i)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>i < length(ParamDefs (targetnode a))\\<close> length \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  valid_edge a", "have \"(fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) \n          ((ParamDefs (targetnode a))!i) = (map (fst cf\\<^sub>1) outs)!i\""], ["proof (prove)\nusing this:\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  valid_edge a\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n     (ParamDefs (targetnode a) ! i) =\n    map (fst cf\\<^sub>1) outs ! i", "by(fastforce intro:fun_upds_nth distinct_ParamDefs)"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf\\<^sub>1) outs ! i\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V = (ParamDefs (targetnode a))!i\\<close> \n          \\<open>i < length(ParamDefs (targetnode a))\\<close> length"], ["proof (chain)\npicking this:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf\\<^sub>1) outs ! i", "have 1:\"(fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V = \n          (fst cf\\<^sub>1)(outs!i)\""], ["proof (prove)\nusing this:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n   (ParamDefs (targetnode a) ! i) =\n  map (fst cf\\<^sub>1) outs ! i\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    fst cf\\<^sub>1 (outs ! i)", "by simp"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  fst cf\\<^sub>1 (outs ! i)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> \n          \\<open>i < length(ParamDefs (targetnode a))\\<close> length"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs", "have po:\"Formal_out(sourcenode a,i) s-p:outs!i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out(targetnode a,i)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. Formal_out\n     (sourcenode a,\n      i) s-p:outs !\n             i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out (targetnode a, i)", "by(fastforce intro:sum_SDG_param_out_edge)"], ["proof (state)\nthis:\n  Formal_out\n   (sourcenode a,\n    i) s-p:outs !\n           i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out (targetnode a, i)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. CFG_node\n     (sourcenode\n       a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)", "by(fastforce intro:sum_SDG_return_edge)"], ["proof (state)\nthis:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>Actual_out(targetnode a,i) \\<in> HRB_slice S\\<close>"], ["proof (chain)\npicking this:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S", "have \"Formal_out(sourcenode a,i) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. Formal_out (sourcenode a, i) \\<in> HRB_slice S", "proof(induct \"Actual_out(targetnode a,i)\" rule:HRB_slice_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "case (phase1 nx')"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "let ?AO = \"Actual_out(targetnode a,i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "from \\<open>valid_SDG_node ?AO\\<close>"], ["proof (chain)\npicking this:\n  valid_SDG_node (Actual_out (targetnode a, i))", "have \"?AO \\<in> sum_SDG_slice2 ?AO\""], ["proof (prove)\nusing this:\n  valid_SDG_node (Actual_out (targetnode a, i))\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i)\n    \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))", "by(rule refl_slice2)"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i)\n  \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "with po"], ["proof (chain)\npicking this:\n  Formal_out\n   (sourcenode a,\n    i) s-p:outs !\n           i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out (targetnode a, i)\n  Actual_out (targetnode a, i)\n  \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))", "have \"Formal_out(sourcenode a,i) \\<in> sum_SDG_slice2 ?AO\""], ["proof (prove)\nusing this:\n  Formal_out\n   (sourcenode a,\n    i) s-p:outs !\n           i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out (targetnode a, i)\n  Actual_out (targetnode a, i)\n  \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))\n\ngoal (1 subgoal):\n 1. Formal_out (sourcenode a, i)\n    \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))", "by(rule param_out_slice2)"], ["proof (state)\nthis:\n  Formal_out (sourcenode a, i)\n  \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))\n\ngoal (2 subgoals):\n 1. \\<And>nx.\n       \\<lbrakk>Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx;\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S\n 2. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "with \\<open>CFG_node (sourcenode a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\\<close>\n            \\<open>Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx'\\<close> \\<open>nx' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  Formal_out (sourcenode a, i)\n  \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))", "show ?case"], ["proof (prove)\nusing this:\n  CFG_node\n   (sourcenode\n     a) s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (targetnode a)\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice1 nx'\n  nx' \\<in> S\n  Formal_out (sourcenode a, i)\n  \\<in> sum_SDG_slice2 (Actual_out (targetnode a, i))\n\ngoal (1 subgoal):\n 1. Formal_out (sourcenode a, i) \\<in> HRB_slice S", "by(fastforce intro:combSlice_Return_parent_node simp:HRB_slice_def)"], ["proof (state)\nthis:\n  Formal_out (sourcenode a, i) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "case (phase2 nx' n' n'' p)"], ["proof (state)\nthis:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'\n  nx' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "from \\<open>Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'\\<close> po"], ["proof (chain)\npicking this:\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'\n  Formal_out\n   (sourcenode a,\n    i) s-p__:outs !\n             i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out (targetnode a, i)", "have \"Formal_out(sourcenode a,i) \\<in> sum_SDG_slice2 n'\""], ["proof (prove)\nusing this:\n  Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n'\n  Formal_out\n   (sourcenode a,\n    i) s-p__:outs !\n             i\\<rightarrow>\\<^bsub>out\\<^esub> Actual_out (targetnode a, i)\n\ngoal (1 subgoal):\n 1. Formal_out (sourcenode a, i) \\<in> sum_SDG_slice2 n'", "by(fastforce intro:param_out_slice2)"], ["proof (state)\nthis:\n  Formal_out (sourcenode a, i) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. \\<And>nx n' n'' p.\n       \\<lbrakk>n' \\<in> sum_SDG_slice1 nx;\n        n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n');\n        Actual_out (targetnode a, i) \\<in> sum_SDG_slice2 n';\n        nx \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Formal_out (sourcenode a, i) \\<in> HRB_slice S", "with \\<open>n' \\<in> sum_SDG_slice1 nx'\\<close> \\<open>n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\\<close> \n            \\<open>nx' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  nx' \\<in> S\n  Formal_out (sourcenode a, i) \\<in> sum_SDG_slice2 n'", "show ?case"], ["proof (prove)\nusing this:\n  n' \\<in> sum_SDG_slice1 nx'\n  n'' s-p\\<rightarrow>\\<^bsub>ret\\<^esub> CFG_node (parent_node n')\n  nx' \\<in> S\n  Formal_out (sourcenode a, i) \\<in> sum_SDG_slice2 n'\n\ngoal (1 subgoal):\n 1. Formal_out (sourcenode a, i) \\<in> HRB_slice S", "by(fastforce intro:combine_SDG_slices.combSlice_Return_parent_node\n                                  simp:HRB_slice_def)"], ["proof (state)\nthis:\n  Formal_out (sourcenode a, i) \\<in> HRB_slice S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Formal_out (sourcenode a, i) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close> \n          \\<open>i < length(ParamDefs (targetnode a))\\<close> length"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  Formal_out (sourcenode a, i) \\<in> HRB_slice S", "have \"outs!i \\<in> Use\\<^bsub>SDG\\<^esub> Formal_out(sourcenode a,i)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  Formal_out (sourcenode a, i) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> Formal_out (sourcenode a, i)", "by(fastforce intro!:Formal_out_SDG_Use get_proc_return)"], ["proof (state)\nthis:\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> Formal_out (sourcenode a, i)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> Formal_out (sourcenode a, i)", "have \"outs!i \\<in> Use\\<^bsub>SDG\\<^esub> (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> Formal_out (sourcenode a, i)\n\ngoal (1 subgoal):\n 1. outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)", "by(auto intro!:CFG_Use_SDG_Use dest:SDG_Use_parent_Use)"], ["proof (state)\nthis:\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "moreover"], ["proof (state)\nthis:\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"parent_node (CFG_node (sourcenode a)) -[]\\<rightarrow>\\<^sub>\\<iota>* \n          parent_node (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. parent_node\n     (CFG_node\n       (sourcenode\n         a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n        (CFG_node (sourcenode a))", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "ultimately"], ["proof (chain)\npicking this:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))", "have \"outs!i \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. outs ! i \\<in> rv S (CFG_node (sourcenode a))", "using \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  V = ParamDefs (targetnode a) ! i\n  i < length (ParamDefs (targetnode a))\n  outs ! i \\<in> Use\\<^bsub>SDG\\<^esub> CFG_node (sourcenode a)\n  parent_node\n   (CFG_node\n     (sourcenode\n       a)) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node\n      (CFG_node (sourcenode a))\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n\ngoal (1 subgoal):\n 1. outs ! i \\<in> rv S (CFG_node (sourcenode a))", "by(fastforce intro:rvI simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  outs ! i \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n          (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  outs ! i \\<in> rv S (CFG_node (sourcenode a))", "have \"(fst cf\\<^sub>1)(outs!i) = (fst cf\\<^sub>2)(outs!i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  outs ! i \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. fst cf\\<^sub>1 (outs ! i) = fst cf\\<^sub>2 (outs ! i)", "by auto(erule_tac x=\"0\" in allE,auto)"], ["proof (state)\nthis:\n  fst cf\\<^sub>1 (outs ! i) = fst cf\\<^sub>2 (outs ! i)\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with 1 2 slice_kind"], ["proof (chain)\npicking this:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  fst cf\\<^sub>1 (outs ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V =\n  fst cf\\<^sub>2 (outs ! i)\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n  fst cf\\<^sub>1 (outs ! i) = fst cf\\<^sub>2 (outs ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  fst cf\\<^sub>1 (outs ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V =\n  fst cf\\<^sub>2 (outs ! i)\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n  fst cf\\<^sub>1 (outs ! i) = fst cf\\<^sub>2 (outs ! i)\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by simp"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case False"], ["proof (state)\nthis:\n  V \\<notin> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  V \\<notin> set (ParamDefs (targetnode a))", "have \"(fst cfx)(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) =\n          (fst (hd cfs\\<^sub>1))(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  V \\<notin> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) =\n    state_val cfs\\<^sub>1(ParamDefs (targetnode a) [:=]\n    map (fst cf\\<^sub>1) outs)", "by(cases cfs\\<^sub>1,auto intro:CFG_return_edge_fun)"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) =\n  state_val cfs\\<^sub>1(ParamDefs (targetnode a) [:=]\n  map (fst cf\\<^sub>1) outs)\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>\n            \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have \"slice_kind S a = \n            Q\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. rspp (targetnode a) (HRB_slice S) outs cf' cf)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n   rspp (targetnode a) (HRB_slice S) outs cf' cf", "by(rule slice_kind_Return_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\\<close> \n            \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length s\\<^sub>1 = length s\\<^sub>2\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf", "have \"state_val (transfer (slice_kind S a) s\\<^sub>2) V = \n            rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V\""], ["proof (prove)\nusing this:\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length s\\<^sub>1 = length s\\<^sub>2\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>V \\<notin> set (ParamDefs (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> set (ParamDefs (targetnode a))\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V", "have \"state_val (transfer (slice_kind S a) s\\<^sub>2) V = state_val cfs\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  V \\<notin> set (ParamDefs (targetnode a))\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n    state_val cfs\\<^sub>2 V", "by(fastforce simp:rspp_def map_merge_def)"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  state_val cfs\\<^sub>2 V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n            (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close>\n            \\<open>hd(tl ms\\<^sub>1) = targetnode a\\<close>\n            \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>[THEN sym] False\n            \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>\n            \\<open>V\\<in>rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  hd (tl ms\\<^sub>1) = targetnode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>2 = length s\\<^sub>1\n  V \\<notin> set (ParamDefs (targetnode a))\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  V \\<in> rv S (CFG_node (targetnode a))\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  state_val cfs\\<^sub>2 V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  hd (tl ms\\<^sub>1) = targetnode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>2 = length s\\<^sub>1\n  V \\<notin> set (ParamDefs (targetnode a))\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  V \\<in> rv S (CFG_node (targetnode a))\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V =\n  state_val cfs\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by(fastforce simp:length_Suc_conv fun_upds_notin)"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"slice_kind S a = (\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'", "by(rule slice_kind_Return)"], ["proof (state)\nthis:\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "from \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  length ms\\<^sub>2 = length s\\<^sub>2", "have \"1 < length ms\\<^sub>2\""], ["proof (prove)\nusing this:\n  length ms\\<^sub>2 = length s\\<^sub>2\n\ngoal (1 subgoal):\n 1. 1 < length ms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  1 < length ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n            (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close>\n            \\<open>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1)))\\<close>\n            \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close> \\<open>ms\\<^sub>1' = []@hd ms\\<^sub>1'#tl ms\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)))\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  ms\\<^sub>1' = [] @ hd ms\\<^sub>1' # tl ms\\<^sub>1'\n  1 < length ms\\<^sub>2", "have \"fst cfx V = fst cfx' V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)))\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  ms\\<^sub>1' = [] @ hd ms\\<^sub>1' # tl ms\\<^sub>1'\n  1 < length ms\\<^sub>2\n\ngoal (1 subgoal):\n 1. fst cfx V = fst cfx' V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<length ms\\<^sub>2.\n                \\<forall>V\\<in>rv S\n                                (CFG_node\n                                  ((sourcenode a # tl ms\\<^sub>1) ! i)).\n                   fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n                   fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n     V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)));\n     ms\\<^sub>1' = tl ms\\<^sub>1;\n     tl ms\\<^sub>1 = hd (tl ms\\<^sub>1) # tl (tl ms\\<^sub>1);\n     Suc 0 < length ms\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> fst cfx V = fst cfx' V", "apply(erule_tac x=\"1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<in> rv S (CFG_node (hd (tl ms\\<^sub>1)));\n     ms\\<^sub>1' = tl ms\\<^sub>1;\n     tl ms\\<^sub>1 = hd (tl ms\\<^sub>1) # tl (tl ms\\<^sub>1);\n     Suc 0 < length ms\\<^sub>2;\n     1 < length ms\\<^sub>2 \\<longrightarrow>\n     (\\<forall>V\\<in>rv S (CFG_node ((sourcenode a # tl ms\\<^sub>1) ! 1)).\n         fst ((cf\\<^sub>1 # cfx # cfsx) ! 1) V =\n         fst ((cf\\<^sub>2 # cfx' # cfsx') ! 1) V)\\<rbrakk>\n    \\<Longrightarrow> fst cfx V = fst cfx' V", "by(cases \"tl ms\\<^sub>1\") auto"], ["proof (state)\nthis:\n  fst cfx V = fst cfx' V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "with \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n            (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \n            \\<open>hd(tl ms\\<^sub>1) = targetnode a\\<close>\n            \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close>[THEN sym] False\n            \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close>\n            \\<open>V\\<in>rv S (CFG_node (targetnode a))\\<close>\n            \\<open>V \\<notin> set (ParamDefs (targetnode a))\\<close>\n            \\<open>slice_kind S a = (\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  hd (tl ms\\<^sub>1) = targetnode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>2 = length s\\<^sub>1\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  V \\<in> rv S (CFG_node (targetnode a))\n  V \\<notin> set (ParamDefs (targetnode a))\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n  fst cfx V = fst cfx' V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  hd (tl ms\\<^sub>1) = targetnode a\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length s\\<^sub>2 = length s\\<^sub>1\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  V \\<in> rv S (CFG_node (targetnode a))\n  V \\<notin> set (ParamDefs (targetnode a))\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n  fst cfx V = fst cfx' V\n\ngoal (1 subgoal):\n 1. fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n    state_val (transfer (slice_kind S a) s\\<^sub>2) V", "by(auto simp:fun_upds_notin)"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n  state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n     fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n     state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>hd(tl ms\\<^sub>1) = targetnode a\\<close> \\<open>tl ms\\<^sub>2 = tl ms\\<^sub>1\\<close> \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close>\n      \\<open>\\<forall>i < length ms\\<^sub>2. \\<forall>V \\<in> rv S (CFG_node ((mx#tl ms\\<^sub>2)!i)). \n        (fst (s\\<^sub>1!(length msx + i))) V = (fst (s\\<^sub>2!i)) V\\<close> \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close>\n      \\<open>length ms\\<^sub>1 = length s\\<^sub>1\\<close> \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>length s\\<^sub>1 = length s\\<^sub>2\\<close> cf2'"], ["proof (chain)\npicking this:\n  hd (tl ms\\<^sub>1) = targetnode a\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1 = length s\\<^sub>2\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n     snd cf\\<^sub>2' = snd cfx'\n  \\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n     fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n     state_val (transfer (slice_kind S a) s\\<^sub>2) V", "have \"\\<forall>i<length ms\\<^sub>1'. \\<forall>V\\<in>rv S (CFG_node ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1')!i)).\n      (fst (s\\<^sub>1'!(length [] + i))) V = (fst (transfer (slice_kind S a) s\\<^sub>2!i)) V\""], ["proof (prove)\nusing this:\n  hd (tl ms\\<^sub>1) = targetnode a\n  tl ms\\<^sub>2 = tl ms\\<^sub>1\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  \\<forall>i<length ms\\<^sub>2.\n     \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n        fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  length ms\\<^sub>1 = length s\\<^sub>1\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1 = length s\\<^sub>2\n  \\<exists>cf\\<^sub>2'.\n     transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n     snd cf\\<^sub>2' = snd cfx'\n  \\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n     fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n     state_val (transfer (slice_kind S a) s\\<^sub>2) V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ms\\<^sub>1'.\n       \\<forall>V\\<in>rv S\n                       (CFG_node\n                         ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1') ! i)).\n          fst (s\\<^sub>1' ! (length [] + i)) V =\n          fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V", "apply(case_tac \"tl ms\\<^sub>1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hd (tl ms\\<^sub>1) = targetnode a;\n     tl ms\\<^sub>2 = tl ms\\<^sub>1; ms\\<^sub>1' = tl ms\\<^sub>1;\n     \\<forall>i<length ms\\<^sub>2.\n        \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n           fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n     length ms\\<^sub>1' = length s\\<^sub>1';\n     length ms\\<^sub>1 = length s\\<^sub>1;\n     length ms\\<^sub>2 = length s\\<^sub>2;\n     length s\\<^sub>1 = length s\\<^sub>2;\n     \\<exists>cf\\<^sub>2'.\n        transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n        snd cf\\<^sub>2' = snd cfx';\n     \\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n        fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs) V =\n        state_val (transfer (slice_kind S a) s\\<^sub>2) V;\n     tl ms\\<^sub>1 = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length ms\\<^sub>1'.\n                         \\<forall>V\\<in>rv S\n   (CFG_node ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1') ! i)).\n                            fst (s\\<^sub>1' ! (length [] + i)) V =\n                            fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n 2. \\<And>a list.\n       \\<lbrakk>hd (tl ms\\<^sub>1) = targetnode a;\n        tl ms\\<^sub>2 = tl ms\\<^sub>1; ms\\<^sub>1' = tl ms\\<^sub>1;\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s\\<^sub>1 ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        length ms\\<^sub>1' = length s\\<^sub>1';\n        length ms\\<^sub>1 = length s\\<^sub>1;\n        length ms\\<^sub>2 = length s\\<^sub>2;\n        length s\\<^sub>1 = length s\\<^sub>2;\n        \\<exists>cf\\<^sub>2'.\n           transfer (slice_kind S a) s\\<^sub>2 = cf\\<^sub>2' # cfsx' \\<and>\n           snd cf\\<^sub>2' = snd cfx';\n        \\<forall>V\\<in>rv S (CFG_node (hd (tl ms\\<^sub>1))).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           state_val (transfer (slice_kind S a) s\\<^sub>2) V;\n        tl ms\\<^sub>1 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length ms\\<^sub>1'.\n                            \\<forall>V\\<in>rv S\n      (CFG_node ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1') ! i)).\n                               fst (s\\<^sub>1' ! (length [] + i)) V =\n                               fst (transfer (slice_kind S a) s\\<^sub>2 ! i)\n                                V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aaa i V.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length ms\\<^sub>2 = Suc (Suc (length cfsx'));\n        length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        i < Suc (length cfsx');\n        V \\<in> rv S (CFG_node ((targetnode a # list) ! i))\\<rbrakk>\n       \\<Longrightarrow> fst (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx) #\n                               cfsx) !\n                              i)\n                          V =\n                         fst (((aaa, snd cfx') # cfsx') ! i) V", "apply(cases ms\\<^sub>2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aaa i V.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length ms\\<^sub>2 = Suc (Suc (length cfsx'));\n        length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        i < Suc (length cfsx');\n        V \\<in> rv S (CFG_node ((targetnode a # list) ! i));\n        ms\\<^sub>2 = []\\<rbrakk>\n       \\<Longrightarrow> fst (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx) #\n                               cfsx) !\n                              i)\n                          V =\n                         fst (((aaa, snd cfx') # cfsx') ! i) V\n 2. \\<And>list aaa i V a lista.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length ms\\<^sub>2 = Suc (Suc (length cfsx'));\n        length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        i < Suc (length cfsx');\n        V \\<in> rv S (CFG_node ((targetnode a # list) ! i));\n        ms\\<^sub>2 = a # lista\\<rbrakk>\n       \\<Longrightarrow> fst (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx) #\n                               cfsx) !\n                              i)\n                          V =\n                         fst (((aaa, snd cfx') # cfsx') ! i) V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aaa i V a lista.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length lista = Suc (length cfsx'); length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        i < Suc (length cfsx');\n        V \\<in> rv S (CFG_node ((targetnode a # list) ! i));\n        ms\\<^sub>2 = a # lista\\<rbrakk>\n       \\<Longrightarrow> fst (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx) #\n                               cfsx) !\n                              i)\n                          V =\n                         fst (((aaa, snd cfx') # cfsx') ! i) V", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list aaa i V a lista.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length lista = Suc (length cfsx'); length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        i < Suc (length cfsx');\n        V \\<in> rv S (CFG_node ((targetnode a # list) ! i));\n        ms\\<^sub>2 = a # lista; i = 0\\<rbrakk>\n       \\<Longrightarrow> fst (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx) #\n                               cfsx) !\n                              i)\n                          V =\n                         fst (((aaa, snd cfx') # cfsx') ! i) V\n 2. \\<And>list aaa i V a lista nat.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length lista = Suc (length cfsx'); length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        i < Suc (length cfsx');\n        V \\<in> rv S (CFG_node ((targetnode a # list) ! i));\n        ms\\<^sub>2 = a # lista; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fst (((fst cfx(ParamDefs (targetnode a) [:=]\n                                map (fst cf\\<^sub>1) outs), snd cfx) #\n                               cfsx) !\n                              i)\n                          V =\n                         fst (((aaa, snd cfx') # cfsx') ! i) V", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list aaa V a lista nat.\n       \\<lbrakk>ms\\<^sub>1' = targetnode a # list;\n        \\<forall>i<Suc (Suc (length cfsx')).\n           \\<forall>V\\<in>rv S\n                           (CFG_node\n                             ((sourcenode a # targetnode a # list) ! i)).\n              fst ((cf\\<^sub>1 # cfx # cfsx) ! i) V =\n              fst ((cf\\<^sub>2 # cfx' # cfsx') ! i) V;\n        length list = length cfsx';\n        length ms\\<^sub>1 = Suc (Suc (length cfsx'));\n        length lista = Suc (length cfsx'); length cfsx = length cfsx';\n        \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n           fst cfx(ParamDefs (targetnode a) [:=] map (fst cf\\<^sub>1) outs)\n            V =\n           aaa V;\n        tl ms\\<^sub>1 = targetnode a # list;\n        transfer (slice_kind S a) (cf\\<^sub>2 # cfx' # cfsx') =\n        (aaa, snd cfx') # cfsx';\n        nat < length cfsx'; V \\<in> rv S (CFG_node (list ! nat));\n        ms\\<^sub>2 = a # lista\\<rbrakk>\n       \\<Longrightarrow> fst (cfsx ! nat) V = fst (cfsx' ! nat) V", "by(erule_tac x=\"Suc(Suc nat)\" in allE,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S\n                     (CFG_node ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>m \\<in> set ms\\<^sub>2. valid_node m\\<close> \\<open>\\<forall>m \\<in> set ms\\<^sub>1'. valid_node m\\<close> \n      \\<open>length ms\\<^sub>2 = length s\\<^sub>2\\<close> \\<open>length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\\<close>\n      \\<open>length ms\\<^sub>1' = length s\\<^sub>1'\\<close> \\<open>ms\\<^sub>1' = tl ms\\<^sub>1\\<close> \\<open>ms\\<^sub>1' = []@hd ms\\<^sub>1'#tl ms\\<^sub>1'\\<close>\n      \\<open>tl ms\\<^sub>1 = []@hd(tl ms\\<^sub>1)#tl(tl ms\\<^sub>1)\\<close>\n      \\<open>get_proc mx = get_proc (hd ms\\<^sub>2)\\<close>\n      \\<open>\\<forall>m \\<in> set (tl (tl ms\\<^sub>1)). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n      \\<open>\\<forall>m \\<in> set (tl (tl ms\\<^sub>1)). return_node m\\<close>\n      \\<open>\\<forall>i<length ms\\<^sub>1'. snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\\<close>"], ["proof (chain)\npicking this:\n  Ball (set ms\\<^sub>2) valid_node\n  Ball (set ms\\<^sub>1') valid_node\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  ms\\<^sub>1' = [] @ hd ms\\<^sub>1' # tl ms\\<^sub>1'\n  tl ms\\<^sub>1 = [] @ hd (tl ms\\<^sub>1) # tl (tl ms\\<^sub>1)\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl (tl ms\\<^sub>1)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (tl ms\\<^sub>1))) return_node\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S\n                     (CFG_node ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V", "have \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  Ball (set ms\\<^sub>2) valid_node\n  Ball (set ms\\<^sub>1') valid_node\n  length ms\\<^sub>2 = length s\\<^sub>2\n  length s\\<^sub>1' = length (transfer (slice_kind S a) s\\<^sub>2)\n  length ms\\<^sub>1' = length s\\<^sub>1'\n  ms\\<^sub>1' = tl ms\\<^sub>1\n  ms\\<^sub>1' = [] @ hd ms\\<^sub>1' # tl ms\\<^sub>1'\n  tl ms\\<^sub>1 = [] @ hd (tl ms\\<^sub>1) # tl (tl ms\\<^sub>1)\n  get_proc mx = get_proc (hd ms\\<^sub>2)\n  \\<forall>m\\<in>set (tl (tl ms\\<^sub>1)).\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl (tl ms\\<^sub>1))) return_node\n  \\<forall>i<length ms\\<^sub>1'.\n     snd (s\\<^sub>1' ! i) = snd (transfer (slice_kind S a) s\\<^sub>2 ! i)\n  \\<forall>i<length ms\\<^sub>1'.\n     \\<forall>V\\<in>rv S\n                     (CFG_node ((hd (tl ms\\<^sub>1) # tl ms\\<^sub>1') ! i)).\n        fst (s\\<^sub>1' ! (length [] + i)) V =\n        fst (transfer (slice_kind S a) s\\<^sub>2 ! i) V\n\ngoal (1 subgoal):\n 1. ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n     transfer (slice_kind S a) s\\<^sub>2)\n    \\<in> WS S", "by(auto intro!:WSI)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>a s s' Q p f' ms S ms'.\n       \\<lbrakk>pred (kind a) s; transfer (kind a) s = s'; valid_edge a;\n        kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        \\<forall>m\\<in>set (tl ms).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        length ms = length s; length s = Suc (length s'); s' \\<noteq> [];\n        hd ms = sourcenode a; hd (tl ms) = targetnode a; ms' = tl ms;\n        Ball (set ms) valid_node; Ball (set ms\\<^sub>2) valid_node;\n        length ms = length s; length ms\\<^sub>2 = length s\\<^sub>2;\n        s \\<noteq> []; s\\<^sub>2 \\<noteq> []; ms = msx @ mx # tl ms\\<^sub>2;\n        get_proc mx = get_proc (hd ms\\<^sub>2);\n        \\<forall>m\\<in>set (tl ms\\<^sub>2).\n           \\<exists>m'.\n              call_of_return_node m m' \\<and>\n              m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        msx \\<noteq> [] \\<longrightarrow>\n        (\\<exists>mx'.\n            call_of_return_node mx mx' \\<and>\n            mx' \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>);\n        Ball (set (tl ms)) return_node;\n        \\<forall>i<length ms\\<^sub>2.\n           snd (s ! (length msx + i)) = snd (s\\<^sub>2 ! i);\n        \\<forall>i<length ms\\<^sub>2.\n           \\<forall>V\\<in>rv S (CFG_node ((mx # tl ms\\<^sub>2) ! i)).\n              fst (s ! (length msx + i)) V = fst (s\\<^sub>2 ! i) V;\n        obs ms \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> =\n        obs ms\\<^sub>2\n         \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            ((ms', s'), ms',\n                             transfer (slice_kind S a) s\\<^sub>2)\n                            \\<in> WS S \\<and>\n                            S,slice_kind\n                               S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n                                [a]\\<Rightarrow> (ms',transfer\n                 (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S", "show ?case"], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n      [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a) s\\<^sub>2)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n           [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n      transfer (slice_kind S a) s\\<^sub>2)\n     \\<in> WS S \\<and>\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n         [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n      transfer (slice_kind S a) s\\<^sub>2)\n     \\<in> WS S \\<and>\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as @\n         [a]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The weak simulation\\<close>"], ["", "definition is_weak_sim :: \n  \"(('node list \\<times> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list) \\<times> \n  ('node list \\<times> (('var \\<rightharpoonup> 'val) \\<times> 'ret) list)) set \\<Rightarrow> 'node SDG_node set \\<Rightarrow> bool\"\n  where \"is_weak_sim R S \\<equiv> \n  \\<forall>ms\\<^sub>1 s\\<^sub>1 ms\\<^sub>2 s\\<^sub>2 ms\\<^sub>1' s\\<^sub>1' as. \n    ((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> R \\<and> S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (ms\\<^sub>1',s\\<^sub>1') \\<and> s\\<^sub>1' \\<noteq> []\n    \\<longrightarrow> (\\<exists>ms\\<^sub>2' s\\<^sub>2' as'. ((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>2',s\\<^sub>2')) \\<in> R \\<and> \n                        S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow> (ms\\<^sub>2',s\\<^sub>2'))\""], ["", "lemma WS_weak_sim:\n  assumes \"((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" \n  and \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (ms\\<^sub>1',s\\<^sub>1')\" and \"s\\<^sub>1' \\<noteq> []\"\n  obtains as' where \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)) \\<in> WS S\"\n  and \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'@[last as]\\<Rightarrow> \n                          (ms\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n                  transfer (slice_kind S (last as)) s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n             [last\n               as]\\<Rightarrow> (ms\\<^sub>1',transfer\n        (slice_kind S (last as)) s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S (last as)) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n      s\\<^sub>2)", "from \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (ms\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (ms\\<^sub>1',s\\<^sub>1')", "obtain ms' s' as' a'\n    where \"S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\"\n    and \"S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\" and \"as = as'@[a']\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>as' ms' s' a'.\n        \\<lbrakk>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s');\n         S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1');\n         as = as' @ [a']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S (last as)) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n      s\\<^sub>2)", "from \\<open>S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')", "have \"\\<forall>m \\<in> set (tl ms'). \\<exists>m'. call_of_return_node m m' \\<and> m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n    and \"\\<forall>n \\<in> set (tl ms'). return_node n\" and \"ms' \\<noteq> []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set (tl ms').\n       \\<exists>m'.\n          call_of_return_node m m' \\<and>\n          m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> &&&\n    Ball (set (tl ms')) return_node &&& ms' \\<noteq> []", "by(auto elim:observable_move.cases simp:call_of_return_node_def)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set (tl ms').\n     \\<exists>m'.\n        call_of_return_node m m' \\<and>\n        m' \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  Ball (set (tl ms')) return_node\n  ms' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S (last as)) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n      s\\<^sub>2)", "from \\<open>S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\\<close> \\<open>((ms\\<^sub>1,s\\<^sub>1),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"((ms',s'),(ms\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (ms',s')\n  ((ms\\<^sub>1, s\\<^sub>1), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(rule WS_silent_moves)"], ["proof (state)\nthis:\n  ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S (last as)) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n      s\\<^sub>2)", "with \\<open>S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\\<close> \\<open>s\\<^sub>1' \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n  s\\<^sub>1' \\<noteq> []\n  ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S", "obtain as'' where \"((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)) \\<in> WS S\"\n    and \"S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as''@[a']\\<Rightarrow> \n    (ms\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ms',s') -a'\\<rightarrow> (ms\\<^sub>1',s\\<^sub>1')\n  s\\<^sub>1' \\<noteq> []\n  ((ms', s'), ms\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n                  transfer (slice_kind S a') s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'' @\n             [a']\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a')\n       s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS_observable_move)"], ["proof (state)\nthis:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'' @\n      [a']\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S (last as)) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n      s\\<^sub>2)", "with \\<open>((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)) \\<in> WS S\\<close> \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  as = as' @ [a']\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'' @\n      [a']\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)", "show \"\\<exists>as'. ((ms\\<^sub>1',s\\<^sub>1'),(ms\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)) \\<in> WS S \\<and>\n    S,slice_kind S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'@[last as]\\<Rightarrow> \n    (ms\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  as = as' @ [a']\n  ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as'' @\n      [a']\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n        transfer (slice_kind S (last as)) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n      s\\<^sub>2)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     ((ms\\<^sub>1', s\\<^sub>1'), ms\\<^sub>1',\n      transfer (slice_kind S (last as)) s\\<^sub>2)\n     \\<in> WS S \\<and>\n     S,slice_kind\n        S \\<turnstile> (ms\\<^sub>2,s\\<^sub>2) =as' @\n         [last\n           as]\\<Rightarrow> (ms\\<^sub>1',transfer (slice_kind S (last as))\n    s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following lemma states the correctness of static intraprocedural slicing:\\\\\n  the simulation \\<open>WS S\\<close> is a desired weak simulation\\<close>"], ["", "theorem WS_is_weak_sim:\"is_weak_sim (WS S) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_weak_sim (WS S) S", "by(fastforce elim:WS_weak_sim simp:is_weak_sim_def)"], ["", "end"], ["", "end"]]}