{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/StaticInter/BasicDefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma fun_upds_nth:\n  \"\\<lbrakk>i < length xs; length xs = length ys; distinct xs\\<rbrakk>\n  \\<Longrightarrow> f(xs [:=] ys)(xs!i) = (ys!i)\"", "lemma fun_upds_eq:\n  assumes \"V \\<in> set xs\" and \"length xs = length ys\" and \"distinct xs\"\n  shows \"f(xs [:=] ys) V = f'(xs [:=] ys) V\"", "lemma fun_upds_notin:\"x \\<notin> set xs \\<Longrightarrow> f(xs [:=] ys) x = f x\"", "lemma distinct_fst_Nil [simp]:\n  \"distinct_fst []\"", "lemma distinct_fst_Cons [simp]:\n  \"distinct_fst ((k,x)#kxs) = (distinct_fst kxs \\<and> (\\<forall>y. (k,y) \\<notin> set kxs))\"", "lemma distinct_fst_isin_same_fst:\n  \"\\<lbrakk>(x,y) \\<in> set xs; (x,y') \\<in> set xs; distinct_fst xs\\<rbrakk>\n  \\<Longrightarrow> y = y'\"", "lemma edge_kind_cases [case_names Intra Call Return]:\n  \"\\<lbrakk>intra_kind et \\<Longrightarrow> P; \\<And>Q r p fs. et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow> P;\n    \\<And>Q p f. et = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], "translations": [["", "lemma fun_upds_nth:\n  \"\\<lbrakk>i < length xs; length xs = length ys; distinct xs\\<rbrakk>\n  \\<Longrightarrow> f(xs [:=] ys)(xs!i) = (ys!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length xs; length xs = length ys; distinct xs\\<rbrakk>\n    \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i", "proof(induct xs arbitrary:ys i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys i.\n       \\<lbrakk>i < length []; length [] = length ys; distinct []\\<rbrakk>\n       \\<Longrightarrow> f([] [:=] ys) ([] ! i) = ys ! i\n 2. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "case Nil"], ["proof (state)\nthis:\n  i < length []\n  length [] = length ys\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>ys i.\n       \\<lbrakk>i < length []; length [] = length ys; distinct []\\<rbrakk>\n       \\<Longrightarrow> f([] [:=] ys) ([] ! i) = ys ! i\n 2. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "thus ?case"], ["proof (prove)\nusing this:\n  i < length []\n  length [] = length ys\n  distinct []\n\ngoal (1 subgoal):\n 1. f([] [:=] ys) ([] ! i) = ys ! i", "by simp"], ["proof (state)\nthis:\n  f([] [:=] ys) ([] ! i) = ys ! i\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "case (Cons x' xs')"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs'; length xs' = length ?ys; distinct xs'\\<rbrakk>\n  \\<Longrightarrow> f(xs' [:=] ?ys) (xs' ! ?i) = ?ys ! ?i\n  i < length (x' # xs')\n  length (x' # xs') = length ys\n  distinct (x' # xs')\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "note IH = \\<open>\\<And>ys i. \\<lbrakk>i < length xs'; length xs' = length ys; distinct xs'\\<rbrakk>\n    \\<Longrightarrow> f(xs' [:=] ys) (xs'!i) = ys!i\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs'; length xs' = length ?ys; distinct xs'\\<rbrakk>\n  \\<Longrightarrow> f(xs' [:=] ?ys) (xs' ! ?i) = ?ys ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "from \\<open>distinct (x'#xs')\\<close>"], ["proof (chain)\npicking this:\n  distinct (x' # xs')", "have \"distinct xs'\" and \"x' \\<notin> set xs'\""], ["proof (prove)\nusing this:\n  distinct (x' # xs')\n\ngoal (1 subgoal):\n 1. distinct xs' &&& x' \\<notin> set xs'", "by simp_all"], ["proof (state)\nthis:\n  distinct xs'\n  x' \\<notin> set xs'\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "from \\<open>length (x'#xs') = length ys\\<close>"], ["proof (chain)\npicking this:\n  length (x' # xs') = length ys", "obtain y' ys' where [simp]:\"ys = y'#ys'\"\n    and \"length xs' = length ys'\""], ["proof (prove)\nusing this:\n  length (x' # xs') = length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y' ys'.\n        \\<lbrakk>ys = y' # ys'; length xs' = length ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases ys) auto"], ["proof (state)\nthis:\n  ys = y' # ys'\n  length xs' = length ys'\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys i.\n       \\<lbrakk>\\<And>ys i.\n                   \\<lbrakk>i < length xs; length xs = length ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> f(xs [:=] ys) (xs ! i) = ys ! i;\n        i < length (a # xs); length (a # xs) = length ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> f(a # xs [:=] ys) ((a # xs) ! i) = ys ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "by simp"], ["proof (state)\nthis:\n  f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "with \\<open>i < length (x'#xs')\\<close>"], ["proof (chain)\npicking this:\n  i < length (x' # xs')\n  i = Suc j", "have \"j < length xs'\""], ["proof (prove)\nusing this:\n  i < length (x' # xs')\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j < length xs'", "by simp"], ["proof (state)\nthis:\n  j < length xs'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "from IH[OF this \\<open>length xs' = length ys'\\<close> \\<open>distinct xs'\\<close>]"], ["proof (chain)\npicking this:\n  f(xs' [:=] ys') (xs' ! j) = ys' ! j", "have \"f(xs' [:=] ys') (xs'!j) = ys'!j\""], ["proof (prove)\nusing this:\n  f(xs' [:=] ys') (xs' ! j) = ys' ! j\n\ngoal (1 subgoal):\n 1. f(xs' [:=] ys') (xs' ! j) = ys' ! j", "."], ["proof (state)\nthis:\n  f(xs' [:=] ys') (xs' ! j) = ys' ! j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "with \\<open>x' \\<notin> set xs'\\<close> \\<open>j < length xs'\\<close>"], ["proof (chain)\npicking this:\n  x' \\<notin> set xs'\n  j < length xs'\n  f(xs' [:=] ys') (xs' ! j) = ys' ! j", "have \"f((x'#xs') [:=] ys) ((x'#xs')!(Suc j)) = ys!(Suc j)\""], ["proof (prove)\nusing this:\n  x' \\<notin> set xs'\n  j < length xs'\n  f(xs' [:=] ys') (xs' ! j) = ys' ! j\n\ngoal (1 subgoal):\n 1. f(x' # xs' [:=] ys) ((x' # xs') ! Suc j) = ys ! Suc j", "by fastforce"], ["proof (state)\nthis:\n  f(x' # xs' [:=] ys) ((x' # xs') ! Suc j) = ys ! Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "with Suc"], ["proof (chain)\npicking this:\n  i = Suc j\n  f(x' # xs' [:=] ys) ((x' # xs') ! Suc j) = ys ! Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  i = Suc j\n  f(x' # xs' [:=] ys) ((x' # xs') ! Suc j) = ys ! Suc j\n\ngoal (1 subgoal):\n 1. f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i", "by simp"], ["proof (state)\nthis:\n  f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f(x' # xs' [:=] ys) ((x' # xs') ! i) = ys ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_upds_eq:\n  assumes \"V \\<in> set xs\" and \"length xs = length ys\" and \"distinct xs\"\n  shows \"f(xs [:=] ys) V = f'(xs [:=] ys) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "from \\<open>V \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> set xs", "obtain i where \"i < length xs\" and \"xs!i = V\""], ["proof (prove)\nusing this:\n  V \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i = V\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "with \\<open>length xs = length ys\\<close> \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  length xs = length ys\n  distinct xs\n  i < length xs\n  xs ! i = V", "have \"f(xs [:=] ys)(xs!i) = (ys!i)\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  distinct xs\n  i < length xs\n  xs ! i = V\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) (xs ! i) = ys ! i", "by -(rule fun_upds_nth)"], ["proof (state)\nthis:\n  f(xs [:=] ys) (xs ! i) = ys ! i\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "moreover"], ["proof (state)\nthis:\n  f(xs [:=] ys) (xs ! i) = ys ! i\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "from \\<open>i < length xs\\<close> \\<open>xs!i = V\\<close> \\<open>length xs = length ys\\<close> \\<open>distinct xs\\<close>"], ["proof (chain)\npicking this:\n  i < length xs\n  xs ! i = V\n  length xs = length ys\n  distinct xs", "have \"f'(xs [:=] ys)(xs!i) = (ys!i)\""], ["proof (prove)\nusing this:\n  i < length xs\n  xs ! i = V\n  length xs = length ys\n  distinct xs\n\ngoal (1 subgoal):\n 1. f'(xs [:=] ys) (xs ! i) = ys ! i", "by -(rule fun_upds_nth)"], ["proof (state)\nthis:\n  f'(xs [:=] ys) (xs ! i) = ys ! i\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "ultimately"], ["proof (chain)\npicking this:\n  f(xs [:=] ys) (xs ! i) = ys ! i\n  f'(xs [:=] ys) (xs ! i) = ys ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  f(xs [:=] ys) (xs ! i) = ys ! i\n  f'(xs [:=] ys) (xs ! i) = ys ! i\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "using \\<open>xs!i = V\\<close>"], ["proof (prove)\nusing this:\n  f(xs [:=] ys) (xs ! i) = ys ! i\n  f'(xs [:=] ys) (xs ! i) = ys ! i\n  xs ! i = V\n\ngoal (1 subgoal):\n 1. f(xs [:=] ys) V = f'(xs [:=] ys) V", "by simp"], ["proof (state)\nthis:\n  f(xs [:=] ys) V = f'(xs [:=] ys) V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_upds_notin:\"x \\<notin> set xs \\<Longrightarrow> f(xs [:=] ys) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> f(xs [:=] ys) x = f x", "by(induct xs arbitrary:ys,auto,case_tac ys,auto)"], ["", "subsection \\<open>\\<open>distinct_fst\\<close>\\<close>"], ["", "definition distinct_fst :: \"('a \\<times> 'b) list \\<Rightarrow> bool\" where\n  \"distinct_fst  \\<equiv>  distinct \\<circ> map fst\""], ["", "lemma distinct_fst_Nil [simp]:\n  \"distinct_fst []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst []", "by(simp add:distinct_fst_def)"], ["", "lemma distinct_fst_Cons [simp]:\n  \"distinct_fst ((k,x)#kxs) = (distinct_fst kxs \\<and> (\\<forall>y. (k,y) \\<notin> set kxs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst ((k, x) # kxs) =\n    (distinct_fst kxs \\<and> (\\<forall>y. (k, y) \\<notin> set kxs))", "by(auto simp:distinct_fst_def image_def)"], ["", "lemma distinct_fst_isin_same_fst:\n  \"\\<lbrakk>(x,y) \\<in> set xs; (x,y') \\<in> set xs; distinct_fst xs\\<rbrakk>\n  \\<Longrightarrow> y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<in> set xs; (x, y') \\<in> set xs;\n     distinct_fst xs\\<rbrakk>\n    \\<Longrightarrow> y = y'", "by(induct xs,auto simp:distinct_fst_def image_def)"], ["", "subsection\\<open>Edge kinds\\<close>"], ["", "text \\<open>Every procedure has a unique name, e.g. in object oriented languages\n  \\<open>pname\\<close> refers to class + procedure.\\<close>"], ["", "text \\<open>A state is a call stack of tuples, which consists of:\n  \\begin{enumerate}\n  \\item data information, i.e.\\ a mapping from the local variables in the call \n  frame to their values, and\n  \\item control flow information, e.g.\\ which node called the current procedure.\n  \\end{enumerate}\n\n  Update and predicate edges check and manipulate only the data information\n  of the top call stack element. Call and return edges however may use the data and\n  control flow information present in the top stack element to state if this edge is\n  traversable. The call edge additionally has a list of functions to determine what\n  values the parameters have in a certain call frame and control flow information for\n  the return. The return edge is concerned with passing the values \n  of the return parameter values to the underlying stack frame. See the funtions \n  \\<open>transfer\\<close> and \\<open>pred\\<close> in locale \\<open>CFG\\<close>.\\<close>"], ["", "datatype (dead 'var, dead 'val, dead 'ret, dead 'pname) edge_kind =\n    UpdateEdge \"('var \\<rightharpoonup> 'val) \\<Rightarrow> ('var \\<rightharpoonup> 'val)\"                  (\"\\<Up>_\")\n  | PredicateEdge \"('var \\<rightharpoonup> 'val) \\<Rightarrow> bool\"                         (\"'(_')\\<^sub>\\<surd>\")\n  | CallEdge \"('var \\<rightharpoonup> 'val) \\<times> 'ret \\<Rightarrow> bool\" \"'ret\" \"'pname\"  \n             \"(('var \\<rightharpoonup> 'val) \\<rightharpoonup> 'val) list\"                       (\"_:_\\<hookrightarrow>\\<^bsub>_\\<^esub>_\" 70)\n  | ReturnEdge \"('var \\<rightharpoonup> 'val) \\<times> 'ret \\<Rightarrow> bool\" \"'pname\" \n               \"('var \\<rightharpoonup> 'val) \\<Rightarrow> ('var \\<rightharpoonup> 'val) \\<Rightarrow> ('var \\<rightharpoonup> 'val)\" (\"_\\<hookleftarrow>\\<^bsub>_\\<^esub>_\" 70)"], ["", "definition intra_kind :: \"('var,'val,'ret,'pname) edge_kind \\<Rightarrow> bool\"\nwhere \"intra_kind et \\<equiv> (\\<exists>f. et = \\<Up>f) \\<or> (\\<exists>Q. et = (Q)\\<^sub>\\<surd>)\""], ["", "lemma edge_kind_cases [case_names Intra Call Return]:\n  \"\\<lbrakk>intra_kind et \\<Longrightarrow> P; \\<And>Q r p fs. et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow> P;\n    \\<And>Q p f. et = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>intra_kind et \\<Longrightarrow> P;\n     \\<And>Q r p fs.\n        et = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow> P;\n     \\<And>Q p f.\n        et = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n        P\\<rbrakk>\n    \\<Longrightarrow> P", "by(cases et,auto simp:intra_kind_def)"], ["", "end"]]}