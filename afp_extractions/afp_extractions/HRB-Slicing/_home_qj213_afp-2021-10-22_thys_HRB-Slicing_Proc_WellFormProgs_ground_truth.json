{"file_name": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing/Proc/WellFormProgs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HRB-Slicing", "problem_names": ["lemma [dest]:\"\\<lbrakk>well_formed procs; (Main,ins,outs,c) \\<in> set procs\\<rbrakk> \\<Longrightarrow> False\"", "lemma well_formed_same_procs [dest]:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs; (p,ins',outs',c') \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> ins = ins' \\<and> outs = outs' \\<and> c = c'\"", "lemma PCFG_sourcelabel_None_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,Label l) -et\\<rightarrow> n'; well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:prog\"", "lemma Proc_CFG_sourcelabel_Some_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> (p,Label l) -et\\<rightarrow> n'; (p,ins,outs,c) \\<in> set procs; \n    well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:c\"", "lemma Proc_CFG_targetlabel_Main_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> (Main,Label l); well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:prog\"", "lemma Proc_CFG_targetlabel_Some_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> (p,Label l); (p,ins,outs,c) \\<in> set procs; \n    well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:c\"", "lemma Proc_CFG_edge_det:\n  \"\\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> n'; prog,procs \\<turnstile> n -et'\\<rightarrow> n'; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> et = et'\"", "lemma Proc_CFG_deterministic:\n  \"\\<lbrakk>prog,procs \\<turnstile> n\\<^sub>1 -et\\<^sub>1\\<rightarrow> n\\<^sub>1'; prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'; n\\<^sub>1 = n\\<^sub>2; n\\<^sub>1' \\<noteq> n\\<^sub>2'; \n   intra_kind et\\<^sub>1; intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et\\<^sub>1 = (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\"", "lemma wf_well_formed [intro]:\"wf prog procs \\<Longrightarrow> well_formed procs\"", "lemma wf_distinct_rets [intro]:\n  \"\\<lbrakk>wf prog procs; containsCall procs prog ps p; (p,ins,outs,c) \\<in> set procs;\n    c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk> \\<Longrightarrow> distinct rets\"", "lemma\n  assumes \"wf prog procs\" and \"containsCall procs prog ps p\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows wf_length_retsI [intro]:\"length rets = length outs\"\n  and wf_length_esI [intro]:\"length es = length ins\"", "lemma wf_wf_prog:\"Rep_wf_prog wfp = (prog,procs) \\<Longrightarrow> wf prog procs\"", "lemma wfp_Seq1: assumes \"Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\"", "lemma wfp_Seq2: assumes \"Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>2, procs)\"", "lemma wfp_CondTrue: assumes \"Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\"", "lemma wfp_CondFalse: assumes \"Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>2, procs)\"", "lemma wfp_WhileBody: assumes \"Rep_wf_prog wfp = (while (b) c', procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c', procs)\"", "lemma wfp_Call: assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"containsCall procs prog ps p\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c,procs)\""], "translations": [["", "lemma [dest]:\"\\<lbrakk>well_formed procs; (Main,ins,outs,c) \\<in> set procs\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_formed procs;\n     (Main, ins, outs, c) \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> False", "by(fastforce simp:well_formed_def wf_proc_def)"], ["", "lemma well_formed_same_procs [dest]:\n  \"\\<lbrakk>well_formed procs; (p,ins,outs,c) \\<in> set procs; (p,ins',outs',c') \\<in> set procs\\<rbrakk>\n  \\<Longrightarrow> ins = ins' \\<and> outs = outs' \\<and> c = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>well_formed procs; (p, ins, outs, c) \\<in> set procs;\n     (p, ins', outs', c') \\<in> set procs\\<rbrakk>\n    \\<Longrightarrow> ins = ins' \\<and> outs = outs' \\<and> c = c'", "apply(auto simp:well_formed_def distinct_fst_def distinct_map inj_on_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n     (p, ins', outs', c') \\<in> set procs; distinct procs;\n     \\<forall>x\\<in>set procs.\n        \\<forall>y\\<in>set procs. fst x = fst y \\<longrightarrow> x = y;\n     \\<forall>x\\<in>set procs. wf_proc x\\<rbrakk>\n    \\<Longrightarrow> ins = ins'\n 2. \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n     (p, ins', outs', c') \\<in> set procs; distinct procs;\n     \\<forall>x\\<in>set procs.\n        \\<forall>y\\<in>set procs. fst x = fst y \\<longrightarrow> x = y;\n     \\<forall>x\\<in>set procs. wf_proc x\\<rbrakk>\n    \\<Longrightarrow> outs = outs'\n 3. \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n     (p, ins', outs', c') \\<in> set procs; distinct procs;\n     \\<forall>x\\<in>set procs.\n        \\<forall>y\\<in>set procs. fst x = fst y \\<longrightarrow> x = y;\n     \\<forall>x\\<in>set procs. wf_proc x\\<rbrakk>\n    \\<Longrightarrow> c = c'", "by(erule_tac x=\"(p,ins,outs,c)\" in ballE,auto)+"], ["", "lemma PCFG_sourcelabel_None_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> (Main,Label l) -et\\<rightarrow> n'; well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> (Main, Label l) -et\\<rightarrow> n';\n     well_formed procs\\<rbrakk>\n    \\<Longrightarrow> l < #:prog", "proof(induct \"(Main,Label l)\" et n' \n      arbitrary:l rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 6. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "case (Main et n')"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 6. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "from \\<open>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce elim:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "from \\<open>prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce elim:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (4 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "case (MainCallReturn p es rets n' l)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>p es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "from \\<open>prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce elim:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c et n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>ins outs c p' es' rets' n' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "qed auto"], ["", "lemma Proc_CFG_sourcelabel_Some_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> (p,Label l) -et\\<rightarrow> n'; (p,ins,outs,c) \\<in> set procs; \n    well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> (p, Label l) -et\\<rightarrow> n';\n     (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> l < #:c", "proof(induct \"(p,Label l)\" et n' arbitrary:l rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>insa outsa ca et n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 6. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "case (Proc ins' outs' c' et n')"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  c' \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>insa outsa ca et n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 6. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "from \\<open>c' \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'", "have \"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (6 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>insa outsa ca et n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 6. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "with \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \n    \\<open>(p,ins',outs',c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'\n\ngoal (1 subgoal):\n 1. l < #:c", "by fastforce"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (5 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "case (ProcCall ins' outs' c' l' p' es rets l'' ins'' outs'' c'' ps)"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  c' \\<turnstile> Label\n                   l' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l''\n  (p', ins'', outs'', c'') \\<in> set procs\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "from \\<open>c' \\<turnstile> Label l' -CEdge (p',es,rets)\\<rightarrow>\\<^sub>p Label l''\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> Label\n                   l' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l''", "have \"l' < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Label\n                   l' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l''\n\ngoal (1 subgoal):\n 1. l' < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l' < #:c'\n\ngoal (5 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "with \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \n    \\<open>(p, ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l' < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l' < #:c'\n\ngoal (1 subgoal):\n 1. l' < #:c", "by fastforce"], ["proof (state)\nthis:\n  l' < #:c\n\ngoal (4 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "case (ProcCallReturn ins' outs' c' p' es rets n')"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  c' \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "from \\<open>c' \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'", "have \"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Label l -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_sourcelabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (4 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca p' es' rets' n' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "with \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \n    \\<open>(p,ins',outs',c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'\n\ngoal (1 subgoal):\n 1. l < #:c", "by fastforce"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (3 subgoals):\n 1. \\<And>et n' l.\n       \\<lbrakk>prog \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>pa es rets n' l.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p n';\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "qed auto"], ["", "lemma Proc_CFG_targetlabel_Main_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> (Main,Label l); well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> (Main, Label l);\n     well_formed procs\\<rbrakk>\n    \\<Longrightarrow> l < #:prog", "proof(induct n et \"(Main,Label l)\" \n      arbitrary:l rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 4. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 5. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 6. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "case (Main n et)"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 4. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 5. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 6. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "from \\<open>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce elim:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 4. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 4. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "case (MainReturn l' p es rets l'' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l' -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l''\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 4. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 5. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "from \\<open>prog \\<turnstile> Label l' -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p Label l''\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label\n                     l' -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l''", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l' -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l''\n\ngoal (1 subgoal):\n 1. l'' < #:prog", "by(fastforce elim:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l'' < #:prog\n\ngoal (4 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "case (MainCallReturn n p es rets)"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>n p es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 4. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "from \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (1 subgoal):\n 1. l < #:prog", "by(fastforce elim:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:prog\n\ngoal (3 subgoals):\n 1. \\<And>ins outs c n et ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog\n 2. \\<And>ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:prog\n 3. \\<And>ins outs c n p' es' rets' ps l.\n       \\<lbrakk>(Main, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge\n                           (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps Main; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:prog", "qed auto"], ["", "lemma Proc_CFG_targetlabel_Some_less_num_nodes:\n  \"\\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> (p,Label l); (p,ins,outs,c) \\<in> set procs; \n    well_formed procs\\<rbrakk> \\<Longrightarrow> l < #:c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> (p, Label l);\n     (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n    \\<Longrightarrow> l < #:c", "proof(induct n et \"(p,Label l)\" arbitrary:l rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>insa outsa ca n et ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 5. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 6. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "case (Proc ins' outs' c' n et)"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l\n  containsCall procs prog ps_ p\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>insa outsa ca n et ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 5. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 6. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "from \\<open>c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l", "have \"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (6 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>insa outsa ca n et ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 3. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 5. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 6. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "with \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \n    \\<open>(p,ins',outs',c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'\n\ngoal (1 subgoal):\n 1. l < #:c", "by fastforce"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (5 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "case (ProcReturn ins' outs' c' l' p' es rets l ins'' outs'' c'' ps)"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  c' \\<turnstile> Label\n                   l' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l\n  (p', ins'', outs'', c'') \\<in> set procs\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "from \\<open>c' \\<turnstile> Label l' -CEdge (p',es,rets)\\<rightarrow>\\<^sub>p Label l\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> Label\n                   l' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l", "have \"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> Label\n                   l' -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (5 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>insa outsa ca l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 4. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 5. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "with \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \n    \\<open>(p, ins', outs', c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'\n\ngoal (1 subgoal):\n 1. l < #:c", "by fastforce"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (4 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "case (ProcCallReturn ins' outs' c' n p'' es rets)"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  c' \\<turnstile> n -CEdge (p'', es, rets)\\<rightarrow>\\<^sub>p Label l\n  containsCall procs prog ps_ p\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "from \\<open>c' \\<turnstile> n -CEdge (p'', es, rets)\\<rightarrow>\\<^sub>p Label l\\<close>"], ["proof (chain)\npicking this:\n  c' \\<turnstile> n -CEdge (p'', es, rets)\\<rightarrow>\\<^sub>p Label l", "have \"l < #:c'\""], ["proof (prove)\nusing this:\n  c' \\<turnstile> n -CEdge (p'', es, rets)\\<rightarrow>\\<^sub>p Label l\n\ngoal (1 subgoal):\n 1. l < #:c'", "by(fastforce intro:Proc_CFG_targetlabel_less_num_nodes)"], ["proof (state)\nthis:\n  l < #:c'\n\ngoal (4 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 4. \\<And>insa outsa ca n p' es' rets' ps l.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> n -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l;\n        containsCall procs prog ps p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "with \\<open>well_formed procs\\<close> \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \n    \\<open>(p,ins',outs',c') \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'", "show ?case"], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  l < #:c'\n\ngoal (1 subgoal):\n 1. l < #:c", "by fastforce"], ["proof (state)\nthis:\n  l < #:c\n\ngoal (3 subgoals):\n 1. \\<And>n et l.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c\n 2. \\<And>l pa es rets l' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (pa, insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l' < #:c\n 3. \\<And>n pa es rets l.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(pa, es, rets)\\<rightarrow>\\<^sub>p Label l;\n        Main = p; (p, ins, outs, c) \\<in> set procs;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> l < #:c", "qed auto"], ["", "lemma Proc_CFG_edge_det:\n  \"\\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> n'; prog,procs \\<turnstile> n -et'\\<rightarrow> n'; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> et = et'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> n -et\\<rightarrow> n';\n     prog,procs \\<turnstile> n -et'\\<rightarrow> n';\n     well_formed procs\\<rbrakk>\n    \\<Longrightarrow> et = et'", "proof(induct rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p ins outs c n et n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case Main"], ["proof (state)\nthis:\n  prog \\<turnstile> n_ -IEdge et_\\<rightarrow>\\<^sub>p n'_\n  prog,procs \\<turnstile> (Main, n_) -et'\\<rightarrow> (Main, n'_)\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>n et n'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>p ins outs c n et n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 3. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 5. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 7. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 8. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n_ -IEdge et_\\<rightarrow>\\<^sub>p n'_\n  prog,procs \\<turnstile> (Main, n_) -et'\\<rightarrow> (Main, n'_)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. et_ = et'", "by(auto elim:PCFG.cases dest:Proc_CFG_edge_det)"], ["proof (state)\nthis:\n  et_ = et'\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case Proc"], ["proof (state)\nthis:\n  (p_, ins_, outs_, c_) \\<in> set procs\n  c_ \\<turnstile> n_ -IEdge et_\\<rightarrow>\\<^sub>p n'_\n  containsCall procs prog ps_ p_\n  prog,procs \\<turnstile> (p_, n_) -et'\\<rightarrow> (p_, n'_)\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> et = et'\n 2. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 4. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 6. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 7. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "thus ?case"], ["proof (prove)\nusing this:\n  (p_, ins_, outs_, c_) \\<in> set procs\n  c_ \\<turnstile> n_ -IEdge et_\\<rightarrow>\\<^sub>p n'_\n  containsCall procs prog ps_ p_\n  prog,procs \\<turnstile> (p_, n_) -et'\\<rightarrow> (p_, n'_)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. et_ = et'", "by(auto elim:PCFG.cases dest:Proc_CFG_edge_det)"], ["proof (state)\nthis:\n  et_ = et'\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case (MainCall l p es rets n' ins outs c)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, ins, outs, c) \\<in> set procs\n  prog,procs \\<turnstile> (Main, Label l) -et'\\<rightarrow> (p, Entry)\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "from \\<open>prog,procs \\<turnstile> (Main,Label l) -et'\\<rightarrow> (p,Entry)\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> (Main, Label l) -et'\\<rightarrow> (p, Entry)\n  well_formed procs", "obtain es' rets' n'' ins' outs' c' \n    where \"prog \\<turnstile> Label l -CEdge (p,es',rets')\\<rightarrow>\\<^sub>p n''\" \n    and \"(p,ins',outs',c') \\<in> set procs\" \n    and \"et' = (\\<lambda>s. True):(Main,n'')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es'\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (Main, Label l) -et'\\<rightarrow> (p, Entry)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>es' rets' n'' ins' outs' c'.\n        \\<lbrakk>prog \\<turnstile> Label\n                                    l -CEdge\n  (p, es', rets')\\<rightarrow>\\<^sub>p n'';\n         (p, ins', outs', c') \\<in> set procs;\n         et' =\n         \\<lambda>s.\n            True:(Main,\n                  n'')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret\n                   es'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:PCFG.cases)"], ["proof (state)\nthis:\n  prog \\<turnstile> Label l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p n''\n  (p, ins', outs', c') \\<in> set procs\n  et' =\n  \\<lambda>s.\n     True:(Main, n'')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es'\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "from \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>(p,ins',outs',c') \\<in> set procs\\<close>\n    \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  well_formed procs", "have \"ins = ins'\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ins = ins'", "by fastforce"], ["proof (state)\nthis:\n  ins = ins'\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "from \\<open>prog \\<turnstile> Label l -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<close>\n    \\<open>prog \\<turnstile> Label l -CEdge (p,es',rets')\\<rightarrow>\\<^sub>p n''\\<close>"], ["proof (chain)\npicking this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  prog \\<turnstile> Label l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p n''", "have \"es = es'\" and \"n' = n''\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label l -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  prog \\<turnstile> Label l -CEdge (p, es', rets')\\<rightarrow>\\<^sub>p n''\n\ngoal (1 subgoal):\n 1. es = es' &&& n' = n''", "by(auto dest:Proc_CFG_Call_nodes_eq)"], ["proof (state)\nthis:\n  es = es'\n  n' = n''\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (Main,\n                                 Label l) -et'\\<rightarrow> (p, Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                  interpret es =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 3. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 5. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 6. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "with \\<open>et' = (\\<lambda>s. True):(Main,n'')\\<hookrightarrow>\\<^bsub>p\\<^esub>map (\\<lambda>e cf. interpret e cf) es'\\<close> \\<open>ins = ins'\\<close>"], ["proof (chain)\npicking this:\n  et' =\n  \\<lambda>s.\n     True:(Main, n'')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es'\n  ins = ins'\n  es = es'\n  n' = n''", "show ?case"], ["proof (prove)\nusing this:\n  et' =\n  \\<lambda>s.\n     True:(Main, n'')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es'\n  ins = ins'\n  es = es'\n  n' = n''\n\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n    et'", "by simp"], ["proof (state)\nthis:\n  \\<lambda>s.\n     True:(Main, n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es =\n  et'\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case (ProcCall p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry)\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry);\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et'\n 2. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 4. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 5. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "from \\<open>prog,procs \\<turnstile> (p,Label l) -et'\\<rightarrow> (p',Entry)\\<close> \\<open>(p',ins',outs',c') \\<in> set procs\\<close> \n    \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>\n    \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry)\n  (p', ins', outs', c') \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "show ?case"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p, Label l) -et'\\<rightarrow> (p', Entry)\n  (p', ins', outs', c') \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       True:(p, Label\n                 l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n    et'", "proof(induct \"(p,Label l)\" et' \"(p',Entry)\" rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 2. \\<And>insa outsa ca et ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 3. \\<And>es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                   interpret es\n 4. \\<And>insa outsa ca es'a rets'a l'a ins'a outs'a c'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es'a,\n                              rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog ps p; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(p, Label\nl'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es'a\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "case (ProcCall insx outsx cx es'x rets'x l'x ins'x outs'x c'x ps)"], ["proof (state)\nthis:\n  (p, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   l -CEdge\n                       (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'x\n  (p', ins'x, outs'x, c'x) \\<in> set procs\n  containsCall procs prog ps p\n  (p', ins', outs', c') \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 2. \\<And>insa outsa ca et ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 3. \\<And>es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                   interpret es\n 4. \\<And>insa outsa ca es'a rets'a l'a ins'a outs'a c'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es'a,\n                              rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog ps p; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(p, Label\nl'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es'a\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>well_formed procs\\<close> \\<open>(p, insx, outsx, cx) \\<in> set procs\\<close> \n      \\<open>(p, ins, outs, c) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  well_formed procs\n  (p, insx, outsx, cx) \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs", "have [simp]:\"cx = c\""], ["proof (prove)\nusing this:\n  well_formed procs\n  (p, insx, outsx, cx) \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs\n\ngoal (1 subgoal):\n 1. cx = c", "by auto"], ["proof (state)\nthis:\n  cx = c\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 2. \\<And>insa outsa ca et ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 3. \\<And>es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                   interpret es\n 4. \\<And>insa outsa ca es'a rets'a l'a ins'a outs'a c'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es'a,\n                              rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog ps p; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(p, Label\nl'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es'a\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>cx \\<turnstile> Label l -CEdge (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'x\\<close>\n      \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  cx \\<turnstile> Label\n                   l -CEdge\n                       (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'x\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have [simp]:\"es'x = es'\" \"l'x = l'\""], ["proof (prove)\nusing this:\n  cx \\<turnstile> Label\n                   l -CEdge\n                       (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'x\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. es'x = es' &&& l'x = l'", "by(auto dest:Proc_CFG_Call_nodes_eq)"], ["proof (state)\nthis:\n  es'x = es'\n  l'x = l'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 2. \\<And>insa outsa ca et ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 3. \\<And>es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                   interpret es\n 4. \\<And>insa outsa ca es'a rets'a l'a ins'a outs'a c'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p', es'a,\n                              rets'a)\\<rightarrow>\\<^sub>p Label l'a;\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog ps p; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(p, Label\nl'a)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es'a\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>s.\n       True:(p, Label\n                 l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n    \\<lambda>s.\n       True:(p, Label\n                 l'x)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es'x", "by simp"], ["proof (state)\nthis:\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  \\<lambda>s.\n     True:(p, Label\n               l'x)\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es'x\n\ngoal (5 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 2. \\<And>insa outsa ca et ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label l -IEdge et\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         et\n 3. \\<And>es rets n' insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p', es, rets)\\<rightarrow>\\<^sub>p n';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         \\<lambda>s.\n                            True:(Main,\n                                  n')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map\n                                   interpret es\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (pa, es, rets)\\<rightarrow>\\<^sub>p Entry;\n        Main = p; Main = p'; (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. \\<And>insa outsa ca p'a es'a rets'a ps.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         l -CEdge\n                             (p'a, es'a, rets'a)\\<rightarrow>\\<^sub>p Entry;\n        containsCall procs prog ps p; p = p';\n        (p', ins', outs', c') \\<in> set procs;\n        (p, ins, outs, c) \\<in> set procs; well_formed procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es',\n                             rets')\\<rightarrow>\\<^sub>p Label l'\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>s.\n                            True:(p, Label\nl')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "qed auto"], ["proof (state)\nthis:\n  \\<lambda>s.\n     True:(p, Label\n               l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n  et'\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case MainReturn"], ["proof (state)\nthis:\n  prog \\<turnstile> Label\n                     l_ -CEdge\n                          (p_, es_, rets_)\\<rightarrow>\\<^sub>p Label l'_\n  (p_, ins_, outs_, c_) \\<in> set procs\n  prog,procs \\<turnstile> (p_, Exit) -et'\\<rightarrow> (Main, Label l'_)\n  well_formed procs\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets l' ins outs c.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> (p, Exit) -et'\\<rightarrow> (Main,\n                       Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                               cf'. cf'(rets [:=] map cf outs) =\n                         et'\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 3. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 4. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> Label\n                     l_ -CEdge\n                          (p_, es_, rets_)\\<rightarrow>\\<^sub>p Label l'_\n  (p_, ins_, outs_, c_) \\<in> set procs\n  prog,procs \\<turnstile> (p_, Exit) -et'\\<rightarrow> (Main, Label l'_)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<lambda>cf.\n       snd cf =\n       (Main,\n        Label\n         l'_)\\<hookleftarrow>\\<^bsub>p_\\<^esub>\\<lambda>cf cf'. cf'(rets_ \n            [:=] map cf outs_) =\n    et'", "by -(erule PCFG.cases,auto dest:Proc_CFG_Call_nodes_eq')"], ["proof (state)\nthis:\n  \\<lambda>cf.\n     snd cf =\n     (Main,\n      Label\n       l'_)\\<hookleftarrow>\\<^bsub>p_\\<^esub>\\<lambda>cf cf'. cf'(rets_ [:=]\n          map cf outs_) =\n  et'\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case (ProcReturn p ins outs c l p' es' rets' l' ins' outs' c' ps)"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  (p', ins', outs', c') \\<in> set procs\n  containsCall procs prog ps p\n  prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l')\n  well_formed procs\n\ngoal (3 subgoals):\n 1. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et'\n 2. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 3. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "from \\<open>prog,procs \\<turnstile> (p',Exit) -et'\\<rightarrow> (p, Label l')\\<close>\n    \\<open>(p, ins, outs, c) \\<in> set procs\\<close> \\<open>(p', ins', outs', c') \\<in> set procs\\<close>\n    \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close> \n    \\<open>containsCall procs prog ps p\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l')\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  well_formed procs", "show ?case"], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> (p', Exit) -et'\\<rightarrow> (p, Label l')\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<lambda>cf.\n       snd cf =\n       (p, Label\n            l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n              [:=] map cf outs') =\n    et'", "proof(induct \"(p',Exit)\" et' \"(p,Label l')\" rule:PCFG.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 3. \\<And>la es rets insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                cf'. cf'(rets [:=] map cf outsa)\n 4. \\<And>insa outsa ca la es'a rets'a ins'a outs'a c'a psa.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p', es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l';\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets'a [:=] map cf outs'a)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Exit -CEdge\n   (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -CEdge\n                               (p'a, es'a,\n                                rets'a)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "case (ProcReturn insx outsx cx lx es'x rets'x ins'x outs'x c'x psx)"], ["proof (state)\nthis:\n  (p, insx, outsx, cx) \\<in> set procs\n  cx \\<turnstile> Label\n                   lx -CEdge\n                        (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'\n  (p', ins'x, outs'x, c'x) \\<in> set procs\n  containsCall procs prog psx p\n  (p, ins, outs, c) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n  containsCall procs prog ps p\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 3. \\<And>la es rets insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                cf'. cf'(rets [:=] map cf outsa)\n 4. \\<And>insa outsa ca la es'a rets'a ins'a outs'a c'a psa.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p', es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l';\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets'a [:=] map cf outs'a)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Exit -CEdge\n   (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -CEdge\n                               (p'a, es'a,\n                                rets'a)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>(p', ins'x, outs'x, c'x) \\<in> set procs\\<close>\n      \\<open>(p', ins', outs', c') \\<in> set procs\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  (p', ins'x, outs'x, c'x) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs", "have [simp]:\"outs'x = outs'\""], ["proof (prove)\nusing this:\n  (p', ins'x, outs'x, c'x) \\<in> set procs\n  (p', ins', outs', c') \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. outs'x = outs'", "by fastforce"], ["proof (state)\nthis:\n  outs'x = outs'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 3. \\<And>la es rets insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                cf'. cf'(rets [:=] map cf outsa)\n 4. \\<And>insa outsa ca la es'a rets'a ins'a outs'a c'a psa.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p', es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l';\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets'a [:=] map cf outs'a)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Exit -CEdge\n   (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -CEdge\n                               (p'a, es'a,\n                                rets'a)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>(p, insx, outsx, cx) \\<in> set procs\\<close> \\<open>(p, ins, outs, c) \\<in> set procs\\<close>\n      \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  (p, insx, outsx, cx) \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "have [simp]:\"cx = c\""], ["proof (prove)\nusing this:\n  (p, insx, outsx, cx) \\<in> set procs\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. cx = c", "by auto"], ["proof (state)\nthis:\n  cx = c\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 3. \\<And>la es rets insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                cf'. cf'(rets [:=] map cf outsa)\n 4. \\<And>insa outsa ca la es'a rets'a ins'a outs'a c'a psa.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p', es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l';\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets'a [:=] map cf outs'a)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Exit -CEdge\n   (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -CEdge\n                               (p'a, es'a,\n                                rets'a)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>cx \\<turnstile> Label lx -CEdge (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'\\<close>\n      \\<open>c \\<turnstile> Label l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\\<close>"], ["proof (chain)\npicking this:\n  cx \\<turnstile> Label\n                   lx -CEdge\n                        (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'", "have [simp]:\"rets'x = rets'\""], ["proof (prove)\nusing this:\n  cx \\<turnstile> Label\n                   lx -CEdge\n                        (p', es'x, rets'x)\\<rightarrow>\\<^sub>p Label l'\n  c \\<turnstile> Label\n                  l -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p Label l'\n\ngoal (1 subgoal):\n 1. rets'x = rets'", "by(fastforce dest:Proc_CFG_Call_nodes_eq')"], ["proof (state)\nthis:\n  rets'x = rets'\n\ngoal (6 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 3. \\<And>la es rets insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                cf'. cf'(rets [:=] map cf outsa)\n 4. \\<And>insa outsa ca la es'a rets'a ins'a outs'a c'a psa.\n       \\<lbrakk>(p, insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Label\n                         la -CEdge\n                              (p', es'a,\n                               rets'a)\\<rightarrow>\\<^sub>p Label l';\n        (p', ins'a, outs'a, c'a) \\<in> set procs;\n        containsCall procs prog psa p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets'a [:=] map cf outs'a)\n 5. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Exit -CEdge\n   (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 6. \\<And>insa outsa ca p'a es'a rets'a psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -CEdge\n                               (p'a, es'a,\n                                rets'a)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>cf.\n       snd cf =\n       (p, Label\n            l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n              [:=] map cf outs') =\n    \\<lambda>cf.\n       snd cf =\n       (p, Label\n            l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n              cf'(rets'x [:=] map cf outs'x)", "by simp"], ["proof (state)\nthis:\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets'x \n            [:=] map cf outs'x)\n\ngoal (5 subgoals):\n 1. \\<And>et.\n       \\<lbrakk>prog \\<turnstile> Exit -IEdge\n   et\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 2. \\<And>insa outsa ca et psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -IEdge et\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         et\n 3. \\<And>la es rets insa outsa ca.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   la -CEdge\n  (p', es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p', insa, outsa, ca) \\<in> set procs; Main = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         \\<lambda>cf.\n                            snd cf =\n                            (Main,\n                             Label\n                              l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                cf'. cf'(rets [:=] map cf outsa)\n 4. \\<And>pa es rets.\n       \\<lbrakk>prog \\<turnstile> Exit -CEdge\n   (pa, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        Main = p'; Main = p; (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>\n 5. \\<And>insa outsa ca p'a es'a rets'a psa.\n       \\<lbrakk>(p', insa, outsa, ca) \\<in> set procs;\n        ca \\<turnstile> Exit -CEdge\n                               (p'a, es'a,\n                                rets'a)\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog psa p'; p' = p;\n        (p, ins, outs, c) \\<in> set procs;\n        (p', ins', outs', c') \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        containsCall procs prog ps p; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<lambda>cf.\n                            snd cf =\n                            (p, Label\n                                 l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\n                                   cf'. cf'(rets' [:=] map cf outs') =\n                         (\\<lambda>s. False)\\<^sub>\\<surd>", "qed auto"], ["proof (state)\nthis:\n  \\<lambda>cf.\n     snd cf =\n     (p, Label\n          l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'. cf'(rets' \n            [:=] map cf outs') =\n  et'\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case MainCallReturn"], ["proof (state)\nthis:\n  prog \\<turnstile> n_ -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p n'_\n  prog,procs \\<turnstile> (Main, n_) -et'\\<rightarrow> (Main, n'_)\n  well_formed procs\n\ngoal (2 subgoals):\n 1. \\<And>n p es rets n'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> (Main, n) -et'\\<rightarrow> (Main, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n 2. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "thus ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> n_ -CEdge (p_, es_, rets_)\\<rightarrow>\\<^sub>p n'_\n  prog,procs \\<turnstile> (Main, n_) -et'\\<rightarrow> (Main, n'_)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "by(auto elim:PCFG.cases dest:Proc_CFG_edge_det)"], ["proof (state)\nthis:\n  (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "case ProcCallReturn"], ["proof (state)\nthis:\n  (p_, ins_, outs_, c_) \\<in> set procs\n  c_ \\<turnstile> n_ -CEdge (p'_, es'_, rets'_)\\<rightarrow>\\<^sub>p n'_\n  containsCall procs prog ps_ p_\n  prog,procs \\<turnstile> (p_, n_) -et'\\<rightarrow> (p_, n'_)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs c n p' es' rets' n' ps.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> (p, n) -et'\\<rightarrow> (p, n');\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "thus ?case"], ["proof (prove)\nusing this:\n  (p_, ins_, outs_, c_) \\<in> set procs\n  c_ \\<turnstile> n_ -CEdge (p'_, es'_, rets'_)\\<rightarrow>\\<^sub>p n'_\n  containsCall procs prog ps_ p_\n  prog,procs \\<turnstile> (p_, n_) -et'\\<rightarrow> (p_, n'_)\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. False)\\<^sub>\\<surd> = et'", "by(auto elim:PCFG.cases dest:Proc_CFG_edge_det)"], ["proof (state)\nthis:\n  (\\<lambda>s. False)\\<^sub>\\<surd> = et'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proc_CFG_deterministic:\n  \"\\<lbrakk>prog,procs \\<turnstile> n\\<^sub>1 -et\\<^sub>1\\<rightarrow> n\\<^sub>1'; prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'; n\\<^sub>1 = n\\<^sub>2; n\\<^sub>1' \\<noteq> n\\<^sub>2'; \n   intra_kind et\\<^sub>1; intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Q Q'. et\\<^sub>1 = (Q)\\<^sub>\\<surd> \\<and> et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and> \n            (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prog,procs \\<turnstile> n\\<^sub>1 -et\\<^sub>1\\<rightarrow> n\\<^sub>1';\n     prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n     n\\<^sub>1 = n\\<^sub>2; n\\<^sub>1' \\<noteq> n\\<^sub>2';\n     intra_kind et\\<^sub>1; intra_kind et\\<^sub>2;\n     well_formed procs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Q Q'.\n                         et\\<^sub>1 = (Q)\\<^sub>\\<surd> \\<and>\n                         et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                         (\\<forall>s.\n                             (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                             (Q' s \\<longrightarrow> \\<not> Q s))", "proof(induct arbitrary:n\\<^sub>2 n\\<^sub>2' rule:PCFG.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n et n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind et; intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Main n et n')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  intra_kind et\n  intra_kind et\\<^sub>2\n  well_formed procs\n\ngoal (8 subgoals):\n 1. \\<And>n et n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind et; intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\\<close> \\<open>(Main,n) = n\\<^sub>2\\<close>\n    \\<open>intra_kind et\\<^sub>2\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (Main, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  well_formed procs", "obtain m m' where \"(Main,m) = n\\<^sub>2\" and \"(Main,m') = n\\<^sub>2'\"\n    and disj:\"prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or> \n    (\\<exists>p es rets. prog \\<turnstile> m -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (Main, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>(Main, m) = n\\<^sub>2; (Main, m') = n\\<^sub>2';\n         prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n         (\\<exists>p es rets.\n             prog \\<turnstile> m -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p m' \\<and>\n             et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct rule:PCFG.induct)(fastforce simp:intra_kind_def)+"], ["proof (state)\nthis:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p es rets.\n      prog \\<turnstile> m -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (8 subgoals):\n 1. \\<And>n et n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind et; intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 8. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from disj"], ["proof (chain)\npicking this:\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p es rets.\n      prog \\<turnstile> m -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p es rets.\n      prog \\<turnstile> m -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. prog \\<turnstile> m -IEdge\n                          et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\""], ["proof (state)\nthis:\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (2 subgoals):\n 1. prog \\<turnstile> m -IEdge\n                          et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(Main,m) = n\\<^sub>2\\<close> \\<open>(Main,m') = n\\<^sub>2'\\<close> \n      \\<open>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(Main,n) = n\\<^sub>2\\<close> \\<open>(Main,n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(auto dest:WCFG_deterministic)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"\\<exists>p es rets. prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  \\<exists>p es rets.\n     prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(Main,m) = n\\<^sub>2\\<close> \\<open>(Main,m') = n\\<^sub>2'\\<close> \n      \\<open>prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(Main,n) = n\\<^sub>2\\<close> \\<open>(Main,n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p es rets.\n     prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>", "have False"], ["proof (prove)\nusing this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p es rets.\n     prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (Proc p ins outs c n et n')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps_ p\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  intra_kind et\n  intra_kind et\\<^sub>2\n  well_formed procs\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\\<close> \\<open>(p,n) = n\\<^sub>2\\<close> \\<open>intra_kind et\\<^sub>2\\<close>\n    \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (p, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "obtain m m' where \"(p,m) = n\\<^sub>2\" and \"(p,m') = n\\<^sub>2'\"\n    and disj:\"c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or> \n    (\\<exists>p' es' rets'. c \\<turnstile> m -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (p, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>(p, m) = n\\<^sub>2; (p, m') = n\\<^sub>2';\n         c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n         (\\<exists>p' es' rets'.\n             c \\<turnstile> m -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p m' \\<and>\n             et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct rule:PCFG.induct)(fastforce simp:intra_kind_def)+"], ["proof (state)\nthis:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p' es' rets'.\n      c \\<turnstile> m -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (7 subgoals):\n 1. \\<And>p ins outs c n et n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2'; intra_kind et;\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            et = (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 7. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from disj"], ["proof (chain)\npicking this:\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p' es' rets'.\n      c \\<turnstile> m -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)", "show ?case"], ["proof (prove)\nusing this:\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p' es' rets'.\n      c \\<turnstile> m -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<turnstile> m -IEdge\n                       et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\""], ["proof (state)\nthis:\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (2 subgoals):\n 1. c \\<turnstile> m -IEdge\n                       et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(p,m) = n\\<^sub>2\\<close> \\<open>(p,m') = n\\<^sub>2'\\<close> \n      \\<open>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(p,n) = n\\<^sub>2\\<close> \\<open>(p,n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'", "show ?thesis"], ["proof (prove)\nusing this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(auto dest:WCFG_deterministic)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"\\<exists>p' es' rets'. c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  \\<exists>p' es' rets'.\n     c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(p,m) = n\\<^sub>2\\<close> \\<open>(p,m') = n\\<^sub>2'\\<close> \n      \\<open>c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(p,n) = n\\<^sub>2\\<close> \\<open>(p,n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p' es' rets'.\n     c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>", "have False"], ["proof (prove)\nusing this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -IEdge et\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p' es' rets'.\n     c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       et = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     et = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (MainCallReturn n p es rets n' n\\<^sub>2 n\\<^sub>2')"], ["proof (state)\nthis:\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  intra_kind et\\<^sub>2\n  well_formed procs\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\\<close> \\<open>(Main,n) = n\\<^sub>2\\<close>\n    \\<open>intra_kind et\\<^sub>2\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (Main, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  well_formed procs", "obtain m m' where \"(Main,m) = n\\<^sub>2\" and \"(Main,m') = n\\<^sub>2'\"\n    and disj:\"prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or> \n    (\\<exists>p es rets. prog \\<turnstile> m -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (Main, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>(Main, m) = n\\<^sub>2; (Main, m') = n\\<^sub>2';\n         prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n         (\\<exists>p es rets.\n             prog \\<turnstile> m -CEdge\n                                   (p, es,\n                                    rets)\\<rightarrow>\\<^sub>p m' \\<and>\n             et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct rule:PCFG.induct)(fastforce simp:intra_kind_def)+"], ["proof (state)\nthis:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p es rets.\n      prog \\<turnstile> m -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (6 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>n p es rets n' n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> n -CEdge\n(p, es, rets)\\<rightarrow>\\<^sub>p n';\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, n) = n\\<^sub>2; (Main, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 6. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from disj"], ["proof (chain)\npicking this:\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p es rets.\n      prog \\<turnstile> m -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)", "show ?case"], ["proof (prove)\nusing this:\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p es rets.\n      prog \\<turnstile> m -CEdge\n                            (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. prog \\<turnstile> m -IEdge\n                          et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\""], ["proof (state)\nthis:\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (2 subgoals):\n 1. prog \\<turnstile> m -IEdge\n                          et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(Main,m) = n\\<^sub>2\\<close> \\<open>(Main,m') = n\\<^sub>2'\\<close> \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n      \\<open>(Main, n) = n\\<^sub>2\\<close> \\<open>(Main, n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'", "have False"], ["proof (prove)\nusing this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  prog \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. prog \\<turnstile> m -IEdge\n                          et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"\\<exists>p es rets. prog \\<turnstile> m -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  \\<exists>p es rets.\n     prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>p es rets.\n       prog \\<turnstile> m -CEdge\n                             (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(Main,m) = n\\<^sub>2\\<close> \\<open>(Main,m') = n\\<^sub>2'\\<close> \\<open>prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<close>\n      \\<open>(Main, n) = n\\<^sub>2\\<close> \\<open>(Main, n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p es rets.\n     prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  (Main, m) = n\\<^sub>2\n  (Main, m') = n\\<^sub>2'\n  prog \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n  (Main, n) = n\\<^sub>2\n  (Main, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p es rets.\n     prog \\<turnstile> m -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(fastforce dest:Proc_CFG_Call_nodes_eq)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (ProcCallReturn p ins outs c n p' es rets n' ps n\\<^sub>2 n\\<^sub>2')"], ["proof (state)\nthis:\n  (p, ins, outs, c) \\<in> set procs\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  containsCall procs prog ps p\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>\n  intra_kind et\\<^sub>2\n  well_formed procs\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\\<close> \\<open>(p,n) = n\\<^sub>2\\<close> \\<open>intra_kind et\\<^sub>2\\<close>\n    \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (p, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs", "obtain m m' where \"(p,m) = n\\<^sub>2\" and \"(p,m') = n\\<^sub>2'\"\n    and disj:\"c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or> \n    (\\<exists>p' es' rets'. c \\<turnstile> m -CEdge (p',es',rets')\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\""], ["proof (prove)\nusing this:\n  prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2'\n  (p, n) = n\\<^sub>2\n  intra_kind et\\<^sub>2\n  (p, ins, outs, c) \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        \\<lbrakk>(p, m) = n\\<^sub>2; (p, m') = n\\<^sub>2';\n         c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n         (\\<exists>p' es' rets'.\n             c \\<turnstile> m -CEdge\n                                (p', es',\n                                 rets')\\<rightarrow>\\<^sub>p m' \\<and>\n             et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(induct rule:PCFG.induct)(fastforce simp:intra_kind_def)+"], ["proof (state)\nthis:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p' es' rets'.\n      c \\<turnstile> m -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (5 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 5. \\<And>p ins outs c n p' es' rets' n' ps n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> n -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p n';\n        containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, n) = n\\<^sub>2; (p, n') \\<noteq> n\\<^sub>2';\n        intra_kind (\\<lambda>s. False)\\<^sub>\\<surd>; intra_kind et\\<^sub>2;\n        well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            (\\<lambda>s. False)\\<^sub>\\<surd> =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from disj"], ["proof (chain)\npicking this:\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p' es' rets'.\n      c \\<turnstile> m -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)", "show ?case"], ["proof (prove)\nusing this:\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<or>\n  (\\<exists>p' es' rets'.\n      c \\<turnstile> m -CEdge\n                         (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n      et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<turnstile> m -IEdge\n                       et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\""], ["proof (state)\nthis:\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (2 subgoals):\n 1. c \\<turnstile> m -IEdge\n                       et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(p,m) = n\\<^sub>2\\<close> \\<open>(p,m') = n\\<^sub>2'\\<close> \n      \\<open>c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(p,n) = n\\<^sub>2\\<close> \\<open>(p,n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'", "have False"], ["proof (prove)\nusing this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  c \\<turnstile> m -IEdge et\\<^sub>2\\<rightarrow>\\<^sub>p m'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:Proc_CFG_Call_Intra_edge_not_same_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. c \\<turnstile> m -IEdge\n                       et\\<^sub>2\\<rightarrow>\\<^sub>p m' \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"\\<exists>p' es' rets'. c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and> et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  \\<exists>p' es' rets'.\n     c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>p' es' rets'.\n       c \\<turnstile> m -CEdge\n                          (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n       et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>(p,m) = n\\<^sub>2\\<close> \\<open>(p,m') = n\\<^sub>2'\\<close> \n      \\<open>c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\\<close> \\<open>(p,n) = n\\<^sub>2\\<close> \\<open>(p,n') \\<noteq> n\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p' es' rets'.\n     c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  (p, m) = n\\<^sub>2\n  (p, m') = n\\<^sub>2'\n  c \\<turnstile> n -CEdge (p', es, rets)\\<rightarrow>\\<^sub>p n'\n  (p, n) = n\\<^sub>2\n  (p, n') \\<noteq> n\\<^sub>2'\n  \\<exists>p' es' rets'.\n     c \\<turnstile> m -CEdge (p', es', rets')\\<rightarrow>\\<^sub>p m' \\<and>\n     et\\<^sub>2 = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n       et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(fastforce dest:Proc_CFG_Call_nodes_eq)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     (\\<lambda>s. False)\\<^sub>\\<surd> = (Q)\\<^sub>\\<surd> \\<and>\n     et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (4 subgoals):\n 1. \\<And>l p es rets n' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p n';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (Main, Label l) = n\\<^sub>2; (p, Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(Main,\n                   n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map interpret es);\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(Main,\n                                     n')\\<hookrightarrow>\\<^bsub>p\\<^esub>map\n                                     interpret es =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Label l) = n\\<^sub>2; (p', Entry) \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>s.\n             True:(p, Label\n                       l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret\n                        es');\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>s.\n                               True:(p, Label\n   l')\\<hookrightarrow>\\<^bsub>p'\\<^esub>map interpret es' =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>l p es rets l' ins outs c n\\<^sub>2 n\\<^sub>2'.\n       \\<lbrakk>prog \\<turnstile> Label\n                                   l -CEdge\n (p, es, rets)\\<rightarrow>\\<^sub>p Label l';\n        (p, ins, outs, c) \\<in> set procs;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p, Exit) = n\\<^sub>2; (Main, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (Main,\n              Label\n               l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n                cf'(rets [:=] map cf outs));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (Main,\n                                Label\n                                 l')\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf\n                                  cf'. cf'(rets [:=] map cf outs) =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>p ins outs c l p' es' rets' l' ins' outs' c' ps n\\<^sub>2\n       n\\<^sub>2'.\n       \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n        c \\<turnstile> Label\n                        l -CEdge\n                            (p', es', rets')\\<rightarrow>\\<^sub>p Label l';\n        (p', ins', outs', c') \\<in> set procs; containsCall procs prog ps p;\n        prog,procs \\<turnstile> n\\<^sub>2 -et\\<^sub>2\\<rightarrow> n\\<^sub>2';\n        (p', Exit) = n\\<^sub>2; (p, Label l') \\<noteq> n\\<^sub>2';\n        intra_kind\n         (\\<lambda>cf.\n             snd cf =\n             (p, Label\n                  l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf cf'.\n                    cf'(rets' [:=] map cf outs'));\n        intra_kind et\\<^sub>2; well_formed procs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            \\<lambda>cf.\n                               snd cf =\n                               (p, Label\n                                    l')\\<hookleftarrow>\\<^bsub>p'\\<^esub>\\<lambda>cf\ncf'. cf'(rets' [:=] map cf outs') =\n                            (Q)\\<^sub>\\<surd> \\<and>\n                            et\\<^sub>2 = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "qed(auto simp:intra_kind_def)"], ["", "subsection \\<open>Well-formedness of programs in combination with a procedure list.\\<close>"], ["", "definition wf :: \"cmd \\<Rightarrow> procs \\<Rightarrow> bool\"\n  where \"wf prog procs \\<equiv> well_formed procs \\<and> \n  (\\<forall>ps p. containsCall procs prog ps p \\<longrightarrow> (\\<exists>ins outs c. (p,ins,outs,c) \\<in> set procs \\<and> \n          (\\<forall>c' n n' es rets. c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n               distinct rets \\<and> length rets = length outs \\<and> length es = length ins)))\""], ["", "lemma wf_well_formed [intro]:\"wf prog procs \\<Longrightarrow> well_formed procs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WellFormProgs.wf prog procs \\<Longrightarrow> well_formed procs", "by(simp add:wf_def)"], ["", "lemma wf_distinct_rets [intro]:\n  \"\\<lbrakk>wf prog procs; containsCall procs prog ps p; (p,ins,outs,c) \\<in> set procs;\n    c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk> \\<Longrightarrow> distinct rets\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>WellFormProgs.wf prog procs; containsCall procs prog ps p;\n     (p, ins, outs, c) \\<in> set procs;\n     c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\\<rbrakk>\n    \\<Longrightarrow> distinct rets", "by(fastforce simp:wf_def)"], ["", "lemma\n  assumes \"wf prog procs\" and \"containsCall procs prog ps p\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"c' \\<turnstile> n -CEdge (p,es,rets)\\<rightarrow>\\<^sub>p n'\"\n  shows wf_length_retsI [intro]:\"length rets = length outs\"\n  and wf_length_esI [intro]:\"length es = length ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rets = length outs &&& length es = length ins", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. length rets = length outs\n 2. length es = length ins", "from \\<open>wf prog procs\\<close>"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs", "have \"well_formed procs\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n\ngoal (1 subgoal):\n 1. well_formed procs", "by fastforce"], ["proof (state)\nthis:\n  well_formed procs\n\ngoal (2 subgoals):\n 1. length rets = length outs\n 2. length es = length ins", "from assms"], ["proof (chain)\npicking this:\n  WellFormProgs.wf prog procs\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'", "obtain ins' outs' c' where \"(p,ins',outs',c') \\<in> set procs\"\n    and lengths:\"length rets = length outs'\" \"length es = length ins'\""], ["proof (prove)\nusing this:\n  WellFormProgs.wf prog procs\n  containsCall procs prog ps p\n  (p, ins, outs, c) \\<in> set procs\n  c' \\<turnstile> n -CEdge (p, es, rets)\\<rightarrow>\\<^sub>p n'\n\ngoal (1 subgoal):\n 1. (\\<And>ins' outs' c'.\n        \\<lbrakk>(p, ins', outs', c') \\<in> set procs;\n         length rets = length outs'; length es = length ins'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add:wf_def) blast"], ["proof (state)\nthis:\n  (p, ins', outs', c') \\<in> set procs\n  length rets = length outs'\n  length es = length ins'\n\ngoal (2 subgoals):\n 1. length rets = length outs\n 2. length es = length ins", "from \\<open>(p,ins,outs,c) \\<in> set procs\\<close> \\<open>(p,ins',outs',c') \\<in> set procs\\<close>\n    \\<open>well_formed procs\\<close>"], ["proof (chain)\npicking this:\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  well_formed procs", "have \"ins' = ins\" \"outs' = outs\" \"c' = c\""], ["proof (prove)\nusing this:\n  (p, ins, outs, c) \\<in> set procs\n  (p, ins', outs', c') \\<in> set procs\n  well_formed procs\n\ngoal (1 subgoal):\n 1. ins' = ins &&& outs' = outs &&& c' = c", "by auto"], ["proof (state)\nthis:\n  ins' = ins\n  outs' = outs\n  c' = c\n\ngoal (2 subgoals):\n 1. length rets = length outs\n 2. length es = length ins", "with lengths"], ["proof (chain)\npicking this:\n  length rets = length outs'\n  length es = length ins'\n  ins' = ins\n  outs' = outs\n  c' = c", "show \"length rets = length outs\" \"length es = length ins\""], ["proof (prove)\nusing this:\n  length rets = length outs'\n  length es = length ins'\n  ins' = ins\n  outs' = outs\n  c' = c\n\ngoal (1 subgoal):\n 1. length rets = length outs &&& length es = length ins", "by simp_all"], ["proof (state)\nthis:\n  length rets = length outs\n  length es = length ins\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Type of well-formed programs\\<close>"], ["", "definition \"wf_prog = {(prog,procs). wf prog procs}\""], ["", "typedef wf_prog = wf_prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> wf_prog", "unfolding wf_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {(x, y). WellFormProgs.wf x y}", "apply (rule_tac x=\"(Skip,[])\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Skip, []) \\<in> {(x, y). WellFormProgs.wf x y}", "apply (simp add:wf_def well_formed_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_wf_prog:\"Rep_wf_prog wfp = (prog,procs) \\<Longrightarrow> wf prog procs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n    WellFormProgs.wf prog procs", "using Rep_wf_prog[of wfp]"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp \\<in> wf_prog\n\ngoal (1 subgoal):\n 1. Rep_wf_prog wfp = (prog, procs) \\<Longrightarrow>\n    WellFormProgs.wf prog procs", "by(simp add:wf_prog_def)"], ["", "lemma wfp_Seq1: assumes \"Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases wfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>wfp'.\n                   Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n                   thesis;\n        Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs);\n        wfp = Abs_wf_prog y; y \\<in> wf_prog\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>wfp'.\n                Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n                thesis;\n     wfp = Abs_wf_prog (c\\<^sub>1;; c\\<^sub>2, procs); well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins)))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"Abs_wf_prog (c\\<^sub>1, procs)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp = Abs_wf_prog (c\\<^sub>1;; c\\<^sub>2, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and> length es = length ins)));\n     Rep_wf_prog (Abs_wf_prog (c\\<^sub>1, procs)) =\n     (c\\<^sub>1, procs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto elim:meta_mp simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["", "lemma wfp_Seq2: assumes \"Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>2, procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\\<close>"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases wfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>wfp'.\n                   Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n                   thesis;\n        Rep_wf_prog wfp = (c\\<^sub>1;; c\\<^sub>2, procs);\n        wfp = Abs_wf_prog y; y \\<in> wf_prog\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>wfp'.\n                Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n                thesis;\n     wfp = Abs_wf_prog (c\\<^sub>1;; c\\<^sub>2, procs); well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins)))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"Abs_wf_prog (c\\<^sub>2, procs)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp = Abs_wf_prog (c\\<^sub>1;; c\\<^sub>2, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and> length es = length ins)));\n     Rep_wf_prog (Abs_wf_prog (c\\<^sub>2, procs)) =\n     (c\\<^sub>2, procs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto elim:meta_mp simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["", "lemma wfp_CondTrue: assumes \"Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>1, procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\\<close>"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases wfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>wfp'.\n                   Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n                   thesis;\n        Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs);\n        wfp = Abs_wf_prog y; y \\<in> wf_prog\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>wfp'.\n                Rep_wf_prog wfp' = (c\\<^sub>1, procs) \\<Longrightarrow>\n                thesis;\n     wfp = Abs_wf_prog (if (b) c\\<^sub>1 else c\\<^sub>2, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins)))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"Abs_wf_prog (c\\<^sub>1, procs)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp = Abs_wf_prog (if (b) c\\<^sub>1 else c\\<^sub>2, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and> length es = length ins)));\n     Rep_wf_prog (Abs_wf_prog (c\\<^sub>1, procs)) =\n     (c\\<^sub>1, procs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto elim:meta_mp simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["", "lemma wfp_CondFalse: assumes \"Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c\\<^sub>2, procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\\<close>"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases wfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>wfp'.\n                   Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n                   thesis;\n        Rep_wf_prog wfp = (if (b) c\\<^sub>1 else c\\<^sub>2, procs);\n        wfp = Abs_wf_prog y; y \\<in> wf_prog\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>wfp'.\n                Rep_wf_prog wfp' = (c\\<^sub>2, procs) \\<Longrightarrow>\n                thesis;\n     wfp = Abs_wf_prog (if (b) c\\<^sub>1 else c\\<^sub>2, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins)))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"Abs_wf_prog (c\\<^sub>2, procs)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp = Abs_wf_prog (if (b) c\\<^sub>1 else c\\<^sub>2, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        (containsCall procs c\\<^sub>1 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and>\n                 length es = length ins))) \\<and>\n        (containsCall procs c\\<^sub>2 ps p \\<longrightarrow>\n         (\\<exists>ins outs.\n             (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n             (\\<forall>c' n n' es rets.\n                 c' \\<turnstile> n -CEdge\n                                     (p, es,\nrets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                 distinct rets \\<and>\n                 length rets = length outs \\<and> length es = length ins)));\n     Rep_wf_prog (Abs_wf_prog (c\\<^sub>2, procs)) =\n     (c\\<^sub>2, procs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto elim:meta_mp simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["", "lemma wfp_WhileBody: assumes \"Rep_wf_prog wfp = (while (b) c', procs)\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c', procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c', procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Rep_wf_prog wfp = (while (b) c', procs)\\<close>"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (while (b) c', procs)\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c', procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases wfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>wfp'.\n                   Rep_wf_prog wfp' = (c', procs) \\<Longrightarrow> thesis;\n        Rep_wf_prog wfp = (while (b) c', procs); wfp = Abs_wf_prog y;\n        y \\<in> wf_prog\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>wfp'.\n                Rep_wf_prog wfp' = (c', procs) \\<Longrightarrow> thesis;\n     wfp = Abs_wf_prog (while (b) c', procs); well_formed procs;\n     \\<forall>ps p.\n        containsCall procs c' ps p \\<longrightarrow>\n        (\\<exists>ins outs.\n            (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n            (\\<forall>c' n n' es rets.\n                c' \\<turnstile> n -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                distinct rets \\<and>\n                length rets = length outs \\<and>\n                length es = length ins))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"Abs_wf_prog (c', procs)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp = Abs_wf_prog (while (b) c', procs); well_formed procs;\n     \\<forall>ps p.\n        containsCall procs c' ps p \\<longrightarrow>\n        (\\<exists>ins outs.\n            (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n            (\\<forall>c' n n' es rets.\n                c' \\<turnstile> n -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                distinct rets \\<and>\n                length rets = length outs \\<and> length es = length ins));\n     Rep_wf_prog (Abs_wf_prog (c', procs)) = (c', procs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(auto elim:meta_mp simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["", "lemma wfp_Call: assumes \"Rep_wf_prog wfp = (prog,procs)\"\n  and \"(p,ins,outs,c) \\<in> set procs\" and \"containsCall procs prog ps p\"\n  obtains wfp' where \"Rep_wf_prog wfp' = (c,procs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Rep_wf_prog wfp = (prog, procs)\n  (p, ins, outs, c) \\<in> set procs\n  containsCall procs prog ps p\n\ngoal (1 subgoal):\n 1. (\\<And>wfp'.\n        Rep_wf_prog wfp' = (c, procs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases wfp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<And>wfp'.\n                   Rep_wf_prog wfp' = (c, procs) \\<Longrightarrow> thesis;\n        Rep_wf_prog wfp = (prog, procs); (p, ins, outs, c) \\<in> set procs;\n        containsCall procs prog ps p; wfp = Abs_wf_prog y;\n        y \\<in> wf_prog\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:Abs_wf_prog_inverse wf_prog_def wf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>wfp'.\n                Rep_wf_prog wfp' = (c, procs) \\<Longrightarrow> thesis;\n     (p, ins, outs, c) \\<in> set procs; containsCall procs prog ps p;\n     wfp = Abs_wf_prog (prog, procs); well_formed procs;\n     \\<forall>ps p.\n        containsCall procs prog ps p \\<longrightarrow>\n        (\\<exists>ins outs.\n            (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n            (\\<forall>c' n n' es rets.\n                c' \\<turnstile> n -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                distinct rets \\<and>\n                length rets = length outs \\<and>\n                length es = length ins))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule_tac x=\"Abs_wf_prog (c, procs)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n     containsCall procs prog ps p; wfp = Abs_wf_prog (prog, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        containsCall procs prog ps p \\<longrightarrow>\n        (\\<exists>ins outs.\n            (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n            (\\<forall>c' n n' es rets.\n                c' \\<turnstile> n -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                distinct rets \\<and>\n                length rets = length outs \\<and> length es = length ins));\n     Rep_wf_prog (Abs_wf_prog (c, procs)) = (c, procs) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(erule meta_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n     containsCall procs prog ps p; wfp = Abs_wf_prog (prog, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        containsCall procs prog ps p \\<longrightarrow>\n        (\\<exists>ins outs.\n            (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n            (\\<forall>c' n n' es rets.\n                c' \\<turnstile> n -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                distinct rets \\<and>\n                length rets = length outs \\<and>\n                length es = length ins))\\<rbrakk>\n    \\<Longrightarrow> Rep_wf_prog (Abs_wf_prog (c, procs)) = (c, procs)", "apply(rule Abs_wf_prog_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, ins, outs, c) \\<in> set procs;\n     containsCall procs prog ps p; wfp = Abs_wf_prog (prog, procs);\n     well_formed procs;\n     \\<forall>ps p.\n        containsCall procs prog ps p \\<longrightarrow>\n        (\\<exists>ins outs.\n            (\\<exists>c. (p, ins, outs, c) \\<in> set procs) \\<and>\n            (\\<forall>c' n n' es rets.\n                c' \\<turnstile> n -CEdge\n                                    (p, es,\n                                     rets)\\<rightarrow>\\<^sub>p n' \\<longrightarrow>\n                distinct rets \\<and>\n                length rets = length outs \\<and>\n                length es = length ins))\\<rbrakk>\n    \\<Longrightarrow> (c, procs) \\<in> wf_prog", "by(auto dest:containsCall_indirection simp:wf_prog_def wf_def)"], ["", "end"]]}