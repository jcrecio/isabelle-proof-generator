{"file_name": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine/UF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine", "problem_names": ["lemma add_lemma: \"\\<And> x y. rec_exec rec_add [x, y] =  x + y\"", "lemma mult_lemma: \"\\<And> x y. rec_exec rec_mult [x, y] = x * y\"", "lemma pred_lemma: \"\\<And> x. rec_exec rec_pred [x] =  x - 1\"", "lemma minus_lemma: \"\\<And> x y. rec_exec rec_minus [x, y] = x - y\"", "lemma sg_lemma: \"\\<And> x. rec_exec rec_sg [x] = (if x = 0 then 0 else 1)\"", "lemma constn_lemma: \"rec_exec (constn n) [x] = n\"", "lemma less_lemma: \"\\<And> x y. rec_exec rec_less [x, y] = \n  (if x < y then 1 else 0)\"", "lemma not_lemma: \n  \"\\<And> x. rec_exec rec_not [x] = (if x = 0 then 1 else 0)\"", "lemma eq_lemma: \"\\<And> x y. rec_exec rec_eq [x, y] = (if x = y then 1 else 0)\"", "lemma conj_lemma: \"\\<And> x y. rec_exec rec_conj [x, y] = (if x = 0 \\<or> y = 0 then 0 \n                                                       else 1)\"", "lemma disj_lemma: \"\\<And> x y. rec_exec rec_disj [x, y] = (if x = 0 \\<and> y = 0 then 0\n                                                     else 1)\"", "lemma rec_pr_Suc_simp_rewrite: \n  \"rec_exec (Pr n f g) (xs @ [Suc x]) =\n                       rec_exec g (xs @ [x] @ \n                        [rec_exec (Pr n f g) (xs @ [x])])\"", "lemma Sigma_0_simp_rewrite:\n  \"Sigma f (xs @ [0]) = f (xs @ [0])\"", "lemma Sigma_Suc_simp_rewrite: \n  \"Sigma f (xs @ [Suc x]) = Sigma f (xs @ [x]) + f (xs @ [Suc x])\"", "lemma append_access_1[simp]: \"(xs @ ys) ! (Suc (length xs)) = ys ! 1\"", "lemma get_fstn_args_take: \"\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk> \\<Longrightarrow> \n  map (\\<lambda> f. rec_exec f xs) (get_fstn_args m n)= take n xs\"", "lemma arity_primerec[simp]: \"primerec f n \\<Longrightarrow> arity f = n\"", "lemma rec_sigma_Suc_simp_rewrite: \n  \"primerec f (Suc (length xs))\n    \\<Longrightarrow> rec_exec (rec_sigma f) (xs @ [Suc x]) = \n    rec_exec (rec_sigma f) (xs @ [x]) + rec_exec f (xs @ [Suc x])\"", "lemma sigma_lemma: \n  \"primerec rg (Suc (length xs))\n     \\<Longrightarrow> rec_exec (rec_sigma rg) (xs @ [x]) = Sigma (rec_exec rg) (xs @ [x])\"", "lemma rec_accum_Suc_simp_rewrite: \n  \"primerec f (Suc (length xs))\n    \\<Longrightarrow> rec_exec (rec_accum f) (xs @ [Suc x]) = \n    rec_exec (rec_accum f) (xs @ [x]) * rec_exec f (xs @ [Suc x])\"", "lemma accum_lemma :\n  \"primerec rg (Suc (length xs))\n     \\<Longrightarrow> rec_exec (rec_accum rg) (xs @ [x]) = Accum (rec_exec rg) (xs @ [x])\"", "lemma rec_accum_ex:\n  assumes \"primerec rf (Suc (length xs))\"\n  shows \"(rec_exec (rec_accum rf) (xs @ [x]) = 0) = \n         (\\<exists> t \\<le> x. rec_exec rf (xs @ [t]) = 0)\"", "lemma all_lemma: \n  \"\\<lbrakk>primerec rf (Suc (length xs));\n    primerec rt (length xs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_all rt rf) xs = (if (\\<forall> x \\<le> (rec_exec rt xs). 0 < rec_exec rf (xs @ [x])) then 1\n                                                                                              else 0)\"", "lemma rec_sigma_ex: \n  assumes \"primerec rf (Suc (length xs))\"\n  shows \"(rec_exec (rec_sigma rf) (xs @ [x]) = 0) = \n                          (\\<forall> t \\<le> x. rec_exec rf (xs @ [t]) = 0)\"", "lemma ex_lemma:\"\n  \\<lbrakk>primerec rf (Suc (length xs));\n   primerec rt (length xs)\\<rbrakk>\n\\<Longrightarrow> (rec_exec (rec_ex rt rf) xs =\n    (if (\\<exists> x \\<le> (rec_exec rt xs). 0 <rec_exec rf (xs @ [x])) then 1\n     else 0))\"", "lemma Minr_range: \"Minr Rr xs w \\<le> w \\<or> Minr Rr xs w = Suc w\"", "lemma expand_conj_in_set: \"{x. x \\<le> Suc w \\<and> Rr (xs @ [x])}\n    = (if Rr (xs @ [Suc w]) then insert (Suc w) \n                              {x. x \\<le> w \\<and> Rr (xs @ [x])}\n      else {x. x \\<le> w \\<and> Rr (xs @ [x])})\"", "lemma Minr_strip_Suc[simp]: \"Minr Rr xs w \\<le> w \\<Longrightarrow> Minr Rr xs (Suc w) = Minr Rr xs w\"", "lemma x_empty_set[simp]: \"\\<forall>x\\<le>w. \\<not> Rr (xs @ [x]) \\<Longrightarrow>  \n                           {x. x \\<le> w \\<and> Rr (xs @ [x])} = {} \"", "lemma Minr_is_Suc[simp]: \"\\<lbrakk>Minr Rr xs w = Suc w; Rr (xs @ [Suc w])\\<rbrakk> \\<Longrightarrow> \n                                       Minr Rr xs (Suc w) = Suc w\"", "lemma Minr_is_Suc_Suc[simp]: \"\\<lbrakk>Minr Rr xs w = Suc w; \\<not> Rr (xs @ [Suc w])\\<rbrakk> \\<Longrightarrow> \n                                   Minr Rr xs (Suc w) = Suc (Suc w)\"", "lemma Minr_Suc_simp: \n  \"Minr Rr xs (Suc w) = \n      (if Minr Rr xs w \\<le> w then Minr Rr xs w\n       else if (Rr (xs @ [Suc w])) then (Suc w)\n       else Suc (Suc w))\"", "lemma length_getpren_params[simp]: \"length (get_fstn_args m n) = n\"", "lemma length_app:\n  \"(length (get_fstn_args (arity rf - Suc 0)\n                           (arity rf - Suc 0)\n   @ [Cn (arity rf - Suc 0) (constn 0)\n           [recf.id (arity rf - Suc 0) 0]]))\n    = (Suc (arity rf - Suc 0))\"", "lemma primerec_accum: \"primerec (rec_accum rf) n \\<Longrightarrow> primerec rf n\"", "lemma primerec_all: \"primerec (rec_all rt rf) n \\<Longrightarrow>\n                       primerec rt n \\<and> primerec rf (Suc n)\"", "lemma primerec_rec_pred_1[intro]: \"primerec rec_pred (Suc 0)\"", "lemma primerec_rec_minus_2[intro]: \"primerec rec_minus (Suc (Suc 0))\"", "lemma primerec_constn_1[intro]: \"primerec (constn n) (Suc 0)\"", "lemma primerec_rec_sg_1[intro]: \"primerec rec_sg (Suc 0)\"", "lemma primerec_getpren[elim]: \"\\<lbrakk>i < n; n \\<le> m\\<rbrakk> \\<Longrightarrow> primerec (get_fstn_args m n ! i) m\"", "lemma primerec_rec_add_2[intro]: \"primerec rec_add (Suc (Suc 0))\"", "lemma primerec_rec_mult_2[intro]:\"primerec rec_mult (Suc (Suc 0))\"", "lemma primerec_ge_2_elim[elim]: \"\\<lbrakk>primerec rf n; n \\<ge> Suc (Suc 0)\\<rbrakk>   \\<Longrightarrow> \n                        primerec (rec_accum rf) n\"", "lemma primerec_all_iff: \n  \"\\<lbrakk>primerec rt n; primerec rf (Suc n); n > 0\\<rbrakk> \\<Longrightarrow> \n                                 primerec (rec_all rt rf) n\"", "lemma primerec_rec_not_1[intro]: \"primerec rec_not (Suc 0)\"", "lemma Min_false1[simp]: \"\\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])} \\<le> w;\n       x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n      \\<Longrightarrow>  False\"", "lemma sigma_minr_lemma: \n  assumes prrf:  \"primerec rf (Suc (length xs))\"\n  shows \"UF.Sigma (rec_exec (rec_all (recf.id (Suc (length xs)) (length xs))\n     (Cn (Suc (Suc (length xs))) rec_not\n      [Cn (Suc (Suc (length xs))) rf (get_fstn_args (Suc (Suc (length xs))) \n       (length xs) @ [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n      (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w\"", "lemma Minr_lemma: \"\n  \\<lbrakk>primerec rf (Suc (length xs))\\<rbrakk> \n     \\<Longrightarrow> rec_exec (rec_Minr rf) (xs @ [w]) = \n            Minr (\\<lambda> args. (0 < rec_exec rf args)) xs w\"", "lemma le_lemma: \n  \"\\<And>x y. rec_exec rec_le [x, y] = (if (x \\<le> y) then 1 else 0)\"", "lemma primerec_rec_disj_2[intro]: \"primerec rec_disj (Suc (Suc 0))\"", "lemma primerec_rec_less_2[intro]: \"primerec rec_less (Suc (Suc 0))\"", "lemma primerec_rec_eq_2[intro]: \"primerec rec_eq (Suc (Suc 0))\"", "lemma primerec_rec_le_2[intro]: \"primerec rec_le (Suc (Suc 0))\"", "lemma Sigma_0: \"\\<forall> i \\<le> n. (f (xs @ [i]) = 0) \\<Longrightarrow> \n                              Sigma f (xs @ [n]) = 0\"", "lemma Sigma_Suc[elim]: \"\\<forall>k<Suc w. f (xs @ [k]) = Suc 0\n        \\<Longrightarrow> Sigma f (xs @ [w]) = Suc w\"", "lemma Sigma_max_point: \"\\<lbrakk>\\<forall> k < ma. f (xs @ [k]) = 1;\n        \\<forall> k \\<ge> ma. f (xs @ [k]) = 0; ma \\<le> w\\<rbrakk>\n    \\<Longrightarrow> Sigma f (xs @ [w]) = ma\"", "lemma Sigma_Max_lemma: \n  assumes prrf: \"primerec rf (Suc (length xs))\"\n  shows \"UF.Sigma (rec_exec (Cn (Suc (Suc (length xs))) rec_not\n  [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n  (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n  [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))), \n  recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n  Cn (Suc (Suc (Suc (length xs)))) rec_not\n  [Cn (Suc (Suc (Suc (length xs)))) rf\n  (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @ \n  [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n  ((xs @ [w]) @ [w]) =\n       Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\"", "lemma Maxr_lemma:\n  assumes h: \"primerec rf (Suc (length xs))\"\n  shows   \"rec_exec (rec_maxr rf) (xs @ [w]) = \n            Maxr (\\<lambda> args. 0 < rec_exec rf args) xs w\"", "lemma quo_is_div: \"y > 0 \\<Longrightarrow> quo [x, y] = x div y\"", "lemma quo_zero[intro]: \"quo [x, 0] = 0\"", "lemma quo_div: \"quo [x, y] = x div y\"", "lemma noteq_lemma: \n  \"\\<And> x y. rec_exec rec_noteq [x, y] = \n               (if x \\<noteq> y then 1 else 0)\"", "lemma primerec_rec_conj_2[intro]: \"primerec rec_conj (Suc (Suc 0))\"", "lemma primerec_rec_noteq_2[intro]: \"primerec rec_noteq (Suc (Suc 0))\"", "lemma quo_lemma1: \"rec_exec rec_quo [x, y] = quo [x, y]\"", "lemma quo_lemma2: \"rec_exec rec_quo [x, y] = x div y\"", "lemma mod_lemma: \"\\<And> x y. rec_exec rec_mod [x, y] = (x mod y)\"", "lemma embranch_all0: \n  \"\\<lbrakk>\\<forall> j < length rcs. rec_exec (rcs ! j) xs = 0;\n    length rgs = length rcs;  \n  rcs \\<noteq> []; \n  list_all (\\<lambda> rf. primerec rf (length xs)) (rgs @ rcs)\\<rbrakk>  \\<Longrightarrow> \n  rec_exec (rec_embranch (zip rgs rcs)) xs = 0\"", "lemma embranch_exec_0: \"\\<lbrakk>rec_exec aa xs = 0; zip rgs list \\<noteq> []; \n       list_all (\\<lambda> rf. primerec rf (length xs)) ([a, aa] @ rgs @ list)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs\n         = rec_exec (rec_embranch (zip rgs list)) xs\"", "lemma zip_null_iff: \"\\<lbrakk>length xs = k; length ys = k; zip xs ys = []\\<rbrakk> \\<Longrightarrow> xs = [] \\<and> ys = []\"", "lemma zip_null_gr: \"\\<lbrakk>length xs = k; length ys = k; zip xs ys \\<noteq> []\\<rbrakk> \\<Longrightarrow> 0 < k\"", "lemma Embranch_0:  \n  \"\\<lbrakk>length rgs = k; length rcs = k; k > 0; \n  \\<forall> j < k. rec_exec (rcs ! j) xs = 0\\<rbrakk> \\<Longrightarrow>\n  Embranch (zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs)) xs = 0\"", "lemma embranch_lemma:\n  assumes branch_num:\n    \"length rgs = n\" \"length rcs = n\" \"n > 0\"\n    and partition: \n    \"(\\<exists> i < n. (rec_exec (rcs ! i) xs = 1 \\<and> (\\<forall> j < n. j \\<noteq> i \\<longrightarrow> \n                                      rec_exec (rcs ! j) xs = 0)))\"\n    and prime_all: \"list_all (\\<lambda> rf. primerec rf (length xs)) (rgs @ rcs)\"\n  shows \"rec_exec (rec_embranch (zip rgs rcs)) xs =\n                  Embranch (zip (map rec_exec rgs) \n                     (map (\\<lambda> r args. 0 < rec_exec r args) rcs)) xs\"", "lemma primerec_all1: \n  \"primerec (rec_all rt rf) n \\<Longrightarrow> primerec rt n\"", "lemma primerec_all2: \"primerec (rec_all rt rf) n \\<Longrightarrow> \n  primerec rf (Suc n)\"", "lemma exec_tmp: \n  \"rec_exec (rec_all (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]]) \n  (Cn 3 rec_noteq [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))  [x, k] = \n  ((if (\\<forall>w\\<le>rec_exec (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]]) ([x, k]). \n  0 < rec_exec (Cn 3 rec_noteq [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n  ([x, k] @ [w])) then 1 else 0))\"", "lemma prime_lemma: \"rec_exec rec_prime [x] = (if Prime x then 1 else 0)\"", "lemma fac_dummy: \"rec_exec rec_dummyfac [x, y] = y !\"", "lemma fac_lemma: \"rec_exec rec_fac [x] =  x!\"", "lemma n_le_fact[simp]: \"n < Suc (n!)\"", "lemma divsor_ex: \n  \"\\<lbrakk>\\<not> Prime x; x > Suc 0\\<rbrakk> \\<Longrightarrow> (\\<exists> u > Suc 0. (\\<exists> v > Suc 0. u * v = x))\"", "lemma divsor_prime_ex: \"\\<lbrakk>\\<not> Prime x; x > Suc 0\\<rbrakk> \\<Longrightarrow> \n  \\<exists> p. Prime p \\<and> p dvd x\"", "lemma fact_pos[intro]: \"0 < n!\"", "lemma fac_Suc: \"Suc n! =  (Suc n) * (n!)\"", "lemma fac_dvd: \"\\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!\"", "lemma fac_dvd2: \"\\<lbrakk>Suc 0 < q; q dvd n!; q \\<le> n\\<rbrakk> \\<Longrightarrow> \\<not> q dvd Suc (n!)\"", "lemma prime_ex: \"\\<exists> p. n < p \\<and> p \\<le> Suc (n!) \\<and> Prime p\"", "lemma Suc_Suc_induct[elim!]: \"\\<lbrakk>i < Suc (Suc 0); \n  primerec (ys ! 0) n; primerec (ys ! 1) n\\<rbrakk> \\<Longrightarrow> primerec (ys ! i) n\"", "lemma primerec_rec_prime_1[intro]: \"primerec rec_prime (Suc 0)\"", "lemma np_lemma: \"rec_exec rec_np [x] = Np x\"", "lemma power_lemma: \"rec_exec rec_power [x, y] = x^y\"", "lemma pi_dummy_lemma: \"rec_exec rec_dummy_pi [x, y] = Pi y\"", "lemma pi_lemma: \"rec_exec rec_pi [x] = Pi x\"", "lemma primerec_sigma[intro!]:  \n  \"\\<lbrakk>n > Suc 0; primerec rf n\\<rbrakk> \\<Longrightarrow> \n  primerec (rec_sigma rf) n\"", "lemma primerec_rec_maxr[intro!]:  \"\\<lbrakk>primerec rf n; n > 0\\<rbrakk> \\<Longrightarrow> primerec (rec_maxr rf) n\"", "lemma Suc_Suc_Suc_induct[elim!]: \n  \"\\<lbrakk>i < Suc (Suc (Suc (0::nat))); primerec (ys ! 0) n;\n  primerec (ys ! 1) n;  \n  primerec (ys ! 2) n\\<rbrakk> \\<Longrightarrow> primerec (ys ! i) n\"", "lemma primerec_2[intro]:\n  \"primerec rec_quo (Suc (Suc 0))\" \"primerec rec_mod (Suc (Suc 0))\"\n  \"primerec rec_power (Suc (Suc 0))\"", "lemma rec_lo_Maxr_lor:\n  \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow>  \n        rec_exec rec_lo [x, y] = Maxr loR [x, y] x\"", "lemma x_less_exp: \"\\<lbrakk>y > Suc 0\\<rbrakk> \\<Longrightarrow> x < y^x\"", "lemma uplimit_loR:\n  assumes \"Suc 0 < x\" \"Suc 0 < y\" \"loR [x, y, xa]\"\n  shows \"xa \\<le> x\"", "lemma loR_set_strengthen[simp]: \"\\<lbrakk>xa \\<le> x; loR [x, y, xa]; Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow>\n  {u. loR [x, y, u]} = {ya. ya \\<le> x \\<and> loR [x, y, ya]}\"", "lemma Maxr_lo: \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow>\n  Maxr loR [x, y] x = lo x y\"", "lemma lo_lemma': \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> \n  rec_exec rec_lo [x, y] = lo x y\"", "lemma lo_lemma'': \"\\<lbrakk>\\<not> Suc 0 < x\\<rbrakk> \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y\"", "lemma lo_lemma''': \"\\<lbrakk>\\<not> Suc 0 < y\\<rbrakk> \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y\"", "lemma lo_lemma: \"rec_exec rec_lo [x, y] = lo x y\"", "lemma lg_maxr: \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> \n                      rec_exec rec_lg [x, y] = Maxr lgR [x, y] x\"", "lemma lgR_ok: \"\\<lbrakk>Suc 0 < y; lgR [x, y, xa]\\<rbrakk> \\<Longrightarrow> xa \\<le> x\"", "lemma lgR_set_strengthen[simp]: \"\\<lbrakk>Suc 0 < x; Suc 0 < y; lgR [x, y, xa]\\<rbrakk> \\<Longrightarrow>\n           {u. lgR [x, y, u]} =  {ya. ya \\<le> x \\<and> lgR [x, y, ya]}\"", "lemma maxr_lg: \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> Maxr lgR [x, y] x = lg x y\"", "lemma lg_lemma': \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y\"", "lemma lg_lemma'': \"\\<not> Suc 0 < x \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y\"", "lemma lg_lemma''': \"\\<not> Suc 0 < y \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y\"", "lemma lg_lemma: \"rec_exec rec_lg [x, y] = lg x y\"", "lemma entry_lemma: \"rec_exec rec_entry [str, i] = Entry str i\"", "lemma listsum2_lemma: \"\\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk> \\<Longrightarrow> \n      rec_exec (rec_listsum2 vl n) xs = listsum2 xs n\"", "lemma strt'_lemma: \"\\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk> \\<Longrightarrow> \n  rec_exec (rec_strt' vl n) xs = strt' xs n\"", "lemma map_s_lemma: \"length xs = vl \\<Longrightarrow> \n  map ((\\<lambda>a. rec_exec a xs) \\<circ> (\\<lambda>i. Cn vl s [recf.id vl i]))\n  [0..<vl]\n        = map Suc xs\"", "lemma strt_lemma: \"length xs = vl \\<Longrightarrow> \n  rec_exec (rec_strt vl) xs = strt xs\"", "lemma scan_lemma: \"rec_exec rec_scan [r] = r mod 2\"", "lemma Suc_Suc_Suc_Suc_induct: \n  \"\\<lbrakk>i < Suc (Suc (Suc (Suc 0))); i = 0 \\<Longrightarrow>  P i;\n    i = 1 \\<Longrightarrow> P i; i =2 \\<Longrightarrow> P i; \n    i =3 \\<Longrightarrow> P i\\<rbrakk> \\<Longrightarrow> P i\"", "lemma newleft_lemma: \n  \"rec_exec rec_newleft [p, r, a] = newleft p r a\"", "lemma numeral_4_eq_4: \"4 = Suc 3\"", "lemma Suc_5_induct: \n  \"\\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0)))); i = 0 \\<Longrightarrow> P 0;\n  i = 1 \\<Longrightarrow> P 1; i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3; i = 4 \\<Longrightarrow> P 4\\<rbrakk> \\<Longrightarrow> P i\"", "lemma primerec_rec_scan_1[intro]: \"primerec rec_scan (Suc 0)\"", "lemma newrght_lemma: \"rec_exec rec_newrght [p, r, a] = newrght p r a\"", "lemma actn_lemma: \"rec_exec rec_actn [m, q, r] = actn m q r\"", "lemma newstat_lemma: \"rec_exec rec_newstat [m, q, r] = newstat m q r\"", "lemma trpl_lemma: \"rec_exec rec_trpl [p, q, r] = trpl p q r\"", "lemma left_lemma: \"rec_exec rec_left [c] = left c\"", "lemma right_lemma: \"rec_exec rec_right [c] = rght c\"", "lemma stat_lemma: \"rec_exec rec_stat [c] = stat c\"", "lemma map_cons_eq: \n  \"(map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ> \n    (\\<lambda>i. recf.id (Suc (length xs)) (i))) \n          [Suc 0..<Suc (length xs)])\n        = map (\\<lambda> i. xs ! (i - 1)) [Suc 0..<Suc (length xs)]\"", "lemma list_map_eq: \n  \"vl = length (xs::nat list) \\<Longrightarrow> map (\\<lambda> i. xs ! (i - 1))\n                                          [Suc 0..<Suc vl] = xs\"", "lemma nonempty_listE: \n  \"Suc 0 \\<le> length xs \\<Longrightarrow> \n     (map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ> \n         (\\<lambda>i. recf.id (Suc (length xs)) (i))) \n             [Suc 0..<length xs] @ [(m # xs) ! length xs]) = xs\"", "lemma inpt_lemma:\n  \"\\<lbrakk>Suc (length xs) = vl\\<rbrakk> \\<Longrightarrow> \n            rec_exec (rec_inpt vl) (m # xs) = inpt m xs\"", "lemma newconf_lemma: \"rec_exec rec_newconf [m ,c] = newconf m c\"", "lemma conf_step: \n  \"rec_exec rec_conf [m, r, Suc t] =\n         rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\"", "lemma conf_lemma: \n  \"rec_exec rec_conf [m, r, t] = conf m r t\"", "lemma NSTD_lemma1: \"rec_exec rec_NSTD [c] = Suc 0 \\<or>\n                   rec_exec rec_NSTD [c] = 0\"", "lemma NSTD_lemma2': \"(rec_exec rec_NSTD [c] = Suc 0) \\<Longrightarrow> NSTD c\"", "lemma NSTD_lemma2'': \n  \"NSTD c \\<Longrightarrow> (rec_exec rec_NSTD [c] = Suc 0)\"", "lemma NSTD_lemma2: \"(rec_exec rec_NSTD [c] = Suc 0) = NSTD c\"", "lemma nstd_lemma: \"rec_exec rec_NSTD [c] = nstd c\"", "lemma nonstop_lemma: \n  \"rec_exec rec_nonstop [m, r, t] = nonstop m r t\"", "lemma primerec_rec_right_1[intro]: \"primerec rec_right (Suc 0)\"", "lemma primerec_rec_pi_helper:\n  \"\\<forall>i<Suc (Suc 0). primerec ([recf.id (Suc 0) 0, recf.id (Suc 0) 0] ! i) (Suc 0)\"", "lemmas primerec_rec_pi_helpers =\n  primerec_rec_pi_helper primerec_constn_1 primerec_rec_sg_1 primerec_rec_not_1 primerec_rec_conj_2", "lemma primrec_dummyfac:\n  \"\\<forall>i<Suc (Suc 0).\n       primerec\n        ([recf.id (Suc 0) 0,\n          Cn (Suc 0) s\n           [Cn (Suc 0) rec_dummyfac\n             [recf.id (Suc 0) 0, recf.id (Suc 0) 0]]] !\n         i)\n        (Suc 0)\"", "lemma primerec_rec_pi_1[intro]:  \"primerec rec_pi (Suc 0)\"", "lemma primerec_recs[intro]:\n  \"primerec rec_trpl (Suc (Suc (Suc 0)))\"\n  \"primerec rec_newleft0 (Suc (Suc 0))\"\n  \"primerec rec_newleft1 (Suc (Suc 0))\"\n  \"primerec rec_newleft2 (Suc (Suc 0))\"\n  \"primerec rec_newleft3 (Suc (Suc 0))\"\n  \"primerec rec_newleft (Suc (Suc (Suc 0)))\"\n  \"primerec rec_left (Suc 0)\"\n  \"primerec rec_actn (Suc (Suc (Suc 0)))\"\n  \"primerec rec_stat (Suc 0)\"\n  \"primerec rec_newstat (Suc (Suc (Suc 0)))\"", "lemma primerec_rec_newrght[intro]: \"primerec rec_newrght (Suc (Suc (Suc 0)))\"", "lemma primerec_rec_newconf[intro]: \"primerec rec_newconf (Suc (Suc 0))\"", "lemma primerec_rec_conf[intro]: \"primerec rec_conf (Suc (Suc (Suc 0)))\"", "lemma primerec_recs2[intro]:\n  \"primerec rec_lg (Suc (Suc 0))\"\n  \"primerec rec_nonstop (Suc (Suc (Suc 0)))\"", "lemma primerec_terminate: \n  \"\\<lbrakk>primerec f x; length xs = x\\<rbrakk> \\<Longrightarrow> terminate f xs\"", "lemma value_lemma: \"rec_exec rec_valu [r] = valu r\"", "lemma primerec_rec_valu_1[intro]: \"primerec rec_valu (Suc 0)\"", "lemma terminate_halt_lemma: \n  \"\\<lbrakk>rec_exec rec_nonstop ([m, r] @ [t]) = 0; \n     \\<forall>i<t. 0 < rec_exec rec_nonstop ([m, r] @ [i])\\<rbrakk> \\<Longrightarrow> terminate rec_halt [m, r]\"", "lemma F_lemma: \"rec_exec rec_halt [m, r] = t \\<Longrightarrow> rec_exec rec_F [m, r] = (valu (rght (conf m r t)))\"", "lemma terminate_F_lemma: \"terminate rec_halt [m, r] \\<Longrightarrow> terminate rec_F [m, r]\"", "lemma bl2wc_0[simp]: \"bl2wc [] = 0\"", "lemma fetch_action_map_4[simp]: \"\\<lbrakk>fetch tp 0 b = (nact, ns)\\<rbrakk> \\<Longrightarrow> action_map nact = 4\"", "lemma Pi_gr_1[simp]: \"Pi n > Suc 0\"", "lemma Pi_not_0[simp]: \"Pi n > 0\"", "lemma godel_code'_nonzero[simp]: \"0 < godel_code' nl n\"", "lemma godel_code_great: \"godel_code nl > 0\"", "lemma godel_code_eq_1: \"(godel_code nl = 1) = (nl = [])\"", "lemma godel_code_1_iff[elim]: \n  \"\\<lbrakk>i < length nl; \\<not> Suc 0 < godel_code nl\\<rbrakk> \\<Longrightarrow> nl ! i = 0\"", "lemma prime_coprime: \"\\<lbrakk>Prime x; Prime y; x\\<noteq>y\\<rbrakk> \\<Longrightarrow> coprime x y\"", "lemma Pi_inc: \"Pi (Suc i) > Pi i\"", "lemma Pi_inc_gr: \"i < j \\<Longrightarrow> Pi i < Pi j\"", "lemma Pi_notEq: \"i \\<noteq> j \\<Longrightarrow> Pi i \\<noteq> Pi j\"", "lemma prime_2[intro]: \"Prime (Suc (Suc 0))\"", "lemma Prime_Pi[intro]: \"Prime (Pi n)\"", "lemma Pi_coprime: \"i \\<noteq> j \\<Longrightarrow> coprime (Pi i) (Pi j)\"", "lemma Pi_power_coprime: \"i \\<noteq> j \\<Longrightarrow> coprime ((Pi i)^m) ((Pi j)^n)\"", "lemma coprime_dvd_mult_nat2: \"\\<lbrakk>coprime (k::nat) n; k dvd n * m\\<rbrakk> \\<Longrightarrow> k dvd m\"", "lemma godel_code'_butlast_last_id' :\n  \"godel_code' (ys @ [y]) (Suc j) = godel_code' ys (Suc j) * \n                                Pi (Suc (length ys + j)) ^ y\"", "lemma godel_code'_butlast_last_id: \n  \"xs \\<noteq> [] \\<Longrightarrow> godel_code' xs (Suc j) = \n  godel_code' (butlast xs) (Suc j) * Pi (length xs + j)^(last xs)\"", "lemma godel_code'_not0: \"godel_code' xs n \\<noteq> 0\"", "lemma godel_code_append_cons: \n  \"length xs = i \\<Longrightarrow> godel_code' (xs@y#ys) (Suc 0)\n    = godel_code' xs (Suc 0) * Pi (Suc i)^y * godel_code' ys (i + 2)\"", "lemma Pi_coprime_pre: \n  \"length ps \\<le> i \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\"", "lemma Pi_coprime_suf: \"i < j \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\"", "lemma godel_finite: \n  \"finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\"", "lemma godel_code_in: \n  \"i < length nl \\<Longrightarrow>  nl ! i  \\<in> {u. Pi (Suc i) ^ u dvd\n                                     godel_code' nl (Suc 0)}\"", "lemma godel_code'_get_nth:\n  \"i < length nl \\<Longrightarrow> Max {u. Pi (Suc i) ^ u dvd \n                          godel_code' nl (Suc 0)} = nl ! i\"", "lemma godel_code'_set[simp]: \n  \"{u. Pi (Suc i) ^ u dvd (Suc (Suc 0)) ^ length nl * \n                                     godel_code' nl (Suc 0)} = \n    {u. Pi (Suc i) ^ u dvd  godel_code' nl (Suc 0)}\"", "lemma godel_code_get_nth: \n  \"i < length nl \\<Longrightarrow> \n           Max {u. Pi (Suc i) ^ u dvd godel_code nl} = nl ! i\"", "lemma mod_dvd_simp: \"(x mod y = (0::nat)) = (y dvd x)\"", "lemma dvd_power_le: \"\\<lbrakk>a > Suc 0; a ^ y dvd a ^ l\\<rbrakk> \\<Longrightarrow> y \\<le> l\"", "lemma Pi_nonzeroE[elim]: \"Pi n = 0 \\<Longrightarrow> RR\"", "lemma Pi_not_oneE[elim]: \"Pi n = Suc 0 \\<Longrightarrow> RR\"", "lemma finite_power_dvd:\n  \"\\<lbrakk>(a::nat) > Suc 0; y \\<noteq> 0\\<rbrakk> \\<Longrightarrow> finite {u. a^u dvd y}\"", "lemma conf_decode1: \"\\<lbrakk>m \\<noteq> n; m \\<noteq> k; k \\<noteq> n\\<rbrakk> \\<Longrightarrow> \n  Max {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r} = l\"", "lemma left_trpl_fst[simp]: \"left (trpl l st r) = l\"", "lemma stat_trpl_snd[simp]: \"stat (trpl l st r) = st\"", "lemma rght_trpl_trd[simp]: \"rght (trpl l st r) = r\"", "lemma max_lor:\n  \"i < length nl \\<Longrightarrow> Max {u. loR [godel_code nl, Pi (Suc i), u]} \n                   = nl ! i\"", "lemma godel_decode: \n  \"i < length nl \\<Longrightarrow> Entry (godel_code nl) i = nl ! i\"", "lemma Four_Suc: \"4 = Suc (Suc (Suc (Suc 0)))\"", "lemma modify_tprog_fetch_even: \n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0\\<rbrakk> \\<Longrightarrow>\n  modify_tprog tp ! (4 * (st - Suc 0) ) = \n  action_map (fst (tp ! (2 * (st - Suc 0))))\"", "lemma modify_tprog_fetch_odd: \n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0\\<rbrakk> \\<Longrightarrow> \n       modify_tprog tp ! (Suc (Suc (4 * (st - Suc 0)))) = \n       action_map (fst (tp ! (Suc (2 * (st - Suc 0)))))\"", "lemma modify_tprog_fetch_action:\n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0; b = 1 \\<or> b = 0\\<rbrakk> \\<Longrightarrow> \n      modify_tprog tp ! (4 * (st - Suc 0) + 2* b) =\n      action_map (fst (tp ! ((2 * (st - Suc 0)) + b)))\"", "lemma length_modify: \"length (modify_tprog tp) = 2 * length tp\"", "lemma fetch_action_eq: \n  \"\\<lbrakk>block_map b = scan r; fetch tp st b = (nact, ns);\n   st \\<le> length tp div 2\\<rbrakk> \\<Longrightarrow> actn (code tp) st r = action_map nact\"", "lemma fetch_zero_zero[simp]: \"fetch tp 0 b = (nact, ns) \\<Longrightarrow> ns = 0\"", "lemma modify_tprog_fetch_state:\n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0; b = 1 \\<or> b = 0\\<rbrakk> \\<Longrightarrow> \n     modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * b) =\n  (snd (tp ! (2 * (st - Suc 0) + b)))\"", "lemma fetch_state_eq:\n  \"\\<lbrakk>block_map b = scan r; \n  fetch tp st b = (nact, ns);\n  st \\<le> length tp div 2\\<rbrakk> \\<Longrightarrow> newstat (code tp) st r = ns\"", "lemma tpl_eqI[intro!]: \n  \"\\<lbrakk>a = a'; b = b'; c = c'\\<rbrakk> \\<Longrightarrow> trpl a b c = trpl a' b' c'\"", "lemma bl2nat_double: \"bl2nat xs (Suc n) = 2 * bl2nat xs n\"", "lemma bl2wc_simps[simp]:\n  \"bl2wc (Oc # tl c) = Suc (bl2wc c) - bl2wc c mod 2 \"\n  \"bl2wc (Bk # c) = 2*bl2wc (c)\"\n  \"2 * bl2wc (tl c) = bl2wc c - bl2wc c mod 2 \"\n  \"bl2wc [Oc] = Suc 0\"\n  \"c \\<noteq> [] \\<Longrightarrow> bl2wc (tl c) = bl2wc c div 2\"\n  \"c \\<noteq> [] \\<Longrightarrow> bl2wc [hd c] = bl2wc c mod 2\"\n  \"c \\<noteq> [] \\<Longrightarrow> bl2wc (hd c # d) = 2 * bl2wc d + bl2wc c mod 2\"\n  \"2 * (bl2wc c div 2) = bl2wc c - bl2wc c mod 2\"\n  \"bl2wc (Oc # list) mod 2 = Suc 0\"", "lemma rec_t_eq_step: \n  \"(\\<lambda> (s, l, r). s \\<le> length tp div 2) c \\<Longrightarrow>\n  trpl_code (step0 c tp) = \n  rec_exec rec_newconf [code tp, trpl_code c]\"", "lemma bl2nat_simps[simp]: \"bl2nat (Oc # Oc\\<up>x) 0 = (2 * 2 ^ x - Suc 0)\"\n  \"bl2nat (Bk\\<up>x) n = 0\"", "lemma bl2nat_exp_zero[simp]: \"bl2nat (Oc\\<up>y) 0 = 2^y - Suc 0\"", "lemma bl2nat_cons_bk: \"bl2nat (ks @ [Bk]) 0 = bl2nat ks 0\"", "lemma bl2nat_cons_oc:\n  \"bl2nat (ks @ [Oc]) 0 =  bl2nat ks 0 + 2 ^ length ks\"", "lemma bl2nat_append: \n  \"bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs) \"", "lemma trpl_code_simp[simp]:\n  \"trpl_code (steps0 (Suc 0, Bk\\<up>l, <lm>) tp 0) = \n    rec_exec rec_conf [code tp, bl2wc (<lm>), 0]\"", "lemma state_in_range_step\n  : \"\\<lbrakk>a \\<le> length A div 2; step0 (a, b, c) A = (st, l, r); tm_wf (A,0)\\<rbrakk>\n  \\<Longrightarrow> st \\<le> length A div 2\"", "lemma state_in_range: \"\\<lbrakk>steps0 (Suc 0, tp) A stp = (st, l, r); tm_wf (A, 0)\\<rbrakk>\n  \\<Longrightarrow> st \\<le> length A div 2\"", "lemma rec_t_eq_steps:\n  \"tm_wf (tp,0) \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp) = \n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp]\"", "lemma bl2wc_Bk_0[simp]: \"bl2wc (Bk\\<up> m) = 0\"", "lemma bl2wc_Oc_then_Bk[simp]: \"bl2wc (Oc\\<up> rs@Bk\\<up> n) = bl2wc (Oc\\<up> rs)\"", "lemma lg_power: \"x > Suc 0 \\<Longrightarrow> lg (x ^ rs) x = rs\"", "lemma nonstop_t_eq: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n); \n   tm_wf (tp, 0); \n  rs > 0\\<rbrakk> \n  \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), stp] = 0\"", "lemma actn_0_is_4[simp]: \"actn m 0 r = 4\"", "lemma newstat_0_0[simp]: \"newstat m 0 r = 0\"", "lemma halt_least_step: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = \n       (0, Bk\\<up> m, Oc\\<up>rs @ Bk\\<up>n); \n    tm_wf (tp, 0); \n    0<rs\\<rbrakk> \\<Longrightarrow>\n    \\<exists> stp. (nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n       (\\<forall> stp'. nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow> stp \\<le> stp'))\"", "lemma conf_trpl_ex: \"\\<exists> p q r. conf m (bl2wc (<lm>)) stp = trpl p q r\"", "lemma nonstop_rgt_ex: \n  \"nonstop m (bl2wc (<lm>)) stpa = 0 \\<Longrightarrow> \\<exists> r. conf m (bl2wc (<lm>)) stpa = trpl 0 0 r\"", "lemma max_divisors: \"x > Suc 0 \\<Longrightarrow> Max {u. x ^ u dvd x ^ r} = r\"", "lemma lo_power:\n  assumes \"x > Suc 0\" shows \"lo (x ^ r) x = r\"", "lemma lo_rgt: \"lo (trpl 0 0 r) (Pi 2) = r\"", "lemma conf_keep: \n  \"conf m lm stp = trpl 0 0 r  \\<Longrightarrow>\n  conf m lm (stp + n) = trpl 0 0 r\"", "lemma halt_state_keep_steps_add:\n  \"\\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0\\<rbrakk> \\<Longrightarrow> \n  conf m (bl2wc (<lm>)) stpa = conf m (bl2wc (<lm>)) (stpa + n)\"", "lemma halt_state_keep: \n  \"\\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0; nonstop m (bl2wc (<lm>)) stpb = 0\\<rbrakk> \\<Longrightarrow>\n  conf m (bl2wc (<lm>)) stpa = conf m (bl2wc (<lm>)) stpb\"", "lemma terminate_halt: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up>m, Oc\\<up>rs@Bk\\<up>n); \n    tm_wf (tp,0); 0<rs\\<rbrakk> \\<Longrightarrow> terminate rec_halt [code tp, (bl2wc (<lm>))]\"", "lemma terminate_F: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up>m, Oc\\<up>rs@Bk\\<up>n); \n    tm_wf (tp,0); 0<rs\\<rbrakk> \\<Longrightarrow> terminate rec_F [code tp, (bl2wc (<lm>))]\"", "lemma F_correct: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up>m, Oc\\<up>rs@Bk\\<up>n); \n    tm_wf (tp,0); 0<rs\\<rbrakk>\n   \\<Longrightarrow> rec_exec rec_F [code tp, (bl2wc (<lm>))] = (rs - Suc 0)\""], "translations": [["", "lemma add_lemma: \"\\<And> x y. rec_exec rec_add [x, y] =  x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_add [x, y] = x + y", "by(induct_tac y, auto simp: rec_add_def rec_exec.simps)"], ["", "text \\<open>\n  Correctness of \\<open>rec_mult\\<close>.\n\\<close>"], ["", "lemma mult_lemma: \"\\<And> x y. rec_exec rec_mult [x, y] = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_mult [x, y] = x * y", "by(induct_tac y, auto simp: rec_mult_def rec_exec.simps add_lemma)"], ["", "text \\<open>\n  Correctness of \\<open>rec_pred\\<close>.\n\\<close>"], ["", "lemma pred_lemma: \"\\<And> x. rec_exec rec_pred [x] =  x - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. rec_exec UF.rec_pred [x] = x - 1", "by(induct_tac x, auto simp: rec_pred_def rec_exec.simps)"], ["", "text \\<open>\n  Correctness of \\<open>rec_minus\\<close>.\n\\<close>"], ["", "lemma minus_lemma: \"\\<And> x y. rec_exec rec_minus [x, y] = x - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_minus [x, y] = x - y", "by(induct_tac y, auto simp: rec_exec.simps rec_minus_def pred_lemma)"], ["", "text \\<open>\n  Correctness of \\<open>rec_sg\\<close>.\n\\<close>"], ["", "lemma sg_lemma: \"\\<And> x. rec_exec rec_sg [x] = (if x = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. rec_exec rec_sg [x] = (if x = 0 then 0 else 1)", "by(auto simp: rec_sg_def minus_lemma rec_exec.simps constn.simps)"], ["", "text \\<open>\n  Correctness of \\<open>constn\\<close>.\n\\<close>"], ["", "lemma constn_lemma: \"rec_exec (constn n) [x] = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (constn n) [x] = n", "by(induct n, auto simp: rec_exec.simps constn.simps)"], ["", "text \\<open>\n  Correctness of \\<open>rec_less\\<close>.\n\\<close>"], ["", "lemma less_lemma: \"\\<And> x y. rec_exec rec_less [x, y] = \n  (if x < y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_less [x, y] = (if x < y then 1 else 0)", "by(induct_tac y, auto simp: rec_exec.simps \n      rec_less_def minus_lemma sg_lemma)"], ["", "text \\<open>\n  Correctness of \\<open>rec_not\\<close>.\n\\<close>"], ["", "lemma not_lemma: \n  \"\\<And> x. rec_exec rec_not [x] = (if x = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. rec_exec rec_not [x] = (if x = 0 then 1 else 0)", "by(induct_tac x, auto simp: rec_exec.simps rec_not_def\n      constn_lemma minus_lemma)"], ["", "text \\<open>\n  Correctness of \\<open>rec_eq\\<close>.\n\\<close>"], ["", "lemma eq_lemma: \"\\<And> x y. rec_exec rec_eq [x, y] = (if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_eq [x, y] = (if x = y then 1 else 0)", "by(induct_tac y, auto simp: rec_exec.simps rec_eq_def constn_lemma add_lemma minus_lemma)"], ["", "text \\<open>\n  Correctness of \\<open>rec_conj\\<close>.\n\\<close>"], ["", "lemma conj_lemma: \"\\<And> x y. rec_exec rec_conj [x, y] = (if x = 0 \\<or> y = 0 then 0 \n                                                       else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rec_exec rec_conj [x, y] = (if x = 0 \\<or> y = 0 then 0 else 1)", "by(induct_tac y, auto simp: rec_exec.simps sg_lemma rec_conj_def mult_lemma)"], ["", "text \\<open>\n  Correctness of \\<open>rec_disj\\<close>.\n\\<close>"], ["", "lemma disj_lemma: \"\\<And> x y. rec_exec rec_disj [x, y] = (if x = 0 \\<and> y = 0 then 0\n                                                     else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rec_exec rec_disj [x, y] = (if x = 0 \\<and> y = 0 then 0 else 1)", "by(induct_tac y, auto simp: rec_disj_def sg_lemma add_lemma rec_exec.simps)"], ["", "text \\<open>\n  \\<open>primrec recf n\\<close> is true iff \n  \\<open>recf\\<close> is a primitive recursive function \n  with arity \\<open>n\\<close>.\n\\<close>"], ["", "inductive primerec :: \"recf \\<Rightarrow> nat \\<Rightarrow> bool\"\n  where\n    prime_z[intro]:  \"primerec z (Suc 0)\" |\n    prime_s[intro]:  \"primerec s (Suc 0)\" |\n    prime_id[intro!]: \"\\<lbrakk>n < m\\<rbrakk> \\<Longrightarrow> primerec (id m n) m\" |\n    prime_cn[intro!]: \"\\<lbrakk>primerec f k; length gs = k; \n  \\<forall> i < length gs. primerec (gs ! i) m; m = n\\<rbrakk> \n  \\<Longrightarrow> primerec (Cn n f gs) m\" |\n    prime_pr[intro!]: \"\\<lbrakk>primerec f n; \n  primerec g (Suc (Suc n)); m = Suc n\\<rbrakk> \n  \\<Longrightarrow> primerec (Pr n f g) m\""], ["", "inductive_cases prime_cn_reverse'[elim]: \"primerec (Cn n f gs) n\""], ["", "inductive_cases prime_mn_reverse: \"primerec (Mn n f) m\""], ["", "inductive_cases prime_z_reverse[elim]: \"primerec z n\""], ["", "inductive_cases prime_s_reverse[elim]: \"primerec s n\""], ["", "inductive_cases prime_id_reverse[elim]: \"primerec (id m n) k\""], ["", "inductive_cases prime_cn_reverse[elim]: \"primerec (Cn n f gs) m\""], ["", "inductive_cases prime_pr_reverse[elim]: \"primerec (Pr n f g) m\""], ["", "declare mult_lemma[simp] add_lemma[simp] pred_lemma[simp] \n  minus_lemma[simp] sg_lemma[simp] constn_lemma[simp] \n  less_lemma[simp] not_lemma[simp] eq_lemma[simp]\n  conj_lemma[simp] disj_lemma[simp]"], ["", "text \\<open>\n  \\<open>Sigma\\<close> is the logical specification of \n  the recursive function \\<open>rec_sigma\\<close>.\n\\<close>"], ["", "function Sigma :: \"(nat list \\<Rightarrow> nat) \\<Rightarrow> nat list \\<Rightarrow> nat\"\n  where\n    \"Sigma g xs = (if last xs = 0 then g xs\n                 else (Sigma g (butlast xs @ [last xs - 1]) +\n                       g xs)) \""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>g xs. x = (g, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>g xs ga xsa.\n       (g, xs) = (ga, xsa) \\<Longrightarrow>\n       (if last xs = 0 then g xs\n        else Sigma_sumC (g, butlast xs @ [last xs - 1]) + g xs) =\n       (if last xsa = 0 then ga xsa\n        else Sigma_sumC (ga, butlast xsa @ [last xsa - 1]) + ga xsa)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All Sigma_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>g xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((g, butlast xs @ [last xs - 1]), g, xs) \\<in> ?R", "show \"wf (measure (\\<lambda> (f, xs). last xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(f, xs). last xs))", "by auto"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>(f, xs). last xs))\n\ngoal (1 subgoal):\n 1. \\<And>g xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((g, butlast xs @ [last xs - 1]), g, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((g, butlast xs @ [last xs - 1]), g, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "fix g xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((g, butlast xs @ [last xs - 1]), g, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "assume \"last (xs::nat list) \\<noteq> 0\""], ["proof (state)\nthis:\n  last xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>g xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((g, butlast xs @ [last xs - 1]), g, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "thus \"((g, butlast xs @ [last xs - 1]), g, xs)  \n                   \\<in> measure (\\<lambda>(f, xs). last xs)\""], ["proof (prove)\nusing this:\n  last xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((g, butlast xs @ [last xs - 1]), g, xs)\n    \\<in> measure (\\<lambda>(f, xs). last xs)", "by auto"], ["proof (state)\nthis:\n  ((g, butlast xs @ [last xs - 1]), g, xs)\n  \\<in> measure (\\<lambda>(f, xs). last xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare rec_exec.simps[simp del] get_fstn_args.simps[simp del]\n  arity.simps[simp del] Sigma.simps[simp del]\n  rec_sigma.simps[simp del]"], ["", "lemma rec_pr_Suc_simp_rewrite: \n  \"rec_exec (Pr n f g) (xs @ [Suc x]) =\n                       rec_exec g (xs @ [x] @ \n                        [rec_exec (Pr n f g) (xs @ [x])])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (Pr n f g) (xs @ [Suc x]) =\n    rec_exec g (xs @ [x] @ [rec_exec (Pr n f g) (xs @ [x])])", "by(simp add: rec_exec.simps)"], ["", "lemma Sigma_0_simp_rewrite:\n  \"Sigma f (xs @ [0]) = f (xs @ [0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma f (xs @ [0]) = f (xs @ [0])", "by(simp add: Sigma.simps)"], ["", "lemma Sigma_Suc_simp_rewrite: \n  \"Sigma f (xs @ [Suc x]) = Sigma f (xs @ [x]) + f (xs @ [Suc x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma f (xs @ [Suc x]) = UF.Sigma f (xs @ [x]) + f (xs @ [Suc x])", "by(simp add: Sigma.simps)"], ["", "lemma append_access_1[simp]: \"(xs @ ys) ! (Suc (length xs)) = ys ! 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys) ! Suc (length xs) = ys ! 1", "by(simp add: nth_append)"], ["", "lemma get_fstn_args_take: \"\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk> \\<Longrightarrow> \n  map (\\<lambda> f. rec_exec f xs) (get_fstn_args m n)= take n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs) (get_fstn_args m n) =\n                      take n xs", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = m; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs) (get_fstn_args m 0) =\n                      take 0 xs\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n                \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                                   (get_fstn_args m n) =\n                                  take n xs;\n        length xs = m; Suc n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                          (get_fstn_args m (Suc n)) =\n                         take (Suc n) xs", "case 0"], ["proof (state)\nthis:\n  length xs = m\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = m; 0 \\<le> m\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs) (get_fstn_args m 0) =\n                      take 0 xs\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n                \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                                   (get_fstn_args m n) =\n                                  take n xs;\n        length xs = m; Suc n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                          (get_fstn_args m (Suc n)) =\n                         take (Suc n) xs", "thus \"?case\""], ["proof (prove)\nusing this:\n  length xs = m\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>f. rec_exec f xs) (get_fstn_args m 0) = take 0 xs", "by(simp add: get_fstn_args.simps)"], ["proof (state)\nthis:\n  map (\\<lambda>f. rec_exec f xs) (get_fstn_args m 0) = take 0 xs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n                \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                                   (get_fstn_args m n) =\n                                  take n xs;\n        length xs = m; Suc n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                          (get_fstn_args m (Suc n)) =\n                         take (Suc n) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n                \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                                   (get_fstn_args m n) =\n                                  take n xs;\n        length xs = m; Suc n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                          (get_fstn_args m (Suc n)) =\n                         take (Suc n) xs", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs) (get_fstn_args m n) =\n                    take n xs\n  length xs = m\n  Suc n \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n                \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                                   (get_fstn_args m n) =\n                                  take n xs;\n        length xs = m; Suc n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs)\n                          (get_fstn_args m (Suc n)) =\n                         take (Suc n) xs", "thus \"?case\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs = m; n \\<le> m\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>f. rec_exec f xs) (get_fstn_args m n) =\n                    take n xs\n  length xs = m\n  Suc n \\<le> m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>f. rec_exec f xs) (get_fstn_args m (Suc n)) =\n    take (Suc n) xs", "by(simp add: get_fstn_args.simps rec_exec.simps \n        take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  map (\\<lambda>f. rec_exec f xs) (get_fstn_args m (Suc n)) =\n  take (Suc n) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arity_primerec[simp]: \"primerec f n \\<Longrightarrow> arity f = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec f n \\<Longrightarrow> arity f = n", "apply(cases f)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>primerec f n; f = z\\<rbrakk> \\<Longrightarrow> arity f = n\n 2. \\<lbrakk>primerec f n; f = s\\<rbrakk> \\<Longrightarrow> arity f = n\n 3. \\<And>x31 x32.\n       \\<lbrakk>primerec f n; f = recf.id x31 x32\\<rbrakk>\n       \\<Longrightarrow> arity f = n\n 4. \\<And>x41 x42 x43.\n       \\<lbrakk>primerec f n; f = Cn x41 x42 x43\\<rbrakk>\n       \\<Longrightarrow> arity f = n\n 5. \\<And>x51 x52 x53.\n       \\<lbrakk>primerec f n; f = Pr x51 x52 x53\\<rbrakk>\n       \\<Longrightarrow> arity f = n\n 6. \\<And>x61 x62.\n       \\<lbrakk>primerec f n; f = Mn x61 x62\\<rbrakk>\n       \\<Longrightarrow> arity f = n", "apply(auto simp: arity.simps )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       \\<lbrakk>primerec (Mn x61 x62) n; f = Mn x61 x62\\<rbrakk>\n       \\<Longrightarrow> x61 = n", "apply(erule_tac prime_mn_reverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rec_sigma_Suc_simp_rewrite: \n  \"primerec f (Suc (length xs))\n    \\<Longrightarrow> rec_exec (rec_sigma f) (xs @ [Suc x]) = \n    rec_exec (rec_sigma f) (xs @ [x]) + rec_exec f (xs @ [Suc x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec f (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_sigma f) (xs @ [Suc x]) =\n    rec_exec (rec_sigma f) (xs @ [x]) + rec_exec f (xs @ [Suc x])", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec f (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_sigma f) (xs @ [Suc 0]) =\n    rec_exec (rec_sigma f) (xs @ [0]) + rec_exec f (xs @ [Suc 0])\n 2. \\<And>x.\n       \\<lbrakk>primerec f (Suc (length xs)) \\<Longrightarrow>\n                rec_exec (rec_sigma f) (xs @ [Suc x]) =\n                rec_exec (rec_sigma f) (xs @ [x]) +\n                rec_exec f (xs @ [Suc x]);\n        primerec f (Suc (length xs))\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_sigma f) (xs @ [Suc (Suc x)]) =\n                         rec_exec (rec_sigma f) (xs @ [Suc x]) +\n                         rec_exec f (xs @ [Suc (Suc x)])", "apply(auto simp: rec_sigma.simps Let_def rec_pr_Suc_simp_rewrite\n      rec_exec.simps get_fstn_args_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_sigma\\<close> with respect to its specification.\n\\<close>"], ["", "lemma sigma_lemma: \n  \"primerec rg (Suc (length xs))\n     \\<Longrightarrow> rec_exec (rec_sigma rg) (xs @ [x]) = Sigma (rec_exec rg) (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rg (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_sigma rg) (xs @ [x]) = UF.Sigma (rec_exec rg) (xs @ [x])", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec rg (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_sigma rg) (xs @ [0]) = UF.Sigma (rec_exec rg) (xs @ [0])\n 2. \\<And>x.\n       \\<lbrakk>primerec rg (Suc (length xs)) \\<Longrightarrow>\n                rec_exec (rec_sigma rg) (xs @ [x]) =\n                UF.Sigma (rec_exec rg) (xs @ [x]);\n        primerec rg (Suc (length xs))\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_sigma rg) (xs @ [Suc x]) =\n                         UF.Sigma (rec_exec rg) (xs @ [Suc x])", "apply(auto simp: rec_exec.simps rec_sigma.simps Let_def \n      get_fstn_args_take Sigma_0_simp_rewrite\n      Sigma_Suc_simp_rewrite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  \\<open>rec_accum f (x1, x2, \\<dots>, xn, k) = \n           f(x1, x2, \\<dots>, xn, 0) * \n           f(x1, x2, \\<dots>, xn, 1) *\n               \\<dots> \n           f(x1, x2, \\<dots>, xn, k)\\<close>\n\\<close>"], ["", "fun rec_accum :: \"recf \\<Rightarrow> recf\"\n  where\n    \"rec_accum rf = \n       (let vl = arity rf in \n          Pr (vl - 1) (Cn (vl - 1) rf (get_fstn_args (vl - 1) (vl - 1) @ \n                     [Cn (vl - 1) (constn 0) [id (vl - 1) 0]])) \n             (Cn (Suc vl) rec_mult [id (Suc vl) (vl), \n                    Cn (Suc vl) rf (get_fstn_args (Suc vl) (vl - 1) \n                      @ [Cn (Suc vl) s [id (Suc vl) (vl - 1)]])]))\""], ["", "text \\<open>\n  \\<open>Accum\\<close> is the formal specification of \\<open>rec_accum\\<close>.\n\\<close>"], ["", "function Accum :: \"(nat list \\<Rightarrow> nat) \\<Rightarrow> nat list \\<Rightarrow> nat\"\n  where\n    \"Accum f xs = (if last xs = 0 then f xs \n                     else (Accum f (butlast xs @ [last xs - 1]) *\n                       f xs))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>f xs. x = (f, xs) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>f xs fa xsa.\n       (f, xs) = (fa, xsa) \\<Longrightarrow>\n       (if last xs = 0 then f xs\n        else Accum_sumC (f, butlast xs @ [last xs - 1]) * f xs) =\n       (if last xsa = 0 then fa xsa\n        else Accum_sumC (fa, butlast xsa @ [last xsa - 1]) * fa xsa)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All Accum_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>f xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((f, butlast xs @ [last xs - 1]), f, xs) \\<in> ?R", "show \"wf (measure (\\<lambda> (f, xs). last xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>(f, xs). last xs))", "by auto"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>(f, xs). last xs))\n\ngoal (1 subgoal):\n 1. \\<And>f xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((f, butlast xs @ [last xs - 1]), f, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((f, butlast xs @ [last xs - 1]), f, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "fix f xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((f, butlast xs @ [last xs - 1]), f, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "assume \"last xs \\<noteq> (0::nat)\""], ["proof (state)\nthis:\n  last xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>f xs.\n       last xs \\<noteq> 0 \\<Longrightarrow>\n       ((f, butlast xs @ [last xs - 1]), f, xs)\n       \\<in> measure (\\<lambda>(f, xs). last xs)", "thus \"((f, butlast xs @ [last xs - 1]), f, xs) \\<in> \n            measure (\\<lambda>(f, xs). last xs)\""], ["proof (prove)\nusing this:\n  last xs \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((f, butlast xs @ [last xs - 1]), f, xs)\n    \\<in> measure (\\<lambda>(f, xs). last xs)", "by auto"], ["proof (state)\nthis:\n  ((f, butlast xs @ [last xs - 1]), f, xs)\n  \\<in> measure (\\<lambda>(f, xs). last xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rec_accum_Suc_simp_rewrite: \n  \"primerec f (Suc (length xs))\n    \\<Longrightarrow> rec_exec (rec_accum f) (xs @ [Suc x]) = \n    rec_exec (rec_accum f) (xs @ [x]) * rec_exec f (xs @ [Suc x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec f (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_accum f) (xs @ [Suc x]) =\n    rec_exec (rec_accum f) (xs @ [x]) * rec_exec f (xs @ [Suc x])", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec f (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_accum f) (xs @ [Suc 0]) =\n    rec_exec (rec_accum f) (xs @ [0]) * rec_exec f (xs @ [Suc 0])\n 2. \\<And>x.\n       \\<lbrakk>primerec f (Suc (length xs)) \\<Longrightarrow>\n                rec_exec (rec_accum f) (xs @ [Suc x]) =\n                rec_exec (rec_accum f) (xs @ [x]) *\n                rec_exec f (xs @ [Suc x]);\n        primerec f (Suc (length xs))\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_accum f) (xs @ [Suc (Suc x)]) =\n                         rec_exec (rec_accum f) (xs @ [Suc x]) *\n                         rec_exec f (xs @ [Suc (Suc x)])", "apply(auto simp: rec_sigma.simps Let_def rec_pr_Suc_simp_rewrite\n      rec_exec.simps get_fstn_args_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_accum\\<close> with respect to its specification.\n\\<close>"], ["", "lemma accum_lemma :\n  \"primerec rg (Suc (length xs))\n     \\<Longrightarrow> rec_exec (rec_accum rg) (xs @ [x]) = Accum (rec_exec rg) (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rg (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_accum rg) (xs @ [x]) = Accum (rec_exec rg) (xs @ [x])", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec rg (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_accum rg) (xs @ [0]) = Accum (rec_exec rg) (xs @ [0])\n 2. \\<And>x.\n       \\<lbrakk>primerec rg (Suc (length xs)) \\<Longrightarrow>\n                rec_exec (rec_accum rg) (xs @ [x]) =\n                Accum (rec_exec rg) (xs @ [x]);\n        primerec rg (Suc (length xs))\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_accum rg) (xs @ [Suc x]) =\n                         Accum (rec_exec rg) (xs @ [Suc x])", "apply(auto simp: rec_exec.simps rec_sigma.simps Let_def \n      get_fstn_args_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare rec_accum.simps [simp del]"], ["", "text \\<open>\n  \\<open>rec_all t f (x1, x2, \\<dots>, xn)\\<close> \n  computes the charactrization function of the following FOL formula:\n  \\<open>(\\<forall> x \\<le> t(x1, x2, \\<dots>, xn). (f(x1, x2, \\<dots>, xn, x) > 0))\\<close>\n\\<close>"], ["", "fun rec_all :: \"recf \\<Rightarrow> recf \\<Rightarrow> recf\"\n  where\n    \"rec_all rt rf = \n    (let vl = arity rf in\n       Cn (vl - 1) rec_sg [Cn (vl - 1) (rec_accum rf) \n                 (get_fstn_args (vl - 1) (vl - 1) @ [rt])])\""], ["", "lemma rec_accum_ex:\n  assumes \"primerec rf (Suc (length xs))\"\n  shows \"(rec_exec (rec_accum rf) (xs @ [x]) = 0) = \n         (\\<exists> t \\<le> x. rec_exec rf (xs @ [t]) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_exec (rec_accum rf) (xs @ [x]) = 0) =\n    (\\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0)", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. (rec_exec (rec_accum rf) (xs @ [0]) = 0) =\n    (\\<exists>t\\<le>0. rec_exec rf (xs @ [t]) = 0)\n 2. \\<And>x.\n       (rec_exec (rec_accum rf) (xs @ [x]) = 0) =\n       (\\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0) \\<Longrightarrow>\n       (rec_exec (rec_accum rf) (xs @ [Suc x]) = 0) =\n       (\\<exists>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)", "case (Suc x)"], ["proof (state)\nthis:\n  (rec_exec (rec_accum rf) (xs @ [x]) = 0) =\n  (\\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0)\n\ngoal (2 subgoals):\n 1. (rec_exec (rec_accum rf) (xs @ [0]) = 0) =\n    (\\<exists>t\\<le>0. rec_exec rf (xs @ [t]) = 0)\n 2. \\<And>x.\n       (rec_exec (rec_accum rf) (xs @ [x]) = 0) =\n       (\\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0) \\<Longrightarrow>\n       (rec_exec (rec_accum rf) (xs @ [Suc x]) = 0) =\n       (\\<exists>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)", "with assms"], ["proof (chain)\npicking this:\n  primerec rf (Suc (length xs))\n  (rec_exec (rec_accum rf) (xs @ [x]) = 0) =\n  (\\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0)", "show ?case"], ["proof (prove)\nusing this:\n  primerec rf (Suc (length xs))\n  (rec_exec (rec_accum rf) (xs @ [x]) = 0) =\n  (\\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0)\n\ngoal (1 subgoal):\n 1. (rec_exec (rec_accum rf) (xs @ [Suc x]) = 0) =\n    (\\<exists>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)", "apply(auto simp add: rec_exec.simps rec_accum.simps get_fstn_args_take)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t ta.\n       \\<lbrakk>primerec rf (Suc (length xs));\n        (if x = 0\n         then rec_exec\n               (Cn (length xs) rf\n                 (get_fstn_args (length xs) (length xs) @\n                  [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n               (butlast (xs @ [x]))\n         else rec_exec\n               (Cn (Suc (Suc (length xs))) rec_mult\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                  Cn (Suc (Suc (length xs))) rf\n                   (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                    [Cn (Suc (Suc (length xs))) s\n                      [recf.id (Suc (Suc (length xs))) (length xs)]])])\n               (butlast (xs @ [x]) @\n                [last (xs @ [x]) - 1,\n                 rec_exec\n                  (Pr (length xs)\n                    (Cn (length xs) rf\n                      (get_fstn_args (length xs) (length xs) @\n                       [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n                    (Cn (Suc (Suc (length xs))) rec_mult\n                      [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                       Cn (Suc (Suc (length xs))) rf\n                        (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                         [Cn (Suc (Suc (length xs))) s\n                           [recf.id (Suc (Suc (length xs)))\n                             (length xs)]])]))\n                  (butlast (xs @ [x]) @ [last (xs @ [x]) - 1])])) =\n        0;\n        t \\<le> x; rec_exec rf (xs @ [t]) = 0; ta \\<le> x;\n        rec_exec rf (xs @ [ta]) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0\n 2. \\<And>t.\n       \\<lbrakk>primerec rf (Suc (length xs));\n        \\<forall>t\\<le>x. 0 < rec_exec rf (xs @ [t]);\n        0 < (if x = 0\n             then rec_exec\n                   (Cn (length xs) rf\n                     (get_fstn_args (length xs) (length xs) @\n                      [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n                   (butlast (xs @ [x]))\n             else rec_exec\n                   (Cn (Suc (Suc (length xs))) rec_mult\n                     [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                      Cn (Suc (Suc (length xs))) rf\n                       (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                        [Cn (Suc (Suc (length xs))) s\n                          [recf.id (Suc (Suc (length xs))) (length xs)]])])\n                   (butlast (xs @ [x]) @\n                    [last (xs @ [x]) - 1,\n                     rec_exec\n                      (Pr (length xs)\n                        (Cn (length xs) rf\n                          (get_fstn_args (length xs) (length xs) @\n                           [Cn (length xs) (constn 0)\n                             [recf.id (length xs) 0]]))\n                        (Cn (Suc (Suc (length xs))) rec_mult\n                          [recf.id (Suc (Suc (length xs)))\n                            (Suc (length xs)),\n                           Cn (Suc (Suc (length xs))) rf\n                            (get_fstn_args (Suc (Suc (length xs)))\n                              (length xs) @\n                             [Cn (Suc (Suc (length xs))) s\n                               [recf.id (Suc (Suc (length xs)))\n                                 (length xs)]])]))\n                      (butlast (xs @ [x]) @ [last (xs @ [x]) - 1])]));\n        t \\<le> Suc x; rec_exec rf (xs @ [t]) = 0;\n        0 < rec_exec rf (xs @ [Suc x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0", "apply(rename_tac t ta)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t ta.\n       \\<lbrakk>primerec rf (Suc (length xs));\n        (if x = 0\n         then rec_exec\n               (Cn (length xs) rf\n                 (get_fstn_args (length xs) (length xs) @\n                  [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n               (butlast (xs @ [x]))\n         else rec_exec\n               (Cn (Suc (Suc (length xs))) rec_mult\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                  Cn (Suc (Suc (length xs))) rf\n                   (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                    [Cn (Suc (Suc (length xs))) s\n                      [recf.id (Suc (Suc (length xs))) (length xs)]])])\n               (butlast (xs @ [x]) @\n                [last (xs @ [x]) - 1,\n                 rec_exec\n                  (Pr (length xs)\n                    (Cn (length xs) rf\n                      (get_fstn_args (length xs) (length xs) @\n                       [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n                    (Cn (Suc (Suc (length xs))) rec_mult\n                      [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                       Cn (Suc (Suc (length xs))) rf\n                        (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                         [Cn (Suc (Suc (length xs))) s\n                           [recf.id (Suc (Suc (length xs)))\n                             (length xs)]])]))\n                  (butlast (xs @ [x]) @ [last (xs @ [x]) - 1])])) =\n        0;\n        t \\<le> x; rec_exec rf (xs @ [t]) = 0; ta \\<le> x;\n        rec_exec rf (xs @ [ta]) = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0\n 2. \\<And>t.\n       \\<lbrakk>primerec rf (Suc (length xs));\n        \\<forall>t\\<le>x. 0 < rec_exec rf (xs @ [t]);\n        0 < (if x = 0\n             then rec_exec\n                   (Cn (length xs) rf\n                     (get_fstn_args (length xs) (length xs) @\n                      [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n                   (butlast (xs @ [x]))\n             else rec_exec\n                   (Cn (Suc (Suc (length xs))) rec_mult\n                     [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                      Cn (Suc (Suc (length xs))) rf\n                       (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                        [Cn (Suc (Suc (length xs))) s\n                          [recf.id (Suc (Suc (length xs))) (length xs)]])])\n                   (butlast (xs @ [x]) @\n                    [last (xs @ [x]) - 1,\n                     rec_exec\n                      (Pr (length xs)\n                        (Cn (length xs) rf\n                          (get_fstn_args (length xs) (length xs) @\n                           [Cn (length xs) (constn 0)\n                             [recf.id (length xs) 0]]))\n                        (Cn (Suc (Suc (length xs))) rec_mult\n                          [recf.id (Suc (Suc (length xs)))\n                            (Suc (length xs)),\n                           Cn (Suc (Suc (length xs))) rf\n                            (get_fstn_args (Suc (Suc (length xs)))\n                              (length xs) @\n                             [Cn (Suc (Suc (length xs))) s\n                               [recf.id (Suc (Suc (length xs)))\n                                 (length xs)]])]))\n                      (butlast (xs @ [x]) @ [last (xs @ [x]) - 1])]));\n        t \\<le> Suc x; rec_exec rf (xs @ [t]) = 0;\n        0 < rec_exec rf (xs @ [Suc x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0", "apply(rule_tac x = ta in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>primerec rf (Suc (length xs));\n        \\<forall>t\\<le>x. 0 < rec_exec rf (xs @ [t]);\n        0 < (if x = 0\n             then rec_exec\n                   (Cn (length xs) rf\n                     (get_fstn_args (length xs) (length xs) @\n                      [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n                   (butlast (xs @ [x]))\n             else rec_exec\n                   (Cn (Suc (Suc (length xs))) rec_mult\n                     [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                      Cn (Suc (Suc (length xs))) rf\n                       (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                        [Cn (Suc (Suc (length xs))) s\n                          [recf.id (Suc (Suc (length xs))) (length xs)]])])\n                   (butlast (xs @ [x]) @\n                    [last (xs @ [x]) - 1,\n                     rec_exec\n                      (Pr (length xs)\n                        (Cn (length xs) rf\n                          (get_fstn_args (length xs) (length xs) @\n                           [Cn (length xs) (constn 0)\n                             [recf.id (length xs) 0]]))\n                        (Cn (Suc (Suc (length xs))) rec_mult\n                          [recf.id (Suc (Suc (length xs)))\n                            (Suc (length xs)),\n                           Cn (Suc (Suc (length xs))) rf\n                            (get_fstn_args (Suc (Suc (length xs)))\n                              (length xs) @\n                             [Cn (Suc (Suc (length xs))) s\n                               [recf.id (Suc (Suc (length xs)))\n                                 (length xs)]])]))\n                      (butlast (xs @ [x]) @ [last (xs @ [x]) - 1])]));\n        t \\<le> Suc x; rec_exec rf (xs @ [t]) = 0;\n        0 < rec_exec rf (xs @ [Suc x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0", "apply(case_tac \"t = Suc x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>primerec rf (Suc (length xs));\n        \\<forall>t\\<le>x. 0 < rec_exec rf (xs @ [t]);\n        0 < (if x = 0\n             then rec_exec\n                   (Cn (length xs) rf\n                     (get_fstn_args (length xs) (length xs) @\n                      [Cn (length xs) (constn 0) [recf.id (length xs) 0]]))\n                   (butlast (xs @ [x]))\n             else rec_exec\n                   (Cn (Suc (Suc (length xs))) rec_mult\n                     [recf.id (Suc (Suc (length xs))) (Suc (length xs)),\n                      Cn (Suc (Suc (length xs))) rf\n                       (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                        [Cn (Suc (Suc (length xs))) s\n                          [recf.id (Suc (Suc (length xs))) (length xs)]])])\n                   (butlast (xs @ [x]) @\n                    [last (xs @ [x]) - 1,\n                     rec_exec\n                      (Pr (length xs)\n                        (Cn (length xs) rf\n                          (get_fstn_args (length xs) (length xs) @\n                           [Cn (length xs) (constn 0)\n                             [recf.id (length xs) 0]]))\n                        (Cn (Suc (Suc (length xs))) rec_mult\n                          [recf.id (Suc (Suc (length xs)))\n                            (Suc (length xs)),\n                           Cn (Suc (Suc (length xs))) rf\n                            (get_fstn_args (Suc (Suc (length xs)))\n                              (length xs) @\n                             [Cn (Suc (Suc (length xs))) s\n                               [recf.id (Suc (Suc (length xs)))\n                                 (length xs)]])]))\n                      (butlast (xs @ [x]) @ [last (xs @ [x]) - 1])]));\n        t \\<le> Suc x; rec_exec rf (xs @ [t]) = 0;\n        0 < rec_exec rf (xs @ [Suc x]); t \\<noteq> Suc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<le>x. rec_exec rf (xs @ [t]) = 0", "apply(rule_tac x = t in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rec_exec (rec_accum rf) (xs @ [Suc x]) = 0) =\n  (\\<exists>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)\n\ngoal (1 subgoal):\n 1. (rec_exec (rec_accum rf) (xs @ [0]) = 0) =\n    (\\<exists>t\\<le>0. rec_exec rf (xs @ [t]) = 0)", "qed (insert assms,auto simp add: rec_exec.simps rec_accum.simps get_fstn_args_take)"], ["", "text \\<open>\n  The correctness of \\<open>rec_all\\<close>.\n\\<close>"], ["", "lemma all_lemma: \n  \"\\<lbrakk>primerec rf (Suc (length xs));\n    primerec rt (length xs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_all rt rf) xs = (if (\\<forall> x \\<le> (rec_exec rt xs). 0 < rec_exec rf (xs @ [x])) then 1\n                                                                                              else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs)\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_all rt rf) xs =\n                      (if \\<forall>x\\<le>rec_exec rt xs.\n                             0 < rec_exec rf (xs @ [x])\n                       then 1 else 0)", "apply(auto simp: rec_all.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n     \\<forall>x\\<le>rec_exec rt xs. 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (Cn (length xs) rec_sg\n                         [Cn (length xs) (rec_accum rf)\n                           (get_fstn_args (length xs) (length xs) @ [rt])])\n                       xs =\n                      Suc 0\n 2. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        x \\<le> rec_exec rt xs; rec_exec rf (xs @ [x]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (length xs) rec_sg\n                            [Cn (length xs) (rec_accum rf)\n                              (get_fstn_args (length xs) (length xs) @\n                               [rt])])\n                          xs =\n                         0", "apply(simp add: rec_exec.simps map_append get_fstn_args_take split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n     \\<forall>x\\<le>rec_exec rt xs. 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> 0 < rec_exec (rec_accum rf) (xs @ [rec_exec rt xs])\n 2. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        x \\<le> rec_exec rt xs; rec_exec rf (xs @ [x]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (length xs) rec_sg\n                            [Cn (length xs) (rec_accum rf)\n                              (get_fstn_args (length xs) (length xs) @\n                               [rt])])\n                          xs =\n                         0", "apply(drule_tac x = \"rec_exec rt xs\" in rec_accum_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primerec rt (length xs);\n     \\<forall>x\\<le>rec_exec rt xs. 0 < rec_exec rf (xs @ [x]);\n     (rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0) =\n     (\\<exists>t\\<le>rec_exec rt xs. rec_exec rf (xs @ [t]) = 0)\\<rbrakk>\n    \\<Longrightarrow> 0 < rec_exec (rec_accum rf) (xs @ [rec_exec rt xs])\n 2. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        x \\<le> rec_exec rt xs; rec_exec rf (xs @ [x]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (length xs) rec_sg\n                            [Cn (length xs) (rec_accum rf)\n                              (get_fstn_args (length xs) (length xs) @\n                               [rt])])\n                          xs =\n                         0", "apply(cases \"rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primerec rt (length xs);\n     \\<forall>x\\<le>rec_exec rt xs. 0 < rec_exec rf (xs @ [x]);\n     \\<exists>t\\<le>rec_exec rt xs. rec_exec rf (xs @ [t]) = 0;\n     rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        x \\<le> rec_exec rt xs; rec_exec rf (xs @ [x]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (length xs) rec_sg\n                            [Cn (length xs) (rec_accum rf)\n                              (get_fstn_args (length xs) (length xs) @\n                               [rt])])\n                          xs =\n                         0", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        x \\<le> rec_exec rt xs; rec_exec rf (xs @ [x]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (length xs) rec_sg\n                            [Cn (length xs) (rec_accum rf)\n                              (get_fstn_args (length xs) (length xs) @\n                               [rt])])\n                          xs =\n                         0", "apply(simp add: rec_exec.simps map_append get_fstn_args_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        x \\<le> rec_exec rt xs; rec_exec rf (xs @ [x]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0", "apply(drule_tac x = \"rec_exec rt xs\" in rec_accum_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>primerec rt (length xs); x \\<le> rec_exec rt xs;\n        rec_exec rf (xs @ [x]) = 0;\n        (rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0) =\n        (\\<exists>t\\<le>rec_exec rt xs. rec_exec rf (xs @ [t]) = 0)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0", "apply(cases \"rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>primerec rt (length xs); x \\<le> rec_exec rt xs;\n        rec_exec rf (xs @ [x]) = 0;\n        (rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0) =\n        (\\<exists>t\\<le>rec_exec rt xs. rec_exec rf (xs @ [t]) = 0);\n        rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0\n 2. \\<And>x.\n       \\<lbrakk>primerec rt (length xs); x \\<le> rec_exec rt xs;\n        rec_exec rf (xs @ [x]) = 0;\n        (rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0) =\n        (\\<exists>t\\<le>rec_exec rt xs. rec_exec rf (xs @ [t]) = 0);\n        rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_accum rf) (xs @ [rec_exec rt xs]) = 0", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  \\<open>rec_ex t f (x1, x2, \\<dots>, xn)\\<close> \n  computes the charactrization function of the following FOL formula:\n  \\<open>(\\<exists> x \\<le> t(x1, x2, \\<dots>, xn). (f(x1, x2, \\<dots>, xn, x) > 0))\\<close>\n\\<close>"], ["", "fun rec_ex :: \"recf \\<Rightarrow> recf \\<Rightarrow> recf\"\n  where\n    \"rec_ex rt rf = \n       (let vl = arity rf in \n         Cn (vl - 1) rec_sg [Cn (vl - 1) (rec_sigma rf) \n                  (get_fstn_args (vl - 1) (vl - 1) @ [rt])])\""], ["", "lemma rec_sigma_ex: \n  assumes \"primerec rf (Suc (length xs))\"\n  shows \"(rec_exec (rec_sigma rf) (xs @ [x]) = 0) = \n                          (\\<forall> t \\<le> x. rec_exec rf (xs @ [t]) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_exec (rec_sigma rf) (xs @ [x]) = 0) =\n    (\\<forall>t\\<le>x. rec_exec rf (xs @ [t]) = 0)", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. (rec_exec (rec_sigma rf) (xs @ [0]) = 0) =\n    (\\<forall>t\\<le>0. rec_exec rf (xs @ [t]) = 0)\n 2. \\<And>x.\n       (rec_exec (rec_sigma rf) (xs @ [x]) = 0) =\n       (\\<forall>t\\<le>x. rec_exec rf (xs @ [t]) = 0) \\<Longrightarrow>\n       (rec_exec (rec_sigma rf) (xs @ [Suc x]) = 0) =\n       (\\<forall>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)", "case (Suc x)"], ["proof (state)\nthis:\n  (rec_exec (rec_sigma rf) (xs @ [x]) = 0) =\n  (\\<forall>t\\<le>x. rec_exec rf (xs @ [t]) = 0)\n\ngoal (2 subgoals):\n 1. (rec_exec (rec_sigma rf) (xs @ [0]) = 0) =\n    (\\<forall>t\\<le>0. rec_exec rf (xs @ [t]) = 0)\n 2. \\<And>x.\n       (rec_exec (rec_sigma rf) (xs @ [x]) = 0) =\n       (\\<forall>t\\<le>x. rec_exec rf (xs @ [t]) = 0) \\<Longrightarrow>\n       (rec_exec (rec_sigma rf) (xs @ [Suc x]) = 0) =\n       (\\<forall>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)", "from Suc assms"], ["proof (chain)\npicking this:\n  (rec_exec (rec_sigma rf) (xs @ [x]) = 0) =\n  (\\<forall>t\\<le>x. rec_exec rf (xs @ [t]) = 0)\n  primerec rf (Suc (length xs))", "show ?case"], ["proof (prove)\nusing this:\n  (rec_exec (rec_sigma rf) (xs @ [x]) = 0) =\n  (\\<forall>t\\<le>x. rec_exec rf (xs @ [t]) = 0)\n  primerec rf (Suc (length xs))\n\ngoal (1 subgoal):\n 1. (rec_exec (rec_sigma rf) (xs @ [Suc x]) = 0) =\n    (\\<forall>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)", "by(auto simp add: rec_exec.simps rec_sigma.simps \n        get_fstn_args_take elim:le_SucE)"], ["proof (state)\nthis:\n  (rec_exec (rec_sigma rf) (xs @ [Suc x]) = 0) =\n  (\\<forall>t\\<le>Suc x. rec_exec rf (xs @ [t]) = 0)\n\ngoal (1 subgoal):\n 1. (rec_exec (rec_sigma rf) (xs @ [0]) = 0) =\n    (\\<forall>t\\<le>0. rec_exec rf (xs @ [t]) = 0)", "qed (insert assms,auto simp: get_fstn_args_take rec_exec.simps rec_sigma.simps)"], ["", "text \\<open>\n  The correctness of \\<open>ex_lemma\\<close>.\n\\<close>"], ["", "lemma ex_lemma:\"\n  \\<lbrakk>primerec rf (Suc (length xs));\n   primerec rt (length xs)\\<rbrakk>\n\\<Longrightarrow> (rec_exec (rec_ex rt rf) xs =\n    (if (\\<exists> x \\<le> (rec_exec rt xs). 0 <rec_exec rf (xs @ [x])) then 1\n     else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs)\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_ex rt rf) xs =\n                      (if \\<exists>x\\<le>rec_exec rt xs.\n                             0 < rec_exec rf (xs @ [x])\n                       then 1 else 0)", "apply(auto simp: rec_exec.simps get_fstn_args_take split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n        rec_exec (rec_sigma rf) (xs @ [rec_exec rt xs]) = 0;\n        x \\<le> rec_exec rt xs\\<rbrakk>\n       \\<Longrightarrow> rec_exec rf (xs @ [x]) = 0\n 2. \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n     0 < rec_exec (rec_sigma rf) (xs @ [rec_exec rt xs])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<le>rec_exec rt xs.\n                         0 < rec_exec rf (xs @ [x])", "apply(drule_tac x = \"rec_exec rt xs\" in rec_sigma_ex, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rf (Suc (length xs)); primerec rt (length xs);\n     0 < rec_exec (rec_sigma rf) (xs @ [rec_exec rt xs])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<le>rec_exec rt xs.\n                         0 < rec_exec rf (xs @ [x])", "apply(drule_tac x = \"rec_exec rt xs\" in rec_sigma_ex, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Definition of \\<open>Min[R]\\<close> on page 77 of Boolos's book.\n\\<close>"], ["", "fun Minr :: \"(nat list \\<Rightarrow> bool) \\<Rightarrow> nat list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where \"Minr Rr xs w = (let setx = {y | y. (y \\<le> w) \\<and> Rr (xs @ [y])} in \n                        if (setx = {}) then (Suc w)\n                                       else (Min setx))\""], ["", "declare Minr.simps[simp del] rec_all.simps[simp del]"], ["", "text \\<open>\n  The following is a set of auxilliary lemmas about \\<open>Minr\\<close>.\n\\<close>"], ["", "lemma Minr_range: \"Minr Rr xs w \\<le> w \\<or> Minr Rr xs w = Suc w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Minr Rr xs w \\<le> w \\<or> Minr Rr xs w = Suc w", "apply(auto simp: Minr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; Rr (xs @ [x]);\n        Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} \\<noteq>\n        Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])}\n                         \\<le> w", "apply(subgoal_tac \"Min {x. x \\<le> w \\<and> Rr (xs @ [x])} \\<le> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; Rr (xs @ [x]);\n        Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} \\<noteq> Suc w;\n        Min {x. x \\<le> w \\<and> Rr (xs @ [x])} \\<le> x\\<rbrakk>\n       \\<Longrightarrow> Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])}\n                         \\<le> w\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> w; Rr (xs @ [x]);\n        Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} \\<noteq>\n        Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {x. x \\<le> w \\<and> Rr (xs @ [x])} \\<le> x", "apply(erule_tac order_trans, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; Rr (xs @ [x]);\n        Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} \\<noteq>\n        Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {x. x \\<le> w \\<and> Rr (xs @ [x])} \\<le> x", "apply(rule_tac Min_le, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma expand_conj_in_set: \"{x. x \\<le> Suc w \\<and> Rr (xs @ [x])}\n    = (if Rr (xs @ [Suc w]) then insert (Suc w) \n                              {x. x \\<le> w \\<and> Rr (xs @ [x])}\n      else {x. x \\<le> w \\<and> Rr (xs @ [x])})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x \\<le> Suc w \\<and> Rr (xs @ [x])} =\n    (if Rr (xs @ [Suc w])\n     then insert (Suc w) {x. x \\<le> w \\<and> Rr (xs @ [x])}\n     else {x. x \\<le> w \\<and> Rr (xs @ [x])})", "by (auto elim:le_SucE)"], ["", "lemma Minr_strip_Suc[simp]: \"Minr Rr xs w \\<le> w \\<Longrightarrow> Minr Rr xs (Suc w) = Minr Rr xs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Minr Rr xs w \\<le> w \\<Longrightarrow> Minr Rr xs (Suc w) = Minr Rr xs w", "by(cases \"\\<forall>x\\<le>w. \\<not> Rr (xs @ [x])\",auto simp add: Minr.simps expand_conj_in_set)"], ["", "lemma x_empty_set[simp]: \"\\<forall>x\\<le>w. \\<not> Rr (xs @ [x]) \\<Longrightarrow>  \n                           {x. x \\<le> w \\<and> Rr (xs @ [x])} = {} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>w. \\<not> Rr (xs @ [x]) \\<Longrightarrow>\n    {x. x \\<le> w \\<and> Rr (xs @ [x])} = {}", "by auto"], ["", "lemma Minr_is_Suc[simp]: \"\\<lbrakk>Minr Rr xs w = Suc w; Rr (xs @ [Suc w])\\<rbrakk> \\<Longrightarrow> \n                                       Minr Rr xs (Suc w) = Suc w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Minr Rr xs w = Suc w; Rr (xs @ [Suc w])\\<rbrakk>\n    \\<Longrightarrow> Minr Rr xs (Suc w) = Suc w", "apply(simp add: Minr.simps expand_conj_in_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if \\<forall>x\\<le>w. \\<not> Rr (xs @ [x]) then Suc w\n              else Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])}) =\n             Suc w;\n     Rr (xs @ [Suc w])\\<rbrakk>\n    \\<Longrightarrow> Min (insert (Suc w)\n                            {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])}) =\n                      Suc w", "apply(cases \"\\<forall>x\\<le>w. \\<not> Rr (xs @ [x])\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Minr_is_Suc_Suc[simp]: \"\\<lbrakk>Minr Rr xs w = Suc w; \\<not> Rr (xs @ [Suc w])\\<rbrakk> \\<Longrightarrow> \n                                   Minr Rr xs (Suc w) = Suc (Suc w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Minr Rr xs w = Suc w; \\<not> Rr (xs @ [Suc w])\\<rbrakk>\n    \\<Longrightarrow> Minr Rr xs (Suc w) = Suc (Suc w)", "apply(simp add: Minr.simps expand_conj_in_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if \\<forall>x\\<le>w. \\<not> Rr (xs @ [x]) then Suc w\n              else Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])}) =\n             Suc w;\n     \\<not> Rr (xs @ [Suc w])\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>x\\<le>w. Rr (xs @ [x])) \\<longrightarrow>\n                      Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} =\n                      Suc (Suc w)", "apply(cases \"\\<forall>x\\<le>w. \\<not> Rr (xs @ [x])\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} = Suc w;\n        \\<not> Rr (xs @ [Suc w]); x \\<le> w; Rr (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"Min {x. x \\<le> w \\<and> Rr (xs @ [x])} \\<in> \n                                {x. x \\<le> w \\<and> Rr (xs @ [x])}\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Min {uu_. uu_ \\<le> w \\<and> Rr (xs @ [uu_])} = Suc w;\n        \\<not> Rr (xs @ [Suc w]); x \\<le> w; Rr (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> Min {x. x \\<le> w \\<and> Rr (xs @ [x])}\n                         \\<in> {x. x \\<le> w \\<and> Rr (xs @ [x])}", "apply(rule_tac Min_in, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Minr_Suc_simp: \n  \"Minr Rr xs (Suc w) = \n      (if Minr Rr xs w \\<le> w then Minr Rr xs w\n       else if (Rr (xs @ [Suc w])) then (Suc w)\n       else Suc (Suc w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Minr Rr xs (Suc w) =\n    (if Minr Rr xs w \\<le> w then Minr Rr xs w\n     else if Rr (xs @ [Suc w]) then Suc w else Suc (Suc w))", "by(insert Minr_range[of Rr xs w], auto)"], ["", "text \\<open>\n  \\<open>rec_Minr\\<close> is the recursive function \n  used to implement \\<open>Minr\\<close>:\n  if \\<open>Rr\\<close> is implemented by a recursive function \\<open>recf\\<close>,\n  then \\<open>rec_Minr recf\\<close> is the recursive function used to \n  implement \\<open>Minr Rr\\<close>\n\\<close>"], ["", "fun rec_Minr :: \"recf \\<Rightarrow> recf\"\n  where\n    \"rec_Minr rf = \n     (let vl = arity rf\n      in let rq = rec_all (id vl (vl - 1)) (Cn (Suc vl) \n              rec_not [Cn (Suc vl) rf \n                    (get_fstn_args (Suc vl) (vl - 1) @\n                                        [id (Suc vl) (vl)])]) \n      in  rec_sigma rq)\""], ["", "lemma length_getpren_params[simp]: \"length (get_fstn_args m n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (get_fstn_args m n) = n", "by(induct n, auto simp: get_fstn_args.simps)"], ["", "lemma length_app:\n  \"(length (get_fstn_args (arity rf - Suc 0)\n                           (arity rf - Suc 0)\n   @ [Cn (arity rf - Suc 0) (constn 0)\n           [recf.id (arity rf - Suc 0) 0]]))\n    = (Suc (arity rf - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (get_fstn_args (arity rf - Suc 0) (arity rf - Suc 0) @\n      [Cn (arity rf - Suc 0) (constn 0) [recf.id (arity rf - Suc 0) 0]]) =\n    Suc (arity rf - Suc 0)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_accum: \"primerec (rec_accum rf) n \\<Longrightarrow> primerec rf n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (rec_accum rf) n \\<Longrightarrow> primerec rf n", "apply(auto simp: rec_accum.simps Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Pr (arity rf - Suc 0)\n       (Cn (arity rf - Suc 0) rf\n         (get_fstn_args (arity rf - Suc 0) (arity rf - Suc 0) @\n          [Cn (arity rf - Suc 0) (constn 0)\n            [recf.id (arity rf - Suc 0) 0]]))\n       (Cn (Suc (arity rf)) rec_mult\n         [recf.id (Suc (arity rf)) (arity rf),\n          Cn (Suc (arity rf)) rf\n           (get_fstn_args (Suc (arity rf)) (arity rf - Suc 0) @\n            [Cn (Suc (arity rf)) s\n              [recf.id (Suc (arity rf)) (arity rf - Suc 0)]])]))\n     n \\<Longrightarrow>\n    primerec rf n", "apply(erule_tac prime_pr_reverse, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = Suc (arity rf - Suc 0);\n     primerec\n      (Cn (arity rf - Suc 0) rf\n        (get_fstn_args (arity rf - Suc 0) (arity rf - Suc 0) @\n         [Cn (arity rf - Suc 0) (constn 0) [recf.id (arity rf - Suc 0) 0]]))\n      (arity rf - Suc 0);\n     primerec\n      (Cn (Suc (arity rf)) rec_mult\n        [recf.id (Suc (arity rf)) (arity rf),\n         Cn (Suc (arity rf)) rf\n          (get_fstn_args (Suc (arity rf)) (arity rf - Suc 0) @\n           [Cn (Suc (arity rf)) s\n             [recf.id (Suc (arity rf)) (arity rf - Suc 0)]])])\n      (Suc (Suc (arity rf - Suc 0)))\\<rbrakk>\n    \\<Longrightarrow> primerec rf (Suc (arity rf - Suc 0))", "apply(erule_tac prime_cn_reverse, simp only: length_app)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_all: \"primerec (rec_all rt rf) n \\<Longrightarrow>\n                       primerec rt n \\<and> primerec rf (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (rec_all rt rf) n \\<Longrightarrow>\n    primerec rt n \\<and> primerec rf (Suc n)", "apply(simp add: rec_all.simps Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (arity rf - Suc 0) rec_sg\n       [Cn (arity rf - Suc 0) (rec_accum rf)\n         (get_fstn_args (arity rf - Suc 0) (arity rf - Suc 0) @ [rt])])\n     n \\<Longrightarrow>\n    primerec rt n \\<and> primerec rf (Suc n)", "apply(erule_tac prime_cn_reverse, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = arity rf - Suc 0; primerec rec_sg (Suc 0);\n     primerec\n      (Cn (arity rf - Suc 0) (rec_accum rf)\n        (get_fstn_args (arity rf - Suc 0) (arity rf - Suc 0) @ [rt]))\n      (arity rf - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> primerec rt (arity rf - Suc 0) \\<and>\n                      primerec rf (Suc (arity rf - Suc 0))", "apply(erule_tac prime_cn_reverse, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = arity rf - Suc 0; primerec rec_sg (Suc 0);\n     primerec (rec_accum rf) (Suc (arity rf - Suc 0));\n     \\<forall>i<Suc (arity rf - Suc 0).\n        primerec\n         ((get_fstn_args (arity rf - Suc 0) (arity rf - Suc 0) @ [rt]) ! i)\n         (arity rf - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> primerec rt (arity rf - Suc 0) \\<and>\n                      primerec rf (Suc (arity rf - Suc 0))", "apply(erule_tac x = n in allE, simp add: nth_append primerec_accum)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare numeral_3_eq_3[simp]"], ["", "lemma primerec_rec_pred_1[intro]: \"primerec rec_pred (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec UF.rec_pred (Suc 0)", "apply(simp add: rec_pred_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc 0) (Pr (Suc 0) z (recf.id (Suc (Suc (Suc 0))) (Suc 0)))\n       [recf.id (Suc 0) 0, recf.id (Suc 0) 0])\n     (Suc 0)", "apply(rule_tac prime_cn, auto dest:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_minus_2[intro]: \"primerec rec_minus (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_minus (Suc (Suc 0))", "apply(auto simp: rec_minus_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_constn_1[intro]: \"primerec (constn n) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (constn n) (Suc 0)", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec (constn 0) (Suc 0)\n 2. \\<And>n.\n       primerec (constn n) (Suc 0) \\<Longrightarrow>\n       primerec (constn (Suc n)) (Suc 0)", "apply(auto simp: constn.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_sg_1[intro]: \"primerec rec_sg (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_sg (Suc 0)", "apply(simp add: rec_sg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc 0) rec_minus\n       [constn (Suc 0),\n        Cn (Suc 0) rec_minus [constn (Suc 0), recf.id (Suc 0) 0]])\n     (Suc 0)", "apply(rule_tac k = \"Suc (Suc 0)\" in prime_cn)"], ["proof (prove)\ngoal (4 subgoals):\n 1. primerec rec_minus (Suc (Suc 0))\n 2. length\n     [constn (Suc 0),\n      Cn (Suc 0) rec_minus [constn (Suc 0), recf.id (Suc 0) 0]] =\n    Suc (Suc 0)\n 3. \\<forall>i<length\n                [constn (Suc 0),\n                 Cn (Suc 0) rec_minus [constn (Suc 0), recf.id (Suc 0) 0]].\n       primerec\n        ([constn (Suc 0),\n          Cn (Suc 0) rec_minus [constn (Suc 0), recf.id (Suc 0) 0]] !\n         i)\n        (Suc 0)\n 4. Suc 0 = Suc 0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([constn (Suc 0),\n          Cn (Suc 0) rec_minus [constn (Suc 0), recf.id (Suc 0) 0]] !\n         i)\n        (Suc 0)", "apply(auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. primerec rec_minus ?k18\n 2. Suc (Suc 0) = ?k18\n 3. primerec (constn (Suc 0)) (Suc 0)", "apply( auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_getpren[elim]: \"\\<lbrakk>i < n; n \\<le> m\\<rbrakk> \\<Longrightarrow> primerec (get_fstn_args m n ! i) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> primerec (get_fstn_args m n ! i) m", "apply(induct n, auto simp: get_fstn_args.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>i < n \\<Longrightarrow> primerec (get_fstn_args m n ! i) m;\n        i < Suc n; Suc n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> primerec ((get_fstn_args m n @ [recf.id m n]) ! i)\n                          m", "apply(cases \"i = n\", auto simp: nth_append intro: prime_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_add_2[intro]: \"primerec rec_add (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_add (Suc (Suc 0))", "apply(simp add: rec_add_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Pr (Suc 0) (recf.id (Suc 0) 0)\n       (Cn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) 2]))\n     (Suc (Suc 0))", "apply(rule_tac prime_pr, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_mult_2[intro]:\"primerec rec_mult (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_mult (Suc (Suc 0))", "apply(simp add: rec_mult_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Pr (Suc 0) z\n       (Cn (Suc (Suc (Suc 0))) rec_add\n         [recf.id (Suc (Suc (Suc 0))) 0, recf.id (Suc (Suc (Suc 0))) 2]))\n     (Suc (Suc 0))", "apply(rule_tac prime_pr, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc (Suc 0))) 0, recf.id (Suc (Suc (Suc 0))) 2] ! i)\n        (Suc (Suc (Suc 0)))", "using less_2_cases numeral_2_eq_2"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc (Suc 0))) 0, recf.id (Suc (Suc (Suc 0))) 2] ! i)\n        (Suc (Suc (Suc 0)))", "by fastforce"], ["", "lemma primerec_ge_2_elim[elim]: \"\\<lbrakk>primerec rf n; n \\<ge> Suc (Suc 0)\\<rbrakk>   \\<Longrightarrow> \n                        primerec (rec_accum rf) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> primerec (rec_accum rf) n", "apply(auto simp: rec_accum.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n; i < n\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (n - Suc 0) (n - Suc 0) @\n                            [Cn (n - Suc 0) (constn 0)\n                              [recf.id (n - Suc 0) 0]]) !\n                           i)\n                          (n - Suc 0)\n 2. \\<And>i.\n       \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n; i < Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ([recf.id (Suc n) n,\n                            Cn (Suc n) rf\n                             (get_fstn_args (Suc n) (n - Suc 0) @\n                              [Cn (Suc n) s\n                                [recf.id (Suc n) (n - Suc 0)]])] !\n                           i)\n                          (Suc n)", "apply(simp add: nth_append, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> primerec rf ?k65\n 2. \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> n = ?k65\n 3. \\<And>i.\n       \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n; i < n\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc n) (n - Suc 0) @\n                            [Cn (Suc n) s [recf.id (Suc n) (n - Suc 0)]]) !\n                           i)\n                          (Suc n)", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n\\<rbrakk>\n    \\<Longrightarrow> n = n\n 2. \\<And>i.\n       \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n; i < n\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc n) (n - Suc 0) @\n                            [Cn (Suc n) s [recf.id (Suc n) (n - Suc 0)]]) !\n                           i)\n                          (Suc n)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>primerec rf n; Suc (Suc 0) \\<le> n; i < n\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc n) (n - Suc 0) @\n                            [Cn (Suc n) s [recf.id (Suc n) (n - Suc 0)]]) !\n                           i)\n                          (Suc n)", "apply(auto simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_all_iff: \n  \"\\<lbrakk>primerec rt n; primerec rf (Suc n); n > 0\\<rbrakk> \\<Longrightarrow> \n                                 primerec (rec_all rt rf) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rt n; primerec rf (Suc n); 0 < n\\<rbrakk>\n    \\<Longrightarrow> primerec (rec_all rt rf) n", "apply(simp add: rec_all.simps, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>primerec rt n; primerec rf (Suc n); 0 < n\\<rbrakk>\n       \\<Longrightarrow> primerec (rec_accum rf) (?k13 i)\n 2. \\<And>i.\n       \\<lbrakk>primerec rt n; primerec rf (Suc n); 0 < n\\<rbrakk>\n       \\<Longrightarrow> Suc n = ?k13 i\n 3. \\<And>ia.\n       \\<lbrakk>primerec rt n; primerec rf (Suc n); 0 < n;\n        ia < Suc n\\<rbrakk>\n       \\<Longrightarrow> primerec ((get_fstn_args n n @ [rt]) ! ia) n", "apply(auto, simp add: nth_append, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_not_1[intro]: \"primerec rec_not (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_not (Suc 0)", "apply(simp add: rec_not_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (Cn (Suc 0) rec_minus [constn (Suc 0), recf.id (Suc 0) 0])\n     (Suc 0)", "apply(rule prime_cn, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Min_false1[simp]: \"\\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])} \\<le> w;\n       x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n      \\<Longrightarrow>  False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> False", "apply(subgoal_tac \"finite {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n     finite {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}", "apply(subgoal_tac \"{uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])} \\<noteq> {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n     finite {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])};\n     {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n     finite {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\\<rbrakk>\n    \\<Longrightarrow> {uu.\n                       uu \\<le> w \\<and>\n                       0 < rec_exec rf (xs @ [uu])} \\<noteq>\n                      {}\n 3. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}", "apply(simp add: Min_le_iff, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<le>w. 0 < rec_exec rf (xs @ [x])\n 2. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}", "apply(rule_tac x = x in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Min {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}\n                    \\<le> w;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {uu. uu \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu])}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sigma_minr_lemma: \n  assumes prrf:  \"primerec rf (Suc (length xs))\"\n  shows \"UF.Sigma (rec_exec (rec_all (recf.id (Suc (length xs)) (length xs))\n     (Cn (Suc (Suc (length xs))) rec_not\n      [Cn (Suc (Suc (length xs))) rf (get_fstn_args (Suc (Suc (length xs))) \n       (length xs) @ [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n      (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "proof(induct w)"], ["proof (state)\ngoal (2 subgoals):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\n 2. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "let ?rt = \"(recf.id (Suc (length xs)) ((length xs)))\""], ["proof (state)\ngoal (2 subgoals):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\n 2. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "let ?rf = \"(Cn (Suc (Suc (length xs))) \n    rec_not [Cn (Suc (Suc (length xs))) rf \n    (get_fstn_args (Suc (Suc (length xs))) (length xs) @ \n                [recf.id (Suc (Suc (length xs))) \n    (Suc ((length xs)))])])\""], ["proof (state)\ngoal (2 subgoals):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\n 2. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "let ?rq = \"(rec_all ?rt ?rf)\""], ["proof (state)\ngoal (2 subgoals):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\n 2. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "have prrf: \"primerec ?rf (Suc (length (xs @ [0]))) \\<and>\n        primerec ?rt (length (xs @ [0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n     (Suc (length (xs @ [0]))) \\<and>\n    primerec (recf.id (Suc (length xs)) (length xs)) (length (xs @ [0]))", "apply(auto simp: prrf nth_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (Cn (Suc (Suc (length xs))) rec_not\n     [Cn (Suc (Suc (length xs))) rf\n       (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n        [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n   (Suc (length (xs @ [0]))) \\<and>\n  primerec (recf.id (Suc (length xs)) (length xs)) (length (xs @ [0]))\n\ngoal (2 subgoals):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\n 2. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "show \"Sigma (rec_exec (rec_all ?rt ?rf)) (xs @ [0])\n       = Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0", "apply(simp add: Sigma.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_all (recf.id (Suc (length xs)) (length xs))\n       (Cn (Suc (Suc (length xs))) rec_not\n         [Cn (Suc (Suc (length xs))) rf\n           (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n            [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n     (xs @ [0]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0", "apply(simp only: prrf all_lemma,  \n        auto simp: rec_exec.simps get_fstn_args_take Minr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rec_exec rf (xs @ [0]) \\<Longrightarrow>\n    Min {uu_. uu_ = 0 \\<and> 0 < rec_exec rf (xs @ [uu_])} = 0", "apply(rule_tac Min_eqI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (rec_all (recf.id (Suc (length xs)) (length xs))\n       (Cn (Suc (Suc (length xs))) rec_not\n         [Cn (Suc (Suc (length xs))) rf\n           (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n            [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n   (xs @ [0]) =\n  Minr (\\<lambda>args. 0 < rec_exec rf args) xs 0\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "let ?rt = \"(recf.id (Suc (length xs)) ((length xs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "let ?rf = \"(Cn (Suc (Suc (length xs))) \n    rec_not [Cn (Suc (Suc (length xs))) rf \n    (get_fstn_args (Suc (Suc (length xs))) (length xs) @ \n                [recf.id (Suc (Suc (length xs))) \n    (Suc ((length xs)))])])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "let ?rq = \"(rec_all ?rt ?rf)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "assume ind:\n    \"Sigma (rec_exec (rec_all ?rt ?rf)) (xs @ [w]) = Minr (\\<lambda>args. 0 < rec_exec rf args) xs w\""], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (rec_all (recf.id (Suc (length xs)) (length xs))\n       (Cn (Suc (Suc (length xs))) rec_not\n         [Cn (Suc (Suc (length xs))) rf\n           (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n            [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n   (xs @ [w]) =\n  Minr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "have prrf: \"primerec ?rf (Suc (length (xs @ [Suc w]))) \\<and>\n        primerec ?rt (length (xs @ [Suc w]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n     (Suc (length (xs @ [Suc w]))) \\<and>\n    primerec (recf.id (Suc (length xs)) (length xs)) (length (xs @ [Suc w]))", "apply(auto simp: prrf nth_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (Cn (Suc (Suc (length xs))) rec_not\n     [Cn (Suc (Suc (length xs))) rf\n       (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n        [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n   (Suc (length (xs @ [Suc w]))) \\<and>\n  primerec (recf.id (Suc (length xs)) (length xs)) (length (xs @ [Suc w]))\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<Longrightarrow>\n       UF.Sigma\n        (rec_exec\n          (rec_all (recf.id (Suc (length xs)) (length xs))\n            (Cn (Suc (Suc (length xs))) rec_not\n              [Cn (Suc (Suc (length xs))) rf\n                (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                 [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n        (xs @ [Suc w]) =\n       Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "show \"UF.Sigma (rec_exec (rec_all ?rt ?rf))\n         (xs @ [Suc w]) =\n        Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (rec_all (recf.id (Suc (length xs)) (length xs))\n         (Cn (Suc (Suc (length xs))) rec_not\n           [Cn (Suc (Suc (length xs))) rf\n             (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n              [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n     (xs @ [Suc w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)", "apply(auto simp: Sigma_Suc_simp_rewrite ind Minr_Suc_simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < rec_exec rf (xs @ [Suc w]);\n     Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_all (recf.id (Suc (length xs)) (length xs))\n                         (Cn (Suc (Suc (length xs))) rec_not\n                           [Cn (Suc (Suc (length xs))) rf\n                             (get_fstn_args (Suc (Suc (length xs)))\n                               (length xs) @\n                              [recf.id (Suc (Suc (length xs)))\n                                (Suc (length xs))])]))\n                       (xs @ [Suc w]) =\n                      0\n 2. \\<lbrakk>0 < rec_exec rf (xs @ [Suc w]);\n     \\<not> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w +\n                      rec_exec\n                       (rec_all (recf.id (Suc (length xs)) (length xs))\n                         (Cn (Suc (Suc (length xs))) rec_not\n                           [Cn (Suc (Suc (length xs))) rf\n                             (get_fstn_args (Suc (Suc (length xs)))\n                               (length xs) @\n                              [recf.id (Suc (Suc (length xs)))\n                                (Suc (length xs))])]))\n                       (xs @ [Suc w]) =\n                      Suc w\n 3. \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n     Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_all (recf.id (Suc (length xs)) (length xs))\n                         (Cn (Suc (Suc (length xs))) rec_not\n                           [Cn (Suc (Suc (length xs))) rf\n                             (get_fstn_args (Suc (Suc (length xs)))\n                               (length xs) @\n                              [recf.id (Suc (Suc (length xs)))\n                                (Suc (length xs))])]))\n                       (xs @ [Suc w]) =\n                      0\n 4. \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n     \\<not> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w +\n                      rec_exec\n                       (rec_all (recf.id (Suc (length xs)) (length xs))\n                         (Cn (Suc (Suc (length xs))) rec_not\n                           [Cn (Suc (Suc (length xs))) rf\n                             (get_fstn_args (Suc (Suc (length xs)))\n                               (length xs) @\n                              [recf.id (Suc (Suc (length xs)))\n                                (Suc (length xs))])]))\n                       (xs @ [Suc w]) =\n                      Suc (Suc w)", "apply(simp_all only: prrf all_lemma)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < rec_exec rf (xs @ [Suc w]);\n     Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> (if \\<forall>x\\<le>rec_exec\n    (recf.id (Suc (length xs)) (length xs)) (xs @ [Suc w]).\n                             0 < rec_exec\n                                  (Cn (Suc (Suc (length xs))) rec_not\n                                    [Cn (Suc (Suc (length xs))) rf\n(get_fstn_args (Suc (Suc (length xs))) (length xs) @\n [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n                                  ((xs @ [Suc w]) @ [x])\n                       then 1 else 0) =\n                      0\n 2. \\<lbrakk>0 < rec_exec rf (xs @ [Suc w]);\n     \\<not> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w +\n                      (if \\<forall>x\\<le>rec_exec\n    (recf.id (Suc (length xs)) (length xs)) (xs @ [Suc w]).\n                             0 < rec_exec\n                                  (Cn (Suc (Suc (length xs))) rec_not\n                                    [Cn (Suc (Suc (length xs))) rf\n(get_fstn_args (Suc (Suc (length xs))) (length xs) @\n [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n                                  ((xs @ [Suc w]) @ [x])\n                       then 1 else 0) =\n                      Suc w\n 3. \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n     Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> (if \\<forall>x\\<le>rec_exec\n    (recf.id (Suc (length xs)) (length xs)) (xs @ [Suc w]).\n                             0 < rec_exec\n                                  (Cn (Suc (Suc (length xs))) rec_not\n                                    [Cn (Suc (Suc (length xs))) rf\n(get_fstn_args (Suc (Suc (length xs))) (length xs) @\n [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n                                  ((xs @ [Suc w]) @ [x])\n                       then 1 else 0) =\n                      0\n 4. \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n     \\<not> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w \\<le> w\\<rbrakk>\n    \\<Longrightarrow> Minr (\\<lambda>args. 0 < rec_exec rf args) xs w +\n                      (if \\<forall>x\\<le>rec_exec\n    (recf.id (Suc (length xs)) (length xs)) (xs @ [Suc w]).\n                             0 < rec_exec\n                                  (Cn (Suc (Suc (length xs))) rec_not\n                                    [Cn (Suc (Suc (length xs))) rf\n(get_fstn_args (Suc (Suc (length xs))) (length xs) @\n [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n                                  ((xs @ [Suc w]) @ [x])\n                       then 1 else 0) =\n                      Suc (Suc w)", "apply(auto simp: rec_exec.simps get_fstn_args_take Let_def Minr.simps split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>0 < rec_exec rf (xs @ [Suc w]);\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]); 0 < rec_exec rf (xs @ [xa]);\n        xa \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc w\n 2. \\<And>x.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0;\n        0 < rec_exec rf (xs @ [x]); x \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n        \\<forall>x.\n           0 < rec_exec rf (xs @ [x]) \\<longrightarrow>\n           \\<not> x \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc w\n 4. \\<And>x xa.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]); 0 < rec_exec rf (xs @ [xa]);\n        xa \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc (Suc w)", "apply(drule_tac Min_false1, simp, simp, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0;\n        0 < rec_exec rf (xs @ [x]); x \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n        \\<forall>x.\n           0 < rec_exec rf (xs @ [x]) \\<longrightarrow>\n           \\<not> x \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc w\n 3. \\<And>x xa.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]); 0 < rec_exec rf (xs @ [xa]);\n        xa \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc (Suc w)", "apply (metis le_SucE neq0_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n        \\<forall>x.\n           0 < rec_exec rf (xs @ [x]) \\<longrightarrow>\n           \\<not> x \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc w\n 2. \\<And>x xa.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]); 0 < rec_exec rf (xs @ [xa]);\n        xa \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc (Suc w)", "apply(drule_tac Min_false1, simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>rec_exec rf (xs @ [Suc w]) = 0;\n        \\<not> Min {uu_. uu_ \\<le> w \\<and> 0 < rec_exec rf (xs @ [uu_])}\n               \\<le> w;\n        x \\<le> w; 0 < rec_exec rf (xs @ [x]); 0 < rec_exec rf (xs @ [xa]);\n        xa \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              uu_ \\<le> w \\<and>\n                              0 < rec_exec rf (xs @ [uu_])} =\n                         Suc (Suc w)", "apply(drule_tac Min_false1, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (rec_all (recf.id (Suc (length xs)) (length xs))\n       (Cn (Suc (Suc (length xs))) rec_not\n         [Cn (Suc (Suc (length xs))) rf\n           (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n            [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])))\n   (xs @ [Suc w]) =\n  Minr (\\<lambda>args. 0 < rec_exec rf args) xs (Suc w)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>rec_Minr\\<close>.\n\\<close>"], ["", "lemma Minr_lemma: \"\n  \\<lbrakk>primerec rf (Suc (length xs))\\<rbrakk> \n     \\<Longrightarrow> rec_exec (rec_Minr rf) (xs @ [w]) = \n            Minr (\\<lambda> args. (0 < rec_exec rf args)) xs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rt = \"(recf.id (Suc (length xs)) ((length xs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf = \"(Cn (Suc (Suc (length xs))) \n    rec_not [Cn (Suc (Suc (length xs))) rf \n    (get_fstn_args (Suc (Suc (length xs))) (length xs) @ \n                [recf.id (Suc (Suc (length xs))) \n    (Suc ((length xs)))])])\""], ["proof (state)\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rq = \"(rec_all ?rt ?rf)\""], ["proof (state)\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "assume h: \"primerec rf (Suc (length xs))\""], ["proof (state)\nthis:\n  primerec rf (Suc (length xs))\n\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "have h1: \"primerec ?rq (Suc (length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (rec_all (recf.id (Suc (length xs)) (length xs))\n       (Cn (Suc (Suc (length xs))) rec_not\n         [Cn (Suc (Suc (length xs))) rf\n           (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n            [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n     (Suc (length xs))", "apply(rule_tac primerec_all_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. primerec (recf.id (Suc (length xs)) (length xs)) (Suc (length xs))\n 2. primerec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])])\n     (Suc (Suc (length xs)))\n 3. 0 < Suc (length xs)", "apply(auto simp: h nth_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (rec_all (recf.id (Suc (length xs)) (length xs))\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n   (Suc (length xs))\n\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "moreover"], ["proof (state)\nthis:\n  primerec\n   (rec_all (recf.id (Suc (length xs)) (length xs))\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n   (Suc (length xs))\n\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "have \"arity rf = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs)", "using h"], ["proof (prove)\nusing this:\n  primerec rf (Suc (length xs))\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs)", "by auto"], ["proof (state)\nthis:\n  arity rf = Suc (length xs)\n\ngoal (1 subgoal):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow>\n    rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "ultimately"], ["proof (chain)\npicking this:\n  primerec\n   (rec_all (recf.id (Suc (length xs)) (length xs))\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n   (Suc (length xs))\n  arity rf = Suc (length xs)", "show \"rec_exec (rec_Minr rf) (xs @ [w]) = \n    Minr (\\<lambda> args. (0 < rec_exec rf args)) xs w\""], ["proof (prove)\nusing this:\n  primerec\n   (rec_all (recf.id (Suc (length xs)) (length xs))\n     (Cn (Suc (Suc (length xs))) rec_not\n       [Cn (Suc (Suc (length xs))) rf\n         (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n          [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n   (Suc (length xs))\n  arity rf = Suc (length xs)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_Minr rf) (xs @ [w]) =\n    Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "apply(simp add: arity.simps Let_def sigma_lemma all_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec\n              (rec_all (recf.id (Suc (length xs)) (length xs))\n                (Cn (Suc (Suc (length xs))) rec_not\n                  [Cn (Suc (Suc (length xs))) rf\n                    (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                     [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n              (Suc (length xs));\n     arity rf = Suc (length xs)\\<rbrakk>\n    \\<Longrightarrow> UF.Sigma\n                       (rec_exec\n                         (rec_all (recf.id (Suc (length xs)) (length xs))\n                           (Cn (Suc (Suc (length xs))) rec_not\n                             [Cn (Suc (Suc (length xs))) rf\n                               (get_fstn_args (Suc (Suc (length xs)))\n                                 (length xs) @\n                                [recf.id (Suc (Suc (length xs)))\n                                  (Suc (length xs))])])))\n                       (xs @ [w]) =\n                      Minr (\\<lambda>args. 0 < rec_exec rf args) xs w", "apply(rule_tac  sigma_minr_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec\n              (rec_all (recf.id (Suc (length xs)) (length xs))\n                (Cn (Suc (Suc (length xs))) rec_not\n                  [Cn (Suc (Suc (length xs))) rf\n                    (get_fstn_args (Suc (Suc (length xs))) (length xs) @\n                     [recf.id (Suc (Suc (length xs))) (Suc (length xs))])]))\n              (Suc (length xs));\n     arity rf = Suc (length xs)\\<rbrakk>\n    \\<Longrightarrow> primerec rf (Suc (length xs))", "apply(simp add: h)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec (rec_Minr rf) (xs @ [w]) =\n  Minr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  \\<open>rec_le\\<close> is the comparasion function \n  which compares its two arguments, testing whether the \n  first is less or equal to the second.\n\\<close>"], ["", "definition rec_le :: \"recf\"\n  where\n    \"rec_le = Cn (Suc (Suc 0)) rec_disj [rec_less, rec_eq]\""], ["", "text \\<open>\n  The correctness of \\<open>rec_le\\<close>.\n\\<close>"], ["", "lemma le_lemma: \n  \"\\<And>x y. rec_exec rec_le [x, y] = (if (x \\<le> y) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_le [x, y] = (if x \\<le> y then 1 else 0)", "by(auto simp: rec_le_def rec_exec.simps)"], ["", "text \\<open>\n  Definition of \\<open>Max[Rr]\\<close> on page 77 of Boolos's book.\n\\<close>"], ["", "fun Maxr :: \"(nat list \\<Rightarrow> bool) \\<Rightarrow> nat list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"Maxr Rr xs w = (let setx = {y. y \\<le> w \\<and> Rr (xs @[y])} in \n                  if setx = {} then 0\n                  else Max setx)\""], ["", "text \\<open>\n  \\<open>rec_maxr\\<close> is the recursive function \n  used to implementation \\<open>Maxr\\<close>.\n\\<close>"], ["", "fun rec_maxr :: \"recf \\<Rightarrow> recf\"\n  where\n    \"rec_maxr rr = (let vl = arity rr in \n                  let rt = id (Suc vl) (vl - 1) in\n                  let rf1 = Cn (Suc (Suc vl)) rec_le \n                    [id (Suc (Suc vl)) \n                     ((Suc vl)), id (Suc (Suc vl)) (vl)] in\n                  let rf2 = Cn (Suc (Suc vl)) rec_not \n                      [Cn (Suc (Suc vl)) \n                           rr (get_fstn_args (Suc (Suc vl)) \n                            (vl - 1) @ \n                             [id (Suc (Suc vl)) ((Suc vl))])] in\n                  let rf = Cn (Suc (Suc vl)) rec_disj [rf1, rf2] in\n                  let Qf = Cn (Suc vl) rec_not [rec_all rt rf]\n                  in Cn vl (rec_sigma Qf) (get_fstn_args vl vl @\n                                                         [id vl (vl - 1)]))\""], ["", "declare rec_maxr.simps[simp del] Maxr.simps[simp del]"], ["", "declare le_lemma[simp]"], ["", "declare numeral_2_eq_2[simp]"], ["", "lemma primerec_rec_disj_2[intro]: \"primerec rec_disj (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_disj (Suc (Suc 0))", "apply(simp add: rec_disj_def, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. primerec rec_add ?k12\n 2. Suc (Suc 0) = ?k12\n 3. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0)] ! i)\n        (Suc (Suc 0))", "apply(auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_less_2[intro]: \"primerec rec_less (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_less (Suc (Suc 0))", "apply(simp add: rec_less_def, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. primerec rec_minus ?k12\n 2. Suc (Suc 0) = ?k12\n 3. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc 0)) (Suc 0), recf.id (Suc (Suc 0)) 0] ! i)\n        (Suc (Suc 0))", "apply(auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_eq_2[intro]: \"primerec rec_eq (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_eq (Suc (Suc 0))", "apply(simp add: rec_eq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc 0)) rec_minus\n       [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n        Cn (Suc (Suc 0)) rec_add\n         [Cn (Suc (Suc 0)) rec_minus\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0)) rec_minus\n           [recf.id (Suc (Suc 0)) (Suc 0), recf.id (Suc (Suc 0)) 0]]])\n     (Suc (Suc 0))", "apply(rule_tac prime_cn, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (6 subgoals):\n 1. primerec rec_add ?k30\n 2. Suc (Suc 0) = ?k30\n 3. primerec rec_minus ?k36\n 4. Suc (Suc 0) = ?k36\n 5. primerec rec_minus ?k49\n 6. Suc (Suc 0) = ?k49", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_le_2[intro]: \"primerec rec_le (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_le (Suc (Suc 0))", "apply(simp add: rec_le_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (Cn (Suc (Suc 0)) rec_disj [rec_less, rec_eq]) (Suc (Suc 0))", "apply(rule_tac prime_cn, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Sigma_0: \"\\<forall> i \\<le> n. (f (xs @ [i]) = 0) \\<Longrightarrow> \n                              Sigma f (xs @ [n]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. f (xs @ [i]) = 0 \\<Longrightarrow>\n    UF.Sigma f (xs @ [n]) = 0", "apply(induct n, simp add: Sigma.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i\\<le>n. f (xs @ [i]) = 0 \\<Longrightarrow>\n                UF.Sigma f (xs @ [n]) = 0;\n        \\<forall>i\\<le>Suc n. f (xs @ [i]) = 0\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [Suc n]) = 0", "apply(simp add: Sigma_Suc_simp_rewrite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Sigma_Suc[elim]: \"\\<forall>k<Suc w. f (xs @ [k]) = Suc 0\n        \\<Longrightarrow> Sigma f (xs @ [w]) = Suc w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k<Suc w. f (xs @ [k]) = Suc 0 \\<Longrightarrow>\n    UF.Sigma f (xs @ [w]) = Suc w", "apply(induct w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>k<Suc 0. f (xs @ [k]) = Suc 0 \\<Longrightarrow>\n    UF.Sigma f (xs @ [0]) = Suc 0\n 2. \\<And>w.\n       \\<lbrakk>\\<forall>k<Suc w. f (xs @ [k]) = Suc 0 \\<Longrightarrow>\n                UF.Sigma f (xs @ [w]) = Suc w;\n        \\<forall>k<Suc (Suc w). f (xs @ [k]) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [Suc w]) = Suc (Suc w)", "apply(simp add: Sigma.simps, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>UF.Sigma f (xs @ [w]) = Suc w;\n        \\<forall>k<Suc (Suc w). f (xs @ [k]) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [Suc w]) = Suc (Suc w)", "apply(simp add: Sigma.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Sigma_max_point: \"\\<lbrakk>\\<forall> k < ma. f (xs @ [k]) = 1;\n        \\<forall> k \\<ge> ma. f (xs @ [k]) = 0; ma \\<le> w\\<rbrakk>\n    \\<Longrightarrow> Sigma f (xs @ [w]) = ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k<ma. f (xs @ [k]) = 1;\n     \\<forall>k\\<ge>ma. f (xs @ [k]) = 0; ma \\<le> w\\<rbrakk>\n    \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma", "apply(induct w, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k. f (xs @ [k]) = 0; ma = 0\\<rbrakk>\n    \\<Longrightarrow> UF.Sigma f (xs @ [0]) = 0\n 2. \\<And>w.\n       \\<lbrakk>ma \\<le> w \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma;\n        \\<forall>k<ma. f (xs @ [k]) = Suc 0;\n        \\<forall>k\\<ge>ma. f (xs @ [k]) = 0; ma \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [Suc w]) = ma", "apply(rule_tac Sigma_0, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>ma \\<le> w \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma;\n        \\<forall>k<ma. f (xs @ [k]) = Suc 0;\n        \\<forall>k\\<ge>ma. f (xs @ [k]) = 0; ma \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [Suc w]) = ma", "apply(simp add: Sigma_Suc_simp_rewrite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>ma \\<le> w \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma;\n        \\<forall>k<ma. f (xs @ [k]) = Suc 0;\n        \\<forall>k\\<ge>ma. f (xs @ [k]) = 0; ma \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma", "using Sigma_Suc"], ["proof (prove)\nusing this:\n  \\<forall>k<Suc ?w. ?f (?xs @ [k]) = Suc 0 \\<Longrightarrow>\n  UF.Sigma ?f (?xs @ [?w]) = Suc ?w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>ma \\<le> w \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma;\n        \\<forall>k<ma. f (xs @ [k]) = Suc 0;\n        \\<forall>k\\<ge>ma. f (xs @ [k]) = 0; ma \\<le> Suc w\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma f (xs @ [w]) = ma", "by fastforce"], ["", "lemma Sigma_Max_lemma: \n  assumes prrf: \"primerec rf (Suc (length xs))\"\n  shows \"UF.Sigma (rec_exec (Cn (Suc (Suc (length xs))) rec_not\n  [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n  (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n  [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))), \n  recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n  Cn (Suc (Suc (Suc (length xs)))) rec_not\n  [Cn (Suc (Suc (Suc (length xs)))) rf\n  (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @ \n  [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n  ((xs @ [w]) @ [w]) =\n       Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rt = \"(recf.id (Suc (Suc (length xs))) ((length xs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf1 = \"Cn (Suc (Suc (Suc (length xs))))\n    rec_le [recf.id (Suc (Suc (Suc (length xs)))) \n    ((Suc (Suc (length xs)))), recf.id \n    (Suc (Suc (Suc (length xs)))) ((Suc (length xs)))]\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf2 = \"Cn (Suc (Suc (Suc (length xs)))) rf \n               (get_fstn_args (Suc (Suc (Suc (length xs))))\n    (length xs) @ \n    [recf.id (Suc (Suc (Suc (length xs))))    \n    ((Suc (Suc (length xs))))])\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf3 = \"Cn (Suc (Suc (Suc (length xs)))) rec_not [?rf2]\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf = \"Cn (Suc (Suc (Suc (length xs)))) rec_disj [?rf1, ?rf3]\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rq = \"rec_all ?rt ?rf\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?notrq = \"Cn (Suc (Suc (length xs))) rec_not [?rq]\""], ["proof (state)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "proof(auto simp: Maxr.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0 \\<Longrightarrow>\n    UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    0\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "assume h: \"\\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0\""], ["proof (state)\nthis:\n  \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0 \\<Longrightarrow>\n    UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    0\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "have \"primerec ?rf (Suc (length (xs @ [w, i]))) \\<and> \n          primerec ?rt (length (xs @ [w, i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n       [Cn (Suc (Suc (Suc (length xs)))) rec_le\n         [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n          recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n        Cn (Suc (Suc (Suc (length xs)))) rec_not\n         [Cn (Suc (Suc (Suc (length xs)))) rf\n           (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n            [recf.id (Suc (Suc (Suc (length xs))))\n              (Suc (Suc (length xs)))])]])\n     (Suc (length (xs @ [w, i]))) \\<and>\n    primerec (recf.id (Suc (Suc (length xs))) (length xs))\n     (length (xs @ [w, i]))", "using prrf"], ["proof (prove)\nusing this:\n  primerec rf (Suc (length xs))\n\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n       [Cn (Suc (Suc (Suc (length xs)))) rec_le\n         [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n          recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n        Cn (Suc (Suc (Suc (length xs)))) rec_not\n         [Cn (Suc (Suc (Suc (length xs)))) rf\n           (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n            [recf.id (Suc (Suc (Suc (length xs))))\n              (Suc (Suc (length xs)))])]])\n     (Suc (length (xs @ [w, i]))) \\<and>\n    primerec (recf.id (Suc (Suc (length xs))) (length xs))\n     (length (xs @ [w, i]))", "apply(auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (7 subgoals):\n 1. primerec rf (Suc (length xs)) \\<Longrightarrow> primerec rec_le ?k19\n 2. primerec rf (Suc (length xs)) \\<Longrightarrow> Suc (Suc 0) = ?k19\n 3. primerec rf (Suc (length xs)) \\<Longrightarrow> primerec rec_not ?k32\n 4. primerec rf (Suc (length xs)) \\<Longrightarrow> Suc 0 = ?k32\n 5. \\<And>i.\n       primerec rf (Suc (length xs)) \\<Longrightarrow> primerec rf (?k36 i)\n 6. \\<And>i.\n       primerec rf (Suc (length xs)) \\<Longrightarrow>\n       Suc (length xs) = ?k36 i\n 7. \\<And>ia.\n       \\<lbrakk>primerec rf (Suc (length xs)); ia < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc (Suc (Suc (length xs))))\n                             (length xs) @\n                            [recf.id (Suc (Suc (Suc (length xs))))\n                              (Suc (Suc (length xs)))]) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>primerec rf (Suc (length xs)); ia < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc (Suc (Suc (length xs))))\n                             (length xs) @\n                            [recf.id (Suc (Suc (Suc (length xs))))\n                              (Suc (Suc (length xs)))]) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "apply(case_tac ia, auto simp: h nth_append primerec_getpren)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n     [Cn (Suc (Suc (Suc (length xs)))) rec_le\n       [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n        recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n      Cn (Suc (Suc (Suc (length xs)))) rec_not\n       [Cn (Suc (Suc (Suc (length xs)))) rf\n         (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs))))\n            (Suc (Suc (length xs)))])]])\n   (Suc (length (xs @ [w, i]))) \\<and>\n  primerec (recf.id (Suc (Suc (length xs))) (length xs))\n   (length (xs @ [w, i]))\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0 \\<Longrightarrow>\n    UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    0\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "hence \"Sigma (rec_exec ?notrq) ((xs@[w])@[w]) = 0\""], ["proof (prove)\nusing this:\n  primerec\n   (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n     [Cn (Suc (Suc (Suc (length xs)))) rec_le\n       [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n        recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n      Cn (Suc (Suc (Suc (length xs)))) rec_not\n       [Cn (Suc (Suc (Suc (length xs)))) rf\n         (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs))))\n            (Suc (Suc (length xs)))])]])\n   (Suc (length (xs @ [w, i]))) \\<and>\n  primerec (recf.id (Suc (Suc (length xs))) (length xs))\n   (length (xs @ [w, i]))\n\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    0", "apply(rule_tac Sigma_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n       [Cn (Suc (Suc (Suc (length xs)))) rec_le\n         [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n          recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n        Cn (Suc (Suc (Suc (length xs)))) rec_not\n         [Cn (Suc (Suc (Suc (length xs)))) rf\n           (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n            [recf.id (Suc (Suc (Suc (length xs))))\n              (Suc (Suc (length xs)))])]])\n     (Suc (length (xs @ [w, i]))) \\<and>\n    primerec (recf.id (Suc (Suc (length xs))) (length xs))\n     (length (xs @ [w, i])) \\<Longrightarrow>\n    \\<forall>i\\<le>w.\n       rec_exec\n        (Cn (Suc (Suc (length xs))) rec_not\n          [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n            (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n              [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs))),\n                 recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n               Cn (Suc (Suc (Suc (length xs)))) rec_not\n                [Cn (Suc (Suc (Suc (length xs)))) rf\n                  (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                   [recf.id (Suc (Suc (Suc (length xs))))\n                     (Suc (Suc (length xs)))])]])])\n        ((xs @ [w]) @ [i]) =\n       0", "apply(auto simp: rec_exec.simps all_lemma\n          get_fstn_args_take nth_append h)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  0\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<le>w. rec_exec rf (xs @ [x]) = 0 \\<Longrightarrow>\n    UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    0\n 2. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "thus \"UF.Sigma (rec_exec ?notrq)\n      (xs @ [w, w]) = 0\""], ["proof (prove)\nusing this:\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  0\n\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    0", "by simp"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   (xs @ [w, w]) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "assume h: \"x \\<le> w\" \"0 < rec_exec rf (xs @ [x])\""], ["proof (state)\nthis:\n  x \\<le> w\n  0 < rec_exec rf (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "hence \"\\<exists> ma. Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\""], ["proof (prove)\nusing this:\n  x \\<le> w\n  0 < rec_exec rf (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>ma. Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma", "by auto"], ["proof (state)\nthis:\n  \\<exists>ma. Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "from this"], ["proof (chain)\npicking this:\n  \\<exists>ma. Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma", "obtain ma where k1: \n      \"Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\""], ["proof (prove)\nusing this:\n  \\<exists>ma. Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n\ngoal (1 subgoal):\n 1. (\\<And>ma.\n        Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} =\n        ma \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "hence k2: \"ma \\<le> w \\<and> 0 < rec_exec rf (xs @ [ma])\""], ["proof (prove)\nusing this:\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n\ngoal (1 subgoal):\n 1. ma \\<le> w \\<and> 0 < rec_exec rf (xs @ [ma])", "using h"], ["proof (prove)\nusing this:\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n  x \\<le> w\n  0 < rec_exec rf (xs @ [x])\n\ngoal (1 subgoal):\n 1. ma \\<le> w \\<and> 0 < rec_exec rf (xs @ [ma])", "apply(subgoal_tac\n          \"Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} \\<in>  {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x]);\n     Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\n     \\<in> {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\\<rbrakk>\n    \\<Longrightarrow> ma \\<le> w \\<and> 0 < rec_exec rf (xs @ [ma])\n 2. \\<lbrakk>Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\n                      \\<in> {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}", "apply(erule_tac CollectE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma;\n     x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\n                      \\<in> {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}", "apply(rule_tac Max_in, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ma \\<le> w \\<and> 0 < rec_exec rf (xs @ [ma])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "hence k3: \"\\<forall> k < ma. (rec_exec ?notrq (xs @ [w, k]) = 1)\""], ["proof (prove)\nusing this:\n  ma \\<le> w \\<and> 0 < rec_exec rf (xs @ [ma])\n\ngoal (1 subgoal):\n 1. \\<forall>k<ma.\n       rec_exec\n        (Cn (Suc (Suc (length xs))) rec_not\n          [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n            (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n              [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs))),\n                 recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n               Cn (Suc (Suc (Suc (length xs)))) rec_not\n                [Cn (Suc (Suc (Suc (length xs)))) rf\n                  (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                   [recf.id (Suc (Suc (Suc (length xs))))\n                     (Suc (Suc (length xs)))])]])])\n        (xs @ [w, k]) =\n       1", "apply(auto simp: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (Suc (Suc (length xs))) rec_not\n                            [rec_all\n                              (recf.id (Suc (Suc (length xs))) (length xs))\n                              (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                  [recf.id (Suc (Suc (Suc (length xs))))\n                                    (Suc (Suc (length xs))),\n                                   recf.id (Suc (Suc (Suc (length xs))))\n                                    (Suc (length xs))],\n                                 Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                  [Cn (Suc (Suc (Suc (length xs)))) rf\n                                    (get_fstn_args\n(Suc (Suc (Suc (length xs)))) (length xs) @\n                                     [recf.id (Suc (Suc (Suc (length xs))))\n (Suc (Suc (length xs)))])]])])\n                          (xs @ [w, k]) =\n                         Suc 0", "apply(subgoal_tac \"primerec ?rf (Suc (length (xs @ [w, k]))) \\<and> \n        primerec ?rt (length (xs @ [w, k]))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma;\n        primerec\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])\n         (Suc (length (xs @ [w, k]))) \\<and>\n        primerec (recf.id (Suc (Suc (length xs))) (length xs))\n         (length (xs @ [w, k]))\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (Suc (Suc (length xs))) rec_not\n                            [rec_all\n                              (recf.id (Suc (Suc (length xs))) (length xs))\n                              (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                  [recf.id (Suc (Suc (Suc (length xs))))\n                                    (Suc (Suc (length xs))),\n                                   recf.id (Suc (Suc (Suc (length xs))))\n                                    (Suc (length xs))],\n                                 Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                  [Cn (Suc (Suc (Suc (length xs)))) rf\n                                    (get_fstn_args\n(Suc (Suc (Suc (length xs)))) (length xs) @\n                                     [recf.id (Suc (Suc (Suc (length xs))))\n (Suc (Suc (length xs)))])]])])\n                          (xs @ [w, k]) =\n                         Suc 0\n 2. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                              [recf.id (Suc (Suc (Suc (length xs))))\n                                (Suc (Suc (length xs))),\n                               recf.id (Suc (Suc (Suc (length xs))))\n                                (Suc (length xs))],\n                             Cn (Suc (Suc (Suc (length xs)))) rec_not\n                              [Cn (Suc (Suc (Suc (length xs)))) rf\n                                (get_fstn_args (Suc (Suc (Suc (length xs))))\n                                  (length xs) @\n                                 [recf.id (Suc (Suc (Suc (length xs))))\n                                   (Suc (Suc (length xs)))])]])\n                          (Suc (length (xs @ [w, k]))) \\<and>\n                         primerec\n                          (recf.id (Suc (Suc (length xs))) (length xs))\n                          (length (xs @ [w, k]))", "apply(auto simp: rec_exec.simps all_lemma get_fstn_args_take nth_append\n          dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec rec_le (?k69 k)\n 2. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc 0) = ?k69 k\n 3. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec rec_not (?k82 k)\n 4. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> Suc 0 = ?k82 k\n 5. \\<And>k i.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec rf (?k86 k i)\n 6. \\<And>k i.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> Suc (length xs) = ?k86 k i\n 7. \\<And>k ia.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma;\n        ia < length xs\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          (get_fstn_args (Suc (Suc (Suc (length xs))))\n                            (length xs) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "using prrf"], ["proof (prove)\nusing this:\n  primerec rf (Suc (length xs))\n\ngoal (7 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec rec_le (?k69 k)\n 2. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc 0) = ?k69 k\n 3. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec rec_not (?k82 k)\n 4. \\<And>k.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> Suc 0 = ?k82 k\n 5. \\<And>k i.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> primerec rf (?k86 k i)\n 6. \\<And>k i.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma\\<rbrakk>\n       \\<Longrightarrow> Suc (length xs) = ?k86 k i\n 7. \\<And>k ia.\n       \\<lbrakk>ma \\<le> w; 0 < rec_exec rf (xs @ [ma]); k < ma;\n        ia < length xs\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          (get_fstn_args (Suc (Suc (Suc (length xs))))\n                            (length xs) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>k<ma.\n     rec_exec\n      (Cn (Suc (Suc (length xs))) rec_not\n        [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs))),\n               recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n             Cn (Suc (Suc (Suc (length xs)))) rec_not\n              [Cn (Suc (Suc (Suc (length xs)))) rf\n                (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                 [recf.id (Suc (Suc (Suc (length xs))))\n                   (Suc (Suc (length xs)))])]])])\n      (xs @ [w, k]) =\n     1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "have k4: \"\\<forall> k \\<ge> ma. (rec_exec ?notrq (xs @ [w, k]) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>ma.\n       rec_exec\n        (Cn (Suc (Suc (length xs))) rec_not\n          [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n            (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n              [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs))),\n                 recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n               Cn (Suc (Suc (Suc (length xs)))) rec_not\n                [Cn (Suc (Suc (Suc (length xs)))) rf\n                  (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                   [recf.id (Suc (Suc (Suc (length xs))))\n                     (Suc (Suc (length xs)))])]])])\n        (xs @ [w, k]) =\n       0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       ma \\<le> k \\<Longrightarrow>\n       rec_exec\n        (Cn (Suc (Suc (length xs))) rec_not\n          [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n            (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n              [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs))),\n                 recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n               Cn (Suc (Suc (Suc (length xs)))) rec_not\n                [Cn (Suc (Suc (Suc (length xs)))) rf\n                  (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                   [recf.id (Suc (Suc (Suc (length xs))))\n                     (Suc (Suc (length xs)))])]])])\n        (xs @ [w, k]) =\n       0", "apply(subgoal_tac \"primerec ?rf (Suc (length (xs @ [w, k]))) \\<and> \n        primerec ?rt (length (xs @ [w, k]))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>ma \\<le> k;\n        primerec\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])\n         (Suc (length (xs @ [w, k]))) \\<and>\n        primerec (recf.id (Suc (Suc (length xs))) (length xs))\n         (length (xs @ [w, k]))\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          (Cn (Suc (Suc (length xs))) rec_not\n                            [rec_all\n                              (recf.id (Suc (Suc (length xs))) (length xs))\n                              (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                  [recf.id (Suc (Suc (Suc (length xs))))\n                                    (Suc (Suc (length xs))),\n                                   recf.id (Suc (Suc (Suc (length xs))))\n                                    (Suc (length xs))],\n                                 Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                  [Cn (Suc (Suc (Suc (length xs)))) rf\n                                    (get_fstn_args\n(Suc (Suc (Suc (length xs)))) (length xs) @\n                                     [recf.id (Suc (Suc (Suc (length xs))))\n (Suc (Suc (length xs)))])]])])\n                          (xs @ [w, k]) =\n                         0\n 2. \\<And>k.\n       ma \\<le> k \\<Longrightarrow>\n       primerec\n        (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n          [Cn (Suc (Suc (Suc (length xs)))) rec_le\n            [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n             recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n           Cn (Suc (Suc (Suc (length xs)))) rec_not\n            [Cn (Suc (Suc (Suc (length xs)))) rf\n              (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs)))])]])\n        (Suc (length (xs @ [w, k]))) \\<and>\n       primerec (recf.id (Suc (Suc (length xs))) (length xs))\n        (length (xs @ [w, k]))", "apply(auto simp: rec_exec.simps all_lemma get_fstn_args_take nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>ma \\<le> k;\n        primerec\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])\n         (Suc (Suc (Suc (length xs))));\n        primerec (recf.id (Suc (Suc (length xs))) (length xs))\n         (Suc (Suc (length xs)));\n        \\<not> x \\<le> k; 0 < rec_exec rf (xs @ [x]); x \\<le> w\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>k i.\n       \\<lbrakk>ma \\<le> k; i < Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ([Cn (Suc (Suc (Suc (length xs)))) rec_le\n                             [recf.id (Suc (Suc (Suc (length xs))))\n                               (Suc (Suc (length xs))),\n                              recf.id (Suc (Suc (Suc (length xs))))\n                               (Suc (length xs))],\n                            Cn (Suc (Suc (Suc (length xs)))) rec_not\n                             [Cn (Suc (Suc (Suc (length xs)))) rf\n                               (get_fstn_args (Suc (Suc (Suc (length xs))))\n                                 (length xs) @\n                                [recf.id (Suc (Suc (Suc (length xs))))\n                                  (Suc (Suc (length xs)))])]] !\n                           i)\n                          (Suc (Suc (Suc (length xs))))", "apply(subgoal_tac \"x \\<le> Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\",\n          simp add: k1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>ma \\<le> k;\n        primerec\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])\n         (Suc (Suc (Suc (length xs))));\n        primerec (recf.id (Suc (Suc (length xs))) (length xs))\n         (Suc (Suc (length xs)));\n        \\<not> x \\<le> k; 0 < rec_exec rf (xs @ [x]); x \\<le> w\\<rbrakk>\n       \\<Longrightarrow> x \\<le> Max {y.\ny \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\n 2. \\<And>k i.\n       \\<lbrakk>ma \\<le> k; i < Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ([Cn (Suc (Suc (Suc (length xs)))) rec_le\n                             [recf.id (Suc (Suc (Suc (length xs))))\n                               (Suc (Suc (length xs))),\n                              recf.id (Suc (Suc (Suc (length xs))))\n                               (Suc (length xs))],\n                            Cn (Suc (Suc (Suc (length xs)))) rec_not\n                             [Cn (Suc (Suc (Suc (length xs)))) rf\n                               (get_fstn_args (Suc (Suc (Suc (length xs))))\n                                 (length xs) @\n                                [recf.id (Suc (Suc (Suc (length xs))))\n                                  (Suc (Suc (length xs)))])]] !\n                           i)\n                          (Suc (Suc (Suc (length xs))))", "apply(rule_tac Max_ge, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>k. ma \\<le> k \\<Longrightarrow> primerec rec_le (?k63 k)\n 2. \\<And>k. ma \\<le> k \\<Longrightarrow> Suc (Suc 0) = ?k63 k\n 3. \\<And>k. ma \\<le> k \\<Longrightarrow> primerec rec_not (?k75 k)\n 4. \\<And>k. ma \\<le> k \\<Longrightarrow> Suc 0 = ?k75 k\n 5. \\<And>k i. ma \\<le> k \\<Longrightarrow> primerec rf (?k79 k i)\n 6. \\<And>k i. ma \\<le> k \\<Longrightarrow> Suc (length xs) = ?k79 k i\n 7. \\<And>k ia.\n       \\<lbrakk>ma \\<le> k; ia < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc (Suc (Suc (length xs))))\n                             (length xs) @\n                            [recf.id (Suc (Suc (Suc (length xs))))\n                              (Suc (Suc (length xs)))]) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "using prrf"], ["proof (prove)\nusing this:\n  primerec rf (Suc (length xs))\n\ngoal (7 subgoals):\n 1. \\<And>k. ma \\<le> k \\<Longrightarrow> primerec rec_le (?k63 k)\n 2. \\<And>k. ma \\<le> k \\<Longrightarrow> Suc (Suc 0) = ?k63 k\n 3. \\<And>k. ma \\<le> k \\<Longrightarrow> primerec rec_not (?k75 k)\n 4. \\<And>k. ma \\<le> k \\<Longrightarrow> Suc 0 = ?k75 k\n 5. \\<And>k i. ma \\<le> k \\<Longrightarrow> primerec rf (?k79 k i)\n 6. \\<And>k i. ma \\<le> k \\<Longrightarrow> Suc (length xs) = ?k79 k i\n 7. \\<And>k ia.\n       \\<lbrakk>ma \\<le> k; ia < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc (Suc (Suc (length xs))))\n                             (length xs) @\n                            [recf.id (Suc (Suc (Suc (length xs))))\n                              (Suc (Suc (length xs)))]) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k ia.\n       \\<lbrakk>ma \\<le> k; ia < Suc (length xs)\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args (Suc (Suc (Suc (length xs))))\n                             (length xs) @\n                            [recf.id (Suc (Suc (Suc (length xs))))\n                              (Suc (Suc (length xs)))]) !\n                           ia)\n                          (Suc (Suc (Suc (length xs))))", "apply(auto simp: h nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>k\\<ge>ma.\n     rec_exec\n      (Cn (Suc (Suc (length xs))) rec_not\n        [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs))),\n               recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n             Cn (Suc (Suc (Suc (length xs)))) rec_not\n              [Cn (Suc (Suc (Suc (length xs)))) rf\n                (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                 [recf.id (Suc (Suc (Suc (length xs))))\n                   (Suc (Suc (length xs)))])]])])\n      (xs @ [w, k]) =\n     0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "from k3 k4 k1"], ["proof (chain)\npicking this:\n  \\<forall>k<ma.\n     rec_exec\n      (Cn (Suc (Suc (length xs))) rec_not\n        [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs))),\n               recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n             Cn (Suc (Suc (Suc (length xs)))) rec_not\n              [Cn (Suc (Suc (Suc (length xs)))) rf\n                (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                 [recf.id (Suc (Suc (Suc (length xs))))\n                   (Suc (Suc (length xs)))])]])])\n      (xs @ [w, k]) =\n     1\n  \\<forall>k\\<ge>ma.\n     rec_exec\n      (Cn (Suc (Suc (length xs))) rec_not\n        [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs))),\n               recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n             Cn (Suc (Suc (Suc (length xs)))) rec_not\n              [Cn (Suc (Suc (Suc (length xs)))) rf\n                (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                 [recf.id (Suc (Suc (Suc (length xs))))\n                   (Suc (Suc (length xs)))])]])])\n      (xs @ [w, k]) =\n     0\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma", "have \"Sigma (rec_exec ?notrq) ((xs @ [w]) @ [w]) = ma\""], ["proof (prove)\nusing this:\n  \\<forall>k<ma.\n     rec_exec\n      (Cn (Suc (Suc (length xs))) rec_not\n        [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs))),\n               recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n             Cn (Suc (Suc (Suc (length xs)))) rec_not\n              [Cn (Suc (Suc (Suc (length xs)))) rf\n                (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                 [recf.id (Suc (Suc (Suc (length xs))))\n                   (Suc (Suc (length xs)))])]])])\n      (xs @ [w, k]) =\n     1\n  \\<forall>k\\<ge>ma.\n     rec_exec\n      (Cn (Suc (Suc (length xs))) rec_not\n        [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n          (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n            [Cn (Suc (Suc (Suc (length xs)))) rec_le\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs))),\n               recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n             Cn (Suc (Suc (Suc (length xs)))) rec_not\n              [Cn (Suc (Suc (Suc (length xs)))) rf\n                (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                 [recf.id (Suc (Suc (Suc (length xs))))\n                   (Suc (Suc (length xs)))])]])])\n      (xs @ [w, k]) =\n     0\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    ma", "apply(rule_tac Sigma_max_point, simp, simp, simp add: k2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  ma\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<le> w; 0 < rec_exec rf (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> UF.Sigma\n                          (rec_exec\n                            (Cn (Suc (Suc (length xs))) rec_not\n                              [rec_all\n                                (recf.id (Suc (Suc (length xs)))\n                                  (length xs))\n                                (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                                  [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs))),\n                                     recf.id (Suc (Suc (Suc (length xs))))\n(Suc (length xs))],\n                                   Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                    [Cn (Suc (Suc (Suc (length xs)))) rf\n(get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))])]])]))\n                          (xs @ [w, w]) =\n                         Max {y. y \\<le> w \\<and>\n                                 0 < rec_exec rf (xs @ [y])}", "from k1 and this"], ["proof (chain)\npicking this:\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  ma", "show \"Sigma (rec_exec ?notrq) (xs @ [w, w]) =\n      Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\""], ["proof (prove)\nusing this:\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])} = ma\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  ma\n\ngoal (1 subgoal):\n 1. UF.Sigma\n     (rec_exec\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}", "by simp"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   (xs @ [w, w]) =\n  Max {y. y \\<le> w \\<and> 0 < rec_exec rf (xs @ [y])}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UF.Sigma\n   (rec_exec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>rec_maxr\\<close>.\n\\<close>"], ["", "lemma Maxr_lemma:\n  assumes h: \"primerec rf (Suc (length xs))\"\n  shows   \"rec_exec (rec_maxr rf) (xs @ [w]) = \n            Maxr (\\<lambda> args. 0 < rec_exec rf args) xs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_maxr rf) (xs @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec (rec_maxr rf) (xs @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "from h"], ["proof (chain)\npicking this:\n  primerec rf (Suc (length xs))", "have \"arity rf = Suc (length xs)\""], ["proof (prove)\nusing this:\n  primerec rf (Suc (length xs))\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs)", "by auto"], ["proof (state)\nthis:\n  arity rf = Suc (length xs)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_maxr rf) (xs @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  arity rf = Suc (length xs)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_maxr rf) (xs @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "proof(simp add: rec_exec.simps rec_maxr.simps nth_append get_fstn_args_take)"], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rt = \"(recf.id (Suc (Suc (length xs))) ((length xs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf1 = \"Cn (Suc (Suc (Suc (length xs))))\n                     rec_le [recf.id (Suc (Suc (Suc (length xs)))) \n              ((Suc (Suc (length xs)))), recf.id \n             (Suc (Suc (Suc (length xs)))) ((Suc (length xs)))]\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf2 = \"Cn (Suc (Suc (Suc (length xs)))) rf \n               (get_fstn_args (Suc (Suc (Suc (length xs))))\n                (length xs) @ \n                  [recf.id (Suc (Suc (Suc (length xs))))    \n                           ((Suc (Suc (length xs))))])\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf3 = \"Cn (Suc (Suc (Suc (length xs)))) rec_not [?rf2]\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rf = \"Cn (Suc (Suc (Suc (length xs)))) rec_disj [?rf1, ?rf3]\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?rq = \"rec_all ?rt ?rf\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "let ?notrq = \"Cn (Suc (Suc (length xs))) rec_not [?rq]\""], ["proof (state)\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "have prt: \"primerec ?rt (Suc (Suc (length xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (recf.id (Suc (Suc (length xs))) (length xs))\n     (Suc (Suc (length xs)))", "by(auto intro: prime_id)"], ["proof (state)\nthis:\n  primerec (recf.id (Suc (Suc (length xs))) (length xs))\n   (Suc (Suc (length xs)))\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "have prrf: \"primerec ?rf (Suc (Suc (Suc (length xs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n       [Cn (Suc (Suc (Suc (length xs)))) rec_le\n         [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n          recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n        Cn (Suc (Suc (Suc (length xs)))) rec_not\n         [Cn (Suc (Suc (Suc (length xs)))) rf\n           (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n            [recf.id (Suc (Suc (Suc (length xs))))\n              (Suc (Suc (length xs)))])]])\n     (Suc (Suc (Suc (length xs))))", "apply(auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (7 subgoals):\n 1. primerec rec_le ?k14\n 2. Suc (Suc 0) = ?k14\n 3. primerec rec_not ?k27\n 4. Suc 0 = ?k27\n 5. primerec rf ?k30\n 6. Suc (length xs) = ?k30\n 7. \\<And>i.\n       i < Suc (length xs) \\<Longrightarrow>\n       primerec\n        ((get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))]) !\n         i)\n        (Suc (Suc (Suc (length xs))))", "apply force+"], ["proof (prove)\ngoal (3 subgoals):\n 1. primerec rf ?k30\n 2. Suc (length xs) = ?k30\n 3. \\<And>i.\n       i < Suc (length xs) \\<Longrightarrow>\n       primerec\n        ((get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))]) !\n         i)\n        (Suc (Suc (Suc (length xs))))", "apply(auto intro: prime_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec rf (Suc (length xs))\n 2. \\<And>i.\n       i < Suc (length xs) \\<Longrightarrow>\n       primerec\n        ((get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))]) !\n         i)\n        (Suc (Suc (Suc (length xs))))", "apply(simp add: h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc (length xs) \\<Longrightarrow>\n       primerec\n        ((get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs)))]) !\n         i)\n        (Suc (Suc (Suc (length xs))))", "apply(auto simp add: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n     [Cn (Suc (Suc (Suc (length xs)))) rec_le\n       [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n        recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n      Cn (Suc (Suc (Suc (length xs)))) rec_not\n       [Cn (Suc (Suc (Suc (length xs)))) rf\n         (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs))))\n            (Suc (Suc (length xs)))])]])\n   (Suc (Suc (Suc (length xs))))\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "from prt and prrf"], ["proof (chain)\npicking this:\n  primerec (recf.id (Suc (Suc (length xs))) (length xs))\n   (Suc (Suc (length xs)))\n  primerec\n   (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n     [Cn (Suc (Suc (Suc (length xs)))) rec_le\n       [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n        recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n      Cn (Suc (Suc (Suc (length xs)))) rec_not\n       [Cn (Suc (Suc (Suc (length xs)))) rf\n         (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs))))\n            (Suc (Suc (length xs)))])]])\n   (Suc (Suc (Suc (length xs))))", "have prrq: \"primerec ?rq \n                                       (Suc (Suc (length xs)))\""], ["proof (prove)\nusing this:\n  primerec (recf.id (Suc (Suc (length xs))) (length xs))\n   (Suc (Suc (length xs)))\n  primerec\n   (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n     [Cn (Suc (Suc (Suc (length xs)))) rec_le\n       [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n        recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n      Cn (Suc (Suc (Suc (length xs)))) rec_not\n       [Cn (Suc (Suc (Suc (length xs)))) rf\n         (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n          [recf.id (Suc (Suc (Suc (length xs))))\n            (Suc (Suc (length xs)))])]])\n   (Suc (Suc (Suc (length xs))))\n\ngoal (1 subgoal):\n 1. primerec\n     (rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n       (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n         [Cn (Suc (Suc (Suc (length xs)))) rec_le\n           [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n            recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n          Cn (Suc (Suc (Suc (length xs)))) rec_not\n           [Cn (Suc (Suc (Suc (length xs)))) rf\n             (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs)))])]]))\n     (Suc (Suc (length xs)))", "by(erule_tac primerec_all_iff, auto)"], ["proof (state)\nthis:\n  primerec\n   (rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n     (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n       [Cn (Suc (Suc (Suc (length xs)))) rec_le\n         [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n          recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n        Cn (Suc (Suc (Suc (length xs)))) rec_not\n         [Cn (Suc (Suc (Suc (length xs)))) rf\n           (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n            [recf.id (Suc (Suc (Suc (length xs))))\n              (Suc (Suc (length xs)))])]]))\n   (Suc (Suc (length xs)))\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "hence prnotrp: \"primerec ?notrq (Suc (length ((xs @ [w]))))\""], ["proof (prove)\nusing this:\n  primerec\n   (rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n     (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n       [Cn (Suc (Suc (Suc (length xs)))) rec_le\n         [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n          recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n        Cn (Suc (Suc (Suc (length xs)))) rec_not\n         [Cn (Suc (Suc (Suc (length xs)))) rf\n           (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n            [recf.id (Suc (Suc (Suc (length xs))))\n              (Suc (Suc (length xs)))])]]))\n   (Suc (Suc (length xs)))\n\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])])\n     (Suc (length (xs @ [w])))", "by(rule_tac prime_cn, auto)"], ["proof (state)\nthis:\n  primerec\n   (Cn (Suc (Suc (length xs))) rec_not\n     [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n       (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n         [Cn (Suc (Suc (Suc (length xs)))) rec_le\n           [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n            recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n          Cn (Suc (Suc (Suc (length xs)))) rec_not\n           [Cn (Suc (Suc (Suc (length xs)))) rf\n             (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs)))])]])])\n   (Suc (length (xs @ [w])))\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "have g1: \"rec_exec (rec_sigma ?notrq) ((xs @ [w]) @ [w]) \n      = Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "using prnotrp"], ["proof (prove)\nusing this:\n  primerec\n   (Cn (Suc (Suc (length xs))) rec_not\n     [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n       (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n         [Cn (Suc (Suc (Suc (length xs)))) rec_le\n           [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n            recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n          Cn (Suc (Suc (Suc (length xs)))) rec_not\n           [Cn (Suc (Suc (Suc (length xs)))) rf\n             (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs)))])]])])\n   (Suc (length (xs @ [w])))\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "using sigma_lemma"], ["proof (prove)\nusing this:\n  primerec\n   (Cn (Suc (Suc (length xs))) rec_not\n     [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n       (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n         [Cn (Suc (Suc (Suc (length xs)))) rec_le\n           [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n            recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n          Cn (Suc (Suc (Suc (length xs)))) rec_not\n           [Cn (Suc (Suc (Suc (length xs)))) rf\n             (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n              [recf.id (Suc (Suc (Suc (length xs))))\n                (Suc (Suc (length xs)))])]])])\n   (Suc (length (xs @ [w])))\n  primerec ?rg (Suc (length ?xs)) \\<Longrightarrow>\n  rec_exec (rec_sigma ?rg) (?xs @ [?x]) =\n  UF.Sigma (rec_exec ?rg) (?xs @ [?x])\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     ((xs @ [w]) @ [w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "apply(simp only: sigma_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec\n              (Cn (Suc (Suc (length xs))) rec_not\n                [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n                  (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                    [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                      [recf.id (Suc (Suc (Suc (length xs))))\n                        (Suc (Suc (length xs))),\n                       recf.id (Suc (Suc (Suc (length xs))))\n                        (Suc (length xs))],\n                     Cn (Suc (Suc (Suc (length xs)))) rec_not\n                      [Cn (Suc (Suc (Suc (length xs)))) rf\n                        (get_fstn_args (Suc (Suc (Suc (length xs))))\n                          (length xs) @\n                         [recf.id (Suc (Suc (Suc (length xs))))\n                           (Suc (Suc (length xs)))])]])])\n              (Suc (length (xs @ [w])));\n     \\<And>rg xs x.\n        primerec rg (Suc (length xs)) \\<Longrightarrow>\n        UF.Sigma (rec_exec rg) (xs @ [x]) =\n        UF.Sigma (rec_exec rg) (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> UF.Sigma\n                       (rec_exec\n                         (Cn (Suc (Suc (length xs))) rec_not\n                           [rec_all\n                             (recf.id (Suc (Suc (length xs))) (length xs))\n                             (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                               [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                                 [recf.id (Suc (Suc (Suc (length xs))))\n                                   (Suc (Suc (length xs))),\n                                  recf.id (Suc (Suc (Suc (length xs))))\n                                   (Suc (length xs))],\n                                Cn (Suc (Suc (Suc (length xs)))) rec_not\n                                 [Cn (Suc (Suc (Suc (length xs)))) rf\n                                   (get_fstn_args\n                                     (Suc (Suc (Suc (length xs))))\n                                     (length xs) @\n                                    [recf.id (Suc (Suc (Suc (length xs))))\n(Suc (Suc (length xs)))])]])]))\n                       ((xs @ [w]) @ [w]) =\n                      Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "apply(rule_tac Sigma_Max_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec\n              (Cn (Suc (Suc (length xs))) rec_not\n                [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n                  (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n                    [Cn (Suc (Suc (Suc (length xs)))) rec_le\n                      [recf.id (Suc (Suc (Suc (length xs))))\n                        (Suc (Suc (length xs))),\n                       recf.id (Suc (Suc (Suc (length xs))))\n                        (Suc (length xs))],\n                     Cn (Suc (Suc (Suc (length xs)))) rec_not\n                      [Cn (Suc (Suc (Suc (length xs)))) rf\n                        (get_fstn_args (Suc (Suc (Suc (length xs))))\n                          (length xs) @\n                         [recf.id (Suc (Suc (Suc (length xs))))\n                           (Suc (Suc (length xs)))])]])])\n              (Suc (length (xs @ [w])));\n     \\<And>rg xs x.\n        primerec rg (Suc (length xs)) \\<Longrightarrow>\n        UF.Sigma (rec_exec rg) (xs @ [x]) =\n        UF.Sigma (rec_exec rg) (xs @ [x])\\<rbrakk>\n    \\<Longrightarrow> primerec rf (Suc (length xs))", "apply(simp add: h)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec\n   (rec_sigma\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal (1 subgoal):\n 1. arity rf = Suc (length xs) \\<Longrightarrow>\n    rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "thus \"rec_exec (rec_sigma ?notrq)\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_sigma\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   ((xs @ [w]) @ [w]) =\n  Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_sigma\n       (Cn (Suc (Suc (length xs))) rec_not\n         [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n           (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n             [Cn (Suc (Suc (Suc (length xs)))) rec_le\n               [recf.id (Suc (Suc (Suc (length xs))))\n                 (Suc (Suc (length xs))),\n                recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n              Cn (Suc (Suc (Suc (length xs)))) rec_not\n               [Cn (Suc (Suc (Suc (length xs)))) rf\n                 (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                  [recf.id (Suc (Suc (Suc (length xs))))\n                    (Suc (Suc (length xs)))])]])]))\n     (xs @ [w, w]) =\n    Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec\n   (rec_sigma\n     (Cn (Suc (Suc (length xs))) rec_not\n       [rec_all (recf.id (Suc (Suc (length xs))) (length xs))\n         (Cn (Suc (Suc (Suc (length xs)))) rec_disj\n           [Cn (Suc (Suc (Suc (length xs)))) rec_le\n             [recf.id (Suc (Suc (Suc (length xs)))) (Suc (Suc (length xs))),\n              recf.id (Suc (Suc (Suc (length xs)))) (Suc (length xs))],\n            Cn (Suc (Suc (Suc (length xs)))) rec_not\n             [Cn (Suc (Suc (Suc (length xs)))) rf\n               (get_fstn_args (Suc (Suc (Suc (length xs)))) (length xs) @\n                [recf.id (Suc (Suc (Suc (length xs))))\n                  (Suc (Suc (length xs)))])]])]))\n   (xs @ [w, w]) =\n  Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec (rec_maxr rf) (xs @ [w]) =\n  Maxr (\\<lambda>args. 0 < rec_exec rf args) xs w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  \\<open>quo\\<close> is the formal specification of division.\n\\<close>"], ["", "fun quo :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"quo [x, y] = (let Rr = \n                         (\\<lambda> zs. ((zs ! (Suc 0) * zs ! (Suc (Suc 0))\n                                 \\<le> zs ! 0) \\<and> zs ! Suc 0 \\<noteq> (0::nat)))\n                 in Maxr Rr [x, y] x)\""], ["", "declare quo.simps[simp del]"], ["", "text \\<open>\n  The following lemmas shows more directly the menaing of \\<open>quo\\<close>:\n\\<close>"], ["", "lemma quo_is_div: \"y > 0 \\<Longrightarrow> quo [x, y] = x div y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "fix xa ya"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "assume h: \"y * ya \\<le> x\"  \"y > 0\""], ["proof (state)\nthis:\n  y * ya \\<le> x\n  0 < y\n\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "hence \"(y * ya) div y \\<le> x div y\""], ["proof (prove)\nusing this:\n  y * ya \\<le> x\n  0 < y\n\ngoal (1 subgoal):\n 1. y * ya div y \\<le> x div y", "by(insert div_le_mono[of \"y * ya\" x y], simp)"], ["proof (state)\nthis:\n  y * ya div y \\<le> x div y\n\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "from this and h"], ["proof (chain)\npicking this:\n  y * ya div y \\<le> x div y\n  y * ya \\<le> x\n  0 < y", "have \"ya \\<le> x div y\""], ["proof (prove)\nusing this:\n  y * ya div y \\<le> x div y\n  y * ya \\<le> x\n  0 < y\n\ngoal (1 subgoal):\n 1. ya \\<le> x div y", "by simp"], ["proof (state)\nthis:\n  ya \\<le> x div y\n\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>y * ?ya2 \\<le> x; 0 < y\\<rbrakk>\n  \\<Longrightarrow> ?ya2 \\<le> x div y\n\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> quo [x, y] = x div y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>y * ?ya2 \\<le> x; 0 < y\\<rbrakk>\n  \\<Longrightarrow> ?ya2 \\<le> x div y\n\ngoal (1 subgoal):\n 1. quo [x, y] = x div y", "by(simp add: quo.simps Maxr.simps, auto,\n        rule_tac Max_eqI, simp, auto)"], ["proof (state)\nthis:\n  quo [x, y] = x div y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quo_zero[intro]: \"quo [x, 0] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quo [x, 0] = 0", "by(simp add: quo.simps Maxr.simps)"], ["", "lemma quo_div: \"quo [x, y] = x div y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quo [x, y] = x div y", "by(cases \"y=0\", auto elim!:quo_is_div)"], ["", "text \\<open>\n  \\<open>rec_noteq\\<close> is the recursive function testing whether its\n  two arguments are not equal.\n\\<close>"], ["", "definition rec_noteq:: \"recf\"\n  where\n    \"rec_noteq = Cn (Suc (Suc 0)) rec_not [Cn (Suc (Suc 0)) \n              rec_eq [id (Suc (Suc 0)) (0), id (Suc (Suc 0)) \n                                        ((Suc 0))]]\""], ["", "text \\<open>\n  The correctness of \\<open>rec_noteq\\<close>.\n\\<close>"], ["", "lemma noteq_lemma: \n  \"\\<And> x y. rec_exec rec_noteq [x, y] = \n               (if x \\<noteq> y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_noteq [x, y] = (if x \\<noteq> y then 1 else 0)", "by(simp add: rec_exec.simps rec_noteq_def)"], ["", "declare noteq_lemma[simp]"], ["", "text \\<open>\n  \\<open>rec_quo\\<close> is the recursive function used to implement \\<open>quo\\<close>\n\\<close>"], ["", "definition rec_quo :: \"recf\"\n  where\n    \"rec_quo = (let rR = Cn (Suc (Suc (Suc 0))) rec_conj\n              [Cn (Suc (Suc (Suc 0))) rec_le \n               [Cn (Suc (Suc (Suc 0))) rec_mult \n                  [id (Suc (Suc (Suc 0))) (Suc 0), \n                     id (Suc (Suc (Suc 0))) ((Suc (Suc 0)))],\n                id (Suc (Suc (Suc 0))) (0)], \n                Cn (Suc (Suc (Suc 0))) rec_noteq \n                         [id (Suc (Suc (Suc 0))) (Suc (0)),\n                Cn (Suc (Suc (Suc 0))) (constn 0) \n                              [id (Suc (Suc (Suc 0))) (0)]]] \n              in Cn (Suc (Suc 0)) (rec_maxr rR)) [id (Suc (Suc 0)) \n                           (0),id (Suc (Suc 0)) (Suc (0)), \n                                   id (Suc (Suc 0)) (0)]\""], ["", "lemma primerec_rec_conj_2[intro]: \"primerec rec_conj (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_conj (Suc (Suc 0))", "apply(simp add: rec_conj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc 0)) rec_sg\n       [Cn (Suc (Suc 0)) rec_mult\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0)]])\n     (Suc (Suc 0))", "apply(rule_tac prime_cn, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_noteq_2[intro]: \"primerec rec_noteq (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_noteq (Suc (Suc 0))", "apply(simp add: rec_noteq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc 0)) rec_not\n       [Cn (Suc (Suc 0)) rec_eq\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0)]])\n     (Suc (Suc 0))", "apply(rule_tac prime_cn, auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma quo_lemma1: \"rec_exec rec_quo [x, y] = quo [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_quo [x, y] = quo [x, y]", "proof(simp add: rec_exec.simps rec_quo_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    quo [x, y]", "let ?rR = \"(Cn (Suc (Suc (Suc 0))) rec_conj\n               [Cn (Suc (Suc (Suc 0))) rec_le\n                   [Cn (Suc (Suc (Suc 0))) rec_mult \n               [recf.id (Suc (Suc (Suc 0))) (Suc (0)), \n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc (0)))],\n                 recf.id (Suc (Suc (Suc 0))) (0)],  \n          Cn (Suc (Suc (Suc 0))) rec_noteq \n                              [recf.id (Suc (Suc (Suc 0))) \n             (Suc (0)), Cn (Suc (Suc (Suc 0))) (constn 0) \n                      [recf.id (Suc (Suc (Suc 0))) (0)]]])\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    quo [x, y]", "have \"rec_exec (rec_maxr ?rR) ([x, y]@ [ x]) = Maxr (\\<lambda> args. 0 < rec_exec ?rR args) [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     ([x, y] @ [x]) =\n    Maxr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn (Suc (Suc (Suc 0))) rec_conj\n                [Cn (Suc (Suc (Suc 0))) rec_le\n                  [Cn (Suc (Suc (Suc 0))) rec_mult\n                    [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                     recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                   recf.id (Suc (Suc (Suc 0))) 0],\n                 Cn (Suc (Suc (Suc 0))) rec_noteq\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   Cn (Suc (Suc (Suc 0))) (constn 0)\n                    [recf.id (Suc (Suc (Suc 0))) 0]]])\n              args)\n     [x, y] x", "proof(rule_tac Maxr_lemma, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]])\n     (Suc (Suc (Suc 0)))", "show \"primerec ?rR (Suc (Suc (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]])\n     (Suc (Suc (Suc 0)))", "apply(auto dest!:less_2_cases[unfolded numeral One_nat_def])"], ["proof (prove)\ngoal (8 subgoals):\n 1. primerec rec_le ?k14\n 2. Suc (Suc 0) = ?k14\n 3. primerec rec_mult ?k20\n 4. Suc (Suc 0) = ?k20\n 5. primerec rec_noteq ?k38\n 6. Suc (Suc 0) = ?k38\n 7. primerec (constn 0) ?k48\n 8. Suc 0 = ?k48", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (Cn (Suc (Suc (Suc 0))) rec_conj\n     [Cn (Suc (Suc (Suc 0))) rec_le\n       [Cn (Suc (Suc (Suc 0))) rec_mult\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n        recf.id (Suc (Suc (Suc 0))) 0],\n      Cn (Suc (Suc (Suc 0))) rec_noteq\n       [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n        Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]]])\n   (Suc (Suc (Suc 0)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_conj\n              [Cn (Suc (Suc (Suc 0))) rec_le\n                [Cn (Suc (Suc (Suc 0))) rec_mult\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                 recf.id (Suc (Suc (Suc 0))) 0],\n               Cn (Suc (Suc (Suc 0))) rec_noteq\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                  [recf.id (Suc (Suc (Suc 0))) 0]]])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    quo [x, y]", "hence g1: \"rec_exec (rec_maxr ?rR) ([x, y,  x]) =\n             Maxr (\\<lambda> args. if rec_exec ?rR args = 0 then False\n                           else True) [x, y] x\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_conj\n              [Cn (Suc (Suc (Suc 0))) rec_le\n                [Cn (Suc (Suc (Suc 0))) rec_mult\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                 recf.id (Suc (Suc (Suc 0))) 0],\n               Cn (Suc (Suc (Suc 0))) rec_noteq\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                  [recf.id (Suc (Suc (Suc 0))) 0]]])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    Maxr\n     (\\<lambda>args.\n         if rec_exec\n             (Cn (Suc (Suc (Suc 0))) rec_conj\n               [Cn (Suc (Suc (Suc 0))) rec_le\n                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                  recf.id (Suc (Suc (Suc 0))) 0],\n                Cn (Suc (Suc (Suc 0))) rec_noteq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) 0]]])\n             args =\n            0\n         then False else True)\n     [x, y] x", "by simp"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]]))\n   [x, y, x] =\n  Maxr\n   (\\<lambda>args.\n       if rec_exec\n           (Cn (Suc (Suc (Suc 0))) rec_conj\n             [Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0],\n              Cn (Suc (Suc (Suc 0))) rec_noteq\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]]])\n           args =\n          0\n       then False else True)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    quo [x, y]", "have g2: \"Maxr (\\<lambda> args. if rec_exec ?rR args = 0 then False\n                           else True) [x, y] x = quo [x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Maxr\n     (\\<lambda>args.\n         if rec_exec\n             (Cn (Suc (Suc (Suc 0))) rec_conj\n               [Cn (Suc (Suc (Suc 0))) rec_le\n                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                  recf.id (Suc (Suc (Suc 0))) 0],\n                Cn (Suc (Suc (Suc 0))) rec_noteq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) 0]]])\n             args =\n            0\n         then False else True)\n     [x, y] x =\n    quo [x, y]", "apply(simp add: rec_exec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Maxr\n     (\\<lambda>args.\n         (args ! Suc 0 * args ! Suc (Suc 0) \\<le> args ! 0 \\<longrightarrow>\n          0 < args ! Suc 0) \\<and>\n         (\\<not> args ! Suc 0 * args ! Suc (Suc 0)\n                 \\<le> args ! 0 \\<longrightarrow>\n          args ! Suc 0 = 0 \\<and> 0 < args ! Suc 0))\n     [x, y] x =\n    quo [x, y]", "apply(simp add: Maxr.simps quo.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Maxr\n   (\\<lambda>args.\n       if rec_exec\n           (Cn (Suc (Suc (Suc 0))) rec_conj\n             [Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0],\n              Cn (Suc (Suc (Suc 0))) rec_noteq\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]]])\n           args =\n          0\n       then False else True)\n   [x, y] x =\n  quo [x, y]\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    quo [x, y]", "from g1 and g2"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]]))\n   [x, y, x] =\n  Maxr\n   (\\<lambda>args.\n       if rec_exec\n           (Cn (Suc (Suc (Suc 0))) rec_conj\n             [Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0],\n              Cn (Suc (Suc (Suc 0))) rec_noteq\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]]])\n           args =\n          0\n       then False else True)\n   [x, y] x\n  Maxr\n   (\\<lambda>args.\n       if rec_exec\n           (Cn (Suc (Suc (Suc 0))) rec_conj\n             [Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0],\n              Cn (Suc (Suc (Suc 0))) rec_noteq\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]]])\n           args =\n          0\n       then False else True)\n   [x, y] x =\n  quo [x, y]", "show \n    \"rec_exec (rec_maxr ?rR) ([x, y,  x]) = quo [x, y]\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]]))\n   [x, y, x] =\n  Maxr\n   (\\<lambda>args.\n       if rec_exec\n           (Cn (Suc (Suc (Suc 0))) rec_conj\n             [Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0],\n              Cn (Suc (Suc (Suc 0))) rec_noteq\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]]])\n           args =\n          0\n       then False else True)\n   [x, y] x\n  Maxr\n   (\\<lambda>args.\n       if rec_exec\n           (Cn (Suc (Suc (Suc 0))) rec_conj\n             [Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0],\n              Cn (Suc (Suc (Suc 0))) rec_noteq\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]]])\n           args =\n          0\n       then False else True)\n   [x, y] x =\n  quo [x, y]\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_conj\n         [Cn (Suc (Suc (Suc 0))) rec_le\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]))\n     [x, y, x] =\n    quo [x, y]", "by simp"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_conj\n       [Cn (Suc (Suc (Suc 0))) rec_le\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0],\n        Cn (Suc (Suc (Suc 0))) rec_noteq\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]]]))\n   [x, y, x] =\n  quo [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>quo\\<close>.\n\\<close>"], ["", "lemma quo_lemma2: \"rec_exec rec_quo [x, y] = x div y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_quo [x, y] = x div y", "using quo_lemma1[of x y] quo_div[of x y]"], ["proof (prove)\nusing this:\n  rec_exec rec_quo [x, y] = quo [x, y]\n  quo [x, y] = x div y\n\ngoal (1 subgoal):\n 1. rec_exec rec_quo [x, y] = x div y", "by simp"], ["", "text \\<open>\n  \\<open>rec_mod\\<close> is the recursive function used to implement \n  the reminder function.\n\\<close>"], ["", "definition rec_mod :: \"recf\"\n  where\n    \"rec_mod = Cn (Suc (Suc 0)) rec_minus [id (Suc (Suc 0)) (0), \n               Cn (Suc (Suc 0)) rec_mult [rec_quo, id (Suc (Suc 0))\n                                                     (Suc (0))]]\""], ["", "text \\<open>\n  The correctness of \\<open>rec_mod\\<close>:\n\\<close>"], ["", "lemma mod_lemma: \"\\<And> x y. rec_exec rec_mod [x, y] = (x mod y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rec_exec rec_mod [x, y] = x mod y", "by(simp add: rec_exec.simps rec_mod_def quo_lemma2 minus_div_mult_eq_mod)"], ["", "text\\<open>lemmas for embranch function\\<close>"], ["", "type_synonym ftype = \"nat list \\<Rightarrow> nat\""], ["", "type_synonym rtype = \"nat list \\<Rightarrow> bool\""], ["", "text \\<open>\n  The specifation of the mutli-way branching statement on\n  page 79 of Boolos's book.\n\\<close>"], ["", "fun Embranch :: \"(ftype * rtype) list \\<Rightarrow> nat list \\<Rightarrow> nat\"\n  where\n    \"Embranch [] xs = 0\" |\n    \"Embranch (gc # gcs) xs = (\n                   let (g, c) = gc in \n                   if c xs then g xs else Embranch gcs xs)\""], ["", "fun rec_embranch' :: \"(recf * recf) list \\<Rightarrow> nat \\<Rightarrow> recf\"\n  where\n    \"rec_embranch' [] vl = Cn vl z [id vl (vl - 1)]\" |\n    \"rec_embranch' ((rg, rc) # rgcs) vl = Cn vl rec_add\n                   [Cn vl rec_mult [rg, rc], rec_embranch' rgcs vl]\""], ["", "text \\<open>\n  \\<open>rec_embrach\\<close> is the recursive function used to implement\n  \\<open>Embranch\\<close>.\n\\<close>"], ["", "fun rec_embranch :: \"(recf * recf) list \\<Rightarrow> recf\"\n  where\n    \"rec_embranch ((rg, rc) # rgcs) = \n         (let vl = arity rg in \n          rec_embranch' ((rg, rc) # rgcs) vl)\""], ["", "declare Embranch.simps[simp del] rec_embranch.simps[simp del]"], ["", "lemma embranch_all0: \n  \"\\<lbrakk>\\<forall> j < length rcs. rec_exec (rcs ! j) xs = 0;\n    length rgs = length rcs;  \n  rcs \\<noteq> []; \n  list_all (\\<lambda> rf. primerec rf (length xs)) (rgs @ rcs)\\<rbrakk>  \\<Longrightarrow> \n  rec_exec (rec_embranch (zip rgs rcs)) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>j<length rcs. rec_exec (rcs ! j) xs = 0;\n     length rgs = length rcs; rcs \\<noteq> [];\n     list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ rcs)\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs)) xs = 0", "proof(induct rcs arbitrary: rgs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rgs.\n       \\<lbrakk>\\<forall>j<length []. rec_exec ([] ! j) xs = 0;\n        length rgs = length []; [] \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ [])\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgs [])) xs = 0\n 2. \\<And>a rcs rgs.\n       \\<lbrakk>\\<And>rgs.\n                   \\<lbrakk>\\<forall>j<length rcs.\n                               rec_exec (rcs ! j) xs = 0;\n                    length rgs = length rcs; rcs \\<noteq> [];\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcs)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs))\nxs =\n                                     0;\n        \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0;\n        length rgs = length (a # rcs); a # rcs \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         (rgs @ a # rcs)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "case (Cons a rcs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>j<length rcs. rec_exec (rcs ! j) xs = 0;\n   length ?rgs = length rcs; rcs \\<noteq> [];\n   list_all (\\<lambda>rf. primerec rf (length xs)) (?rgs @ rcs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_embranch (zip ?rgs rcs)) xs = 0\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\n\ngoal (2 subgoals):\n 1. \\<And>rgs.\n       \\<lbrakk>\\<forall>j<length []. rec_exec ([] ! j) xs = 0;\n        length rgs = length []; [] \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ [])\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgs [])) xs = 0\n 2. \\<And>a rcs rgs.\n       \\<lbrakk>\\<And>rgs.\n                   \\<lbrakk>\\<forall>j<length rcs.\n                               rec_exec (rcs ! j) xs = 0;\n                    length rgs = length rcs; rcs \\<noteq> [];\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcs)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs))\nxs =\n                                     0;\n        \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0;\n        length rgs = length (a # rcs); a # rcs \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         (rgs @ a # rcs)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>j<length rcs. rec_exec (rcs ! j) xs = 0;\n   length ?rgs = length rcs; rcs \\<noteq> [];\n   list_all (\\<lambda>rf. primerec rf (length xs)) (?rgs @ rcs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_embranch (zip ?rgs rcs)) xs = 0\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>j<length rcs. rec_exec (rcs ! j) xs = 0;\n   length ?rgs = length rcs; rcs \\<noteq> [];\n   list_all (\\<lambda>rf. primerec rf (length xs)) (?rgs @ rcs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_embranch (zip ?rgs rcs)) xs = 0\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "proof(cases rgs, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>rgs.\n                   \\<lbrakk>\\<forall>j<length rcs.\n                               rec_exec (rcs ! j) xs = 0;\n                    length rgs = length rcs; rcs \\<noteq> [];\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcs)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs))\nxs =\n                                     0;\n        \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0;\n        length rgs = length (a # rcs); a # rcs \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs);\n        rgs = aa # list\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "fix a rcs rgs aa list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>rgs.\n                   \\<lbrakk>\\<forall>j<length rcsa__.\n                               rec_exec (rcsa__ ! j) xs = 0;\n                    length rgs = length rcsa__; rcsa__ \\<noteq> [];\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcsa__)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec\n(rec_embranch (zip rgs rcsa__)) xs =\n                                     0;\n        \\<forall>j<length (a__ # rcsa__).\n           rec_exec ((a__ # rcsa__) ! j) xs = 0;\n        length rgsa__ = length (a__ # rcsa__); a__ # rcsa__ \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         (rgsa__ @ a__ # rcsa__);\n        rgsa__ = aa # list\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgsa__ (a__ # rcsa__)))\n                          xs =\n                         0", "assume ind: \n      \"\\<And>rgs. \\<lbrakk>\\<forall>j<length rcs. rec_exec (rcs ! j) xs = 0; \n             length rgs = length rcs; rcs \\<noteq> []; \n            list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ rcs)\\<rbrakk> \\<Longrightarrow> \n                      rec_exec (rec_embranch (zip rgs rcs)) xs = 0\"\n      and h:  \"\\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\"\n      \"length rgs = length (a # rcs)\" \n      \"a # rcs \\<noteq> []\" \n      \"list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\"\n      \"rgs = aa # list\""], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>j<length rcs. rec_exec (rcs ! j) xs = 0;\n   length ?rgs = length rcs; rcs \\<noteq> [];\n   list_all (\\<lambda>rf. primerec rf (length xs)) (?rgs @ rcs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_embranch (zip ?rgs rcs)) xs = 0\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\n  rgs = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>rgs.\n                   \\<lbrakk>\\<forall>j<length rcsa__.\n                               rec_exec (rcsa__ ! j) xs = 0;\n                    length rgs = length rcsa__; rcsa__ \\<noteq> [];\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcsa__)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec\n(rec_embranch (zip rgs rcsa__)) xs =\n                                     0;\n        \\<forall>j<length (a__ # rcsa__).\n           rec_exec ((a__ # rcsa__) ! j) xs = 0;\n        length rgsa__ = length (a__ # rcsa__); a__ # rcsa__ \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         (rgsa__ @ a__ # rcsa__);\n        rgsa__ = aa # list\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgsa__ (a__ # rcsa__)))\n                          xs =\n                         0", "have g: \"rcs \\<noteq> [] \\<Longrightarrow> rec_exec (rec_embranch (zip list rcs)) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip list rcs)) xs = 0", "using h"], ["proof (prove)\nusing this:\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\n  rgs = aa # list\n\ngoal (1 subgoal):\n 1. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip list rcs)) xs = 0", "by(rule_tac ind, auto)"], ["proof (state)\nthis:\n  rcs \\<noteq> [] \\<Longrightarrow>\n  rec_exec (rec_embranch (zip list rcs)) xs = 0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>rgs.\n                   \\<lbrakk>\\<forall>j<length rcsa__.\n                               rec_exec (rcsa__ ! j) xs = 0;\n                    length rgs = length rcsa__; rcsa__ \\<noteq> [];\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcsa__)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec\n(rec_embranch (zip rgs rcsa__)) xs =\n                                     0;\n        \\<forall>j<length (a__ # rcsa__).\n           rec_exec ((a__ # rcsa__) ! j) xs = 0;\n        length rgsa__ = length (a__ # rcsa__); a__ # rcsa__ \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         (rgsa__ @ a__ # rcsa__);\n        rgsa__ = aa # list\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgsa__ (a__ # rcsa__)))\n                          xs =\n                         0", "show \"rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "proof(cases \"rcs = []\", simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. rcs = [] \\<Longrightarrow> rec_exec (rec_embranch (zip rgs [a])) xs = 0\n 2. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "show \"rec_exec (rec_embranch (zip rgs [a])) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs [a])) xs = 0", "using h"], ["proof (prove)\nusing this:\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\n  rgs = aa # list\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs [a])) xs = 0", "by (auto simp add: rec_embranch.simps rec_exec.simps)"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip rgs [a])) xs = 0\n\ngoal (1 subgoal):\n 1. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "assume \"rcs \\<noteq> []\""], ["proof (state)\nthis:\n  rcs \\<noteq> []\n\ngoal (1 subgoal):\n 1. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "hence \"rec_exec (rec_embranch (zip list rcs)) xs = 0\""], ["proof (prove)\nusing this:\n  rcs \\<noteq> []\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip list rcs)) xs = 0", "using g"], ["proof (prove)\nusing this:\n  rcs \\<noteq> []\n  rcs \\<noteq> [] \\<Longrightarrow>\n  rec_exec (rec_embranch (zip list rcs)) xs = 0\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip list rcs)) xs = 0", "by simp"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip list rcs)) xs = 0\n\ngoal (1 subgoal):\n 1. rcs \\<noteq> [] \\<Longrightarrow>\n    rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "thus \"rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0\""], ["proof (prove)\nusing this:\n  rec_exec (rec_embranch (zip list rcs)) xs = 0\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "using h"], ["proof (prove)\nusing this:\n  rec_exec (rec_embranch (zip list rcs)) xs = 0\n  \\<forall>j<length (a # rcs). rec_exec ((a # rcs) ! j) xs = 0\n  length rgs = length (a # rcs)\n  a # rcs \\<noteq> []\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ a # rcs)\n  rgs = aa # list\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0", "by(cases rcs;cases list, auto simp add: rec_embranch.simps rec_exec.simps)"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip rgs (a # rcs))) xs = 0\n\ngoal (1 subgoal):\n 1. \\<And>rgs.\n       \\<lbrakk>\\<forall>j<length []. rec_exec ([] ! j) xs = 0;\n        length rgs = length []; [] \\<noteq> [];\n        list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ [])\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip rgs [])) xs = 0", "qed simp"], ["", "lemma embranch_exec_0: \"\\<lbrakk>rec_exec aa xs = 0; zip rgs list \\<noteq> []; \n       list_all (\\<lambda> rf. primerec rf (length xs)) ([a, aa] @ rgs @ list)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs\n         = rec_exec (rec_embranch (zip rgs list)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     list_all (\\<lambda>rf. primerec rf (length xs))\n      ([a, aa] @ rgs @ list)\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n                      rec_exec (rec_embranch (zip rgs list)) xs", "apply(auto simp add: rec_exec.simps rec_embranch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     primerec a (length xs); primerec aa (length xs);\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n     list_all (\\<lambda>rf. primerec rf (length xs)) list\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch' (zip rgs list) (length xs))\n                       xs =\n                      rec_exec (rec_embranch (zip rgs list)) xs", "apply(cases \"zip rgs list\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab lista.\n       \\<lbrakk>rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n        primerec a (length xs); primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        zip rgs list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch' (zip rgs list) (length xs))\n                          xs =\n                         rec_exec (rec_embranch (zip rgs list)) xs", "apply(cases \"hd (zip rgs list)\", simp add: rec_embranch.simps rec_exec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab lista aaa b.\n       \\<lbrakk>rec_exec aa xs = 0; primerec a (length xs);\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        zip rgs list = (aaa, b) # lista; ab = (aaa, b)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch' lista (length xs)) xs =\n                         rec_exec (rec_embranch' lista (arity aaa)) xs", "apply(subgoal_tac \"arity a = length xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab lista aaa b.\n       \\<lbrakk>rec_exec aa xs = 0; primerec a (length xs);\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        zip rgs list = (aaa, b) # lista; ab = (aaa, b);\n        arity a = length xs\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch' lista (length xs)) xs =\n                         rec_exec (rec_embranch' lista (arity aaa)) xs\n 2. \\<And>ab lista aaa b.\n       \\<lbrakk>rec_exec aa xs = 0; primerec a (length xs);\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        zip rgs list = (aaa, b) # lista; ab = (aaa, b)\\<rbrakk>\n       \\<Longrightarrow> arity a = length xs", "apply(cases rgs;cases list;force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab lista aaa b.\n       \\<lbrakk>rec_exec aa xs = 0; primerec a (length xs);\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        zip rgs list = (aaa, b) # lista; ab = (aaa, b)\\<rbrakk>\n       \\<Longrightarrow> arity a = length xs", "by force"], ["", "lemma zip_null_iff: \"\\<lbrakk>length xs = k; length ys = k; zip xs ys = []\\<rbrakk> \\<Longrightarrow> xs = [] \\<and> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = k; length ys = k; zip xs ys = []\\<rbrakk>\n    \\<Longrightarrow> xs = [] \\<and> ys = []", "apply(cases xs, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>Suc (length list) = k; length ys = k;\n        zip (a # list) ys = []; xs = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply(cases ys, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zip_null_gr: \"\\<lbrakk>length xs = k; length ys = k; zip xs ys \\<noteq> []\\<rbrakk> \\<Longrightarrow> 0 < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = k; length ys = k; zip xs ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < k", "apply(cases xs, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Embranch_0:  \n  \"\\<lbrakk>length rgs = k; length rcs = k; k > 0; \n  \\<forall> j < k. rec_exec (rcs ! j) xs = 0\\<rbrakk> \\<Longrightarrow>\n  Embranch (zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs)) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n     \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n    \\<Longrightarrow> Embranch\n                       (zip (map rec_exec rgs)\n                         (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n                       xs =\n                      0", "proof(induct rgs arbitrary: rcs k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rcs k.\n       \\<lbrakk>length [] = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec [])\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0\n 2. \\<And>a rgs rcs k.\n       \\<lbrakk>\\<And>rcs k.\n                   \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n                    \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n                   \\<Longrightarrow> Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs =\n                                     0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0", "case (Cons a rgs rcs k)"], ["proof (state)\nthis:\n  \\<lbrakk>length rgs = ?k; length ?rcs = ?k; 0 < ?k;\n   \\<forall>j<?k. rec_exec (?rcs ! j) xs = 0\\<rbrakk>\n  \\<Longrightarrow> Embranch\n                     (zip (map rec_exec rgs)\n                       (map (\\<lambda>r args. 0 < rec_exec r args) ?rcs))\n                     xs =\n                    0\n  length (a # rgs) = k\n  length rcs = k\n  0 < k\n  \\<forall>j<k. rec_exec (rcs ! j) xs = 0\n\ngoal (2 subgoals):\n 1. \\<And>rcs k.\n       \\<lbrakk>length [] = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec [])\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0\n 2. \\<And>a rgs rcs k.\n       \\<lbrakk>\\<And>rcs k.\n                   \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n                    \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n                   \\<Longrightarrow> Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs =\n                                     0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length rgs = ?k; length ?rcs = ?k; 0 < ?k;\n   \\<forall>j<?k. rec_exec (?rcs ! j) xs = 0\\<rbrakk>\n  \\<Longrightarrow> Embranch\n                     (zip (map rec_exec rgs)\n                       (map (\\<lambda>r args. 0 < rec_exec r args) ?rcs))\n                     xs =\n                    0\n  length (a # rgs) = k\n  length rcs = k\n  0 < k\n  \\<forall>j<k. rec_exec (rcs ! j) xs = 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length rgs = ?k; length ?rcs = ?k; 0 < ?k;\n   \\<forall>j<?k. rec_exec (?rcs ! j) xs = 0\\<rbrakk>\n  \\<Longrightarrow> Embranch\n                     (zip (map rec_exec rgs)\n                       (map (\\<lambda>r args. 0 < rec_exec r args) ?rcs))\n                     xs =\n                    0\n  length (a # rgs) = k\n  length rcs = k\n  0 < k\n  \\<forall>j<k. rec_exec (rcs ! j) xs = 0\n\ngoal (1 subgoal):\n 1. Embranch\n     (zip (map rec_exec (a # rgs))\n       (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n     xs =\n    0", "apply(cases rcs, simp, cases \"rgs = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>\\<And>k rcs.\n                   \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n                    \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n                   \\<Longrightarrow> Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs =\n                                     0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rcs = aa # list;\n        \\<And>k rcs.\n           \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n            \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n           \\<Longrightarrow> Embranch\n                              (zip (map rec_exec rgs)\n                                (map (\\<lambda>r args. 0 < rec_exec r args)\n                                  rcs))\n                              xs =\n                             0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rgs = []\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>k rcs.\n                   \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n                    \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n                   \\<Longrightarrow> Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs =\n                                     0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rcs = aa # list;\n        \\<And>k rcs.\n           \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n            \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n           \\<Longrightarrow> Embranch\n                              (zip (map rec_exec rgs)\n                                (map (\\<lambda>r args. 0 < rec_exec r args)\n                                  rcs))\n                              xs =\n                             0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rgs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0", "apply(simp add: Embranch.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc 0 = k; list = [];\n        \\<forall>j<k. rec_exec ([aa] ! j) xs = 0; rcs = [aa];\n        rgs = []\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec aa xs \\<longrightarrow>\n                         rec_exec a xs = 0\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>k rcs.\n                   \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n                    \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n                   \\<Longrightarrow> Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs =\n                                     0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rcs = aa # list;\n        \\<And>k rcs.\n           \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n            \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n           \\<Longrightarrow> Embranch\n                              (zip (map rec_exec rgs)\n                                (map (\\<lambda>r args. 0 < rec_exec r args)\n                                  rcs))\n                              xs =\n                             0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rgs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0", "apply(erule_tac x = 0 in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc 0 = k; list = []; rcs = [aa]; rgs = [];\n        0 < k \\<longrightarrow> rec_exec ([aa] ! 0) xs = 0\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec aa xs \\<longrightarrow>\n                         rec_exec a xs = 0\n 2. \\<And>aa list.\n       \\<lbrakk>\\<And>k rcs.\n                   \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n                    \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n                   \\<Longrightarrow> Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs =\n                                     0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rcs = aa # list;\n        \\<And>k rcs.\n           \\<lbrakk>length rgs = k; length rcs = k; 0 < k;\n            \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n           \\<Longrightarrow> Embranch\n                              (zip (map rec_exec rgs)\n                                (map (\\<lambda>r args. 0 < rec_exec r args)\n                                  rcs))\n                              xs =\n                             0;\n        length (a # rgs) = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0; rgs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0", "apply (auto simp add: Embranch.simps intro!: Cons(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\nthis:\n  Embranch\n   (zip (map rec_exec (a # rgs))\n     (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n   xs =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>rcs k.\n       \\<lbrakk>length [] = k; length rcs = k; 0 < k;\n        \\<forall>j<k. rec_exec (rcs ! j) xs = 0\\<rbrakk>\n       \\<Longrightarrow> Embranch\n                          (zip (map rec_exec [])\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs =\n                         0", "qed simp"], ["", "text \\<open>\n  The correctness of \\<open>rec_embranch\\<close>.\n\\<close>"], ["", "lemma embranch_lemma:\n  assumes branch_num:\n    \"length rgs = n\" \"length rcs = n\" \"n > 0\"\n    and partition: \n    \"(\\<exists> i < n. (rec_exec (rcs ! i) xs = 1 \\<and> (\\<forall> j < n. j \\<noteq> i \\<longrightarrow> \n                                      rec_exec (rcs ! j) xs = 0)))\"\n    and prime_all: \"list_all (\\<lambda> rf. primerec rf (length xs)) (rgs @ rcs)\"\n  shows \"rec_exec (rec_embranch (zip rgs rcs)) xs =\n                  Embranch (zip (map rec_exec rgs) \n                     (map (\\<lambda> r args. 0 < rec_exec r args) rcs)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs rcs)) xs =\n    Embranch\n     (zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n     xs", "using branch_num partition prime_all"], ["proof (prove)\nusing this:\n  length rgs = n\n  length rcs = n\n  0 < n\n  \\<exists>i<n.\n     rec_exec (rcs ! i) xs = 1 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0)\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ rcs)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs rcs)) xs =\n    Embranch\n     (zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n     xs", "proof(induct rgs arbitrary: rcs n, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rgs rcs n.\n       \\<lbrakk>\\<And>rcs n.\n                   \\<lbrakk>length rgs = n; length rcs = n; 0 < n;\n                    \\<exists>i<n.\n                       rec_exec (rcs ! i) xs = 1 \\<and>\n                       (\\<forall>j<n.\n                           j \\<noteq> i \\<longrightarrow>\n                           rec_exec (rcs ! j) xs = 0);\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcs)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs))\nxs =\n                                     Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs;\n        length (a # rgs) = n; length rcs = n; 0 < n;\n        \\<exists>i<n.\n           rec_exec (rcs ! i) xs = 1 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0);\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         ((a # rgs) @ rcs)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip (a # rgs) rcs)) xs =\n                         Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs", "fix a rgs rcs n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rgs rcs n.\n       \\<lbrakk>\\<And>rcs n.\n                   \\<lbrakk>length rgs = n; length rcs = n; 0 < n;\n                    \\<exists>i<n.\n                       rec_exec (rcs ! i) xs = 1 \\<and>\n                       (\\<forall>j<n.\n                           j \\<noteq> i \\<longrightarrow>\n                           rec_exec (rcs ! j) xs = 0);\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcs)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs))\nxs =\n                                     Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs;\n        length (a # rgs) = n; length rcs = n; 0 < n;\n        \\<exists>i<n.\n           rec_exec (rcs ! i) xs = 1 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0);\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         ((a # rgs) @ rcs)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip (a # rgs) rcs)) xs =\n                         Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs", "assume ind: \n    \"\\<And>rcs n. \\<lbrakk>length rgs = n; length rcs = n; 0 < n;\n    \\<exists>i<n. rec_exec (rcs ! i) xs = 1 \\<and> (\\<forall>j<n. j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0);\n    list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ rcs)\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs)) xs =\n    Embranch (zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs)) xs\"\n    and h: \"length (a # rgs) = n\" \"length (rcs::recf list) = n\" \"0 < n\"\n    \" \\<exists>i<n. rec_exec (rcs ! i) xs = 1 \\<and> \n         (\\<forall>j<n. j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0)\" \n    \"list_all (\\<lambda>rf. primerec rf (length xs)) ((a # rgs) @ rcs)\""], ["proof (state)\nthis:\n  \\<lbrakk>length rgs = ?n; length ?rcs = ?n; 0 < ?n;\n   \\<exists>i<?n.\n      rec_exec (?rcs ! i) xs = 1 \\<and>\n      (\\<forall>j<?n.\n          j \\<noteq> i \\<longrightarrow> rec_exec (?rcs ! j) xs = 0);\n   list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ ?rcs)\\<rbrakk>\n  \\<Longrightarrow> rec_exec (rec_embranch (zip rgs ?rcs)) xs =\n                    Embranch\n                     (zip (map rec_exec rgs)\n                       (map (\\<lambda>r args. 0 < rec_exec r args) ?rcs))\n                     xs\n  length (a # rgs) = n\n  length rcs = n\n  0 < n\n  \\<exists>i<n.\n     rec_exec (rcs ! i) xs = 1 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0)\n  list_all (\\<lambda>rf. primerec rf (length xs)) ((a # rgs) @ rcs)\n\ngoal (1 subgoal):\n 1. \\<And>a rgs rcs n.\n       \\<lbrakk>\\<And>rcs n.\n                   \\<lbrakk>length rgs = n; length rcs = n; 0 < n;\n                    \\<exists>i<n.\n                       rec_exec (rcs ! i) xs = 1 \\<and>\n                       (\\<forall>j<n.\n                           j \\<noteq> i \\<longrightarrow>\n                           rec_exec (rcs ! j) xs = 0);\n                    list_all (\\<lambda>rf. primerec rf (length xs))\n                     (rgs @ rcs)\\<rbrakk>\n                   \\<Longrightarrow> rec_exec (rec_embranch (zip rgs rcs))\nxs =\n                                     Embranch\n(zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\nxs;\n        length (a # rgs) = n; length rcs = n; 0 < n;\n        \\<exists>i<n.\n           rec_exec (rcs ! i) xs = 1 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0);\n        list_all (\\<lambda>rf. primerec rf (length xs))\n         ((a # rgs) @ rcs)\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch (zip (a # rgs) rcs)) xs =\n                         Embranch\n                          (zip (map rec_exec (a # rgs))\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              rcs))\n                          xs", "from h"], ["proof (chain)\npicking this:\n  length (a # rgs) = n\n  length rcs = n\n  0 < n\n  \\<exists>i<n.\n     rec_exec (rcs ! i) xs = 1 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0)\n  list_all (\\<lambda>rf. primerec rf (length xs)) ((a # rgs) @ rcs)", "show \"rec_exec (rec_embranch (zip (a # rgs) rcs)) xs =\n    Embranch (zip (map rec_exec (a # rgs)) (map (\\<lambda>r args. \n                0 < rec_exec r args) rcs)) xs\""], ["proof (prove)\nusing this:\n  length (a # rgs) = n\n  length rcs = n\n  0 < n\n  \\<exists>i<n.\n     rec_exec (rcs ! i) xs = 1 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec (rcs ! j) xs = 0)\n  list_all (\\<lambda>rf. primerec rf (length xs)) ((a # rgs) @ rcs)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip (a # rgs) rcs)) xs =\n    Embranch\n     (zip (map rec_exec (a # rgs))\n       (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n     xs", "apply(cases rcs, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "apply(cases \"rec_exec (hd rcs) xs = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "apply(case_tac [!] \"zip rgs (tl rcs) = []\", simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec aa xs = 0; zip rgs list = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch [(a, aa)]) xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 4. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "apply(subgoal_tac \"rgs = [] \\<and> (tl rcs) = []\", simp add: Embranch.simps rec_exec.simps rec_embranch.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec aa xs = 0; zip rgs list = []\\<rbrakk>\n       \\<Longrightarrow> rgs = [] \\<and> tl rcs = []\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 4. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "apply(rule_tac  zip_null_iff, simp, simp, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "fix aa list"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "assume \"rcs = aa # list\""], ["proof (state)\nthis:\n  rcs = aa # list\n\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "assume g:\n      \"Suc (length rgs) = n\" \"Suc (length list) = n\" \n      \"\\<exists>i<n. rec_exec ((aa # list) ! i) xs = Suc 0 \\<and> \n          (\\<forall>j<n. j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\"\n      \"primerec a (length xs) \\<and> \n      list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n      primerec aa (length xs) \\<and> \n      list_all (\\<lambda>rf. primerec rf (length xs)) list\"\n      \"rec_exec (hd rcs) xs = 0\" \"rcs = aa # list\" \"zip rgs (tl rcs) \\<noteq> []\""], ["proof (state)\nthis:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rec_exec (hd rcs) xs = 0\n  rcs = aa # list\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "hence \"rec_exec aa xs = 0\" \"zip rgs list \\<noteq> []\""], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rec_exec (hd rcs) xs = 0\n  rcs = aa # list\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. rec_exec aa xs = 0 &&& zip rgs list \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  rec_exec aa xs = 0\n  zip rgs list \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "note g = g(1,2,3,4,6) this"], ["proof (state)\nthis:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec aa xs = 0\n  zip rgs list \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "have \"rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs\n        = rec_exec (rec_embranch (zip rgs list)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n    rec_exec (rec_embranch (zip rgs list)) xs", "apply(rule embranch_exec_0, simp_all add: g)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n  rec_exec (rec_embranch (zip rgs list)) xs\n\ngoal (3 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs = 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 3. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "from g and this"], ["proof (chain)\npicking this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec aa xs = 0\n  zip rgs list \\<noteq> []\n  rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n  rec_exec (rec_embranch (zip rgs list)) xs", "show \"rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n         Embranch ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) # \n           zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) list)) xs\""], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec aa xs = 0\n  zip rgs list \\<noteq> []\n  rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n  rec_exec (rec_embranch (zip rgs list)) xs\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n    Embranch\n     ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n      zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) list))\n     xs", "apply(simp add: Embranch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch (zip rgs list)) xs =\n                      Embranch\n                       (zip (map rec_exec rgs)\n                         (map (\\<lambda>r args. 0 < rec_exec r args) list))\n                       xs", "apply(rule_tac n = \"n - Suc 0\" in ind)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> length rgs = n - Suc 0\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> length list = n - Suc 0\n 3. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> 0 < n - Suc 0\n 4. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n - Suc 0.\n                         rec_exec (list ! i) xs = 1 \\<and>\n                         (\\<forall>j<n - Suc 0.\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec (list ! j) xs = 0)\n 5. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>rf. primerec rf (length xs))\n                       (rgs @ list)", "apply(cases n;force)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> length list = n - Suc 0\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> 0 < n - Suc 0\n 3. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n - Suc 0.\n                         rec_exec (list ! i) xs = 1 \\<and>\n                         (\\<forall>j<n - Suc 0.\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec (list ! j) xs = 0)\n 4. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>rf. primerec rf (length xs))\n                       (rgs @ list)", "apply(cases n;force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> 0 < n - Suc 0\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n - Suc 0.\n                         rec_exec (list ! i) xs = 1 \\<and>\n                         (\\<forall>j<n - Suc 0.\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec (list ! j) xs = 0)\n 3. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>rf. primerec rf (length xs))\n                       (rgs @ list)", "apply(cases n;force simp add: zip_null_gr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<n - Suc 0.\n                         rec_exec (list ! i) xs = 1 \\<and>\n                         (\\<forall>j<n - Suc 0.\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec (list ! j) xs = 0)\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec aa xs = 0; zip rgs list \\<noteq> [];\n     rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n     rec_exec (rec_embranch (zip rgs list)) xs\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>rf. primerec rf (length xs))\n                       (rgs @ list)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>rcs = aa # list; rec_exec aa xs = 0;\n        zip rgs list \\<noteq> [];\n        rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n        rec_exec (rec_embranch (zip rgs list)) xs;\n        n = Suc (length rgs); length list = length rgs;\n        primerec a (length xs); i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length rgs.\n                            rec_exec (list ! i) xs = Suc 0 \\<and>\n                            (\\<forall>j<length rgs.\n                                j \\<noteq> i \\<longrightarrow>\n                                rec_exec (list ! j) xs = 0)", "apply(rename_tac i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>rcs = aa # list; rec_exec aa xs = 0;\n        zip rgs list \\<noteq> [];\n        rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n        rec_exec (rec_embranch (zip rgs list)) xs;\n        n = Suc (length rgs); length list = length rgs;\n        primerec a (length xs); i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length rgs.\n                            rec_exec (list ! i) xs = Suc 0 \\<and>\n                            (\\<forall>j<length rgs.\n                                j \\<noteq> i \\<longrightarrow>\n                                rec_exec (list ! j) xs = 0)", "apply(case_tac i, force, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nat.\n       \\<lbrakk>rcs = aa # list; rec_exec aa xs = 0;\n        zip rgs list \\<noteq> [];\n        rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n        rec_exec (rec_embranch (zip rgs list)) xs;\n        n = Suc (length rgs); length list = length rgs;\n        primerec a (length xs); nat < length rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec (list ! nat) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> Suc nat \\<longrightarrow>\n           rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length rgs.\n                            rec_exec (list ! i) xs = Suc 0 \\<and>\n                            (\\<forall>j<length rgs.\n                                j \\<noteq> i \\<longrightarrow>\n                                rec_exec (list ! j) xs = 0)", "apply(rule_tac x = \"i - 1\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nat.\n       \\<lbrakk>rcs = aa # list; rec_exec aa xs = 0;\n        zip rgs list \\<noteq> [];\n        rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n        rec_exec (rec_embranch (zip rgs list)) xs;\n        n = Suc (length rgs); length list = length rgs;\n        primerec a (length xs); nat < length rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec (list ! nat) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> Suc nat \\<longrightarrow>\n           rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<forall>j<length rgs.\n                            j \\<noteq> nat \\<longrightarrow>\n                            rec_exec (list ! j) xs = 0", "by auto"], ["proof (state)\nthis:\n  rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n  Embranch\n   ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n    zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs\n\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "fix aa list"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "assume g: \"Suc (length rgs) = n\" \"Suc (length list) = n\"\n      \"\\<exists>i<n. rec_exec ((aa # list) ! i) xs = Suc 0 \\<and> \n      (\\<forall>j<n. j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\"\n      \"primerec a (length xs) \\<and> list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n      primerec aa (length xs) \\<and> list_all (\\<lambda>rf. primerec rf (length xs)) list\"\n      \"rcs = aa # list\" \"rec_exec (hd rcs) xs \\<noteq> 0\" \"zip rgs (tl rcs) = []\""], ["proof (state)\nthis:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) = []\n\ngoal (2 subgoals):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) = []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs\n 2. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "thus \"rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs = \n        Embranch ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) # \n       zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) list)) xs\""], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) = []\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n    Embranch\n     ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n      zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) list))\n     xs", "apply(subgoal_tac \"rgs = [] \\<and> list = []\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 = n;\n     \\<exists>i<n.\n        rec_exec ([aa] ! i) xs = n \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow> rec_exec ([aa] ! j) xs = 0);\n     0 < rec_exec aa xs; rgs = [] \\<and> list = [];\n     primerec a (length xs) \\<and> primerec aa (length xs);\n     rcs = [aa]\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch [(a, aa)]) xs =\n                      Embranch\n                       [(rec_exec a, \\<lambda>args. 0 < rec_exec aa args)]\n                       xs\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) = []\\<rbrakk>\n    \\<Longrightarrow> rgs = [] \\<and> list = []", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) = []\\<rbrakk>\n    \\<Longrightarrow> rgs = [] \\<and> list = []\n 2. \\<lbrakk>Suc 0 = n;\n     \\<exists>i<n.\n        rec_exec ([aa] ! i) xs = n \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow> rec_exec ([aa] ! j) xs = 0);\n     0 < rec_exec aa xs; rgs = [] \\<and> list = [];\n     primerec a (length xs) \\<and> primerec aa (length xs);\n     rcs = [aa]\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch [(a, aa)]) xs =\n                      Embranch\n                       [(rec_exec a, \\<lambda>args. 0 < rec_exec aa args)]\n                       xs", "apply(rule_tac zip_null_iff, simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 = n;\n     \\<exists>i<n.\n        rec_exec ([aa] ! i) xs = n \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow> rec_exec ([aa] ! j) xs = 0);\n     0 < rec_exec aa xs; rgs = [] \\<and> list = [];\n     primerec a (length xs) \\<and> primerec aa (length xs);\n     rcs = [aa]\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_embranch [(a, aa)]) xs =\n                      Embranch\n                       [(rec_exec a, \\<lambda>args. 0 < rec_exec aa args)]\n                       xs", "apply(simp add: rec_exec.simps rec_embranch.simps Embranch.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n  Embranch\n   ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n    zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "fix aa list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "assume g: \"Suc (length rgs) = n\" \"Suc (length list) = n\"\n      \"\\<exists>i<n. rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>  \n           (\\<forall>j<n. j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\"\n      \"primerec a (length xs) \\<and> list_all (\\<lambda>rf. primerec rf (length xs)) rgs\n      \\<and> primerec aa (length xs) \\<and> list_all (\\<lambda>rf. primerec rf (length xs)) list\"\n      \"rcs = aa # list\" \"rec_exec (hd rcs) xs \\<noteq> 0\" \"zip rgs (tl rcs) \\<noteq> []\""], ["proof (state)\nthis:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "have \"rec_exec aa xs =  Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec aa xs = Suc 0", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. rec_exec aa xs = Suc 0", "apply(cases \"rec_exec aa xs\", simp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec aa xs = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "moreover"], ["proof (state)\nthis:\n  rec_exec aa xs = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "have \"rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0", "have \"rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)", "apply(cases \"zip rgs list\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab lista.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []; zip rgs list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> rec_embranch' (zip rgs list) (length xs) =\n                         rec_embranch (zip rgs list)", "apply(cases \"hd (zip rgs list)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab lista aaa b.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []; zip rgs list = ab # lista;\n        hd (zip rgs list) = (aaa, b)\\<rbrakk>\n       \\<Longrightarrow> rec_embranch' (zip rgs list) (length xs) =\n                         rec_embranch (zip rgs list)", "apply(simp add: rec_embranch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab lista aaa b.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list = (aaa, b) # lista; ab = (aaa, b)\\<rbrakk>\n       \\<Longrightarrow> length xs = arity aaa \\<and>\n                         rec_embranch' lista (length xs) =\n                         rec_embranch' lista (arity aaa)", "apply(cases rgs, simp, simp, cases list, simp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0", "moreover"], ["proof (state)\nthis:\n  rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0", "have \"rec_exec (rec_embranch (zip rgs list)) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch (zip rgs list)) xs = 0", "proof(rule embranch_all0)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>j<length list. rec_exec (list ! j) xs = 0\n 2. length rgs = length list\n 3. list \\<noteq> []\n 4. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "show \" \\<forall>j<length list. rec_exec (list ! j) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<length list. rec_exec (list ! j) xs = 0", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>j<length list. rec_exec (list ! j) xs = 0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(case_tac i, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>rcs = aa # list; zip rgs list \\<noteq> [];\n        n = Suc (length rgs); length list = length rgs;\n        primerec a (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec aa xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           0 < j \\<longrightarrow> rec_exec (list ! (j - Suc 0)) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0\n 2. \\<And>i j nat.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(erule_tac x = \"Suc j\" in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j nat.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j nat.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs); nat < length rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec (list ! nat) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> Suc nat \\<longrightarrow>\n           rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(erule_tac x = 0 in allE, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>j<length list. rec_exec (list ! j) xs = 0\n\ngoal (3 subgoals):\n 1. length rgs = length list\n 2. list \\<noteq> []\n 3. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. length rgs = length list\n 2. list \\<noteq> []\n 3. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "show \"length rgs = length list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rgs = length list", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. length rgs = length list", "by(cases n;force)"], ["proof (state)\nthis:\n  length rgs = length list\n\ngoal (2 subgoals):\n 1. list \\<noteq> []\n 2. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. list \\<noteq> []\n 2. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "show \"list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list \\<noteq> []", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. list \\<noteq> []", "by(cases list; force)"], ["proof (state)\nthis:\n  list \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "show \"list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)", "by auto"], ["proof (state)\nthis:\n  list_all (\\<lambda>rf. primerec rf (length xs)) (rgs @ list)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip rgs list)) xs = 0\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0", "ultimately"], ["proof (chain)\npicking this:\n  rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)\n  rec_exec (rec_embranch (zip rgs list)) xs = 0", "show \"rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\""], ["proof (prove)\nusing this:\n  rec_embranch' (zip rgs list) (length xs) = rec_embranch (zip rgs list)\n  rec_exec (rec_embranch (zip rgs list)) xs = 0\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0", "by simp"], ["proof (state)\nthis:\n  rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "moreover"], ["proof (state)\nthis:\n  rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "have \n      \"Embranch (zip (map rec_exec rgs) \n          (map (\\<lambda>r args. 0 < rec_exec r args) list)) xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Embranch\n     (zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) list))\n     xs =\n    0", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. Embranch\n     (zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) list))\n     xs =\n    0", "apply(rule_tac k = \"length rgs\" in Embranch_0)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length rgs = length rgs\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length list = length rgs\n 3. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < length rgs\n 4. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length rgs. rec_exec (list ! j) xs = 0", "apply(simp, cases n, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 0 < length rgs\n 2. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length rgs. rec_exec (list ! j) xs = 0", "apply(cases rgs, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n     \\<exists>i<n.\n        rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n        (\\<forall>j<n.\n            j \\<noteq> i \\<longrightarrow>\n            rec_exec ((aa # list) ! j) xs = 0);\n     primerec a (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n     primerec aa (length xs) \\<and>\n     list_all (\\<lambda>rf. primerec rf (length xs)) list;\n     rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n     zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>j<length rgs. rec_exec (list ! j) xs = 0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(case_tac i, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>rcs = aa # list; zip rgs list \\<noteq> [];\n        n = Suc (length rgs); length list = length rgs;\n        primerec a (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec aa xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           0 < j \\<longrightarrow> rec_exec (list ! (j - Suc 0)) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0\n 2. \\<And>i j nat.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(erule_tac x = \"Suc j\" in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j nat.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs);\n        i < Suc (length rgs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec ((aa # list) ! i) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j nat.\n       \\<lbrakk>rcs = aa # list; 0 < rec_exec aa xs;\n        zip rgs list \\<noteq> []; n = Suc (length rgs);\n        length list = length rgs; primerec a (length xs); nat < length rgs;\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs;\n        rec_exec (list ! nat) xs = Suc 0;\n        \\<forall>j<Suc (length rgs).\n           j \\<noteq> Suc nat \\<longrightarrow>\n           rec_exec ((aa # list) ! j) xs = 0;\n        primerec aa (length xs);\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        j < length rgs; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> rec_exec (list ! j) xs = 0", "apply(rule_tac x = 0 in allE, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Embranch\n   (zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "moreover"], ["proof (state)\nthis:\n  Embranch\n   (zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "have \"arity a = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity a = length xs", "using g"], ["proof (prove)\nusing this:\n  Suc (length rgs) = n\n  Suc (length list) = n\n  \\<exists>i<n.\n     rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n     (\\<forall>j<n.\n         j \\<noteq> i \\<longrightarrow> rec_exec ((aa # list) ! j) xs = 0)\n  primerec a (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n  primerec aa (length xs) \\<and>\n  list_all (\\<lambda>rf. primerec rf (length xs)) list\n  rcs = aa # list\n  rec_exec (hd rcs) xs \\<noteq> 0\n  zip rgs (tl rcs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. arity a = length xs", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  arity a = length xs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc (length rgs) = n; Suc (length list) = n;\n        \\<exists>i<n.\n           rec_exec ((aa # list) ! i) xs = Suc 0 \\<and>\n           (\\<forall>j<n.\n               j \\<noteq> i \\<longrightarrow>\n               rec_exec ((aa # list) ! j) xs = 0);\n        primerec a (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) rgs \\<and>\n        primerec aa (length xs) \\<and>\n        list_all (\\<lambda>rf. primerec rf (length xs)) list;\n        rcs = aa # list; rec_exec (hd rcs) xs \\<noteq> 0;\n        zip rgs (tl rcs) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_embranch ((a, aa) # zip rgs list))\n                          xs =\n                         Embranch\n                          ((rec_exec a,\n                            \\<lambda>args. 0 < rec_exec aa args) #\n                           zip (map rec_exec rgs)\n                            (map (\\<lambda>r args. 0 < rec_exec r args)\n                              list))\n                          xs", "ultimately"], ["proof (chain)\npicking this:\n  rec_exec aa xs = Suc 0\n  rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\n  Embranch\n   (zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs =\n  0\n  arity a = length xs", "show \"rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs = \n      Embranch ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n           zip (map rec_exec rgs) (map (\\<lambda>r args. 0 < rec_exec r args) list)) xs\""], ["proof (prove)\nusing this:\n  rec_exec aa xs = Suc 0\n  rec_exec (rec_embranch' (zip rgs list) (length xs)) xs = 0\n  Embranch\n   (zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs =\n  0\n  arity a = length xs\n\ngoal (1 subgoal):\n 1. rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n    Embranch\n     ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n      zip (map rec_exec rgs)\n       (map (\\<lambda>r args. 0 < rec_exec r args) list))\n     xs", "apply(simp add: rec_exec.simps rec_embranch.simps Embranch.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec (rec_embranch ((a, aa) # zip rgs list)) xs =\n  Embranch\n   ((rec_exec a, \\<lambda>args. 0 < rec_exec aa args) #\n    zip (map rec_exec rgs)\n     (map (\\<lambda>r args. 0 < rec_exec r args) list))\n   xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec (rec_embranch (zip (a # rgs) rcs)) xs =\n  Embranch\n   (zip (map rec_exec (a # rgs))\n     (map (\\<lambda>r args. 0 < rec_exec r args) rcs))\n   xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  \\<open>prime n\\<close> means \\<open>n\\<close> is a prime number.\n\\<close>"], ["", "fun Prime :: \"nat \\<Rightarrow> bool\"\n  where\n    \"Prime x = (1 < x \\<and> (\\<forall> u < x. (\\<forall> v < x. u * v \\<noteq> x)))\""], ["", "declare Prime.simps [simp del]"], ["", "lemma primerec_all1: \n  \"primerec (rec_all rt rf) n \\<Longrightarrow> primerec rt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (rec_all rt rf) n \\<Longrightarrow> primerec rt n", "by (simp add: primerec_all)"], ["", "lemma primerec_all2: \"primerec (rec_all rt rf) n \\<Longrightarrow> \n  primerec rf (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (rec_all rt rf) n \\<Longrightarrow> primerec rf (Suc n)", "by(insert primerec_all[of rt rf n], simp)"], ["", "text \\<open>\n  \\<open>rec_prime\\<close> is the recursive function used to implement\n  \\<open>Prime\\<close>.\n\\<close>"], ["", "definition rec_prime :: \"recf\"\n  where\n    \"rec_prime = Cn (Suc 0) rec_conj \n  [Cn (Suc 0) rec_less [constn 1, id (Suc 0) (0)],\n        rec_all (Cn 1 rec_minus [id 1 0, constn 1]) \n       (rec_all (Cn 2 rec_minus [id 2 0, Cn 2 (constn 1) \n  [id 2 0]]) (Cn 3 rec_noteq \n       [Cn 3 rec_mult [id 3 1, id 3 2], id 3 0]))]\""], ["", "declare numeral_2_eq_2[simp del] numeral_3_eq_3[simp del]"], ["", "lemma exec_tmp: \n  \"rec_exec (rec_all (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]]) \n  (Cn 3 rec_noteq [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))  [x, k] = \n  ((if (\\<forall>w\\<le>rec_exec (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]]) ([x, k]). \n  0 < rec_exec (Cn 3 rec_noteq [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n  ([x, k] @ [w])) then 1 else 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n     [x, k] =\n    (if \\<forall>w\\<le>rec_exec\n                        (Cn 2 rec_minus\n                          [recf.id 2 0,\n                           Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                        [x, k].\n           0 < rec_exec\n                (Cn 3 rec_noteq\n                  [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                   recf.id 3 0])\n                ([x, k] @ [w])\n     then 1 else 0)", "apply(rule_tac all_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n     (Suc (length [x, k]))\n 2. primerec\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (length [x, k])", "apply(auto simp:numeral)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0] !\n         i)\n        (Suc (Suc (Suc 0)))\n 2. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc 0)) 0,\n          Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]] !\n         i)\n        (Suc (Suc 0))", "apply (metis (no_types, lifting) Suc_mono length_Cons less_2_cases list.size(3) nth_Cons_0\n      nth_Cons_Suc numeral_2_eq_2 prime_cn prime_id primerec_rec_mult_2 zero_less_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc 0)) 0,\n          Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]] !\n         i)\n        (Suc (Suc 0))", "by (metis (no_types, lifting) One_nat_def length_Cons less_2_cases nth_Cons_0 nth_Cons_Suc \n      prime_cn_reverse primerec_rec_eq_2 rec_eq_def zero_less_Suc)"], ["", "text \\<open>\n  The correctness of \\<open>Prime\\<close>.\n\\<close>"], ["", "lemma prime_lemma: \"rec_exec rec_prime [x] = (if Prime x then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_prime [x] = (if Prime x then 1 else 0)", "proof(simp add: rec_exec.simps rec_prime_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "let ?rt1 = \"(Cn 2 rec_minus [recf.id 2 0, \n    Cn 2 (constn (Suc 0)) [recf.id 2 0]])\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "let ?rf1 = \"(Cn 3 rec_noteq [Cn 3 rec_mult \n    [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 (0)])\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "let ?rt2 = \"(Cn (Suc 0) rec_minus \n    [recf.id (Suc 0) 0, constn (Suc 0)])\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "let ?rf2 = \"rec_all ?rt1 ?rf1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "have h1: \"rec_exec (rec_all ?rt2 ?rf2) ([x]) = \n        (if (\\<forall>k\\<le>rec_exec ?rt2 ([x]). 0 < rec_exec ?rf2 ([x] @ [k])) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n       (rec_all\n         (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n         (Cn 3 rec_noteq\n           [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n     [x] =\n    (if \\<forall>k\\<le>rec_exec\n                        (Cn (Suc 0) rec_minus\n                          [recf.id (Suc 0) 0, constn (Suc 0)])\n                        [x].\n           0 < rec_exec\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0]))\n                ([x] @ [k])\n     then 1 else 0)", "proof(rule_tac all_lemma, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. primerec\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n     (Suc (Suc 0))\n 2. primerec (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (Suc 0)", "show \"primerec ?rf2 (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n     (Suc (Suc 0))", "apply(rule_tac primerec_all_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. primerec\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (Suc (Suc 0))\n 2. primerec\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n     (Suc (Suc (Suc 0)))\n 3. 0 < Suc (Suc 0)", "apply(auto simp: numeral)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([recf.id (Suc (Suc 0)) 0,\n          Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]] !\n         i)\n        (Suc (Suc 0))\n 2. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0] !\n         i)\n        (Suc (Suc (Suc 0)))", "apply (metis (no_types, lifting) One_nat_def length_Cons less_2_cases nth_Cons_0 nth_Cons_Suc\n          prime_cn_reverse primerec_rec_eq_2 rec_eq_def zero_less_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < Suc (Suc 0) \\<Longrightarrow>\n       primerec\n        ([Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0] !\n         i)\n        (Suc (Suc (Suc 0)))", "by (metis (no_types, lifting) Suc_mono length_Cons less_2_cases list.size(3) nth_Cons_0 \n          nth_Cons_Suc numeral_2_eq_2 prime_cn prime_id primerec_rec_mult_2 zero_less_Suc)"], ["proof (state)\nthis:\n  primerec\n   (rec_all\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   (Suc (Suc 0))\n\ngoal (1 subgoal):\n 1. primerec (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (Suc 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. primerec (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (Suc 0)", "show \"primerec (Cn (Suc 0) rec_minus\n             [recf.id (Suc 0) 0, constn (Suc 0)]) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (Suc 0)", "using less_2_cases numeral"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n  2 = Suc 1\n  3 = Suc 2\n  4 = Suc 3\n  5 = Suc 4\n  6 = Suc 5\n  7 = Suc 6\n  8 = Suc 7\n  9 = Suc 8\n  10 = Suc 9\n  11 = Suc 10\n  12 = Suc 11\n\ngoal (1 subgoal):\n 1. primerec (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (Suc 0)", "by fastforce"], ["proof (state)\nthis:\n  primerec (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n   (Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec\n   (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n   [x] =\n  (if \\<forall>k\\<le>rec_exec\n                      (Cn (Suc 0) rec_minus\n                        [recf.id (Suc 0) 0, constn (Suc 0)])\n                      [x].\n         0 < rec_exec\n              (rec_all\n                (Cn 2 rec_minus\n                  [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                (Cn 3 rec_noteq\n                  [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                   recf.id 3 0]))\n              ([x] @ [k])\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "from h1"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n   [x] =\n  (if \\<forall>k\\<le>rec_exec\n                      (Cn (Suc 0) rec_minus\n                        [recf.id (Suc 0) 0, constn (Suc 0)])\n                      [x].\n         0 < rec_exec\n              (rec_all\n                (Cn 2 rec_minus\n                  [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                (Cn 3 rec_noteq\n                  [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                   recf.id 3 0]))\n              ([x] @ [k])\n   then 1 else 0)", "show \n    \"(Suc 0 < x \\<longrightarrow>  (rec_exec (rec_all ?rt2 ?rf2) [x] = 0 \\<longrightarrow> \n    \\<not> Prime x) \\<and>\n     (0 < rec_exec (rec_all ?rt2 ?rf2) [x] \\<longrightarrow> Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow> \\<not> Prime x \\<and> (rec_exec (rec_all ?rt2 ?rf2) [x] = 0\n    \\<longrightarrow> \\<not> Prime x))\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n   [x] =\n  (if \\<forall>k\\<le>rec_exec\n                      (Cn (Suc 0) rec_minus\n                        [recf.id (Suc 0) 0, constn (Suc 0)])\n                      [x].\n         0 < rec_exec\n              (rec_all\n                (Cn 2 rec_minus\n                  [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                (Cn 3 rec_noteq\n                  [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                   recf.id 3 0]))\n              ([x] @ [k])\n   then 1 else 0)\n\ngoal (1 subgoal):\n 1. (Suc 0 < x \\<longrightarrow>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x) \\<and>\n     (0 < rec_exec\n           (rec_all\n             (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0])))\n           [x] \\<longrightarrow>\n      Prime x)) \\<and>\n    (\\<not> Suc 0 < x \\<longrightarrow>\n     \\<not> Prime x \\<and>\n     (rec_exec\n       (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n              recf.id 3 0])))\n       [x] =\n      0 \\<longrightarrow>\n      \\<not> Prime x))", "apply(auto simp:rec_exec.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     \\<forall>k\\<le>x - Suc 0.\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, k];\n     Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> Prime x\n 2. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: exec_tmp rec_exec.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     \\<forall>k\\<le>x - Suc 0.\n        0 < (if \\<forall>w\\<le>x - Suc 0.\n                   0 < (if k * w \\<noteq> x then 1 else 0)\n             then 1 else 0);\n     Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> Prime x\n 2. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     \\<forall>k\\<le>x - Suc 0.\n        0 < (if \\<forall>w\\<le>x - Suc 0.\n                   0 < (if k * w \\<noteq> x then 1 else 0)\n             then 1 else 0);\n     Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> Prime x\n 2. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "assume *:\"\\<forall>k\\<le>x - Suc 0. (0::nat) < (if \\<forall>w\\<le>x - Suc 0. \n           0 < (if k * w \\<noteq> x then 1 else (0 :: nat)) then 1 else 0)\" \"Suc 0 < x\""], ["proof (state)\nthis:\n  \\<forall>k\\<le>x - Suc 0.\n     0 < (if \\<forall>w\\<le>x - Suc 0.\n                0 < (if k * w \\<noteq> x then 1 else 0)\n          then 1 else 0)\n  Suc 0 < x\n\ngoal (4 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     \\<forall>k\\<le>x - Suc 0.\n        0 < (if \\<forall>w\\<le>x - Suc 0.\n                   0 < (if k * w \\<noteq> x then 1 else 0)\n             then 1 else 0);\n     Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> Prime x\n 2. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"Prime x\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>x - Suc 0.\n     0 < (if \\<forall>w\\<le>x - Suc 0.\n                0 < (if k * w \\<noteq> x then 1 else 0)\n          then 1 else 0)\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. Prime x", "apply(simp add: rec_exec.simps split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k.\n                (\\<forall>w.\n                    k * w = x \\<longrightarrow>\n                    \\<not> w \\<le> x - Suc 0) \\<or>\n                \\<not> k \\<le> x - Suc 0;\n     Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> Prime x", "apply(simp add: Prime.simps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>\\<forall>k.\n                   (\\<forall>w.\n                       k * w = u * v \\<longrightarrow>\n                       \\<not> w \\<le> u * v - Suc 0) \\<or>\n                   \\<not> k \\<le> u * v - Suc 0;\n        Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac u v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>\\<forall>k.\n                   (\\<forall>w.\n                       k * w = u * v \\<longrightarrow>\n                       \\<not> w \\<le> u * v - Suc 0) \\<or>\n                   \\<not> k \\<le> u * v - Suc 0;\n        Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule_tac x = u in allE, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v;\n        \\<not> v \\<le> u * v - Suc 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v;\n        \\<not> u \\<le> u * v - Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac u, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v nat.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v;\n        \\<not> v \\<le> u * v - Suc 0; u = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v;\n        \\<not> u \\<le> u * v - Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"u - 1\", simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v;\n        \\<not> u \\<le> u * v - Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac v, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v nat.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < v; Suc 0 < u; x = u * v;\n        \\<not> u \\<le> u * v - Suc 0; v = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"v - 1\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Prime x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<not> Suc 0 < x\" \"Prime x\""], ["proof (state)\nthis:\n  \\<not> Suc 0 < x\n  Prime x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>rec_exec\n              (rec_all\n                (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n                (rec_all\n                  (Cn 2 rec_minus\n                    [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                  (Cn 3 rec_noteq\n                    [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                     recf.id 3 0])))\n              [x] =\n             Suc 0;\n     0 < rec_exec\n          (rec_all\n            (Cn 2 rec_minus\n              [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n            (Cn 3 rec_noteq\n              [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0]))\n          [x, 0];\n     \\<not> Suc 0 < x; Prime x\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<not> Suc 0 < x\n  Prime x\n\ngoal (1 subgoal):\n 1. False", "apply(simp add: Prime.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"rec_exec (rec_all ?rt1 ?rf1)\n      [x, k] = 0\" \"k \\<le> x - Suc 0\" \"Prime x\""], ["proof (state)\nthis:\n  rec_exec\n   (rec_all\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   [x, k] =\n  0\n  k \\<le> x - Suc 0\n  Prime x\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        0 < rec_exec\n             (rec_all\n               (Cn 2 rec_minus\n                 [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n               (Cn 3 rec_noteq\n                 [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                  recf.id 3 0]))\n             [x, 0];\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_all\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   [x, k] =\n  0\n  k \\<le> x - Suc 0\n  Prime x\n\ngoal (1 subgoal):\n 1. False", "apply(simp add: exec_tmp rec_exec.simps Prime.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"rec_exec (rec_all ?rt1 ?rf1)\n      [x, k] = 0\" \"k \\<le> x - Suc 0\" \"Prime x\""], ["proof (state)\nthis:\n  rec_exec\n   (rec_all\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   [x, k] =\n  0\n  k \\<le> x - Suc 0\n  Prime x\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>rec_exec\n                 (rec_all\n                   (Cn (Suc 0) rec_minus\n                     [recf.id (Suc 0) 0, constn (Suc 0)])\n                   (rec_all\n                     (Cn 2 rec_minus\n                       [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                     (Cn 3 rec_noteq\n                       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                        recf.id 3 0])))\n                 [x] =\n                (if \\<forall>k\\<le>x - Suc 0.\n                       0 < rec_exec\n                            (rec_all\n                              (Cn 2 rec_minus\n                                [recf.id 2 0,\n                                 Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n                              (Cn 3 rec_noteq\n                                [Cn 3 rec_mult\n                                  [recf.id 3 (Suc 0), recf.id 3 2],\n                                 recf.id 3 0]))\n                            [x, k]\n                 then 1 else 0);\n        k \\<le> x - Suc 0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, k] =\n        0;\n        rec_exec\n         (rec_all\n           (Cn 2 rec_minus\n             [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n           (Cn 3 rec_noteq\n             [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n         [x, 0] =\n        0;\n        Prime x\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_all\n     (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n     (Cn 3 rec_noteq\n       [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   [x, k] =\n  0\n  k \\<le> x - Suc 0\n  Prime x\n\ngoal (1 subgoal):\n 1. False", "apply(simp add: exec_tmp rec_exec.simps Prime.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Suc 0 < x \\<longrightarrow>\n   (rec_exec\n     (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n       (rec_all\n         (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n         (Cn 3 rec_noteq\n           [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n     [x] =\n    0 \\<longrightarrow>\n    \\<not> Prime x) \\<and>\n   (0 < rec_exec\n         (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n           (rec_all\n             (Cn 2 rec_minus\n               [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n             (Cn 3 rec_noteq\n               [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2],\n                recf.id 3 0])))\n         [x] \\<longrightarrow>\n    Prime x)) \\<and>\n  (\\<not> Suc 0 < x \\<longrightarrow>\n   \\<not> Prime x \\<and>\n   (rec_exec\n     (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n       (rec_all\n         (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n         (Cn 3 rec_noteq\n           [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n     [x] =\n    0 \\<longrightarrow>\n    \\<not> Prime x))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition rec_dummyfac :: \"recf\"\n  where\n    \"rec_dummyfac = Pr 1 (constn 1) \n  (Cn 3 rec_mult [id 3 2, Cn 3 s [id 3 1]])\""], ["", "text \\<open>\n  The recursive function used to implment factorization.\n\\<close>"], ["", "definition rec_fac :: \"recf\"\n  where\n    \"rec_fac = Cn 1 rec_dummyfac [id 1 0, id 1 0]\""], ["", "text \\<open>\n  Formal specification of factorization.\n\\<close>"], ["", "fun fac :: \"nat \\<Rightarrow> nat\"  (\"_!\" [100] 99)\n  where\n    \"fac 0 = 1\" |\n    \"fac (Suc x) = (Suc x) * fac x\""], ["", "lemma fac_dummy: \"rec_exec rec_dummyfac [x, y] = y !\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_dummyfac [x, y] = y!", "apply(induct y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rec_exec rec_dummyfac [x, 0] = 0!\n 2. \\<And>y.\n       rec_exec rec_dummyfac [x, y] = y! \\<Longrightarrow>\n       rec_exec rec_dummyfac [x, Suc y] = Suc y!", "apply(auto simp: rec_dummyfac_def rec_exec.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_fac\\<close>.\n\\<close>"], ["", "lemma fac_lemma: \"rec_exec rec_fac [x] =  x!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_fac [x] = x!", "apply(simp add: rec_fac_def rec_exec.simps fac_dummy)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare fac.simps[simp del]"], ["", "text \\<open>\n  \\<open>Np x\\<close> returns the first prime number after \\<open>x\\<close>.\n\\<close>"], ["", "fun Np ::\"nat \\<Rightarrow> nat\"\n  where\n    \"Np x = Min {y. y \\<le> Suc (x!) \\<and> x < y \\<and> Prime y}\""], ["", "declare Np.simps[simp del] rec_Minr.simps[simp del]"], ["", "text \\<open>\n  \\<open>rec_np\\<close> is the recursive function used to implement\n  \\<open>Np\\<close>.\n\\<close>"], ["", "definition rec_np :: \"recf\"\n  where\n    \"rec_np = (let Rr = Cn 2 rec_conj [Cn 2 rec_less [id 2 0, id 2 1], \n  Cn 2 rec_prime [id 2 1]]\n             in Cn 1 (rec_Minr Rr) [id 1 0, Cn 1 s [rec_fac]])\""], ["", "lemma n_le_fact[simp]: \"n < Suc (n!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < Suc (n!)", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < Suc (0!)\n 2. \\<And>n. n < Suc (n!) \\<Longrightarrow> Suc n < Suc (Suc n!)", "case (Suc n)"], ["proof (state)\nthis:\n  n < Suc (n!)\n\ngoal (2 subgoals):\n 1. 0 < Suc (0!)\n 2. \\<And>n. n < Suc (n!) \\<Longrightarrow> Suc n < Suc (Suc n!)", "then"], ["proof (chain)\npicking this:\n  n < Suc (n!)", "show ?case"], ["proof (prove)\nusing this:\n  n < Suc (n!)\n\ngoal (1 subgoal):\n 1. Suc n < Suc (Suc n!)", "apply(simp add: fac.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < Suc (n!) \\<Longrightarrow> n < n! + n * n!", "apply(cases n, auto simp: fac.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Suc n < Suc (Suc n!)\n\ngoal (1 subgoal):\n 1. 0 < Suc (0!)", "qed simp"], ["", "lemma divsor_ex: \n  \"\\<lbrakk>\\<not> Prime x; x > Suc 0\\<rbrakk> \\<Longrightarrow> (\\<exists> u > Suc 0. (\\<exists> v > Suc 0. u * v = x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Prime x; Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u>Suc 0. \\<exists>v>Suc 0. u * v = x", "by(auto simp: Prime.simps)"], ["", "lemma divsor_prime_ex: \"\\<lbrakk>\\<not> Prime x; x > Suc 0\\<rbrakk> \\<Longrightarrow> \n  \\<exists> p. Prime p \\<and> p dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Prime x; Suc 0 < x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd x", "apply(induct x rule: wf_induct[where r = \"measure (\\<lambda> y. y)\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> measure (\\<lambda>y. y) \\<longrightarrow>\n                   \\<not> Prime y \\<longrightarrow>\n                   Suc 0 < y \\<longrightarrow>\n                   (\\<exists>p. Prime p \\<and> p dvd y);\n        \\<not> Prime x; Suc 0 < x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd x", "apply(drule_tac divsor_ex, simp, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>\\<forall>y<u * v.\n                   \\<not> Prime y \\<longrightarrow>\n                   Suc 0 < y \\<longrightarrow>\n                   (\\<exists>p. Prime p \\<and> p dvd y);\n        Suc 0 < u * v; Suc 0 < u; Suc 0 < v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd u * v", "apply(rename_tac u v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>\\<forall>y<u * v.\n                   \\<not> Prime y \\<longrightarrow>\n                   Suc 0 < y \\<longrightarrow>\n                   (\\<exists>p. Prime p \\<and> p dvd y);\n        Suc 0 < u * v; Suc 0 < u; Suc 0 < v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd u * v", "apply(erule_tac x = u in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < u; Suc 0 < v;\n        \\<not> Prime u \\<longrightarrow>\n        (\\<exists>p. Prime p \\<and> p dvd u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd u * v", "apply(case_tac \"Prime u\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < u; Suc 0 < v; Prime u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd u * v\n 2. \\<And>u v.\n       \\<lbrakk>Suc 0 < u * v; Suc 0 < u; Suc 0 < v;\n        \\<not> Prime u \\<longrightarrow>\n        (\\<exists>p. Prime p \\<and> p dvd u);\n        \\<not> Prime u\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. Prime p \\<and> p dvd u * v", "apply(rule_tac x = u in exI, simp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fact_pos[intro]: \"0 < n!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n!", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 0!\n 2. \\<And>n. 0 < n! \\<Longrightarrow> 0 < Suc n!", "apply(auto simp: fac.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fac_Suc: \"Suc n! =  (Suc n) * (n!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n! = Suc n * n!", "by(simp add: fac.simps)"], ["", "lemma fac_dvd: \"\\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < q; q \\<le> 0\\<rbrakk> \\<Longrightarrow> q dvd 0!\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < q; q \\<le> n\\<rbrakk>\n                \\<Longrightarrow> q dvd n!;\n        0 < q; q \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> q dvd Suc n!", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!\n  0 < q\n  q \\<le> Suc n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < q; q \\<le> 0\\<rbrakk> \\<Longrightarrow> q dvd 0!\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < q; q \\<le> n\\<rbrakk>\n                \\<Longrightarrow> q dvd n!;\n        0 < q; q \\<le> Suc n\\<rbrakk>\n       \\<Longrightarrow> q dvd Suc n!", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!\n  0 < q\n  q \\<le> Suc n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!\n  0 < q\n  q \\<le> Suc n\n\ngoal (1 subgoal):\n 1. q dvd Suc n!", "apply(cases \"q \\<le> n\", simp add: fac_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!;\n     0 < q; q \\<le> Suc n; \\<not> q \\<le> n\\<rbrakk>\n    \\<Longrightarrow> q dvd Suc n!", "apply(subgoal_tac \"q = Suc n\", simp only: fac_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>True; False\\<rbrakk> \\<Longrightarrow> Suc n dvd n!;\n     0 < Suc n; Suc n \\<le> Suc n; \\<not> Suc n \\<le> n; q = Suc n\\<rbrakk>\n    \\<Longrightarrow> Suc n dvd Suc n * n!\n 2. \\<lbrakk>\\<lbrakk>0 < q; q \\<le> n\\<rbrakk> \\<Longrightarrow> q dvd n!;\n     0 < q; q \\<le> Suc n; \\<not> q \\<le> n\\<rbrakk>\n    \\<Longrightarrow> q = Suc n", "apply(rule_tac dvd_mult2, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q dvd Suc n!\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < q; q \\<le> 0\\<rbrakk> \\<Longrightarrow> q dvd 0!", "qed simp"], ["", "lemma fac_dvd2: \"\\<lbrakk>Suc 0 < q; q dvd n!; q \\<le> n\\<rbrakk> \\<Longrightarrow> \\<not> q dvd Suc (n!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < q; q dvd n!; q \\<le> n\\<rbrakk>\n    \\<Longrightarrow> \\<not> q dvd Suc (n!)", "proof(auto simp: dvd_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>Suc 0 < q; q \\<le> n; n! = q * k;\n        Suc (q * k) = q * ka\\<rbrakk>\n       \\<Longrightarrow> False", "fix k ka"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>Suc 0 < q; q \\<le> n; n! = q * k;\n        Suc (q * k) = q * ka\\<rbrakk>\n       \\<Longrightarrow> False", "assume h1: \"Suc 0 < q\" \"q \\<le> n\"\n    and h2: \"Suc (q * k) = q * ka\""], ["proof (state)\nthis:\n  Suc 0 < q\n  q \\<le> n\n  Suc (q * k) = q * ka\n\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>Suc 0 < q; q \\<le> n; n! = q * k;\n        Suc (q * k) = q * ka\\<rbrakk>\n       \\<Longrightarrow> False", "have \"k < ka\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < ka", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k < ka", "have \"q * k < q * ka\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * k < q * ka", "using h2"], ["proof (prove)\nusing this:\n  Suc (q * k) = q * ka\n\ngoal (1 subgoal):\n 1. q * k < q * ka", "by arith"], ["proof (state)\nthis:\n  q * k < q * ka\n\ngoal (1 subgoal):\n 1. k < ka", "thus \"k < ka\""], ["proof (prove)\nusing this:\n  q * k < q * ka\n\ngoal (1 subgoal):\n 1. k < ka", "using h1"], ["proof (prove)\nusing this:\n  q * k < q * ka\n  Suc 0 < q\n  q \\<le> n\n\ngoal (1 subgoal):\n 1. k < ka", "by(auto)"], ["proof (state)\nthis:\n  k < ka\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k < ka\n\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>Suc 0 < q; q \\<le> n; n! = q * k;\n        Suc (q * k) = q * ka\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>d. d > 0 \\<and>  ka = d + k\""], ["proof (prove)\nusing this:\n  k < ka\n\ngoal (1 subgoal):\n 1. \\<exists>d>0. ka = d + k", "by(rule_tac x = \"ka - k\" in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>d>0. ka = d + k\n\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>Suc 0 < q; q \\<le> n; n! = q * k;\n        Suc (q * k) = q * ka\\<rbrakk>\n       \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>d>0. ka = d + k", "obtain d where \"d > 0 \\<and> ka = d + k\""], ["proof (prove)\nusing this:\n  \\<exists>d>0. ka = d + k\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        0 < d \\<and> ka = d + k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  0 < d \\<and> ka = d + k\n\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>Suc 0 < q; q \\<le> n; n! = q * k;\n        Suc (q * k) = q * ka\\<rbrakk>\n       \\<Longrightarrow> False", "from h2 and this and h1"], ["proof (chain)\npicking this:\n  Suc (q * k) = q * ka\n  0 < d \\<and> ka = d + k\n  Suc 0 < q\n  q \\<le> n", "show \"False\""], ["proof (prove)\nusing this:\n  Suc (q * k) = q * ka\n  0 < d \\<and> ka = d + k\n  Suc 0 < q\n  q \\<le> n\n\ngoal (1 subgoal):\n 1. False", "by(simp add: add_mult_distrib2)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_ex: \"\\<exists> p. n < p \\<and> p \\<le> Suc (n!) \\<and> Prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "proof(cases \"Prime (n! + 1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n 2. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "case True"], ["proof (state)\nthis:\n  Prime (n! + 1)\n\ngoal (2 subgoals):\n 1. Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n 2. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  Prime (n! + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "by(rule_tac x = \"Suc (n!)\" in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n\ngoal (1 subgoal):\n 1. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "assume h: \"\\<not> Prime (n! + 1)\""], ["proof (state)\nthis:\n  \\<not> Prime (n! + 1)\n\ngoal (1 subgoal):\n 1. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "hence \"\\<exists> p. Prime p \\<and> p dvd (n! + 1)\""], ["proof (prove)\nusing this:\n  \\<not> Prime (n! + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>p. Prime p \\<and> p dvd n! + 1", "by(erule_tac divsor_prime_ex, auto)"], ["proof (state)\nthis:\n  \\<exists>p. Prime p \\<and> p dvd n! + 1\n\ngoal (1 subgoal):\n 1. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "from this"], ["proof (chain)\npicking this:\n  \\<exists>p. Prime p \\<and> p dvd n! + 1", "obtain q where k: \"Prime q \\<and> q dvd (n! + 1)\""], ["proof (prove)\nusing this:\n  \\<exists>p. Prime p \\<and> p dvd n! + 1\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        Prime q \\<and> q dvd n! + 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  Prime q \\<and> q dvd n! + 1\n\ngoal (1 subgoal):\n 1. \\<not> Prime (n! + 1) \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  Prime q \\<and> q dvd n! + 1\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "proof(cases \"q > n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Prime q \\<and> q dvd n! + 1; n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n 2. \\<lbrakk>Prime q \\<and> q dvd n! + 1; \\<not> n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "case True"], ["proof (state)\nthis:\n  n < q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Prime q \\<and> q dvd n! + 1; n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n 2. \\<lbrakk>Prime q \\<and> q dvd n! + 1; \\<not> n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  n < q\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "using k"], ["proof (prove)\nusing this:\n  n < q\n  Prime q \\<and> q dvd n! + 1\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "by(auto intro:dvd_imp_le)"], ["proof (state)\nthis:\n  \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Prime q \\<and> q dvd n! + 1; \\<not> n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Prime q \\<and> q dvd n! + 1; \\<not> n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "case False"], ["proof (state)\nthis:\n  \\<not> n < q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Prime q \\<and> q dvd n! + 1; \\<not> n < q\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<not> n < q\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < q \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "assume g: \"\\<not> n < q\""], ["proof (state)\nthis:\n  \\<not> n < q\n\ngoal (1 subgoal):\n 1. \\<not> n < q \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "have j: \"q > Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < q", "using k"], ["proof (prove)\nusing this:\n  Prime q \\<and> q dvd n! + 1\n\ngoal (1 subgoal):\n 1. Suc 0 < q", "by(cases q, auto simp: Prime.simps)"], ["proof (state)\nthis:\n  Suc 0 < q\n\ngoal (1 subgoal):\n 1. \\<not> n < q \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "hence \"q dvd n!\""], ["proof (prove)\nusing this:\n  Suc 0 < q\n\ngoal (1 subgoal):\n 1. q dvd n!", "using g"], ["proof (prove)\nusing this:\n  Suc 0 < q\n  \\<not> n < q\n\ngoal (1 subgoal):\n 1. q dvd n!", "apply(rule_tac fac_dvd, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  q dvd n!\n\ngoal (1 subgoal):\n 1. \\<not> n < q \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "hence \"\\<not> q dvd Suc (n!)\""], ["proof (prove)\nusing this:\n  q dvd n!\n\ngoal (1 subgoal):\n 1. \\<not> q dvd Suc (n!)", "using g j"], ["proof (prove)\nusing this:\n  q dvd n!\n  \\<not> n < q\n  Suc 0 < q\n\ngoal (1 subgoal):\n 1. \\<not> q dvd Suc (n!)", "by(rule_tac fac_dvd2, auto)"], ["proof (state)\nthis:\n  \\<not> q dvd Suc (n!)\n\ngoal (1 subgoal):\n 1. \\<not> n < q \\<Longrightarrow>\n    \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<not> q dvd Suc (n!)\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "using k"], ["proof (prove)\nusing this:\n  \\<not> q dvd Suc (n!)\n  Prime q \\<and> q dvd n! + 1\n\ngoal (1 subgoal):\n 1. \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p", "by simp"], ["proof (state)\nthis:\n  \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p>n. p \\<le> Suc (n!) \\<and> Prime p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Suc_Suc_induct[elim!]: \"\\<lbrakk>i < Suc (Suc 0); \n  primerec (ys ! 0) n; primerec (ys ! 1) n\\<rbrakk> \\<Longrightarrow> primerec (ys ! i) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc (Suc 0); primerec (ys ! 0) n;\n     primerec (ys ! 1) n\\<rbrakk>\n    \\<Longrightarrow> primerec (ys ! i) n", "by(cases i, auto)"], ["", "lemma primerec_rec_prime_1[intro]: \"primerec rec_prime (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_prime (Suc 0)", "apply(auto simp: rec_prime_def, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (rec_all (Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)])\n       (rec_all\n         (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n         (Cn 3 rec_noteq\n           [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])))\n     (Suc 0)", "apply(rule_tac primerec_all_iff, auto, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (rec_all\n       (Cn 2 rec_minus [recf.id 2 0, Cn 2 (constn (Suc 0)) [recf.id 2 0]])\n       (Cn 3 rec_noteq\n         [Cn 3 rec_mult [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n     (Suc (Suc 0))", "apply(rule_tac primerec_all_iff, auto, auto simp:  \n      numeral_2_eq_2 numeral_3_eq_3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_np\\<close>.\n\\<close>"], ["", "lemma np_lemma: \"rec_exec rec_np [x] = Np x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_np [x] = Np x", "proof(auto simp: rec_np_def rec_exec.simps Let_def fac_lemma)"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     [x, Suc (x!)] =\n    Np x", "let ?rr = \"(Cn 2 rec_conj [Cn 2 rec_less [recf.id 2 0,\n    recf.id 2 (Suc 0)], Cn 2 rec_prime [recf.id 2 (Suc 0)]])\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     [x, Suc (x!)] =\n    Np x", "let ?R = \"\\<lambda> zs. zs ! 0 < zs ! 1 \\<and> Prime (zs ! 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     [x, Suc (x!)] =\n    Np x", "have g1: \"rec_exec (rec_Minr ?rr) ([x] @ [Suc (x!)]) = \n    Minr (\\<lambda> args. 0 < rec_exec ?rr args) [x] (Suc (x!))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     ([x] @ [Suc (x!)]) =\n    Minr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn 2 rec_conj\n                [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n                 Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n              args)\n     [x] (Suc (x!))", "by(rule_tac Minr_lemma, auto simp: rec_exec.simps\n        prime_lemma, auto simp:  numeral_2_eq_2 numeral_3_eq_3)"], ["proof (state)\nthis:\n  rec_exec\n   (rec_Minr\n     (Cn 2 rec_conj\n       [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n        Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n   ([x] @ [Suc (x!)]) =\n  Minr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 2 rec_conj\n              [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n               Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n            args)\n   [x] (Suc (x!))\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     [x, Suc (x!)] =\n    Np x", "have g2: \"Minr (\\<lambda> args. 0 < rec_exec ?rr args) [x] (Suc (x!)) = Np x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Minr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn 2 rec_conj\n                [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n                 Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n              args)\n     [x] (Suc (x!)) =\n    Np x", "using prime_ex[of x]"], ["proof (prove)\nusing this:\n  \\<exists>p>x. p \\<le> Suc (x!) \\<and> Prime p\n\ngoal (1 subgoal):\n 1. Minr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn 2 rec_conj\n                [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n                 Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n              args)\n     [x] (Suc (x!)) =\n    Np x", "apply(auto simp: Minr.simps Np.simps rec_exec.simps prime_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p xa.\n       \\<lbrakk>x < p; p \\<le> Suc (x!); Prime p; Prime xa; x < xa;\n        xa \\<le> Suc (x!)\\<rbrakk>\n       \\<Longrightarrow> Min {uu_.\n                              (Prime uu_ \\<longrightarrow>\n                               (x < uu_ \\<longrightarrow>\n                                uu_ \\<le> Suc (x!)) \\<and>\n                               x < uu_) \\<and>\n                              Prime uu_} =\n                         Min {y. y \\<le> Suc (x!) \\<and>\n                                 x < y \\<and> Prime y}", "apply(subgoal_tac\n        \"{uu. (Prime uu \\<longrightarrow> (x < uu \\<longrightarrow> uu \\<le> Suc (x!)) \\<and> x < uu) \\<and> Prime uu}\n    = {y. y \\<le> Suc (x!) \\<and> x < y \\<and> Prime y}\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Minr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 2 rec_conj\n              [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n               Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n            args)\n   [x] (Suc (x!)) =\n  Np x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     [x, Suc (x!)] =\n    Np x", "from g1 and g2"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_Minr\n     (Cn 2 rec_conj\n       [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n        Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n   ([x] @ [Suc (x!)]) =\n  Minr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 2 rec_conj\n              [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n               Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n            args)\n   [x] (Suc (x!))\n  Minr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 2 rec_conj\n              [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n               Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n            args)\n   [x] (Suc (x!)) =\n  Np x", "show \"rec_exec (rec_Minr ?rr) ([x, Suc (x!)]) = Np x\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_Minr\n     (Cn 2 rec_conj\n       [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n        Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n   ([x] @ [Suc (x!)]) =\n  Minr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 2 rec_conj\n              [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n               Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n            args)\n   [x] (Suc (x!))\n  Minr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 2 rec_conj\n              [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n               Cn 2 rec_prime [recf.id 2 (Suc 0)]])\n            args)\n   [x] (Suc (x!)) =\n  Np x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_Minr\n       (Cn 2 rec_conj\n         [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n          Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n     [x, Suc (x!)] =\n    Np x", "by simp"], ["proof (state)\nthis:\n  rec_exec\n   (rec_Minr\n     (Cn 2 rec_conj\n       [Cn 2 rec_less [recf.id 2 0, recf.id 2 (Suc 0)],\n        Cn 2 rec_prime [recf.id 2 (Suc 0)]]))\n   [x, Suc (x!)] =\n  Np x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  \\<open>rec_power\\<close> is the recursive function used to implement\n  power function.\n\\<close>"], ["", "definition rec_power :: \"recf\"\n  where\n    \"rec_power = Pr 1 (constn 1) (Cn 3 rec_mult [id 3 0, id 3 2])\""], ["", "text \\<open>\n  The correctness of \\<open>rec_power\\<close>.\n\\<close>"], ["", "lemma power_lemma: \"rec_exec rec_power [x, y] = x^y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_power [x, y] = x ^ y", "by(induct y, auto simp: rec_exec.simps rec_power_def)"], ["", "text\\<open>\n  \\<open>Pi k\\<close> returns the \\<open>k\\<close>-th prime number.\n\\<close>"], ["", "fun Pi :: \"nat \\<Rightarrow> nat\"\n  where\n    \"Pi 0 = 2\" |\n    \"Pi (Suc x) = Np (Pi x)\""], ["", "definition rec_dummy_pi :: \"recf\"\n  where\n    \"rec_dummy_pi = Pr 1 (constn 2) (Cn 3 rec_np [id 3 2])\""], ["", "text \\<open>\n  \\<open>rec_pi\\<close> is the recursive function used to implement\n  \\<open>Pi\\<close>.\n\\<close>"], ["", "definition rec_pi :: \"recf\"\n  where\n    \"rec_pi = Cn 1 rec_dummy_pi [id 1 0, id 1 0]\""], ["", "lemma pi_dummy_lemma: \"rec_exec rec_dummy_pi [x, y] = Pi y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_dummy_pi [x, y] = Pi y", "apply(induct y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rec_exec rec_dummy_pi [x, 0] = Pi 0\n 2. \\<And>y.\n       rec_exec rec_dummy_pi [x, y] = Pi y \\<Longrightarrow>\n       rec_exec rec_dummy_pi [x, Suc y] = Pi (Suc y)", "by(auto simp: rec_exec.simps rec_dummy_pi_def Pi.simps np_lemma)"], ["", "text \\<open>\n  The correctness of \\<open>rec_pi\\<close>.\n\\<close>"], ["", "lemma pi_lemma: \"rec_exec rec_pi [x] = Pi x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_pi [x] = Pi x", "apply(simp add: rec_pi_def rec_exec.simps pi_dummy_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun loR :: \"nat list \\<Rightarrow> bool\"\n  where\n    \"loR [x, y, u] = (x mod (y^u) = 0)\""], ["", "declare loR.simps[simp del]"], ["", "text \\<open>\n  \\<open>Lo\\<close> specifies the \\<open>lo\\<close> function given on page 79 of \n  Boolos's book. It is one of the two notions of integeral logarithmetic\n  operation on that page. The other is \\<open>lg\\<close>.\n\\<close>"], ["", "fun lo :: \" nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where \n    \"lo x y  = (if x > 1 \\<and> y > 1 \\<and> {u. loR [x, y, u]} \\<noteq> {} then Max {u. loR [x, y, u]}\n                                                         else 0)\""], ["", "declare lo.simps[simp del]"], ["", "lemma primerec_sigma[intro!]:  \n  \"\\<lbrakk>n > Suc 0; primerec rf n\\<rbrakk> \\<Longrightarrow> \n  primerec (rec_sigma rf) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < n; primerec rf n\\<rbrakk>\n    \\<Longrightarrow> primerec (rec_sigma rf) n", "apply(simp add: rec_sigma.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < n; primerec rf n\\<rbrakk>\n    \\<Longrightarrow> primerec\n                       (Pr (n - Suc 0)\n                         (Cn (n - Suc 0) rf\n                           (get_fstn_args (n - Suc 0) (n - Suc 0) @\n                            [Cn (n - Suc 0) (constn 0)\n                              [recf.id (n - Suc 0) 0]]))\n                         (Cn (Suc n) rec_add\n                           [recf.id (Suc n) n,\n                            Cn (Suc n) rf\n                             (get_fstn_args (Suc n) (n - Suc 0) @\n                              [Cn (Suc n) s\n                                [recf.id (Suc n) (n - Suc 0)]])]))\n                       n", "apply(auto, auto simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_maxr[intro!]:  \"\\<lbrakk>primerec rf n; n > 0\\<rbrakk> \\<Longrightarrow> primerec (rec_maxr rf) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rf n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> primerec (rec_maxr rf) n", "apply(simp add: rec_maxr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec rf n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> primerec\n                       (Cn n\n                         (rec_sigma\n                           (Cn (Suc n) rec_not\n                             [rec_all (recf.id (Suc n) (n - Suc 0))\n                               (Cn (Suc (Suc n)) rec_disj\n                                 [Cn (Suc (Suc n)) rec_le\n                                   [recf.id (Suc (Suc n)) (Suc n),\n                                    recf.id (Suc (Suc n)) n],\n                                  Cn (Suc (Suc n)) rec_not\n                                   [Cn (Suc (Suc n)) rf\n                                     (get_fstn_args (Suc (Suc n))\n (n - Suc 0) @\n[recf.id (Suc (Suc n)) (Suc n)])]])]))\n                         (get_fstn_args n n @ [recf.id n (n - Suc 0)]))\n                       n", "apply(rule_tac prime_cn, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>primerec rf n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> primerec\n                       (rec_all (recf.id (Suc n) (n - Suc 0))\n                         (Cn (Suc (Suc n)) rec_disj\n                           [Cn (Suc (Suc n)) rec_le\n                             [recf.id (Suc (Suc n)) (Suc n),\n                              recf.id (Suc (Suc n)) n],\n                            Cn (Suc (Suc n)) rec_not\n                             [Cn (Suc (Suc n)) rf\n                               (get_fstn_args (Suc (Suc n)) (n - Suc 0) @\n                                [recf.id (Suc (Suc n)) (Suc n)])]]))\n                       (Suc n)\n 2. \\<And>i.\n       \\<lbrakk>primerec rf n; 0 < n; i < Suc n\\<rbrakk>\n       \\<Longrightarrow> primerec\n                          ((get_fstn_args n n @ [recf.id n (n - Suc 0)]) !\n                           i)\n                          n", "apply(rule_tac primerec_all_iff, auto, auto simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Suc_Suc_Suc_induct[elim!]: \n  \"\\<lbrakk>i < Suc (Suc (Suc (0::nat))); primerec (ys ! 0) n;\n  primerec (ys ! 1) n;  \n  primerec (ys ! 2) n\\<rbrakk> \\<Longrightarrow> primerec (ys ! i) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc (Suc (Suc 0)); primerec (ys ! 0) n;\n     primerec (ys ! 1) n; primerec (ys ! 2) n\\<rbrakk>\n    \\<Longrightarrow> primerec (ys ! i) n", "apply(cases i, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>nat < Suc (Suc 0); primerec (ys ! 0) n;\n        primerec (ys ! Suc 0) n; primerec (ys ! 2) n; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> primerec (ys ! Suc nat) n", "apply(cases \"i-1\", simp, simp add: numeral_2_eq_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_2[intro]:\n  \"primerec rec_quo (Suc (Suc 0))\" \"primerec rec_mod (Suc (Suc 0))\"\n  \"primerec rec_power (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_quo (Suc (Suc 0)) &&&\n    primerec rec_mod (Suc (Suc 0)) &&& primerec rec_power (Suc (Suc 0))", "by(force simp: prime_cn prime_id rec_mod_def rec_quo_def rec_power_def prime_pr numeral)+"], ["", "text \\<open>\n  \\<open>rec_lo\\<close> is the recursive function used to implement \\<open>Lo\\<close>.\n\\<close>"], ["", "definition rec_lo :: \"recf\"\n  where\n    \"rec_lo = (let rR = Cn 3 rec_eq [Cn 3 rec_mod [id 3 0, \n               Cn 3 rec_power [id 3 1, id 3 2]], \n                     Cn 3 (constn 0) [id 3 1]] in\n             let rb =  Cn 2 (rec_maxr rR) [id 2 0, id 2 1, id 2 0] in \n             let rcond = Cn 2 rec_conj [Cn 2 rec_less [Cn 2 (constn 1)\n                                             [id 2 0], id 2 0], \n                                        Cn 2 rec_less [Cn 2 (constn 1)\n                                                [id 2 0], id 2 1]] in \n             let rcond2 = Cn 2 rec_minus \n                              [Cn 2 (constn 1) [id 2 0], rcond] \n             in Cn 2 rec_add [Cn 2 rec_mult [rb, rcond], \n                  Cn 2 rec_mult [Cn 2 (constn 0) [id 2 0], rcond2]])\""], ["", "lemma rec_lo_Maxr_lor:\n  \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow>  \n        rec_exec rec_lo [x, y] = Maxr loR [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_lo [x, y] = Maxr loR [x, y] x", "proof(auto simp: rec_exec.simps rec_lo_def Let_def \n    numeral_2_eq_2 numeral_3_eq_3)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn (Suc (Suc (Suc 0))) rec_eq\n                           [Cn (Suc (Suc (Suc 0))) rec_mod\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                            Cn (Suc (Suc (Suc 0))) (constn 0)\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                       [x, y, x] =\n                      Maxr loR [x, y] x", "let ?rR = \"(Cn (Suc (Suc (Suc 0))) rec_eq\n     [Cn (Suc (Suc (Suc 0))) rec_mod [recf.id (Suc (Suc (Suc 0))) 0,\n     Cn (Suc (Suc (Suc 0))) rec_power [recf.id (Suc (Suc (Suc 0)))\n     (Suc 0), recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n     Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn (Suc (Suc (Suc 0))) rec_eq\n                           [Cn (Suc (Suc (Suc 0))) rec_mod\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                            Cn (Suc (Suc (Suc 0))) (constn 0)\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                       [x, y, x] =\n                      Maxr loR [x, y] x", "have h: \"rec_exec (rec_maxr ?rR) ([x, y] @ [x]) =\n    Maxr (\\<lambda> args. 0 < rec_exec ?rR args) [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_eq\n         [Cn (Suc (Suc (Suc 0))) rec_mod\n           [recf.id (Suc (Suc (Suc 0))) 0,\n            Cn (Suc (Suc (Suc 0))) rec_power\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n     ([x, y] @ [x]) =\n    Maxr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn (Suc (Suc (Suc 0))) rec_eq\n                [Cn (Suc (Suc (Suc 0))) rec_mod\n                  [recf.id (Suc (Suc (Suc 0))) 0,\n                   Cn (Suc (Suc (Suc 0))) rec_power\n                    [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                     recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n              args)\n     [x, y] x", "by(rule_tac Maxr_lemma, auto simp: rec_exec.simps\n        mod_lemma power_lemma, auto simp: numeral_2_eq_2 numeral_3_eq_3)"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_eq\n       [Cn (Suc (Suc (Suc 0))) rec_mod\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) rec_power\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n        Cn (Suc (Suc (Suc 0))) (constn 0)\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_eq\n              [Cn (Suc (Suc (Suc 0))) rec_mod\n                [recf.id (Suc (Suc (Suc 0))) 0,\n                 Cn (Suc (Suc (Suc 0))) rec_power\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn (Suc (Suc (Suc 0))) rec_eq\n                           [Cn (Suc (Suc (Suc 0))) rec_mod\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                            Cn (Suc (Suc (Suc 0))) (constn 0)\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                       [x, y, x] =\n                      Maxr loR [x, y] x", "have \"Maxr loR [x, y] x =  Maxr (\\<lambda> args. 0 < rec_exec ?rR args) [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Maxr loR [x, y] x =\n    Maxr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn (Suc (Suc (Suc 0))) rec_eq\n                [Cn (Suc (Suc (Suc 0))) rec_mod\n                  [recf.id (Suc (Suc (Suc 0))) 0,\n                   Cn (Suc (Suc (Suc 0))) rec_power\n                    [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                     recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n              args)\n     [x, y] x", "apply(simp add: rec_exec.simps mod_lemma power_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Maxr loR [x, y] x =\n    Maxr (\\<lambda>args. args ! 0 mod args ! Suc 0 ^ args ! Suc (Suc 0) = 0)\n     [x, y] x", "apply(simp add: Maxr.simps loR.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Maxr loR [x, y] x =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_eq\n              [Cn (Suc (Suc (Suc 0))) rec_mod\n                [recf.id (Suc (Suc (Suc 0))) 0,\n                 Cn (Suc (Suc (Suc 0))) rec_power\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn (Suc (Suc (Suc 0))) rec_eq\n                           [Cn (Suc (Suc (Suc 0))) rec_mod\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                            Cn (Suc (Suc (Suc 0))) (constn 0)\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                       [x, y, x] =\n                      Maxr loR [x, y] x", "from h and this"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_eq\n       [Cn (Suc (Suc (Suc 0))) rec_mod\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) rec_power\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n        Cn (Suc (Suc (Suc 0))) (constn 0)\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_eq\n              [Cn (Suc (Suc (Suc 0))) rec_mod\n                [recf.id (Suc (Suc (Suc 0))) 0,\n                 Cn (Suc (Suc (Suc 0))) rec_power\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n            args)\n   [x, y] x\n  Maxr loR [x, y] x =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_eq\n              [Cn (Suc (Suc (Suc 0))) rec_mod\n                [recf.id (Suc (Suc (Suc 0))) 0,\n                 Cn (Suc (Suc (Suc 0))) rec_power\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n            args)\n   [x, y] x", "show \"rec_exec (rec_maxr ?rR) [x, y, x] = \n    Maxr loR [x, y] x\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_eq\n       [Cn (Suc (Suc (Suc 0))) rec_mod\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) rec_power\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n        Cn (Suc (Suc (Suc 0))) (constn 0)\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_eq\n              [Cn (Suc (Suc (Suc 0))) rec_mod\n                [recf.id (Suc (Suc (Suc 0))) 0,\n                 Cn (Suc (Suc (Suc 0))) rec_power\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n            args)\n   [x, y] x\n  Maxr loR [x, y] x =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn (Suc (Suc (Suc 0))) rec_eq\n              [Cn (Suc (Suc (Suc 0))) rec_mod\n                [recf.id (Suc (Suc (Suc 0))) 0,\n                 Cn (Suc (Suc (Suc 0))) rec_power\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) (Suc 0)]])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn (Suc (Suc (Suc 0))) rec_eq\n         [Cn (Suc (Suc (Suc 0))) rec_mod\n           [recf.id (Suc (Suc (Suc 0))) 0,\n            Cn (Suc (Suc (Suc 0))) rec_power\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n     [x, y, x] =\n    Maxr loR [x, y] x", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn (Suc (Suc (Suc 0))) rec_eq\n       [Cn (Suc (Suc (Suc 0))) rec_mod\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) rec_power\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n        Cn (Suc (Suc (Suc 0))) (constn 0)\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n   [x, y, x] =\n  Maxr loR [x, y] x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma x_less_exp: \"\\<lbrakk>y > Suc 0\\<rbrakk> \\<Longrightarrow> x < y^x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < y \\<Longrightarrow> x < y ^ x", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc 0 < y \\<Longrightarrow> 0 < y ^ 0\n 2. \\<And>x.\n       \\<lbrakk>Suc 0 < y \\<Longrightarrow> x < y ^ x; Suc 0 < y\\<rbrakk>\n       \\<Longrightarrow> Suc x < y ^ Suc x", "case (Suc x)"], ["proof (state)\nthis:\n  Suc 0 < y \\<Longrightarrow> x < y ^ x\n  Suc 0 < y\n\ngoal (2 subgoals):\n 1. Suc 0 < y \\<Longrightarrow> 0 < y ^ 0\n 2. \\<And>x.\n       \\<lbrakk>Suc 0 < y \\<Longrightarrow> x < y ^ x; Suc 0 < y\\<rbrakk>\n       \\<Longrightarrow> Suc x < y ^ Suc x", "then"], ["proof (chain)\npicking this:\n  Suc 0 < y \\<Longrightarrow> x < y ^ x\n  Suc 0 < y", "show ?case"], ["proof (prove)\nusing this:\n  Suc 0 < y \\<Longrightarrow> x < y ^ x\n  Suc 0 < y\n\ngoal (1 subgoal):\n 1. Suc x < y ^ Suc x", "apply(cases x, simp, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat < y * y ^ nat; x = Suc nat; Suc 0 < y\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc nat) < y * (y * y ^ nat)", "apply(rule_tac y = \"y* y^(x-1)\" in le_less_trans, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Suc x < y ^ Suc x\n\ngoal (1 subgoal):\n 1. Suc 0 < y \\<Longrightarrow> 0 < y ^ 0", "qed simp"], ["", "lemma uplimit_loR:\n  assumes \"Suc 0 < x\" \"Suc 0 < y\" \"loR [x, y, xa]\"\n  shows \"xa \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa \\<le> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xa \\<le> x", "have \"Suc 0 < x \\<Longrightarrow> Suc 0 < y \\<Longrightarrow> y ^ xa dvd x \\<Longrightarrow> xa \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y; y ^ xa dvd x\\<rbrakk>\n    \\<Longrightarrow> xa \\<le> x", "by (meson Suc_lessD le_less_trans nat_dvd_not_less nat_le_linear x_less_exp)"], ["proof (state)\nthis:\n  \\<lbrakk>Suc 0 < x; Suc 0 < y; y ^ xa dvd x\\<rbrakk>\n  \\<Longrightarrow> xa \\<le> x\n\ngoal (1 subgoal):\n 1. xa \\<le> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc 0 < x; Suc 0 < y; y ^ xa dvd x\\<rbrakk>\n  \\<Longrightarrow> xa \\<le> x\n\ngoal (1 subgoal):\n 1. xa \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc 0 < x; Suc 0 < y; y ^ xa dvd x\\<rbrakk>\n  \\<Longrightarrow> xa \\<le> x\n  Suc 0 < x\n  Suc 0 < y\n  loR [x, y, xa]\n\ngoal (1 subgoal):\n 1. xa \\<le> x", "by(auto simp: loR.simps)"], ["proof (state)\nthis:\n  xa \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loR_set_strengthen[simp]: \"\\<lbrakk>xa \\<le> x; loR [x, y, xa]; Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow>\n  {u. loR [x, y, u]} = {ya. ya \\<le> x \\<and> loR [x, y, ya]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa \\<le> x; loR [x, y, xa]; Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> {u. loR [x, y, u]} =\n                      {ya. ya \\<le> x \\<and> loR [x, y, ya]}", "apply(rule_tac Collect_cong, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>xa \\<le> x; loR [x, y, xa]; Suc 0 < x; Suc 0 < y;\n        loR [x, y, u]\\<rbrakk>\n       \\<Longrightarrow> u \\<le> x", "apply(erule_tac uplimit_loR, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Maxr_lo: \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow>\n  Maxr loR [x, y] x = lo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> Maxr loR [x, y] x = lo x y", "apply(simp add: Maxr.simps lo.simps, auto simp: uplimit_loR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < y;\n        \\<forall>xa\\<le>x. \\<not> loR [x, y, xa]; loR [x, y, xa]\\<rbrakk>\n       \\<Longrightarrow> Max {u. loR [x, y, u]} = 0\n 2. \\<And>xa xaa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < y; loR [x, y, xa];\n        loR [x, y, xaa]\\<rbrakk>\n       \\<Longrightarrow> Max {ya. ya \\<le> x \\<and> loR [x, y, ya]} =\n                         Max {u. loR [x, y, u]}", "by (meson uplimit_loR)+"], ["", "lemma lo_lemma': \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> \n  rec_exec rec_lo [x, y] = lo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y", "by(simp add: Maxr_lo  rec_lo_Maxr_lor)"], ["", "lemma lo_lemma'': \"\\<lbrakk>\\<not> Suc 0 < x\\<rbrakk> \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < x \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y", "apply(cases x, auto simp: rec_exec.simps rec_lo_def \n      Let_def lo.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lo_lemma''': \"\\<lbrakk>\\<not> Suc 0 < y\\<rbrakk> \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < y \\<Longrightarrow> rec_exec rec_lo [x, y] = lo x y", "apply(cases y, auto simp: rec_exec.simps rec_lo_def \n      Let_def lo.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_lo\\<close>:\n\\<close>"], ["", "lemma lo_lemma: \"rec_exec rec_lo [x, y] = lo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_lo [x, y] = lo x y", "apply(cases \"Suc 0 < x \\<and> Suc 0 < y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc 0 < x \\<and> Suc 0 < y \\<Longrightarrow>\n    rec_exec rec_lo [x, y] = lo x y\n 2. \\<not> (Suc 0 < x \\<and> Suc 0 < y) \\<Longrightarrow>\n    rec_exec rec_lo [x, y] = lo x y", "apply(auto simp: lo_lemma' lo_lemma'' lo_lemma''')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun lgR :: \"nat list \\<Rightarrow> bool\"\n  where\n    \"lgR [x, y, u] = (y^u \\<le> x)\""], ["", "text \\<open>\n  \\<open>lg\\<close> specifies the \\<open>lg\\<close> function given on page 79 of \n  Boolos's book. It is one of the two notions of integeral logarithmetic\n  operation on that page. The other is \\<open>lo\\<close>.\n\\<close>"], ["", "fun lg :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"lg x y = (if x > 1 \\<and> y > 1 \\<and> {u. lgR [x, y, u]} \\<noteq> {} then \n                 Max {u. lgR [x, y, u]}\n              else 0)\""], ["", "declare lg.simps[simp del] lgR.simps[simp del]"], ["", "text \\<open>\n  \\<open>rec_lg\\<close> is the recursive function used to implement \\<open>lg\\<close>.\n\\<close>"], ["", "definition rec_lg :: \"recf\"\n  where\n    \"rec_lg = (let rec_lgR = Cn 3 rec_le\n  [Cn 3 rec_power [id 3 1, id 3 2], id 3 0] in\n  let conR1 = Cn 2 rec_conj [Cn 2 rec_less \n                     [Cn 2 (constn 1) [id 2 0], id 2 0], \n                            Cn 2 rec_less [Cn 2 (constn 1) \n                                 [id 2 0], id 2 1]] in \n  let conR2 = Cn 2 rec_not [conR1] in \n        Cn 2 rec_add [Cn 2 rec_mult \n              [conR1, Cn 2 (rec_maxr rec_lgR)\n                       [id 2 0, id 2 1, id 2 0]], \n                       Cn 2 rec_mult [conR2, Cn 2 (constn 0) \n                                [id 2 0]]])\""], ["", "lemma lg_maxr: \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> \n                      rec_exec rec_lg [x, y] = Maxr lgR [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_lg [x, y] = Maxr lgR [x, y] x", "proof(simp add: rec_exec.simps rec_lg_def Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn 3 rec_le\n                           [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                            recf.id 3 0]))\n                       [x, y, x] =\n                      Maxr lgR [x, y] x", "assume h: \"Suc 0 < x\" \"Suc 0 < y\""], ["proof (state)\nthis:\n  Suc 0 < x\n  Suc 0 < y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn 3 rec_le\n                           [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                            recf.id 3 0]))\n                       [x, y, x] =\n                      Maxr lgR [x, y] x", "let ?rR = \"(Cn 3 rec_le [Cn 3 rec_power\n               [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn 3 rec_le\n                           [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                            recf.id 3 0]))\n                       [x, y, x] =\n                      Maxr lgR [x, y] x", "have \"rec_exec (rec_maxr ?rR) ([x, y] @ [x])\n              = Maxr ((\\<lambda> args. 0 < rec_exec ?rR args)) [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn 3 rec_le\n         [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n     ([x, y] @ [x]) =\n    Maxr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn 3 rec_le\n                [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                 recf.id 3 0])\n              args)\n     [x, y] x", "proof(rule Maxr_lemma)"], ["proof (state)\ngoal (1 subgoal):\n 1. primerec\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n     (Suc (length [x, y]))", "show \"primerec (Cn 3 rec_le [Cn 3 rec_power \n              [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]) (Suc (length [x, y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n     (Suc (length [x, y]))", "apply(auto simp: numeral_3_eq_3)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  primerec\n   (Cn 3 rec_le\n     [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0])\n   (Suc (length [x, y]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn 3 rec_le\n                           [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                            recf.id 3 0]))\n                       [x, y, x] =\n                      Maxr lgR [x, y] x", "moreover"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn 3 rec_le\n                           [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                            recf.id 3 0]))\n                       [x, y, x] =\n                      Maxr lgR [x, y] x", "have \"Maxr lgR [x, y] x = Maxr ((\\<lambda> args. 0 < rec_exec ?rR args)) [x, y] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Maxr lgR [x, y] x =\n    Maxr\n     (\\<lambda>args.\n         0 < rec_exec\n              (Cn 3 rec_le\n                [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                 recf.id 3 0])\n              args)\n     [x, y] x", "apply(simp add: rec_exec.simps power_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Maxr lgR [x, y] x =\n    Maxr (\\<lambda>args. args ! Suc 0 ^ args ! 2 \\<le> args ! 0) [x, y] x", "apply(simp add: Maxr.simps lgR.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Maxr lgR [x, y] x =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec\n                       (rec_maxr\n                         (Cn 3 rec_le\n                           [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n                            recf.id 3 0]))\n                       [x, y, x] =\n                      Maxr lgR [x, y] x", "ultimately"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_maxr\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x\n  Maxr lgR [x, y] x =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x", "show \"rec_exec (rec_maxr ?rR) [x, y, x] = Maxr lgR [x, y] x\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_maxr\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   ([x, y] @ [x]) =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x\n  Maxr lgR [x, y] x =\n  Maxr\n   (\\<lambda>args.\n       0 < rec_exec\n            (Cn 3 rec_le\n              [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2],\n               recf.id 3 0])\n            args)\n   [x, y] x\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_maxr\n       (Cn 3 rec_le\n         [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n     [x, y, x] =\n    Maxr lgR [x, y] x", "by simp"], ["proof (state)\nthis:\n  rec_exec\n   (rec_maxr\n     (Cn 3 rec_le\n       [Cn 3 rec_power [recf.id 3 (Suc 0), recf.id 3 2], recf.id 3 0]))\n   [x, y, x] =\n  Maxr lgR [x, y] x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lgR_ok: \"\\<lbrakk>Suc 0 < y; lgR [x, y, xa]\\<rbrakk> \\<Longrightarrow> xa \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < y; lgR [x, y, xa]\\<rbrakk> \\<Longrightarrow> xa \\<le> x", "apply(auto simp add: lgR.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < y; y ^ xa \\<le> x\\<rbrakk> \\<Longrightarrow> xa \\<le> x", "apply(subgoal_tac \"y^xa > xa\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < y; y ^ xa \\<le> x\\<rbrakk>\n    \\<Longrightarrow> xa < y ^ xa", "apply(erule x_less_exp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lgR_set_strengthen[simp]: \"\\<lbrakk>Suc 0 < x; Suc 0 < y; lgR [x, y, xa]\\<rbrakk> \\<Longrightarrow>\n           {u. lgR [x, y, u]} =  {ya. ya \\<le> x \\<and> lgR [x, y, ya]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y; lgR [x, y, xa]\\<rbrakk>\n    \\<Longrightarrow> {u. lgR [x, y, u]} =\n                      {ya. ya \\<le> x \\<and> lgR [x, y, ya]}", "apply(rule_tac Collect_cong, auto simp:lgR_ok)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma maxr_lg: \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> Maxr lgR [x, y] x = lg x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> Maxr lgR [x, y] x = lg x y", "apply(auto simp add: lg.simps Maxr.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < y;\n        \\<forall>xa\\<le>x. \\<not> lgR [x, y, xa]; lgR [x, y, xa]\\<rbrakk>\n       \\<Longrightarrow> Max {ya. ya \\<le> x \\<and> lgR [x, y, ya]} = 0", "using lgR_ok"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc 0 < ?y; lgR [?x, ?y, ?xa]\\<rbrakk>\n  \\<Longrightarrow> ?xa \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < y;\n        \\<forall>xa\\<le>x. \\<not> lgR [x, y, xa]; lgR [x, y, xa]\\<rbrakk>\n       \\<Longrightarrow> Max {ya. ya \\<le> x \\<and> lgR [x, y, ya]} = 0", "by blast"], ["", "lemma lg_lemma': \"\\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk> \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; Suc 0 < y\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y", "apply(simp add: maxr_lg lg_maxr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lg_lemma'': \"\\<not> Suc 0 < x \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < x \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y", "apply(simp add: rec_exec.simps rec_lg_def Let_def lg.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lg_lemma''': \"\\<not> Suc 0 < y \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < y \\<Longrightarrow> rec_exec rec_lg [x, y] = lg x y", "apply(simp add: rec_exec.simps rec_lg_def Let_def lg.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_lg\\<close>.\n\\<close>"], ["", "lemma lg_lemma: \"rec_exec rec_lg [x, y] = lg x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_lg [x, y] = lg x y", "apply(cases \"Suc 0 < x \\<and> Suc 0 < y\", auto simp: \n      lg_lemma' lg_lemma'' lg_lemma''')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  \\<open>Entry sr i\\<close> returns the \\<open>i\\<close>-th entry of a list of natural \n  numbers encoded by number \\<open>sr\\<close> using Godel's coding.\n\\<close>"], ["", "fun Entry :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"Entry sr i = lo sr (Pi (Suc i))\""], ["", "text \\<open>\n  \\<open>rec_entry\\<close> is the recursive function used to implement\n  \\<open>Entry\\<close>.\n\\<close>"], ["", "definition rec_entry:: \"recf\"\n  where\n    \"rec_entry = Cn 2 rec_lo [id 2 0, Cn 2 rec_pi [Cn 2 s [id 2 1]]]\""], ["", "declare Pi.simps[simp del]"], ["", "text \\<open>\n  The correctness of \\<open>rec_entry\\<close>.\n\\<close>"], ["", "lemma entry_lemma: \"rec_exec rec_entry [str, i] = Entry str i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_entry [str, i] = Entry str i", "by(simp add: rec_entry_def  rec_exec.simps lo_lemma pi_lemma)"], ["", "subsection \\<open>The construction of F\\<close>"], ["", "text \\<open>\n  Using the auxilliary functions obtained in last section, \n  we are going to contruct the function \\<open>F\\<close>, \n  which is an interpreter of Turing Machines.\n\\<close>"], ["", "fun listsum2 :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"listsum2 xs 0 = 0\"\n  | \"listsum2 xs (Suc n) = listsum2 xs n + xs ! n\""], ["", "fun rec_listsum2 :: \"nat \\<Rightarrow> nat \\<Rightarrow> recf\"\n  where\n    \"rec_listsum2 vl 0 = Cn vl z [id vl 0]\"\n  | \"rec_listsum2 vl (Suc n) = Cn vl rec_add [rec_listsum2 vl n, id vl n]\""], ["", "declare listsum2.simps[simp del] rec_listsum2.simps[simp del]"], ["", "lemma listsum2_lemma: \"\\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk> \\<Longrightarrow> \n      rec_exec (rec_listsum2 vl n) xs = listsum2 xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_listsum2 vl n) xs = listsum2 xs n", "apply(induct n, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs = vl \\<Longrightarrow>\n    rec_exec (rec_listsum2 vl 0) xs = listsum2 xs 0\n 2. \\<And>n.\n       \\<lbrakk>rec_exec (rec_listsum2 vl n) xs = listsum2 xs n;\n        length xs = vl; Suc n \\<le> vl\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_listsum2 vl (Suc n)) xs =\n                         listsum2 xs (Suc n)", "apply(simp_all add: rec_exec.simps rec_listsum2.simps listsum2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun strt' :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"strt' xs 0 = 0\"\n  | \"strt' xs (Suc n) = (let dbound = listsum2 xs n + n in \n                       strt' xs n + (2^(xs ! n + dbound) - 2^dbound))\""], ["", "fun rec_strt' :: \"nat \\<Rightarrow> nat \\<Rightarrow> recf\"\n  where\n    \"rec_strt' vl 0 = Cn vl z [id vl 0]\"\n  | \"rec_strt' vl (Suc n) = (let rec_dbound =\n  Cn vl rec_add [rec_listsum2 vl n, Cn vl (constn n) [id vl 0]]\n  in Cn vl rec_add [rec_strt' vl n, Cn vl rec_minus \n  [Cn vl rec_power [Cn vl (constn 2) [id vl 0], Cn vl rec_add\n  [id vl (n), rec_dbound]], \n  Cn vl rec_power [Cn vl (constn 2) [id vl 0], rec_dbound]]])\""], ["", "declare strt'.simps[simp del] rec_strt'.simps[simp del]"], ["", "lemma strt'_lemma: \"\\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk> \\<Longrightarrow> \n  rec_exec (rec_strt' vl n) xs = strt' xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_strt' vl n) xs = strt' xs n", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length xs = vl; 0 \\<le> vl\\<rbrakk>\n    \\<Longrightarrow> rec_exec (rec_strt' vl 0) xs = strt' xs 0\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>length xs = vl; n \\<le> vl\\<rbrakk>\n                \\<Longrightarrow> rec_exec (rec_strt' vl n) xs = strt' xs n;\n        length xs = vl; Suc n \\<le> vl\\<rbrakk>\n       \\<Longrightarrow> rec_exec (rec_strt' vl (Suc n)) xs =\n                         strt' xs (Suc n)", "apply(simp_all add: rec_exec.simps rec_strt'.simps strt'.simps\n      Let_def power_lemma listsum2_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  \\<open>strt\\<close> corresponds to the \\<open>strt\\<close> function on page 90 of B book, but \n  this definition generalises the original one to deal with multiple input arguments.\n\\<close>"], ["", "fun strt :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"strt xs = (let ys = map Suc xs in \n              strt' ys (length ys))\""], ["", "fun rec_map :: \"recf \\<Rightarrow> nat \\<Rightarrow> recf list\"\n  where\n    \"rec_map rf vl = map (\\<lambda> i. Cn vl rf [id vl i]) [0..<vl]\""], ["", "text \\<open>\n  \\<open>rec_strt\\<close> is the recursive function used to implement \\<open>strt\\<close>.\n\\<close>"], ["", "fun rec_strt :: \"nat \\<Rightarrow> recf\"\n  where\n    \"rec_strt vl = Cn vl (rec_strt' vl vl) (rec_map s vl)\""], ["", "lemma map_s_lemma: \"length xs = vl \\<Longrightarrow> \n  map ((\\<lambda>a. rec_exec a xs) \\<circ> (\\<lambda>i. Cn vl s [recf.id vl i]))\n  [0..<vl]\n        = map Suc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = vl \\<Longrightarrow>\n    map ((\\<lambda>a. rec_exec a xs) \\<circ>\n         (\\<lambda>i. Cn vl s [recf.id vl i]))\n     [0..<vl] =\n    map Suc xs", "apply(induct vl arbitrary: xs, simp, auto simp: rec_exec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                              (\\<lambda>i.\n                                  Cn (Suc vl) s [recf.id (Suc vl) i]))\n                          [0..<vl] @\n                         [Suc (xs ! vl)] =\n                         map Suc xs", "apply(rename_tac vl xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                              (\\<lambda>i.\n                                  Cn (Suc vl) s [recf.id (Suc vl) i]))\n                          [0..<vl] @\n                         [Suc (xs ! vl)] =\n                         map Suc xs", "apply(subgoal_tac \"\\<exists> ys y. xs = ys @ [y]\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       (\\<And>xs.\n           length xs = length ys \\<Longrightarrow>\n           map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n            [0..<length ys] =\n           map Suc xs) \\<Longrightarrow>\n       map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n            (\\<lambda>i.\n                Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n        [0..<length ys] =\n       map Suc ys\n 2. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       (\\<And>xs.\n           length xs = length ys \\<Longrightarrow>\n           map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n            [0..<length ys] =\n           map Suc xs) \\<Longrightarrow>\n       map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n            (\\<lambda>i.\n                Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n        [0..<length ys] =\n       map Suc ys\n 2. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "fix ys y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       (\\<And>xs.\n           length xs = length ys \\<Longrightarrow>\n           map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n            [0..<length ys] =\n           map Suc xs) \\<Longrightarrow>\n       map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n            (\\<lambda>i.\n                Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n        [0..<length ys] =\n       map Suc ys\n 2. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "assume ind: \"\\<And>xs. length xs = length (ys::nat list) \\<Longrightarrow>\n      map ((\\<lambda>a. rec_exec a xs) \\<circ> (\\<lambda>i. Cn (length ys) s \n        [recf.id (length ys) (i)])) [0..<length ys] = map Suc xs\""], ["proof (state)\nthis:\n  length ?xs = length ys \\<Longrightarrow>\n  map ((\\<lambda>a. rec_exec a ?xs) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys] =\n  map Suc ?xs\n\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       (\\<And>xs.\n           length xs = length ys \\<Longrightarrow>\n           map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n            [0..<length ys] =\n           map Suc xs) \\<Longrightarrow>\n       map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n            (\\<lambda>i.\n                Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n        [0..<length ys] =\n       map Suc ys\n 2. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "show\n    \"map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ> (\\<lambda>i. Cn (Suc (length ys)) s \n  [recf.id (Suc (length ys)) (i)])) [0..<length ys] = map Suc ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map Suc ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map Suc ys", "have \"map ((\\<lambda>a. rec_exec a ys) \\<circ> (\\<lambda>i. Cn (length ys) s\n        [recf.id (length ys) (i)])) [0..<length ys] = map Suc ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a ys) \\<circ>\n         (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n     [0..<length ys] =\n    map Suc ys", "apply(rule_tac ind, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys] =\n  map Suc ys\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map Suc ys", "moreover"], ["proof (state)\nthis:\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys] =\n  map Suc ys\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map Suc ys", "have\n      \"map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ> (\\<lambda>i. Cn (Suc (length ys)) s\n           [recf.id (Suc (length ys)) (i)])) [0..<length ys]\n         = map ((\\<lambda>a. rec_exec a ys) \\<circ> (\\<lambda>i. Cn (length ys) s \n                 [recf.id (length ys) (i)])) [0..<length ys]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map ((\\<lambda>a. rec_exec a ys) \\<circ>\n         (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n     [0..<length ys]", "apply(rule_tac map_ext, auto simp: rec_exec.simps nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n       (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n   [0..<length ys] =\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys]\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map Suc ys", "ultimately"], ["proof (chain)\npicking this:\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys] =\n  map Suc ys\n  map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n       (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n   [0..<length ys] =\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys]", "show \"?thesis\""], ["proof (prove)\nusing this:\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys] =\n  map Suc ys\n  map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n       (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n   [0..<length ys] =\n  map ((\\<lambda>a. rec_exec a ys) \\<circ>\n       (\\<lambda>i. Cn (length ys) s [recf.id (length ys) i]))\n   [0..<length ys]\n\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n         (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n     [0..<length ys] =\n    map Suc ys", "by simp"], ["proof (state)\nthis:\n  map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n       (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n   [0..<length ys] =\n  map Suc ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map ((\\<lambda>a. rec_exec a (ys @ [y])) \\<circ>\n       (\\<lambda>i. Cn (Suc (length ys)) s [recf.id (Suc (length ys)) i]))\n   [0..<length ys] =\n  map Suc ys\n\ngoal (1 subgoal):\n 1. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "fix vl xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "assume \"length xs = Suc vl\""], ["proof (state)\nthis:\n  length xs = Suc vl\n\ngoal (1 subgoal):\n 1. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = vl \\<Longrightarrow>\n                   map ((\\<lambda>a. rec_exec a xs) \\<circ>\n                        (\\<lambda>i. Cn vl s [recf.id vl i]))\n                    [0..<vl] =\n                   map Suc xs;\n        length xs = Suc vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "thus \"\\<exists>ys y. xs = ys @ [y]\""], ["proof (prove)\nusing this:\n  length xs = Suc vl\n\ngoal (1 subgoal):\n 1. \\<exists>ys y. xs = ys @ [y]", "apply(rule_tac x = \"butlast xs\" in exI, rule_tac x = \"last xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs = Suc vl; length xs = Suc vl\\<rbrakk>\n    \\<Longrightarrow> xs = butlast xs @ [last xs]", "apply(subgoal_tac \"xs \\<noteq> []\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ys y. xs = ys @ [y]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>rec_strt\\<close>.\n\\<close>"], ["", "lemma strt_lemma: \"length xs = vl \\<Longrightarrow> \n  rec_exec (rec_strt vl) xs = strt xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = vl \\<Longrightarrow> rec_exec (rec_strt vl) xs = strt xs", "apply(simp add: strt.simps rec_exec.simps strt'_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = vl \\<Longrightarrow>\n    strt'\n     (map ((\\<lambda>a. rec_exec a xs) \\<circ>\n           (\\<lambda>i. Cn vl s [recf.id vl i]))\n       [0..<vl])\n     vl =\n    strt' (map Suc xs) vl", "apply(subgoal_tac \"(map ((\\<lambda>a. rec_exec a xs) \\<circ> (\\<lambda>i. Cn vl s [recf.id vl (i)])) [0..<vl])\n                  = map Suc xs\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vl = length xs \\<Longrightarrow>\n    map ((\\<lambda>a. rec_exec a xs) \\<circ>\n         (\\<lambda>i. Cn (length xs) s [recf.id (length xs) i]))\n     [0..<length xs] =\n    map Suc xs", "apply(rule map_s_lemma, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The \\<open>scan\\<close> function on page 90 of B book.\n\\<close>"], ["", "fun scan :: \"nat \\<Rightarrow> nat\"\n  where\n    \"scan r = r mod 2\""], ["", "text \\<open>\n  \\<open>rec_scan\\<close> is the implemention of \\<open>scan\\<close>.\n\\<close>"], ["", "definition rec_scan :: \"recf\"\n  where \"rec_scan = Cn 1 rec_mod [id 1 0, constn 2]\""], ["", "text \\<open>\n  The correctness of \\<open>scan\\<close>.\n\\<close>"], ["", "lemma scan_lemma: \"rec_exec rec_scan [r] = r mod 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_scan [r] = r mod 2", "by(simp add: rec_exec.simps rec_scan_def mod_lemma)"], ["", "fun newleft0 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newleft0 [p, r] = p\""], ["", "definition rec_newleft0 :: \"recf\"\n  where\n    \"rec_newleft0 = id 2 0\""], ["", "fun newrgt0 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newrgt0 [p, r] = r - scan r\""], ["", "definition rec_newrgt0 :: \"recf\"\n  where\n    \"rec_newrgt0 = Cn 2 rec_minus [id 2 1, Cn 2 rec_scan [id 2 1]]\""], ["", "(*newleft1, newrgt1: left rgt number after execute on step*)"], ["", "fun newleft1 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newleft1 [p, r] = p\""], ["", "definition rec_newleft1 :: \"recf\"\n  where\n    \"rec_newleft1 = id 2 0\""], ["", "fun newrgt1 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newrgt1 [p, r] = r + 1 - scan r\""], ["", "definition rec_newrgt1 :: \"recf\"\n  where\n    \"rec_newrgt1 = \n  Cn 2 rec_minus [Cn 2 rec_add [id 2 1, Cn 2 (constn 1) [id 2 0]], \n                  Cn 2 rec_scan [id 2 1]]\""], ["", "fun newleft2 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newleft2 [p, r] = p div 2\""], ["", "definition rec_newleft2 :: \"recf\" \n  where\n    \"rec_newleft2 = Cn 2 rec_quo [id 2 0, Cn 2 (constn 2) [id 2 0]]\""], ["", "fun newrgt2 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newrgt2 [p, r] = 2 * r + p mod 2\""], ["", "definition rec_newrgt2 :: \"recf\"\n  where\n    \"rec_newrgt2 =\n    Cn 2 rec_add [Cn 2 rec_mult [Cn 2 (constn 2) [id 2 0], id 2 1],                     \n                 Cn 2 rec_mod [id 2 0, Cn 2 (constn 2) [id 2 0]]]\""], ["", "fun newleft3 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newleft3 [p, r] = 2 * p + r mod 2\""], ["", "definition rec_newleft3 :: \"recf\"\n  where\n    \"rec_newleft3 = \n  Cn 2 rec_add [Cn 2 rec_mult [Cn 2 (constn 2) [id 2 0], id 2 0], \n                Cn 2 rec_mod [id 2 1, Cn 2 (constn 2) [id 2 0]]]\""], ["", "fun newrgt3 :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"newrgt3 [p, r] = r div 2\""], ["", "definition rec_newrgt3 :: \"recf\"\n  where\n    \"rec_newrgt3 = Cn 2 rec_quo [id 2 1, Cn 2 (constn 2) [id 2 0]]\""], ["", "text \\<open>\n  The \\<open>new_left\\<close> function on page 91 of B book.\n\\<close>"], ["", "fun newleft :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"newleft p r a = (if a = 0 \\<or> a = 1 then newleft0 [p, r] \n                    else if a = 2 then newleft2 [p, r]\n                    else if a = 3 then newleft3 [p, r]\n                    else p)\""], ["", "text \\<open>\n  \\<open>rec_newleft\\<close> is the recursive function used to \n  implement \\<open>newleft\\<close>.\n\\<close>"], ["", "definition rec_newleft :: \"recf\" \n  where\n    \"rec_newleft =\n  (let g0 = \n      Cn 3 rec_newleft0 [id 3 0, id 3 1] in \n  let g1 = Cn 3 rec_newleft2 [id 3 0, id 3 1] in \n  let g2 = Cn 3 rec_newleft3 [id 3 0, id 3 1] in \n  let g3 = id 3 0 in\n  let r0 = Cn 3 rec_disj\n          [Cn 3 rec_eq [id 3 2, Cn 3 (constn 0) [id 3 0]],\n           Cn 3 rec_eq [id 3 2, Cn 3 (constn 1) [id 3 0]]] in \n  let r1 = Cn 3 rec_eq [id 3 2, Cn 3 (constn 2) [id 3 0]] in \n  let r2 = Cn 3 rec_eq [id 3 2, Cn 3 (constn 3) [id 3 0]] in\n  let r3 = Cn 3 rec_less [Cn 3 (constn 3) [id 3 0], id 3 2] in \n  let gs = [g0, g1, g2, g3] in \n  let rs = [r0, r1, r2, r3] in \n  rec_embranch (zip gs rs))\""], ["", "declare newleft.simps[simp del]"], ["", "lemma Suc_Suc_Suc_Suc_induct: \n  \"\\<lbrakk>i < Suc (Suc (Suc (Suc 0))); i = 0 \\<Longrightarrow>  P i;\n    i = 1 \\<Longrightarrow> P i; i =2 \\<Longrightarrow> P i; \n    i =3 \\<Longrightarrow> P i\\<rbrakk> \\<Longrightarrow> P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc (Suc (Suc (Suc 0))); i = 0 \\<Longrightarrow> P i;\n     i = 1 \\<Longrightarrow> P i; i = 2 \\<Longrightarrow> P i;\n     i = 3 \\<Longrightarrow> P i\\<rbrakk>\n    \\<Longrightarrow> P i", "apply(cases i, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc 0))); i = 0 \\<Longrightarrow> P i;\n        i = 1 \\<Longrightarrow> P i; i = 2 \\<Longrightarrow> P i;\n        i = 3 \\<Longrightarrow> P i; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> P i", "apply(cases \"i - 1\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc 0))); i = 0 \\<Longrightarrow> P i;\n        i = 1 \\<Longrightarrow> P i; i = 2 \\<Longrightarrow> P i;\n        i = 3 \\<Longrightarrow> P i; i = Suc nat; i - 1 = Suc nata\\<rbrakk>\n       \\<Longrightarrow> P i", "apply(cases \"i - 1 - 1\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata natb.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc 0))); i = 0 \\<Longrightarrow> P i;\n        i = 1 \\<Longrightarrow> P i; i = 2 \\<Longrightarrow> P i;\n        i = 3 \\<Longrightarrow> P i; i = Suc nat; i - 1 = Suc nata;\n        i - 1 - 1 = Suc natb\\<rbrakk>\n       \\<Longrightarrow> P i", "by(cases \"i - 1 - 1 - 1\", auto simp:numeral)"], ["", "declare quo_lemma2[simp] mod_lemma[simp]"], ["", "text \\<open>\n  The correctness of \\<open>rec_newleft\\<close>.\n\\<close>"], ["", "lemma newleft_lemma: \n  \"rec_exec rec_newleft [p, r, a] = newleft p r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_newleft [p, r, a] = newleft p r a", "proof(simp only: rec_newleft_def Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "let ?rgs = \"[Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1], Cn 3 rec_newleft2 \n       [recf.id 3 0, recf.id 3 1], Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "let ?rrs = \n    \"[Cn 3 rec_disj [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) \n     [recf.id 3 0]], Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]], \n     Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n     Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n     Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "have k1: \"rec_exec (rec_embranch (zip ?rgs ?rrs)) [p, r, a]\n                         = Embranch (zip (map rec_exec ?rgs) (map (\\<lambda>r args. 0 < rec_exec r args) ?rrs)) [p, r, a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    Embranch\n     (zip (map rec_exec\n            [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n       (map (\\<lambda>r args. 0 < rec_exec r args)\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a]", "apply(rule_tac embranch_lemma )"], ["proof (prove)\ngoal (5 subgoals):\n 1. length\n     [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n      Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n      Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0] =\n    ?n\n 2. length\n     [Cn 3 rec_disj\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n      Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n      Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n      Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]] =\n    ?n\n 3. 0 < ?n\n 4. \\<exists>i<?n.\n       rec_exec\n        ([Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]] !\n         i)\n        [p, r, a] =\n       1 \\<and>\n       (\\<forall>j<?n.\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n              Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n              Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n              Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]] !\n             j)\n            [p, r, a] =\n           0)\n 5. list_all (\\<lambda>rf. primerec rf (length [p, r, a]))\n     ([Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n       Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n       Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0] @\n      [Cn 3 rec_disj\n        [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n         Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n       Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n       Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n       Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]])", "apply(auto simp: numeral_3_eq_3 numeral_2_eq_2 rec_newleft0_def \n        rec_newleft1_def rec_newleft2_def rec_newleft3_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<Suc (Suc (Suc (Suc 0))).\n       rec_exec\n        ([Cn (Suc (Suc (Suc 0))) rec_disj\n           [Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn 0)\n               [recf.id (Suc (Suc (Suc 0))) 0]],\n            Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n               [recf.id (Suc (Suc (Suc 0))) 0]]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_less\n           [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n         i)\n        [p, r, a] =\n       Suc 0 \\<and>\n       (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn (Suc (Suc (Suc 0))) rec_disj\n               [Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                   [recf.id (Suc (Suc (Suc 0))) 0]]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_less\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n             j)\n            [p, r, a] =\n           0)", "apply(cases \"a = 0 \\<or> a = 1\", rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = 0 \\<or> a = 1 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc 0))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_disj\n        [Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0]],\n         Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n            [recf.id (Suc (Suc (Suc 0))) 0]]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_disj\n            [Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) 0]],\n             Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                [recf.id (Suc (Suc (Suc 0))) 0]]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)\n 2. \\<not> (a = 0 \\<or> a = 1) \\<Longrightarrow>\n    \\<exists>i<Suc (Suc (Suc (Suc 0))).\n       rec_exec\n        ([Cn (Suc (Suc (Suc 0))) rec_disj\n           [Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn 0)\n               [recf.id (Suc (Suc (Suc 0))) 0]],\n            Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n               [recf.id (Suc (Suc (Suc 0))) 0]]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_less\n           [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n         i)\n        [p, r, a] =\n       Suc 0 \\<and>\n       (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn (Suc (Suc (Suc 0))) rec_disj\n               [Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                   [recf.id (Suc (Suc (Suc 0))) 0]]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_less\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n             j)\n            [p, r, a] =\n           0)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> (a = 0 \\<or> a = 1) \\<Longrightarrow>\n    \\<exists>i<Suc (Suc (Suc (Suc 0))).\n       rec_exec\n        ([Cn (Suc (Suc (Suc 0))) rec_disj\n           [Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn 0)\n               [recf.id (Suc (Suc (Suc 0))) 0]],\n            Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n               [recf.id (Suc (Suc (Suc 0))) 0]]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_less\n           [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n         i)\n        [p, r, a] =\n       Suc 0 \\<and>\n       (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn (Suc (Suc (Suc 0))) rec_disj\n               [Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                   [recf.id (Suc (Suc (Suc 0))) 0]]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_less\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n             j)\n            [p, r, a] =\n           0)\n 2. a = 0 \\<or> a = 1 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc 0))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_disj\n        [Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0]],\n         Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n            [recf.id (Suc (Suc (Suc 0))) 0]]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_disj\n            [Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) 0]],\n             Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                [recf.id (Suc (Suc (Suc 0))) 0]]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a = 2\", rule_tac x = \"Suc 0\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a = 2\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc 0))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_disj\n                          [Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn 0)\n                              [recf.id (Suc (Suc (Suc 0))) 0]],\n                           Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                              [recf.id (Suc (Suc (Suc 0))) 0]]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_disj\n                              [Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                                  [recf.id (Suc (Suc (Suc 0))) 0]],\n                               Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                  [recf.id (Suc (Suc (Suc 0))) 0]]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 2. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a \\<noteq> 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc 0))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_disj\n                                 [Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn 0)\n                                     [recf.id (Suc (Suc (Suc 0))) 0]],\n                                  Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                     [recf.id (Suc (Suc (Suc 0))) 0]]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 3. a = 0 \\<or> a = 1 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc 0))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_disj\n        [Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0]],\n         Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n            [recf.id (Suc (Suc (Suc 0))) 0]]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_disj\n            [Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) 0]],\n             Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                [recf.id (Suc (Suc (Suc 0))) 0]]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a \\<noteq> 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc 0))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_disj\n                                 [Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn 0)\n                                     [recf.id (Suc (Suc (Suc 0))) 0]],\n                                  Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                     [recf.id (Suc (Suc (Suc 0))) 0]]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 2. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a = 2\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc 0))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_disj\n                          [Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn 0)\n                              [recf.id (Suc (Suc (Suc 0))) 0]],\n                           Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                              [recf.id (Suc (Suc (Suc 0))) 0]]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_disj\n                              [Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                                  [recf.id (Suc (Suc (Suc 0))) 0]],\n                               Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                  [recf.id (Suc (Suc (Suc 0))) 0]]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 3. a = 0 \\<or> a = 1 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc 0))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_disj\n        [Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0]],\n         Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n            [recf.id (Suc (Suc (Suc 0))) 0]]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_disj\n            [Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) 0]],\n             Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                [recf.id (Suc (Suc (Suc 0))) 0]]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a = 3\", rule_tac x = \"2\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a \\<noteq> 2; a = 3\\<rbrakk>\n    \\<Longrightarrow> 2 < Suc (Suc (Suc (Suc 0))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_disj\n                          [Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn 0)\n                              [recf.id (Suc (Suc (Suc 0))) 0]],\n                           Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                              [recf.id (Suc (Suc (Suc 0))) 0]]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        2)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                          j \\<noteq> 2 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_disj\n                              [Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                                  [recf.id (Suc (Suc (Suc 0))) 0]],\n                               Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                  [recf.id (Suc (Suc (Suc 0))) 0]]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 2. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a \\<noteq> 2; a \\<noteq> 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc 0))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_disj\n                                 [Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn 0)\n                                     [recf.id (Suc (Suc (Suc 0))) 0]],\n                                  Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                     [recf.id (Suc (Suc (Suc 0))) 0]]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 3. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a = 2\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc 0))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_disj\n                          [Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn 0)\n                              [recf.id (Suc (Suc (Suc 0))) 0]],\n                           Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                              [recf.id (Suc (Suc (Suc 0))) 0]]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_disj\n                              [Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                                  [recf.id (Suc (Suc (Suc 0))) 0]],\n                               Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                  [recf.id (Suc (Suc (Suc 0))) 0]]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 4. a = 0 \\<or> a = 1 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc 0))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_disj\n        [Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0]],\n         Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n            [recf.id (Suc (Suc (Suc 0))) 0]]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_disj\n            [Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) 0]],\n             Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                [recf.id (Suc (Suc (Suc 0))) 0]]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a \\<noteq> 2; a \\<noteq> 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc 0))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_disj\n                                 [Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn 0)\n                                     [recf.id (Suc (Suc (Suc 0))) 0]],\n                                  Cn (Suc (Suc (Suc 0))) rec_eq\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                     [recf.id (Suc (Suc (Suc 0))) 0]]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 2. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a \\<noteq> 2; a = 3\\<rbrakk>\n    \\<Longrightarrow> 2 < Suc (Suc (Suc (Suc 0))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_disj\n                          [Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn 0)\n                              [recf.id (Suc (Suc (Suc 0))) 0]],\n                           Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                              [recf.id (Suc (Suc (Suc 0))) 0]]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        2)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                          j \\<noteq> 2 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_disj\n                              [Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                                  [recf.id (Suc (Suc (Suc 0))) 0]],\n                               Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                  [recf.id (Suc (Suc (Suc 0))) 0]]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 3. \\<lbrakk>\\<not> (a = 0 \\<or> a = 1); a = 2\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc 0))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_disj\n                          [Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn 0)\n                              [recf.id (Suc (Suc (Suc 0))) 0]],\n                           Cn (Suc (Suc (Suc 0))) rec_eq\n                            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                              [recf.id (Suc (Suc (Suc 0))) 0]]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_disj\n                              [Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn 0)\n                                  [recf.id (Suc (Suc (Suc 0))) 0]],\n                               Cn (Suc (Suc (Suc 0))) rec_eq\n                                [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                  [recf.id (Suc (Suc (Suc 0))) 0]]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 4. a = 0 \\<or> a = 1 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc 0))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_disj\n        [Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0]],\n         Cn (Suc (Suc (Suc 0))) rec_eq\n          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n            [recf.id (Suc (Suc (Suc 0))) 0]]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc 0))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_disj\n            [Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn 0)\n                [recf.id (Suc (Suc (Suc 0))) 0]],\n             Cn (Suc (Suc (Suc 0))) rec_eq\n              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                [recf.id (Suc (Suc (Suc 0))) 0]]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a > 3\", rule_tac x = \"3\" in exI, auto)"], ["proof (prove)\ngoal (10 subgoals):\n 1. 3 < a \\<Longrightarrow>\n    rec_exec\n     (Cn (Suc (Suc (Suc 0))) rec_less\n       [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n         [recf.id (Suc (Suc (Suc 0))) 0],\n        recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))])\n     [p, r, a] =\n    Suc 0\n 2. \\<And>j.\n       \\<lbrakk>3 < a; j < Suc (Suc (Suc (Suc 0))); j \\<noteq> 3\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, a] =\n                         0\n 3. a = 3 \\<Longrightarrow>\n    rec_exec\n     (Cn (Suc (Suc (Suc 0))) rec_eq\n       [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n        Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n         [recf.id (Suc (Suc (Suc 0))) 0]])\n     [p, r, 3] =\n    Suc 0\n 4. \\<And>j.\n       \\<lbrakk>a = 3; j < Suc (Suc (Suc (Suc 0))); j \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, 3] =\n                         0\n 5. a = 2 \\<Longrightarrow>\n    rec_exec\n     (Cn (Suc (Suc (Suc 0))) rec_eq\n       [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n        Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n         [recf.id (Suc (Suc (Suc 0))) 0]])\n     [p, r, 2] =\n    Suc 0\n 6. \\<And>j.\n       \\<lbrakk>a = 2; j < Suc (Suc (Suc (Suc 0)));\n        j \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, 2] =\n                         0\n 7. a = 0 \\<Longrightarrow>\n    rec_exec\n     (Cn (Suc (Suc (Suc 0))) rec_disj\n       [Cn (Suc (Suc (Suc 0))) rec_eq\n         [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]],\n        Cn (Suc (Suc (Suc 0))) rec_eq\n         [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n          Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n           [recf.id (Suc (Suc (Suc 0))) 0]]])\n     [p, r, 0] =\n    Suc 0\n 8. \\<And>j.\n       \\<lbrakk>a = 0; j < Suc (Suc (Suc (Suc 0))); 0 < j\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           (j - Suc 0))\n                          [p, r, 0] =\n                         0\n 9. a = Suc 0 \\<Longrightarrow>\n    rec_exec\n     (Cn (Suc (Suc (Suc 0))) rec_disj\n       [Cn (Suc (Suc (Suc 0))) rec_eq\n         [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n          Cn (Suc (Suc (Suc 0))) (constn 0)\n           [recf.id (Suc (Suc (Suc 0))) 0]],\n        Cn (Suc (Suc (Suc 0))) rec_eq\n         [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n          Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n           [recf.id (Suc (Suc (Suc 0))) 0]]])\n     [p, r, Suc 0] =\n    Suc 0\n 10. \\<And>j.\n        \\<lbrakk>a = Suc 0; j < Suc (Suc (Suc (Suc 0))); 0 < j\\<rbrakk>\n        \\<Longrightarrow> rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            (j - Suc 0))\n                           [p, r, Suc 0] =\n                          0", "apply(auto simp: rec_exec.simps)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>3 < a; j < Suc (Suc (Suc (Suc 0))); j \\<noteq> 3\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, a] =\n                         0\n 2. \\<And>j.\n       \\<lbrakk>a = 3; j < Suc (Suc (Suc (Suc 0))); j \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, 3] =\n                         0\n 3. \\<And>j.\n       \\<lbrakk>a = 2; j < Suc (Suc (Suc (Suc 0)));\n        j \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_disj\n                             [Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn 0)\n                                 [recf.id (Suc (Suc (Suc 0))) 0]],\n                              Cn (Suc (Suc (Suc 0))) rec_eq\n                               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, 2] =\n                         0\n 4. \\<And>j.\n       \\<lbrakk>a = 0; j < Suc (Suc (Suc (Suc 0))); 0 < j\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           (j - Suc 0))\n                          [p, r, 0] =\n                         0\n 5. \\<And>j.\n       \\<lbrakk>a = Suc 0; j < Suc (Suc (Suc (Suc 0))); 0 < j\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           (j - Suc 0))\n                          [p, r, Suc 0] =\n                         0", "apply(erule_tac [!] Suc_Suc_Suc_Suc_induct, auto simp: rec_exec.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a]\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "have k2: \"Embranch (zip (map rec_exec ?rgs) (map (\\<lambda>r args. 0 < rec_exec r args) ?rrs)) [p, r, a] = newleft p r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Embranch\n     (zip (map rec_exec\n            [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n       (map (\\<lambda>r args. 0 < rec_exec r args)\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "apply(simp add: Embranch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < rec_exec\n          (Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2])\n          [p, r, a] \\<longrightarrow>\n     (0 < rec_exec\n           (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]])\n           [p, r, a] \\<longrightarrow>\n      (0 < rec_exec\n            (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n            [p, r, a] \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a)) \\<and>\n      (rec_exec (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n        [p, r, a] =\n       0 \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a))) \\<and>\n     (rec_exec (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]])\n       [p, r, a] =\n      0 \\<longrightarrow>\n      (0 < rec_exec\n            (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n            [p, r, a] \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a)) \\<and>\n      (rec_exec (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n        [p, r, a] =\n       0 \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (recf.id 3 0) [p, r, a] = newleft p r a)))) \\<and>\n    (rec_exec (Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2])\n      [p, r, a] =\n     0 \\<longrightarrow>\n     (0 < rec_exec\n           (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]])\n           [p, r, a] \\<longrightarrow>\n      (0 < rec_exec\n            (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n            [p, r, a] \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a)) \\<and>\n      (rec_exec (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n        [p, r, a] =\n       0 \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a))) \\<and>\n     (rec_exec (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]])\n       [p, r, a] =\n      0 \\<longrightarrow>\n      (0 < rec_exec\n            (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n            [p, r, a] \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a)) \\<and>\n      (rec_exec (Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]])\n        [p, r, a] =\n       0 \\<longrightarrow>\n       (0 < rec_exec\n             (Cn 3 rec_disj\n               [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n                Cn 3 rec_eq\n                 [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n             [p, r, a] \\<longrightarrow>\n        rec_exec (Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 (Suc 0)])\n         [p, r, a] =\n        newleft p r a) \\<and>\n       (rec_exec\n         (Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn (Suc 0)) [recf.id 3 0]]])\n         [p, r, a] =\n        0 \\<longrightarrow>\n        newleft p r a = 0))))", "apply(simp add: rec_exec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = 0 \\<longrightarrow>\n     rec_exec rec_newleft0 [p, r] = newleft p r 0) \\<and>\n    (0 < a \\<longrightarrow>\n     (a = Suc 0 \\<longrightarrow>\n      rec_exec rec_newleft0 [p, r] = newleft p r (Suc 0)) \\<and>\n     (a \\<noteq> Suc 0 \\<longrightarrow>\n      (a = 2 \\<longrightarrow>\n       rec_exec rec_newleft2 [p, r] = newleft p r 2) \\<and>\n      (a \\<noteq> 2 \\<longrightarrow>\n       (a = 3 \\<longrightarrow>\n        rec_exec rec_newleft3 [p, r] = newleft p r 3) \\<and>\n       (a \\<noteq> 3 \\<longrightarrow> p = newleft p r a))))", "apply(auto simp: newleft.simps rec_newleft0_def rec_exec.simps\n        rec_newleft1_def rec_newleft2_def rec_newleft3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newleft p r a\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "from k1 and k2"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a]\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newleft p r a", "show \n    \"rec_exec (rec_embranch (zip ?rgs ?rrs)) [p, r, a] = newleft p r a\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a]\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newleft p r a\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n         [Cn 3 rec_disj\n           [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n            Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newleft p r a", "by simp"], ["proof (state)\nthis:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newleft0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newleft3 [recf.id 3 0, recf.id 3 1], recf.id 3 0]\n       [Cn 3 rec_disj\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newleft p r a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The \\<open>newrght\\<close> function is one similar to \\<open>newleft\\<close>, but used to \n  compute the right number.\n\\<close>"], ["", "fun newrght :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"newrght p r a  = (if a = 0 then newrgt0 [p, r]\n                    else if a = 1 then newrgt1 [p, r]\n                    else if a = 2 then newrgt2 [p, r]\n                    else if a = 3 then newrgt3 [p, r]\n                    else r)\""], ["", "text \\<open>\n  \\<open>rec_newrght\\<close> is the recursive function used to implement \n  \\<open>newrgth\\<close>.\n\\<close>"], ["", "definition rec_newrght :: \"recf\" \n  where\n    \"rec_newrght =\n  (let g0 = Cn 3 rec_newrgt0 [id 3 0, id 3 1] in \n  let g1 = Cn 3 rec_newrgt1 [id 3 0, id 3 1] in \n  let g2 = Cn 3 rec_newrgt2 [id 3 0, id 3 1] in \n  let g3 = Cn 3 rec_newrgt3 [id 3 0, id 3 1] in\n  let g4 = id 3 1 in \n  let r0 = Cn 3 rec_eq [id 3 2, Cn 3 (constn 0) [id 3 0]] in \n  let r1 = Cn 3 rec_eq [id 3 2, Cn 3 (constn 1) [id 3 0]] in \n  let r2 = Cn 3 rec_eq [id 3 2, Cn 3 (constn 2) [id 3 0]] in\n  let r3 = Cn 3 rec_eq [id 3 2, Cn 3 (constn 3) [id 3 0]] in\n  let r4 = Cn 3 rec_less [Cn 3 (constn 3) [id 3 0], id 3 2] in \n  let gs = [g0, g1, g2, g3, g4] in \n  let rs = [r0, r1, r2, r3, r4] in \n  rec_embranch (zip gs rs))\""], ["", "declare newrght.simps[simp del]"], ["", "lemma numeral_4_eq_4: \"4 = Suc 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 = Suc 3", "by auto"], ["", "lemma Suc_5_induct: \n  \"\\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0)))); i = 0 \\<Longrightarrow> P 0;\n  i = 1 \\<Longrightarrow> P 1; i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3; i = 4 \\<Longrightarrow> P 4\\<rbrakk> \\<Longrightarrow> P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0)))); i = 0 \\<Longrightarrow> P 0;\n     i = 1 \\<Longrightarrow> P 1; i = 2 \\<Longrightarrow> P 2;\n     i = 3 \\<Longrightarrow> P 3; i = 4 \\<Longrightarrow> P 4\\<rbrakk>\n    \\<Longrightarrow> P i", "apply(cases i, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0))));\n        i = 0 \\<Longrightarrow> P 0; i = 1 \\<Longrightarrow> P 1;\n        i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3;\n        i = 4 \\<Longrightarrow> P 4; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> P i", "apply(cases \"i-1\", force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat nata.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0))));\n        i = 0 \\<Longrightarrow> P 0; i = 1 \\<Longrightarrow> P 1;\n        i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3;\n        i = 4 \\<Longrightarrow> P 4; i = Suc nat; i - 1 = Suc nata\\<rbrakk>\n       \\<Longrightarrow> P i", "apply(cases \"i-1-1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0))));\n        i = 0 \\<Longrightarrow> P 0; i = 1 \\<Longrightarrow> P 1;\n        i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3;\n        i = 4 \\<Longrightarrow> P 4; i = Suc nat; i - 1 = Suc nata;\n        i - 1 - 1 = 0\\<rbrakk>\n       \\<Longrightarrow> P i\n 2. \\<And>nat nata natb.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0))));\n        i = 0 \\<Longrightarrow> P 0; i = 1 \\<Longrightarrow> P 1;\n        i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3;\n        i = 4 \\<Longrightarrow> P 4; i = Suc nat; i - 1 = Suc nata;\n        i - 1 - 1 = Suc natb\\<rbrakk>\n       \\<Longrightarrow> P i", "using less_2_cases numeral"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n  2 = Suc 1\n  3 = Suc 2\n  4 = Suc 3\n  5 = Suc 4\n  6 = Suc 5\n  7 = Suc 6\n  8 = Suc 7\n  9 = Suc 8\n  10 = Suc 9\n  11 = Suc 10\n  12 = Suc 11\n\ngoal (2 subgoals):\n 1. \\<And>nat nata.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0))));\n        i = 0 \\<Longrightarrow> P 0; i = 1 \\<Longrightarrow> P 1;\n        i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3;\n        i = 4 \\<Longrightarrow> P 4; i = Suc nat; i - 1 = Suc nata;\n        i - 1 - 1 = 0\\<rbrakk>\n       \\<Longrightarrow> P i\n 2. \\<And>nat nata natb.\n       \\<lbrakk>i < Suc (Suc (Suc (Suc (Suc 0))));\n        i = 0 \\<Longrightarrow> P 0; i = 1 \\<Longrightarrow> P 1;\n        i = 2 \\<Longrightarrow> P 2; i = 3 \\<Longrightarrow> P 3;\n        i = 4 \\<Longrightarrow> P 4; i = Suc nat; i - 1 = Suc nata;\n        i - 1 - 1 = Suc natb\\<rbrakk>\n       \\<Longrightarrow> P i", "by auto"], ["", "lemma primerec_rec_scan_1[intro]: \"primerec rec_scan (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_scan (Suc 0)", "apply(auto simp: rec_scan_def, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_newrght\\<close>.\n\\<close>"], ["", "lemma newrght_lemma: \"rec_exec rec_newrght [p, r, a] = newrght p r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_newrght [p, r, a] = newrght p r a", "proof(simp only: rec_newrght_def Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?gs' = \"[newrgt0, newrgt1, newrgt2, newrgt3, \\<lambda> zs. zs ! 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?r0 = \"\\<lambda> zs. zs ! 2 = 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?r1 = \"\\<lambda> zs. zs ! 2 = 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?r2 = \"\\<lambda> zs. zs ! 2 = 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?r3 = \"\\<lambda> zs. zs ! 2 = 3\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?r4 = \"\\<lambda> zs. zs ! 2 > 3\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?gs = \"map (\\<lambda> g. (\\<lambda> zs. g [zs ! 0, zs ! 1])) ?gs'\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?rs = \"[?r0, ?r1, ?r2, ?r3, ?r4]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?rgs = \n    \"[Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n    Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n     Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1], \n      Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "let ?rrs = \n    \"[Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]], Cn 3 rec_eq [recf.id 3 2, \n    Cn 3 (constn 1) [recf.id 3 0]], Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n     Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]], \n       Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "have k1: \"rec_exec (rec_embranch (zip ?rgs ?rrs)) [p, r, a]\n    = Embranch (zip (map rec_exec ?rgs) (map (\\<lambda>r args. 0 < rec_exec r args) ?rrs)) [p, r, a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    Embranch\n     (zip (map rec_exec\n            [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n       (map (\\<lambda>r args. 0 < rec_exec r args)\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a]", "apply(rule_tac embranch_lemma)"], ["proof (prove)\ngoal (5 subgoals):\n 1. length\n     [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n      Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n      Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n      Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1] =\n    ?n\n 2. length\n     [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n      Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n      Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n      Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n      Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]] =\n    ?n\n 3. 0 < ?n\n 4. \\<exists>i<?n.\n       rec_exec\n        ([Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]] !\n         i)\n        [p, r, a] =\n       1 \\<and>\n       (\\<forall>j<?n.\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n              Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n              Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n              Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n              Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]] !\n             j)\n            [p, r, a] =\n           0)\n 5. list_all (\\<lambda>rf. primerec rf (length [p, r, a]))\n     ([Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n       Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n       Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n       Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1] @\n      [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n       Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n       Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n       Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n       Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]])", "apply(auto simp: numeral_3_eq_3 numeral_2_eq_2 rec_newrgt0_def \n        rec_newrgt1_def rec_newrgt2_def rec_newrgt3_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n       rec_exec\n        ([Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_less\n           [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n         i)\n        [p, r, a] =\n       Suc 0 \\<and>\n       (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_less\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n             j)\n            [p, r, a] =\n           0)", "apply(cases \"a = 0\", rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n       rec_exec\n        ([Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_less\n           [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n         i)\n        [p, r, a] =\n       Suc 0 \\<and>\n       (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_less\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n             j)\n            [p, r, a] =\n           0)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n       rec_exec\n        ([Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0]],\n          Cn (Suc (Suc (Suc 0))) rec_less\n           [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n         i)\n        [p, r, a] =\n       Suc 0 \\<and>\n       (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n           j \\<noteq> i \\<longrightarrow>\n           rec_exec\n            ([Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn 0)\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]],\n              Cn (Suc (Suc (Suc 0))) rec_less\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n             j)\n            [p, r, a] =\n           0)\n 2. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a = 1\", rule_tac x = \"Suc 0\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; a = 1\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 2. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 3. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 2. \\<lbrakk>a \\<noteq> 0; a = 1\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 3. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a = 2\", rule_tac x = \"2\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a = 2\\<rbrakk>\n    \\<Longrightarrow> 2 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        2)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> 2 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 2. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a \\<noteq> 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 3. \\<lbrakk>a \\<noteq> 0; a = 1\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 4. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a \\<noteq> 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 2. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a = 2\\<rbrakk>\n    \\<Longrightarrow> 2 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        2)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> 2 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 3. \\<lbrakk>a \\<noteq> 0; a = 1\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 4. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a = 3\", rule_tac x = \"3\" in exI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a \\<noteq> 2; a = 3\\<rbrakk>\n    \\<Longrightarrow> 3 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        3)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> 3 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 2. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a \\<noteq> 2; a \\<noteq> 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 3. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a = 2\\<rbrakk>\n    \\<Longrightarrow> 2 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        2)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> 2 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 4. \\<lbrakk>a \\<noteq> 0; a = 1\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 5. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "prefer 2"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a \\<noteq> 2; a \\<noteq> 3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<Suc (Suc (Suc (Suc (Suc 0)))).\n                         rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           i)\n                          [p, r, a] =\n                         Suc 0 \\<and>\n                         (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                             j \\<noteq> i \\<longrightarrow>\n                             rec_exec\n                              ([Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc 0)))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                                  Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0]],\n                                Cn (Suc (Suc (Suc 0))) rec_less\n                                 [Cn (Suc (Suc (Suc 0)))\n                                   (constn (Suc (Suc (Suc 0))))\n                                   [recf.id (Suc (Suc (Suc 0))) 0],\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]] !\n                               j)\n                              [p, r, a] =\n                             0)\n 2. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a \\<noteq> 2; a = 3\\<rbrakk>\n    \\<Longrightarrow> 3 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        3)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> 3 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 3. \\<lbrakk>a \\<noteq> 0; a \\<noteq> 1; a = 2\\<rbrakk>\n    \\<Longrightarrow> 2 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        2)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> 2 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 4. \\<lbrakk>a \\<noteq> 0; a = 1\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n                      rec_exec\n                       ([Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn 0)\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_eq\n                          [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                           Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0]],\n                         Cn (Suc (Suc (Suc 0))) rec_less\n                          [Cn (Suc (Suc (Suc 0)))\n                            (constn (Suc (Suc (Suc 0))))\n                            [recf.id (Suc (Suc (Suc 0))) 0],\n                           recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                        Suc 0)\n                       [p, r, a] =\n                      Suc 0 \\<and>\n                      (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n                          j \\<noteq> Suc 0 \\<longrightarrow>\n                          rec_exec\n                           ([Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn 0)\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_eq\n                              [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                               Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0]],\n                             Cn (Suc (Suc (Suc 0))) rec_less\n                              [Cn (Suc (Suc (Suc 0)))\n                                (constn (Suc (Suc (Suc 0))))\n                                [recf.id (Suc (Suc (Suc 0))) 0],\n                               recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                            j)\n                           [p, r, a] =\n                          0)\n 5. a = 0 \\<Longrightarrow>\n    0 < Suc (Suc (Suc (Suc (Suc 0)))) \\<and>\n    rec_exec\n     ([Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn 0) [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_eq\n        [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n         Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0]],\n       Cn (Suc (Suc (Suc 0))) rec_less\n        [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n          [recf.id (Suc (Suc (Suc 0))) 0],\n         recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n      0)\n     [p, r, a] =\n    Suc 0 \\<and>\n    (\\<forall>j<Suc (Suc (Suc (Suc (Suc 0)))).\n        j \\<noteq> 0 \\<longrightarrow>\n        rec_exec\n         ([Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n             Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0]],\n           Cn (Suc (Suc (Suc 0))) rec_less\n            [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n              [recf.id (Suc (Suc (Suc 0))) 0],\n             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n          j)\n         [p, r, a] =\n        0)", "apply(cases \"a > 3\", rule_tac x = \"4\" in exI, auto simp: rec_exec.simps)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>3 < a; j < Suc (Suc (Suc (Suc (Suc 0))));\n        j \\<noteq> 4\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, a] =\n                         0\n 2. \\<And>j.\n       \\<lbrakk>a = 3; j < Suc (Suc (Suc (Suc (Suc 0))));\n        j \\<noteq> 3\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, 3] =\n                         0\n 3. \\<And>j.\n       \\<lbrakk>a = 2; j < Suc (Suc (Suc (Suc (Suc 0))));\n        j \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, 2] =\n                         0\n 4. \\<And>j.\n       \\<lbrakk>a = Suc 0; j < Suc (Suc (Suc (Suc (Suc 0))));\n        j \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn 0)\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           j)\n                          [p, r, Suc 0] =\n                         0\n 5. \\<And>j.\n       \\<lbrakk>a = 0; j < Suc (Suc (Suc (Suc (Suc 0)))); 0 < j\\<rbrakk>\n       \\<Longrightarrow> rec_exec\n                          ([Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_eq\n                             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                              Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0]],\n                            Cn (Suc (Suc (Suc 0))) rec_less\n                             [Cn (Suc (Suc (Suc 0)))\n                               (constn (Suc (Suc (Suc 0))))\n                               [recf.id (Suc (Suc (Suc 0))) 0],\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]] !\n                           (j - Suc 0))\n                          [p, r, 0] =\n                         0", "apply(erule_tac [!] Suc_5_induct, auto simp: rec_exec.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a]\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "have k2: \"Embranch (zip (map rec_exec ?rgs)\n    (map (\\<lambda>r args. 0 < rec_exec r args) ?rrs)) [p, r, a] = newrght p r a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Embranch\n     (zip (map rec_exec\n            [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n       (map (\\<lambda>r args. 0 < rec_exec r args)\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "apply(auto simp:Embranch.simps rec_exec.simps)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 3 < a \\<Longrightarrow> r = newrght p r a\n 2. a = 3 \\<Longrightarrow> rec_exec rec_newrgt3 [p, r] = newrght p r 3\n 3. a = 2 \\<Longrightarrow> rec_exec rec_newrgt2 [p, r] = newrght p r 2\n 4. \\<lbrakk>a = Suc 0;\n     rec_exec rec_newrgt1 [p, r] \\<noteq> newrght p r (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False\n 5. \\<lbrakk>\\<not> 3 < a; a \\<noteq> 3; a \\<noteq> 2;\n     a \\<noteq> Suc 0\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_newrgt0 [p, r] = newrght p r a", "apply(auto simp: newrght.simps rec_newrgt3_def rec_newrgt2_def\n        rec_newrgt1_def rec_newrgt0_def rec_exec.simps\n        scan_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newrght p r a\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "from k1 and k2"], ["proof (chain)\npicking this:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a]\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newrght p r a", "show \n    \"rec_exec (rec_embranch (zip ?rgs ?rrs)) [p, r, a] =      \n                                    newrght p r a\""], ["proof (prove)\nusing this:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a]\n  Embranch\n   (zip (map rec_exec\n          [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1])\n     (map (\\<lambda>r args. 0 < rec_exec r args)\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newrght p r a\n\ngoal (1 subgoal):\n 1. rec_exec\n     (rec_embranch\n       (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n             Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n         [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n          Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n          Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n     [p, r, a] =\n    newrght p r a", "by simp"], ["proof (state)\nthis:\n  rec_exec\n   (rec_embranch\n     (zip [Cn 3 rec_newrgt0 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt1 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt2 [recf.id 3 0, recf.id 3 1],\n           Cn 3 rec_newrgt3 [recf.id 3 0, recf.id 3 1], recf.id 3 1]\n       [Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 0) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 1) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 2) [recf.id 3 0]],\n        Cn 3 rec_eq [recf.id 3 2, Cn 3 (constn 3) [recf.id 3 0]],\n        Cn 3 rec_less [Cn 3 (constn 3) [recf.id 3 0], recf.id 3 2]]))\n   [p, r, a] =\n  newrght p r a\n\ngoal:\nNo subgoals!", "qed"], ["", "declare Entry.simps[simp del]"], ["", "text \\<open>\n  The \\<open>actn\\<close> function given on page 92 of B book, which is used to \n  fetch Turing Machine intructions. \n  In \\<open>actn m q r\\<close>, \\<open>m\\<close> is the Godel coding of a Turing Machine,\n  \\<open>q\\<close> is the current state of Turing Machine, \\<open>r\\<close> is the\n  right number of Turing Machine tape.\n\\<close>"], ["", "fun actn :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"actn m q r = (if q \\<noteq> 0 then Entry m (4*(q - 1) + 2 * scan r)\n                 else 4)\""], ["", "text \\<open>\n  \\<open>rec_actn\\<close> is the recursive function used to implement \\<open>actn\\<close>\n\\<close>"], ["", "definition rec_actn :: \"recf\"\n  where\n    \"rec_actn = \n  Cn 3 rec_add [Cn 3 rec_mult \n        [Cn 3 rec_entry [id 3 0, Cn 3 rec_add [Cn 3 rec_mult \n                                 [Cn 3 (constn 4) [id 3 0], \n                Cn 3 rec_minus [id 3 1, Cn 3 (constn 1) [id 3 0]]], \n                   Cn 3 rec_mult [Cn 3 (constn 2) [id 3 0],\n                      Cn 3 rec_scan [id 3 2]]]], \n            Cn 3 rec_noteq [id 3 1, Cn 3 (constn 0) [id 3 0]]], \n                             Cn 3 rec_mult [Cn 3 (constn 4) [id 3 0], \n             Cn 3 rec_eq [id 3 1, Cn 3 (constn 0) [id 3 0]]]] \""], ["", "text \\<open>\n  The correctness of \\<open>actn\\<close>.\n\\<close>"], ["", "lemma actn_lemma: \"rec_exec rec_actn [m, q, r] = actn m q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_actn [m, q, r] = actn m q r", "by(auto simp: rec_actn_def rec_exec.simps entry_lemma scan_lemma)"], ["", "fun newstat :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"newstat m q r = (if q \\<noteq> 0 then Entry m (4*(q - 1) + 2*scan r + 1)\n                    else 0)\""], ["", "definition rec_newstat :: \"recf\"\n  where\n    \"rec_newstat = Cn 3 rec_add \n    [Cn 3 rec_mult [Cn 3 rec_entry [id 3 0, \n           Cn 3 rec_add [Cn 3 rec_mult [Cn 3 (constn 4) [id 3 0], \n           Cn 3 rec_minus [id 3 1, Cn 3 (constn 1) [id 3 0]]], \n           Cn 3 rec_add [Cn 3 rec_mult [Cn 3 (constn 2) [id 3 0],\n           Cn 3 rec_scan [id 3 2]], Cn 3 (constn 1) [id 3 0]]]], \n           Cn 3 rec_noteq [id 3 1, Cn 3 (constn 0) [id 3 0]]], \n           Cn 3 rec_mult [Cn 3 (constn 0) [id 3 0], \n           Cn 3 rec_eq [id 3 1, Cn 3 (constn 0) [id 3 0]]]] \""], ["", "lemma newstat_lemma: \"rec_exec rec_newstat [m, q, r] = newstat m q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_newstat [m, q, r] = newstat m q r", "by(auto simp:  rec_exec.simps entry_lemma scan_lemma rec_newstat_def)"], ["", "declare newstat.simps[simp del] actn.simps[simp del]"], ["", "text\\<open>code the configuration\\<close>"], ["", "fun trpl :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"trpl p q r = (Pi 0)^p * (Pi 1)^q * (Pi 2)^r\""], ["", "definition rec_trpl :: \"recf\"\n  where\n    \"rec_trpl = Cn 3 rec_mult [Cn 3 rec_mult \n       [Cn 3 rec_power [Cn 3 (constn (Pi 0)) [id 3 0], id 3 0], \n        Cn 3 rec_power [Cn 3 (constn (Pi 1)) [id 3 0], id 3 1]],\n        Cn 3 rec_power [Cn 3 (constn (Pi 2)) [id 3 0], id 3 2]]\""], ["", "declare trpl.simps[simp del]"], ["", "lemma trpl_lemma: \"rec_exec rec_trpl [p, q, r] = trpl p q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_trpl [p, q, r] = trpl p q r", "by(auto simp: rec_trpl_def rec_exec.simps power_lemma trpl.simps)"], ["", "text\\<open>left, stat, rght: decode func\\<close>"], ["", "fun left :: \"nat \\<Rightarrow> nat\"\n  where\n    \"left c = lo c (Pi 0)\""], ["", "fun stat :: \"nat \\<Rightarrow> nat\"\n  where\n    \"stat c = lo c (Pi 1)\""], ["", "fun rght :: \"nat \\<Rightarrow> nat\"\n  where\n    \"rght c = lo c (Pi 2)\""], ["", "fun inpt :: \"nat \\<Rightarrow> nat list \\<Rightarrow> nat\"\n  where\n    \"inpt m xs = trpl 0 1 (strt xs)\""], ["", "fun newconf :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"newconf m c = trpl (newleft (left c) (rght c) \n                        (actn m (stat c) (rght c)))\n                        (newstat m (stat c) (rght c)) \n                        (newrght (left c) (rght c) \n                              (actn m (stat c) (rght c)))\""], ["", "declare left.simps[simp del] stat.simps[simp del] rght.simps[simp del]\n  inpt.simps[simp del] newconf.simps[simp del]"], ["", "definition rec_left :: \"recf\"\n  where\n    \"rec_left = Cn 1 rec_lo [id 1 0, constn (Pi 0)]\""], ["", "definition rec_right :: \"recf\"\n  where\n    \"rec_right = Cn 1 rec_lo [id 1 0, constn (Pi 2)]\""], ["", "definition rec_stat :: \"recf\"\n  where\n    \"rec_stat = Cn 1 rec_lo [id 1 0, constn (Pi 1)]\""], ["", "definition rec_inpt :: \"nat \\<Rightarrow> recf\"\n  where\n    \"rec_inpt vl = Cn vl rec_trpl \n                  [Cn vl (constn 0) [id vl 0], \n                   Cn vl (constn 1) [id vl 0], \n                   Cn vl (rec_strt (vl - 1)) \n                        (map (\\<lambda> i. id vl (i)) [1..<vl])]\""], ["", "lemma left_lemma: \"rec_exec rec_left [c] = left c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_left [c] = left c", "by(simp add: rec_exec.simps rec_left_def left.simps lo_lemma)"], ["", "lemma right_lemma: \"rec_exec rec_right [c] = rght c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_right [c] = rght c", "by(simp add: rec_exec.simps rec_right_def rght.simps lo_lemma)"], ["", "lemma stat_lemma: \"rec_exec rec_stat [c] = stat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_stat [c] = stat c", "by(simp add: rec_exec.simps rec_stat_def stat.simps lo_lemma)"], ["", "declare rec_strt.simps[simp del] strt.simps[simp del]"], ["", "lemma map_cons_eq: \n  \"(map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ> \n    (\\<lambda>i. recf.id (Suc (length xs)) (i))) \n          [Suc 0..<Suc (length xs)])\n        = map (\\<lambda> i. xs ! (i - 1)) [Suc 0..<Suc (length xs)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n         recf.id (Suc (length xs)))\n     [Suc 0..<Suc (length xs)] =\n    map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc (length xs)]", "apply(rule map_ext, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc 0 \\<le> length xs \\<Longrightarrow>\n    rec_exec (recf.id (Suc (length xs)) (length xs)) (m # xs) =\n    xs ! (length xs - Suc 0)\n 2. \\<And>x.\n       \\<lbrakk>Suc 0 \\<le> x; x < length xs\\<rbrakk>\n       \\<Longrightarrow> rec_exec (recf.id (Suc (length xs)) x) (m # xs) =\n                         xs ! (x - Suc 0)", "apply(auto simp: rec_exec.simps nth_append nth_Cons split: nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_map_eq: \n  \"vl = length (xs::nat list) \\<Longrightarrow> map (\\<lambda> i. xs ! (i - 1))\n                                          [Suc 0..<Suc vl] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vl = length xs \\<Longrightarrow>\n    map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc vl] = xs", "proof(induct vl arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = length xs \\<Longrightarrow>\n       map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc 0] = xs\n 2. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   vl = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc vl] = xs;\n        Suc vl = length xs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. xs ! (i - 1))\n                          [Suc 0..<Suc (Suc vl)] =\n                         xs", "case (Suc vl)"], ["proof (state)\nthis:\n  vl = length ?xs \\<Longrightarrow>\n  map (\\<lambda>i. ?xs ! (i - 1)) [Suc 0..<Suc vl] = ?xs\n  Suc vl = length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       0 = length xs \\<Longrightarrow>\n       map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc 0] = xs\n 2. \\<And>vl xs.\n       \\<lbrakk>\\<And>xs.\n                   vl = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc vl] = xs;\n        Suc vl = length xs\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. xs ! (i - 1))\n                          [Suc 0..<Suc (Suc vl)] =\n                         xs", "then"], ["proof (chain)\npicking this:\n  vl = length ?xs \\<Longrightarrow>\n  map (\\<lambda>i. ?xs ! (i - 1)) [Suc 0..<Suc vl] = ?xs\n  Suc vl = length xs", "show ?case"], ["proof (prove)\nusing this:\n  vl = length ?xs \\<Longrightarrow>\n  map (\\<lambda>i. ?xs ! (i - 1)) [Suc 0..<Suc vl] = ?xs\n  Suc vl = length xs\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc (Suc vl)] = xs", "apply(subgoal_tac \"\\<exists> ys y. xs = ys @ [y]\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "fix ys y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "assume ind: \n      \"\\<And>xs. length (ys::nat list) = length (xs::nat list) \\<Longrightarrow>\n            map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                                [xs ! (length xs - Suc 0)] = xs\"\n      and h: \"Suc 0 \\<le> length (ys::nat list)\""], ["proof (state)\nthis:\n  length ys = length ?xs \\<Longrightarrow>\n  map (\\<lambda>i. ?xs ! (i - Suc 0)) [Suc 0..<length ?xs] @\n  [?xs ! (length ?xs - Suc 0)] =\n  ?xs\n  Suc 0 \\<le> length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "have \"map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys] @ \n                                   [ys ! (length ys - Suc 0)] = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys] @\n    [ys ! (length ys - Suc 0)] =\n    ys", "apply(rule_tac ind, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys] @\n  [ys ! (length ys - Suc 0)] =\n  ys\n\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys] @\n  [ys ! (length ys - Suc 0)] =\n  ys\n\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "have \n      \"map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys]\n      = map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys] =\n    map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys]", "apply(rule map_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [Suc 0..<length ys] \\<longrightarrow>\n       (ys @ [y]) ! (x - Suc 0) = ys ! (x - Suc 0)", "using h"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set [Suc 0..<length ys] \\<longrightarrow>\n       (ys @ [y]) ! (x - Suc 0) = ys ! (x - Suc 0)", "apply(auto simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys] =\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys]\n\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>xs.\n                   length ys = length xs \\<Longrightarrow>\n                   map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] @\n                   [xs ! (length xs - Suc 0)] =\n                   xs;\n        vl = length ys; xs = ys @ [y]; Suc 0 \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0))\n                          [Suc 0..<length ys] @\n                         [(ys @ [y]) ! (length ys - Suc 0)] =\n                         ys\n 2. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys] @\n  [ys ! (length ys - Suc 0)] =\n  ys\n  map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys] =\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys]", "show \"map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) \n        [Suc 0..<length ys] @ [(ys @ [y]) ! (length ys - Suc 0)] = ys\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys] @\n  [ys ! (length ys - Suc 0)] =\n  ys\n  map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys] =\n  map (\\<lambda>i. ys ! (i - Suc 0)) [Suc 0..<length ys]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys] @\n    [(ys @ [y]) ! (length ys - Suc 0)] =\n    ys", "apply(simp del: map_eq_conv add: nth_append, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[ys ! 0] = ys; \\<not> length ys - Suc 0 < length ys\\<rbrakk>\n    \\<Longrightarrow> [y] = ys", "using h"], ["proof (prove)\nusing this:\n  Suc 0 \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[ys ! 0] = ys; \\<not> length ys - Suc 0 < length ys\\<rbrakk>\n    \\<Longrightarrow> [y] = ys", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map (\\<lambda>i. (ys @ [y]) ! (i - Suc 0)) [Suc 0..<length ys] @\n  [(ys @ [y]) ! (length ys - Suc 0)] =\n  ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                vl = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "fix vl xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                vla__ = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vla__ = length xsa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xsa__ = ys @ [y]", "assume \"Suc vl = length (xs::nat list)\""], ["proof (state)\nthis:\n  Suc vl = length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                vla__ = length xs \\<Longrightarrow>\n                map (\\<lambda>i. xs ! (i - Suc 0))\n                 (if Suc 0 \\<le> length xs\n                  then [Suc 0..<length xs] @ [length xs] else []) =\n                xs;\n     Suc vla__ = length xsa__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ys y. xsa__ = ys @ [y]", "thus \"\\<exists>ys y. xs = ys @ [y]\""], ["proof (prove)\nusing this:\n  Suc vl = length xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys y. xs = ys @ [y]", "apply(rule_tac x = \"butlast xs\" in exI, \n          rule_tac x = \"last xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc vl = length xs; Suc vl = length xs\\<rbrakk>\n    \\<Longrightarrow> xs = butlast xs @ [last xs]", "apply(cases \"xs \\<noteq> []\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ys y. xs = ys @ [y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc (Suc vl)] = xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       0 = length xs \\<Longrightarrow>\n       map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc 0] = xs", "qed simp"], ["", "lemma nonempty_listE: \n  \"Suc 0 \\<le> length xs \\<Longrightarrow> \n     (map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ> \n         (\\<lambda>i. recf.id (Suc (length xs)) (i))) \n             [Suc 0..<length xs] @ [(m # xs) ! length xs]) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length xs \\<Longrightarrow>\n    map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n         recf.id (Suc (length xs)))\n     [Suc 0..<length xs] @\n    [(m # xs) ! length xs] =\n    xs", "using map_cons_eq[of m xs]"], ["proof (prove)\nusing this:\n  map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ> recf.id (Suc (length xs)))\n   [Suc 0..<Suc (length xs)] =\n  map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc (length xs)]\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length xs \\<Longrightarrow>\n    map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n         recf.id (Suc (length xs)))\n     [Suc 0..<length xs] @\n    [(m # xs) ! length xs] =\n    xs", "apply(simp del: map_eq_conv add: rec_exec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 \\<le> length xs;\n     map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n          recf.id (Suc (length xs)))\n      [Suc 0..<length xs] =\n     map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] \\<and>\n     (m # xs) ! length xs = xs ! (length xs - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>i. xs ! (i - Suc 0))\n                       [Suc 0..<length xs] @\n                      [xs ! (length xs - Suc 0)] =\n                      xs", "using list_map_eq[of \"length xs\" xs]"], ["proof (prove)\nusing this:\n  length xs = length xs \\<Longrightarrow>\n  map (\\<lambda>i. xs ! (i - 1)) [Suc 0..<Suc (length xs)] = xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 \\<le> length xs;\n     map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n          recf.id (Suc (length xs)))\n      [Suc 0..<length xs] =\n     map (\\<lambda>i. xs ! (i - Suc 0)) [Suc 0..<length xs] \\<and>\n     (m # xs) ! length xs = xs ! (length xs - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>i. xs ! (i - Suc 0))\n                       [Suc 0..<length xs] @\n                      [xs ! (length xs - Suc 0)] =\n                      xs", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inpt_lemma:\n  \"\\<lbrakk>Suc (length xs) = vl\\<rbrakk> \\<Longrightarrow> \n            rec_exec (rec_inpt vl) (m # xs) = inpt m xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (length xs) = vl \\<Longrightarrow>\n    rec_exec (rec_inpt vl) (m # xs) = inpt m xs", "apply(auto simp: rec_exec.simps rec_inpt_def \n      trpl_lemma inpt.simps strt_lemma)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vl = Suc (length xs); Suc 0 \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> trpl 0 (Suc 0)\n                       (strt\n                         (map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n                               recf.id (Suc (length xs)))\n                           [Suc 0..<length xs] @\n                          [(m # xs) ! length xs])) =\n                      trpl 0 (Suc 0) (strt xs)\n 2. \\<lbrakk>vl = Suc (length xs); \\<not> Suc 0 \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> trpl 0 (Suc 0) (strt []) = trpl 0 (Suc 0) (strt xs)", "apply(subgoal_tac\n      \"(map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ> \n          (\\<lambda>i. recf.id (Suc (length xs)) (i))) \n            [Suc 0..<length xs] @ [(m # xs) ! length xs]) = xs\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vl = Suc (length xs); Suc 0 \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> map ((\\<lambda>a. rec_exec a (m # xs)) \\<circ>\n                           recf.id (Suc (length xs)))\n                       [Suc 0..<length xs] @\n                      [(m # xs) ! length xs] =\n                      xs\n 2. \\<lbrakk>vl = Suc (length xs); \\<not> Suc 0 \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> trpl 0 (Suc 0) (strt []) = trpl 0 (Suc 0) (strt xs)", "apply(auto elim:nonempty_listE, cases xs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition rec_newconf:: \"recf\"\n  where\n    \"rec_newconf = \n    Cn 2 rec_trpl \n        [Cn 2 rec_newleft [Cn 2 rec_left [id 2 1], \n                           Cn 2 rec_right [id 2 1], \n                           Cn 2 rec_actn [id 2 0, \n                                          Cn 2 rec_stat [id 2 1], \n                           Cn 2 rec_right [id 2 1]]],\n          Cn 2 rec_newstat [id 2 0, \n                            Cn 2 rec_stat [id 2 1], \n                            Cn 2 rec_right [id 2 1]],\n           Cn 2 rec_newrght [Cn 2 rec_left [id 2 1], \n                             Cn 2 rec_right [id 2 1], \n                             Cn 2 rec_actn [id 2 0, \n                                   Cn 2 rec_stat [id 2 1], \n                             Cn 2 rec_right [id 2 1]]]]\""], ["", "lemma newconf_lemma: \"rec_exec rec_newconf [m ,c] = newconf m c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_newconf [m, c] = newconf m c", "by(auto simp: rec_newconf_def rec_exec.simps \n      trpl_lemma newleft_lemma left_lemma\n      right_lemma stat_lemma newrght_lemma actn_lemma \n      newstat_lemma newconf.simps)"], ["", "declare newconf_lemma[simp]"], ["", "text \\<open>\n  \\<open>conf m r k\\<close> computes the TM configuration after \\<open>k\\<close> steps of execution\n  of TM coded as \\<open>m\\<close> starting from the initial configuration where the left number equals \\<open>0\\<close>, \n  right number equals \\<open>r\\<close>. \n\\<close>"], ["", "fun conf :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"conf m r 0 = trpl 0 (Suc 0) r\"\n  | \"conf m r (Suc t) = newconf m (conf m r t)\""], ["", "declare conf.simps[simp del]"], ["", "text \\<open>\n  \\<open>conf\\<close> is implemented by the following recursive function \\<open>rec_conf\\<close>.\n\\<close>"], ["", "definition rec_conf :: \"recf\"\n  where\n    \"rec_conf = Pr 2 (Cn 2 rec_trpl [Cn 2 (constn 0) [id 2 0], Cn 2 (constn (Suc 0)) [id 2 0], id 2 1])\n                  (Cn 4 rec_newconf [id 4 0, id 4 3])\""], ["", "lemma conf_step: \n  \"rec_exec rec_conf [m, r, Suc t] =\n         rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_conf [m, r, Suc t] =\n    rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec rec_conf [m, r, Suc t] =\n    rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]", "have \"rec_exec rec_conf ([m, r] @ [Suc t]) = \n          rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_conf ([m, r] @ [Suc t]) =\n    rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]", "by(simp only: rec_conf_def rec_pr_Suc_simp_rewrite,\n        simp add: rec_exec.simps)"], ["proof (state)\nthis:\n  rec_exec rec_conf ([m, r] @ [Suc t]) =\n  rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\n\ngoal (1 subgoal):\n 1. rec_exec rec_conf [m, r, Suc t] =\n    rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]", "thus \"rec_exec rec_conf [m, r, Suc t] =\n                rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\""], ["proof (prove)\nusing this:\n  rec_exec rec_conf ([m, r] @ [Suc t]) =\n  rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\n\ngoal (1 subgoal):\n 1. rec_exec rec_conf [m, r, Suc t] =\n    rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]", "by simp"], ["proof (state)\nthis:\n  rec_exec rec_conf [m, r, Suc t] =\n  rec_exec rec_newconf [m, rec_exec rec_conf [m, r, t]]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>rec_conf\\<close>.\n\\<close>"], ["", "lemma conf_lemma: \n  \"rec_exec rec_conf [m, r, t] = conf m r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_conf [m, r, t] = conf m r t", "by (induct t)\n    (auto simp add: rec_conf_def rec_exec.simps conf.simps inpt_lemma trpl_lemma)"], ["", "text \\<open>\n  \\<open>NSTD c\\<close> returns true if the configureation coded by \\<open>c\\<close> is no a stardard\n  final configuration.\n\\<close>"], ["", "fun NSTD :: \"nat \\<Rightarrow> bool\"\n  where\n    \"NSTD c = (stat c \\<noteq> 0 \\<or> left c \\<noteq> 0 \\<or> \n             rght c \\<noteq> 2^(lg (rght c + 1) 2) - 1 \\<or> rght c = 0)\""], ["", "text \\<open>\n  \\<open>rec_NSTD\\<close> is the recursive function implementing \\<open>NSTD\\<close>.\n\\<close>"], ["", "definition rec_NSTD :: \"recf\"\n  where\n    \"rec_NSTD =\n     Cn 1 rec_disj [\n          Cn 1 rec_disj [\n             Cn 1 rec_disj \n                [Cn 1 rec_noteq [rec_stat, constn 0], \n                 Cn 1 rec_noteq [rec_left, constn 0]] , \n              Cn 1 rec_noteq [rec_right,  \n                              Cn 1 rec_minus [Cn 1 rec_power \n                                 [constn 2, Cn 1 rec_lg \n                                    [Cn 1 rec_add        \n                                     [rec_right, constn 1], \n                                            constn 2]], constn 1]]],\n               Cn 1 rec_eq [rec_right, constn 0]]\""], ["", "lemma NSTD_lemma1: \"rec_exec rec_NSTD [c] = Suc 0 \\<or>\n                   rec_exec rec_NSTD [c] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_NSTD [c] = Suc 0 \\<or> rec_exec rec_NSTD [c] = 0", "by(simp add: rec_exec.simps rec_NSTD_def)"], ["", "declare NSTD.simps[simp del]"], ["", "lemma NSTD_lemma2': \"(rec_exec rec_NSTD [c] = Suc 0) \\<Longrightarrow> NSTD c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_NSTD [c] = Suc 0 \\<Longrightarrow> NSTD c", "apply(simp add: rec_exec.simps rec_NSTD_def stat_lemma left_lemma \n      lg_lemma right_lemma power_lemma NSTD.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if (if (if 0 < stat c then 1 else 0) = 0 \\<and>\n                (if 0 < left c then 1 else 0) = 0\n             then 0 else 1) =\n            0 \\<and>\n            (if rght c \\<noteq> 2 ^ lg (Suc (rght c)) 2 - Suc 0 then 1\n             else 0) =\n            0\n         then 0 else 1) =\n        0 \\<and>\n        (if rght c = 0 then 1 else 0) = 0\n     then 0 else 1) =\n    Suc 0 \\<Longrightarrow>\n    rght c = 2 ^ lg (Suc (rght c)) 2 - Suc 0 \\<longrightarrow>\n    0 < stat c \\<or> 0 < left c \\<or> rght c = 0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if (if (if (if 0 < left c then 1 else 0) = 0 then 0 else 1) =\n                     0\n                  then 0 else 1) =\n                 0\n              then 0 else 1) =\n             Suc 0;\n     rght c = 2 ^ lg (Suc (rght c)) 2 - Suc 0; stat c = 0;\n     0 < rght c\\<rbrakk>\n    \\<Longrightarrow> 0 < left c", "apply(cases \"0 < left c\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NSTD_lemma2'': \n  \"NSTD c \\<Longrightarrow> (rec_exec rec_NSTD [c] = Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NSTD c \\<Longrightarrow> rec_exec rec_NSTD [c] = Suc 0", "apply(simp add: rec_exec.simps rec_NSTD_def stat_lemma \n      left_lemma lg_lemma right_lemma power_lemma NSTD.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rght c = 2 ^ lg (Suc (rght c)) 2 - Suc 0 \\<longrightarrow>\n    0 < stat c \\<or> 0 < left c \\<or> rght c = 0 \\<Longrightarrow>\n    stat c = 0 \\<longrightarrow>\n    left c = 0 \\<longrightarrow>\n    rght c = 2 ^ lg (Suc (rght c)) 2 - Suc 0 \\<longrightarrow> rght c = 0", "apply(auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>NSTD\\<close>.\n\\<close>"], ["", "lemma NSTD_lemma2: \"(rec_exec rec_NSTD [c] = Suc 0) = NSTD c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_exec rec_NSTD [c] = Suc 0) = NSTD c", "using NSTD_lemma1"], ["proof (prove)\nusing this:\n  rec_exec rec_NSTD [?c] = Suc 0 \\<or> rec_exec rec_NSTD [?c] = 0\n\ngoal (1 subgoal):\n 1. (rec_exec rec_NSTD [c] = Suc 0) = NSTD c", "apply(auto intro: NSTD_lemma2' NSTD_lemma2'')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun nstd :: \"nat \\<Rightarrow> nat\"\n  where\n    \"nstd c = (if NSTD c then 1 else 0)\""], ["", "lemma nstd_lemma: \"rec_exec rec_NSTD [c] = nstd c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_NSTD [c] = nstd c", "using NSTD_lemma1"], ["proof (prove)\nusing this:\n  rec_exec rec_NSTD [?c] = Suc 0 \\<or> rec_exec rec_NSTD [?c] = 0\n\ngoal (1 subgoal):\n 1. rec_exec rec_NSTD [c] = nstd c", "apply(simp add: NSTD_lemma2, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  \\<open>nonstep m r t\\<close> means afer \\<open>t\\<close> steps of execution, the TM coded by \\<open>m\\<close>\n  is not at a stardard final configuration.\n\\<close>"], ["", "fun nonstop :: \"nat \\<Rightarrow> nat  \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"nonstop m r t = nstd (conf m r t)\""], ["", "text \\<open>\n  \\<open>rec_nonstop\\<close> is the recursive function implementing \\<open>nonstop\\<close>.\n\\<close>"], ["", "definition rec_nonstop :: \"recf\"\n  where\n    \"rec_nonstop = Cn 3 rec_NSTD [rec_conf]\""], ["", "text \\<open>\n  The correctness of \\<open>rec_nonstop\\<close>.\n\\<close>"], ["", "lemma nonstop_lemma: \n  \"rec_exec rec_nonstop [m, r, t] = nonstop m r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_nonstop [m, r, t] = nonstop m r t", "apply(simp add: rec_exec.simps rec_nonstop_def nstd_lemma conf_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>\n  \\<open>rec_halt\\<close> is the recursive function calculating the steps a TM needs to execute before\n  to reach a stardard final configuration. This recursive function is the only one\n  using \\<open>Mn\\<close> combinator. So it is the only non-primitive recursive function \n  needs to be used in the construction of the universal function \\<open>F\\<close>.\n\\<close>"], ["", "definition rec_halt :: \"recf\"\n  where\n    \"rec_halt = Mn (Suc (Suc 0)) (rec_nonstop)\""], ["", "declare nonstop.simps[simp del]"], ["", "text \\<open>\n  The lemma relates the interpreter of primitive functions with\n  the calculation relation of general recursive functions. \n\\<close>"], ["", "declare numeral_2_eq_2[simp] numeral_3_eq_3[simp]"], ["", "lemma primerec_rec_right_1[intro]: \"primerec rec_right (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_right (Suc 0)", "by(auto simp: rec_right_def rec_lo_def Let_def;force)"], ["", "lemma primerec_rec_pi_helper:\n  \"\\<forall>i<Suc (Suc 0). primerec ([recf.id (Suc 0) 0, recf.id (Suc 0) 0] ! i) (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (Suc 0).\n       primerec ([recf.id (Suc 0) 0, recf.id (Suc 0) 0] ! i) (Suc 0)", "by fastforce"], ["", "lemmas primerec_rec_pi_helpers =\n  primerec_rec_pi_helper primerec_constn_1 primerec_rec_sg_1 primerec_rec_not_1 primerec_rec_conj_2"], ["", "lemma primrec_dummyfac:\n  \"\\<forall>i<Suc (Suc 0).\n       primerec\n        ([recf.id (Suc 0) 0,\n          Cn (Suc 0) s\n           [Cn (Suc 0) rec_dummyfac\n             [recf.id (Suc 0) 0, recf.id (Suc 0) 0]]] !\n         i)\n        (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (Suc 0).\n       primerec\n        ([recf.id (Suc 0) 0,\n          Cn (Suc 0) s\n           [Cn (Suc 0) rec_dummyfac\n             [recf.id (Suc 0) 0, recf.id (Suc 0) 0]]] !\n         i)\n        (Suc 0)", "by(auto simp: rec_dummyfac_def;force)"], ["", "lemma primerec_rec_pi_1[intro]:  \"primerec rec_pi (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_pi (Suc 0)", "apply(simp add: rec_pi_def rec_dummy_pi_def \n      rec_np_def rec_fac_def rec_prime_def\n      rec_Minr.simps Let_def get_fstn_args.simps\n      arity.simps\n      rec_all.simps rec_sigma.simps rec_accum.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc 0)\n       (Pr (Suc 0) (constn (Suc (Suc 0)))\n         (Cn (Suc (Suc (Suc 0)))\n           (Cn (Suc 0)\n             (Pr (Suc 0)\n               (Cn (Suc 0)\n                 (Cn (Suc (Suc 0)) rec_sg\n                   [Cn (Suc (Suc 0))\n                     (Pr (Suc (Suc 0))\n                       (Cn (Suc (Suc 0))\n                         (Cn (Suc (Suc (Suc 0))) rec_not\n                           [Cn (Suc (Suc (Suc 0)))\n                             (Cn (Suc (Suc 0)) rec_conj\n                               [Cn (Suc (Suc 0)) rec_less\n                                 [recf.id (Suc (Suc 0)) 0,\n                                  recf.id (Suc (Suc 0)) (Suc 0)],\n                                Cn (Suc (Suc 0))\n                                 (Cn (Suc 0) rec_conj\n                                   [Cn (Suc 0) rec_less\n                                     [constn (Suc 0), recf.id (Suc 0) 0],\n                                    Cn (Suc 0) rec_sg\n                                     [Cn (Suc 0)\n (Pr (Suc 0)\n   (Cn (Suc 0)\n     (Cn (Suc (Suc 0)) rec_sg\n       [Cn (Suc (Suc 0))\n         (Pr (Suc (Suc 0))\n           (Cn (Suc (Suc 0))\n             (Cn (Suc (Suc (Suc 0))) rec_noteq\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0])\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n           (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n             [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n              Cn (Suc (Suc (Suc (Suc 0))))\n               (Cn (Suc (Suc (Suc 0))) rec_noteq\n                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                  recf.id (Suc (Suc (Suc 0))) 0])\n               [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                Cn (Suc (Suc (Suc (Suc 0)))) s\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          Cn (Suc (Suc 0)) rec_minus\n           [recf.id (Suc (Suc 0)) 0,\n            Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]]]])\n     [recf.id (Suc 0) 0, Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n   (Cn (Suc (Suc (Suc 0))) rec_mult\n     [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n      Cn (Suc (Suc (Suc 0)))\n       (Cn (Suc (Suc 0)) rec_sg\n         [Cn (Suc (Suc 0))\n           (Pr (Suc (Suc 0))\n             (Cn (Suc (Suc 0))\n               (Cn (Suc (Suc (Suc 0))) rec_noteq\n                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                  recf.id (Suc (Suc (Suc 0))) 0])\n               [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n             (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n               [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                Cn (Suc (Suc (Suc (Suc 0))))\n                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                    recf.id (Suc (Suc (Suc 0))) 0])\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                  recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                  Cn (Suc (Suc (Suc (Suc 0)))) s\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            Cn (Suc (Suc 0)) rec_minus\n             [recf.id (Suc (Suc 0)) 0,\n              Cn (Suc (Suc 0)) (constn (Suc 0))\n               [recf.id (Suc (Suc 0)) 0]]]])\n       [recf.id (Suc (Suc (Suc 0))) 0,\n        Cn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n [recf.id (Suc 0) 0,\n  Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                                 [recf.id (Suc (Suc 0)) (Suc 0)]])\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n                         [recf.id (Suc (Suc 0)) 0,\n                          recf.id (Suc (Suc 0)) (Suc 0),\n                          Cn (Suc (Suc 0)) (constn 0)\n                           [recf.id (Suc (Suc 0)) 0]])\n                       (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                         [recf.id (Suc (Suc (Suc (Suc 0))))\n                           (Suc (Suc (Suc 0))),\n                          Cn (Suc (Suc (Suc (Suc 0))))\n                           (Cn (Suc (Suc (Suc 0))) rec_not\n                             [Cn (Suc (Suc (Suc 0)))\n                               (Cn (Suc (Suc 0)) rec_conj\n                                 [Cn (Suc (Suc 0)) rec_less\n                                   [recf.id (Suc (Suc 0)) 0,\n                                    recf.id (Suc (Suc 0)) (Suc 0)],\n                                  Cn (Suc (Suc 0))\n                                   (Cn (Suc 0) rec_conj\n                                     [Cn (Suc 0) rec_less\n [constn (Suc 0), recf.id (Suc 0) 0],\nCn (Suc 0) rec_sg\n [Cn (Suc 0)\n   (Pr (Suc 0)\n     (Cn (Suc 0)\n       (Cn (Suc (Suc 0)) rec_sg\n         [Cn (Suc (Suc 0))\n           (Pr (Suc (Suc 0))\n             (Cn (Suc (Suc 0))\n               (Cn (Suc (Suc (Suc 0))) rec_noteq\n                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                  recf.id (Suc (Suc (Suc 0))) 0])\n               [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n             (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n               [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                Cn (Suc (Suc (Suc (Suc 0))))\n                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                    recf.id (Suc (Suc (Suc 0))) 0])\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                  recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                  Cn (Suc (Suc (Suc (Suc 0)))) s\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            Cn (Suc (Suc 0)) rec_minus\n             [recf.id (Suc (Suc 0)) 0,\n              Cn (Suc (Suc 0)) (constn (Suc 0))\n               [recf.id (Suc (Suc 0)) 0]]]])\n       [recf.id (Suc 0) 0, Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n     (Cn (Suc (Suc (Suc 0))) rec_mult\n       [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n        Cn (Suc (Suc (Suc 0)))\n         (Cn (Suc (Suc 0)) rec_sg\n           [Cn (Suc (Suc 0))\n             (Pr (Suc (Suc 0))\n               (Cn (Suc (Suc 0))\n                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                    recf.id (Suc (Suc (Suc 0))) 0])\n                 [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                  Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n               (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                  Cn (Suc (Suc (Suc (Suc 0))))\n                   (Cn (Suc (Suc (Suc 0))) rec_noteq\n                     [Cn (Suc (Suc (Suc 0))) rec_mult\n                       [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                        recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                      recf.id (Suc (Suc (Suc 0))) 0])\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                    recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                    Cn (Suc (Suc (Suc (Suc 0)))) s\n                     [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              Cn (Suc (Suc 0)) rec_minus\n               [recf.id (Suc (Suc 0)) 0,\n                Cn (Suc (Suc 0)) (constn (Suc 0))\n                 [recf.id (Suc (Suc 0)) 0]]]])\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n   [recf.id (Suc 0) 0,\n    Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                                   [recf.id (Suc (Suc 0)) (Suc 0)]])\n                               [recf.id (Suc (Suc (Suc 0))) 0,\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n                           [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                            recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                            Cn (Suc (Suc (Suc (Suc 0)))) s\n                             [recf.id (Suc (Suc (Suc (Suc 0))))\n                               (Suc (Suc 0))]]]))\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0),\n                      recf.id (Suc (Suc 0)) (Suc 0)]])\n                 [recf.id (Suc 0) 0,\n                  Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n               (Cn (Suc (Suc (Suc 0))) rec_add\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0)))\n                   (Cn (Suc (Suc 0)) rec_sg\n                     [Cn (Suc (Suc 0))\n                       (Pr (Suc (Suc 0))\n                         (Cn (Suc (Suc 0))\n                           (Cn (Suc (Suc (Suc 0))) rec_not\n                             [Cn (Suc (Suc (Suc 0)))\n                               (Cn (Suc (Suc 0)) rec_conj\n                                 [Cn (Suc (Suc 0)) rec_less\n                                   [recf.id (Suc (Suc 0)) 0,\n                                    recf.id (Suc (Suc 0)) (Suc 0)],\n                                  Cn (Suc (Suc 0))\n                                   (Cn (Suc 0) rec_conj\n                                     [Cn (Suc 0) rec_less\n [constn (Suc 0), recf.id (Suc 0) 0],\nCn (Suc 0) rec_sg\n [Cn (Suc 0)\n   (Pr (Suc 0)\n     (Cn (Suc 0)\n       (Cn (Suc (Suc 0)) rec_sg\n         [Cn (Suc (Suc 0))\n           (Pr (Suc (Suc 0))\n             (Cn (Suc (Suc 0))\n               (Cn (Suc (Suc (Suc 0))) rec_noteq\n                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                  recf.id (Suc (Suc (Suc 0))) 0])\n               [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n             (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n               [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                Cn (Suc (Suc (Suc (Suc 0))))\n                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                    recf.id (Suc (Suc (Suc 0))) 0])\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                  recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                  Cn (Suc (Suc (Suc (Suc 0)))) s\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            Cn (Suc (Suc 0)) rec_minus\n             [recf.id (Suc (Suc 0)) 0,\n              Cn (Suc (Suc 0)) (constn (Suc 0))\n               [recf.id (Suc (Suc 0)) 0]]]])\n       [recf.id (Suc 0) 0, Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n     (Cn (Suc (Suc (Suc 0))) rec_mult\n       [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n        Cn (Suc (Suc (Suc 0)))\n         (Cn (Suc (Suc 0)) rec_sg\n           [Cn (Suc (Suc 0))\n             (Pr (Suc (Suc 0))\n               (Cn (Suc (Suc 0))\n                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                    recf.id (Suc (Suc (Suc 0))) 0])\n                 [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                  Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n               (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                  Cn (Suc (Suc (Suc (Suc 0))))\n                   (Cn (Suc (Suc (Suc 0))) rec_noteq\n                     [Cn (Suc (Suc (Suc 0))) rec_mult\n                       [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                        recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                      recf.id (Suc (Suc (Suc 0))) 0])\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                    recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                    Cn (Suc (Suc (Suc (Suc 0)))) s\n                     [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              Cn (Suc (Suc 0)) rec_minus\n               [recf.id (Suc (Suc 0)) 0,\n                Cn (Suc (Suc 0)) (constn (Suc 0))\n                 [recf.id (Suc (Suc 0)) 0]]]])\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n   [recf.id (Suc 0) 0,\n    Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                                   [recf.id (Suc (Suc 0)) (Suc 0)]])\n                               [recf.id (Suc (Suc (Suc 0))) 0,\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n                           [recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Cn (Suc (Suc 0)) (constn 0)\n                             [recf.id (Suc (Suc 0)) 0]])\n                         (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                           [recf.id (Suc (Suc (Suc (Suc 0))))\n                             (Suc (Suc (Suc 0))),\n                            Cn (Suc (Suc (Suc (Suc 0))))\n                             (Cn (Suc (Suc (Suc 0))) rec_not\n                               [Cn (Suc (Suc (Suc 0)))\n                                 (Cn (Suc (Suc 0)) rec_conj\n                                   [Cn (Suc (Suc 0)) rec_less\n                                     [recf.id (Suc (Suc 0)) 0,\nrecf.id (Suc (Suc 0)) (Suc 0)],\n                                    Cn (Suc (Suc 0))\n                                     (Cn (Suc 0) rec_conj\n [Cn (Suc 0) rec_less [constn (Suc 0), recf.id (Suc 0) 0],\n  Cn (Suc 0) rec_sg\n   [Cn (Suc 0)\n     (Pr (Suc 0)\n       (Cn (Suc 0)\n         (Cn (Suc (Suc 0)) rec_sg\n           [Cn (Suc (Suc 0))\n             (Pr (Suc (Suc 0))\n               (Cn (Suc (Suc 0))\n                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                    recf.id (Suc (Suc (Suc 0))) 0])\n                 [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                  Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n               (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                  Cn (Suc (Suc (Suc (Suc 0))))\n                   (Cn (Suc (Suc (Suc 0))) rec_noteq\n                     [Cn (Suc (Suc (Suc 0))) rec_mult\n                       [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                        recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                      recf.id (Suc (Suc (Suc 0))) 0])\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                    recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                    Cn (Suc (Suc (Suc (Suc 0)))) s\n                     [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              Cn (Suc (Suc 0)) rec_minus\n               [recf.id (Suc (Suc 0)) 0,\n                Cn (Suc (Suc 0)) (constn (Suc 0))\n                 [recf.id (Suc (Suc 0)) 0]]]])\n         [recf.id (Suc 0) 0, Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n       (Cn (Suc (Suc (Suc 0))) rec_mult\n         [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n          Cn (Suc (Suc (Suc 0)))\n           (Cn (Suc (Suc 0)) rec_sg\n             [Cn (Suc (Suc 0))\n               (Pr (Suc (Suc 0))\n                 (Cn (Suc (Suc 0))\n                   (Cn (Suc (Suc (Suc 0))) rec_noteq\n                     [Cn (Suc (Suc (Suc 0))) rec_mult\n                       [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                        recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                      recf.id (Suc (Suc (Suc 0))) 0])\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n                 (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                    Cn (Suc (Suc (Suc (Suc 0))))\n                     (Cn (Suc (Suc (Suc 0))) rec_noteq\n                       [Cn (Suc (Suc (Suc 0))) rec_mult\n                         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                          recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                        recf.id (Suc (Suc (Suc 0))) 0])\n                     [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                      recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                      Cn (Suc (Suc (Suc (Suc 0)))) s\n                       [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n               [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                Cn (Suc (Suc 0)) rec_minus\n                 [recf.id (Suc (Suc 0)) 0,\n                  Cn (Suc (Suc 0)) (constn (Suc 0))\n                   [recf.id (Suc (Suc 0)) 0]]]])\n           [recf.id (Suc (Suc (Suc 0))) 0,\n            Cn (Suc (Suc (Suc 0))) s\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n     [recf.id (Suc 0) 0,\n      Cn (Suc 0) rec_minus [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                                     [recf.id (Suc (Suc 0)) (Suc 0)]])\n                                 [recf.id (Suc (Suc (Suc 0))) 0,\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))]])\n                             [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                              recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                              Cn (Suc (Suc (Suc (Suc 0)))) s\n                               [recf.id (Suc (Suc (Suc (Suc 0))))\n                                 (Suc (Suc 0))]]]))\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0),\n                        recf.id (Suc (Suc 0)) (Suc 0)]])\n                   [recf.id (Suc (Suc (Suc 0))) 0,\n                    Cn (Suc (Suc (Suc 0))) s\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n             [recf.id (Suc 0) 0,\n              Cn (Suc 0) s\n               [Cn (Suc 0) rec_dummyfac\n                 [recf.id (Suc 0) 0, recf.id (Suc 0) 0]]])\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]))\n       [recf.id (Suc 0) 0, recf.id (Suc 0) 0])\n     (Suc 0)", "apply(tactic \\<open>resolve_tac @{context} [@{thm prime_cn},  @{thm prime_pr}] 1\\<close>\n      ;(simp add:primerec_rec_pi_helpers primrec_dummyfac)?)+"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<forall>i<Suc (Suc 0).\n       primerec\n        ([Cn (Suc (Suc 0)) rec_less\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0))\n           (Cn (Suc 0) rec_conj\n             [Cn (Suc 0) rec_less [constn (Suc 0), recf.id (Suc 0) 0],\n              Cn (Suc 0) rec_sg\n               [Cn (Suc 0)\n                 (Pr (Suc 0)\n                   (Cn (Suc 0)\n                     (Cn (Suc (Suc 0)) rec_sg\n                       [Cn (Suc (Suc 0))\n                         (Pr (Suc (Suc 0))\n                           (Cn (Suc (Suc 0))\n                             (Cn (Suc (Suc (Suc 0))) rec_noteq\n                               [Cn (Suc (Suc (Suc 0))) rec_mult\n                                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                  recf.id (Suc (Suc (Suc 0)))\n                                   (Suc (Suc 0))],\n                                recf.id (Suc (Suc (Suc 0))) 0])\n                             [recf.id (Suc (Suc 0)) 0,\n                              recf.id (Suc (Suc 0)) (Suc 0),\n                              Cn (Suc (Suc 0)) (constn 0)\n                               [recf.id (Suc (Suc 0)) 0]])\n                           (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                             [recf.id (Suc (Suc (Suc (Suc 0))))\n                               (Suc (Suc (Suc 0))),\n                              Cn (Suc (Suc (Suc (Suc 0))))\n                               (Cn (Suc (Suc (Suc 0))) rec_noteq\n                                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                    recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0))],\n                                  recf.id (Suc (Suc (Suc 0))) 0])\n                               [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                                recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                                Cn (Suc (Suc (Suc (Suc 0)))) s\n                                 [recf.id (Suc (Suc (Suc (Suc 0))))\n                                   (Suc (Suc 0))]]]))\n                         [recf.id (Suc (Suc 0)) 0,\n                          recf.id (Suc (Suc 0)) (Suc 0),\n                          Cn (Suc (Suc 0)) rec_minus\n                           [recf.id (Suc (Suc 0)) 0,\n                            Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0]]]])\n                     [recf.id (Suc 0) 0,\n                      Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n                   (Cn (Suc (Suc (Suc 0))) rec_mult\n                     [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                      Cn (Suc (Suc (Suc 0)))\n                       (Cn (Suc (Suc 0)) rec_sg\n                         [Cn (Suc (Suc 0))\n                           (Pr (Suc (Suc 0))\n                             (Cn (Suc (Suc 0))\n                               (Cn (Suc (Suc (Suc 0))) rec_noteq\n                                 [Cn (Suc (Suc (Suc 0))) rec_mult\n                                   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                    recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0))],\n                                  recf.id (Suc (Suc (Suc 0))) 0])\n                               [recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Cn (Suc (Suc 0)) (constn 0)\n                                 [recf.id (Suc (Suc 0)) 0]])\n                             (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                               [recf.id (Suc (Suc (Suc (Suc 0))))\n                                 (Suc (Suc (Suc 0))),\n                                Cn (Suc (Suc (Suc (Suc 0))))\n                                 (Cn (Suc (Suc (Suc 0))) rec_noteq\n                                   [Cn (Suc (Suc (Suc 0))) rec_mult\n                                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\nrecf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                                    recf.id (Suc (Suc (Suc 0))) 0])\n                                 [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                                  recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                                  Cn (Suc (Suc (Suc (Suc 0)))) s\n                                   [recf.id (Suc (Suc (Suc (Suc 0))))\n                                     (Suc (Suc 0))]]]))\n                           [recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Cn (Suc (Suc 0)) rec_minus\n                             [recf.id (Suc (Suc 0)) 0,\n                              Cn (Suc (Suc 0)) (constn (Suc 0))\n                               [recf.id (Suc (Suc 0)) 0]]]])\n                       [recf.id (Suc (Suc (Suc 0))) 0,\n                        Cn (Suc (Suc (Suc 0))) s\n                         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n                 [recf.id (Suc 0) 0,\n                  Cn (Suc 0) rec_minus\n                   [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n           [recf.id (Suc (Suc 0)) (Suc 0)]] !\n         i)\n        (Suc (Suc 0))\n 2. \\<forall>i<Suc (Suc 0).\n       primerec\n        ([recf.id (Suc (Suc (Suc 0))) 0,\n          recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))] !\n         i)\n        (Suc (Suc (Suc 0)))\n 3. \\<forall>i<Suc (Suc (Suc 0)).\n       primerec\n        ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]] !\n         i)\n        (Suc (Suc 0))\n 4. primerec\n     (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n       [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n        Cn (Suc (Suc (Suc (Suc 0))))\n         (Cn (Suc (Suc (Suc 0))) rec_not\n           [Cn (Suc (Suc (Suc 0)))\n             (Cn (Suc (Suc 0)) rec_conj\n               [Cn (Suc (Suc 0)) rec_less\n                 [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0)],\n                Cn (Suc (Suc 0))\n                 (Cn (Suc 0) rec_conj\n                   [Cn (Suc 0) rec_less [constn (Suc 0), recf.id (Suc 0) 0],\n                    Cn (Suc 0) rec_sg\n                     [Cn (Suc 0)\n                       (Pr (Suc 0)\n                         (Cn (Suc 0)\n                           (Cn (Suc (Suc 0)) rec_sg\n                             [Cn (Suc (Suc 0))\n                               (Pr (Suc (Suc 0))\n                                 (Cn (Suc (Suc 0))\n                                   (Cn (Suc (Suc (Suc 0))) rec_noteq\n                                     [Cn (Suc (Suc (Suc 0))) rec_mult\n [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\nrecf.id (Suc (Suc (Suc 0))) 0])\n                                   [recf.id (Suc (Suc 0)) 0,\n                                    recf.id (Suc (Suc 0)) (Suc 0),\n                                    Cn (Suc (Suc 0)) (constn 0)\n                                     [recf.id (Suc (Suc 0)) 0]])\n                                 (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                                   [recf.id (Suc (Suc (Suc (Suc 0))))\n                                     (Suc (Suc (Suc 0))),\n                                    Cn (Suc (Suc (Suc (Suc 0))))\n                                     (Cn (Suc (Suc (Suc 0))) rec_noteq\n [Cn (Suc (Suc (Suc 0))) rec_mult\n   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n  recf.id (Suc (Suc (Suc 0))) 0])\n                                     [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\nrecf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\nCn (Suc (Suc (Suc (Suc 0)))) s\n [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n                               [recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Cn (Suc (Suc 0)) rec_minus\n                                 [recf.id (Suc (Suc 0)) 0,\n                                  Cn (Suc (Suc 0)) (constn (Suc 0))\n                                   [recf.id (Suc (Suc 0)) 0]]]])\n                           [recf.id (Suc 0) 0,\n                            Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n                         (Cn (Suc (Suc (Suc 0))) rec_mult\n                           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                            Cn (Suc (Suc (Suc 0)))\n                             (Cn (Suc (Suc 0)) rec_sg\n                               [Cn (Suc (Suc 0))\n                                 (Pr (Suc (Suc 0))\n                                   (Cn (Suc (Suc 0))\n                                     (Cn (Suc (Suc (Suc 0))) rec_noteq\n [Cn (Suc (Suc (Suc 0))) rec_mult\n   [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n  recf.id (Suc (Suc (Suc 0))) 0])\n                                     [recf.id (Suc (Suc 0)) 0,\nrecf.id (Suc (Suc 0)) (Suc 0),\nCn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n                                   (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                                     [recf.id (Suc (Suc (Suc (Suc 0))))\n (Suc (Suc (Suc 0))),\nCn (Suc (Suc (Suc (Suc 0))))\n (Cn (Suc (Suc (Suc 0))) rec_noteq\n   [Cn (Suc (Suc (Suc 0))) rec_mult\n     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n    recf.id (Suc (Suc (Suc 0))) 0])\n [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n  recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n  Cn (Suc (Suc (Suc (Suc 0)))) s\n   [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n                                 [recf.id (Suc (Suc 0)) 0,\n                                  recf.id (Suc (Suc 0)) (Suc 0),\n                                  Cn (Suc (Suc 0)) rec_minus\n                                   [recf.id (Suc (Suc 0)) 0,\n                                    Cn (Suc (Suc 0)) (constn (Suc 0))\n                                     [recf.id (Suc (Suc 0)) 0]]]])\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) s\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n                       [recf.id (Suc 0) 0,\n                        Cn (Suc 0) rec_minus\n                         [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                 [recf.id (Suc (Suc 0)) (Suc 0)]])\n             [recf.id (Suc (Suc (Suc 0))) 0,\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n         [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n          recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n          Cn (Suc (Suc (Suc (Suc 0)))) s\n           [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]])\n     (Suc (Suc (Suc (Suc 0))))\n 5. \\<forall>i<Suc (Suc (Suc 0)).\n       primerec\n        ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          recf.id (Suc (Suc 0)) (Suc 0)] !\n         i)\n        (Suc (Suc 0))\n 6. \\<forall>i<Suc (Suc 0).\n       primerec\n        ([recf.id (Suc 0) 0, Cn (Suc 0) (constn 0) [recf.id (Suc 0) 0]] ! i)\n        (Suc 0)\n 7. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_add\n       [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n        Cn (Suc (Suc (Suc 0)))\n         (Cn (Suc (Suc 0)) rec_sg\n           [Cn (Suc (Suc 0))\n             (Pr (Suc (Suc 0))\n               (Cn (Suc (Suc 0))\n                 (Cn (Suc (Suc (Suc 0))) rec_not\n                   [Cn (Suc (Suc (Suc 0)))\n                     (Cn (Suc (Suc 0)) rec_conj\n                       [Cn (Suc (Suc 0)) rec_less\n                         [recf.id (Suc (Suc 0)) 0,\n                          recf.id (Suc (Suc 0)) (Suc 0)],\n                        Cn (Suc (Suc 0))\n                         (Cn (Suc 0) rec_conj\n                           [Cn (Suc 0) rec_less\n                             [constn (Suc 0), recf.id (Suc 0) 0],\n                            Cn (Suc 0) rec_sg\n                             [Cn (Suc 0)\n                               (Pr (Suc 0)\n                                 (Cn (Suc 0)\n                                   (Cn (Suc (Suc 0)) rec_sg\n                                     [Cn (Suc (Suc 0))\n (Pr (Suc (Suc 0))\n   (Cn (Suc (Suc 0))\n     (Cn (Suc (Suc (Suc 0))) rec_noteq\n       [Cn (Suc (Suc (Suc 0))) rec_mult\n         [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n          recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n        recf.id (Suc (Suc (Suc 0))) 0])\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n      Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n   (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n     [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n      Cn (Suc (Suc (Suc (Suc 0))))\n       (Cn (Suc (Suc (Suc 0))) rec_noteq\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0])\n       [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n        recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n        Cn (Suc (Suc (Suc (Suc 0)))) s\n         [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n  Cn (Suc (Suc 0)) rec_minus\n   [recf.id (Suc (Suc 0)) 0,\n    Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]]]])\n                                   [recf.id (Suc 0) 0,\n                                    Cn (Suc 0) (constn 0)\n                                     [recf.id (Suc 0) 0]])\n                                 (Cn (Suc (Suc (Suc 0))) rec_mult\n                                   [recf.id (Suc (Suc (Suc 0)))\n                                     (Suc (Suc 0)),\n                                    Cn (Suc (Suc (Suc 0)))\n                                     (Cn (Suc (Suc 0)) rec_sg\n [Cn (Suc (Suc 0))\n   (Pr (Suc (Suc 0))\n     (Cn (Suc (Suc 0))\n       (Cn (Suc (Suc (Suc 0))) rec_noteq\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0])\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n     (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n       [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n        Cn (Suc (Suc (Suc (Suc 0))))\n         (Cn (Suc (Suc (Suc 0))) rec_noteq\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0])\n         [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n          recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n          Cn (Suc (Suc (Suc (Suc 0)))) s\n           [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n    Cn (Suc (Suc 0)) rec_minus\n     [recf.id (Suc (Suc 0)) 0,\n      Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]]]])\n                                     [recf.id (Suc (Suc (Suc 0))) 0,\nCn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n                               [recf.id (Suc 0) 0,\n                                Cn (Suc 0) rec_minus\n                                 [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                         [recf.id (Suc (Suc 0)) (Suc 0)]])\n                     [recf.id (Suc (Suc (Suc 0))) 0,\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n                 [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                  Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n               (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n                 [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n                  Cn (Suc (Suc (Suc (Suc 0))))\n                   (Cn (Suc (Suc (Suc 0))) rec_not\n                     [Cn (Suc (Suc (Suc 0)))\n                       (Cn (Suc (Suc 0)) rec_conj\n                         [Cn (Suc (Suc 0)) rec_less\n                           [recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0)],\n                          Cn (Suc (Suc 0))\n                           (Cn (Suc 0) rec_conj\n                             [Cn (Suc 0) rec_less\n                               [constn (Suc 0), recf.id (Suc 0) 0],\n                              Cn (Suc 0) rec_sg\n                               [Cn (Suc 0)\n                                 (Pr (Suc 0)\n                                   (Cn (Suc 0)\n                                     (Cn (Suc (Suc 0)) rec_sg\n [Cn (Suc (Suc 0))\n   (Pr (Suc (Suc 0))\n     (Cn (Suc (Suc 0))\n       (Cn (Suc (Suc (Suc 0))) rec_noteq\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n          recf.id (Suc (Suc (Suc 0))) 0])\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n     (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n       [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n        Cn (Suc (Suc (Suc (Suc 0))))\n         (Cn (Suc (Suc (Suc 0))) rec_noteq\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0])\n         [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n          recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n          Cn (Suc (Suc (Suc (Suc 0)))) s\n           [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n    Cn (Suc (Suc 0)) rec_minus\n     [recf.id (Suc (Suc 0)) 0,\n      Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]]]])\n                                     [recf.id (Suc 0) 0,\nCn (Suc 0) (constn 0) [recf.id (Suc 0) 0]])\n                                   (Cn (Suc (Suc (Suc 0))) rec_mult\n                                     [recf.id (Suc (Suc (Suc 0)))\n (Suc (Suc 0)),\nCn (Suc (Suc (Suc 0)))\n (Cn (Suc (Suc 0)) rec_sg\n   [Cn (Suc (Suc 0))\n     (Pr (Suc (Suc 0))\n       (Cn (Suc (Suc 0))\n         (Cn (Suc (Suc (Suc 0))) rec_noteq\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n            recf.id (Suc (Suc (Suc 0))) 0])\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]])\n       (Cn (Suc (Suc (Suc (Suc 0)))) rec_mult\n         [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc (Suc 0))),\n          Cn (Suc (Suc (Suc (Suc 0))))\n           (Cn (Suc (Suc (Suc 0))) rec_noteq\n             [Cn (Suc (Suc (Suc 0))) rec_mult\n               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n              recf.id (Suc (Suc (Suc 0))) 0])\n           [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n            recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n            Cn (Suc (Suc (Suc (Suc 0)))) s\n             [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n      Cn (Suc (Suc 0)) rec_minus\n       [recf.id (Suc (Suc 0)) 0,\n        Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0]]]])\n [recf.id (Suc (Suc (Suc 0))) 0,\n  Cn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]]))\n                                 [recf.id (Suc 0) 0,\n                                  Cn (Suc 0) rec_minus\n                                   [recf.id (Suc 0) 0, constn (Suc 0)]]]])\n                           [recf.id (Suc (Suc 0)) (Suc 0)]])\n                       [recf.id (Suc (Suc (Suc 0))) 0,\n                        recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n                   [recf.id (Suc (Suc (Suc (Suc 0)))) 0,\n                    recf.id (Suc (Suc (Suc (Suc 0)))) (Suc 0),\n                    Cn (Suc (Suc (Suc (Suc 0)))) s\n                     [recf.id (Suc (Suc (Suc (Suc 0)))) (Suc (Suc 0))]]]))\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              recf.id (Suc (Suc 0)) (Suc 0)]])\n         [recf.id (Suc (Suc (Suc 0))) 0,\n          Cn (Suc (Suc (Suc 0))) s [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]])\n     (Suc (Suc (Suc 0)))\n 8. primerec (recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))) (Suc (Suc (Suc 0)))", "by fastforce+"], ["", "lemma primerec_recs[intro]:\n  \"primerec rec_trpl (Suc (Suc (Suc 0)))\"\n  \"primerec rec_newleft0 (Suc (Suc 0))\"\n  \"primerec rec_newleft1 (Suc (Suc 0))\"\n  \"primerec rec_newleft2 (Suc (Suc 0))\"\n  \"primerec rec_newleft3 (Suc (Suc 0))\"\n  \"primerec rec_newleft (Suc (Suc (Suc 0)))\"\n  \"primerec rec_left (Suc 0)\"\n  \"primerec rec_actn (Suc (Suc (Suc 0)))\"\n  \"primerec rec_stat (Suc 0)\"\n  \"primerec rec_newstat (Suc (Suc (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((primerec rec_trpl (Suc (Suc (Suc 0))) &&&\n      primerec rec_newleft0 (Suc (Suc 0))) &&&\n     primerec rec_newleft1 (Suc (Suc 0)) &&&\n     primerec rec_newleft2 (Suc (Suc 0)) &&&\n     primerec rec_newleft3 (Suc (Suc 0))) &&&\n    (primerec rec_newleft (Suc (Suc (Suc 0))) &&&\n     primerec rec_left (Suc 0)) &&&\n    primerec rec_actn (Suc (Suc (Suc 0))) &&&\n    primerec rec_stat (Suc 0) &&& primerec rec_newstat (Suc (Suc (Suc 0)))", "apply(simp_all add: rec_newleft_def rec_embranch.simps rec_left_def rec_lo_def rec_entry_def\n      rec_actn_def Let_def arity.simps rec_newleft0_def rec_stat_def rec_newstat_def\n      rec_newleft1_def rec_newleft2_def rec_newleft3_def rec_trpl_def)"], ["proof (prove)\ngoal (10 subgoals):\n 1. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_mult\n       [Cn (Suc (Suc (Suc 0))) rec_mult\n         [Cn (Suc (Suc (Suc 0))) rec_power\n           [Cn (Suc (Suc (Suc 0))) (constn (Pi 0))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_power\n           [Cn (Suc (Suc (Suc 0))) (constn (Pi (Suc 0)))\n             [recf.id (Suc (Suc (Suc 0))) 0],\n            recf.id (Suc (Suc (Suc 0))) (Suc 0)]],\n        Cn (Suc (Suc (Suc 0))) rec_power\n         [Cn (Suc (Suc (Suc 0))) (constn (Pi (Suc (Suc 0))))\n           [recf.id (Suc (Suc (Suc 0))) 0],\n          recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]])\n     (Suc (Suc (Suc 0)))\n 2. primerec (recf.id (Suc (Suc 0)) 0) (Suc (Suc 0))\n 3. primerec (recf.id (Suc (Suc 0)) 0) (Suc (Suc 0))\n 4. primerec\n     (Cn (Suc (Suc 0)) rec_quo\n       [recf.id (Suc (Suc 0)) 0,\n        Cn (Suc (Suc 0)) (constn (Suc (Suc 0))) [recf.id (Suc (Suc 0)) 0]])\n     (Suc (Suc 0))\n 5. primerec\n     (Cn (Suc (Suc 0)) rec_add\n       [Cn (Suc (Suc 0)) rec_mult\n         [Cn (Suc (Suc 0)) (constn (Suc (Suc 0))) [recf.id (Suc (Suc 0)) 0],\n          recf.id (Suc (Suc 0)) 0],\n        Cn (Suc (Suc 0)) rec_mod\n         [recf.id (Suc (Suc 0)) (Suc 0),\n          Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n           [recf.id (Suc (Suc 0)) 0]]])\n     (Suc (Suc 0))\n 6. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_add\n       [Cn (Suc (Suc (Suc 0))) rec_mult\n         [Cn (Suc (Suc (Suc 0))) (recf.id (Suc (Suc 0)) 0)\n           [recf.id (Suc (Suc (Suc 0))) 0,\n            recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n          Cn (Suc (Suc (Suc 0))) rec_disj\n           [Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn 0)\n               [recf.id (Suc (Suc (Suc 0))) 0]],\n            Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n               [recf.id (Suc (Suc (Suc 0))) 0]]]],\n        Cn (Suc (Suc (Suc 0))) rec_add\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [Cn (Suc (Suc (Suc 0)))\n             (Cn (Suc (Suc 0)) rec_quo\n               [recf.id (Suc (Suc 0)) 0,\n                Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc 0)) 0]])\n             [recf.id (Suc (Suc (Suc 0))) 0,\n              recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n            Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n               [recf.id (Suc (Suc (Suc 0))) 0]]],\n          Cn (Suc (Suc (Suc 0))) rec_add\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [Cn (Suc (Suc (Suc 0)))\n               (Cn (Suc (Suc 0)) rec_add\n                 [Cn (Suc (Suc 0)) rec_mult\n                   [Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n                     [recf.id (Suc (Suc 0)) 0],\n                    recf.id (Suc (Suc 0)) 0],\n                  Cn (Suc (Suc 0)) rec_mod\n                   [recf.id (Suc (Suc 0)) (Suc 0),\n                    Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n                     [recf.id (Suc (Suc 0)) 0]]])\n               [recf.id (Suc (Suc (Suc 0))) 0,\n                recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n            Cn (Suc (Suc (Suc 0))) rec_add\n             [Cn (Suc (Suc (Suc 0))) rec_mult\n               [recf.id (Suc (Suc (Suc 0))) 0,\n                Cn (Suc (Suc (Suc 0))) rec_less\n                 [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                   [recf.id (Suc (Suc (Suc 0))) 0],\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n              Cn (Suc (Suc (Suc 0))) z\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]]]]])\n     (Suc (Suc (Suc 0)))\n 7. primerec\n     (Cn (Suc 0)\n       (Cn (Suc (Suc 0)) rec_add\n         [Cn (Suc (Suc 0)) rec_mult\n           [Cn (Suc (Suc 0))\n             (rec_maxr\n               (Cn (Suc (Suc (Suc 0))) rec_eq\n                 [Cn (Suc (Suc (Suc 0))) rec_mod\n                   [recf.id (Suc (Suc (Suc 0))) 0,\n                    Cn (Suc (Suc (Suc 0))) rec_power\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              recf.id (Suc (Suc 0)) 0],\n            Cn (Suc (Suc 0)) rec_conj\n             [Cn (Suc (Suc 0)) rec_less\n               [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n                recf.id (Suc (Suc 0)) 0],\n              Cn (Suc (Suc 0)) rec_less\n               [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n                recf.id (Suc (Suc 0)) (Suc 0)]]],\n          Cn (Suc (Suc 0)) rec_mult\n           [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n            Cn (Suc (Suc 0)) rec_minus\n             [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n              Cn (Suc (Suc 0)) rec_conj\n               [Cn (Suc (Suc 0)) rec_less\n                 [Cn (Suc (Suc 0)) (constn (Suc 0))\n                   [recf.id (Suc (Suc 0)) 0],\n                  recf.id (Suc (Suc 0)) 0],\n                Cn (Suc (Suc 0)) rec_less\n                 [Cn (Suc (Suc 0)) (constn (Suc 0))\n                   [recf.id (Suc (Suc 0)) 0],\n                  recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n       [recf.id (Suc 0) 0, constn (Pi 0)])\n     (Suc 0)\n 8. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_add\n       [Cn (Suc (Suc (Suc 0))) rec_mult\n         [Cn (Suc (Suc (Suc 0)))\n           (Cn (Suc (Suc 0))\n             (Cn (Suc (Suc 0)) rec_add\n               [Cn (Suc (Suc 0)) rec_mult\n                 [Cn (Suc (Suc 0))\n                   (rec_maxr\n                     (Cn (Suc (Suc (Suc 0))) rec_eq\n                       [Cn (Suc (Suc (Suc 0))) rec_mod\n                         [recf.id (Suc (Suc (Suc 0))) 0,\n                          Cn (Suc (Suc (Suc 0))) rec_power\n                           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                        Cn (Suc (Suc (Suc 0))) (constn 0)\n                         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    recf.id (Suc (Suc 0)) 0],\n                  Cn (Suc (Suc 0)) rec_conj\n                   [Cn (Suc (Suc 0)) rec_less\n                     [Cn (Suc (Suc 0)) (constn (Suc 0))\n                       [recf.id (Suc (Suc 0)) 0],\n                      recf.id (Suc (Suc 0)) 0],\n                    Cn (Suc (Suc 0)) rec_less\n                     [Cn (Suc (Suc 0)) (constn (Suc 0))\n                       [recf.id (Suc (Suc 0)) 0],\n                      recf.id (Suc (Suc 0)) (Suc 0)]]],\n                Cn (Suc (Suc 0)) rec_mult\n                 [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n                  Cn (Suc (Suc 0)) rec_minus\n                   [Cn (Suc (Suc 0)) (constn (Suc 0))\n                     [recf.id (Suc (Suc 0)) 0],\n                    Cn (Suc (Suc 0)) rec_conj\n                     [Cn (Suc (Suc 0)) rec_less\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_less\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n             [recf.id (Suc (Suc 0)) 0,\n              Cn (Suc (Suc 0)) rec_pi\n               [Cn (Suc (Suc 0)) s [recf.id (Suc (Suc 0)) (Suc 0)]]])\n           [recf.id (Suc (Suc (Suc 0))) 0,\n            Cn (Suc (Suc (Suc 0))) rec_add\n             [Cn (Suc (Suc (Suc 0))) rec_mult\n               [Cn (Suc (Suc (Suc 0))) (constn 4)\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                Cn (Suc (Suc (Suc 0))) rec_minus\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                   [recf.id (Suc (Suc (Suc 0))) 0]]],\n              Cn (Suc (Suc (Suc 0))) rec_mult\n               [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0],\n                Cn (Suc (Suc (Suc 0))) rec_scan\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]]]],\n          Cn (Suc (Suc (Suc 0))) rec_noteq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]],\n        Cn (Suc (Suc (Suc 0))) rec_mult\n         [Cn (Suc (Suc (Suc 0))) (constn 4) [recf.id (Suc (Suc (Suc 0))) 0],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]]])\n     (Suc (Suc (Suc 0)))\n 9. primerec\n     (Cn (Suc 0)\n       (Cn (Suc (Suc 0)) rec_add\n         [Cn (Suc (Suc 0)) rec_mult\n           [Cn (Suc (Suc 0))\n             (rec_maxr\n               (Cn (Suc (Suc (Suc 0))) rec_eq\n                 [Cn (Suc (Suc (Suc 0))) rec_mod\n                   [recf.id (Suc (Suc (Suc 0))) 0,\n                    Cn (Suc (Suc (Suc 0))) rec_power\n                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                      recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                   [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              recf.id (Suc (Suc 0)) 0],\n            Cn (Suc (Suc 0)) rec_conj\n             [Cn (Suc (Suc 0)) rec_less\n               [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n                recf.id (Suc (Suc 0)) 0],\n              Cn (Suc (Suc 0)) rec_less\n               [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n                recf.id (Suc (Suc 0)) (Suc 0)]]],\n          Cn (Suc (Suc 0)) rec_mult\n           [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n            Cn (Suc (Suc 0)) rec_minus\n             [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n              Cn (Suc (Suc 0)) rec_conj\n               [Cn (Suc (Suc 0)) rec_less\n                 [Cn (Suc (Suc 0)) (constn (Suc 0))\n                   [recf.id (Suc (Suc 0)) 0],\n                  recf.id (Suc (Suc 0)) 0],\n                Cn (Suc (Suc 0)) rec_less\n                 [Cn (Suc (Suc 0)) (constn (Suc 0))\n                   [recf.id (Suc (Suc 0)) 0],\n                  recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n       [recf.id (Suc 0) 0, constn (Pi (Suc 0))])\n     (Suc 0)\n 10. primerec\n      (Cn (Suc (Suc (Suc 0))) rec_add\n        [Cn (Suc (Suc (Suc 0))) rec_mult\n          [Cn (Suc (Suc (Suc 0)))\n            (Cn (Suc (Suc 0))\n              (Cn (Suc (Suc 0)) rec_add\n                [Cn (Suc (Suc 0)) rec_mult\n                  [Cn (Suc (Suc 0))\n                    (rec_maxr\n                      (Cn (Suc (Suc (Suc 0))) rec_eq\n                        [Cn (Suc (Suc (Suc 0))) rec_mod\n                          [recf.id (Suc (Suc (Suc 0))) 0,\n                           Cn (Suc (Suc (Suc 0))) rec_power\n                            [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                             recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                         Cn (Suc (Suc (Suc 0))) (constn 0)\n                          [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                    [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                     recf.id (Suc (Suc 0)) 0],\n                   Cn (Suc (Suc 0)) rec_conj\n                    [Cn (Suc (Suc 0)) rec_less\n                      [Cn (Suc (Suc 0)) (constn (Suc 0))\n                        [recf.id (Suc (Suc 0)) 0],\n                       recf.id (Suc (Suc 0)) 0],\n                     Cn (Suc (Suc 0)) rec_less\n                      [Cn (Suc (Suc 0)) (constn (Suc 0))\n                        [recf.id (Suc (Suc 0)) 0],\n                       recf.id (Suc (Suc 0)) (Suc 0)]]],\n                 Cn (Suc (Suc 0)) rec_mult\n                  [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n                   Cn (Suc (Suc 0)) rec_minus\n                    [Cn (Suc (Suc 0)) (constn (Suc 0))\n                      [recf.id (Suc (Suc 0)) 0],\n                     Cn (Suc (Suc 0)) rec_conj\n                      [Cn (Suc (Suc 0)) rec_less\n                        [Cn (Suc (Suc 0)) (constn (Suc 0))\n                          [recf.id (Suc (Suc 0)) 0],\n                         recf.id (Suc (Suc 0)) 0],\n                       Cn (Suc (Suc 0)) rec_less\n                        [Cn (Suc (Suc 0)) (constn (Suc 0))\n                          [recf.id (Suc (Suc 0)) 0],\n                         recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n              [recf.id (Suc (Suc 0)) 0,\n               Cn (Suc (Suc 0)) rec_pi\n                [Cn (Suc (Suc 0)) s [recf.id (Suc (Suc 0)) (Suc 0)]]])\n            [recf.id (Suc (Suc (Suc 0))) 0,\n             Cn (Suc (Suc (Suc 0))) rec_add\n              [Cn (Suc (Suc (Suc 0))) rec_mult\n                [Cn (Suc (Suc (Suc 0))) (constn 4)\n                  [recf.id (Suc (Suc (Suc 0))) 0],\n                 Cn (Suc (Suc (Suc 0))) rec_minus\n                  [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                   Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                    [recf.id (Suc (Suc (Suc 0))) 0]]],\n               Cn (Suc (Suc (Suc 0))) rec_add\n                [Cn (Suc (Suc (Suc 0))) rec_mult\n                  [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                    [recf.id (Suc (Suc (Suc 0))) 0],\n                   Cn (Suc (Suc (Suc 0))) rec_scan\n                    [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                 Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n                  [recf.id (Suc (Suc (Suc 0))) 0]]]],\n           Cn (Suc (Suc (Suc 0))) rec_noteq\n            [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]]],\n         Cn (Suc (Suc (Suc 0))) rec_mult\n          [Cn (Suc (Suc (Suc 0))) (constn 0)\n            [recf.id (Suc (Suc (Suc 0))) 0],\n           Cn (Suc (Suc (Suc 0))) rec_eq\n            [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n             Cn (Suc (Suc (Suc 0))) (constn 0)\n              [recf.id (Suc (Suc (Suc 0))) 0]]]])\n      (Suc (Suc (Suc 0)))", "apply(tactic \\<open>resolve_tac @{context} [@{thm prime_cn}, \n    @{thm prime_id}, @{thm prime_pr}] 1\\<close>;force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_newrght[intro]: \"primerec rec_newrght (Suc (Suc (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_newrght (Suc (Suc (Suc 0)))", "apply(simp add: rec_newrght_def rec_embranch.simps\n      Let_def arity.simps rec_newrgt0_def \n      rec_newrgt1_def rec_newrgt2_def rec_newrgt3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc (Suc 0))) rec_add\n       [Cn (Suc (Suc (Suc 0))) rec_mult\n         [Cn (Suc (Suc (Suc 0)))\n           (Cn (Suc (Suc 0)) rec_minus\n             [recf.id (Suc (Suc 0)) (Suc 0),\n              Cn (Suc (Suc 0)) rec_scan [recf.id (Suc (Suc 0)) (Suc 0)]])\n           [recf.id (Suc (Suc (Suc 0))) 0,\n            recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n          Cn (Suc (Suc (Suc 0))) rec_eq\n           [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n            Cn (Suc (Suc (Suc 0))) (constn 0)\n             [recf.id (Suc (Suc (Suc 0))) 0]]],\n        Cn (Suc (Suc (Suc 0))) rec_add\n         [Cn (Suc (Suc (Suc 0))) rec_mult\n           [Cn (Suc (Suc (Suc 0)))\n             (Cn (Suc (Suc 0)) rec_minus\n               [Cn (Suc (Suc 0)) rec_add\n                 [recf.id (Suc (Suc 0)) (Suc 0),\n                  Cn (Suc (Suc 0)) (constn (Suc 0))\n                   [recf.id (Suc (Suc 0)) 0]],\n                Cn (Suc (Suc 0)) rec_scan [recf.id (Suc (Suc 0)) (Suc 0)]])\n             [recf.id (Suc (Suc (Suc 0))) 0,\n              recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n            Cn (Suc (Suc (Suc 0))) rec_eq\n             [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n              Cn (Suc (Suc (Suc 0))) (constn (Suc 0))\n               [recf.id (Suc (Suc (Suc 0))) 0]]],\n          Cn (Suc (Suc (Suc 0))) rec_add\n           [Cn (Suc (Suc (Suc 0))) rec_mult\n             [Cn (Suc (Suc (Suc 0)))\n               (Cn (Suc (Suc 0)) rec_add\n                 [Cn (Suc (Suc 0)) rec_mult\n                   [Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n                     [recf.id (Suc (Suc 0)) 0],\n                    recf.id (Suc (Suc 0)) (Suc 0)],\n                  Cn (Suc (Suc 0)) rec_mod\n                   [recf.id (Suc (Suc 0)) 0,\n                    Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n                     [recf.id (Suc (Suc 0)) 0]]])\n               [recf.id (Suc (Suc (Suc 0))) 0,\n                recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n              Cn (Suc (Suc (Suc 0))) rec_eq\n               [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc 0)))\n                 [recf.id (Suc (Suc (Suc 0))) 0]]],\n            Cn (Suc (Suc (Suc 0))) rec_add\n             [Cn (Suc (Suc (Suc 0))) rec_mult\n               [Cn (Suc (Suc (Suc 0)))\n                 (Cn (Suc (Suc 0)) rec_quo\n                   [recf.id (Suc (Suc 0)) (Suc 0),\n                    Cn (Suc (Suc 0)) (constn (Suc (Suc 0)))\n                     [recf.id (Suc (Suc 0)) 0]])\n                 [recf.id (Suc (Suc (Suc 0))) 0,\n                  recf.id (Suc (Suc (Suc 0))) (Suc 0)],\n                Cn (Suc (Suc (Suc 0))) rec_eq\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0)),\n                  Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                   [recf.id (Suc (Suc (Suc 0))) 0]]],\n              Cn (Suc (Suc (Suc 0))) rec_add\n               [Cn (Suc (Suc (Suc 0))) rec_mult\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  Cn (Suc (Suc (Suc 0))) rec_less\n                   [Cn (Suc (Suc (Suc 0))) (constn (Suc (Suc (Suc 0))))\n                     [recf.id (Suc (Suc (Suc 0))) 0],\n                    recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                Cn (Suc (Suc (Suc 0))) z\n                 [recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]]]]]])\n     (Suc (Suc (Suc 0)))", "apply(tactic \\<open>resolve_tac @{context} [@{thm prime_cn}, \n    @{thm prime_id}, @{thm prime_pr}] 1\\<close>;force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma primerec_rec_newconf[intro]: \"primerec rec_newconf (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_newconf (Suc (Suc 0))", "apply(simp add: rec_newconf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Cn (Suc (Suc 0)) rec_trpl\n       [Cn (Suc (Suc 0)) rec_newleft\n         [Cn (Suc (Suc 0)) rec_left [recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0)) rec_right [recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0)) rec_actn\n           [recf.id (Suc (Suc 0)) 0,\n            Cn (Suc (Suc 0)) rec_stat [recf.id (Suc (Suc 0)) (Suc 0)],\n            Cn (Suc (Suc 0)) rec_right [recf.id (Suc (Suc 0)) (Suc 0)]]],\n        Cn (Suc (Suc 0)) rec_newstat\n         [recf.id (Suc (Suc 0)) 0,\n          Cn (Suc (Suc 0)) rec_stat [recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0)) rec_right [recf.id (Suc (Suc 0)) (Suc 0)]],\n        Cn (Suc (Suc 0)) rec_newrght\n         [Cn (Suc (Suc 0)) rec_left [recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0)) rec_right [recf.id (Suc (Suc 0)) (Suc 0)],\n          Cn (Suc (Suc 0)) rec_actn\n           [recf.id (Suc (Suc 0)) 0,\n            Cn (Suc (Suc 0)) rec_stat [recf.id (Suc (Suc 0)) (Suc 0)],\n            Cn (Suc (Suc 0)) rec_right [recf.id (Suc (Suc 0)) (Suc 0)]]]])\n     (Suc (Suc 0))", "by(tactic \\<open>resolve_tac @{context} [@{thm prime_cn}, \n    @{thm prime_id}, @{thm prime_pr}] 1\\<close>;force)"], ["", "lemma primerec_rec_conf[intro]: \"primerec rec_conf (Suc (Suc (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_conf (Suc (Suc (Suc 0)))", "apply(simp add: rec_conf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec\n     (Pr (Suc (Suc 0))\n       (Cn (Suc (Suc 0)) rec_trpl\n         [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n          Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n          recf.id (Suc (Suc 0)) (Suc 0)])\n       (Cn 4 rec_newconf [recf.id 4 0, recf.id 4 (Suc (Suc (Suc 0)))]))\n     (Suc (Suc (Suc 0)))", "by(tactic \\<open>resolve_tac @{context} [@{thm prime_cn}, \n    @{thm prime_id}, @{thm prime_pr}] 1\\<close>;force simp: numeral)"], ["", "lemma primerec_recs2[intro]:\n  \"primerec rec_lg (Suc (Suc 0))\"\n  \"primerec rec_nonstop (Suc (Suc (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_lg (Suc (Suc 0)) &&&\n    primerec rec_nonstop (Suc (Suc (Suc 0)))", "apply(simp_all add: rec_lg_def rec_nonstop_def rec_NSTD_def rec_stat_def\n      rec_lo_def Let_def rec_left_def rec_right_def rec_newconf_def\n      rec_newstat_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec\n     (Cn (Suc (Suc 0)) rec_add\n       [Cn (Suc (Suc 0)) rec_mult\n         [Cn (Suc (Suc 0)) rec_conj\n           [Cn (Suc (Suc 0)) rec_less\n             [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n              recf.id (Suc (Suc 0)) 0],\n            Cn (Suc (Suc 0)) rec_less\n             [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n              recf.id (Suc (Suc 0)) (Suc 0)]],\n          Cn (Suc (Suc 0))\n           (rec_maxr\n             (Cn (Suc (Suc (Suc 0))) rec_le\n               [Cn (Suc (Suc (Suc 0))) rec_power\n                 [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                  recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                recf.id (Suc (Suc (Suc 0))) 0]))\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            recf.id (Suc (Suc 0)) 0]],\n        Cn (Suc (Suc 0)) rec_mult\n         [Cn (Suc (Suc 0)) rec_not\n           [Cn (Suc (Suc 0)) rec_conj\n             [Cn (Suc (Suc 0)) rec_less\n               [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n                recf.id (Suc (Suc 0)) 0],\n              Cn (Suc (Suc 0)) rec_less\n               [Cn (Suc (Suc 0)) (constn (Suc 0)) [recf.id (Suc (Suc 0)) 0],\n                recf.id (Suc (Suc 0)) (Suc 0)]]],\n          Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0]]])\n     (Suc (Suc 0))\n 2. primerec\n     (Cn (Suc (Suc (Suc 0)))\n       (Cn (Suc 0) rec_disj\n         [Cn (Suc 0) rec_disj\n           [Cn (Suc 0) rec_disj\n             [Cn (Suc 0) rec_noteq\n               [Cn (Suc 0)\n                 (Cn (Suc (Suc 0)) rec_add\n                   [Cn (Suc (Suc 0)) rec_mult\n                     [Cn (Suc (Suc 0))\n                       (rec_maxr\n                         (Cn (Suc (Suc (Suc 0))) rec_eq\n                           [Cn (Suc (Suc (Suc 0))) rec_mod\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                            Cn (Suc (Suc (Suc 0))) (constn 0)\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0),\n                        recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_conj\n                       [Cn (Suc (Suc 0)) rec_less\n                         [Cn (Suc (Suc 0)) (constn (Suc 0))\n                           [recf.id (Suc (Suc 0)) 0],\n                          recf.id (Suc (Suc 0)) 0],\n                        Cn (Suc (Suc 0)) rec_less\n                         [Cn (Suc (Suc 0)) (constn (Suc 0))\n                           [recf.id (Suc (Suc 0)) 0],\n                          recf.id (Suc (Suc 0)) (Suc 0)]]],\n                    Cn (Suc (Suc 0)) rec_mult\n                     [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_minus\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        Cn (Suc (Suc 0)) rec_conj\n                         [Cn (Suc (Suc 0)) rec_less\n                           [Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0],\n                            recf.id (Suc (Suc 0)) 0],\n                          Cn (Suc (Suc 0)) rec_less\n                           [Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0],\n                            recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n                 [recf.id (Suc 0) 0, constn (Pi (Suc 0))],\n                constn 0],\n              Cn (Suc 0) rec_noteq\n               [Cn (Suc 0)\n                 (Cn (Suc (Suc 0)) rec_add\n                   [Cn (Suc (Suc 0)) rec_mult\n                     [Cn (Suc (Suc 0))\n                       (rec_maxr\n                         (Cn (Suc (Suc (Suc 0))) rec_eq\n                           [Cn (Suc (Suc (Suc 0))) rec_mod\n                             [recf.id (Suc (Suc (Suc 0))) 0,\n                              Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                            Cn (Suc (Suc (Suc 0))) (constn 0)\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0),\n                        recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_conj\n                       [Cn (Suc (Suc 0)) rec_less\n                         [Cn (Suc (Suc 0)) (constn (Suc 0))\n                           [recf.id (Suc (Suc 0)) 0],\n                          recf.id (Suc (Suc 0)) 0],\n                        Cn (Suc (Suc 0)) rec_less\n                         [Cn (Suc (Suc 0)) (constn (Suc 0))\n                           [recf.id (Suc (Suc 0)) 0],\n                          recf.id (Suc (Suc 0)) (Suc 0)]]],\n                    Cn (Suc (Suc 0)) rec_mult\n                     [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_minus\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        Cn (Suc (Suc 0)) rec_conj\n                         [Cn (Suc (Suc 0)) rec_less\n                           [Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0],\n                            recf.id (Suc (Suc 0)) 0],\n                          Cn (Suc (Suc 0)) rec_less\n                           [Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0],\n                            recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n                 [recf.id (Suc 0) 0, constn (Pi 0)],\n                constn 0]],\n            Cn (Suc 0) rec_noteq\n             [Cn (Suc 0)\n               (Cn (Suc (Suc 0)) rec_add\n                 [Cn (Suc (Suc 0)) rec_mult\n                   [Cn (Suc (Suc 0))\n                     (rec_maxr\n                       (Cn (Suc (Suc (Suc 0))) rec_eq\n                         [Cn (Suc (Suc (Suc 0))) rec_mod\n                           [recf.id (Suc (Suc (Suc 0))) 0,\n                            Cn (Suc (Suc (Suc 0))) rec_power\n                             [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                              recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                          Cn (Suc (Suc (Suc 0))) (constn 0)\n                           [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0),\n                      recf.id (Suc (Suc 0)) 0],\n                    Cn (Suc (Suc 0)) rec_conj\n                     [Cn (Suc (Suc 0)) rec_less\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_less\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        recf.id (Suc (Suc 0)) (Suc 0)]]],\n                  Cn (Suc (Suc 0)) rec_mult\n                   [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n                    Cn (Suc (Suc 0)) rec_minus\n                     [Cn (Suc (Suc 0)) (constn (Suc 0))\n                       [recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_conj\n                       [Cn (Suc (Suc 0)) rec_less\n                         [Cn (Suc (Suc 0)) (constn (Suc 0))\n                           [recf.id (Suc (Suc 0)) 0],\n                          recf.id (Suc (Suc 0)) 0],\n                        Cn (Suc (Suc 0)) rec_less\n                         [Cn (Suc (Suc 0)) (constn (Suc 0))\n                           [recf.id (Suc (Suc 0)) 0],\n                          recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n               [recf.id (Suc 0) 0, constn (Pi (Suc (Suc 0)))],\n              Cn (Suc 0) rec_minus\n               [Cn (Suc 0) rec_power\n                 [constn (Suc (Suc 0)),\n                  Cn (Suc 0)\n                   (Cn (Suc (Suc 0)) rec_add\n                     [Cn (Suc (Suc 0)) rec_mult\n                       [Cn (Suc (Suc 0)) rec_conj\n                         [Cn (Suc (Suc 0)) rec_less\n                           [Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0],\n                            recf.id (Suc (Suc 0)) 0],\n                          Cn (Suc (Suc 0)) rec_less\n                           [Cn (Suc (Suc 0)) (constn (Suc 0))\n                             [recf.id (Suc (Suc 0)) 0],\n                            recf.id (Suc (Suc 0)) (Suc 0)]],\n                        Cn (Suc (Suc 0))\n                         (rec_maxr\n                           (Cn (Suc (Suc (Suc 0))) rec_le\n                             [Cn (Suc (Suc (Suc 0))) rec_power\n                               [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                                recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))],\n                              recf.id (Suc (Suc (Suc 0))) 0]))\n                         [recf.id (Suc (Suc 0)) 0,\n                          recf.id (Suc (Suc 0)) (Suc 0),\n                          recf.id (Suc (Suc 0)) 0]],\n                      Cn (Suc (Suc 0)) rec_mult\n                       [Cn (Suc (Suc 0)) rec_not\n                         [Cn (Suc (Suc 0)) rec_conj\n                           [Cn (Suc (Suc 0)) rec_less\n                             [Cn (Suc (Suc 0)) (constn (Suc 0))\n                               [recf.id (Suc (Suc 0)) 0],\n                              recf.id (Suc (Suc 0)) 0],\n                            Cn (Suc (Suc 0)) rec_less\n                             [Cn (Suc (Suc 0)) (constn (Suc 0))\n                               [recf.id (Suc (Suc 0)) 0],\n                              recf.id (Suc (Suc 0)) (Suc 0)]]],\n                        Cn (Suc (Suc 0)) (constn 0)\n                         [recf.id (Suc (Suc 0)) 0]]])\n                   [Cn (Suc 0) rec_add\n                     [Cn (Suc 0)\n                       (Cn (Suc (Suc 0)) rec_add\n                         [Cn (Suc (Suc 0)) rec_mult\n                           [Cn (Suc (Suc 0))\n                             (rec_maxr\n                               (Cn (Suc (Suc (Suc 0))) rec_eq\n                                 [Cn (Suc (Suc (Suc 0))) rec_mod\n                                   [recf.id (Suc (Suc (Suc 0))) 0,\n                                    Cn (Suc (Suc (Suc 0))) rec_power\n                                     [recf.id (Suc (Suc (Suc 0))) (Suc 0),\nrecf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                                  Cn (Suc (Suc (Suc 0))) (constn 0)\n                                   [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                             [recf.id (Suc (Suc 0)) 0,\n                              recf.id (Suc (Suc 0)) (Suc 0),\n                              recf.id (Suc (Suc 0)) 0],\n                            Cn (Suc (Suc 0)) rec_conj\n                             [Cn (Suc (Suc 0)) rec_less\n                               [Cn (Suc (Suc 0)) (constn (Suc 0))\n                                 [recf.id (Suc (Suc 0)) 0],\n                                recf.id (Suc (Suc 0)) 0],\n                              Cn (Suc (Suc 0)) rec_less\n                               [Cn (Suc (Suc 0)) (constn (Suc 0))\n                                 [recf.id (Suc (Suc 0)) 0],\n                                recf.id (Suc (Suc 0)) (Suc 0)]]],\n                          Cn (Suc (Suc 0)) rec_mult\n                           [Cn (Suc (Suc 0)) (constn 0)\n                             [recf.id (Suc (Suc 0)) 0],\n                            Cn (Suc (Suc 0)) rec_minus\n                             [Cn (Suc (Suc 0)) (constn (Suc 0))\n                               [recf.id (Suc (Suc 0)) 0],\n                              Cn (Suc (Suc 0)) rec_conj\n                               [Cn (Suc (Suc 0)) rec_less\n                                 [Cn (Suc (Suc 0)) (constn (Suc 0))\n                                   [recf.id (Suc (Suc 0)) 0],\n                                  recf.id (Suc (Suc 0)) 0],\n                                Cn (Suc (Suc 0)) rec_less\n                                 [Cn (Suc (Suc 0)) (constn (Suc 0))\n                                   [recf.id (Suc (Suc 0)) 0],\n                                  recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n                       [recf.id (Suc 0) 0, constn (Pi (Suc (Suc 0)))],\n                      constn (Suc 0)],\n                    constn (Suc (Suc 0))]],\n                constn (Suc 0)]]],\n          Cn (Suc 0) rec_eq\n           [Cn (Suc 0)\n             (Cn (Suc (Suc 0)) rec_add\n               [Cn (Suc (Suc 0)) rec_mult\n                 [Cn (Suc (Suc 0))\n                   (rec_maxr\n                     (Cn (Suc (Suc (Suc 0))) rec_eq\n                       [Cn (Suc (Suc (Suc 0))) rec_mod\n                         [recf.id (Suc (Suc (Suc 0))) 0,\n                          Cn (Suc (Suc (Suc 0))) rec_power\n                           [recf.id (Suc (Suc (Suc 0))) (Suc 0),\n                            recf.id (Suc (Suc (Suc 0))) (Suc (Suc 0))]],\n                        Cn (Suc (Suc (Suc 0))) (constn 0)\n                         [recf.id (Suc (Suc (Suc 0))) (Suc 0)]]))\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    recf.id (Suc (Suc 0)) 0],\n                  Cn (Suc (Suc 0)) rec_conj\n                   [Cn (Suc (Suc 0)) rec_less\n                     [Cn (Suc (Suc 0)) (constn (Suc 0))\n                       [recf.id (Suc (Suc 0)) 0],\n                      recf.id (Suc (Suc 0)) 0],\n                    Cn (Suc (Suc 0)) rec_less\n                     [Cn (Suc (Suc 0)) (constn (Suc 0))\n                       [recf.id (Suc (Suc 0)) 0],\n                      recf.id (Suc (Suc 0)) (Suc 0)]]],\n                Cn (Suc (Suc 0)) rec_mult\n                 [Cn (Suc (Suc 0)) (constn 0) [recf.id (Suc (Suc 0)) 0],\n                  Cn (Suc (Suc 0)) rec_minus\n                   [Cn (Suc (Suc 0)) (constn (Suc 0))\n                     [recf.id (Suc (Suc 0)) 0],\n                    Cn (Suc (Suc 0)) rec_conj\n                     [Cn (Suc (Suc 0)) rec_less\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        recf.id (Suc (Suc 0)) 0],\n                      Cn (Suc (Suc 0)) rec_less\n                       [Cn (Suc (Suc 0)) (constn (Suc 0))\n                         [recf.id (Suc (Suc 0)) 0],\n                        recf.id (Suc (Suc 0)) (Suc 0)]]]]])\n             [recf.id (Suc 0) 0, constn (Pi (Suc (Suc 0)))],\n            constn 0]])\n       [rec_conf])\n     (Suc (Suc (Suc 0)))", "by(tactic \\<open>resolve_tac @{context} [@{thm prime_cn}, \n    @{thm prime_id}, @{thm prime_pr}] 1\\<close>;fastforce)+"], ["", "lemma primerec_terminate: \n  \"\\<lbrakk>primerec f x; length xs = x\\<rbrakk> \\<Longrightarrow> terminate f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>primerec f x; length xs = x\\<rbrakk>\n    \\<Longrightarrow> terminate f xs", "proof(induct arbitrary: xs rule: primerec.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate z xs\n 2. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 3. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 4. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 5. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "fix xs"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate z xs\n 2. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 3. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 4. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 5. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "assume \"length (xs::nat list) = Suc 0\""], ["proof (state)\nthis:\n  length xs = Suc 0\n\ngoal (5 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate z xs\n 2. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 3. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 4. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 5. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "thus \"terminate z xs\""], ["proof (prove)\nusing this:\n  length xs = Suc 0\n\ngoal (1 subgoal):\n 1. terminate z xs", "by(cases xs, auto intro: termi_z)"], ["proof (state)\nthis:\n  terminate z xs\n\ngoal (4 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 2. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 3. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 4. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 2. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 3. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 4. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "fix xs"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 2. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 3. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 4. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "assume \"length (xs::nat list) = Suc 0\""], ["proof (state)\nthis:\n  length xs = Suc 0\n\ngoal (4 subgoals):\n 1. \\<And>xs. length xs = Suc 0 \\<Longrightarrow> terminate s xs\n 2. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 3. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 4. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "thus \"terminate s xs\""], ["proof (prove)\nusing this:\n  length xs = Suc 0\n\ngoal (1 subgoal):\n 1. terminate s xs", "by(cases xs, auto intro: termi_s)"], ["proof (state)\nthis:\n  terminate s xs\n\ngoal (3 subgoals):\n 1. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 2. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 3. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 2. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 3. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "fix n m xs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 2. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 3. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "assume \"n < m\" \"length (xs::nat list) = m\""], ["proof (state)\nthis:\n  n < m\n  length xs = m\n\ngoal (3 subgoals):\n 1. \\<And>n m xs.\n       \\<lbrakk>n < m; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (recf.id m n) xs\n 2. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 3. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "thus \"terminate (id m n) xs\""], ["proof (prove)\nusing this:\n  n < m\n  length xs = m\n\ngoal (1 subgoal):\n 1. terminate (recf.id m n) xs", "by(erule_tac termi_id, simp)"], ["proof (state)\nthis:\n  terminate (recf.id m n) xs\n\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "fix f k gs m n xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "assume ind: \"\\<forall>i<length gs. primerec (gs ! i) m \\<and> (\\<forall>x. length x = m \\<longrightarrow> terminate (gs ! i) x)\"\n    and ind2: \"\\<And> xs. length xs = k \\<Longrightarrow> terminate f xs\"\n    and h: \"primerec f k\"  \"length gs = k\" \"m = n\" \"length (xs::nat list) = m\""], ["proof (state)\nthis:\n  \\<forall>i<length gs.\n     primerec (gs ! i) m \\<and>\n     (\\<forall>x. length x = m \\<longrightarrow> terminate (gs ! i) x)\n  length ?xs = k \\<Longrightarrow> terminate f ?xs\n  primerec f k\n  length gs = k\n  m = n\n  length xs = m\n\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "have \"terminate f (map (\\<lambda>g. rec_exec g xs) gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate f (map (\\<lambda>g. rec_exec g xs) gs)", "using ind2[of \"(map (\\<lambda>g. rec_exec g xs) gs)\"] h"], ["proof (prove)\nusing this:\n  length (map (\\<lambda>g. rec_exec g xs) gs) = k \\<Longrightarrow>\n  terminate f (map (\\<lambda>g. rec_exec g xs) gs)\n  primerec f k\n  length gs = k\n  m = n\n  length xs = m\n\ngoal (1 subgoal):\n 1. terminate f (map (\\<lambda>g. rec_exec g xs) gs)", "by simp"], ["proof (state)\nthis:\n  terminate f (map (\\<lambda>g. rec_exec g xs) gs)\n\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "moreover"], ["proof (state)\nthis:\n  terminate f (map (\\<lambda>g. rec_exec g xs) gs)\n\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "have \"\\<forall>g\\<in>set gs. terminate g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set gs. terminate g xs", "using ind h"], ["proof (prove)\nusing this:\n  \\<forall>i<length gs.\n     primerec (gs ! i) m \\<and>\n     (\\<forall>x. length x = m \\<longrightarrow> terminate (gs ! i) x)\n  primerec f k\n  length gs = k\n  m = n\n  length xs = m\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set gs. terminate g xs", "by(auto simp: set_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set gs. terminate g xs\n\ngoal (2 subgoals):\n 1. \\<And>f k gs m n xs.\n       \\<lbrakk>primerec f k;\n        \\<And>xs. length xs = k \\<Longrightarrow> terminate f xs;\n        length gs = k;\n        \\<forall>i<length gs.\n           primerec (gs ! i) m \\<and>\n           (\\<forall>x.\n               length x = m \\<longrightarrow> terminate (gs ! i) x);\n        m = n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Cn n f gs) xs\n 2. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "ultimately"], ["proof (chain)\npicking this:\n  terminate f (map (\\<lambda>g. rec_exec g xs) gs)\n  \\<forall>g\\<in>set gs. terminate g xs", "show \"terminate (Cn n f gs) xs\""], ["proof (prove)\nusing this:\n  terminate f (map (\\<lambda>g. rec_exec g xs) gs)\n  \\<forall>g\\<in>set gs. terminate g xs\n\ngoal (1 subgoal):\n 1. terminate (Cn n f gs) xs", "using h"], ["proof (prove)\nusing this:\n  terminate f (map (\\<lambda>g. rec_exec g xs) gs)\n  \\<forall>g\\<in>set gs. terminate g xs\n  primerec f k\n  length gs = k\n  m = n\n  length xs = m\n\ngoal (1 subgoal):\n 1. terminate (Cn n f gs) xs", "by(rule_tac termi_cn, auto)"], ["proof (state)\nthis:\n  terminate (Cn n f gs) xs\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "fix f n g m xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "assume ind1: \"\\<And>xs. length xs = n \\<Longrightarrow> terminate f xs\"\n    and ind2: \"\\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs\"\n    and h: \"primerec f n\" \" primerec g (Suc (Suc n))\" \" m = Suc n\" \"length (xs::nat list) = m\""], ["proof (state)\nthis:\n  length ?xs = n \\<Longrightarrow> terminate f ?xs\n  length ?xs = Suc (Suc n) \\<Longrightarrow> terminate g ?xs\n  primerec f n\n  primerec g (Suc (Suc n))\n  m = Suc n\n  length xs = m\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "have \"\\<forall>y<last xs. terminate g (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y<last xs.\n       terminate g\n        (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])", "using h ind2"], ["proof (prove)\nusing this:\n  primerec f n\n  primerec g (Suc (Suc n))\n  m = Suc n\n  length xs = m\n  length ?xs = Suc (Suc n) \\<Longrightarrow> terminate g ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>y<last xs.\n       terminate g\n        (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>y<last xs.\n     terminate g (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "moreover"], ["proof (state)\nthis:\n  \\<forall>y<last xs.\n     terminate g (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "have \"terminate f (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate f (butlast xs)", "using ind1[of \"butlast xs\"] h"], ["proof (prove)\nusing this:\n  length (butlast xs) = n \\<Longrightarrow> terminate f (butlast xs)\n  primerec f n\n  primerec g (Suc (Suc n))\n  m = Suc n\n  length xs = m\n\ngoal (1 subgoal):\n 1. terminate f (butlast xs)", "by simp"], ["proof (state)\nthis:\n  terminate f (butlast xs)\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "moreover"], ["proof (state)\nthis:\n  terminate f (butlast xs)\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "have \"length (butlast xs) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (butlast xs) = n", "using h"], ["proof (prove)\nusing this:\n  primerec f n\n  primerec g (Suc (Suc n))\n  m = Suc n\n  length xs = m\n\ngoal (1 subgoal):\n 1. length (butlast xs) = n", "by simp"], ["proof (state)\nthis:\n  length (butlast xs) = n\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y<last xs.\n     terminate g (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])\n  terminate f (butlast xs)\n  length (butlast xs) = n", "have \"terminate (Pr n f g) (butlast xs @ [last xs])\""], ["proof (prove)\nusing this:\n  \\<forall>y<last xs.\n     terminate g (butlast xs @ [y, rec_exec (Pr n f g) (butlast xs @ [y])])\n  terminate f (butlast xs)\n  length (butlast xs) = n\n\ngoal (1 subgoal):\n 1. terminate (Pr n f g) (butlast xs @ [last xs])", "by(rule_tac termi_pr, simp_all)"], ["proof (state)\nthis:\n  terminate (Pr n f g) (butlast xs @ [last xs])\n\ngoal (1 subgoal):\n 1. \\<And>f n g m xs.\n       \\<lbrakk>primerec f n;\n        \\<And>xs. length xs = n \\<Longrightarrow> terminate f xs;\n        primerec g (Suc (Suc n));\n        \\<And>xs. length xs = Suc (Suc n) \\<Longrightarrow> terminate g xs;\n        m = Suc n; length xs = m\\<rbrakk>\n       \\<Longrightarrow> terminate (Pr n f g) xs", "thus \"terminate (Pr n f g) xs\""], ["proof (prove)\nusing this:\n  terminate (Pr n f g) (butlast xs @ [last xs])\n\ngoal (1 subgoal):\n 1. terminate (Pr n f g) xs", "using h"], ["proof (prove)\nusing this:\n  terminate (Pr n f g) (butlast xs @ [last xs])\n  primerec f n\n  primerec g (Suc (Suc n))\n  m = Suc n\n  length xs = m\n\ngoal (1 subgoal):\n 1. terminate (Pr n f g) xs", "by(cases \"xs = []\", auto)"], ["proof (state)\nthis:\n  terminate (Pr n f g) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following lemma gives the correctness of \\<open>rec_halt\\<close>.\n  It says: if \\<open>rec_halt\\<close> calculates that the TM coded by \\<open>m\\<close>\n  will reach a standard final configuration after \\<open>t\\<close> steps of execution, then it is indeed so.\n\\<close>"], ["", "text \\<open>F: universal machine\\<close>"], ["", "text \\<open>\n  \\<open>valu r\\<close> extracts computing result out of the right number \\<open>r\\<close>.\n\\<close>"], ["", "fun valu :: \"nat \\<Rightarrow> nat\"\n  where\n    \"valu r = (lg (r + 1) 2) - 1\""], ["", "text \\<open>\n  \\<open>rec_valu\\<close> is the recursive function implementing \\<open>valu\\<close>.\n\\<close>"], ["", "definition rec_valu :: \"recf\"\n  where\n    \"rec_valu = Cn 1 rec_minus [Cn 1 rec_lg [s, constn 2], constn 1]\""], ["", "text \\<open>\n  The correctness of \\<open>rec_valu\\<close>.\n\\<close>"], ["", "lemma value_lemma: \"rec_exec rec_valu [r] = valu r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_valu [r] = valu r", "by(simp add: rec_exec.simps rec_valu_def lg_lemma)"], ["", "lemma primerec_rec_valu_1[intro]: \"primerec rec_valu (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_valu (Suc 0)", "unfolding rec_valu_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec (Cn 1 rec_minus [Cn 1 rec_lg [s, constn 2], constn 1]) (Suc 0)", "apply(rule prime_cn[of _ \"Suc (Suc 0)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. primerec rec_minus (Suc (Suc 0))\n 2. length [Cn 1 rec_lg [s, constn 2], constn 1] = Suc (Suc 0)\n 3. \\<forall>i<length [Cn 1 rec_lg [s, constn 2], constn 1].\n       primerec ([Cn 1 rec_lg [s, constn 2], constn 1] ! i) (Suc 0)\n 4. Suc 0 = 1", "by auto auto"], ["", "declare valu.simps[simp del]"], ["", "text \\<open>\n  The definition of the universal function \\<open>rec_F\\<close>.\n\\<close>"], ["", "definition rec_F :: \"recf\"\n  where\n    \"rec_F = Cn (Suc (Suc 0)) rec_valu [Cn (Suc (Suc 0)) rec_right [Cn (Suc (Suc 0))\n rec_conf ([id (Suc (Suc 0)) 0, id (Suc (Suc 0)) (Suc 0), rec_halt])]]\""], ["", "lemma terminate_halt_lemma: \n  \"\\<lbrakk>rec_exec rec_nonstop ([m, r] @ [t]) = 0; \n     \\<forall>i<t. 0 < rec_exec rec_nonstop ([m, r] @ [i])\\<rbrakk> \\<Longrightarrow> terminate rec_halt [m, r]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rec_exec rec_nonstop ([m, r] @ [t]) = 0;\n     \\<forall>i<t. 0 < rec_exec rec_nonstop ([m, r] @ [i])\\<rbrakk>\n    \\<Longrightarrow> terminate rec_halt [m, r]", "apply(simp add: rec_halt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rec_exec rec_nonstop [m, r, t] = 0;\n     \\<forall>i<t. 0 < rec_exec rec_nonstop [m, r, i]\\<rbrakk>\n    \\<Longrightarrow> terminate (Mn (Suc (Suc 0)) rec_nonstop) [m, r]", "apply(rule termi_mn, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rec_exec rec_nonstop [m, r, t] = 0;\n     \\<forall>i<t. 0 < rec_exec rec_nonstop [m, r, i]\\<rbrakk>\n    \\<Longrightarrow> terminate rec_nonstop [m, r, t]\n 2. \\<And>i.\n       \\<lbrakk>rec_exec rec_nonstop [m, r, t] = 0;\n        \\<forall>i<t. 0 < rec_exec rec_nonstop [m, r, i]; i < t\\<rbrakk>\n       \\<Longrightarrow> terminate rec_nonstop [m, r, i]", "by(rule primerec_terminate; auto)+"], ["", "text \\<open>\n  The correctness of \\<open>rec_F\\<close>, halt case.\n\\<close>"], ["", "lemma F_lemma: \"rec_exec rec_halt [m, r] = t \\<Longrightarrow> rec_exec rec_F [m, r] = (valu (rght (conf m r t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_halt [m, r] = t \\<Longrightarrow>\n    rec_exec rec_F [m, r] = valu (rght (conf m r t))", "by(simp add: rec_F_def rec_exec.simps value_lemma right_lemma conf_lemma halt_lemma)"], ["", "lemma terminate_F_lemma: \"terminate rec_halt [m, r] \\<Longrightarrow> terminate rec_F [m, r]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_halt [m, r] \\<Longrightarrow> terminate rec_F [m, r]", "apply(simp add: rec_F_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]])\n     [m, r]", "apply(rule termi_cn, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate rec_valu\n     [rec_exec\n       (Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]])\n       [m, r]]\n 2. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate\n     (Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]])\n     [m, r]", "apply(rule primerec_terminate, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate\n     (Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]])\n     [m, r]", "apply(rule termi_cn, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate rec_right\n     [rec_exec\n       (Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt])\n       [m, r]]\n 2. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate\n     (Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt])\n     [m, r]", "apply(rule primerec_terminate, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate\n     (Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt])\n     [m, r]", "apply(rule termi_cn, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate rec_conf\n     [rec_exec (recf.id (Suc (Suc 0)) 0) [m, r],\n      rec_exec (recf.id (Suc (Suc 0)) (Suc 0)) [m, r],\n      rec_exec rec_halt [m, r]]\n 2. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate (recf.id (Suc (Suc 0)) 0) [m, r]\n 3. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate (recf.id (Suc (Suc 0)) (Suc 0)) [m, r]", "apply(rule primerec_terminate, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate (recf.id (Suc (Suc 0)) 0) [m, r]\n 2. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate (recf.id (Suc (Suc 0)) (Suc 0)) [m, r]", "apply(rule termi_id;force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_halt [m, r] \\<Longrightarrow>\n    terminate (recf.id (Suc (Suc 0)) (Suc 0)) [m, r]", "apply(rule termi_id;force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correctness of \\<open>rec_F\\<close>, nonhalt case.\n\\<close>"], ["", "subsection \\<open>Coding function of TMs\\<close>"], ["", "text \\<open>\n  The purpose of this section is to get the coding function of Turing Machine, which is \n  going to be named \\<open>code\\<close>.\n\\<close>"], ["", "fun bl2nat :: \"cell list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"bl2nat [] n = 0\"\n  | \"bl2nat (Bk#bl) n = bl2nat bl (Suc n)\"\n  | \"bl2nat (Oc#bl) n = 2^n + bl2nat bl (Suc n)\""], ["", "fun bl2wc :: \"cell list \\<Rightarrow> nat\"\n  where\n    \"bl2wc xs = bl2nat xs 0\""], ["", "fun trpl_code :: \"config \\<Rightarrow> nat\"\n  where\n    \"trpl_code (st, l, r) = trpl (bl2wc l) st (bl2wc r)\""], ["", "declare bl2nat.simps[simp del] bl2wc.simps[simp del]\n  trpl_code.simps[simp del]"], ["", "fun action_map :: \"action \\<Rightarrow> nat\"\n  where\n    \"action_map W0 = 0\"\n  | \"action_map W1 = 1\"\n  | \"action_map L = 2\"\n  | \"action_map R = 3\"\n  | \"action_map Nop = 4\""], ["", "fun action_map_iff :: \"nat \\<Rightarrow> action\"\n  where\n    \"action_map_iff (0::nat) = W0\"\n  | \"action_map_iff (Suc 0) = W1\"\n  | \"action_map_iff (Suc (Suc 0)) = L\"\n  | \"action_map_iff (Suc (Suc (Suc 0))) = R\"\n  | \"action_map_iff n = Nop\""], ["", "fun block_map :: \"cell \\<Rightarrow> nat\"\n  where\n    \"block_map Bk = 0\"\n  | \"block_map Oc = 1\""], ["", "fun godel_code' :: \"nat list \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"godel_code' [] n = 1\"\n  | \"godel_code' (x#xs) n = (Pi n)^x * godel_code' xs (Suc n) \""], ["", "fun godel_code :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"godel_code xs = (let lh = length xs in \n                   2^lh * (godel_code' xs (Suc 0)))\""], ["", "fun modify_tprog :: \"instr list \\<Rightarrow> nat list\"\n  where\n    \"modify_tprog [] =  []\"\n  | \"modify_tprog ((ac, ns)#nl) = action_map ac # ns # modify_tprog nl\""], ["", "text \\<open>\n  \\<open>code tp\\<close> gives the Godel coding of TM program \\<open>tp\\<close>.\n\\<close>"], ["", "fun code :: \"instr list \\<Rightarrow> nat\"\n  where \n    \"code tp = (let nl = modify_tprog tp in \n              godel_code nl)\""], ["", "subsection \\<open>Relating interperter functions to the execution of TMs\\<close>"], ["", "lemma bl2wc_0[simp]: \"bl2wc [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc [] = 0", "by(simp add: bl2wc.simps bl2nat.simps)"], ["", "lemma fetch_action_map_4[simp]: \"\\<lbrakk>fetch tp 0 b = (nact, ns)\\<rbrakk> \\<Longrightarrow> action_map nact = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch tp 0 b = (nact, ns) \\<Longrightarrow> action_map nact = 4", "apply(simp add: fetch.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Pi_gr_1[simp]: \"Pi n > Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < Pi n", "proof(induct n, auto simp: Pi.simps Np.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc 0 < Pi n \\<Longrightarrow>\n       Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc 0 < Pi n \\<Longrightarrow>\n       Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "let ?setx = \"{y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc 0 < Pi n \\<Longrightarrow>\n       Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "have \"finite ?setx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "by auto"], ["proof (state)\nthis:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc 0 < Pi n \\<Longrightarrow>\n       Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "moreover"], ["proof (state)\nthis:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc 0 < Pi n \\<Longrightarrow>\n       Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "have \"?setx \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}", "using prime_ex[of \"Pi n\"]"], ["proof (prove)\nusing this:\n  \\<exists>p>Pi n. p \\<le> Suc (Pi n!) \\<and> Prime p\n\ngoal (1 subgoal):\n 1. {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc 0 < Pi n \\<Longrightarrow>\n       Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "ultimately"], ["proof (chain)\npicking this:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n  {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}", "show \"Suc 0 < Min ?setx\""], ["proof (prove)\nusing this:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n  {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "apply(simp add: Min_gr_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>Pi n. x \\<le> Suc (Pi n!) \\<and> Prime x \\<Longrightarrow>\n    \\<forall>x.\n       x \\<le> Suc (Pi n!) \\<and> Pi n < x \\<and> Prime x \\<longrightarrow>\n       Suc 0 < x", "apply(auto simp: Prime.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Suc 0 < Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pi_not_0[simp]: \"Pi n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Pi n", "using Pi_gr_1[of n]"], ["proof (prove)\nusing this:\n  Suc 0 < Pi n\n\ngoal (1 subgoal):\n 1. 0 < Pi n", "by arith"], ["", "declare godel_code.simps[simp del]"], ["", "lemma godel_code'_nonzero[simp]: \"0 < godel_code' nl n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < godel_code' nl n", "apply(induct nl arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. 0 < godel_code' [] n\n 2. \\<And>a nl n.\n       (\\<And>n. 0 < godel_code' nl n) \\<Longrightarrow>\n       0 < godel_code' (a # nl) n", "apply(auto simp: godel_code'.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma godel_code_great: \"godel_code nl > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < godel_code nl", "apply(simp add: godel_code.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma godel_code_eq_1: \"(godel_code nl = 1) = (nl = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (godel_code nl = 1) = (nl = [])", "apply(auto simp: godel_code.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma godel_code_1_iff[elim]: \n  \"\\<lbrakk>i < length nl; \\<not> Suc 0 < godel_code nl\\<rbrakk> \\<Longrightarrow> nl ! i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl; \\<not> Suc 0 < godel_code nl\\<rbrakk>\n    \\<Longrightarrow> nl ! i = 0", "using godel_code_great[of nl] godel_code_eq_1[of nl]"], ["proof (prove)\nusing this:\n  0 < godel_code nl\n  (godel_code nl = 1) = (nl = [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl; \\<not> Suc 0 < godel_code nl\\<rbrakk>\n    \\<Longrightarrow> nl ! i = 0", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prime_coprime: \"\\<lbrakk>Prime x; Prime y; x\\<noteq>y\\<rbrakk> \\<Longrightarrow> coprime x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Prime x; Prime y; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> coprime x y", "proof (simp only: Prime.simps coprime_def, auto simp: dvd_def,\n    rule_tac classical, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c k ka.\n       \\<lbrakk>Suc 0 < c * k;\n        \\<forall>u<c * k. \\<forall>v<c * k. u * v \\<noteq> c * k;\n        Suc 0 < c * ka;\n        \\<forall>u<c * ka. \\<forall>v<c * ka. u * v \\<noteq> c * ka;\n        x = c * k; y = c * ka; k \\<noteq> ka; 0 < c;\n        c \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "fix d k ka"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c k ka.\n       \\<lbrakk>Suc 0 < c * k;\n        \\<forall>u<c * k. \\<forall>v<c * k. u * v \\<noteq> c * k;\n        Suc 0 < c * ka;\n        \\<forall>u<c * ka. \\<forall>v<c * ka. u * v \\<noteq> c * ka;\n        x = c * k; y = c * ka; k \\<noteq> ka; 0 < c;\n        c \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "assume case_ka: \"\\<forall>u<d * ka. \\<forall>v<d * ka. u * v \\<noteq> d * ka\" \n    and case_k: \"\\<forall>u<d * k. \\<forall>v<d * k. u * v \\<noteq> d * k\"\n    and h: \"(0::nat) < d\" \"d \\<noteq> Suc 0\" \"Suc 0 < d * ka\" \n    \"ka \\<noteq> k\" \"Suc 0 < d * k\""], ["proof (state)\nthis:\n  \\<forall>u<d * ka. \\<forall>v<d * ka. u * v \\<noteq> d * ka\n  \\<forall>u<d * k. \\<forall>v<d * k. u * v \\<noteq> d * k\n  0 < d\n  d \\<noteq> Suc 0\n  Suc 0 < d * ka\n  ka \\<noteq> k\n  Suc 0 < d * k\n\ngoal (1 subgoal):\n 1. \\<And>c k ka.\n       \\<lbrakk>Suc 0 < c * k;\n        \\<forall>u<c * k. \\<forall>v<c * k. u * v \\<noteq> c * k;\n        Suc 0 < c * ka;\n        \\<forall>u<c * ka. \\<forall>v<c * ka. u * v \\<noteq> c * ka;\n        x = c * k; y = c * ka; k \\<noteq> ka; 0 < c;\n        c \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "from h"], ["proof (chain)\npicking this:\n  0 < d\n  d \\<noteq> Suc 0\n  Suc 0 < d * ka\n  ka \\<noteq> k\n  Suc 0 < d * k", "have \"k > Suc 0 \\<or> ka >Suc 0\""], ["proof (prove)\nusing this:\n  0 < d\n  d \\<noteq> Suc 0\n  Suc 0 < d * ka\n  ka \\<noteq> k\n  Suc 0 < d * k\n\ngoal (1 subgoal):\n 1. Suc 0 < k \\<or> Suc 0 < ka", "by (cases ka;cases k;force+)"], ["proof (state)\nthis:\n  Suc 0 < k \\<or> Suc 0 < ka\n\ngoal (1 subgoal):\n 1. \\<And>c k ka.\n       \\<lbrakk>Suc 0 < c * k;\n        \\<forall>u<c * k. \\<forall>v<c * k. u * v \\<noteq> c * k;\n        Suc 0 < c * ka;\n        \\<forall>u<c * ka. \\<forall>v<c * ka. u * v \\<noteq> c * ka;\n        x = c * k; y = c * ka; k \\<noteq> ka; 0 < c;\n        c \\<noteq> Suc 0\\<rbrakk>\n       \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  Suc 0 < k \\<or> Suc 0 < ka", "show \"False\""], ["proof (prove)\nusing this:\n  Suc 0 < k \\<or> Suc 0 < ka\n\ngoal (1 subgoal):\n 1. False", "proof(erule_tac disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc 0 < k \\<Longrightarrow> False\n 2. Suc 0 < ka \\<Longrightarrow> False", "assume  \"(Suc 0::nat) < k\""], ["proof (state)\nthis:\n  Suc 0 < k\n\ngoal (2 subgoals):\n 1. Suc 0 < k \\<Longrightarrow> False\n 2. Suc 0 < ka \\<Longrightarrow> False", "hence \"k < d*k \\<and> d < d*k\""], ["proof (prove)\nusing this:\n  Suc 0 < k\n\ngoal (1 subgoal):\n 1. k < d * k \\<and> d < d * k", "using h"], ["proof (prove)\nusing this:\n  Suc 0 < k\n  0 < d\n  d \\<noteq> Suc 0\n  Suc 0 < d * ka\n  ka \\<noteq> k\n  Suc 0 < d * k\n\ngoal (1 subgoal):\n 1. k < d * k \\<and> d < d * k", "by(auto)"], ["proof (state)\nthis:\n  k < d * k \\<and> d < d * k\n\ngoal (2 subgoals):\n 1. Suc 0 < k \\<Longrightarrow> False\n 2. Suc 0 < ka \\<Longrightarrow> False", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  k < d * k \\<and> d < d * k\n\ngoal (1 subgoal):\n 1. False", "using case_k"], ["proof (prove)\nusing this:\n  k < d * k \\<and> d < d * k\n  \\<forall>u<d * k. \\<forall>v<d * k. u * v \\<noteq> d * k\n\ngoal (1 subgoal):\n 1. False", "apply(erule_tac x = d in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < d * k \\<and> d < d * k;\n     d < d * k \\<longrightarrow>\n     (\\<forall>v<d * k. d * v \\<noteq> d * k)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k \\<and> Suc 0 < d \\<and> 0 < d \\<and> Suc 0 < k;\n     \\<forall>v<d * k. v \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule_tac x = k in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k \\<and> Suc 0 < d \\<and> 0 < d \\<and> Suc 0 < k;\n     k < d * k \\<longrightarrow> k \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Suc 0 < ka \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < ka \\<Longrightarrow> False", "assume \"(Suc 0::nat) < ka\""], ["proof (state)\nthis:\n  Suc 0 < ka\n\ngoal (1 subgoal):\n 1. Suc 0 < ka \\<Longrightarrow> False", "hence \"ka < d * ka \\<and> d < d*ka\""], ["proof (prove)\nusing this:\n  Suc 0 < ka\n\ngoal (1 subgoal):\n 1. ka < d * ka \\<and> d < d * ka", "using h"], ["proof (prove)\nusing this:\n  Suc 0 < ka\n  0 < d\n  d \\<noteq> Suc 0\n  Suc 0 < d * ka\n  ka \\<noteq> k\n  Suc 0 < d * k\n\ngoal (1 subgoal):\n 1. ka < d * ka \\<and> d < d * ka", "by auto"], ["proof (state)\nthis:\n  ka < d * ka \\<and> d < d * ka\n\ngoal (1 subgoal):\n 1. Suc 0 < ka \\<Longrightarrow> False", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  ka < d * ka \\<and> d < d * ka\n\ngoal (1 subgoal):\n 1. False", "using case_ka"], ["proof (prove)\nusing this:\n  ka < d * ka \\<and> d < d * ka\n  \\<forall>u<d * ka. \\<forall>v<d * ka. u * v \\<noteq> d * ka\n\ngoal (1 subgoal):\n 1. False", "apply(erule_tac x = d in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ka < d * ka \\<and> d < d * ka;\n     d < d * ka \\<longrightarrow>\n     (\\<forall>v<d * ka. d * v \\<noteq> d * ka)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < ka \\<and> Suc 0 < d \\<and> 0 < d \\<and> Suc 0 < ka;\n     \\<forall>v<d * ka. v \\<noteq> ka\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule_tac x = ka in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < ka \\<and> Suc 0 < d \\<and> 0 < d \\<and> Suc 0 < ka;\n     ka < d * ka \\<longrightarrow> ka \\<noteq> ka\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pi_inc: \"Pi (Suc i) > Pi i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi i < Pi (Suc i)", "proof(simp add: Pi.simps Np.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "let ?setx = \"{y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "have \"finite ?setx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "by simp"], ["proof (state)\nthis:\n  finite {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}\n\ngoal (1 subgoal):\n 1. Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "moreover"], ["proof (state)\nthis:\n  finite {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}\n\ngoal (1 subgoal):\n 1. Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "have \"?setx \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y} \\<noteq> {}", "using prime_ex[of \"Pi i\"]"], ["proof (prove)\nusing this:\n  \\<exists>p>Pi i. p \\<le> Suc (Pi i!) \\<and> Prime p\n\ngoal (1 subgoal):\n 1. {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y} \\<noteq> {}", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "ultimately"], ["proof (chain)\npicking this:\n  finite {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}\n  {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y} \\<noteq> {}", "show \"Pi i < Min ?setx\""], ["proof (prove)\nusing this:\n  finite {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}\n  {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Pi i < Min {y. y \\<le> Suc (Pi i!) \\<and> Pi i < y \\<and> Prime y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pi_inc_gr: \"i < j \\<Longrightarrow> Pi i < Pi j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> Pi i < Pi j", "proof(induct j, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> Pi i < Pi j; i < Suc j\\<rbrakk>\n       \\<Longrightarrow> Pi i < Pi (Suc j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> Pi i < Pi j; i < Suc j\\<rbrakk>\n       \\<Longrightarrow> Pi i < Pi (Suc j)", "assume ind: \"i < j \\<Longrightarrow> Pi i < Pi j\"\n    and h: \"i < Suc j\""], ["proof (state)\nthis:\n  i < j \\<Longrightarrow> Pi i < Pi j\n  i < Suc j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i < j \\<Longrightarrow> Pi i < Pi j; i < Suc j\\<rbrakk>\n       \\<Longrightarrow> Pi i < Pi (Suc j)", "from h"], ["proof (chain)\npicking this:\n  i < Suc j", "show \"Pi i < Pi (Suc j)\""], ["proof (prove)\nusing this:\n  i < Suc j\n\ngoal (1 subgoal):\n 1. Pi i < Pi (Suc j)", "proof(cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < Suc j; i < j\\<rbrakk> \\<Longrightarrow> Pi i < Pi (Suc j)\n 2. \\<lbrakk>i < Suc j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i < Pi (Suc j)", "case True"], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < Suc j; i < j\\<rbrakk> \\<Longrightarrow> Pi i < Pi (Suc j)\n 2. \\<lbrakk>i < Suc j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i < Pi (Suc j)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. Pi i < Pi (Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> Pi i < Pi (Suc j)", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> Pi i < Pi (Suc j)", "hence \"Pi i < Pi j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. Pi i < Pi j", "by(erule_tac ind)"], ["proof (state)\nthis:\n  Pi i < Pi j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> Pi i < Pi (Suc j)", "moreover"], ["proof (state)\nthis:\n  Pi i < Pi j\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> Pi i < Pi (Suc j)", "have \"Pi j < Pi (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi j < Pi (Suc j)", "apply(simp add: Pi_inc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Pi j < Pi (Suc j)\n\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> Pi i < Pi (Suc j)", "ultimately"], ["proof (chain)\npicking this:\n  Pi i < Pi j\n  Pi j < Pi (Suc j)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Pi i < Pi j\n  Pi j < Pi (Suc j)\n\ngoal (1 subgoal):\n 1. Pi i < Pi (Suc j)", "by simp"], ["proof (state)\nthis:\n  Pi i < Pi (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi i < Pi (Suc j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i < Pi (Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i < Pi (Suc j)", "assume \"i < Suc j\" \"\\<not> i < j\""], ["proof (state)\nthis:\n  i < Suc j\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i < Pi (Suc j)", "hence \"i = j\""], ["proof (prove)\nusing this:\n  i < Suc j\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. i = j", "by arith"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < Suc j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i < Pi (Suc j)", "thus \"Pi i < Pi (Suc j)\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. Pi i < Pi (Suc j)", "apply(simp add: Pi_inc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Pi i < Pi (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi i < Pi (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pi_notEq: \"i \\<noteq> j \\<Longrightarrow> Pi i \\<noteq> Pi j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> Pi i \\<noteq> Pi j", "apply(cases \"i < j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> j; i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i \\<noteq> Pi j\n 2. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i \\<noteq> Pi j", "using Pi_inc_gr[of i j]"], ["proof (prove)\nusing this:\n  i < j \\<Longrightarrow> Pi i < Pi j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> j; i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i \\<noteq> Pi j\n 2. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i \\<noteq> Pi j", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i \\<noteq> Pi j", "using Pi_inc_gr[of j i]"], ["proof (prove)\nusing this:\n  j < i \\<Longrightarrow> Pi j < Pi i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; \\<not> i < j\\<rbrakk>\n    \\<Longrightarrow> Pi i \\<noteq> Pi j", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prime_2[intro]: \"Prime (Suc (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prime (Suc (Suc 0))", "apply(auto simp: Prime.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u < Suc (Suc 0); v < Suc (Suc 0);\n        u * v = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> False", "using less_2_cases"], ["proof (prove)\nusing this:\n  ?n < 2 \\<Longrightarrow> ?n = 0 \\<or> ?n = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u < Suc (Suc 0); v < Suc (Suc 0);\n        u * v = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["", "lemma Prime_Pi[intro]: \"Prime (Pi n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prime (Pi n)", "proof(induct n, auto simp: Pi.simps Np.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Prime (Pi n) \\<Longrightarrow>\n       Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Prime (Pi n) \\<Longrightarrow>\n       Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "let ?setx = \"{y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       Prime (Pi n) \\<Longrightarrow>\n       Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "show \"Prime (Min ?setx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "have \"finite ?setx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}", "by simp"], ["proof (state)\nthis:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n\ngoal (1 subgoal):\n 1. Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "moreover"], ["proof (state)\nthis:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n\ngoal (1 subgoal):\n 1. Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "have \"?setx \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}", "using prime_ex[of \"Pi n\"]"], ["proof (prove)\nusing this:\n  \\<exists>p>Pi n. p \\<le> Suc (Pi n!) \\<and> Prime p\n\ngoal (1 subgoal):\n 1. {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "ultimately"], ["proof (chain)\npicking this:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n  {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}", "show \"?thesis\""], ["proof (prove)\nusing this:\n  finite {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y}\n  {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})", "apply(drule_tac Min_in, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Prime (Min {y. y \\<le> Suc (Pi n!) \\<and> Pi n < y \\<and> Prime y})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pi_coprime: \"i \\<noteq> j \\<Longrightarrow> coprime (Pi i) (Pi j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> coprime (Pi i) (Pi j)", "using Prime_Pi[of i]"], ["proof (prove)\nusing this:\n  Prime (Pi i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> coprime (Pi i) (Pi j)", "using Prime_Pi[of j]"], ["proof (prove)\nusing this:\n  Prime (Pi i)\n  Prime (Pi j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> coprime (Pi i) (Pi j)", "apply(rule_tac prime_coprime, simp_all add: Pi_notEq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Pi_power_coprime: \"i \\<noteq> j \\<Longrightarrow> coprime ((Pi i)^m) ((Pi j)^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> coprime (Pi i ^ m) (Pi j ^ n)", "unfolding coprime_power_right_iff coprime_power_left_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (coprime (Pi i) (Pi j) \\<or> m = 0) \\<or> n = 0", "using Pi_coprime"], ["proof (prove)\nusing this:\n  ?i \\<noteq> ?j \\<Longrightarrow> coprime (Pi ?i) (Pi ?j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (coprime (Pi i) (Pi j) \\<or> m = 0) \\<or> n = 0", "by auto"], ["", "lemma coprime_dvd_mult_nat2: \"\\<lbrakk>coprime (k::nat) n; k dvd n * m\\<rbrakk> \\<Longrightarrow> k dvd m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime k n; k dvd n * m\\<rbrakk> \\<Longrightarrow> k dvd m", "unfolding coprime_dvd_mult_right_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime k n; k dvd m\\<rbrakk> \\<Longrightarrow> k dvd m", "."], ["", "declare godel_code'.simps[simp del]"], ["", "lemma godel_code'_butlast_last_id' :\n  \"godel_code' (ys @ [y]) (Suc j) = godel_code' ys (Suc j) * \n                                Pi (Suc (length ys + j)) ^ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. godel_code' (ys @ [y]) (Suc j) =\n    godel_code' ys (Suc j) * Pi (Suc (length ys + j)) ^ y", "proof(induct ys arbitrary: j, simp_all add: godel_code'.simps)"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["", "lemma godel_code'_butlast_last_id: \n  \"xs \\<noteq> [] \\<Longrightarrow> godel_code' xs (Suc j) = \n  godel_code' (butlast xs) (Suc j) * Pi (length xs + j)^(last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    godel_code' xs (Suc j) =\n    godel_code' (butlast xs) (Suc j) * Pi (length xs + j) ^ last xs", "apply(subgoal_tac \"\\<exists> ys y. xs = ys @ [y]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs \\<noteq> []; \\<exists>ys y. xs = ys @ [y]\\<rbrakk>\n    \\<Longrightarrow> godel_code' xs (Suc j) =\n                      godel_code' (butlast xs) (Suc j) *\n                      Pi (length xs + j) ^ last xs\n 2. xs \\<noteq> [] \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "apply(erule_tac exE, erule_tac exE, simp add: \n      godel_code'_butlast_last_id')"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> \\<exists>ys y. xs = ys @ [y]", "apply(rule_tac x = \"butlast xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> \\<exists>y. xs = butlast xs @ [y]", "apply(rule_tac x = \"last xs\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma godel_code'_not0: \"godel_code' xs n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. godel_code' xs n \\<noteq> 0", "apply(induct xs, auto simp: godel_code'.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma godel_code_append_cons: \n  \"length xs = i \\<Longrightarrow> godel_code' (xs@y#ys) (Suc 0)\n    = godel_code' xs (Suc 0) * Pi (Suc i)^y * godel_code' ys (i + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = i \\<Longrightarrow>\n    godel_code' (xs @ y # ys) (Suc 0) =\n    godel_code' xs (Suc 0) * Pi (Suc i) ^ y * godel_code' ys (i + 2)", "proof(induct \"length xs\" arbitrary: i y ys xs, simp add: godel_code'.simps,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "fix x xs i y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "assume ind: \n    \"\\<And>xs i y ys. \\<lbrakk>x = i; length xs = i\\<rbrakk> \\<Longrightarrow> \n       godel_code' (xs @ y # ys) (Suc 0) \n     = godel_code' xs (Suc 0) * Pi (Suc i) ^ y * \n                             godel_code' ys (Suc (Suc i))\"\n    and h: \"Suc x = i\" \n    \"length (xs::nat list) = i\""], ["proof (state)\nthis:\n  \\<lbrakk>x = ?i; length ?xs = ?i\\<rbrakk>\n  \\<Longrightarrow> godel_code' (?xs @ ?y # ?ys) (Suc 0) =\n                    godel_code' ?xs (Suc 0) * Pi (Suc ?i) ^ ?y *\n                    godel_code' ?ys (Suc (Suc ?i))\n  Suc x = i\n  length xs = i\n\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "have \n    \"godel_code' (butlast xs @ last xs # ((y::nat)#ys)) (Suc 0) = \n        godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1))^(last xs) \n              * godel_code' (y#ys) (Suc (Suc (i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. godel_code' (butlast xs @ last xs # y # ys) (Suc 0) =\n    godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1)) ^ last xs *\n    godel_code' (y # ys) (Suc (Suc (i - 1)))", "apply(rule_tac ind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = i - 1\n 2. length (butlast xs) = i - 1", "using h"], ["proof (prove)\nusing this:\n  Suc x = i\n  length xs = i\n\ngoal (2 subgoals):\n 1. x = i - 1\n 2. length (butlast xs) = i - 1", "by(auto)"], ["proof (state)\nthis:\n  godel_code' (butlast xs @ last xs # y # ys) (Suc 0) =\n  godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1)) ^ last xs *\n  godel_code' (y # ys) (Suc (Suc (i - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "moreover"], ["proof (state)\nthis:\n  godel_code' (butlast xs @ last xs # y # ys) (Suc 0) =\n  godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1)) ^ last xs *\n  godel_code' (y # ys) (Suc (Suc (i - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "have \n    \"godel_code' xs (Suc 0)= godel_code' (butlast xs) (Suc 0) *\n                                                  Pi (i)^(last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. godel_code' xs (Suc 0) =\n    godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs", "using godel_code'_butlast_last_id[of xs] h"], ["proof (prove)\nusing this:\n  xs \\<noteq> [] \\<Longrightarrow>\n  godel_code' xs (Suc ?j) =\n  godel_code' (butlast xs) (Suc ?j) * Pi (length xs + ?j) ^ last xs\n  Suc x = i\n  length xs = i\n\ngoal (1 subgoal):\n 1. godel_code' xs (Suc 0) =\n    godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs", "apply(cases \"xs = []\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  godel_code' xs (Suc 0) = godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "moreover"], ["proof (state)\nthis:\n  godel_code' xs (Suc 0) = godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "have \"butlast xs @ last xs # y # ys = xs @ y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast xs @ last xs # y # ys = xs @ y # ys", "using h"], ["proof (prove)\nusing this:\n  Suc x = i\n  length xs = i\n\ngoal (1 subgoal):\n 1. butlast xs @ last xs # y # ys = xs @ y # ys", "apply(cases xs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  butlast xs @ last xs # y # ys = xs @ y # ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs i y ys.\n       \\<lbrakk>\\<And>xs i y ys.\n                   \\<lbrakk>x = i; length xs = i\\<rbrakk>\n                   \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                                     godel_code' xs (Suc 0) *\n                                     Pi (Suc i) ^ y *\n                                     godel_code' ys (Suc (Suc i));\n        Suc x = i; length xs = i\\<rbrakk>\n       \\<Longrightarrow> godel_code' (xs @ y # ys) (Suc 0) =\n                         godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                         godel_code' ys (Suc (Suc i))", "ultimately"], ["proof (chain)\npicking this:\n  godel_code' (butlast xs @ last xs # y # ys) (Suc 0) =\n  godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1)) ^ last xs *\n  godel_code' (y # ys) (Suc (Suc (i - 1)))\n  godel_code' xs (Suc 0) = godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs\n  butlast xs @ last xs # y # ys = xs @ y # ys", "show \n    \"godel_code' (xs @ y # ys) (Suc 0) =\n               godel_code' xs (Suc 0) * Pi (Suc i) ^ y *\n                    godel_code' ys (Suc (Suc i))\""], ["proof (prove)\nusing this:\n  godel_code' (butlast xs @ last xs # y # ys) (Suc 0) =\n  godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1)) ^ last xs *\n  godel_code' (y # ys) (Suc (Suc (i - 1)))\n  godel_code' xs (Suc 0) = godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs\n  butlast xs @ last xs # y # ys = xs @ y # ys\n\ngoal (1 subgoal):\n 1. godel_code' (xs @ y # ys) (Suc 0) =\n    godel_code' xs (Suc 0) * Pi (Suc i) ^ y * godel_code' ys (Suc (Suc i))", "using h"], ["proof (prove)\nusing this:\n  godel_code' (butlast xs @ last xs # y # ys) (Suc 0) =\n  godel_code' (butlast xs) (Suc 0) * Pi (Suc (i - 1)) ^ last xs *\n  godel_code' (y # ys) (Suc (Suc (i - 1)))\n  godel_code' xs (Suc 0) = godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs\n  butlast xs @ last xs # y # ys = xs @ y # ys\n  Suc x = i\n  length xs = i\n\ngoal (1 subgoal):\n 1. godel_code' (xs @ y # ys) (Suc 0) =\n    godel_code' xs (Suc 0) * Pi (Suc i) ^ y * godel_code' ys (Suc (Suc i))", "apply(simp add: godel_code'_not0 Pi_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>godel_code' (xs @ y # ys) (Suc 0) =\n             godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs *\n             godel_code' (y # ys) (Suc i);\n     godel_code' xs (Suc 0) =\n     godel_code' (butlast xs) (Suc 0) * Pi i ^ last xs;\n     butlast xs @ [last xs] = xs; Suc x = i; length xs = i\\<rbrakk>\n    \\<Longrightarrow> godel_code' (y # ys) (Suc i) =\n                      Pi (Suc i) ^ y * godel_code' ys (Suc (Suc i)) \\<or>\n                      Pi i = 0 \\<and> 0 < last xs", "apply(simp add: godel_code'.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  godel_code' (xs @ y # ys) (Suc 0) =\n  godel_code' xs (Suc 0) * Pi (Suc i) ^ y * godel_code' ys (Suc (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pi_coprime_pre: \n  \"length ps \\<le> i \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ps \\<le> i \\<Longrightarrow>\n    coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "proof(induct \"length ps\" arbitrary: ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "fix x ps"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "assume ind: \n    \"\\<And>ps. \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk> \\<Longrightarrow>\n                  coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\"\n    and h: \"Suc x = length ps\"\n    \"length (ps::nat list) \\<le> i\""], ["proof (state)\nthis:\n  \\<lbrakk>x = length ?ps; length ?ps \\<le> i\\<rbrakk>\n  \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ?ps (Suc 0))\n  Suc x = length ps\n  length ps \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "have g: \"coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))", "apply(rule_tac ind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = length (butlast ps)\n 2. length (butlast ps) \\<le> i", "using h"], ["proof (prove)\nusing this:\n  Suc x = length ps\n  length ps \\<le> i\n\ngoal (2 subgoals):\n 1. x = length (butlast ps)\n 2. length (butlast ps) \\<le> i", "by auto"], ["proof (state)\nthis:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "have k: \"godel_code' ps (Suc 0) = \n         godel_code' (butlast ps) (Suc 0) * Pi (length ps)^(last ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. godel_code' ps (Suc 0) =\n    godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps", "using godel_code'_butlast_last_id[of ps 0] h"], ["proof (prove)\nusing this:\n  ps \\<noteq> [] \\<Longrightarrow>\n  godel_code' ps (Suc 0) =\n  godel_code' (butlast ps) (Suc 0) * Pi (length ps + 0) ^ last ps\n  Suc x = length ps\n  length ps \\<le> i\n\ngoal (1 subgoal):\n 1. godel_code' ps (Suc 0) =\n    godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps", "by(cases ps, simp, simp)"], ["proof (state)\nthis:\n  godel_code' ps (Suc 0) =\n  godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "from g"], ["proof (chain)\npicking this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))", "have \"coprime (Pi (Suc i)) (Pi (length ps) ^ last ps)\""], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i)) (Pi (length ps) ^ last ps)", "unfolding coprime_power_right_iff"], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i)) (Pi (length ps)) \\<or> last ps = 0", "using Pi_coprime h(2)"], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n  ?i \\<noteq> ?j \\<Longrightarrow> coprime (Pi ?i) (Pi ?j)\n  length ps \\<le> i\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i)) (Pi (length ps)) \\<or> last ps = 0", "by auto"], ["proof (state)\nthis:\n  coprime (Pi (Suc i)) (Pi (length ps) ^ last ps)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "with g"], ["proof (chain)\npicking this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n  coprime (Pi (Suc i)) (Pi (length ps) ^ last ps)", "have \n    \"coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0) *\n                                        Pi (length ps)^(last ps)) \""], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n  coprime (Pi (Suc i)) (Pi (length ps) ^ last ps)\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i))\n     (godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps)", "unfolding coprime_mult_right_iff coprime_power_right_iff"], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0))\n  coprime (Pi (Suc i)) (Pi (length ps)) \\<or> last ps = 0\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i)) (godel_code' (butlast ps) (Suc 0)) \\<and>\n    (coprime (Pi (Suc i)) (Pi (length ps)) \\<or> last ps = 0)", "by auto"], ["proof (state)\nthis:\n  coprime (Pi (Suc i))\n   (godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; length ps \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi (Suc i))\n(godel_code' ps (Suc 0));\n        Suc x = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "from this and k"], ["proof (chain)\npicking this:\n  coprime (Pi (Suc i))\n   (godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps)\n  godel_code' ps (Suc 0) =\n  godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps", "show \"coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\""], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i))\n   (godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps)\n  godel_code' ps (Suc 0) =\n  godel_code' (butlast ps) (Suc 0) * Pi (length ps) ^ last ps\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "by simp"], ["proof (state)\nthis:\n  coprime (Pi (Suc i)) (godel_code' ps (Suc 0))\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; length ps \\<le> i\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi (Suc i)) (godel_code' ps (Suc 0))", "qed (auto simp add: godel_code'.simps)"], ["", "lemma Pi_coprime_suf: \"i < j \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "proof(induct \"length ps\" arbitrary: ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; i < j\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi i) (godel_code' ps j);\n        Suc x = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "fix x ps"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; i < j\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi i) (godel_code' ps j);\n        Suc x = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "assume ind: \n    \"\\<And>ps. \\<lbrakk>x = length ps; i < j\\<rbrakk> \\<Longrightarrow> \n                    coprime (Pi i) (godel_code' ps j)\"\n    and h: \"Suc x = length (ps::nat list)\" \"i < j\""], ["proof (state)\nthis:\n  \\<lbrakk>x = length ?ps; i < j\\<rbrakk>\n  \\<Longrightarrow> coprime (Pi i) (godel_code' ?ps j)\n  Suc x = length ps\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; i < j\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi i) (godel_code' ps j);\n        Suc x = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "have g: \"coprime (Pi i) (godel_code' (butlast ps) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (Pi i) (godel_code' (butlast ps) j)", "apply(rule ind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = length (butlast ps)\n 2. i < j", "using h"], ["proof (prove)\nusing this:\n  Suc x = length ps\n  i < j\n\ngoal (2 subgoals):\n 1. x = length (butlast ps)\n 2. i < j", "by auto"], ["proof (state)\nthis:\n  coprime (Pi i) (godel_code' (butlast ps) j)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; i < j\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi i) (godel_code' ps j);\n        Suc x = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "have k: \"(godel_code' ps j) = godel_code' (butlast ps) j *\n                                 Pi (length ps + j - 1)^last ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. godel_code' ps j =\n    godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps", "using h godel_code'_butlast_last_id[of ps \"j - 1\"]"], ["proof (prove)\nusing this:\n  Suc x = length ps\n  i < j\n  ps \\<noteq> [] \\<Longrightarrow>\n  godel_code' ps (Suc (j - 1)) =\n  godel_code' (butlast ps) (Suc (j - 1)) *\n  Pi (length ps + (j - 1)) ^ last ps\n\ngoal (1 subgoal):\n 1. godel_code' ps j =\n    godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps", "apply(cases \"ps = []\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  godel_code' ps j =\n  godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; i < j\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi i) (godel_code' ps j);\n        Suc x = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "from g"], ["proof (chain)\npicking this:\n  coprime (Pi i) (godel_code' (butlast ps) j)", "have\n    \"coprime (Pi i) (godel_code' (butlast ps) j * \n                          Pi (length ps + j - 1)^last ps)\""], ["proof (prove)\nusing this:\n  coprime (Pi i) (godel_code' (butlast ps) j)\n\ngoal (1 subgoal):\n 1. coprime (Pi i)\n     (godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps)", "using Pi_power_coprime[of i \"length ps + j - 1\" 1 \"last ps\"] h"], ["proof (prove)\nusing this:\n  coprime (Pi i) (godel_code' (butlast ps) j)\n  i \\<noteq> length ps + j - 1 \\<Longrightarrow>\n  coprime (Pi i ^ 1) (Pi (length ps + j - 1) ^ last ps)\n  Suc x = length ps\n  i < j\n\ngoal (1 subgoal):\n 1. coprime (Pi i)\n     (godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps)", "by(auto)"], ["proof (state)\nthis:\n  coprime (Pi i)\n   (godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps)\n\ngoal (2 subgoals):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)\n 2. \\<And>x ps.\n       \\<lbrakk>\\<And>ps.\n                   \\<lbrakk>x = length ps; i < j\\<rbrakk>\n                   \\<Longrightarrow> coprime (Pi i) (godel_code' ps j);\n        Suc x = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "from k and this"], ["proof (chain)\npicking this:\n  godel_code' ps j =\n  godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps\n  coprime (Pi i)\n   (godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps)", "show \"coprime (Pi i) (godel_code' ps j)\""], ["proof (prove)\nusing this:\n  godel_code' ps j =\n  godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps\n  coprime (Pi i)\n   (godel_code' (butlast ps) j * Pi (length ps + j - 1) ^ last ps)\n\ngoal (1 subgoal):\n 1. coprime (Pi i) (godel_code' ps j)", "by auto"], ["proof (state)\nthis:\n  coprime (Pi i) (godel_code' ps j)\n\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>0 = length ps; i < j\\<rbrakk>\n       \\<Longrightarrow> coprime (Pi i) (godel_code' ps j)", "qed (simp add: godel_code'.simps)"], ["", "lemma godel_finite: \n  \"finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "proof(rule bounded_nat_set_is_finite[of _ \"godel_code' nl (Suc 0)\",rule_format],goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {u. Pi (Suc i) ^ u dvd\n                    godel_code' nl (Suc 0)} \\<Longrightarrow>\n       ia < godel_code' nl (Suc 0)", "case (1 ia)"], ["proof (state)\nthis:\n  ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia \\<in> {u. Pi (Suc i) ^ u dvd\n                    godel_code' nl (Suc 0)} \\<Longrightarrow>\n       ia < godel_code' nl (Suc 0)", "then"], ["proof (chain)\npicking this:\n  ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "show ?case"], ["proof (prove)\nusing this:\n  ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. ia < godel_code' nl (Suc 0)", "proof(cases \"ia < godel_code' nl (Suc 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)\n 2. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     \\<not> ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)", "case False"], ["proof (state)\nthis:\n  \\<not> ia < godel_code' nl (Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)\n 2. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     \\<not> ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)", "hence g1: \"Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0)\"\n      and g2: \"\\<not> ia < godel_code' nl (Suc 0)\"\n      and \"Pi (Suc i)^ia \\<le> godel_code' nl (Suc 0)\""], ["proof (prove)\nusing this:\n  \\<not> ia < godel_code' nl (Suc 0)\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0) &&&\n    \\<not> ia < godel_code' nl (Suc 0) &&&\n    Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)", "using godel_code'_not0[of nl \"Suc 0\"]"], ["proof (prove)\nusing this:\n  \\<not> ia < godel_code' nl (Suc 0)\n  godel_code' nl (Suc 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0) &&&\n    \\<not> ia < godel_code' nl (Suc 0) &&&\n    Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)", "using 1"], ["proof (prove)\nusing this:\n  \\<not> ia < godel_code' nl (Suc 0)\n  godel_code' nl (Suc 0) \\<noteq> 0\n  ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0) &&&\n    \\<not> ia < godel_code' nl (Suc 0) &&&\n    Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)", "by (auto elim:dvd_imp_le)"], ["proof (state)\nthis:\n  Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0)\n  \\<not> ia < godel_code' nl (Suc 0)\n  Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)\n 2. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     \\<not> ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)", "moreover"], ["proof (state)\nthis:\n  Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0)\n  \\<not> ia < godel_code' nl (Suc 0)\n  Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)\n 2. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     \\<not> ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)", "have \"ia < Pi (Suc i)^ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia < Pi (Suc i) ^ ia", "by(rule x_less_exp[OF Pi_gr_1])"], ["proof (state)\nthis:\n  ia < Pi (Suc i) ^ ia\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)\n 2. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     \\<not> ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)", "ultimately"], ["proof (chain)\npicking this:\n  Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0)\n  \\<not> ia < godel_code' nl (Suc 0)\n  Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)\n  ia < Pi (Suc i) ^ ia", "show ?thesis"], ["proof (prove)\nusing this:\n  Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0)\n  \\<not> ia < godel_code' nl (Suc 0)\n  Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)\n  ia < Pi (Suc i) ^ ia\n\ngoal (1 subgoal):\n 1. ia < godel_code' nl (Suc 0)", "using g2"], ["proof (prove)\nusing this:\n  Pi (Suc i) ^ ia dvd godel_code' nl (Suc 0)\n  \\<not> ia < godel_code' nl (Suc 0)\n  Pi (Suc i) ^ ia \\<le> godel_code' nl (Suc 0)\n  ia < Pi (Suc i) ^ ia\n  \\<not> ia < godel_code' nl (Suc 0)\n\ngoal (1 subgoal):\n 1. ia < godel_code' nl (Suc 0)", "by(auto)"], ["proof (state)\nthis:\n  ia < godel_code' nl (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ia \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)};\n     ia < godel_code' nl (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> ia < godel_code' nl (Suc 0)", "qed auto"], ["proof (state)\nthis:\n  ia < godel_code' nl (Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma godel_code_in: \n  \"i < length nl \\<Longrightarrow>  nl ! i  \\<in> {u. Pi (Suc i) ^ u dvd\n                                     godel_code' nl (Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "assume h: \"i<length nl\""], ["proof (state)\nthis:\n  i < length nl\n\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "hence \"godel_code' (take i nl@(nl!i)#drop (Suc i) nl) (Suc 0)\n           = godel_code' (take i nl) (Suc 0) *  Pi (Suc i)^(nl!i) *\n                               godel_code' (drop (Suc i) nl) (i + 2)\""], ["proof (prove)\nusing this:\n  i < length nl\n\ngoal (1 subgoal):\n 1. godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n    godel_code' (drop (Suc i) nl) (i + 2)", "by(rule_tac godel_code_append_cons, simp)"], ["proof (state)\nthis:\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "moreover"], ["proof (state)\nthis:\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "from h"], ["proof (chain)\npicking this:\n  i < length nl", "have \"take i nl @ (nl ! i) # drop (Suc i) nl = nl\""], ["proof (prove)\nusing this:\n  i < length nl\n\ngoal (1 subgoal):\n 1. take i nl @ nl ! i # drop (Suc i) nl = nl", "using upd_conv_take_nth_drop[of i nl \"nl ! i\"]"], ["proof (prove)\nusing this:\n  i < length nl\n  i < length nl \\<Longrightarrow>\n  nl[i := nl ! i] = take i nl @ nl ! i # drop (Suc i) nl\n\ngoal (1 subgoal):\n 1. take i nl @ nl ! i # drop (Suc i) nl = nl", "by simp"], ["proof (state)\nthis:\n  take i nl @ nl ! i # drop (Suc i) nl = nl\n\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "ultimately"], ["proof (chain)\npicking this:\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n  take i nl @ nl ! i # drop (Suc i) nl = nl", "show \n    \"nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\""], ["proof (prove)\nusing this:\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n  take i nl @ nl ! i # drop (Suc i) nl = nl\n\ngoal (1 subgoal):\n 1. nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "by(simp)"], ["proof (state)\nthis:\n  nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma godel_code'_get_nth:\n  \"i < length nl \\<Longrightarrow> Max {u. Pi (Suc i) ^ u dvd \n                          godel_code' nl (Suc 0)} = nl ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    Max {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)} = nl ! i", "proof(rule_tac Max_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < length nl \\<Longrightarrow>\n    finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n 2. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 3. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "let ?gc = \"godel_code' nl (Suc 0)\""], ["proof (state)\ngoal (3 subgoals):\n 1. i < length nl \\<Longrightarrow>\n    finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n 2. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 3. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "assume h: \"i < length nl\""], ["proof (state)\nthis:\n  i < length nl\n\ngoal (3 subgoals):\n 1. i < length nl \\<Longrightarrow>\n    finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n 2. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 3. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "thus \"finite {u. Pi (Suc i) ^ u dvd ?gc}\""], ["proof (prove)\nusing this:\n  i < length nl\n\ngoal (1 subgoal):\n 1. finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "by (simp add: godel_finite)"], ["proof (state)\nthis:\n  finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "let ?suf =\"godel_code' (drop (Suc i) nl) (i + 2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "let ?pref = \"godel_code' (take i nl) (Suc 0)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "assume h: \"i < length nl\" \n    \"y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\""], ["proof (state)\nthis:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "moreover"], ["proof (state)\nthis:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "hence\n    \"godel_code' (take i nl@(nl!i)#drop (Suc i) nl) (Suc 0)\n    = ?pref * Pi (Suc i)^(nl!i) * ?suf\""], ["proof (prove)\nusing this:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n    godel_code' (drop (Suc i) nl) (i + 2)", "by(rule_tac godel_code_append_cons, simp)"], ["proof (state)\nthis:\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "moreover"], ["proof (state)\nthis:\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "from h"], ["proof (chain)\npicking this:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "have \"take i nl @ (nl!i) # drop (Suc i) nl = nl\""], ["proof (prove)\nusing this:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. take i nl @ nl ! i # drop (Suc i) nl = nl", "using upd_conv_take_nth_drop[of i nl \"nl!i\"]"], ["proof (prove)\nusing this:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n  i < length nl \\<Longrightarrow>\n  nl[i := nl ! i] = take i nl @ nl ! i # drop (Suc i) nl\n\ngoal (1 subgoal):\n 1. take i nl @ nl ! i # drop (Suc i) nl = nl", "by simp"], ["proof (state)\nthis:\n  take i nl @ nl ! i # drop (Suc i) nl = nl\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>i < length nl;\n        y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> nl ! i\n 2. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "ultimately"], ["proof (chain)\npicking this:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n  take i nl @ nl ! i # drop (Suc i) nl = nl", "show \"y\\<le>nl!i\""], ["proof (prove)\nusing this:\n  i < length nl\n  y \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n  godel_code' (take i nl @ nl ! i # drop (Suc i) nl) (Suc 0) =\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (i + 2)\n  take i nl @ nl ! i # drop (Suc i) nl = nl\n\ngoal (1 subgoal):\n 1. y \\<le> nl ! i", "proof(simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     Pi (Suc i) ^ y dvd\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     godel_code' nl (Suc 0) =\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     take i nl @ nl ! i # drop (Suc i) nl = nl\\<rbrakk>\n    \\<Longrightarrow> y \\<le> nl ! i", "let ?suf' = \"godel_code' (drop (Suc i) nl) (Suc (Suc i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     Pi (Suc i) ^ y dvd\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     godel_code' nl (Suc 0) =\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     take i nl @ nl ! i # drop (Suc i) nl = nl\\<rbrakk>\n    \\<Longrightarrow> y \\<le> nl ! i", "assume mult_dvd: \n      \"Pi (Suc i) ^ y dvd ?pref *  Pi (Suc i) ^ nl ! i * ?suf'\""], ["proof (state)\nthis:\n  Pi (Suc i) ^ y dvd\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (Suc (Suc i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     Pi (Suc i) ^ y dvd\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     godel_code' nl (Suc 0) =\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     take i nl @ nl ! i # drop (Suc i) nl = nl\\<rbrakk>\n    \\<Longrightarrow> y \\<le> nl ! i", "hence \"Pi (Suc i) ^ y dvd ?pref * Pi (Suc i) ^ nl ! i\""], ["proof (prove)\nusing this:\n  Pi (Suc i) ^ y dvd\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (Suc (Suc i))\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n    godel_code' (drop (Suc i) nl) (Suc (Suc i)) \\<Longrightarrow>\n    Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i", "have \"coprime (Pi (Suc i)^y) ?suf'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i) ^ y) (godel_code' (drop (Suc i) nl) (Suc (Suc i)))", "by (simp add: Pi_coprime_suf)"], ["proof (state)\nthis:\n  coprime (Pi (Suc i) ^ y) (godel_code' (drop (Suc i) nl) (Suc (Suc i)))\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n    godel_code' (drop (Suc i) nl) (Suc (Suc i)) \\<Longrightarrow>\n    Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i) ^ y) (godel_code' (drop (Suc i) nl) (Suc (Suc i)))\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i", "using coprime_dvd_mult_left_iff mult_dvd"], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i) ^ y) (godel_code' (drop (Suc i) nl) (Suc (Suc i)))\n  coprime ?a ?c \\<Longrightarrow> (?a dvd ?b * ?c) = (?a dvd ?b)\n  Pi (Suc i) ^ y dvd\n  godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n  godel_code' (drop (Suc i) nl) (Suc (Suc i))\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i", "by blast"], ["proof (state)\nthis:\n  Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     Pi (Suc i) ^ y dvd\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     godel_code' nl (Suc 0) =\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     take i nl @ nl ! i # drop (Suc i) nl = nl\\<rbrakk>\n    \\<Longrightarrow> y \\<le> nl ! i", "hence \"Pi (Suc i) ^ y dvd Pi (Suc i) ^ nl ! i\""], ["proof (prove)\nusing this:\n  Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd Pi (Suc i) ^ nl ! i", "proof(rule_tac coprime_dvd_mult_nat2)"], ["proof (state)\ngoal (2 subgoals):\n 1. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i \\<Longrightarrow>\n    coprime (Pi (Suc i) ^ y) ?n1\n 2. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i \\<Longrightarrow>\n    Pi (Suc i) ^ y dvd ?n1 * Pi (Suc i) ^ nl ! i", "have \"coprime (Pi (Suc i)^y) (?pref^Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i) ^ y) (godel_code' (take i nl) (Suc 0) ^ Suc 0)", "using Pi_coprime_pre"], ["proof (prove)\nusing this:\n  length ?ps \\<le> ?i \\<Longrightarrow>\n  coprime (Pi (Suc ?i)) (godel_code' ?ps (Suc 0))\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i) ^ y) (godel_code' (take i nl) (Suc 0) ^ Suc 0)", "by simp"], ["proof (state)\nthis:\n  coprime (Pi (Suc i) ^ y) (godel_code' (take i nl) (Suc 0) ^ Suc 0)\n\ngoal (2 subgoals):\n 1. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i \\<Longrightarrow>\n    coprime (Pi (Suc i) ^ y) ?n1\n 2. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i \\<Longrightarrow>\n    Pi (Suc i) ^ y dvd ?n1 * Pi (Suc i) ^ nl ! i", "thus \"coprime (Pi (Suc i) ^ y) ?pref\""], ["proof (prove)\nusing this:\n  coprime (Pi (Suc i) ^ y) (godel_code' (take i nl) (Suc 0) ^ Suc 0)\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i) ^ y) (godel_code' (take i nl) (Suc 0))", "by simp"], ["proof (state)\nthis:\n  coprime (Pi (Suc i) ^ y) (godel_code' (take i nl) (Suc 0))\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y dvd\n    godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i \\<Longrightarrow>\n    Pi (Suc i) ^ y dvd godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i", "qed"], ["proof (state)\nthis:\n  Pi (Suc i) ^ y dvd Pi (Suc i) ^ nl ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     Pi (Suc i) ^ y dvd\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     godel_code' nl (Suc 0) =\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     take i nl @ nl ! i # drop (Suc i) nl = nl\\<rbrakk>\n    \\<Longrightarrow> y \\<le> nl ! i", "hence \"Pi (Suc i) ^ y \\<le>  Pi (Suc i) ^ nl ! i \""], ["proof (prove)\nusing this:\n  Pi (Suc i) ^ y dvd Pi (Suc i) ^ nl ! i\n\ngoal (1 subgoal):\n 1. Pi (Suc i) ^ y \\<le> Pi (Suc i) ^ nl ! i", "apply(rule_tac dvd_imp_le, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Pi (Suc i) ^ y \\<le> Pi (Suc i) ^ nl ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     Pi (Suc i) ^ y dvd\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     godel_code' nl (Suc 0) =\n     godel_code' (take i nl) (Suc 0) * Pi (Suc i) ^ nl ! i *\n     godel_code' (drop (Suc i) nl) (Suc (Suc i));\n     take i nl @ nl ! i # drop (Suc i) nl = nl\\<rbrakk>\n    \\<Longrightarrow> y \\<le> nl ! i", "thus \"y \\<le> nl ! i\""], ["proof (prove)\nusing this:\n  Pi (Suc i) ^ y \\<le> Pi (Suc i) ^ nl ! i\n\ngoal (1 subgoal):\n 1. y \\<le> nl ! i", "apply(rule_tac power_le_imp_le_exp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y \\<le> nl ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> nl ! i\n\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "assume h: \"i<length nl\""], ["proof (state)\nthis:\n  i < length nl\n\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "thus \"nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\""], ["proof (prove)\nusing this:\n  i < length nl\n\ngoal (1 subgoal):\n 1. nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "by(rule_tac godel_code_in, simp)"], ["proof (state)\nthis:\n  nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma godel_code'_set[simp]: \n  \"{u. Pi (Suc i) ^ u dvd (Suc (Suc 0)) ^ length nl * \n                                     godel_code' nl (Suc 0)} = \n    {u. Pi (Suc i) ^ u dvd  godel_code' nl (Suc 0)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Pi (Suc i) ^ u dvd\n        Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0)} =\n    {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}", "apply(rule_tac Collect_cong, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)", "apply(rule_tac n = \" (Suc (Suc 0)) ^ length nl\" in \n      coprime_dvd_mult_nat2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       coprime (Pi (Suc i) ^ u) (Suc (Suc 0) ^ length nl)\n 2. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       Pi (Suc i) ^ u dvd Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       coprime (Pi (Suc i) ^ u) (Suc (Suc 0) ^ length nl)\n 2. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       Pi (Suc i) ^ u dvd Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0)", "have \"Pi 0 = (2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi 0 = 2", "by(simp add: Pi.simps)"], ["proof (state)\nthis:\n  Pi 0 = 2\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       coprime (Pi (Suc i) ^ u) (Suc (Suc 0) ^ length nl)\n 2. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       Pi (Suc i) ^ u dvd Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0)", "show \"coprime (Pi (Suc i) ^ u) ((Suc (Suc 0)) ^ length nl)\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i) ^ u) (Suc (Suc 0) ^ length nl)", "using Pi_coprime Pi.simps(1)"], ["proof (prove)\nusing this:\n  ?i \\<noteq> ?j \\<Longrightarrow> coprime (Pi ?i) (Pi ?j)\n  Pi 0 = 2\n\ngoal (1 subgoal):\n 1. coprime (Pi (Suc i) ^ u) (Suc (Suc 0) ^ length nl)", "by force"], ["proof (state)\nthis:\n  coprime (Pi (Suc i) ^ ?u) (Suc (Suc 0) ^ length nl)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       Pi (Suc i) ^ u dvd\n       Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0) \\<Longrightarrow>\n       Pi (Suc i) ^ u dvd Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0)", "qed"], ["", "lemma godel_code_get_nth: \n  \"i < length nl \\<Longrightarrow> \n           Max {u. Pi (Suc i) ^ u dvd godel_code nl} = nl ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    Max {u. Pi (Suc i) ^ u dvd godel_code nl} = nl ! i", "by(simp add: godel_code.simps godel_code'_get_nth)"], ["", "lemma mod_dvd_simp: \"(x mod y = (0::nat)) = (y dvd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod y = 0) = (y dvd x)", "by(simp add: dvd_def, auto)"], ["", "lemma dvd_power_le: \"\\<lbrakk>a > Suc 0; a ^ y dvd a ^ l\\<rbrakk> \\<Longrightarrow> y \\<le> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < a; a ^ y dvd a ^ l\\<rbrakk> \\<Longrightarrow> y \\<le> l", "apply(cases \"y \\<le> l\", simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < a; a ^ y dvd a ^ l; \\<not> y \\<le> l\\<rbrakk>\n    \\<Longrightarrow> False", "apply(subgoal_tac \"\\<exists> d. y = l + d\", auto simp: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < a; a ^ y dvd a ^ l; \\<not> y \\<le> l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d. y = l + d", "apply(rule_tac x = \"y - l\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Pi_nonzeroE[elim]: \"Pi n = 0 \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi n = 0 \\<Longrightarrow> RR", "using Pi_not_0[of n]"], ["proof (prove)\nusing this:\n  0 < Pi n\n\ngoal (1 subgoal):\n 1. Pi n = 0 \\<Longrightarrow> RR", "by simp"], ["", "lemma Pi_not_oneE[elim]: \"Pi n = Suc 0 \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi n = Suc 0 \\<Longrightarrow> RR", "using Pi_gr_1[of n]"], ["proof (prove)\nusing this:\n  Suc 0 < Pi n\n\ngoal (1 subgoal):\n 1. Pi n = Suc 0 \\<Longrightarrow> RR", "by simp"], ["", "lemma finite_power_dvd:\n  \"\\<lbrakk>(a::nat) > Suc 0; y \\<noteq> 0\\<rbrakk> \\<Longrightarrow> finite {u. a^u dvd y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < a; y \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> finite {u. a ^ u dvd y}", "apply(auto simp: dvd_def simp:gr0_conv_Suc intro!:bounded_nat_set_is_finite[of _ y])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i m k.\n       \\<lbrakk>Suc 0 < a; y = a ^ i * k; Suc m = a ^ i * k\\<rbrakk>\n       \\<Longrightarrow> i < a ^ i * k", "by (metis le_less_trans mod_less mod_mult_self1_is_0 not_le Suc_lessD less_trans_Suc\n      mult.right_neutral n_less_n_mult_m x_less_exp\n      zero_less_Suc zero_less_mult_pos)"], ["", "lemma conf_decode1: \"\\<lbrakk>m \\<noteq> n; m \\<noteq> k; k \\<noteq> n\\<rbrakk> \\<Longrightarrow> \n  Max {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r} = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> n; m \\<noteq> k; k \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Max {u. Pi m ^ u dvd\n                              Pi m ^ l * Pi n ^ st * Pi k ^ r} =\n                      l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> n; m \\<noteq> k; k \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Max {u. Pi m ^ u dvd\n                              Pi m ^ l * Pi n ^ st * Pi k ^ r} =\n                      l", "let ?setx = \"{u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> n; m \\<noteq> k; k \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Max {u. Pi m ^ u dvd\n                              Pi m ^ l * Pi n ^ st * Pi k ^ r} =\n                      l", "assume g: \"m \\<noteq> n\" \"m \\<noteq> k\" \"k \\<noteq> n\""], ["proof (state)\nthis:\n  m \\<noteq> n\n  m \\<noteq> k\n  k \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> n; m \\<noteq> k; k \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> Max {u. Pi m ^ u dvd\n                              Pi m ^ l * Pi n ^ st * Pi k ^ r} =\n                      l", "show \"Max ?setx = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r} = l", "proof(rule_tac Max_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}\n 2. \\<And>y.\n       y \\<in> {u. Pi m ^ u dvd\n                   Pi m ^ l * Pi n ^ st * Pi k ^ r} \\<Longrightarrow>\n       y \\<le> l\n 3. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "show \"finite ?setx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "apply(rule_tac finite_power_dvd, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {u. Pi m ^ u dvd\n                   Pi m ^ l * Pi n ^ st * Pi k ^ r} \\<Longrightarrow>\n       y \\<le> l\n 2. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {u. Pi m ^ u dvd\n                   Pi m ^ l * Pi n ^ st * Pi k ^ r} \\<Longrightarrow>\n       y \\<le> l\n 2. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {u. Pi m ^ u dvd\n                   Pi m ^ l * Pi n ^ st * Pi k ^ r} \\<Longrightarrow>\n       y \\<le> l\n 2. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "assume h: \"y \\<in> ?setx\""], ["proof (state)\nthis:\n  y \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {u. Pi m ^ u dvd\n                   Pi m ^ l * Pi n ^ st * Pi k ^ r} \\<Longrightarrow>\n       y \\<le> l\n 2. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "have \"Pi m ^ y dvd Pi m ^ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l", "have \"Pi m ^ y dvd Pi m ^ l * Pi n ^ st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l * Pi n ^ st", "using h g Pi_power_coprime"], ["proof (prove)\nusing this:\n  y \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}\n  m \\<noteq> n\n  m \\<noteq> k\n  k \\<noteq> n\n  ?i \\<noteq> ?j \\<Longrightarrow> coprime (Pi ?i ^ ?m) (Pi ?j ^ ?n)\n\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l * Pi n ^ st", "by (simp add: coprime_dvd_mult_left_iff)"], ["proof (state)\nthis:\n  Pi m ^ y dvd Pi m ^ l * Pi n ^ st\n\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l", "thus \"Pi m^y dvd Pi m^l\""], ["proof (prove)\nusing this:\n  Pi m ^ y dvd Pi m ^ l * Pi n ^ st\n\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l", "using g Pi_power_coprime coprime_dvd_mult_left_iff"], ["proof (prove)\nusing this:\n  Pi m ^ y dvd Pi m ^ l * Pi n ^ st\n  m \\<noteq> n\n  m \\<noteq> k\n  k \\<noteq> n\n  ?i \\<noteq> ?j \\<Longrightarrow> coprime (Pi ?i ^ ?m) (Pi ?j ^ ?n)\n  coprime ?a ?c \\<Longrightarrow> (?a dvd ?b * ?c) = (?a dvd ?b)\n\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l", "by blast"], ["proof (state)\nthis:\n  Pi m ^ y dvd Pi m ^ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Pi m ^ y dvd Pi m ^ l\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> {u. Pi m ^ u dvd\n                   Pi m ^ l * Pi n ^ st * Pi k ^ r} \\<Longrightarrow>\n       y \\<le> l\n 2. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "thus \"y \\<le> (l::nat)\""], ["proof (prove)\nusing this:\n  Pi m ^ y dvd Pi m ^ l\n\ngoal (1 subgoal):\n 1. y \\<le> l", "apply(rule_tac a = \"Pi m\" in power_le_imp_le_exp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Pi m ^ y dvd Pi m ^ l \\<Longrightarrow> 1 < Pi m\n 2. Pi m ^ y dvd Pi m ^ l \\<Longrightarrow> Pi m ^ y \\<le> Pi m ^ l", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi m ^ y dvd Pi m ^ l \\<Longrightarrow> y \\<le> l", "apply(rule_tac dvd_power_le, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y \\<le> l\n\ngoal (1 subgoal):\n 1. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "show \"l \\<in> ?setx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}", "by simp"], ["proof (state)\nthis:\n  l \\<in> {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max {u. Pi m ^ u dvd Pi m ^ l * Pi n ^ st * Pi k ^ r} = l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_trpl_fst[simp]: \"left (trpl l st r) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left (trpl l st r) = l", "apply(simp add: left.simps trpl.simps lo.simps loR.simps mod_dvd_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r \\<and>\n     (\\<exists>x.\n         Pi 0 ^ x dvd\n         Pi 0 ^ l * Pi (Suc 0) ^ st *\n         Pi (Suc (Suc 0)) ^ r) \\<longrightarrow>\n     Max {u. Pi 0 ^ u dvd\n             Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r} =\n     l) \\<and>\n    ((Suc 0\n      < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r \\<longrightarrow>\n      (\\<forall>x.\n          \\<not> Pi 0 ^ x dvd\n                 Pi 0 ^ l * Pi (Suc 0) ^ st *\n                 Pi (Suc (Suc 0)) ^ r)) \\<longrightarrow>\n     l = 0)", "apply(auto simp: conf_decode1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    l = 0\n 2. \\<forall>x.\n       \\<not> Pi 0 ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    l = 0", "apply(cases \"Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> Suc 0\n                    < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n     Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r = 0\\<rbrakk>\n    \\<Longrightarrow> l = 0\n 2. \\<And>nat.\n       \\<lbrakk>\\<not> Suc 0\n                       < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r = Suc nat\\<rbrakk>\n       \\<Longrightarrow> l = 0\n 3. \\<forall>x.\n       \\<not> Pi 0 ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    l = 0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<not> Pi 0 ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    l = 0", "apply(erule_tac x = l in allE, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma stat_trpl_snd[simp]: \"stat (trpl l st r) = st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stat (trpl l st r) = st", "apply(simp add: stat.simps trpl.simps lo.simps \n      loR.simps mod_dvd_simp, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi (Suc 0) ^ x dvd\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\\<rbrakk>\n       \\<Longrightarrow> Max {u. Pi (Suc 0) ^ u dvd\n                                 Pi 0 ^ l * Pi (Suc 0) ^ st *\n                                 Pi (Suc (Suc 0)) ^ r} =\n                         st\n 2. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0\n 3. \\<forall>x.\n       \\<not> Pi (Suc 0) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0", "apply(subgoal_tac \"Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\n               = Pi (Suc 0)^st * Pi 0 ^ l *  Pi (Suc (Suc 0)) ^ r\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi (Suc 0) ^ x dvd\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r =\n        Pi (Suc 0) ^ st * Pi 0 ^ l * Pi (Suc (Suc 0)) ^ r\\<rbrakk>\n       \\<Longrightarrow> Max {u. Pi (Suc 0) ^ u dvd\n                                 Pi 0 ^ l * Pi (Suc 0) ^ st *\n                                 Pi (Suc (Suc 0)) ^ r} =\n                         st\n 2. \\<And>x.\n       \\<lbrakk>Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi (Suc 0) ^ x dvd\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\\<rbrakk>\n       \\<Longrightarrow> Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r =\n                         Pi (Suc 0) ^ st * Pi 0 ^ l * Pi (Suc (Suc 0)) ^ r\n 3. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0\n 4. \\<forall>x.\n       \\<not> Pi (Suc 0) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0", "apply(simp (no_asm_simp) add: conf_decode1, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0\n 2. \\<forall>x.\n       \\<not> Pi (Suc 0) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0", "apply(cases \"Pi 0 ^ l * Pi (Suc 0) ^ st * \n                                  Pi (Suc (Suc 0)) ^ r\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<not> Pi (Suc 0) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    st = 0", "apply(erule_tac x = st in allE, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rght_trpl_trd[simp]: \"rght (trpl l st r) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rght (trpl l st r) = r", "apply(simp add: rght.simps trpl.simps lo.simps \n      loR.simps mod_dvd_simp, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi (Suc (Suc 0)) ^ x dvd\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\\<rbrakk>\n       \\<Longrightarrow> Max {u. Pi (Suc (Suc 0)) ^ u dvd\n                                 Pi 0 ^ l * Pi (Suc 0) ^ st *\n                                 Pi (Suc (Suc 0)) ^ r} =\n                         r\n 2. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0\n 3. \\<forall>x.\n       \\<not> Pi (Suc (Suc 0)) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0", "apply(subgoal_tac \"Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\n               = Pi (Suc (Suc 0))^r * Pi 0 ^ l *  Pi (Suc 0) ^ st\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi (Suc (Suc 0)) ^ x dvd\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r =\n        Pi (Suc (Suc 0)) ^ r * Pi 0 ^ l * Pi (Suc 0) ^ st\\<rbrakk>\n       \\<Longrightarrow> Max {u. Pi (Suc (Suc 0)) ^ u dvd\n                                 Pi 0 ^ l * Pi (Suc 0) ^ st *\n                                 Pi (Suc (Suc 0)) ^ r} =\n                         r\n 2. \\<And>x.\n       \\<lbrakk>Suc 0 < Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r;\n        Pi (Suc (Suc 0)) ^ x dvd\n        Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\\<rbrakk>\n       \\<Longrightarrow> Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r =\n                         Pi (Suc (Suc 0)) ^ r * Pi 0 ^ l * Pi (Suc 0) ^ st\n 3. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0\n 4. \\<forall>x.\n       \\<not> Pi (Suc (Suc 0)) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0", "apply(simp (no_asm_simp) add: conf_decode1, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> Suc 0\n           < Pi 0 ^ l * Pi (Suc 0) ^ st *\n             Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0\n 2. \\<forall>x.\n       \\<not> Pi (Suc (Suc 0)) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0", "apply(cases \"Pi 0 ^ l * Pi (Suc 0) ^ st * Pi (Suc (Suc 0)) ^ r\",\n      auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<not> Pi (Suc (Suc 0)) ^ x dvd\n              Pi 0 ^ l * Pi (Suc 0) ^ st *\n              Pi (Suc (Suc 0)) ^ r \\<Longrightarrow>\n    r = 0", "apply(erule_tac x = r in allE, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma max_lor:\n  \"i < length nl \\<Longrightarrow> Max {u. loR [godel_code nl, Pi (Suc i), u]} \n                   = nl ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow>\n    Max {u. loR [godel_code nl, Pi (Suc i), u]} = nl ! i", "apply(simp add: loR.simps godel_code_get_nth mod_dvd_simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma godel_decode: \n  \"i < length nl \\<Longrightarrow> Entry (godel_code nl) i = nl ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length nl \\<Longrightarrow> Entry (godel_code nl) i = nl ! i", "apply(auto simp: Entry.simps lo.simps max_lor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     \\<forall>x. \\<not> loR [godel_code nl, Pi (Suc i), x]\\<rbrakk>\n    \\<Longrightarrow> nl ! i = 0", "apply(erule_tac x = \"nl!i\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     \\<not> loR [godel_code nl, Pi (Suc i), nl ! i]\\<rbrakk>\n    \\<Longrightarrow> nl ! i = 0", "using max_lor[of i nl] godel_finite[of i nl]"], ["proof (prove)\nusing this:\n  i < length nl \\<Longrightarrow>\n  Max {u. loR [godel_code nl, Pi (Suc i), u]} = nl ! i\n  finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     \\<not> loR [godel_code nl, Pi (Suc i), nl ! i]\\<rbrakk>\n    \\<Longrightarrow> nl ! i = 0", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl; \\<not> loR [godel_code nl, Pi (Suc i), nl ! i];\n     Max {u. loR [godel_code nl, Pi (Suc i), u]} = nl ! i;\n     finite {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\\<rbrakk>\n    \\<Longrightarrow> nl ! i = 0", "apply(drule_tac Max_in, auto simp: loR.simps \n      godel_code.simps mod_dvd_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     \\<not> Pi (Suc i) ^ nl ! i dvd\n            Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0);\n     Max {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)} = nl ! i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. Pi (Suc i) ^ x dvd godel_code' nl (Suc 0)", "using godel_code_in[of i nl]"], ["proof (prove)\nusing this:\n  i < length nl \\<Longrightarrow>\n  nl ! i \\<in> {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length nl;\n     \\<not> Pi (Suc i) ^ nl ! i dvd\n            Suc (Suc 0) ^ length nl * godel_code' nl (Suc 0);\n     Max {u. Pi (Suc i) ^ u dvd godel_code' nl (Suc 0)} = nl ! i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. Pi (Suc i) ^ x dvd godel_code' nl (Suc 0)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Four_Suc: \"4 = Suc (Suc (Suc (Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 = Suc (Suc (Suc (Suc 0)))", "by auto"], ["", "declare numeral_2_eq_2[simp del]"], ["", "lemma modify_tprog_fetch_even: \n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0\\<rbrakk> \\<Longrightarrow>\n  modify_tprog tp ! (4 * (st - Suc 0) ) = \n  action_map (fst (tp ! (2 * (st - Suc 0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (st - Suc 0))))", "proof(induct st arbitrary: tp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                     action_map\n(fst (tp ! (2 * (st - Suc 0))));\n        Suc st \\<le> length tp div 2; 0 < Suc st\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                         action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "fix tp st"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                     action_map\n(fst (tp ! (2 * (st - Suc 0))));\n        Suc st \\<le> length tp div 2; 0 < Suc st\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                         action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "assume ind: \n    \"\\<And>tp. \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk> \\<Longrightarrow> \n     modify_tprog tp ! (4 * (st - Suc 0)) =\n               action_map (fst ((tp::instr list) ! (2 * (st - Suc 0))))\"\n    and h: \"Suc st \\<le> length (tp::instr list) div 2\" \"0 < Suc st\""], ["proof (state)\nthis:\n  \\<lbrakk>st \\<le> length ?tp div 2; 0 < st\\<rbrakk>\n  \\<Longrightarrow> modify_tprog ?tp ! (4 * (st - Suc 0)) =\n                    action_map (fst (?tp ! (2 * (st - Suc 0))))\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                     action_map\n(fst (tp ! (2 * (st - Suc 0))));\n        Suc st \\<le> length tp div 2; 0 < Suc st\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                         action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "thus \"modify_tprog tp ! (4 * (Suc st - Suc 0)) = \n          action_map (fst (tp ! (2 * (Suc st - Suc 0))))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<le> length ?tp div 2; 0 < st\\<rbrakk>\n  \\<Longrightarrow> modify_tprog ?tp ! (4 * (st - Suc 0)) =\n                    action_map (fst (?tp ! (2 * (st - Suc 0))))\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n    action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "proof(cases \"st = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st = 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))\n 2. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "case True"], ["proof (state)\nthis:\n  st = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st = 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))\n 2. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  st = 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n    action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "using h"], ["proof (prove)\nusing this:\n  st = 0\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n    action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "by(cases tp, auto)"], ["proof (state)\nthis:\n  modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n  action_map (fst (tp ! (2 * (Suc st - Suc 0))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "case False"], ["proof (state)\nthis:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "assume g: \"st \\<noteq> 0\""], ["proof (state)\nthis:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "hence \"\\<exists> aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\""], ["proof (prove)\nusing this:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "using h"], ["proof (prove)\nusing this:\n  st \\<noteq> 0\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "by(cases tp; cases \"tl tp\", auto)"], ["proof (state)\nthis:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "obtain aa ab ba bb tp' where g1: \n      \"tp = (aa, ab) # (ba, bb) # tp'\""], ["proof (prove)\nusing this:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. (\\<And>aa ab ba bb tp'.\n        tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "hence g2: \n      \"modify_tprog tp' ! (4 * (st - Suc 0)) = \n      action_map (fst ((tp'::instr list) ! (2 * (st - Suc 0))))\""], ["proof (prove)\nusing this:\n  tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. modify_tprog tp' ! (4 * (st - Suc 0)) =\n    action_map (fst (tp' ! (2 * (st - Suc 0))))", "using h g"], ["proof (prove)\nusing this:\n  tp = (aa, ab) # (ba, bb) # tp'\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp' ! (4 * (st - Suc 0)) =\n    action_map (fst (tp' ! (2 * (st - Suc 0))))", "by (auto intro:ind)"], ["proof (state)\nthis:\n  modify_tprog tp' ! (4 * (st - Suc 0)) =\n  action_map (fst (tp' ! (2 * (st - Suc 0))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0)) =\n                                  action_map\n                                   (fst (tp ! (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n                      action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  modify_tprog tp' ! (4 * (st - Suc 0)) =\n  action_map (fst (tp' ! (2 * (st - Suc 0))))\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n    action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "using g1 g"], ["proof (prove)\nusing this:\n  modify_tprog tp' ! (4 * (st - Suc 0)) =\n  action_map (fst (tp' ! (2 * (st - Suc 0))))\n  tp = (aa, ab) # (ba, bb) # tp'\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n    action_map (fst (tp ! (2 * (Suc st - Suc 0))))", "by(cases st, auto simp add: Four_Suc)"], ["proof (state)\nthis:\n  modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n  action_map (fst (tp ! (2 * (Suc st - Suc 0))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  modify_tprog tp ! (4 * (Suc st - Suc 0)) =\n  action_map (fst (tp ! (2 * (Suc st - Suc 0))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modify_tprog_fetch_odd: \n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0\\<rbrakk> \\<Longrightarrow> \n       modify_tprog tp ! (Suc (Suc (4 * (st - Suc 0)))) = \n       action_map (fst (tp ! (Suc (2 * (st - Suc 0)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (st - Suc 0))))", "proof(induct st arbitrary: tp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp !\n                                     Suc (Suc (4 * (st - Suc 0))) =\n                                     action_map\n(fst (tp ! Suc (2 * (st - Suc 0))));\n        Suc st \\<le> length tp div 2; 0 < Suc st\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (Suc (4 * (Suc st - Suc 0))) =\n                         action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "fix tp st"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp !\n                                     Suc (Suc (4 * (st - Suc 0))) =\n                                     action_map\n(fst (tp ! Suc (2 * (st - Suc 0))));\n        Suc st \\<le> length tp div 2; 0 < Suc st\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (Suc (4 * (Suc st - Suc 0))) =\n                         action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "assume ind: \n    \"\\<And>tp. \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk> \\<Longrightarrow>  \n       modify_tprog tp ! Suc (Suc (4 * (st - Suc 0))) = \n          action_map (fst (tp ! Suc (2 * (st - Suc 0))))\"\n    and h: \"Suc st \\<le> length (tp::instr list) div 2\" \"0 < Suc st\""], ["proof (state)\nthis:\n  \\<lbrakk>st \\<le> length ?tp div 2; 0 < st\\<rbrakk>\n  \\<Longrightarrow> modify_tprog ?tp ! Suc (Suc (4 * (st - Suc 0))) =\n                    action_map (fst (?tp ! Suc (2 * (st - Suc 0))))\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp !\n                                     Suc (Suc (4 * (st - Suc 0))) =\n                                     action_map\n(fst (tp ! Suc (2 * (st - Suc 0))));\n        Suc st \\<le> length tp div 2; 0 < Suc st\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (Suc (4 * (Suc st - Suc 0))) =\n                         action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "thus \"modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) \n     = action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>st \\<le> length ?tp div 2; 0 < st\\<rbrakk>\n  \\<Longrightarrow> modify_tprog ?tp ! Suc (Suc (4 * (st - Suc 0))) =\n                    action_map (fst (?tp ! Suc (2 * (st - Suc 0))))\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n    action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "proof(cases \"st = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st = 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))\n 2. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "case True"], ["proof (state)\nthis:\n  st = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st = 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))\n 2. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  st = 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n    action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "using h"], ["proof (prove)\nusing this:\n  st = 0\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n    action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "apply(cases tp, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>st = 0; Suc st \\<le> length tp div 2; 0 < Suc st;\n        tp = a # list\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (Suc (4 * (Suc st - Suc 0))) =\n                         action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "by(cases \"tl tp\", auto)"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n  action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "case False"], ["proof (state)\nthis:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "assume g: \"st \\<noteq> 0\""], ["proof (state)\nthis:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "hence \"\\<exists> aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\""], ["proof (prove)\nusing this:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "using h"], ["proof (prove)\nusing this:\n  st \\<noteq> 0\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n\ngoal (1 subgoal):\n 1. \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "apply(cases tp, simp, cases \"tl tp\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "obtain aa ab ba bb tp' where g1: \n      \"tp = (aa, ab) # (ba, bb) # tp'\""], ["proof (prove)\nusing this:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. (\\<And>aa ab ba bb tp'.\n        tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "hence g2: \"modify_tprog tp' ! Suc (Suc (4 * (st  - Suc 0))) = \n          action_map (fst (tp' ! Suc (2 * (st - Suc 0))))\""], ["proof (prove)\nusing this:\n  tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. modify_tprog tp' ! Suc (Suc (4 * (st - Suc 0))) =\n    action_map (fst (tp' ! Suc (2 * (st - Suc 0))))", "apply(rule_tac ind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n    st \\<le> length tp' div 2\n 2. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow> 0 < st", "using h g"], ["proof (prove)\nusing this:\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n  st \\<noteq> 0\n\ngoal (2 subgoals):\n 1. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n    st \\<le> length tp' div 2\n 2. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow> 0 < st", "by auto"], ["proof (state)\nthis:\n  modify_tprog tp' ! Suc (Suc (4 * (st - Suc 0))) =\n  action_map (fst (tp' ! Suc (2 * (st - Suc 0))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>tp.\n                \\<lbrakk>st \\<le> length tp div 2; 0 < st\\<rbrakk>\n                \\<Longrightarrow> modify_tprog tp !\n                                  Suc (Suc (4 * (st - Suc 0))) =\n                                  action_map\n                                   (fst (tp ! Suc (2 * (st - Suc 0))));\n     Suc st \\<le> length tp div 2; 0 < Suc st; st \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n                      action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  modify_tprog tp' ! Suc (Suc (4 * (st - Suc 0))) =\n  action_map (fst (tp' ! Suc (2 * (st - Suc 0))))\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n    action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "using g1 g"], ["proof (prove)\nusing this:\n  modify_tprog tp' ! Suc (Suc (4 * (st - Suc 0))) =\n  action_map (fst (tp' ! Suc (2 * (st - Suc 0))))\n  tp = (aa, ab) # (ba, bb) # tp'\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n    action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))", "apply(cases st, simp, simp add: Four_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n  action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (Suc (4 * (Suc st - Suc 0))) =\n  action_map (fst (tp ! Suc (2 * (Suc st - Suc 0))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modify_tprog_fetch_action:\n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0; b = 1 \\<or> b = 0\\<rbrakk> \\<Longrightarrow> \n      modify_tprog tp ! (4 * (st - Suc 0) + 2* b) =\n      action_map (fst (tp ! ((2 * (st - Suc 0)) + b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>st \\<le> length tp div 2; 0 < st; b = 1 \\<or> b = 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! (4 * (st - Suc 0) + 2 * b) =\n                      action_map (fst (tp ! (2 * (st - Suc 0) + b)))", "apply(erule_tac disjE, auto elim: modify_tprog_fetch_odd\n      modify_tprog_fetch_even)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_modify: \"length (modify_tprog tp) = 2 * length tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (modify_tprog tp) = 2 * length tp", "apply(induct tp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare fetch.simps[simp del]"], ["", "lemma fetch_action_eq: \n  \"\\<lbrakk>block_map b = scan r; fetch tp st b = (nact, ns);\n   st \\<le> length tp div 2\\<rbrakk> \\<Longrightarrow> actn (code tp) st r = action_map nact\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = scan r; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2\\<rbrakk>\n    \\<Longrightarrow> actn (code tp) st r = action_map nact", "proof(simp add: actn.simps, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "let ?i = \"4 * (st - Suc 0) + 2 * (r mod 2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "assume h: \"block_map b = r mod 2\" \"fetch tp st b = (nact, ns)\" \n    \"st \\<le> length tp div 2\" \"0 < st\""], ["proof (state)\nthis:\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "have \"?i < length (modify_tprog tp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)", "have \"length (modify_tprog tp) = 2 * length tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (modify_tprog tp) = 2 * length tp", "by(simp add: length_modify)"], ["proof (state)\nthis:\n  length (modify_tprog tp) = 2 * length tp\n\ngoal (1 subgoal):\n 1. 4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  length (modify_tprog tp) = 2 * length tp\n\ngoal (1 subgoal):\n 1. 4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)", "using h"], ["proof (prove)\nusing this:\n  length (modify_tprog tp) = 2 * length tp\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (1 subgoal):\n 1. 4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)", "by(auto)"], ["proof (state)\nthis:\n  4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "hence \n    \"Entry (godel_code (modify_tprog tp))?i = \n                                   (modify_tprog tp) ! ?i\""], ["proof (prove)\nusing this:\n  4 * (st - Suc 0) + 2 * (r mod 2) < length (modify_tprog tp)\n\ngoal (1 subgoal):\n 1. Entry (godel_code (modify_tprog tp))\n     (4 * (st - Suc 0) + 2 * (r mod 2)) =\n    modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2))", "by(erule_tac godel_decode)"], ["proof (state)\nthis:\n  Entry (godel_code (modify_tprog tp)) (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "moreover"], ["proof (state)\nthis:\n  Entry (godel_code (modify_tprog tp)) (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "have \n    \"modify_tprog tp ! ?i = \n            action_map (fst (tp ! (2 * (st - Suc 0) + r mod 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2)) =\n    action_map (fst (tp ! (2 * (st - Suc 0) + r mod 2)))", "apply(rule_tac  modify_tprog_fetch_action)"], ["proof (prove)\ngoal (3 subgoals):\n 1. st \\<le> length tp div 2\n 2. 0 < st\n 3. r mod 2 = 1 \\<or> is_even r", "using h"], ["proof (prove)\nusing this:\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (3 subgoals):\n 1. st \\<le> length tp div 2\n 2. 0 < st\n 3. r mod 2 = 1 \\<or> is_even r", "by(auto)"], ["proof (state)\nthis:\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  action_map (fst (tp ! (2 * (st - Suc 0) + r mod 2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "moreover"], ["proof (state)\nthis:\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  action_map (fst (tp ! (2 * (st - Suc 0) + r mod 2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "have \"(fst (tp ! (2 * (st - Suc 0) + r mod 2))) = nact\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (tp ! (2 * (st - Suc 0) + r mod 2)) = nact", "using h"], ["proof (prove)\nusing this:\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (1 subgoal):\n 1. fst (tp ! (2 * (st - Suc 0) + r mod 2)) = nact", "apply(cases st, simp_all add: fetch.simps nth_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>fetch tp (Suc nat) b = (nact, ns); st = Suc nat;\n        block_map b = r mod 2; Suc nat \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> fst (tp ! (2 * nat + r mod 2)) = nact", "apply(cases b, auto simp: block_map.simps nth_of.simps fetch.simps \n        split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>st = Suc nat; Suc 0 = r mod 2;\n        Suc nat \\<le> length tp div 2; b = Oc;\n        \\<not> length tp \\<le> Suc (2 * nat);\n        tp ! Suc (2 * nat) = (nact, ns)\\<rbrakk>\n       \\<Longrightarrow> fst (tp ! (2 * nat + r mod 2)) = nact", "apply(cases \"r mod 2\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fst (tp ! (2 * (st - Suc 0) + r mod 2)) = nact\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (4 * (st - Suc 0) + 2 * (r mod 2)) =\n                      action_map nact", "ultimately"], ["proof (chain)\npicking this:\n  Entry (godel_code (modify_tprog tp)) (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2))\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  action_map (fst (tp ! (2 * (st - Suc 0) + r mod 2)))\n  fst (tp ! (2 * (st - Suc 0) + r mod 2)) = nact", "show \n    \"Entry (godel_code (modify_tprog tp))\n                      (4 * (st - Suc 0) + 2 * (r mod 2))\n           = action_map nact\""], ["proof (prove)\nusing this:\n  Entry (godel_code (modify_tprog tp)) (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2))\n  modify_tprog tp ! (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  action_map (fst (tp ! (2 * (st - Suc 0) + r mod 2)))\n  fst (tp ! (2 * (st - Suc 0) + r mod 2)) = nact\n\ngoal (1 subgoal):\n 1. Entry (godel_code (modify_tprog tp))\n     (4 * (st - Suc 0) + 2 * (r mod 2)) =\n    action_map nact", "by simp"], ["proof (state)\nthis:\n  Entry (godel_code (modify_tprog tp)) (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  action_map nact\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fetch_zero_zero[simp]: \"fetch tp 0 b = (nact, ns) \\<Longrightarrow> ns = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch tp 0 b = (nact, ns) \\<Longrightarrow> ns = 0", "by(simp add: fetch.simps)"], ["", "lemma modify_tprog_fetch_state:\n  \"\\<lbrakk>st \\<le> length tp div 2; st > 0; b = 1 \\<or> b = 0\\<rbrakk> \\<Longrightarrow> \n     modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * b) =\n  (snd (tp ! (2 * (st - Suc 0) + b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>st \\<le> length tp div 2; 0 < st; b = 1 \\<or> b = 0\\<rbrakk>\n    \\<Longrightarrow> modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * b) =\n                      snd (tp ! (2 * (st - Suc 0) + b))", "proof(induct st arbitrary: tp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st;\n                    b = 1 \\<or> b = 0\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp !\n                                     Suc (4 * (st - Suc 0) + 2 * b) =\n                                     snd (tp ! (2 * (st - Suc 0) + b));\n        Suc st \\<le> length tp div 2; 0 < Suc st; b = 1 \\<or> b = 0\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (4 * (Suc st - Suc 0) + 2 * b) =\n                         snd (tp ! (2 * (Suc st - Suc 0) + b))", "fix st tp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st;\n                    b = 1 \\<or> b = 0\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp !\n                                     Suc (4 * (st - Suc 0) + 2 * b) =\n                                     snd (tp ! (2 * (st - Suc 0) + b));\n        Suc st \\<le> length tp div 2; 0 < Suc st; b = 1 \\<or> b = 0\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (4 * (Suc st - Suc 0) + 2 * b) =\n                         snd (tp ! (2 * (Suc st - Suc 0) + b))", "assume ind: \n    \"\\<And>tp. \\<lbrakk>st \\<le> length tp div 2; 0 < st; b = 1 \\<or> b = 0\\<rbrakk> \\<Longrightarrow> \n    modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * b) =\n                             snd (tp ! (2 * (st - Suc 0) + b))\"\n    and h:\n    \"Suc st \\<le> length (tp::instr list) div 2\" \n    \"0 < Suc st\" \n    \"b = 1 \\<or> b = 0\""], ["proof (state)\nthis:\n  \\<lbrakk>st \\<le> length ?tp div 2; 0 < st; b = 1 \\<or> b = 0\\<rbrakk>\n  \\<Longrightarrow> modify_tprog ?tp ! Suc (4 * (st - Suc 0) + 2 * b) =\n                    snd (?tp ! (2 * (st - Suc 0) + b))\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n  b = 1 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. \\<And>st tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>st \\<le> length tp div 2; 0 < st;\n                    b = 1 \\<or> b = 0\\<rbrakk>\n                   \\<Longrightarrow> modify_tprog tp !\n                                     Suc (4 * (st - Suc 0) + 2 * b) =\n                                     snd (tp ! (2 * (st - Suc 0) + b));\n        Suc st \\<le> length tp div 2; 0 < Suc st; b = 1 \\<or> b = 0\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (4 * (Suc st - Suc 0) + 2 * b) =\n                         snd (tp ! (2 * (Suc st - Suc 0) + b))", "show \"modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n                             snd (tp ! (2 * (Suc st - Suc 0) + b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "proof(cases \"st = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. st = 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))\n 2. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "case True"], ["proof (state)\nthis:\n  st = 0\n\ngoal (2 subgoals):\n 1. st = 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))\n 2. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  st = 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "using h"], ["proof (prove)\nusing this:\n  st = 0\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n  b = 1 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "apply(cases tp, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>st = 0; Suc st \\<le> length tp div 2; 0 < Suc st;\n        b = 1 \\<or> b = 0; tp = a # list\\<rbrakk>\n       \\<Longrightarrow> modify_tprog tp !\n                         Suc (4 * (Suc st - Suc 0) + 2 * b) =\n                         snd (tp ! (2 * (Suc st - Suc 0) + b))", "apply(cases \"tl tp\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n  snd (tp ! (2 * (Suc st - Suc 0) + b))\n\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "case False"], ["proof (state)\nthis:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "assume g: \"st \\<noteq> 0\""], ["proof (state)\nthis:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "hence \"\\<exists> aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\""], ["proof (prove)\nusing this:\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "using h"], ["proof (prove)\nusing this:\n  st \\<noteq> 0\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n  b = 1 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "by(cases tp, force, cases \"tl tp\", auto)"], ["proof (state)\nthis:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'", "obtain aa ab ba bb tp' where g1:\n      \"tp = (aa, ab) # (ba, bb) # tp'\""], ["proof (prove)\nusing this:\n  \\<exists>aa ab ba bb tp'. tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. (\\<And>aa ab ba bb tp'.\n        tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "hence g2: \n      \"modify_tprog tp' ! Suc (4 * (st - Suc 0) + 2 * b) =\n                              snd (tp' ! (2 * (st - Suc 0) + b))\""], ["proof (prove)\nusing this:\n  tp = (aa, ab) # (ba, bb) # tp'\n\ngoal (1 subgoal):\n 1. modify_tprog tp' ! Suc (4 * (st - Suc 0) + 2 * b) =\n    snd (tp' ! (2 * (st - Suc 0) + b))", "apply(intro ind)"], ["proof (prove)\ngoal (3 subgoals):\n 1. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n    st \\<le> length tp' div 2\n 2. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow> 0 < st\n 3. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow> b = 1 \\<or> b = 0", "using h g"], ["proof (prove)\nusing this:\n  Suc st \\<le> length tp div 2\n  0 < Suc st\n  b = 1 \\<or> b = 0\n  st \\<noteq> 0\n\ngoal (3 subgoals):\n 1. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow>\n    st \\<le> length tp' div 2\n 2. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow> 0 < st\n 3. tp = (aa, ab) # (ba, bb) # tp' \\<Longrightarrow> b = 1 \\<or> b = 0", "by auto"], ["proof (state)\nthis:\n  modify_tprog tp' ! Suc (4 * (st - Suc 0) + 2 * b) =\n  snd (tp' ! (2 * (st - Suc 0) + b))\n\ngoal (1 subgoal):\n 1. st \\<noteq> 0 \\<Longrightarrow>\n    modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  modify_tprog tp' ! Suc (4 * (st - Suc 0) + 2 * b) =\n  snd (tp' ! (2 * (st - Suc 0) + b))\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "using g1 g"], ["proof (prove)\nusing this:\n  modify_tprog tp' ! Suc (4 * (st - Suc 0) + 2 * b) =\n  snd (tp' ! (2 * (st - Suc 0) + b))\n  tp = (aa, ab) # (ba, bb) # tp'\n  st \\<noteq> 0\n\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n    snd (tp ! (2 * (Suc st - Suc 0) + b))", "by(cases st;force)"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n  snd (tp ! (2 * (Suc st - Suc 0) + b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (4 * (Suc st - Suc 0) + 2 * b) =\n  snd (tp ! (2 * (Suc st - Suc 0) + b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fetch_state_eq:\n  \"\\<lbrakk>block_map b = scan r; \n  fetch tp st b = (nact, ns);\n  st \\<le> length tp div 2\\<rbrakk> \\<Longrightarrow> newstat (code tp) st r = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = scan r; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2\\<rbrakk>\n    \\<Longrightarrow> newstat (code tp) st r = ns", "proof(simp add: newstat.simps, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "let ?i = \"Suc (4 * (st - Suc 0) + 2 * (r mod 2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "assume h: \"block_map b = r mod 2\" \"fetch tp st b =\n             (nact, ns)\" \"st \\<le> length tp div 2\" \"0 < st\""], ["proof (state)\nthis:\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "have \"?i < length (modify_tprog tp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)", "have \"length (modify_tprog tp) = 2 * length tp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (modify_tprog tp) = 2 * length tp", "by(simp add: length_modify)"], ["proof (state)\nthis:\n  length (modify_tprog tp) = 2 * length tp\n\ngoal (1 subgoal):\n 1. Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  length (modify_tprog tp) = 2 * length tp\n\ngoal (1 subgoal):\n 1. Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)", "using h"], ["proof (prove)\nusing this:\n  length (modify_tprog tp) = 2 * length tp\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (1 subgoal):\n 1. Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)", "by(auto)"], ["proof (state)\nthis:\n  Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "hence \"Entry (godel_code (modify_tprog tp)) (?i) = \n                                  (modify_tprog tp) ! ?i\""], ["proof (prove)\nusing this:\n  Suc (4 * (st - Suc 0) + 2 * (r mod 2)) < length (modify_tprog tp)\n\ngoal (1 subgoal):\n 1. Entry (godel_code (modify_tprog tp))\n     (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n    modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2))", "by(erule_tac godel_decode)"], ["proof (state)\nthis:\n  Entry (godel_code (modify_tprog tp))\n   (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "moreover"], ["proof (state)\nthis:\n  Entry (godel_code (modify_tprog tp))\n   (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "have \n    \"modify_tprog tp ! ?i =  \n               (snd (tp ! (2 * (st - Suc 0) + r mod 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2)) =\n    snd (tp ! (2 * (st - Suc 0) + r mod 2))", "apply(rule_tac  modify_tprog_fetch_state)"], ["proof (prove)\ngoal (3 subgoals):\n 1. st \\<le> length tp div 2\n 2. 0 < st\n 3. r mod 2 = 1 \\<or> is_even r", "using h"], ["proof (prove)\nusing this:\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (3 subgoals):\n 1. st \\<le> length tp div 2\n 2. 0 < st\n 3. r mod 2 = 1 \\<or> is_even r", "by(auto)"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  snd (tp ! (2 * (st - Suc 0) + r mod 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "moreover"], ["proof (state)\nthis:\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  snd (tp ! (2 * (st - Suc 0) + r mod 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "have \"(snd (tp ! (2 * (st - Suc 0) + r mod 2))) = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (tp ! (2 * (st - Suc 0) + r mod 2)) = ns", "using h"], ["proof (prove)\nusing this:\n  block_map b = r mod 2\n  fetch tp st b = (nact, ns)\n  st \\<le> length tp div 2\n  0 < st\n\ngoal (1 subgoal):\n 1. snd (tp ! (2 * (st - Suc 0) + r mod 2)) = ns", "apply(cases st, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n        st \\<le> length tp div 2; 0 < st; st = Suc nat\\<rbrakk>\n       \\<Longrightarrow> snd (tp ! (2 * (st - Suc 0) + r mod 2)) = ns", "apply(cases b, auto simp: fetch.simps split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2; st = Suc nat; b = Oc;\n        Suc 0 = r mod 2; \\<not> length tp \\<le> 2 * nat + r mod 2;\n        tp ! (2 * nat + r mod 2) = (nact, ns)\\<rbrakk>\n       \\<Longrightarrow> snd (tp ! (2 * (Suc nat - r mod 2) + r mod 2)) = ns", "apply(cases \"(2 * (st - r mod 2) + r mod 2) = \n                       (2 * (st - 1) + r mod 2)\";auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2; st = Suc nat; b = Oc;\n        Suc 0 = r mod 2; \\<not> length tp \\<le> 2 * nat + r mod 2;\n        tp ! (2 * nat + r mod 2) = (nact, ns)\\<rbrakk>\n       \\<Longrightarrow> snd (tp ! (2 * (Suc nat - r mod 2) + r mod 2)) = ns", "by (metis diff_Suc_Suc diff_zero prod.sel(2))"], ["proof (state)\nthis:\n  snd (tp ! (2 * (st - Suc 0) + r mod 2)) = ns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>block_map b = r mod 2; fetch tp st b = (nact, ns);\n     st \\<le> length tp div 2; 0 < st\\<rbrakk>\n    \\<Longrightarrow> Entry (godel_code (modify_tprog tp))\n                       (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n                      ns", "ultimately"], ["proof (chain)\npicking this:\n  Entry (godel_code (modify_tprog tp))\n   (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2))\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  snd (tp ! (2 * (st - Suc 0) + r mod 2))\n  snd (tp ! (2 * (st - Suc 0) + r mod 2)) = ns", "show \"Entry (godel_code (modify_tprog tp)) (?i)\n           = ns\""], ["proof (prove)\nusing this:\n  Entry (godel_code (modify_tprog tp))\n   (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2))\n  modify_tprog tp ! Suc (4 * (st - Suc 0) + 2 * (r mod 2)) =\n  snd (tp ! (2 * (st - Suc 0) + r mod 2))\n  snd (tp ! (2 * (st - Suc 0) + r mod 2)) = ns\n\ngoal (1 subgoal):\n 1. Entry (godel_code (modify_tprog tp))\n     (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n    ns", "by simp"], ["proof (state)\nthis:\n  Entry (godel_code (modify_tprog tp))\n   (Suc (4 * (st - Suc 0) + 2 * (r mod 2))) =\n  ns\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tpl_eqI[intro!]: \n  \"\\<lbrakk>a = a'; b = b'; c = c'\\<rbrakk> \\<Longrightarrow> trpl a b c = trpl a' b' c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = a'; b = b'; c = c'\\<rbrakk>\n    \\<Longrightarrow> trpl a b c = trpl a' b' c'", "by simp"], ["", "lemma bl2nat_double: \"bl2nat xs (Suc n) = 2 * bl2nat xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat xs (Suc n) = 2 * bl2nat xs n", "proof(induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. bl2nat [] (Suc n) = 2 * bl2nat [] n\n 2. \\<And>a xs n.\n       (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n       bl2nat (a # xs) (Suc n) = 2 * bl2nat (a # xs) n", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>n. bl2nat [] (Suc n) = 2 * bl2nat [] n\n 2. \\<And>a xs n.\n       (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n       bl2nat (a # xs) (Suc n) = 2 * bl2nat (a # xs) n", "thus \"?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat [] (Suc n) = 2 * bl2nat [] n", "by(simp add: bl2nat.simps)"], ["proof (state)\nthis:\n  bl2nat [] (Suc n) = 2 * bl2nat [] n\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n       bl2nat (a # xs) (Suc n) = 2 * bl2nat (a # xs) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n       bl2nat (a # xs) (Suc n) = 2 * bl2nat (a # xs) n", "case (Cons x xs)"], ["proof (state)\nthis:\n  bl2nat xs (Suc ?n) = 2 * bl2nat xs ?n\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n       bl2nat (a # xs) (Suc n) = 2 * bl2nat (a # xs) n", "thus \"?case\""], ["proof (prove)\nusing this:\n  bl2nat xs (Suc ?n) = 2 * bl2nat xs ?n\n\ngoal (1 subgoal):\n 1. bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n    bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "assume ind: \"\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n \""], ["proof (state)\nthis:\n  bl2nat xs (Suc ?n) = 2 * bl2nat xs ?n\n\ngoal (1 subgoal):\n 1. (\\<And>n. bl2nat xs (Suc n) = 2 * bl2nat xs n) \\<Longrightarrow>\n    bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "show \"bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "proof(cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = Bk \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\n 2. x = Oc \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "case Bk"], ["proof (state)\nthis:\n  x = Bk\n\ngoal (2 subgoals):\n 1. x = Bk \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\n 2. x = Oc \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  x = Bk\n\ngoal (1 subgoal):\n 1. bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "apply(simp add: bl2nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Bk \\<Longrightarrow> bl2nat xs (Suc (Suc n)) = 2 * bl2nat xs (Suc n)", "using ind[of \"Suc n\"]"], ["proof (prove)\nusing this:\n  bl2nat xs (Suc (Suc n)) = 2 * bl2nat xs (Suc n)\n\ngoal (1 subgoal):\n 1. x = Bk \\<Longrightarrow> bl2nat xs (Suc (Suc n)) = 2 * bl2nat xs (Suc n)", "by simp"], ["proof (state)\nthis:\n  bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\n\ngoal (1 subgoal):\n 1. x = Oc \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = Oc \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "case Oc"], ["proof (state)\nthis:\n  x = Oc\n\ngoal (1 subgoal):\n 1. x = Oc \\<Longrightarrow> bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  x = Oc\n\ngoal (1 subgoal):\n 1. bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n", "apply(simp add: bl2nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Oc \\<Longrightarrow> bl2nat xs (Suc (Suc n)) = 2 * bl2nat xs (Suc n)", "using ind[of \"Suc n\"]"], ["proof (prove)\nusing this:\n  bl2nat xs (Suc (Suc n)) = 2 * bl2nat xs (Suc n)\n\ngoal (1 subgoal):\n 1. x = Oc \\<Longrightarrow> bl2nat xs (Suc (Suc n)) = 2 * bl2nat xs (Suc n)", "by simp"], ["proof (state)\nthis:\n  bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bl2nat (x # xs) (Suc n) = 2 * bl2nat (x # xs) n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl2wc_simps[simp]:\n  \"bl2wc (Oc # tl c) = Suc (bl2wc c) - bl2wc c mod 2 \"\n  \"bl2wc (Bk # c) = 2*bl2wc (c)\"\n  \"2 * bl2wc (tl c) = bl2wc c - bl2wc c mod 2 \"\n  \"bl2wc [Oc] = Suc 0\"\n  \"c \\<noteq> [] \\<Longrightarrow> bl2wc (tl c) = bl2wc c div 2\"\n  \"c \\<noteq> [] \\<Longrightarrow> bl2wc [hd c] = bl2wc c mod 2\"\n  \"c \\<noteq> [] \\<Longrightarrow> bl2wc (hd c # d) = 2 * bl2wc d + bl2wc c mod 2\"\n  \"2 * (bl2wc c div 2) = bl2wc c - bl2wc c mod 2\"\n  \"bl2wc (Oc # list) mod 2 = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((bl2wc (Oc # tl c) = Suc (bl2wc c) - bl2wc c mod 2 &&&\n      bl2wc (Bk # c) = 2 * bl2wc c) &&&\n     2 * bl2wc (tl c) = bl2wc c - bl2wc c mod 2 &&& bl2wc [Oc] = Suc 0) &&&\n    ((c \\<noteq> [] \\<Longrightarrow> bl2wc (tl c) = bl2wc c div 2) &&&\n     (c \\<noteq> [] \\<Longrightarrow> bl2wc [hd c] = bl2wc c mod 2)) &&&\n    (c \\<noteq> [] \\<Longrightarrow>\n     bl2wc (hd c # d) = 2 * bl2wc d + bl2wc c mod 2) &&&\n    2 * (bl2wc c div 2) = bl2wc c - bl2wc c mod 2 &&&\n    bl2wc (Oc # list) mod 2 = Suc 0", "by(cases c;cases \"hd c\";force simp: bl2wc.simps bl2nat.simps bl2nat_double)+"], ["", "declare code.simps[simp del]"], ["", "declare nth_of.simps[simp del]"], ["", "text \\<open>\n  The lemma relates the one step execution of TMs with the interpreter function \\<open>rec_newconf\\<close>.\n\\<close>"], ["", "lemma rec_t_eq_step: \n  \"(\\<lambda> (s, l, r). s \\<le> length tp div 2) c \\<Longrightarrow>\n  trpl_code (step0 c tp) = \n  rec_exec rec_newconf [code tp, trpl_code c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case c of\n    (s, l, r) \\<Rightarrow> s \\<le> length tp div 2 \\<Longrightarrow>\n    trpl_code (step0 c tp) = rec_exec rec_newconf [code tp, trpl_code c]", "proof(cases c)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ca.\n       \\<lbrakk>case c of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2;\n        c = (a, b, ca)\\<rbrakk>\n       \\<Longrightarrow> trpl_code (step0 c tp) =\n                         rec_exec rec_newconf [code tp, trpl_code c]", "case (fields s l r)"], ["proof (state)\nthis:\n  c = (s, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b ca.\n       \\<lbrakk>case c of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2;\n        c = (a, b, ca)\\<rbrakk>\n       \\<Longrightarrow> trpl_code (step0 c tp) =\n                         rec_exec rec_newconf [code tp, trpl_code c]", "assume \"case c of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2\""], ["proof (state)\nthis:\n  case c of (s__, l, r) \\<Rightarrow> s__ \\<le> length tp div 2\n\ngoal (1 subgoal):\n 1. \\<And>a b ca.\n       \\<lbrakk>case c of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2;\n        c = (a, b, ca)\\<rbrakk>\n       \\<Longrightarrow> trpl_code (step0 c tp) =\n                         rec_exec rec_newconf [code tp, trpl_code c]", "with fields"], ["proof (chain)\npicking this:\n  c = (s, l, r)\n  case c of (s__, l, r) \\<Rightarrow> s__ \\<le> length tp div 2", "have \"s \\<le> length tp div 2\""], ["proof (prove)\nusing this:\n  c = (s, l, r)\n  case c of (s__, l, r) \\<Rightarrow> s__ \\<le> length tp div 2\n\ngoal (1 subgoal):\n 1. s \\<le> length tp div 2", "by auto"], ["proof (state)\nthis:\n  s \\<le> length tp div 2\n\ngoal (1 subgoal):\n 1. \\<And>a b ca.\n       \\<lbrakk>case c of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2;\n        c = (a, b, ca)\\<rbrakk>\n       \\<Longrightarrow> trpl_code (step0 c tp) =\n                         rec_exec rec_newconf [code tp, trpl_code c]", "thus ?thesis"], ["proof (prove)\nusing this:\n  s \\<le> length tp div 2\n\ngoal (1 subgoal):\n 1. trpl_code (step0 c tp) = rec_exec rec_newconf [code tp, trpl_code c]", "unfolding fields"], ["proof (prove)\nusing this:\n  s \\<le> length tp div 2\n\ngoal (1 subgoal):\n 1. trpl_code (step0 (s, l, r) tp) =\n    rec_exec rec_newconf [code tp, trpl_code (s, l, r)]", "proof(cases \"fetch tp s (read r)\",\n      simp add: newconf.simps trpl_code.simps step.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "fix a b ca aa ba"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "assume h: \"(a::nat) \\<le> length tp div 2\" \n      \"fetch tp a (read ca) = (aa, ba)\""], ["proof (state)\nthis:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "moreover"], ["proof (state)\nthis:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "hence \"actn (code tp) a (bl2wc ca) = action_map aa\""], ["proof (prove)\nusing this:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)\n\ngoal (1 subgoal):\n 1. actn (code tp) a (bl2wc ca) = action_map aa", "apply(rule_tac b = \"read ca\" \n          in fetch_action_eq, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (hd ca) = (aa, ba);\n     ca \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> block_map (hd ca) = bl2wc ca mod 2", "apply(cases \"hd ca\";cases ca;force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  actn (code tp) a (bl2wc ca) = action_map aa\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "moreover"], ["proof (state)\nthis:\n  actn (code tp) a (bl2wc ca) = action_map aa\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "from h"], ["proof (chain)\npicking this:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)", "have \"(newstat (code tp) a (bl2wc ca)) = ba\""], ["proof (prove)\nusing this:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)\n\ngoal (1 subgoal):\n 1. newstat (code tp) a (bl2wc ca) = ba", "apply(rule_tac b = \"read ca\" \n          in fetch_state_eq, auto split: list.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (hd ca) = (aa, ba);\n     ca \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> block_map (hd ca) = bl2wc ca mod 2", "apply(cases \"hd ca\";cases ca;force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  newstat (code tp) a (bl2wc ca) = ba\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fetch tp s (read r) = (a, b);\n        s \\<le> length tp div 2\\<rbrakk>\n       \\<Longrightarrow> trpl_code (b, update a (l, r)) =\n                         trpl\n                          (newleft (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))\n                          (newstat (code tp) s (bl2wc r))\n                          (newrght (bl2wc l) (bl2wc r)\n                            (actn (code tp) s (bl2wc r)))", "ultimately"], ["proof (chain)\npicking this:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)\n  actn (code tp) a (bl2wc ca) = action_map aa\n  newstat (code tp) a (bl2wc ca) = ba", "show \n      \"trpl_code (ba, update aa (b, ca)) =\n          trpl (newleft (bl2wc b) (bl2wc ca) (actn (code tp) a (bl2wc ca))) \n    (newstat (code tp) a (bl2wc ca)) (newrght (bl2wc b) (bl2wc ca) (actn (code tp) a (bl2wc ca)))\""], ["proof (prove)\nusing this:\n  a \\<le> length tp div 2\n  fetch tp a (read ca) = (aa, ba)\n  actn (code tp) a (bl2wc ca) = action_map aa\n  newstat (code tp) a (bl2wc ca) = ba\n\ngoal (1 subgoal):\n 1. trpl_code (ba, update aa (b, ca)) =\n    trpl (newleft (bl2wc b) (bl2wc ca) (actn (code tp) a (bl2wc ca)))\n     (newstat (code tp) a (bl2wc ca))\n     (newrght (bl2wc b) (bl2wc ca) (actn (code tp) a (bl2wc ca)))", "apply(cases aa)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (read ca) = (aa, ba);\n     actn (code tp) a (bl2wc ca) = action_map aa;\n     newstat (code tp) a (bl2wc ca) = ba; aa = W0\\<rbrakk>\n    \\<Longrightarrow> trpl_code (ba, update aa (b, ca)) =\n                      trpl\n                       (newleft (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n                       (newstat (code tp) a (bl2wc ca))\n                       (newrght (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n 2. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (read ca) = (aa, ba);\n     actn (code tp) a (bl2wc ca) = action_map aa;\n     newstat (code tp) a (bl2wc ca) = ba; aa = W1\\<rbrakk>\n    \\<Longrightarrow> trpl_code (ba, update aa (b, ca)) =\n                      trpl\n                       (newleft (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n                       (newstat (code tp) a (bl2wc ca))\n                       (newrght (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n 3. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (read ca) = (aa, ba);\n     actn (code tp) a (bl2wc ca) = action_map aa;\n     newstat (code tp) a (bl2wc ca) = ba; aa = L\\<rbrakk>\n    \\<Longrightarrow> trpl_code (ba, update aa (b, ca)) =\n                      trpl\n                       (newleft (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n                       (newstat (code tp) a (bl2wc ca))\n                       (newrght (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n 4. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (read ca) = (aa, ba);\n     actn (code tp) a (bl2wc ca) = action_map aa;\n     newstat (code tp) a (bl2wc ca) = ba; aa = R\\<rbrakk>\n    \\<Longrightarrow> trpl_code (ba, update aa (b, ca)) =\n                      trpl\n                       (newleft (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n                       (newstat (code tp) a (bl2wc ca))\n                       (newrght (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n 5. \\<lbrakk>a \\<le> length tp div 2; fetch tp a (read ca) = (aa, ba);\n     actn (code tp) a (bl2wc ca) = action_map aa;\n     newstat (code tp) a (bl2wc ca) = ba; aa = Nop\\<rbrakk>\n    \\<Longrightarrow> trpl_code (ba, update aa (b, ca)) =\n                      trpl\n                       (newleft (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))\n                       (newstat (code tp) a (bl2wc ca))\n                       (newrght (bl2wc b) (bl2wc ca)\n                         (actn (code tp) a (bl2wc ca)))", "apply(auto simp: trpl_code.simps \n          newleft.simps newrght.simps split: action.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trpl_code (ba, update aa (b, ca)) =\n  trpl (newleft (bl2wc b) (bl2wc ca) (actn (code tp) a (bl2wc ca)))\n   (newstat (code tp) a (bl2wc ca))\n   (newrght (bl2wc b) (bl2wc ca) (actn (code tp) a (bl2wc ca)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trpl_code (step0 c tp) = rec_exec rec_newconf [code tp, trpl_code c]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl2nat_simps[simp]: \"bl2nat (Oc # Oc\\<up>x) 0 = (2 * 2 ^ x - Suc 0)\"\n  \"bl2nat (Bk\\<up>x) n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (Oc # Oc \\<up> x) 0 = 2 * 2 ^ x - Suc 0 &&&\n    bl2nat (Bk \\<up> x) n = 0", "by(induct x;force simp: bl2nat.simps bl2nat_double exp_ind)+"], ["", "lemma bl2nat_exp_zero[simp]: \"bl2nat (Oc\\<up>y) 0 = 2^y - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (Oc \\<up> y) 0 = 2 ^ y - Suc 0", "proof(induct y)"], ["proof (state)\ngoal (2 subgoals):\n 1. bl2nat (Oc \\<up> 0) 0 = 2 ^ 0 - Suc 0\n 2. \\<And>y.\n       bl2nat (Oc \\<up> y) 0 = 2 ^ y - Suc 0 \\<Longrightarrow>\n       bl2nat (Oc \\<up> Suc y) 0 = 2 ^ Suc y - Suc 0", "case (Suc y)"], ["proof (state)\nthis:\n  bl2nat (Oc \\<up> y) 0 = 2 ^ y - Suc 0\n\ngoal (2 subgoals):\n 1. bl2nat (Oc \\<up> 0) 0 = 2 ^ 0 - Suc 0\n 2. \\<And>y.\n       bl2nat (Oc \\<up> y) 0 = 2 ^ y - Suc 0 \\<Longrightarrow>\n       bl2nat (Oc \\<up> Suc y) 0 = 2 ^ Suc y - Suc 0", "then"], ["proof (chain)\npicking this:\n  bl2nat (Oc \\<up> y) 0 = 2 ^ y - Suc 0", "show ?case"], ["proof (prove)\nusing this:\n  bl2nat (Oc \\<up> y) 0 = 2 ^ y - Suc 0\n\ngoal (1 subgoal):\n 1. bl2nat (Oc \\<up> Suc y) 0 = 2 ^ Suc y - Suc 0", "by(cases \"(2::nat)^y\", auto)"], ["proof (state)\nthis:\n  bl2nat (Oc \\<up> Suc y) 0 = 2 ^ Suc y - Suc 0\n\ngoal (1 subgoal):\n 1. bl2nat (Oc \\<up> 0) 0 = 2 ^ 0 - Suc 0", "qed (auto simp: bl2nat.simps bl2nat_double)"], ["", "lemma bl2nat_cons_bk: \"bl2nat (ks @ [Bk]) 0 = bl2nat ks 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (ks @ [Bk]) 0 = bl2nat ks 0", "proof(induct ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. bl2nat ([] @ [Bk]) 0 = bl2nat [] 0\n 2. \\<And>a ks.\n       bl2nat (ks @ [Bk]) 0 = bl2nat ks 0 \\<Longrightarrow>\n       bl2nat ((a # ks) @ [Bk]) 0 = bl2nat (a # ks) 0", "case (Cons a ks)"], ["proof (state)\nthis:\n  bl2nat (ks @ [Bk]) 0 = bl2nat ks 0\n\ngoal (2 subgoals):\n 1. bl2nat ([] @ [Bk]) 0 = bl2nat [] 0\n 2. \\<And>a ks.\n       bl2nat (ks @ [Bk]) 0 = bl2nat ks 0 \\<Longrightarrow>\n       bl2nat ((a # ks) @ [Bk]) 0 = bl2nat (a # ks) 0", "then"], ["proof (chain)\npicking this:\n  bl2nat (ks @ [Bk]) 0 = bl2nat ks 0", "show ?case"], ["proof (prove)\nusing this:\n  bl2nat (ks @ [Bk]) 0 = bl2nat ks 0\n\ngoal (1 subgoal):\n 1. bl2nat ((a # ks) @ [Bk]) 0 = bl2nat (a # ks) 0", "by (cases a, auto simp: bl2nat.simps bl2nat_double)"], ["proof (state)\nthis:\n  bl2nat ((a # ks) @ [Bk]) 0 = bl2nat (a # ks) 0\n\ngoal (1 subgoal):\n 1. bl2nat ([] @ [Bk]) 0 = bl2nat [] 0", "qed (auto simp: bl2nat.simps)"], ["", "lemma bl2nat_cons_oc:\n  \"bl2nat (ks @ [Oc]) 0 =  bl2nat ks 0 + 2 ^ length ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (ks @ [Oc]) 0 = bl2nat ks 0 + 2 ^ length ks", "proof(induct ks)"], ["proof (state)\ngoal (2 subgoals):\n 1. bl2nat ([] @ [Oc]) 0 = bl2nat [] 0 + 2 ^ length []\n 2. \\<And>a ks.\n       bl2nat (ks @ [Oc]) 0 = bl2nat ks 0 + 2 ^ length ks \\<Longrightarrow>\n       bl2nat ((a # ks) @ [Oc]) 0 = bl2nat (a # ks) 0 + 2 ^ length (a # ks)", "case (Cons a ks)"], ["proof (state)\nthis:\n  bl2nat (ks @ [Oc]) 0 = bl2nat ks 0 + 2 ^ length ks\n\ngoal (2 subgoals):\n 1. bl2nat ([] @ [Oc]) 0 = bl2nat [] 0 + 2 ^ length []\n 2. \\<And>a ks.\n       bl2nat (ks @ [Oc]) 0 = bl2nat ks 0 + 2 ^ length ks \\<Longrightarrow>\n       bl2nat ((a # ks) @ [Oc]) 0 = bl2nat (a # ks) 0 + 2 ^ length (a # ks)", "then"], ["proof (chain)\npicking this:\n  bl2nat (ks @ [Oc]) 0 = bl2nat ks 0 + 2 ^ length ks", "show ?case"], ["proof (prove)\nusing this:\n  bl2nat (ks @ [Oc]) 0 = bl2nat ks 0 + 2 ^ length ks\n\ngoal (1 subgoal):\n 1. bl2nat ((a # ks) @ [Oc]) 0 = bl2nat (a # ks) 0 + 2 ^ length (a # ks)", "by(cases a, auto simp: bl2nat.simps bl2nat_double)"], ["proof (state)\nthis:\n  bl2nat ((a # ks) @ [Oc]) 0 = bl2nat (a # ks) 0 + 2 ^ length (a # ks)\n\ngoal (1 subgoal):\n 1. bl2nat ([] @ [Oc]) 0 = bl2nat [] 0 + 2 ^ length []", "qed (auto simp: bl2nat.simps)"], ["", "lemma bl2nat_append: \n  \"bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs)", "proof(induct \"length xs\" arbitrary: xs ys, simp add: bl2nat.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "fix x xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "assume ind: \n    \"\\<And>xs ys. x = length xs \\<Longrightarrow> \n             bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs)\"\n    and h: \"Suc x = length (xs::cell list)\""], ["proof (state)\nthis:\n  x = length ?xs \\<Longrightarrow>\n  bl2nat (?xs @ ?ys) 0 = bl2nat ?xs 0 + bl2nat ?ys (length ?xs)\n  Suc x = length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "have \"\\<exists> ks k. xs = ks @ [k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ks k. xs = ks @ [k]", "apply(rule_tac x = \"butlast xs\" in exI,\n        rule_tac x = \"last xs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = butlast xs @ [last xs]", "using h"], ["proof (prove)\nusing this:\n  Suc x = length xs\n\ngoal (1 subgoal):\n 1. xs = butlast xs @ [last xs]", "apply(cases xs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ks k. xs = ks @ [k]\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>ks k. xs = ks @ [k]", "obtain ks k where \"xs = ks @ [k]\""], ["proof (prove)\nusing this:\n  \\<exists>ks k. xs = ks @ [k]\n\ngoal (1 subgoal):\n 1. (\\<And>ks k. xs = ks @ [k] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = ks @ [k]\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "moreover"], ["proof (state)\nthis:\n  xs = ks @ [k]\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "hence \n    \"bl2nat (ks @ (k # ys)) 0 = bl2nat ks 0 +\n                               bl2nat (k # ys) (length ks)\""], ["proof (prove)\nusing this:\n  xs = ks @ [k]\n\ngoal (1 subgoal):\n 1. bl2nat (ks @ k # ys) 0 = bl2nat ks 0 + bl2nat (k # ys) (length ks)", "apply(rule_tac ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ks @ [k] \\<Longrightarrow> x = length ks", "using h"], ["proof (prove)\nusing this:\n  Suc x = length xs\n\ngoal (1 subgoal):\n 1. xs = ks @ [k] \\<Longrightarrow> x = length ks", "by simp"], ["proof (state)\nthis:\n  bl2nat (ks @ k # ys) 0 = bl2nat ks 0 + bl2nat (k # ys) (length ks)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>xs ys.\n                   x = length xs \\<Longrightarrow>\n                   bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs);\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> bl2nat (xs @ ys) 0 =\n                         bl2nat xs 0 + bl2nat ys (length xs)", "ultimately"], ["proof (chain)\npicking this:\n  xs = ks @ [k]\n  bl2nat (ks @ k # ys) 0 = bl2nat ks 0 + bl2nat (k # ys) (length ks)", "show \"bl2nat (xs @ ys) 0 = \n                  bl2nat xs 0 + bl2nat ys (length xs)\""], ["proof (prove)\nusing this:\n  xs = ks @ [k]\n  bl2nat (ks @ k # ys) 0 = bl2nat ks 0 + bl2nat (k # ys) (length ks)\n\ngoal (1 subgoal):\n 1. bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs)", "apply(cases k, simp_all add: bl2nat.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bl2nat (ks @ Bk # ys) 0 =\n             bl2nat ks 0 + bl2nat ys (Suc (length ks));\n     k = Bk; xs = ks @ [Bk]\\<rbrakk>\n    \\<Longrightarrow> bl2nat ks 0 = bl2nat (ks @ [Bk]) 0\n 2. \\<lbrakk>bl2nat (ks @ Oc # ys) 0 =\n             bl2nat ks 0 + (2 ^ length ks + bl2nat ys (Suc (length ks)));\n     k = Oc; xs = ks @ [Oc]\\<rbrakk>\n    \\<Longrightarrow> bl2nat ks 0 + 2 ^ length ks = bl2nat (ks @ [Oc]) 0", "apply(simp_all only: bl2nat_cons_bk bl2nat_cons_oc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bl2nat (xs @ ys) 0 = bl2nat xs 0 + bl2nat ys (length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trpl_code_simp[simp]:\n  \"trpl_code (steps0 (Suc 0, Bk\\<up>l, <lm>) tp 0) = \n    rec_exec rec_conf [code tp, bl2wc (<lm>), 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), 0]", "apply(simp add: steps.simps rec_exec.simps conf_lemma  conf.simps \n      inpt.simps trpl_code.simps bl2wc.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The following lemma relates the multi-step interpreter function \\<open>rec_conf\\<close>\n  with the multi-step execution of TMs.\n\\<close>"], ["", "lemma state_in_range_step\n  : \"\\<lbrakk>a \\<le> length A div 2; step0 (a, b, c) A = (st, l, r); tm_wf (A,0)\\<rbrakk>\n  \\<Longrightarrow> st \\<le> length A div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> length A div 2; step0 (a, b, c) A = (st, l, r);\n     tm_wf0 A\\<rbrakk>\n    \\<Longrightarrow> st \\<le> length A div 2", "apply(simp add: step.simps fetch.simps tm_wf.simps \n      split: if_splits list.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<le> length A div 2; c = []; 2 \\<le> length A;\n     is_even (length A);\n     \\<forall>x\\<in>set A.\n        case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n     (case fetch A a Bk of (a, s') \\<Rightarrow> (s', update a (b, []))) =\n     (st, l, r)\\<rbrakk>\n    \\<Longrightarrow> st \\<le> length A div 2\n 2. \\<lbrakk>a \\<le> length A div 2; c \\<noteq> []; 2 \\<le> length A;\n     is_even (length A);\n     \\<forall>x\\<in>set A.\n        case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n     (case fetch A a (hd c) of\n      (a, s') \\<Rightarrow> (s', update a (b, c))) =\n     (st, l, r)\\<rbrakk>\n    \\<Longrightarrow> st \\<le> length A div 2", "apply(case_tac [!] a, auto simp: list_all_length \n      fetch.simps nth_of.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length A div 2; c = []; 2 \\<le> length A;\n        \\<forall>x\\<in>set A.\n           case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n        (case case if length A \\<le> 2 * nat then None\n                   else Some (A ! (2 * nat)) of\n              None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i of\n         (a, s') \\<Rightarrow> (s', update a (b, []))) =\n        (st, l, r);\n        a = Suc nat; even (length A)\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2\n 2. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length A div 2; c \\<noteq> [];\n        2 \\<le> length A;\n        \\<forall>x\\<in>set A.\n           case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n        (case fetch A (Suc nat) (hd c) of\n         (a, s') \\<Rightarrow> (s', update a (b, c))) =\n        (st, l, r);\n        a = Suc nat; even (length A)\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "apply(erule_tac x = \"A ! (2*nat) \" in ballE, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length A div 2; c \\<noteq> [];\n        2 \\<le> length A;\n        \\<forall>x\\<in>set A.\n           case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n        (case fetch A (Suc nat) (hd c) of\n         (a, s') \\<Rightarrow> (s', update a (b, c))) =\n        (st, l, r);\n        a = Suc nat; even (length A)\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "apply(cases \"hd c\", auto simp: fetch.simps nth_of.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length A div 2; c \\<noteq> [];\n        2 \\<le> length A;\n        \\<forall>x\\<in>set A.\n           case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n        (case case if length A \\<le> 2 * nat then None\n                   else Some (A ! (2 * nat)) of\n              None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i of\n         (a, s') \\<Rightarrow> (s', update a (b, c))) =\n        (st, l, r);\n        a = Suc nat; even (length A); hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2\n 2. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length A div 2; c \\<noteq> [];\n        2 \\<le> length A;\n        \\<forall>x\\<in>set A.\n           case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n        (case case if length A \\<le> Suc (2 * nat) then None\n                   else Some (A ! Suc (2 * nat)) of\n              None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i of\n         (a, s') \\<Rightarrow> (s', update a (b, c))) =\n        (st, l, r);\n        a = Suc nat; even (length A); hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "apply(erule_tac x = \"A !(2 * nat)\" in ballE, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length A div 2; c \\<noteq> [];\n        2 \\<le> length A;\n        \\<forall>x\\<in>set A.\n           case x of (a, s) \\<Rightarrow> s \\<le> length A div 2;\n        (case case if length A \\<le> Suc (2 * nat) then None\n                   else Some (A ! Suc (2 * nat)) of\n              None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i of\n         (a, s') \\<Rightarrow> (s', update a (b, c))) =\n        (st, l, r);\n        a = Suc nat; even (length A); hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "apply(erule_tac x = \"A !Suc (2 * nat)\" in ballE, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma state_in_range: \"\\<lbrakk>steps0 (Suc 0, tp) A stp = (st, l, r); tm_wf (A, 0)\\<rbrakk>\n  \\<Longrightarrow> st \\<le> length A div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, tp) A stp = (st, l, r); tm_wf0 A\\<rbrakk>\n    \\<Longrightarrow> st \\<le> length A div 2", "proof(induct stp arbitrary: st l r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>st l r.\n       \\<lbrakk>steps0 (Suc 0, tp) A 0 = (st, l, r); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2\n 2. \\<And>stp st l r.\n       \\<lbrakk>\\<And>st l r.\n                   \\<lbrakk>steps0 (Suc 0, tp) A stp = (st, l, r);\n                    tm_wf0 A\\<rbrakk>\n                   \\<Longrightarrow> st \\<le> length A div 2;\n        steps0 (Suc 0, tp) A (Suc stp) = (st, l, r); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "case (Suc stp st l r)"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (Suc 0, tp) A stp = (?st, ?l, ?r); tm_wf0 A\\<rbrakk>\n  \\<Longrightarrow> ?st \\<le> length A div 2\n  steps0 (Suc 0, tp) A (Suc stp) = (st, l, r)\n  tm_wf0 A\n\ngoal (2 subgoals):\n 1. \\<And>st l r.\n       \\<lbrakk>steps0 (Suc 0, tp) A 0 = (st, l, r); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2\n 2. \\<And>stp st l r.\n       \\<lbrakk>\\<And>st l r.\n                   \\<lbrakk>steps0 (Suc 0, tp) A stp = (st, l, r);\n                    tm_wf0 A\\<rbrakk>\n                   \\<Longrightarrow> st \\<le> length A div 2;\n        steps0 (Suc 0, tp) A (Suc stp) = (st, l, r); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "from Suc.prems"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, tp) A (Suc stp) = (st, l, r)\n  tm_wf0 A", "show ?case"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, tp) A (Suc stp) = (st, l, r)\n  tm_wf0 A\n\ngoal (1 subgoal):\n 1. st \\<le> length A div 2", "proof(simp add: step_red, cases \"(steps0 (Suc 0, tp) A stp)\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>step0 (a, b, c) A = (st, l, r);\n        steps0 (Suc 0, tp) A stp = (a, b, c); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>step0 (a, b, c) A = (st, l, r);\n        steps0 (Suc 0, tp) A stp = (a, b, c); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "assume h3: \"step0 (a, b, c) A = (st, l, r)\"\n      and h4: \"steps0 (Suc 0, tp) A stp = (a, b, c)\""], ["proof (state)\nthis:\n  step0 (a, b, c) A = (st, l, r)\n  steps0 (Suc 0, tp) A stp = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>step0 (a, b, c) A = (st, l, r);\n        steps0 (Suc 0, tp) A stp = (a, b, c); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "have \"a \\<le> length A div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> length A div 2", "using Suc.prems h4"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, tp) A (Suc stp) = (st, l, r)\n  tm_wf0 A\n  steps0 (Suc 0, tp) A stp = (a, b, c)\n\ngoal (1 subgoal):\n 1. a \\<le> length A div 2", "by (auto intro: Suc.hyps)"], ["proof (state)\nthis:\n  a \\<le> length A div 2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>step0 (a, b, c) A = (st, l, r);\n        steps0 (Suc 0, tp) A stp = (a, b, c); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  a \\<le> length A div 2\n\ngoal (1 subgoal):\n 1. st \\<le> length A div 2", "using h3 Suc.prems"], ["proof (prove)\nusing this:\n  a \\<le> length A div 2\n  step0 (a, b, c) A = (st, l, r)\n  steps0 (Suc 0, tp) A (Suc stp) = (st, l, r)\n  tm_wf0 A\n\ngoal (1 subgoal):\n 1. st \\<le> length A div 2", "by (auto elim: state_in_range_step)"], ["proof (state)\nthis:\n  st \\<le> length A div 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st \\<le> length A div 2\n\ngoal (1 subgoal):\n 1. \\<And>st l r.\n       \\<lbrakk>steps0 (Suc 0, tp) A 0 = (st, l, r); tm_wf0 A\\<rbrakk>\n       \\<Longrightarrow> st \\<le> length A div 2", "qed(auto simp: tm_wf.simps steps.simps)"], ["", "lemma rec_t_eq_steps:\n  \"tm_wf (tp,0) \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp) = \n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 tp \\<Longrightarrow>\n    trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), stp]", "proof(induct stp)"], ["proof (state)\ngoal (2 subgoals):\n 1. tm_wf0 tp \\<Longrightarrow>\n    trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), 0]\n 2. \\<And>stp.\n       \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n                trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n                rec_exec rec_conf [code tp, bl2wc (<lm>), stp];\n        tm_wf0 tp\\<rbrakk>\n       \\<Longrightarrow> trpl_code\n                          (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp)) =\n                         rec_exec rec_conf [code tp, bl2wc (<lm>), Suc stp]", "case 0"], ["proof (state)\nthis:\n  tm_wf0 tp\n\ngoal (2 subgoals):\n 1. tm_wf0 tp \\<Longrightarrow>\n    trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), 0]\n 2. \\<And>stp.\n       \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n                trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n                rec_exec rec_conf [code tp, bl2wc (<lm>), stp];\n        tm_wf0 tp\\<rbrakk>\n       \\<Longrightarrow> trpl_code\n                          (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp)) =\n                         rec_exec rec_conf [code tp, bl2wc (<lm>), Suc stp]", "thus \"?case\""], ["proof (prove)\nusing this:\n  tm_wf0 tp\n\ngoal (1 subgoal):\n 1. trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), 0]", "by(simp)"], ["proof (state)\nthis:\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), 0]\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n                trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n                rec_exec rec_conf [code tp, bl2wc (<lm>), stp];\n        tm_wf0 tp\\<rbrakk>\n       \\<Longrightarrow> trpl_code\n                          (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp)) =\n                         rec_exec rec_conf [code tp, bl2wc (<lm>), Suc stp]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n                trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n                rec_exec rec_conf [code tp, bl2wc (<lm>), stp];\n        tm_wf0 tp\\<rbrakk>\n       \\<Longrightarrow> trpl_code\n                          (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp)) =\n                         rec_exec rec_conf [code tp, bl2wc (<lm>), Suc stp]", "case (Suc n)"], ["proof (state)\nthis:\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp n) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), n]\n  tm_wf0 tp\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n                trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n                rec_exec rec_conf [code tp, bl2wc (<lm>), stp];\n        tm_wf0 tp\\<rbrakk>\n       \\<Longrightarrow> trpl_code\n                          (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp)) =\n                         rec_exec rec_conf [code tp, bl2wc (<lm>), Suc stp]", "thus \"?case\""], ["proof (prove)\nusing this:\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp n) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), n]\n  tm_wf0 tp\n\ngoal (1 subgoal):\n 1. trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc n)) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n             trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp n) =\n             rec_exec rec_conf [code tp, bl2wc (<lm>), n];\n     tm_wf0 tp\\<rbrakk>\n    \\<Longrightarrow> trpl_code\n                       (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc n)) =\n                      rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]", "assume ind: \n      \"tm_wf (tp,0) \\<Longrightarrow> trpl_code (steps0 (Suc 0, Bk\\<up> l, <lm>) tp n) \n      = rec_exec rec_conf [code tp, bl2wc (<lm>), n]\"\n      and h: \"tm_wf (tp, 0)\""], ["proof (state)\nthis:\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp n) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), n]\n  tm_wf0 tp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp \\<Longrightarrow>\n             trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp n) =\n             rec_exec rec_conf [code tp, bl2wc (<lm>), n];\n     tm_wf0 tp\\<rbrakk>\n    \\<Longrightarrow> trpl_code\n                       (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc n)) =\n                      rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]", "show \n      \"trpl_code (steps0 (Suc 0, Bk\\<up> l, <lm>) tp (Suc n)) =\n      rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc n)) =\n    rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]", "proof(cases \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp  n\", \n        simp only: step_red conf_lemma conf.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c) \\<Longrightarrow>\n       trpl_code (step0 (a, b, c) tp) =\n       newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c) \\<Longrightarrow>\n       trpl_code (step0 (a, b, c) tp) =\n       newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "assume g: \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp n = (a, b, c) \""], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c) \\<Longrightarrow>\n       trpl_code (step0 (a, b, c) tp) =\n       newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "hence \"conf (code tp) (bl2wc (<lm>)) n= trpl_code (a, b, c)\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c)\n\ngoal (1 subgoal):\n 1. conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)", "using ind h"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c)\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp n) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), n]\n  tm_wf0 tp\n\ngoal (1 subgoal):\n 1. conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)", "apply(simp add: conf_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c) \\<Longrightarrow>\n       trpl_code (step0 (a, b, c) tp) =\n       newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "moreover"], ["proof (state)\nthis:\n  conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c) \\<Longrightarrow>\n       trpl_code (step0 (a, b, c) tp) =\n       newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "hence \n        \"trpl_code (step0 (a, b, c) tp) = \n        rec_exec rec_newconf [code tp, trpl_code (a, b, c)]\""], ["proof (prove)\nusing this:\n  conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)\n\ngoal (1 subgoal):\n 1. trpl_code (step0 (a, b, c) tp) =\n    rec_exec rec_newconf [code tp, trpl_code (a, b, c)]", "apply(rule_tac rec_t_eq_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c) \\<Longrightarrow>\n    case (a, b, c) of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2", "using h g"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c)\n\ngoal (1 subgoal):\n 1. conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c) \\<Longrightarrow>\n    case (a, b, c) of (s, l, r) \\<Rightarrow> s \\<le> length tp div 2", "apply(simp add: state_in_range)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trpl_code (step0 (a, b, c) tp) =\n  rec_exec rec_newconf [code tp, trpl_code (a, b, c)]\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       steps0 (Suc 0, Bk \\<up> l, <lm>) tp n = (a, b, c) \\<Longrightarrow>\n       trpl_code (step0 (a, b, c) tp) =\n       newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "ultimately"], ["proof (chain)\npicking this:\n  conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)\n  trpl_code (step0 (a, b, c) tp) =\n  rec_exec rec_newconf [code tp, trpl_code (a, b, c)]", "show \n        \"trpl_code (step0 (a, b, c) tp) =\n            newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)\""], ["proof (prove)\nusing this:\n  conf (code tp) (bl2wc (<lm>)) n = trpl_code (a, b, c)\n  trpl_code (step0 (a, b, c) tp) =\n  rec_exec rec_newconf [code tp, trpl_code (a, b, c)]\n\ngoal (1 subgoal):\n 1. trpl_code (step0 (a, b, c) tp) =\n    newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)", "by(simp)"], ["proof (state)\nthis:\n  trpl_code (step0 (a, b, c) tp) =\n  newconf (code tp) (conf (code tp) (bl2wc (<lm>)) n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc n)) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc n)) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), Suc n]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl2wc_Bk_0[simp]: \"bl2wc (Bk\\<up> m) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc (Bk \\<up> m) = 0", "apply(induct m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bl2wc (Bk \\<up> 0) = 0\n 2. \\<And>m.\n       bl2wc (Bk \\<up> m) = 0 \\<Longrightarrow> bl2wc (Bk \\<up> Suc m) = 0", "apply(simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl2wc_Oc_then_Bk[simp]: \"bl2wc (Oc\\<up> rs@Bk\\<up> n) = bl2wc (Oc\\<up> rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc (Oc \\<up> rs @ Bk \\<up> n) = bl2wc (Oc \\<up> rs)", "apply(induct rs, simp, \n      simp add: bl2wc.simps bl2nat.simps bl2nat_double)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lg_power: \"x > Suc 0 \\<Longrightarrow> lg (x ^ rs) x = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < x \\<Longrightarrow> lg (x ^ rs) x = rs", "proof(simp add: lg.simps, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < x ^ rs; lgR [x ^ rs, x, xa]\\<rbrakk>\n       \\<Longrightarrow> Max {ya.\n                              ya \\<le> x ^ rs \\<and> lgR [x ^ rs, x, ya]} =\n                         rs\n 2. \\<lbrakk>Suc 0 < x; \\<not> Suc 0 < x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0\n 3. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "fix xa"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < x ^ rs; lgR [x ^ rs, x, xa]\\<rbrakk>\n       \\<Longrightarrow> Max {ya.\n                              ya \\<le> x ^ rs \\<and> lgR [x ^ rs, x, ya]} =\n                         rs\n 2. \\<lbrakk>Suc 0 < x; \\<not> Suc 0 < x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0\n 3. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "assume h: \"Suc 0 < x\""], ["proof (state)\nthis:\n  Suc 0 < x\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>Suc 0 < x; Suc 0 < x ^ rs; lgR [x ^ rs, x, xa]\\<rbrakk>\n       \\<Longrightarrow> Max {ya.\n                              ya \\<le> x ^ rs \\<and> lgR [x ^ rs, x, ya]} =\n                         rs\n 2. \\<lbrakk>Suc 0 < x; \\<not> Suc 0 < x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0\n 3. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "show \"Max {ya. ya \\<le> x ^ rs \\<and> lgR [x ^ rs, x, ya]} = rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {ya. ya \\<le> x ^ rs \\<and> lgR [x ^ rs, x, ya]} = rs", "apply(rule_tac Max_eqI, simp_all add: lgR.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<le> x ^ rs \\<and> x ^ y \\<le> x ^ rs \\<Longrightarrow> y \\<le> rs\n 2. rs \\<le> x ^ rs", "apply(simp add: h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rs \\<le> x ^ rs", "using x_less_exp[of x rs] h"], ["proof (prove)\nusing this:\n  Suc 0 < x \\<Longrightarrow> rs < x ^ rs\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. rs \\<le> x ^ rs", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Max {ya. ya \\<le> x ^ rs \\<and> lgR [x ^ rs, x, ya]} = rs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 < x; \\<not> Suc 0 < x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0\n 2. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 < x; \\<not> Suc 0 < x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0\n 2. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "assume \"\\<not> Suc 0 < x ^ rs\" \"Suc 0 < x\""], ["proof (state)\nthis:\n  \\<not> Suc 0 < x ^ rs\n  Suc 0 < x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 < x; \\<not> Suc 0 < x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0\n 2. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "thus \"rs = 0\""], ["proof (prove)\nusing this:\n  \\<not> Suc 0 < x ^ rs\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. rs = 0", "apply(cases \"x ^ rs\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "assume \"Suc 0 < x\" \"\\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\""], ["proof (state)\nthis:\n  Suc 0 < x\n  \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "thus \"rs = 0\""], ["proof (prove)\nusing this:\n  Suc 0 < x\n  \\<forall>xa. \\<not> lgR [x ^ rs, x, xa]\n\ngoal (1 subgoal):\n 1. rs = 0", "apply(simp only:lgR.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; \\<forall>xa. \\<not> x ^ xa \\<le> x ^ rs\\<rbrakk>\n    \\<Longrightarrow> rs = 0", "apply(erule_tac x = rs in allE, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rs = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following lemma relates execution of TMs with \n  the multi-step interpreter function \\<open>rec_nonstop\\<close>. Note,\n  \\<open>rec_nonstop\\<close> is constructed using \\<open>rec_conf\\<close>.\n\\<close>"], ["", "declare tm_wf.simps[simp del]"], ["", "lemma nonstop_t_eq: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n); \n   tm_wf (tp, 0); \n  rs > 0\\<rbrakk> \n  \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), stp] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), stp] = 0", "proof(simp add: nonstop_lemma nonstop.simps )"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> \\<not> NSTD (conf (code tp) (bl2wc (<lm>)) stp)", "assume h: \"steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n)\"\n    and tc_t: \"tm_wf (tp, 0)\" \"rs > 0\""], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> \\<not> NSTD (conf (code tp) (bl2wc (<lm>)) stp)", "have g: \"rec_exec rec_conf [code tp,  bl2wc (<lm>), stp] =\n                                        trpl_code (0, Bk\\<up> m, Oc\\<up> rs@Bk\\<up> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "using rec_t_eq_steps[of tp l lm stp] tc_t h"], ["proof (prove)\nusing this:\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp]\n  tm_wf0 tp\n  0 < rs\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "by(simp)"], ["proof (state)\nthis:\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> \\<not> NSTD (conf (code tp) (bl2wc (<lm>)) stp)", "thus \"\\<not> NSTD (conf (code tp) (bl2wc (<lm>)) stp)\""], ["proof (prove)\nusing this:\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. \\<not> NSTD (conf (code tp) (bl2wc (<lm>)) stp)", "proof(auto simp: NSTD.simps)"], ["proof (state)\ngoal (4 subgoals):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\n 2. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    stat (conf (code tp) (bl2wc (<lm>)) stp) = 0\n 3. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    left (conf (code tp) (bl2wc (<lm>)) stp) = 0\n 4. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "show \"stat (conf (code tp) (bl2wc (<lm>)) stp) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stat (conf (code tp) (bl2wc (<lm>)) stp) = 0", "using g"], ["proof (prove)\nusing this:\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. stat (conf (code tp) (bl2wc (<lm>)) stp) = 0", "by(auto simp: conf_lemma trpl_code.simps)"], ["proof (state)\nthis:\n  stat (conf (code tp) (bl2wc (<lm>)) stp) = 0\n\ngoal (3 subgoals):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\n 2. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    left (conf (code tp) (bl2wc (<lm>)) stp) = 0\n 3. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\n 2. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    left (conf (code tp) (bl2wc (<lm>)) stp) = 0\n 3. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "show \"left (conf (code tp) (bl2wc (<lm>)) stp) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left (conf (code tp) (bl2wc (<lm>)) stp) = 0", "using g"], ["proof (prove)\nusing this:\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. left (conf (code tp) (bl2wc (<lm>)) stp) = 0", "by(simp add: conf_lemma trpl_code.simps)"], ["proof (state)\nthis:\n  left (conf (code tp) (bl2wc (<lm>)) stp) = 0\n\ngoal (2 subgoals):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\n 2. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\n 2. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "show \"rght (conf (code tp) (bl2wc (<lm>)) stp) = \n           2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0", "using g h"], ["proof (prove)\nusing this:\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. rght (conf (code tp) (bl2wc (<lm>)) stp) =\n    2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0", "proof(simp add: conf_lemma trpl_code.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>conf (code tp) (bl2wc (<lm>)) stp =\n             trpl 0 0 (bl2wc (Oc \\<up> rs));\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\\<rbrakk>\n    \\<Longrightarrow> bl2wc (Oc \\<up> rs) =\n                      2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 - Suc 0", "have \"2 ^ lg (Suc (bl2wc (Oc\\<up> rs))) 2 = Suc (bl2wc (Oc\\<up> rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 = Suc (bl2wc (Oc \\<up> rs))", "apply(simp add: bl2wc.simps lg_power)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 = Suc (bl2wc (Oc \\<up> rs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>conf (code tp) (bl2wc (<lm>)) stp =\n             trpl 0 0 (bl2wc (Oc \\<up> rs));\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\\<rbrakk>\n    \\<Longrightarrow> bl2wc (Oc \\<up> rs) =\n                      2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 - Suc 0", "thus \"bl2wc (Oc\\<up> rs) = 2 ^ lg (Suc (bl2wc (Oc\\<up> rs))) 2 - Suc 0\""], ["proof (prove)\nusing this:\n  2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 = Suc (bl2wc (Oc \\<up> rs))\n\ngoal (1 subgoal):\n 1. bl2wc (Oc \\<up> rs) = 2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 - Suc 0", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bl2wc (Oc \\<up> rs) = 2 ^ lg (Suc (bl2wc (Oc \\<up> rs))) 2 - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rght (conf (code tp) (bl2wc (<lm>)) stp) =\n  2 ^ lg (Suc (rght (conf (code tp) (bl2wc (<lm>)) stp))) 2 - Suc 0\n\ngoal (1 subgoal):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n    0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "show \"0 < rght (conf (code tp) (bl2wc (<lm>)) stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "using g h tc_t"], ["proof (prove)\nusing this:\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. 0 < rght (conf (code tp) (bl2wc (<lm>)) stp)", "apply(simp add: conf_lemma trpl_code.simps bl2wc.simps\n          bl2nat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>conf (code tp) (bl2nat (<lm>) 0) stp =\n             trpl 0 0 (bl2nat (Oc \\<up> rs @ Bk \\<up> n) 0);\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> 0 < bl2nat (Oc \\<up> rs @ Bk \\<up> n) 0", "apply(cases rs, simp, simp add: bl2nat.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < rght (conf (code tp) (bl2wc (<lm>)) stp)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> NSTD (conf (code tp) (bl2wc (<lm>)) stp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma actn_0_is_4[simp]: \"actn m 0 r = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actn m 0 r = 4", "by(simp add: actn.simps)"], ["", "lemma newstat_0_0[simp]: \"newstat m 0 r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newstat m 0 r = 0", "by(simp add: newstat.simps)"], ["", "declare step_red[simp del]"], ["", "lemma halt_least_step: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = \n       (0, Bk\\<up> m, Oc\\<up>rs @ Bk\\<up>n); \n    tm_wf (tp, 0); \n    0<rs\\<rbrakk> \\<Longrightarrow>\n    \\<exists> stp. (nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n       (\\<forall> stp'. nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow> stp \\<le> stp'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp.\n                         nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                         (\\<forall>stp'.\n                             nonstop (code tp) (bl2wc (<lm>)) stp' =\n                             0 \\<longrightarrow>\n                             stp \\<le> stp')", "proof(induct stp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0 =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp.\n                         nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                         (\\<forall>stp'.\n                             nonstop (code tp) (bl2wc (<lm>)) stp' =\n                             0 \\<longrightarrow>\n                             stp \\<le> stp')\n 2. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "case 0"], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0 =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0 =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp.\n                         nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                         (\\<forall>stp'.\n                             nonstop (code tp) (bl2wc (<lm>)) stp' =\n                             0 \\<longrightarrow>\n                             stp \\<le> stp')\n 2. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "then"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0 =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs", "show ?case"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp 0 =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n       (\\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stp \\<le> stp')", "by (simp add: steps.simps(1))"], ["proof (state)\nthis:\n  \\<exists>stp.\n     nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n     (\\<forall>stp'.\n         nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n         stp \\<le> stp')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "case (Suc stp)"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n           (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n   tm_wf0 tp; 0 < rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp.\n                       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                       (\\<forall>stp'.\n                           nonstop (code tp) (bl2wc (<lm>)) stp' =\n                           0 \\<longrightarrow>\n                           stp \\<le> stp')\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "hence ind: \n    \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp = (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n) \\<Longrightarrow> \n    \\<exists>stp. nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and> \n          (\\<forall>stp'. nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow> stp \\<le> stp')\"\n    and h: \n    \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp (Suc stp) = (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n)\"\n    \"tm_wf (tp, 0::nat)\" \n    \"0 < rs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n           (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n   tm_wf0 tp; 0 < rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp.\n                       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                       (\\<forall>stp'.\n                           nonstop (code tp) (bl2wc (<lm>)) stp' =\n                           0 \\<longrightarrow>\n                           stp \\<le> stp')\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n     \\<exists>stp.\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n        (\\<forall>stp'.\n            nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n            stp \\<le> stp')) &&&\n    steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n    (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) &&&\n    tm_wf0 tp &&& 0 < rs", "by simp+"], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n  \\<exists>stp.\n     nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n     (\\<forall>stp'.\n         nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n         stp \\<le> stp')\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "{"], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) \\<Longrightarrow>\n  \\<exists>stp.\n     nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n     (\\<forall>stp'.\n         nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n         stp \\<le> stp')\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "fix a b c nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "assume \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp = (a, b, c)\"\n      \"a = Suc nat\""], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c)\n  a = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "hence \"\\<exists>stp. nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and> \n      (\\<forall>stp'. nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow> stp \\<le> stp')\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c)\n  a = Suc nat\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n       (\\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stp \\<le> stp')", "using h"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c)\n  a = Suc nat\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n       (\\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stp \\<le> stp')", "apply(rule_tac x = \"Suc stp\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n     a = Suc nat;\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> nonstop (code tp) (bl2wc (<lm>)) (Suc stp) = 0\n 2. \\<And>stp'.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        a = Suc nat;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs;\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> Suc stp \\<le> stp'", "apply(drule_tac  nonstop_t_eq, simp_all add: nonstop_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp'.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        a = Suc nat;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs;\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> Suc stp \\<le> stp'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp'.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        a = Suc nat;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs;\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> Suc stp \\<le> stp'", "fix stp'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp'.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        a = Suc nat;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs;\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> Suc stp \\<le> stp'", "assume g:\"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp = (Suc nat, b, c)\" \n        \"nonstop (code tp) (bl2wc (<lm>)) stp' = 0\""], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c)\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 0\n\ngoal (1 subgoal):\n 1. \\<And>stp'.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        a = Suc nat;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs;\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> Suc stp \\<le> stp'", "thus  \"Suc stp \\<le> stp'\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c)\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 0\n\ngoal (1 subgoal):\n 1. Suc stp \\<le> stp'", "proof(cases \"Suc stp \\<le> stp'\", simp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc stp \\<le> stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<not> Suc stp \\<le> stp'\""], ["proof (state)\nthis:\n  \\<not> Suc stp \\<le> stp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc stp \\<le> stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"stp' \\<le> stp\""], ["proof (prove)\nusing this:\n  \\<not> Suc stp \\<le> stp'\n\ngoal (1 subgoal):\n 1. stp' \\<le> stp", "by simp"], ["proof (state)\nthis:\n  stp' \\<le> stp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc stp \\<le> stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"\\<not> is_final (steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp')\""], ["proof (prove)\nusing this:\n  stp' \\<le> stp\n\ngoal (1 subgoal):\n 1. \\<not> is_final (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp')", "using g"], ["proof (prove)\nusing this:\n  stp' \\<le> stp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c)\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 0\n\ngoal (1 subgoal):\n 1. \\<not> is_final (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp')", "apply(cases \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp'\",auto, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, ba, ca);\n        stp' \\<le> stp;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> 0 < a", "apply(subgoal_tac \"\\<exists> n. stp = stp' + n\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ba ca n.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, ba, ca);\n        steps0 (a, ba, ca) tp n = (Suc nat, b, c);\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0; stp = stp' + n\\<rbrakk>\n       \\<Longrightarrow> 0 < a\n 2. \\<And>a ba ca.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, ba, ca);\n        stp' \\<le> stp;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. stp = stp' + n", "apply(cases \"fst (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp')\", simp_all add: steps.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ba ca.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, ba, ca);\n        stp' \\<le> stp;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n        nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. stp = stp' + n", "apply(rule_tac x = \"stp - stp'\"  in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc stp \\<le> stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"nonstop (code tp) (bl2wc (<lm>)) stp' = 1\""], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp')\n\ngoal (1 subgoal):\n 1. nonstop (code tp) (bl2wc (<lm>)) stp' = 1", "proof(cases \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp'\",\n            simp add: nonstop.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>0 < a;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>0 < a;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "assume k: \n            \"0 < a\" \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp' = (a, b, c)\""], ["proof (state)\nthis:\n  0 < a\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>0 < a;\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "thus \" NSTD (conf (code tp) (bl2wc (<lm>)) stp')\""], ["proof (prove)\nusing this:\n  0 < a\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\n\ngoal (1 subgoal):\n 1. NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "using rec_t_eq_steps[of tp l lm stp'] h"], ["proof (prove)\nusing this:\n  0 < a\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp') =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp']\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "proof(simp add: conf_lemma)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c);\n     trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "assume \"trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp'\""], ["proof (state)\nthis:\n  trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c);\n     trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "moreover"], ["proof (state)\nthis:\n  trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c);\n     trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "have \"NSTD (trpl_code (a, b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NSTD (trpl_code (a, b, c))", "using k"], ["proof (prove)\nusing this:\n  0 < a\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c)\n\ngoal (1 subgoal):\n 1. NSTD (trpl_code (a, b, c))", "apply(auto simp: trpl_code.simps NSTD.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  NSTD (trpl_code (a, b, c))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp' = (a, b, c);\n     trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "ultimately"], ["proof (chain)\npicking this:\n  trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp'\n  NSTD (trpl_code (a, b, c))", "show \"NSTD (conf (code tp) (bl2wc (<lm>)) stp')\""], ["proof (prove)\nusing this:\n  trpl_code (a, b, c) = conf (code tp) (bl2wc (<lm>)) stp'\n  NSTD (trpl_code (a, b, c))\n\ngoal (1 subgoal):\n 1. NSTD (conf (code tp) (bl2wc (<lm>)) stp')", "by simp"], ["proof (state)\nthis:\n  NSTD (conf (code tp) (bl2wc (<lm>)) stp')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NSTD (conf (code tp) (bl2wc (<lm>)) stp')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Suc stp \\<le> stp';\n     steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c);\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0\\<rbrakk>\n    \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 1\n\ngoal (1 subgoal):\n 1. False", "using g"], ["proof (prove)\nusing this:\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 1\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (Suc nat, b, c)\n  nonstop (code tp) (bl2wc (<lm>)) stp' = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc stp \\<le> stp'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp.\n     nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n     (\\<forall>stp'.\n         nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n         stp \\<le> stp')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (?a2, ?b2, ?c2);\n   ?a2 = Suc ?nat2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp.\n                       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                       (\\<forall>stp'.\n                           nonstop (code tp) (bl2wc (<lm>)) stp' =\n                           0 \\<longrightarrow>\n                           stp \\<le> stp')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "note [intro] = this"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (?a2, ?b2, ?c2);\n   ?a2 = Suc ?nat2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp.\n                       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                       (\\<forall>stp'.\n                           nonstop (code tp) (bl2wc (<lm>)) stp' =\n                           0 \\<longrightarrow>\n                           stp \\<le> stp')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n                 tm_wf0 tp; 0 < rs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>stp.\n                                     nonstop (code tp) (bl2wc (<lm>)) stp =\n                                     0 \\<and>\n                                     (\\<forall>stp'.\n   nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n   stp \\<le> stp');\n        steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n                            (\\<forall>stp'.\n                                nonstop (code tp) (bl2wc (<lm>)) stp' =\n                                0 \\<longrightarrow>\n                                stp \\<le> stp')", "from h"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs", "show \n      \"\\<exists>stp. nonstop (code tp) (bl2wc (<lm>)) stp = 0 \n    \\<and> (\\<forall>stp'. nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow> stp \\<le> stp')\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp (Suc stp) =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n       (\\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stp \\<le> stp')", "by(simp add: step_red, \n          cases \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp\", simp, \n          cases \"fst (steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp)\",\n          auto simp add: nonstop_t_eq intro:ind dest:nonstop_t_eq)"], ["proof (state)\nthis:\n  \\<exists>stp.\n     nonstop (code tp) (bl2wc (<lm>)) stp = 0 \\<and>\n     (\\<forall>stp'.\n         nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n         stp \\<le> stp')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conf_trpl_ex: \"\\<exists> p q r. conf m (bl2wc (<lm>)) stp = trpl p q r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p q r. conf m (bl2wc (<lm>)) stp = trpl p q r", "apply(induct stp, auto simp: conf.simps inpt.simps trpl.simps \n      newconf.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p q r.\n       Pi (Suc 0) * Pi 2 ^ bl2wc (<lm>) =\n       Pi 0 ^ p * Pi (Suc 0) ^ q * Pi 2 ^ r", "apply(rule_tac x = 0 in exI, rule_tac x = 1 in exI, \n      rule_tac x = \"bl2wc (<lm>)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi (Suc 0) * Pi 2 ^ bl2wc (<lm>) =\n    Pi 0 ^ 0 * Pi (Suc 0) ^ 1 * Pi 2 ^ bl2wc (<lm>)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nonstop_rgt_ex: \n  \"nonstop m (bl2wc (<lm>)) stpa = 0 \\<Longrightarrow> \\<exists> r. conf m (bl2wc (<lm>)) stpa = trpl 0 0 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonstop m (bl2wc (<lm>)) stpa = 0 \\<Longrightarrow>\n    \\<exists>r. conf m (bl2wc (<lm>)) stpa = trpl 0 0 r", "apply(auto simp: nonstop.simps NSTD.simps split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rght (conf m (bl2wc (<lm>)) stpa) =\n             2 ^ lg (Suc (rght (conf m (bl2wc (<lm>)) stpa))) 2 - Suc 0;\n     stat (conf m (bl2wc (<lm>)) stpa) = 0;\n     left (conf m (bl2wc (<lm>)) stpa) = 0;\n     0 < rght (conf m (bl2wc (<lm>)) stpa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. conf m (bl2wc (<lm>)) stpa = trpl 0 0 r", "using conf_trpl_ex[of m lm stpa]"], ["proof (prove)\nusing this:\n  \\<exists>p q r. conf m (bl2wc (<lm>)) stpa = trpl p q r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rght (conf m (bl2wc (<lm>)) stpa) =\n             2 ^ lg (Suc (rght (conf m (bl2wc (<lm>)) stpa))) 2 - Suc 0;\n     stat (conf m (bl2wc (<lm>)) stpa) = 0;\n     left (conf m (bl2wc (<lm>)) stpa) = 0;\n     0 < rght (conf m (bl2wc (<lm>)) stpa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r. conf m (bl2wc (<lm>)) stpa = trpl 0 0 r", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma max_divisors: \"x > Suc 0 \\<Longrightarrow> Max {u. x ^ u dvd x ^ r} = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < x \\<Longrightarrow> Max {u. x ^ u dvd x ^ r} = r", "proof(rule_tac Max_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc 0 < x \\<Longrightarrow> finite {u. x ^ u dvd x ^ r}\n 2. \\<And>y.\n       \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> r\n 3. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "assume \"x > Suc 0\""], ["proof (state)\nthis:\n  Suc 0 < x\n\ngoal (3 subgoals):\n 1. Suc 0 < x \\<Longrightarrow> finite {u. x ^ u dvd x ^ r}\n 2. \\<And>y.\n       \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> r\n 3. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "thus \"finite {u. x ^ u dvd x ^ r}\""], ["proof (prove)\nusing this:\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. finite {u. x ^ u dvd x ^ r}", "apply(rule_tac finite_power_dvd, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite {u. x ^ u dvd x ^ r}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> r\n 2. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> r\n 2. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> r\n 2. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "assume \"Suc 0 < x\" \"y \\<in> {u. x ^ u dvd x ^ r}\""], ["proof (state)\nthis:\n  Suc 0 < x\n  y \\<in> {u. x ^ u dvd x ^ r}\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> r\n 2. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "thus \"y \\<le> r\""], ["proof (prove)\nusing this:\n  Suc 0 < x\n  y \\<in> {u. x ^ u dvd x ^ r}\n\ngoal (1 subgoal):\n 1. y \\<le> r", "apply(cases \"y\\<le> r\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r};\n     \\<not> y \\<le> r\\<rbrakk>\n    \\<Longrightarrow> y \\<le> r", "apply(subgoal_tac \"\\<exists> d. y = r + d\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r}; \\<not> y \\<le> r;\n     \\<exists>d. y = r + d\\<rbrakk>\n    \\<Longrightarrow> y \\<le> r\n 2. \\<lbrakk>Suc 0 < x; y \\<in> {u. x ^ u dvd x ^ r};\n     \\<not> y \\<le> r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d. y = r + d", "apply(auto simp: power_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < x; x ^ y dvd x ^ r; \\<not> y \\<le> r\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d. y = r + d", "apply(rule_tac x = \"y - r\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y \\<le> r\n\ngoal (1 subgoal):\n 1. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < x \\<Longrightarrow> r \\<in> {u. x ^ u dvd x ^ r}", "show \"r \\<in> {u. x ^ u dvd x ^ r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> {u. x ^ u dvd x ^ r}", "by simp"], ["proof (state)\nthis:\n  r \\<in> {u. x ^ u dvd x ^ r}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lo_power:\n  assumes \"x > Suc 0\" shows \"lo (x ^ r) x = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "have \"\\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0", "using assms"], ["proof (prove)\nusing this:\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0", "by (metis Suc_lessD Suc_lessI nat_power_eq_Suc_0_iff zero_less_power)"], ["proof (state)\nthis:\n  \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0\n\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "moreover"], ["proof (state)\nthis:\n  \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0\n\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "have \"\\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0", "using dvd_refl assms"], ["proof (prove)\nusing this:\n  ?a dvd ?a\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. \\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0", "by(cases \"x^r\";blast)"], ["proof (state)\nthis:\n  \\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0\n\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0\n  \\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0\n  \\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0\n\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "using assms"], ["proof (prove)\nusing this:\n  \\<not> Suc 0 < x ^ r \\<Longrightarrow> r = 0\n  \\<forall>xa. \\<not> x ^ xa dvd x ^ r \\<Longrightarrow> r = 0\n  Suc 0 < x\n\ngoal (1 subgoal):\n 1. lo (x ^ r) x = r", "by(auto simp: lo.simps loR.simps mod_dvd_simp elim:max_divisors)"], ["proof (state)\nthis:\n  lo (x ^ r) x = r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lo_rgt: \"lo (trpl 0 0 r) (Pi 2) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lo (trpl 0 0 r) (Pi 2) = r", "apply(simp add: trpl.simps lo_power)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conf_keep: \n  \"conf m lm stp = trpl 0 0 r  \\<Longrightarrow>\n  conf m lm (stp + n) = trpl 0 0 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conf m lm stp = trpl 0 0 r \\<Longrightarrow>\n    conf m lm (stp + n) = trpl 0 0 r", "apply(induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. conf m lm stp = trpl 0 0 r \\<Longrightarrow>\n    conf m lm (stp + 0) = trpl 0 0 r\n 2. \\<And>n.\n       \\<lbrakk>conf m lm stp = trpl 0 0 r \\<Longrightarrow>\n                conf m lm (stp + n) = trpl 0 0 r;\n        conf m lm stp = trpl 0 0 r\\<rbrakk>\n       \\<Longrightarrow> conf m lm (stp + Suc n) = trpl 0 0 r", "apply(auto simp: conf.simps  newconf.simps newleft.simps \n      newrght.simps rght.simps lo_rgt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma halt_state_keep_steps_add:\n  \"\\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0\\<rbrakk> \\<Longrightarrow> \n  conf m (bl2wc (<lm>)) stpa = conf m (bl2wc (<lm>)) (stpa + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonstop m (bl2wc (<lm>)) stpa = 0 \\<Longrightarrow>\n    conf m (bl2wc (<lm>)) stpa = conf m (bl2wc (<lm>)) (stpa + n)", "apply(drule_tac nonstop_rgt_ex, auto simp: conf_keep)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma halt_state_keep: \n  \"\\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0; nonstop m (bl2wc (<lm>)) stpb = 0\\<rbrakk> \\<Longrightarrow>\n  conf m (bl2wc (<lm>)) stpa = conf m (bl2wc (<lm>)) stpb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb", "apply(cases \"stpa > stpb\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0; stpb < stpa\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb\n 2. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0; \\<not> stpb < stpa\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb", "using halt_state_keep_steps_add[of m lm stpb \"stpa - stpb\"]"], ["proof (prove)\nusing this:\n  nonstop m (bl2wc (<lm>)) stpb = 0 \\<Longrightarrow>\n  conf m (bl2wc (<lm>)) stpb = conf m (bl2wc (<lm>)) (stpb + (stpa - stpb))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0; stpb < stpa\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb\n 2. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0; \\<not> stpb < stpa\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0; \\<not> stpb < stpa\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb", "using halt_state_keep_steps_add[of m lm stpa \"stpb - stpa\"]"], ["proof (prove)\nusing this:\n  nonstop m (bl2wc (<lm>)) stpa = 0 \\<Longrightarrow>\n  conf m (bl2wc (<lm>)) stpa = conf m (bl2wc (<lm>)) (stpa + (stpb - stpa))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nonstop m (bl2wc (<lm>)) stpa = 0;\n     nonstop m (bl2wc (<lm>)) stpb = 0; \\<not> stpb < stpa\\<rbrakk>\n    \\<Longrightarrow> conf m (bl2wc (<lm>)) stpa =\n                      conf m (bl2wc (<lm>)) stpb", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  The correntess of \\<open>rec_F\\<close> which relates the interpreter function \\<open>rec_F\\<close> with the\n  execution of of TMs.\n\\<close>"], ["", "lemma terminate_halt: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up>m, Oc\\<up>rs@Bk\\<up>n); \n    tm_wf (tp,0); 0<rs\\<rbrakk> \\<Longrightarrow> terminate rec_halt [code tp, (bl2wc (<lm>))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> terminate rec_halt [code tp, bl2wc (<lm>)]", "by(frule_tac halt_least_step;force simp:nonstop_lemma intro:terminate_halt_lemma)"], ["", "lemma terminate_F: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up>m, Oc\\<up>rs@Bk\\<up>n); \n    tm_wf (tp,0); 0<rs\\<rbrakk> \\<Longrightarrow> terminate rec_F [code tp, (bl2wc (<lm>))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> terminate rec_F [code tp, bl2wc (<lm>)]", "apply(drule_tac terminate_halt, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp; 0 < rs;\n     terminate rec_halt [code tp, bl2wc (<lm>)]\\<rbrakk>\n    \\<Longrightarrow> terminate rec_F [code tp, bl2wc (<lm>)]", "apply(erule_tac terminate_F_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma F_correct: \n  \"\\<lbrakk>steps0 (Suc 0, Bk\\<up>l, <lm>) tp stp = (0, Bk\\<up>m, Oc\\<up>rs@Bk\\<up>n); \n    tm_wf (tp,0); 0<rs\\<rbrakk>\n   \\<Longrightarrow> rec_exec rec_F [code tp, (bl2wc (<lm>))] = (rs - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n             (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "apply(frule_tac halt_least_step, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp'\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "apply(frule_tac  nonstop_t_eq, auto simp: nonstop_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "using rec_t_eq_steps[of tp l lm stp]"], ["proof (prove)\nusing this:\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp]\n\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "apply(simp add: conf_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "fix stpa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "assume h: \n    \"nonstop (code tp) (bl2wc (<lm>)) stpa = 0\" \n    \"\\<forall>stp'. nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow> stpa \\<le> stp'\" \n    \"nonstop (code tp) (bl2wc (<lm>)) stp = 0\" \n    \"trpl_code (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n) = conf (code tp) (bl2wc (<lm>)) stp\"\n    \"steps0 (Suc 0, Bk\\<up> l, <lm>) tp stp = (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up> n)\""], ["proof (state)\nthis:\n  nonstop (code tp) (bl2wc (<lm>)) stpa = 0\n  \\<forall>stp'.\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n     stpa \\<le> stp'\n  nonstop (code tp) (bl2wc (<lm>)) stp = 0\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n  conf (code tp) (bl2wc (<lm>)) stp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "hence g1: \"conf (code tp) (bl2wc (<lm>)) stpa = trpl_code (0, Bk\\<up> m, Oc\\<up> rs @ Bk\\<up>n)\""], ["proof (prove)\nusing this:\n  nonstop (code tp) (bl2wc (<lm>)) stpa = 0\n  \\<forall>stp'.\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n     stpa \\<le> stp'\n  nonstop (code tp) (bl2wc (<lm>)) stp = 0\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n  conf (code tp) (bl2wc (<lm>)) stp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. conf (code tp) (bl2wc (<lm>)) stpa =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "using halt_state_keep[of \"code tp\" lm stpa stp]"], ["proof (prove)\nusing this:\n  nonstop (code tp) (bl2wc (<lm>)) stpa = 0\n  \\<forall>stp'.\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n     stpa \\<le> stp'\n  nonstop (code tp) (bl2wc (<lm>)) stp = 0\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n  conf (code tp) (bl2wc (<lm>)) stp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  \\<lbrakk>nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n   nonstop (code tp) (bl2wc (<lm>)) stp = 0\\<rbrakk>\n  \\<Longrightarrow> conf (code tp) (bl2wc (<lm>)) stpa =\n                    conf (code tp) (bl2wc (<lm>)) stp\n\ngoal (1 subgoal):\n 1. conf (code tp) (bl2wc (<lm>)) stpa =\n    trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "by(simp)"], ["proof (state)\nthis:\n  conf (code tp) (bl2wc (<lm>)) stpa =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "moreover"], ["proof (state)\nthis:\n  conf (code tp) (bl2wc (<lm>)) stpa =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "have g2:\n    \"rec_exec rec_halt [code tp, (bl2wc (<lm>))] = stpa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_halt [code tp, bl2wc (<lm>)] = stpa", "using h"], ["proof (prove)\nusing this:\n  nonstop (code tp) (bl2wc (<lm>)) stpa = 0\n  \\<forall>stp'.\n     nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n     stpa \\<le> stp'\n  nonstop (code tp) (bl2wc (<lm>)) stp = 0\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n  conf (code tp) (bl2wc (<lm>)) stp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. rec_exec rec_halt [code tp, bl2wc (<lm>)] = stpa", "by(auto simp: rec_exec.simps rec_halt_def nonstop_lemma intro!: Least_equality)"], ["proof (state)\nthis:\n  rec_exec rec_halt [code tp, bl2wc (<lm>)] = stpa\n\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n        tm_wf0 tp; 0 < rs; nonstop (code tp) (bl2wc (<lm>)) stpa = 0;\n        \\<forall>stp'.\n           nonstop (code tp) (bl2wc (<lm>)) stp' = 0 \\<longrightarrow>\n           stpa \\<le> stp';\n        nonstop (code tp) (bl2wc (<lm>)) stp = 0;\n        trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n) =\n        conf (code tp) (bl2wc (<lm>)) stp\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "show  \n    \"rec_exec rec_F [code tp, (bl2wc (<lm>))] = (rs - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "have \n      \"valu (rght (conf (code tp) (bl2wc (<lm>)) stpa)) = rs - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valu (rght (conf (code tp) (bl2wc (<lm>)) stpa)) = rs - Suc 0", "using g1"], ["proof (prove)\nusing this:\n  conf (code tp) (bl2wc (<lm>)) stpa =\n  trpl_code (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. valu (rght (conf (code tp) (bl2wc (<lm>)) stpa)) = rs - Suc 0", "apply(simp add: valu.simps trpl_code.simps \n          bl2wc.simps  bl2nat_append lg_power)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  valu (rght (conf (code tp) (bl2wc (<lm>)) stpa)) = rs - Suc 0\n\ngoal (1 subgoal):\n 1. rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  valu (rght (conf (code tp) (bl2wc (<lm>)) stpa)) = rs - Suc 0\n\ngoal (1 subgoal):\n 1. rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "by(simp add: rec_exec.simps F_lemma g2)"], ["proof (state)\nthis:\n  rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}