{"file_name": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine/Abacus_Mopup.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine", "problem_names": ["lemma mop_bef_length[simp]: \"length (mopup_a n) = 4 * n\"", "lemma mopup_a_nth: \n  \"\\<lbrakk>q < n; x < 4\\<rbrakk> \\<Longrightarrow> mopup_a n ! (4 * q + x) = \n                             mopup_a (Suc q) ! ((4 * q) + x)\"", "lemma fetch_bef_erase_a_o[simp]: \n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n  \\<Longrightarrow> (fetch (mopup_a n @ shift mopup_b (2 * n)) s Oc) = (W0, s + 1)\"", "lemma fetch_bef_erase_a_b[simp]:\n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n   \\<Longrightarrow>  (fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk) = (R, s + 2)\"", "lemma fetch_bef_erase_b_b: \n  assumes \"n < length lm\" \"0 < s\" \"s \\<le> 2 * n\" \"s mod 2 = 0\"\n  shows \"(fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk) = (R, s - 1)\"", "lemma fetch_jump_over1_o: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Oc\n  = (R, Suc (2 * n))\"", "lemma fetch_jump_over1_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Bk \n = (R, Suc (Suc (2 * n)))\"", "lemma fetch_aft_erase_a_o: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Oc \n = (W0, Suc (2 * n + 2))\"", "lemma fetch_aft_erase_a_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Bk\n  = (L, Suc (2 * n + 4))\"", "lemma fetch_aft_erase_b_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2*n + 3) Bk\n  = (R, Suc (2 * n + 3))\"", "lemma fetch_aft_erase_c_o: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Oc \n = (W0, Suc (2 * n + 2))\"", "lemma fetch_aft_erase_c_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Bk \n = (R, Suc (2 * n + 1))\"", "lemma fetch_left_moving_o: \n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Oc) \n = (L, 2*n + 6)\"", "lemma fetch_left_moving_b: \n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Bk)\n  = (L, 2*n + 5)\"", "lemma fetch_jump_over2_b:\n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Bk) \n = (R, 0)\"", "lemma fetch_jump_over2_o: \n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Oc) \n = (L, 2*n + 6)\"", "lemmas mopupfetchs = \n  fetch_bef_erase_a_o fetch_bef_erase_a_b fetch_bef_erase_b_b \n  fetch_jump_over1_o fetch_jump_over1_b fetch_aft_erase_a_o \n  fetch_aft_erase_a_b fetch_aft_erase_b_b fetch_aft_erase_c_o \n  fetch_aft_erase_c_b fetch_left_moving_o fetch_left_moving_b \n  fetch_jump_over2_b fetch_jump_over2_o", "lemma mopup_bef_erase_b_Bk_via_a_Oc[simp]: \n  \"\\<lbrakk>mopup_bef_erase_a (s, l, Oc # xs) lm n ires\\<rbrakk> \\<Longrightarrow> \n  mopup_bef_erase_b (Suc s, l, Bk # xs) lm n ires\"", "lemma mopup_false1:\n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0;  \\<not> Suc s \\<le> 2 * n\\<rbrakk> \n  \\<Longrightarrow> RR\"", "lemma mopup_bef_erase_a_implies_two[simp]: \n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; \n   mopup_bef_erase_a (s, l, Oc # xs) lm n ires; r = Oc # xs\\<rbrakk>\n \\<Longrightarrow> (Suc s \\<le> 2 * n \\<longrightarrow> mopup_bef_erase_b (Suc s, l, Bk # xs) lm n ires)  \\<and>\n     (\\<not> Suc s \\<le> 2 * n \\<longrightarrow> mopup_jump_over1 (Suc s, l, Bk # xs) lm n ires) \"", "lemma tape_of_nl_cons: \"<m # lm> = (if lm = [] then Oc\\<up>(Suc m)\n                    else Oc\\<up>(Suc m) @ Bk # <lm>)\"", "lemma drop_tape_of_cons: \n  \"\\<lbrakk>Suc q < length lm; x = lm ! q\\<rbrakk> \\<Longrightarrow> <drop q lm> = Oc # Oc \\<up> x @ Bk # <drop (Suc q) lm>\"", "lemma erase2jumpover1:\n  \"\\<lbrakk>q < length list; \n             \\<forall>rn. <drop q list> \\<noteq> Oc # Oc \\<up> (list ! q) @ Bk # <drop (Suc q) list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> (list ! q)\"", "lemma erase2jumpover2:\n  \"\\<lbrakk>q < length list; \\<forall>rn. <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n  Oc # Oc \\<up> (list ! q) @ Bk # <drop (Suc q) list> @ Bk \\<up> rn\\<rbrakk>\n  \\<Longrightarrow> RR\"", "lemma mod_ex1: \"(a mod 2 = Suc 0) = (\\<exists> q. a = Suc (2 * q))\"", "lemma mopup_bef_erase_a_2_jump_over[simp]:\n  \"\\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0;  s \\<le> 2 * n;\n   mopup_bef_erase_a (s, l, Bk # xs) lm n ires; \\<not> (Suc (Suc s) \\<le> 2 * n)\\<rbrakk> \n\\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\"", "lemma Suc_Suc_div:  \"\\<lbrakk>0 < s; s mod 2 = Suc 0; Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n           \\<Longrightarrow> (Suc (Suc (s div 2))) \\<le> n\"", "lemma mopup_bef_erase_a_2_a[simp]: \n  assumes \"n < length lm\" \"0 < s\" \"s mod 2 = Suc 0\" \n    \"mopup_bef_erase_a (s, l, Bk # xs) lm n ires\"\n    \"Suc (Suc s) \\<le> 2 * n\"\n  shows \"mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires\"", "lemma mopup_false2: \n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; \n   s mod 2 = Suc 0; Suc s \\<noteq> 2 * n;\n   \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk> \\<Longrightarrow> RR\"", "lemma ariths[simp]: \"\\<lbrakk>0 < s; s \\<le> 2 *n; s mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> \n                                      (s - Suc 0) mod 2 = Suc 0\"\n  \"\\<lbrakk>0 < s; s \\<le> 2 *n; s mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow>\n                                       s - Suc 0 \\<le> 2 * n\"\n  \"\\<lbrakk>0 < s; s \\<le> 2 *n; s mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> \\<not> s \\<le> Suc 0\"", "lemma take_suc[intro]:\n  \"\\<exists>lna. Bk # Bk \\<up> ln = Bk \\<up> lna\"", "lemma mopup_bef_erase[simp]: \"mopup_bef_erase_a (s, l, []) lm n ires \\<Longrightarrow> \n                        mopup_bef_erase_a (s, l, [Bk]) lm n ires\"\n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; \\<not> Suc (Suc s) \\<le> 2 *n;\n     mopup_bef_erase_a (s, l, []) lm n ires\\<rbrakk>\n    \\<Longrightarrow>  mopup_jump_over1 (s', Bk # l, []) lm n ires\"\n  \"mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"\n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; \n               s mod 2 \\<noteq> Suc 0; \n               mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\<rbrakk> \n           \\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n ires\"\n  \"\\<lbrakk>mopup_bef_erase_b (s, l, []) lm n ires\\<rbrakk> \\<Longrightarrow> \n                   mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires\"", "lemma mopup_jump_over1_in_ctx[simp]:\n  assumes \"mopup_jump_over1 (Suc (2 * n), l, Oc # xs) lm n ires\"\n  shows \"mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires\"", "lemma mopup_jump_over1_2_aft_erase_a[simp]:  \n  assumes \"mopup_jump_over1 (Suc (2 * n), l, Bk # xs) lm n ires\"\n  shows \"mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires\"", "lemma mopup_aft_erase_a_via_jump_over1[simp]: \n  \"\\<lbrakk>mopup_jump_over1 (Suc (2 * n), l, []) lm n ires\\<rbrakk> \\<Longrightarrow> \n    mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, []) lm n ires\"", "lemma tape_of_list_empty[simp]: \"<[]> = []\"", "lemma mopup_aft_erase_b_via_a[simp]: \n  assumes \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, Oc # xs) lm n ires\"\n  shows \"mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires\"", "lemma mopup_left_moving_via_aft_erase_a[simp]:\n  assumes \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, Bk # xs) lm n ires\"\n  shows \"mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires\"", "lemma mopup_aft_erase_a_nonempty[simp]:\n  \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"", "lemma mopup_left_moving_via_aft_erase_a_emptylst[simp]:\n  assumes \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, []) lm n ires\"\n  shows \"mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires\"", "lemma mopup_aft_erase_b_no_Oc[simp]: \"mopup_aft_erase_b (2 * n + 3, l, Oc # xs) lm n ires = False\"", "lemma tape_of_ex1[intro]: \n  \"\\<exists>rna ml. Oc \\<up> a @ Bk \\<up> rn = <ml::nat list> @ Bk \\<up> rna \\<or> Oc \\<up> a @ Bk \\<up> rn = Bk # <ml> @ Bk \\<up> rna\"", "lemma mopup_aft_erase_b_via_c_helper: \"\\<exists>rna ml. Oc \\<up> a @ Bk # <list::nat list> @ Bk \\<up> rn = \n  <ml> @ Bk \\<up> rna \\<or> Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = Bk # <ml::nat list> @ Bk \\<up> rna\"", "lemma mopup_aft_erase_b_via_c[simp]: \n  assumes \"mopup_aft_erase_c (2 * n + 4, l, Oc # xs) lm n ires\"\n  shows \"mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires\"", "lemma mopup_aft_erase_c_aft_erase_a[simp]: \n  assumes \"mopup_aft_erase_c (2 * n + 4, l, Bk # xs) lm n ires\"\n  shows \"mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires\"", "lemma mopup_aft_erase_a_via_c[simp]: \n  \"\\<lbrakk>mopup_aft_erase_c (2 * n + 4, l, []) lm n ires\\<rbrakk> \n \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, []) lm n ires\"", "lemma mopup_aft_erase_b_2_aft_erase_c[simp]:\n  assumes \"mopup_aft_erase_b (2 * n + 3, l, Bk # xs) lm n ires\"\n  shows \"mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires\"", "lemma mopup_aft_erase_c_via_b[simp]: \n  \"\\<lbrakk>mopup_aft_erase_b (2 * n + 3, l, []) lm n ires\\<rbrakk> \n \\<Longrightarrow> mopup_aft_erase_c (4 + 2 * n, Bk # l, []) lm n ires\"", "lemma mopup_left_moving_nonempty[simp]: \n  \"mopup_left_moving (2 * n + 5, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"", "lemma exp_ind: \"a\\<up>(Suc x) = a\\<up>x @ [a]\"", "lemma mopup_jump_over2_via_left_moving[simp]:  \n  \"\\<lbrakk>mopup_left_moving (2 * n + 5, l, Oc # xs) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_jump_over2 (2 * n + 6, tl l, hd l # Oc # xs) lm n ires\"", "lemma mopup_left_moving_nonempty_snd[simp]: \"mopup_left_moving (2 * n + 5, l, xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"", "lemma mopup_left_moving_hd_Bk[simp]:\n  \"\\<lbrakk>mopup_left_moving (2 * n + 5, l, Bk # xs) lm n ires\\<rbrakk> \n \\<Longrightarrow> mopup_left_moving (2 * n + 5, tl l, hd l # Bk # xs) lm n ires\"", "lemma mopup_left_moving_emptylist[simp]: \n  \"\\<lbrakk>mopup_left_moving (2 * n + 5, l, []) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_left_moving (2 * n + 5, tl l, [hd l]) lm n ires\"", "lemma mopup_jump_over2_Oc_nonempty[simp]: \n  \"mopup_jump_over2 (2 * n + 6, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"", "lemma mopup_jump_over2_context[simp]: \n  \"\\<lbrakk>mopup_jump_over2 (2 * n + 6, l, Oc # xs) lm n ires\\<rbrakk>\n \\<Longrightarrow>  mopup_jump_over2 (2 * n + 6, tl l, hd l # Oc # xs) lm n ires\"", "lemma mopup_stop_via_jump_over2[simp]: \n  \"\\<lbrakk>mopup_jump_over2 (2 * n + 6, l, Bk # xs) lm n ires\\<rbrakk> \n  \\<Longrightarrow> mopup_stop (0, Bk # l, xs) lm n ires\"", "lemma mopup_jump_over2_nonempty[simp]: \"mopup_jump_over2 (2 * n + 6, l, []) lm n ires = False\"", "lemma mod_ex2: \"(a mod (2::nat) = 0) = (\\<exists> q. a = 2 * q)\"", "lemma mod_2: \"x mod 2  = 0 \\<or>  x mod 2 = Suc 0\"", "lemma mopup_inv_step:\n  \"\\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_inv (step (s, l, r) (mopup_a n @ shift mopup_b (2 * n), 0)) lm n ires\"", "lemma mopup_inv_steps: \n  \"\\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk> \\<Longrightarrow> \n     mopup_inv (steps (s, l, r) (mopup_a n @ shift mopup_b (2 * n), 0)  stp) lm n ires\"", "lemma wf_abc_mopup_measure:\n  shows \"wf abc_mopup_measure\"", "lemma abc_mopup_measure_induct [case_names Step]: \n  \"\\<lbrakk>\\<And>n. \\<not> P (f n) \\<Longrightarrow> (f (Suc n), (f n)) \\<in> abc_mopup_measure\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\"", "lemma mopup_erase_nonempty[simp]:\n  \"mopup_bef_erase_a (a, aa, []) lm n ires = False\"\n  \"mopup_bef_erase_b (a, aa, []) lm n ires = False\"\n  \"mopup_aft_erase_b (2 * n + 3, aa, []) lm n ires = False\"", "lemma fetch_mopup_a_shift[simp]: \n  assumes \"0 < q\" \"q \\<le> n\"\n  shows \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2*q) Bk = (R, 2*q - 1)\"", "lemma mopup_halt:\n  assumes \n    less: \"n < length lm\"\n    and inv: \"mopup_inv (Suc 0, l, r) lm n ires\"\n    and f: \"f = (\\<lambda> stp. (steps (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n), 0) stp, n))\"\n    and P: \"P = (\\<lambda> (c, n). is_final c)\"\n  shows \"\\<exists> stp. P (f stp)\"", "lemma mopup_inv_start: \n  \"n < length am \\<Longrightarrow> mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\"", "lemma mopup_correct:\n  assumes less: \"n < length (am::nat list)\"\n    and rs: \"am ! n = rs\"\n  shows \"\\<exists> stp i j. (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp)\n    = (0, Bk\\<up>i @ Bk # Bk # ires, Oc # Oc\\<up> rs @ Bk\\<up>j)\"", "lemma wf_mopup[intro]: \"tm_wf (mopup n, 0)\""], "translations": [["", "lemma mop_bef_length[simp]: \"length (mopup_a n) = 4 * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mopup_a n) = 4 * n", "by(induct n, simp_all)"], ["", "lemma mopup_a_nth: \n  \"\\<lbrakk>q < n; x < 4\\<rbrakk> \\<Longrightarrow> mopup_a n ! (4 * q + x) = \n                             mopup_a (Suc q) ! ((4 * q) + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < n; x < 4\\<rbrakk>\n    \\<Longrightarrow> mopup_a n ! (4 * q + x) =\n                      mopup_a (Suc q) ! (4 * q + x)", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>q < 0; x < 4\\<rbrakk>\n    \\<Longrightarrow> mopup_a 0 ! (4 * q + x) =\n                      mopup_a (Suc q) ! (4 * q + x)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>q < n; x < 4\\<rbrakk>\n                \\<Longrightarrow> mopup_a n ! (4 * q + x) =\n                                  mopup_a (Suc q) ! (4 * q + x);\n        q < Suc n; x < 4\\<rbrakk>\n       \\<Longrightarrow> mopup_a (Suc n) ! (4 * q + x) =\n                         mopup_a (Suc q) ! (4 * q + x)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>q < n; x < 4\\<rbrakk>\n  \\<Longrightarrow> mopup_a n ! (4 * q + x) = mopup_a (Suc q) ! (4 * q + x)\n  q < Suc n\n  x < 4\n\ngoal (2 subgoals):\n 1. \\<lbrakk>q < 0; x < 4\\<rbrakk>\n    \\<Longrightarrow> mopup_a 0 ! (4 * q + x) =\n                      mopup_a (Suc q) ! (4 * q + x)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>q < n; x < 4\\<rbrakk>\n                \\<Longrightarrow> mopup_a n ! (4 * q + x) =\n                                  mopup_a (Suc q) ! (4 * q + x);\n        q < Suc n; x < 4\\<rbrakk>\n       \\<Longrightarrow> mopup_a (Suc n) ! (4 * q + x) =\n                         mopup_a (Suc q) ! (4 * q + x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>q < n; x < 4\\<rbrakk>\n  \\<Longrightarrow> mopup_a n ! (4 * q + x) = mopup_a (Suc q) ! (4 * q + x)\n  q < Suc n\n  x < 4", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>q < n; x < 4\\<rbrakk>\n  \\<Longrightarrow> mopup_a n ! (4 * q + x) = mopup_a (Suc q) ! (4 * q + x)\n  q < Suc n\n  x < 4\n\ngoal (1 subgoal):\n 1. mopup_a (Suc n) ! (4 * q + x) = mopup_a (Suc q) ! (4 * q + x)", "by(cases \"q < n\";cases \"q = n\", auto simp add: nth_append)"], ["proof (state)\nthis:\n  mopup_a (Suc n) ! (4 * q + x) = mopup_a (Suc q) ! (4 * q + x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>q < 0; x < 4\\<rbrakk>\n    \\<Longrightarrow> mopup_a 0 ! (4 * q + x) =\n                      mopup_a (Suc q) ! (4 * q + x)", "qed auto"], ["", "lemma fetch_bef_erase_a_o[simp]: \n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n  \\<Longrightarrow> (fetch (mopup_a n @ shift mopup_b (2 * n)) s Oc) = (W0, s + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> fetch (mopup_a n @ shift mopup_b (2 * n)) s Oc =\n                      (W0, s + 1)", "apply(subgoal_tac \"\\<exists> q. s = 2*q + 1\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> (mopup_a n @ shift mopup_b (2 * n)) ! Suc (4 * q) =\n                         (W0, Suc (Suc (2 * q)))\n 2. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(subgoal_tac \"length (mopup_a n) = 4*n\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q);\n        length (mopup_a n) = 4 * n\\<rbrakk>\n       \\<Longrightarrow> (mopup_a n @ shift mopup_b (2 * n)) ! Suc (4 * q) =\n                         (W0, Suc (Suc (2 * q)))\n 2. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> length (mopup_a n) = 4 * n\n 3. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(auto simp: nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> mopup_a n ! Suc (4 * q) = (W0, Suc (Suc (2 * q)))\n 2. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(subgoal_tac \"mopup_a n ! (4 * q + 1) = \n                      mopup_a (Suc q) ! ((4 * q) + 1)\", \n      simp add: nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> mopup_a n ! (4 * q + 1) =\n                         mopup_a (Suc q) ! (4 * q + 1)\n 2. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(rule mopup_a_nth, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_bef_erase_a_b[simp]:\n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n   \\<Longrightarrow>  (fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk) = (R, s + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk =\n                      (R, s + 2)", "apply(subgoal_tac \"\\<exists> q. s = 2*q + 1\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> (mopup_a n @ shift mopup_b (2 * n)) ! (4 * q) =\n                         (R, Suc (Suc (Suc (2 * q))))\n 2. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(subgoal_tac \"length (mopup_a n) = 4*n\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q);\n        length (mopup_a n) = 4 * n\\<rbrakk>\n       \\<Longrightarrow> (mopup_a n @ shift mopup_b (2 * n)) ! (4 * q) =\n                         (R, Suc (Suc (Suc (2 * q))))\n 2. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> length (mopup_a n) = 4 * n\n 3. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(auto simp: nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> mopup_a n ! (4 * q) = (R, Suc (Suc (Suc (2 * q))))\n 2. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(subgoal_tac \"mopup_a n ! (4 * q + 0) = \n                       mopup_a (Suc q) ! ((4 * q + 0))\", \n      simp add: nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Suc (2 * q) \\<le> 2 * n; s = Suc (2 * q)\\<rbrakk>\n       \\<Longrightarrow> mopup_a n ! (4 * q + 0) =\n                         mopup_a (Suc q) ! (4 * q + 0)\n 2. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply(rule mopup_a_nth, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q. s = Suc (2 * q)", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_bef_erase_b_b: \n  assumes \"n < length lm\" \"0 < s\" \"s \\<le> 2 * n\" \"s mod 2 = 0\"\n  shows \"(fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk) = (R, s - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "from assms"], ["proof (chain)\npicking this:\n  n < length lm\n  0 < s\n  s \\<le> 2 * n\n  is_even s", "obtain q where q:\"s = 2 * q\""], ["proof (prove)\nusing this:\n  n < length lm\n  0 < s\n  s \\<le> 2 * n\n  is_even s\n\ngoal (1 subgoal):\n 1. (\\<And>q. s = 2 * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  s = 2 * q\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "then"], ["proof (chain)\npicking this:\n  s = 2 * q", "obtain nat where nat:\"q = Suc nat\""], ["proof (prove)\nusing this:\n  s = 2 * q\n\ngoal (1 subgoal):\n 1. (\\<And>nat. q = Suc nat \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  s = 2 * q\n  0 < s\n\ngoal (1 subgoal):\n 1. (\\<And>nat. q = Suc nat \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases q, auto)"], ["proof (state)\nthis:\n  q = Suc nat\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "from assms(3) mopup_a_nth[of nat n 2]"], ["proof (chain)\npicking this:\n  s \\<le> 2 * n\n  \\<lbrakk>nat < n; 2 < 4\\<rbrakk>\n  \\<Longrightarrow> mopup_a n ! (4 * nat + 2) =\n                    mopup_a (Suc nat) ! (4 * nat + 2)", "have \"mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! ((4 * nat) + 2)\""], ["proof (prove)\nusing this:\n  s \\<le> 2 * n\n  \\<lbrakk>nat < n; 2 < 4\\<rbrakk>\n  \\<Longrightarrow> mopup_a n ! (4 * nat + 2) =\n                    mopup_a (Suc nat) ! (4 * nat + 2)\n\ngoal (1 subgoal):\n 1. mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)", "unfolding nat q"], ["proof (prove)\nusing this:\n  2 * Suc nat \\<le> 2 * n\n  \\<lbrakk>nat < n; 2 < 4\\<rbrakk>\n  \\<Longrightarrow> mopup_a n ! (4 * nat + 2) =\n                    mopup_a (Suc nat) ! (4 * nat + 2)\n\ngoal (1 subgoal):\n 1. mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)", "by auto"], ["proof (state)\nthis:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "using assms nat q"], ["proof (prove)\nusing this:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)\n  n < length lm\n  0 < s\n  s \\<le> 2 * n\n  is_even s\n  q = Suc nat\n  s = 2 * q\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  fetch (mopup_a n @ shift mopup_b (2 * n)) s Bk = (R, s - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fetch_jump_over1_o: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Oc\n  = (R, Suc (2 * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Oc =\n    (R, Suc (2 * n))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Oc =\n    (R, Suc (2 * n))\n 2. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_jump_over1_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Bk \n = (R, Suc (Suc (2 * n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Bk =\n    (R, Suc (Suc (2 * n)))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (2 * n)) Bk =\n    (R, Suc (Suc (2 * n)))\n 2. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_aft_erase_a_o: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Oc \n = (W0, Suc (2 * n + 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Oc =\n    (W0, Suc (2 * n + 2))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Oc =\n    (W0, Suc (2 * n + 2))\n 2. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_aft_erase_a_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Bk\n  = (L, Suc (2 * n + 4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Bk =\n    (L, Suc (2 * n + 4))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (Suc (Suc (2 * n))) Bk =\n    (L, Suc (2 * n + 4))\n 2. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_aft_erase_b_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2*n + 3) Bk\n  = (R, Suc (2 * n + 3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 3) Bk =\n    (R, Suc (2 * n + 3))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 3) Bk =\n    (R, Suc (2 * n + 3))\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 3 = Suc (2*n + 2)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 3 = Suc (2 * n + 2)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 2)) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (R, Suc (Suc (2 * n + 2)))\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 3 = Suc (2 * n + 2)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_aft_erase_c_o: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Oc \n = (W0, Suc (2 * n + 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Oc =\n    (W0, Suc (2 * n + 2))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Oc =\n    (W0, Suc (2 * n + 2))\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 4 = Suc (2*n + 3)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 4 = Suc (2 * n + 3)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 3) + 1) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (W0, Suc (2 * n + 2))\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 4 = Suc (2 * n + 3)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_aft_erase_c_b: \n  \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Bk \n = (R, Suc (2 * n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Bk =\n    (R, Suc (2 * n + 1))", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 4) Bk =\n    (R, Suc (2 * n + 1))\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 4 = Suc (2*n + 3)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 4 = Suc (2 * n + 3)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 3)) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (R, Suc (2 * n + 1))\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 4 = Suc (2 * n + 3)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_left_moving_o: \n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Oc) \n = (L, 2*n + 6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Oc =\n    (L, 2 * n + 6)", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Oc =\n    (L, 2 * n + 6)\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 5 = Suc (2*n + 4)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 5 = Suc (2 * n + 4)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 4) + 1) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (L, 2 * n + 6)\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 5 = Suc (2 * n + 4)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_left_moving_b: \n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Bk)\n  = (L, 2*n + 5)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Bk =\n    (L, 2 * n + 5)", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 5) Bk =\n    (L, 2 * n + 5)\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 5 = Suc (2*n + 4)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 5 = Suc (2 * n + 4)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 4)) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (L, Suc (2 * n + 4))\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 5 = Suc (2 * n + 4)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_jump_over2_b:\n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Bk) \n = (R, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Bk = (R, 0)", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Bk = (R, 0)\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 6 = Suc (2*n + 5)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 6 = Suc (2 * n + 5)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 5)) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (R, 0)\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 6 = Suc (2 * n + 5)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fetch_jump_over2_o: \n  \"(fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Oc) \n = (L, 2*n + 6)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Oc =\n    (L, 2 * n + 6)", "apply(subgoal_tac \"length (mopup_a n) = 4 * n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (mopup_a n) = 4 * n \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * n + 6) Oc =\n    (L, 2 * n + 6)\n 2. length (mopup_a n) = 4 * n", "apply(subgoal_tac \"2*n + 6 = Suc (2*n + 5)\", simp only: fetch.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length (mopup_a n) = 4 * n;\n     2 * n + 6 = Suc (2 * n + 5)\\<rbrakk>\n    \\<Longrightarrow> (case nth_of (mopup_a n @ shift mopup_b (2 * n))\n                             (2 * (2 * n + 5) + 1) of\n                       None \\<Rightarrow> (Nop, 0)\n                       | Some i \\<Rightarrow> i) =\n                      (L, Suc (2 * n + 5))\n 2. length (mopup_a n) = 4 * n \\<Longrightarrow> 2 * n + 6 = Suc (2 * n + 5)\n 3. length (mopup_a n) = 4 * n", "apply(auto simp: mopup_b_def nth_append shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas mopupfetchs = \n  fetch_bef_erase_a_o fetch_bef_erase_a_b fetch_bef_erase_b_b \n  fetch_jump_over1_o fetch_jump_over1_b fetch_aft_erase_a_o \n  fetch_aft_erase_a_b fetch_aft_erase_b_b fetch_aft_erase_c_o \n  fetch_aft_erase_c_b fetch_left_moving_o fetch_left_moving_b \n  fetch_jump_over2_b fetch_jump_over2_o"], ["", "declare \n  mopup_jump_over2.simps[simp del] mopup_left_moving.simps[simp del]\n  mopup_aft_erase_c.simps[simp del] mopup_aft_erase_b.simps[simp del] \n  mopup_aft_erase_a.simps[simp del] mopup_jump_over1.simps[simp del]\n  mopup_bef_erase_a.simps[simp del] mopup_bef_erase_b.simps[simp del]\n  mopup_stop.simps[simp del]"], ["", "lemma mopup_bef_erase_b_Bk_via_a_Oc[simp]: \n  \"\\<lbrakk>mopup_bef_erase_a (s, l, Oc # xs) lm n ires\\<rbrakk> \\<Longrightarrow> \n  mopup_bef_erase_b (Suc s, l, Bk # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (s, l, Oc # xs) lm n ires \\<Longrightarrow>\n    mopup_bef_erase_b (Suc s, l, Bk # xs) lm n ires", "apply(auto simp: mopup_bef_erase_a.simps mopup_bef_erase_b.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln m rn.\n       \\<lbrakk>l = Bk \\<up> ln @ Bk # Bk # ires;\n        Oc # xs =\n        Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m rn.\n                            xs =\n                            Oc \\<up> m @\n                            Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn", "by (metis cell.distinct(1) hd_append list.sel(1) list.sel(3) tl_append2 tl_replicate)"], ["", "lemma mopup_false1:\n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0;  \\<not> Suc s \\<le> 2 * n\\<rbrakk> \n  \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0;\n     \\<not> Suc s \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(arith)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_bef_erase_a_implies_two[simp]: \n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; \n   mopup_bef_erase_a (s, l, Oc # xs) lm n ires; r = Oc # xs\\<rbrakk>\n \\<Longrightarrow> (Suc s \\<le> 2 * n \\<longrightarrow> mopup_bef_erase_b (Suc s, l, Bk # xs) lm n ires)  \\<and>\n     (\\<not> Suc s \\<le> 2 * n \\<longrightarrow> mopup_jump_over1 (Suc s, l, Bk # xs) lm n ires) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0;\n     mopup_bef_erase_a (s, l, Oc # xs) lm n ires; r = Oc # xs\\<rbrakk>\n    \\<Longrightarrow> (Suc s \\<le> 2 * n \\<longrightarrow>\n                       mopup_bef_erase_b (Suc s, l, Bk # xs) lm n\n                        ires) \\<and>\n                      (\\<not> Suc s \\<le> 2 * n \\<longrightarrow>\n                       mopup_jump_over1 (Suc s, l, Bk # xs) lm n ires)", "apply(auto elim!: mopup_false1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tape_of_nl_cons: \"<m # lm> = (if lm = [] then Oc\\<up>(Suc m)\n                    else Oc\\<up>(Suc m) @ Bk # <lm>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <m # lm> =\n    (if lm = [] then Oc \\<up> Suc m else Oc \\<up> Suc m @ Bk # <lm>)", "by(cases lm, simp_all add: tape_of_list_def  tape_of_nat_def split: if_splits)"], ["", "lemma drop_tape_of_cons: \n  \"\\<lbrakk>Suc q < length lm; x = lm ! q\\<rbrakk> \\<Longrightarrow> <drop q lm> = Oc # Oc \\<up> x @ Bk # <drop (Suc q) lm>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc q < length lm; x = lm ! q\\<rbrakk>\n    \\<Longrightarrow> <drop q lm> = Oc # Oc \\<up> x @ Bk # <drop (Suc q) lm>", "using Suc_lessD append_Cons list.simps(2) Cons_nth_drop_Suc replicate_Suc tape_of_nl_cons"], ["proof (prove)\nusing this:\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n  (?x # ?xs) @ ?ys = ?x # ?xs @ ?ys\n  [] \\<noteq> ?x21.0 # ?x22.0\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs ! ?i # drop (Suc ?i) ?xs = drop ?i ?xs\n  ?x \\<up> Suc ?n = ?x # ?x \\<up> ?n\n  <?m # ?lm> =\n  (if ?lm = [] then Oc \\<up> Suc ?m else Oc \\<up> Suc ?m @ Bk # <?lm>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc q < length lm; x = lm ! q\\<rbrakk>\n    \\<Longrightarrow> <drop q lm> = Oc # Oc \\<up> x @ Bk # <drop (Suc q) lm>", "by metis"], ["", "lemma erase2jumpover1:\n  \"\\<lbrakk>q < length list; \n             \\<forall>rn. <drop q list> \\<noteq> Oc # Oc \\<up> (list ! q) @ Bk # <drop (Suc q) list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> (list ! q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> \\<noteq>\n        Oc #\n        Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q", "apply(erule_tac x = 0 in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < length list;\n     <drop q list> \\<noteq>\n     Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list>\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q", "apply(cases \"Suc q < length list\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q < length list;\n     <drop q list> \\<noteq>\n     Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list>;\n     Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q\n 2. \\<lbrakk>q < length list;\n     <drop q list> \\<noteq>\n     Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list>;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q", "apply(erule_tac notE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q < length list; Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> <drop q list> =\n                      Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list>\n 2. \\<lbrakk>q < length list;\n     <drop q list> \\<noteq>\n     Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list>;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q", "apply(rule_tac drop_tape_of_cons, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < length list;\n     <drop q list> \\<noteq> Oc # Oc \\<up> list ! q @ Bk # <[]>;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q", "apply(subgoal_tac \"length list = Suc q\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk><drop q list> \\<noteq> Oc # Oc \\<up> list ! q @ Bk # <[]>;\n     length list = Suc q\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q", "apply(subgoal_tac \"drop q list = [list ! q]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk><drop q list> \\<noteq> Oc # Oc \\<up> list ! q @ Bk # <[]>;\n     length list = Suc q; drop q list = [list ! q]\\<rbrakk>\n    \\<Longrightarrow> <drop q list> = Oc # Oc \\<up> list ! q\n 2. \\<lbrakk><drop q list> \\<noteq> Oc # Oc \\<up> list ! q @ Bk # <[]>;\n     length list = Suc q\\<rbrakk>\n    \\<Longrightarrow> drop q list = [list ! q]", "apply(simp add: tape_of_nat_def tape_of_list_def replicate_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk><drop q list> \\<noteq> Oc # Oc \\<up> list ! q @ Bk # <[]>;\n     length list = Suc q\\<rbrakk>\n    \\<Longrightarrow> drop q list = [list ! q]", "by (metis append_Nil2 append_eq_conv_conj Cons_nth_drop_Suc lessI)"], ["", "lemma erase2jumpover2:\n  \"\\<lbrakk>q < length list; \\<forall>rn. <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n  Oc # Oc \\<up> (list ! q) @ Bk # <drop (Suc q) list> @ Bk \\<up> rn\\<rbrakk>\n  \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n        Oc #\n        Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(cases \"Suc q < length list\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n        Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> rn;\n     Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> RR\n 2. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n        Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> rn;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(erule_tac x = \"Suc n\" in allE, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc q < length list;\n     <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n     Oc #\n     Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> Suc n\\<rbrakk>\n    \\<Longrightarrow> RR\n 2. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n        Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> rn;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(erule_tac notE, simp add: replicate_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc q < length list \\<Longrightarrow>\n    <drop q list> = Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list>\n 2. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n        Oc # Oc \\<up> list ! q @ Bk # <drop (Suc q) list> @ Bk \\<up> rn;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(rule_tac drop_tape_of_cons, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q < length list;\n     \\<forall>rn.\n        <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n        Oc # Oc \\<up> list ! q @ Bk # <[]> @ Bk \\<up> rn;\n     \\<not> Suc q < length list\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(subgoal_tac \"length list = Suc q\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>rn.\n                <drop q list> @ Bk # Bk \\<up> n \\<noteq>\n                Oc # Oc \\<up> list ! q @ Bk # <[]> @ Bk \\<up> rn;\n     length list = Suc q\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(erule_tac x = \"n\" in allE, simp add: tape_of_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length list = Suc q;\n     tape_of_nat_list (drop q list) \\<noteq> Oc # Oc \\<up> list ! q\\<rbrakk>\n    \\<Longrightarrow> RR", "by (metis append_Nil2 append_eq_conv_conj Cons_nth_drop_Suc lessI replicate_Suc tape_of_list_def tape_of_nl_cons)"], ["", "lemma mod_ex1: \"(a mod 2 = Suc 0) = (\\<exists> q. a = Suc (2 * q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a mod 2 = Suc 0) = (\\<exists>q. a = Suc (2 * q))", "by arith"], ["", "declare replicate_Suc[simp]"], ["", "lemma mopup_bef_erase_a_2_jump_over[simp]:\n  \"\\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0;  s \\<le> 2 * n;\n   mopup_bef_erase_a (s, l, Bk # xs) lm n ires; \\<not> (Suc (Suc s) \\<le> 2 * n)\\<rbrakk> \n\\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "case (Suc nat)"], ["proof (state)\nthis:\n  n = Suc nat\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "assume assms: \"n < length lm\" \"0 < s\" \"s mod 2 = Suc 0\" \"s \\<le> 2 * n\"\n    \"mopup_bef_erase_a (s, l, Bk # xs) lm n ires\" \"\\<not> (Suc (Suc s) \\<le> 2 * n)\""], ["proof (state)\nthis:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n", "obtain a lm' where Cons:\"lm = Cons a lm'\""], ["proof (prove)\nusing this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. (\\<And>a lm'. lm = a # lm' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases lm,auto)"], ["proof (state)\nthis:\n  lm = a # lm'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n", "have n:\"Suc s div 2 = n\""], ["proof (prove)\nusing this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. Suc s div 2 = n", "by auto"], ["proof (state)\nthis:\n  Suc s div 2 = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "have [simp]:\"s = Suc (2 * q) \\<longleftrightarrow> q = nat\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s = Suc (2 * q)) = (q = nat)", "using assms Suc"], ["proof (prove)\nusing this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n\n  n = Suc nat\n\ngoal (1 subgoal):\n 1. (s = Suc (2 * q)) = (q = nat)", "by presburger"], ["proof (state)\nthis:\n  (s = Suc (2 * ?q)) = (?q = nat)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n", "obtain ln m rn where ln:\"l = Bk \\<up> ln @ Bk # Bk # ires\"\n    and \"Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  s \\<le> 2 * n\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  \\<not> Suc (Suc s) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. (\\<And>ln m rn.\n        \\<lbrakk>l = Bk \\<up> ln @ Bk # Bk # ires;\n         Bk # xs =\n         Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mopup_bef_erase_a.simps mopup_jump_over1.simps)"], ["proof (state)\nthis:\n  l = Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "hence xs:\"xs = <drop n lm> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  l = Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. xs = <drop n lm> @ Bk \\<up> rn", "by(cases m;auto simp: n mod_ex1)"], ["proof (state)\nthis:\n  xs = <drop n lm> @ Bk \\<up> rn\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "have [intro]:\"nat < length lm' \\<Longrightarrow>\n    \\<forall>rna. xs \\<noteq> Oc # Oc \\<up> (lm' ! nat) @ Bk # <drop (Suc nat) lm'> @ Bk \\<up> rna \\<Longrightarrow>\n    <drop nat lm'> @ Bk \\<up> rn = Oc # Oc \\<up> (lm' ! nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat < length lm';\n     \\<forall>rna.\n        xs \\<noteq>\n        Oc #\n        Oc \\<up> lm' ! nat @\n        Bk # <drop (Suc nat) lm'> @ Bk \\<up> rna\\<rbrakk>\n    \\<Longrightarrow> <drop nat lm'> @ Bk \\<up> rn = Oc # Oc \\<up> lm' ! nat", "by(cases rn, auto elim: erase2jumpover1 erase2jumpover2 simp:xs Suc Cons)"], ["proof (state)\nthis:\n  \\<lbrakk>nat < length lm';\n   \\<forall>rna.\n      xs \\<noteq>\n      Oc #\n      Oc \\<up> lm' ! nat @ Bk # <drop (Suc nat) lm'> @ Bk \\<up> rna\\<rbrakk>\n  \\<Longrightarrow> <drop nat lm'> @ Bk \\<up> rn = Oc # Oc \\<up> lm' ! nat\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "have [intro]:\"<drop nat lm'> \\<noteq> Oc # Oc \\<up> (lm' ! nat) @ Bk # <drop (Suc nat) lm'> @ Bk \\<up> 0 \\<Longrightarrow> length lm' \\<le> Suc nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <drop nat lm'> \\<noteq>\n    Oc #\n    Oc \\<up> lm' ! nat @\n    Bk # <drop (Suc nat) lm'> @ Bk \\<up> 0 \\<Longrightarrow>\n    length lm' \\<le> Suc nat", "using drop_tape_of_cons[of nat lm']"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc nat < length lm'; ?x = lm' ! nat\\<rbrakk>\n  \\<Longrightarrow> <drop nat lm'> =\n                    Oc # Oc \\<up> ?x @ Bk # <drop (Suc nat) lm'>\n\ngoal (1 subgoal):\n 1. <drop nat lm'> \\<noteq>\n    Oc #\n    Oc \\<up> lm' ! nat @\n    Bk # <drop (Suc nat) lm'> @ Bk \\<up> 0 \\<Longrightarrow>\n    length lm' \\<le> Suc nat", "by fastforce"], ["proof (state)\nthis:\n  <drop nat lm'> \\<noteq>\n  Oc #\n  Oc \\<up> lm' ! nat @\n  Bk # <drop (Suc nat) lm'> @ Bk \\<up> 0 \\<Longrightarrow>\n  length lm' \\<le> Suc nat\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "from assms(1,3)"], ["proof (chain)\npicking this:\n  n < length lm\n  s mod 2 = Suc 0", "have [intro!]:\"\n            0 + Suc (lm' ! nat) = Suc (lm' ! nat) \\<and>\n            Bk # Bk \\<up> ln = Oc \\<up> 0 @ Bk \\<up> Suc ln \\<and>\n            ((\\<exists>rna. xs = Oc \\<up> Suc (lm' ! nat) @ Bk # <drop (Suc nat) lm'> @ Bk \\<up> rna) \\<or>\n             xs = Oc \\<up> Suc (lm' ! nat) \\<and> length lm' \\<le> Suc nat)\""], ["proof (prove)\nusing this:\n  n < length lm\n  s mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. 0 + Suc (lm' ! nat) = Suc (lm' ! nat) \\<and>\n    Bk # Bk \\<up> ln = Oc \\<up> 0 @ Bk \\<up> Suc ln \\<and>\n    ((\\<exists>rna.\n         xs =\n         Oc \\<up> Suc (lm' ! nat) @\n         Bk # <drop (Suc nat) lm'> @ Bk \\<up> rna) \\<or>\n     xs = Oc \\<up> Suc (lm' ! nat) \\<and> length lm' \\<le> Suc nat)", "by (auto simp:Cons ln xs Suc)"], ["proof (state)\nthis:\n  0 + Suc (lm' ! nat) = Suc (lm' ! nat) \\<and>\n  Bk # Bk \\<up> ln = Oc \\<up> 0 @ Bk \\<up> Suc ln \\<and>\n  ((\\<exists>rna.\n       xs =\n       Oc \\<up> Suc (lm' ! nat) @\n       Bk # <drop (Suc nat) lm'> @ Bk \\<up> rna) \\<or>\n   xs = Oc \\<up> Suc (lm' ! nat) \\<and> length lm' \\<le> Suc nat)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires\n 2. \\<And>nat.\n       \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n        mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n        \\<not> Suc (Suc s) \\<le> 2 * n; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "from assms(1,3)"], ["proof (chain)\npicking this:\n  n < length lm\n  s mod 2 = Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n < length lm\n  s mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. mopup_jump_over1 (s', Bk # l, xs) lm n ires", "unfolding Cons ln Suc"], ["proof (prove)\nusing this:\n  Suc nat < length (a # lm')\n  s mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. mopup_jump_over1 (s', Bk # Bk \\<up> ln @ Bk # Bk # ires, xs) (a # lm')\n     (Suc nat) ires", "by(auto simp: mopup_bef_erase_a.simps mopup_jump_over1.simps simp del:split_head_repeat)"], ["proof (state)\nthis:\n  mopup_jump_over1 (s', Bk # l, xs) lm n ires\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length lm; 0 < s; s mod 2 = Suc 0; s \\<le> 2 * n;\n     mopup_bef_erase_a (s, l, Bk # xs) lm n ires;\n     \\<not> Suc (Suc s) \\<le> 2 * n; n = 0\\<rbrakk>\n    \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, xs) lm n ires", "qed auto"], ["", "lemma Suc_Suc_div:  \"\\<lbrakk>0 < s; s mod 2 = Suc 0; Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n           \\<Longrightarrow> (Suc (Suc (s div 2))) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s mod 2 = Suc 0; Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> Suc (Suc (s div 2)) \\<le> n", "by(arith)"], ["", "lemma mopup_bef_erase_a_2_a[simp]: \n  assumes \"n < length lm\" \"0 < s\" \"s mod 2 = Suc 0\" \n    \"mopup_bef_erase_a (s, l, Bk # xs) lm n ires\"\n    \"Suc (Suc s) \\<le> 2 * n\"\n  shows \"mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  Suc (Suc s) \\<le> 2 * n", "obtain rn m ln where\n    rn:\"l = Bk \\<up> ln @ Bk # Bk # ires\" \"Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  Suc (Suc s) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. (\\<And>ln m rn.\n        \\<lbrakk>l = Bk \\<up> ln @ Bk # Bk # ires;\n         Bk # xs =\n         Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: mopup_bef_erase_a.simps)"], ["proof (state)\nthis:\n  l = Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "hence m:\"m = 0\""], ["proof (prove)\nusing this:\n  l = Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. m = 0", "using assms"], ["proof (prove)\nusing this:\n  l = Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\n  n < length lm\n  0 < s\n  s mod 2 = Suc 0\n  mopup_bef_erase_a (s, l, Bk # xs) lm n ires\n  Suc (Suc s) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. m = 0", "by (cases m,auto)"], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "hence d:\"drop (Suc (Suc (s div 2))) lm \\<noteq> []\""], ["proof (prove)\nusing this:\n  m = 0\n\ngoal (1 subgoal):\n 1. drop (Suc (Suc (s div 2))) lm \\<noteq> []", "using assms(1,3,5)"], ["proof (prove)\nusing this:\n  m = 0\n  n < length lm\n  s mod 2 = Suc 0\n  Suc (Suc s) \\<le> 2 * n\n\ngoal (1 subgoal):\n 1. drop (Suc (Suc (s div 2))) lm \\<noteq> []", "by auto arith"], ["proof (state)\nthis:\n  drop (Suc (Suc (s div 2))) lm \\<noteq> []\n\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "hence \"Bk # l = Bk \\<up> Suc ln @ Bk # Bk # ires \\<and>\n    xs = Oc \\<up> Suc (lm ! (Suc s div 2)) @ Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  drop (Suc (Suc (s div 2))) lm \\<noteq> []\n\ngoal (1 subgoal):\n 1. Bk # l = Bk \\<up> Suc ln @ Bk # Bk # ires \\<and>\n    xs =\n    Oc \\<up> Suc (lm ! (Suc s div 2)) @\n    Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn", "using rn"], ["proof (prove)\nusing this:\n  drop (Suc (Suc (s div 2))) lm \\<noteq> []\n  l = Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m @ Bk # <drop (Suc s div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. Bk # l = Bk \\<up> Suc ln @ Bk # Bk # ires \\<and>\n    xs =\n    Oc \\<up> Suc (lm ! (Suc s div 2)) @\n    Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn", "by(auto intro:drop_tape_of_cons simp:m)"], ["proof (state)\nthis:\n  Bk # l = Bk \\<up> Suc ln @ Bk # Bk # ires \\<and>\n  xs =\n  Oc \\<up> Suc (lm ! (Suc s div 2)) @\n  Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  Bk # l = Bk \\<up> Suc ln @ Bk # Bk # ires \\<and>\n  xs =\n  Oc \\<up> Suc (lm ! (Suc s div 2)) @\n  Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires", "unfolding mopup_bef_erase_a.simps"], ["proof (prove)\nusing this:\n  Bk # l = Bk \\<up> Suc ln @ Bk # Bk # ires \\<and>\n  xs =\n  Oc \\<up> Suc (lm ! (Suc s div 2)) @\n  Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>ln m rn.\n       Bk # l = Bk \\<up> ln @ Bk # Bk # ires \\<and>\n       xs =\n       Oc \\<up> m @ Bk # <drop ((Suc (Suc s) + 1) div 2) lm> @ Bk \\<up> rn", "by blast"], ["proof (state)\nthis:\n  mopup_bef_erase_a (Suc (Suc s), Bk # l, xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_false2: \n  \"\\<lbrakk>0 < s; s \\<le> 2 * n; \n   s mod 2 = Suc 0; Suc s \\<noteq> 2 * n;\n   \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk> \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; Suc s \\<noteq> 2 * n;\n     \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> RR", "by(arith)"], ["", "lemma ariths[simp]: \"\\<lbrakk>0 < s; s \\<le> 2 *n; s mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> \n                                      (s - Suc 0) mod 2 = Suc 0\"\n  \"\\<lbrakk>0 < s; s \\<le> 2 *n; s mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow>\n                                       s - Suc 0 \\<le> 2 * n\"\n  \"\\<lbrakk>0 < s; s \\<le> 2 *n; s mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> \\<not> s \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 \\<noteq> Suc 0\\<rbrakk>\n     \\<Longrightarrow> (s - Suc 0) mod 2 = Suc 0) &&&\n    (\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 \\<noteq> Suc 0\\<rbrakk>\n     \\<Longrightarrow> s - Suc 0 \\<le> 2 * n) &&&\n    (\\<lbrakk>0 < s; s \\<le> 2 * n; s mod 2 \\<noteq> Suc 0\\<rbrakk>\n     \\<Longrightarrow> \\<not> s \\<le> Suc 0)", "by(arith)+"], ["", "lemma take_suc[intro]:\n  \"\\<exists>lna. Bk # Bk \\<up> ln = Bk \\<up> lna\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lna. Bk # Bk \\<up> ln = Bk \\<up> lna", "by(rule_tac x = \"Suc ln\" in exI, simp)"], ["", "lemma mopup_bef_erase[simp]: \"mopup_bef_erase_a (s, l, []) lm n ires \\<Longrightarrow> \n                        mopup_bef_erase_a (s, l, [Bk]) lm n ires\"\n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; \\<not> Suc (Suc s) \\<le> 2 *n;\n     mopup_bef_erase_a (s, l, []) lm n ires\\<rbrakk>\n    \\<Longrightarrow>  mopup_jump_over1 (s', Bk # l, []) lm n ires\"\n  \"mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"\n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; \n               s mod 2 \\<noteq> Suc 0; \n               mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\<rbrakk> \n           \\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n ires\"\n  \"\\<lbrakk>mopup_bef_erase_b (s, l, []) lm n ires\\<rbrakk> \\<Longrightarrow> \n                   mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((mopup_bef_erase_a (s, l, []) lm n ires \\<Longrightarrow>\n      mopup_bef_erase_a (s, l, [Bk]) lm n ires) &&&\n     (\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0;\n       \\<not> Suc (Suc s) \\<le> 2 * n;\n       mopup_bef_erase_a (s, l, []) lm n ires\\<rbrakk>\n      \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, []) lm n ires)) &&&\n    (mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\<Longrightarrow>\n     l \\<noteq> []) &&&\n    (\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 \\<noteq> Suc 0;\n      mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\<rbrakk>\n     \\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n\n                        ires) &&&\n    (mopup_bef_erase_b (s, l, []) lm n ires \\<Longrightarrow>\n     mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires)", "by(auto simp: mopup_bef_erase_b.simps mopup_bef_erase_a.simps)"], ["", "lemma mopup_jump_over1_in_ctx[simp]:\n  assumes \"mopup_jump_over1 (Suc (2 * n), l, Oc # xs) lm n ires\"\n  shows \"mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_jump_over1 (Suc (2 * n), l, Oc # xs) lm n ires", "obtain ln m1 m2 rn where\n    \"m1 + m2 = Suc (lm ! n)\"\n    \"l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\"\n    \"(Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n         Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])\""], ["proof (prove)\nusing this:\n  mopup_jump_over1 (Suc (2 * n), l, Oc # xs) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2 ln rn.\n        \\<lbrakk>m1 + m2 = Suc (lm ! n);\n         l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n         Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n         Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_jump_over1.simps"], ["proof (prove)\nusing this:\n  \\<exists>ln m1 m2 rn.\n     m1 + m2 = Suc (lm ! n) \\<and>\n     l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n     (Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n      Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2 ln rn.\n        \\<lbrakk>m1 + m2 = Suc (lm ! n);\n         l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n         Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n         Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 + m2 = Suc (lm ! n)\n  l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\n  Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n  Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\n\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  m1 + m2 = Suc (lm ! n)\n  l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\n  Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n  Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\n\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires", "unfolding mopup_jump_over1.simps"], ["proof (prove)\nusing this:\n  m1 + m2 = Suc (lm ! n)\n  l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\n  Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n  Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\n\ngoal (1 subgoal):\n 1. \\<exists>ln m1 m2 rn.\n       m1 + m2 = Suc (lm ! n) \\<and>\n       Oc # l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n       (xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n        xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])", "apply(rule_tac x = ln in exI, rule_tac x = \"Suc m1\" in exI\n        ,rule_tac x = \"m2 - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m1 + m2 = Suc (lm ! n);\n     l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [];\n     m1 + m2 = Suc (lm ! n); l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [];\n     m1 + m2 = Suc (lm ! n); l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Oc # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Oc # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rn.\n                         Suc m1 + (m2 - 1) = Suc (lm ! n) \\<and>\n                         Oc # l =\n                         Oc \\<up> Suc m1 @\n                         Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                         (xs =\n                          Oc \\<up> (m2 - 1) @\n                          Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n                          xs = Oc \\<up> (m2 - 1) \\<and>\n                          drop (Suc n) lm = [])", "by(cases \"m2\", auto)"], ["proof (state)\nthis:\n  mopup_jump_over1 (Suc (2 * n), Oc # l, xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_jump_over1_2_aft_erase_a[simp]:  \n  assumes \"mopup_jump_over1 (Suc (2 * n), l, Bk # xs) lm n ires\"\n  shows \"mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_jump_over1 (Suc (2 * n), l, Bk # xs) lm n ires", "obtain ln m1 m2 rn where\n    \"m1 + m2 = Suc (lm ! n)\"\n    \"l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\"\n    \"(Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n        Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])\""], ["proof (prove)\nusing this:\n  mopup_jump_over1 (Suc (2 * n), l, Bk # xs) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2 ln rn.\n        \\<lbrakk>m1 + m2 = Suc (lm ! n);\n         l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n         Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n         Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_jump_over1.simps"], ["proof (prove)\nusing this:\n  \\<exists>ln m1 m2 rn.\n     m1 + m2 = Suc (lm ! n) \\<and>\n     l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n     (Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n      Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])\n\ngoal (1 subgoal):\n 1. (\\<And>m1 m2 ln rn.\n        \\<lbrakk>m1 + m2 = Suc (lm ! n);\n         l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n         Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n         Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 + m2 = Suc (lm ! n)\n  l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n  Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  m1 + m2 = Suc (lm ! n)\n  l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n  Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "unfolding mopup_aft_erase_a.simps"], ["proof (prove)\nusing this:\n  m1 + m2 = Suc (lm ! n)\n  l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires\n  Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n  Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\n\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn ml m.\n       m = Suc (lm ! n) \\<and>\n       Bk # l =\n       Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n       xs = <ml> @ Bk \\<up> rn", "apply( rule_tac x = ln in exI, rule_tac x = \"Suc 0\" in exI,rule_tac x = rn in exI\n        , rule_tac x = \"drop (Suc n) lm\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m1 + m2 = Suc (lm ! n);\n     l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [];\n     m1 + m2 = Suc (lm ! n); l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [];\n     m1 + m2 = Suc (lm ! n); l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = [];\n     m1 + m2 = Suc (lm ! n); l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n     Bk # xs = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n     Bk # xs = Oc \\<up> m2 \\<and> drop (Suc n) lm = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk # l =\n                         Bk \\<up> Suc 0 @\n                         Oc \\<up> m @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                         xs = <drop (Suc n) lm> @ Bk \\<up> rn", "by(cases m2, auto)"], ["proof (state)\nthis:\n  mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_aft_erase_a_via_jump_over1[simp]: \n  \"\\<lbrakk>mopup_jump_over1 (Suc (2 * n), l, []) lm n ires\\<rbrakk> \\<Longrightarrow> \n    mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, []) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), l, []) lm n ires \\<Longrightarrow>\n    mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, []) lm n ires", "proof(rule mopup_jump_over1_2_aft_erase_a)"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), l, []) lm n ires \\<Longrightarrow>\n    mopup_jump_over1 (Suc (2 * n), l, [Bk]) lm n ires", "assume a:\"mopup_jump_over1 (Suc (2 * n), l, []) lm n ires\""], ["proof (state)\nthis:\n  mopup_jump_over1 (Suc (2 * n), l, []) lm n ires\n\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), l, []) lm n ires \\<Longrightarrow>\n    mopup_jump_over1 (Suc (2 * n), l, [Bk]) lm n ires", "then"], ["proof (chain)\npicking this:\n  mopup_jump_over1 (Suc (2 * n), l, []) lm n ires", "obtain ln where ln:\"length lm \\<le> Suc n \\<Longrightarrow> l = Oc # Oc \\<up> (lm ! n) @ Bk \\<up> ln @ Bk # Bk # ires\""], ["proof (prove)\nusing this:\n  mopup_jump_over1 (Suc (2 * n), l, []) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>ln.\n        (length lm \\<le> Suc n \\<Longrightarrow>\n         l =\n         Oc #\n         Oc \\<up> lm ! n @ Bk \\<up> ln @ Bk # Bk # ires) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_jump_over1.simps"], ["proof (prove)\nusing this:\n  \\<exists>ln m1 m2 rn.\n     m1 + m2 = Suc (lm ! n) \\<and>\n     l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n     ([] = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n      [] = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])\n\ngoal (1 subgoal):\n 1. (\\<And>ln.\n        (length lm \\<le> Suc n \\<Longrightarrow>\n         l =\n         Oc #\n         Oc \\<up> lm ! n @ Bk \\<up> ln @ Bk # Bk # ires) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length lm \\<le> Suc n \\<Longrightarrow>\n  l = Oc # Oc \\<up> lm ! n @ Bk \\<up> ln @ Bk # Bk # ires\n\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), l, []) lm n ires \\<Longrightarrow>\n    mopup_jump_over1 (Suc (2 * n), l, [Bk]) lm n ires", "show \"mopup_jump_over1 (Suc (2 * n), l, [Bk]) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over1 (Suc (2 * n), l, [Bk]) lm n ires", "unfolding mopup_jump_over1.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln m1 m2 rn.\n       m1 + m2 = Suc (lm ! n) \\<and>\n       l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n       ([Bk] = Oc \\<up> m2 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n        [Bk] = Oc \\<up> m2 \\<and> drop (Suc n) lm = [])", "apply(rule_tac x = ln in exI, rule_tac x = \"Suc (lm ! n)\" in exI, \n        rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn.\n       Suc (lm ! n) + 0 = Suc (lm ! n) \\<and>\n       l = Oc \\<up> Suc (lm ! n) @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n       ([Bk] = Oc \\<up> 0 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n        [Bk] = Oc \\<up> 0 \\<and> drop (Suc n) lm = [])", "using a ln"], ["proof (prove)\nusing this:\n  mopup_jump_over1 (Suc (2 * n), l, []) lm n ires\n  length lm \\<le> Suc n \\<Longrightarrow>\n  l = Oc # Oc \\<up> lm ! n @ Bk \\<up> ln @ Bk # Bk # ires\n\ngoal (1 subgoal):\n 1. \\<exists>rn.\n       Suc (lm ! n) + 0 = Suc (lm ! n) \\<and>\n       l = Oc \\<up> Suc (lm ! n) @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n       ([Bk] = Oc \\<up> 0 @ Bk # <drop (Suc n) lm> @ Bk \\<up> rn \\<or>\n        [Bk] = Oc \\<up> 0 \\<and> drop (Suc n) lm = [])", "by(auto simp: mopup_jump_over1.simps tape_of_list_def )"], ["proof (state)\nthis:\n  mopup_jump_over1 (Suc (2 * n), l, [Bk]) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tape_of_list_empty[simp]: \"<[]> = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <[]> = []", "by(simp add: tape_of_list_def)"], ["", "lemma mopup_aft_erase_b_via_a[simp]: \n  assumes \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, Oc # xs) lm n ires\"\n  shows \"mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_aft_erase_a (Suc (Suc (2 * n)), l, Oc # xs) lm n ires", "obtain lnl lnr rn ml where\n    assms:\n    \"l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\"\n    \"Oc # xs = <ml::nat list> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  mopup_aft_erase_a (Suc (Suc (2 * n)), l, Oc # xs) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Oc # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_aft_erase_a.simps"], ["proof (prove)\nusing this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Oc # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "then"], ["proof (chain)\npicking this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn", "obtain a list where ml:\"ml = a # list\""], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. (\\<And>a list. ml = a # list \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ml,cases rn,auto)"], ["proof (state)\nthis:\n  ml = a # list\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "with assms"], ["proof (chain)\npicking this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n  ml = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n  ml = a # list\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "unfolding mopup_aft_erase_b.simps"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n  ml = a # list\n\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn ml m.\n       m = Suc (lm ! n) \\<and>\n       l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n       (Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n        Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn)", "apply(auto simp add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ml = [a];\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list = []; xs = Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and> Bk # <ml> @ Bk \\<up> rna = Bk \\<up> rn\n 2. \\<lbrakk>ml = a # list;\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and>\n                         <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(cases a, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ml = [0];\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list = []; xs = Bk \\<up> rn; a = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Bk \\<up> rn = <ml> @ Bk \\<up> rna \\<or>\n                         Bk # <ml> @ Bk \\<up> rna = Bk \\<up> rn\n 2. \\<And>nat.\n       \\<lbrakk>ml = [Suc nat];\n        l =\n        Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        list = []; xs = Oc # Oc \\<up> nat @ Bk \\<up> rn;\n        a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ml.\n                            Oc # Oc \\<up> nat @ Bk \\<up> rn =\n                            <ml> @ Bk \\<up> rna\n 3. \\<lbrakk>ml = a # list;\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and>\n                         <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(rule_tac x = rn in exI, rule_tac x = \"[]\" in exI, force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>ml = [Suc nat];\n        l =\n        Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        list = []; xs = Oc # Oc \\<up> nat @ Bk \\<up> rn;\n        a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ml.\n                            Oc # Oc \\<up> nat @ Bk \\<up> rn =\n                            <ml> @ Bk \\<up> rna\n 2. \\<lbrakk>ml = a # list;\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and>\n                         <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(rule_tac x = rn in exI, rule_tac x = \"[a-1]\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>ml = [Suc nat];\n        l =\n        Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        list = []; xs = Oc # Oc \\<up> nat @ Bk \\<up> rn;\n        a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Oc # Oc \\<up> nat @ Bk \\<up> rn =\n                         <[a - 1]> @ Bk \\<up> rn\n 2. \\<lbrakk>ml = a # list;\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and>\n                         <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(cases \"a\"; force simp add: tape_of_list_def tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ml = a # list;\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and>\n                         <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(cases \"a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ml = a # list;\n     l =\n     Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n     list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n     a = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         a = 0 \\<and>\n                         <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn\n 2. \\<And>nat.\n       \\<lbrakk>ml = a # list;\n        l =\n        Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ml.\n                            Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                            <ml> @ Bk \\<up> rna \\<or>\n                            a = 0 \\<and>\n                            <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(rule_tac x = rn in exI, rule_tac x = list in exI, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>ml = a # list;\n        l =\n        Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        list \\<noteq> []; xs = Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ml.\n                            Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                            <ml> @ Bk \\<up> rna \\<or>\n                            a = 0 \\<and>\n                            <ml> @ Bk \\<up> rna = <list> @ Bk \\<up> rn", "apply(rule_tac x = rn in exI,rule_tac x = \"(a-1) # list\" in exI, simp add: tape_of_nl_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_left_moving_via_aft_erase_a[simp]:\n  assumes \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, Bk # xs) lm n ires\"\n  shows \"mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires", "from assms[unfolded mopup_aft_erase_a.simps]"], ["proof (chain)\npicking this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     Bk # xs = <ml> @ Bk \\<up> rn", "obtain lnl lnr rn ml where\n    \"l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\"\n    \"Bk # xs = <ml::nat list> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     Bk # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Bk # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires", "unfolding mopup_left_moving.simps"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (tl l =\n        Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        hd l # Bk # xs = Bk \\<up> rn \\<or>\n        tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        hd l # Bk # xs = Oc # Bk \\<up> rn)", "by(cases lnr;cases ml,auto simp: tape_of_nl_cons)"], ["proof (state)\nthis:\n  mopup_left_moving (5 + 2 * n, tl l, hd l # Bk # xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_aft_erase_a_nonempty[simp]:\n  \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, xs) lm n ires \\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), l, xs) lm n ires \\<Longrightarrow>\n    l \\<noteq> []", "by(auto simp only: mopup_aft_erase_a.simps)"], ["", "lemma mopup_left_moving_via_aft_erase_a_emptylst[simp]:\n  assumes \"mopup_aft_erase_a (Suc (Suc (2 * n)), l, []) lm n ires\"\n  shows \"mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires", "have [intro!]:\"[Bk] = Bk \\<up> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [Bk] = Bk \\<up> 1", "by auto"], ["proof (state)\nthis:\n  [Bk] = Bk \\<up> 1\n\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_aft_erase_a (Suc (Suc (2 * n)), l, []) lm n ires", "obtain lnl lnr where \"l = Bk \\<up> lnr @ Oc # Oc \\<up> (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\""], ["proof (prove)\nusing this:\n  mopup_aft_erase_a (Suc (Suc (2 * n)), l, []) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl.\n        l =\n        Bk \\<up> lnr @\n        Oc #\n        Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_aft_erase_a.simps"], ["proof (prove)\nusing this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     [] = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl.\n        l =\n        Bk \\<up> lnr @\n        Oc #\n        Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires\n\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires\n\ngoal (1 subgoal):\n 1. mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires", "by(case_tac lnr, auto simp add:mopup_left_moving.simps)"], ["proof (state)\nthis:\n  mopup_left_moving (5 + 2 * n, tl l, [hd l]) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_aft_erase_b_no_Oc[simp]: \"mopup_aft_erase_b (2 * n + 3, l, Oc # xs) lm n ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (2 * n + 3, l, Oc # xs) lm n ires = False", "by(auto simp: mopup_aft_erase_b.simps)"], ["", "lemma tape_of_ex1[intro]: \n  \"\\<exists>rna ml. Oc \\<up> a @ Bk \\<up> rn = <ml::nat list> @ Bk \\<up> rna \\<or> Oc \\<up> a @ Bk \\<up> rn = Bk # <ml> @ Bk \\<up> rna\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rna ml.\n       Oc \\<up> a @ Bk \\<up> rn = <ml> @ Bk \\<up> rna \\<or>\n       Oc \\<up> a @ Bk \\<up> rn = Bk # <ml> @ Bk \\<up> rna", "by(rule_tac x = rn in exI, rule_tac x = \"if a = 0 then [] else [a-1]\" in exI,\n      simp add: tape_of_list_def tape_of_nat_def)"], ["", "lemma mopup_aft_erase_b_via_c_helper: \"\\<exists>rna ml. Oc \\<up> a @ Bk # <list::nat list> @ Bk \\<up> rn = \n  <ml> @ Bk \\<up> rna \\<or> Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = Bk # <ml::nat list> @ Bk \\<up> rna\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rna ml.\n       Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = <ml> @ Bk \\<up> rna \\<or>\n       Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = Bk # <ml> @ Bk \\<up> rna", "apply(cases \"list = []\", simp add: replicate_Suc[THEN sym] del: replicate_Suc split_head_repeat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list = [] \\<Longrightarrow>\n    \\<exists>rna ml.\n       Oc \\<up> a @ Bk \\<up> Suc rn = <ml> @ Bk \\<up> rna \\<or>\n       Oc \\<up> a @ Bk \\<up> Suc rn = Bk # <ml> @ Bk \\<up> rna\n 2. list \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rna ml.\n       Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = <ml> @ Bk \\<up> rna \\<or>\n       Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = Bk # <ml> @ Bk \\<up> rna", "apply(rule_tac rn = \"Suc rn\" in tape_of_ex1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list \\<noteq> [] \\<Longrightarrow>\n    \\<exists>rna ml.\n       Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = <ml> @ Bk \\<up> rna \\<or>\n       Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn = Bk # <ml> @ Bk \\<up> rna", "apply(cases a, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list \\<noteq> []; a = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna ml.\n                         Bk # <list> @ Bk \\<up> rn =\n                         <ml> @ Bk \\<up> rna \\<or>\n                         <list> @ Bk \\<up> rn = <ml> @ Bk \\<up> rna\n 2. \\<And>nat.\n       \\<lbrakk>list \\<noteq> []; a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ml.\n                            Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                            <ml> @ Bk \\<up> rna \\<or>\n                            Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                            Bk # <ml> @ Bk \\<up> rna", "apply(rule_tac x = rn in exI, rule_tac x = list in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>list \\<noteq> []; a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ml.\n                            Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                            <ml> @ Bk \\<up> rna \\<or>\n                            Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                            Bk # <ml> @ Bk \\<up> rna", "apply(rule_tac x = rn in exI, rule_tac x = \"(a-1) # list\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>list \\<noteq> []; a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         <(a - 1) # list> @ Bk \\<up> rn \\<or>\n                         Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn =\n                         Bk # <(a - 1) # list> @ Bk \\<up> rn", "apply(simp add: tape_of_nl_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_aft_erase_b_via_c[simp]: \n  assumes \"mopup_aft_erase_c (2 * n + 4, l, Oc # xs) lm n ires\"\n  shows \"mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_aft_erase_c (2 * n + 4, l, Oc # xs) lm n ires", "obtain lnl rn lnr ml where assms:\n    \"l = Bk \\<up> lnr @ Oc # Oc \\<up> (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\"\n    \"Oc # xs = <ml::nat list> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  mopup_aft_erase_c (2 * n + 4, l, Oc # xs) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Oc # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_aft_erase_c.simps"], ["proof (prove)\nusing this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     (Oc # xs = <ml> @ Bk \\<up> rn \\<or> Oc # xs = Bk # <ml> @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Oc # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "hence \"Oc # xs = Bk \\<up> rn \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. Oc # xs = Bk \\<up> rn \\<Longrightarrow> False", "by(cases rn,auto)"], ["proof (state)\nthis:\n  Oc # xs = Bk \\<up> rn \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  Oc # xs = Bk \\<up> rn \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "using assms"], ["proof (prove)\nusing this:\n  Oc # xs = Bk \\<up> rn \\<Longrightarrow> False\n  l = Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires", "unfolding mopup_aft_erase_b.simps"], ["proof (prove)\nusing this:\n  Oc # xs = Bk \\<up> rn \\<Longrightarrow> False\n  l = Bk \\<up> lnr @ Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires\n  Oc # xs = <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn ml m.\n       m = Suc (lm ! n) \\<and>\n       l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n       (Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n        Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn)", "by(cases ml)\n      (auto simp add: tape_of_nl_cons split: if_splits intro:mopup_aft_erase_b_via_c_helper\n        simp del:split_head_repeat)"], ["proof (state)\nthis:\n  mopup_aft_erase_b (Suc (Suc (Suc (2 * n))), l, Bk # xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_aft_erase_c_aft_erase_a[simp]: \n  assumes \"mopup_aft_erase_c (2 * n + 4, l, Bk # xs) lm n ires\"\n  shows \"mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_aft_erase_c (2 * n + 4, l, Bk # xs) lm n ires", "obtain lnl lnr rn ml where\n    \"l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\"\n    \"(Bk # xs = <ml::nat list> @ Bk \\<up> rn \\<or> Bk # xs = Bk # <ml> @ Bk \\<up> rn)\""], ["proof (prove)\nusing this:\n  mopup_aft_erase_c (2 * n + 4, l, Bk # xs) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Bk # xs = <ml> @ Bk \\<up> rn \\<or>\n         Bk # xs = Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mopup_aft_erase_c.simps"], ["proof (prove)\nusing this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     (Bk # xs = <ml> @ Bk \\<up> rn \\<or> Bk # xs = Bk # <ml> @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Bk # xs = <ml> @ Bk \\<up> rn \\<or>\n         Bk # xs = Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = <ml> @ Bk \\<up> rn \\<or> Bk # xs = Bk # <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = <ml> @ Bk \\<up> rn \\<or> Bk # xs = Bk # <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires", "unfolding mopup_aft_erase_a.simps"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = <ml> @ Bk \\<up> rn \\<or> Bk # xs = Bk # <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn ml m.\n       m = Suc (lm ! n) \\<and>\n       Bk # l =\n       Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n       xs = <ml> @ Bk \\<up> rn", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Bk # xs = <ml> @ Bk \\<up> rn \\<or>\n             Bk # xs = Bk # <ml> @ Bk \\<up> rn;\n     l =\n     Bk \\<up> lnr @\n     Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn\n 2. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply(subgoal_tac \"ml = []\", simp, case_tac rn, \n        simp, simp, rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>l =\n                Bk \\<up> lnr @\n                Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        xs = Bk \\<up> nat; ml = []; rn = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lnla lnra.\n                            Bk #\n                            Bk \\<up> lnr @\n                            Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl =\n                            Bk \\<up> lnra @\n                            Oc # Oc \\<up> lm ! n @ Bk \\<up> lnla\n 2. \\<And>nat.\n       \\<lbrakk>l =\n                Bk \\<up> lnr @\n                Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        xs = Bk \\<up> nat; ml = []; rn = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn ml. Bk \\<up> nat = <ml> @ Bk \\<up> rn\n 3. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> ml = []\n 4. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply(rule_tac x = lnl in exI, rule_tac x = \"Suc lnr\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>l =\n                Bk \\<up> lnr @\n                Oc # Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires;\n        xs = Bk \\<up> nat; ml = []; rn = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn ml. Bk \\<up> nat = <ml> @ Bk \\<up> rn\n 2. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = <ml> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> ml = []\n 3. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply (insert tape_of_list_empty,blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = <ml> @ Bk \\<up> rn; <[]> = []\\<rbrakk>\n    \\<Longrightarrow> ml = []\n 2. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = Bk # <ml> @ Bk \\<up> rn; <[]> = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply(case_tac ml, simp, simp add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = Bk # <ml> @ Bk \\<up> rn; <[]> = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lnla lnra rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> lnra @\n                         Oc \\<up> m @ Bk \\<up> lnla @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply(rule_tac x = lnl in exI, rule_tac x = \"Suc lnr\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l =\n             Bk \\<up> lnr @\n             Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n     Bk # xs = Bk # <ml> @ Bk \\<up> rn; <[]> = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rn ml m.\n                         m = Suc (lm ! n) \\<and>\n                         Bk #\n                         Bk \\<up> lnr @\n                         Oc \\<up> Suc (lm ! n) @\n                         Bk \\<up> lnl @ Bk # Bk # ires =\n                         Bk \\<up> Suc lnr @\n                         Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n                         xs = <ml> @ Bk \\<up> rn", "apply(rule_tac x = rn in exI, rule_tac x = \"ml\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_aft_erase_a_via_c[simp]: \n  \"\\<lbrakk>mopup_aft_erase_c (2 * n + 4, l, []) lm n ires\\<rbrakk> \n \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, []) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_c (2 * n + 4, l, []) lm n ires \\<Longrightarrow>\n    mopup_aft_erase_a (Suc (Suc (2 * n)), Bk # l, []) lm n ires", "by (rule mopup_aft_erase_c_aft_erase_a)\n    (auto simp:mopup_aft_erase_c.simps)"], ["", "lemma mopup_aft_erase_b_2_aft_erase_c[simp]:\n  assumes \"mopup_aft_erase_b (2 * n + 3, l, Bk # xs) lm n ires\"\n  shows \"mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires", "from assms"], ["proof (chain)\npicking this:\n  mopup_aft_erase_b (2 * n + 3, l, Bk # xs) lm n ires", "obtain lnl lnr ml rn where\n    \"l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\"\n    \"Bk # xs = Bk # <ml::nat list> @ Bk \\<up> rn \\<or> Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  mopup_aft_erase_b (2 * n + 3, l, Bk # xs) lm n ires\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n         Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding  mopup_aft_erase_b.simps"], ["proof (prove)\nusing this:\n  \\<exists>lnl lnr rn ml m.\n     m = Suc (lm ! n) \\<and>\n     l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n     (Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n      Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>lnr lnl ml rn.\n        \\<lbrakk>l =\n                 Bk \\<up> lnr @\n                 Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires;\n         Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n         Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n  Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n  Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires", "unfolding mopup_aft_erase_c.simps"], ["proof (prove)\nusing this:\n  l = Bk \\<up> lnr @ Oc \\<up> Suc (lm ! n) @ Bk \\<up> lnl @ Bk # Bk # ires\n  Bk # xs = Bk # <ml> @ Bk \\<up> rn \\<or>\n  Bk # xs = Bk # Bk # <ml> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn ml m.\n       m = Suc (lm ! n) \\<and>\n       Bk # l =\n       Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n       (xs = <ml> @ Bk \\<up> rn \\<or> xs = Bk # <ml> @ Bk \\<up> rn)", "by (rule_tac x = \"lnl\" in exI) auto"], ["proof (state)\nthis:\n  mopup_aft_erase_c (4 + 2 * n, Bk # l, xs) lm n ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_aft_erase_c_via_b[simp]: \n  \"\\<lbrakk>mopup_aft_erase_b (2 * n + 3, l, []) lm n ires\\<rbrakk> \n \\<Longrightarrow> mopup_aft_erase_c (4 + 2 * n, Bk # l, []) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_aft_erase_b (2 * n + 3, l, []) lm n ires \\<Longrightarrow>\n    mopup_aft_erase_c (4 + 2 * n, Bk # l, []) lm n ires", "by(auto simp add: mopup_aft_erase_b.simps intro:mopup_aft_erase_b_2_aft_erase_c)"], ["", "lemma mopup_left_moving_nonempty[simp]: \n  \"mopup_left_moving (2 * n + 5, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (2 * n + 5, l, Oc # xs) lm n ires \\<Longrightarrow>\n    l \\<noteq> []", "by(auto simp: mopup_left_moving.simps)"], ["", "lemma exp_ind: \"a\\<up>(Suc x) = a\\<up>x @ [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<up> Suc x = a \\<up> x @ [a]", "by(induct x, auto)"], ["", "lemma mopup_jump_over2_via_left_moving[simp]:  \n  \"\\<lbrakk>mopup_left_moving (2 * n + 5, l, Oc # xs) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_jump_over2 (2 * n + 6, tl l, hd l # Oc # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (2 * n + 5, l, Oc # xs) lm n ires \\<Longrightarrow>\n    mopup_jump_over2 (2 * n + 6, tl l, hd l # Oc # xs) lm n ires", "apply(simp only: mopup_left_moving.simps mopup_jump_over2.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>ln rn m1 m2.\n       m1 + m2 = Suc (lm ! n) \\<and>\n       hd l # Oc # xs \\<noteq> [] \\<and>\n       (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n        tl l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n        hd l # Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n       (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n        tl l = Bk \\<up> ln @ Bk # ires \\<and>\n        hd l # Oc # xs = Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>ln rn m1 m2.\n          m1 + m2 = Suc (lm ! n) \\<and>\n          hd l # Oc # xs \\<noteq> [] \\<and>\n          (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n           tl l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n           hd l # Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n          (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n           tl l = Bk \\<up> ln @ Bk # ires \\<and>\n           hd l # Oc # xs = Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(erule conjE, erule disjE, erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires;\n        Oc # xs = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)\n 2. \\<And>lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply (simp add: Cons_replicate_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(rename_tac Lnl lnr rn m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(cases \"hd l\", simp add:  )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lnl rn.\n       \\<lbrakk>l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                xs = Bk \\<up> rn;\n        hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Bk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Bk \\<up> ln @ Bk # ires \\<and>\n                            Oc # Bk \\<up> rn =\n                            Oc \\<up> (m1 + m2) @ Bk \\<up> rna\n 2. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn;\n        hd l = Oc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(cases \"lm ! n\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Lnl rn.\n       \\<lbrakk>l = Bk \\<up> Lnl @ Bk # Bk # ires \\<and> xs = Bk \\<up> rn;\n        hd (Bk \\<up> Lnl @ Bk # Bk # ires) = Bk; lm ! n = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna m1 m2.\n                            m1 + m2 = Suc 0 \\<and>\n                            tl (Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Bk \\<up> ln @ Bk # ires \\<and>\n                            Oc # Bk \\<up> rn =\n                            Oc \\<up> (m1 + m2) @ Bk \\<up> rna\n 2. \\<And>Lnl rn nat.\n       \\<lbrakk>l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                xs = Bk \\<up> rn;\n        hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Bk;\n        lm ! n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Bk \\<up> ln @ Bk # ires \\<and>\n                            Oc # Bk \\<up> rn =\n                            Oc \\<up> (m1 + m2) @ Bk \\<up> rna\n 3. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn;\n        hd l = Oc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(rule exI, rule_tac x = \"length xs\" in exI, \n      rule_tac x = \"Suc 0\" in exI, rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Lnl rn.\n       \\<lbrakk>l = Bk \\<up> Lnl @ Bk # Bk # ires \\<and> xs = Bk \\<up> rn;\n        hd (Bk \\<up> Lnl @ Bk # Bk # ires) = Bk; lm ! n = 0\\<rbrakk>\n       \\<Longrightarrow> Suc 0 + 0 = Suc 0 \\<and>\n                         tl (Bk \\<up> Lnl @ Bk # Bk # ires) =\n                         Bk \\<up> ?ln13 Lnl rn @ Bk # ires \\<and>\n                         Oc # Bk \\<up> rn =\n                         Oc \\<up> (Suc 0 + 0) @ Bk \\<up> length xs\n 2. \\<And>Lnl rn nat.\n       \\<lbrakk>l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                xs = Bk \\<up> rn;\n        hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Bk;\n        lm ! n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Bk \\<up> ln @ Bk # ires \\<and>\n                            Oc # Bk \\<up> rn =\n                            Oc \\<up> (m1 + m2) @ Bk \\<up> rna\n 3. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn;\n        hd l = Oc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(case_tac Lnl, simp,simp,  simp add: exp_ind[THEN sym])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lnl rn nat.\n       \\<lbrakk>l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                xs = Bk \\<up> rn;\n        hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Bk;\n        lm ! n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Bk \\<up> ln @ Bk # ires \\<and>\n                            Oc # Bk \\<up> rn =\n                            Oc \\<up> (m1 + m2) @ Bk \\<up> rna\n 2. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn;\n        hd l = Oc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(cases \"lm ! n\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lnl rn nat nata.\n       \\<lbrakk>l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                xs = Bk \\<up> rn;\n        hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Bk;\n        lm ! n = Suc nat; lm ! n = Suc nata\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Bk \\<up> ln @ Bk # ires \\<and>\n                            Oc # Bk \\<up> rn =\n                            Oc \\<up> (m1 + m2) @ Bk \\<up> rna\n 2. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn;\n        hd l = Oc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(case_tac Lnl, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lnl lnr rn m.\n       \\<lbrakk>m = Suc (lm ! n);\n        l = Oc \\<up> (m - 1) @ Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc # Bk \\<up> rn;\n        hd l = Oc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            hd l # Oc # xs \\<noteq> [] \\<and>\n                            (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n                             tl l =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n                             tl l = Bk \\<up> ln @ Bk # ires \\<and>\n                             hd l # Oc # xs =\n                             Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(rule_tac x = Lnl in exI, rule_tac x = \"length xs\" in exI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lnl rn.\n       \\<lbrakk>hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Oc;\n        l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires;\n        xs = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Oc \\<up> m1 @\n                            Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                            [Oc, Oc] = Oc \\<up> m2", "apply(cases \"lm ! n\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lnl rn.\n       \\<lbrakk>hd (Bk \\<up> Lnl @ Bk # Bk # ires) = Oc;\n        l = Bk \\<up> Lnl @ Bk # Bk # ires; xs = Bk \\<up> rn;\n        lm ! n = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m1 m2.\n                            m1 + m2 = Suc 0 \\<and>\n                            tl (Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Oc \\<up> m1 @\n                            Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                            [Oc, Oc] = Oc \\<up> m2\n 2. \\<And>Lnl rn nat.\n       \\<lbrakk>hd (Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires) = Oc;\n        l = Oc \\<up> lm ! n @ Bk \\<up> Lnl @ Bk # Bk # ires;\n        xs = Bk \\<up> rn; lm ! n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            tl (Oc \\<up> lm ! n @\n                                Bk \\<up> Lnl @ Bk # Bk # ires) =\n                            Oc \\<up> m1 @\n                            Bk \\<up> Lnl @ Bk # Bk # ires \\<and>\n                            [Oc, Oc] = Oc \\<up> m2", "apply(case_tac Lnl, simp_all add: numeral_2_eq_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_left_moving_nonempty_snd[simp]: \"mopup_left_moving (2 * n + 5, l, xs) lm n ires \\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (2 * n + 5, l, xs) lm n ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(auto simp: mopup_left_moving.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_left_moving_hd_Bk[simp]:\n  \"\\<lbrakk>mopup_left_moving (2 * n + 5, l, Bk # xs) lm n ires\\<rbrakk> \n \\<Longrightarrow> mopup_left_moving (2 * n + 5, tl l, hd l # Bk # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (2 * n + 5, l, Bk # xs) lm n ires \\<Longrightarrow>\n    mopup_left_moving (2 * n + 5, tl l, hd l # Bk # xs) lm n ires", "apply(simp only: mopup_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Bk # xs = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Bk # xs = Oc # Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (tl l =\n        Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        hd l # Bk # xs = Bk \\<up> rn \\<or>\n        tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        hd l # Bk # xs = Oc # Bk \\<up> rn)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Bk # xs = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Bk # xs = Oc # Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>lnl lnr rn m.\n          m = Suc (lm ! n) \\<and>\n          (tl l =\n           Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           hd l # Bk # xs = Bk \\<up> rn \\<or>\n           tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           hd l # Bk # xs = Oc # Bk \\<up> rn)", "apply(rename_tac lnl Lnr rn m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl Lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> Lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Bk # xs = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        Bk # xs = Oc # Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>lnl lnr rn m.\n          m = Suc (lm ! n) \\<and>\n          (tl l =\n           Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           hd l # Bk # xs = Bk \\<up> rn \\<or>\n           tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           hd l # Bk # xs = Oc # Bk \\<up> rn)", "apply(case_tac Lnr, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_left_moving_emptylist[simp]: \n  \"\\<lbrakk>mopup_left_moving (2 * n + 5, l, []) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_left_moving (2 * n + 5, tl l, [hd l]) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_left_moving (2 * n + 5, l, []) lm n ires \\<Longrightarrow>\n    mopup_left_moving (2 * n + 5, tl l, [hd l]) lm n ires", "apply(simp only: mopup_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [] = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [] = Oc # Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (tl l =\n        Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [hd l] = Bk \\<up> rn \\<or>\n        tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [hd l] = Oc # Bk \\<up> rn)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [] = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [] = Oc # Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>lnl lnr rn m.\n          m = Suc (lm ! n) \\<and>\n          (tl l =\n           Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           [hd l] = Bk \\<up> rn \\<or>\n           tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           [hd l] = Oc # Bk \\<up> rn)", "apply(rename_tac lnl Lnr rn m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl Lnr rn m.\n       m = Suc (lm ! n) \\<and>\n       (l = Bk \\<up> Lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [] = Bk \\<up> rn \\<or>\n        l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n        [] = Oc # Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>lnl lnr rn m.\n          m = Suc (lm ! n) \\<and>\n          (tl l =\n           Bk \\<up> lnr @ Oc \\<up> m @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           [hd l] = Bk \\<up> rn \\<or>\n           tl l = Oc \\<up> (m - 1) @ Bk \\<up> lnl @ Bk # Bk # ires \\<and>\n           [hd l] = Oc # Bk \\<up> rn)", "apply(case_tac Lnr, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lnl nat.\n       l =\n       Bk #\n       Bk \\<up> nat @\n       Oc #\n       Oc \\<up> lm ! n @ Bk \\<up> lnl @ Bk # Bk # ires \\<Longrightarrow>\n       \\<exists>rn. [Bk] = Bk \\<up> rn", "apply(rule_tac x = 1 in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_jump_over2_Oc_nonempty[simp]: \n  \"mopup_jump_over2 (2 * n + 6, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over2 (2 * n + 6, l, Oc # xs) lm n ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(auto simp: mopup_jump_over2.simps )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_jump_over2_context[simp]: \n  \"\\<lbrakk>mopup_jump_over2 (2 * n + 6, l, Oc # xs) lm n ires\\<rbrakk>\n \\<Longrightarrow>  mopup_jump_over2 (2 * n + 6, tl l, hd l # Oc # xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over2 (2 * n + 6, l, Oc # xs) lm n ires \\<Longrightarrow>\n    mopup_jump_over2 (2 * n + 6, tl l, hd l # Oc # xs) lm n ires", "apply(simp only: mopup_jump_over2.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln rn m1 m2.\n       m1 + m2 = Suc (lm ! n) \\<and>\n       Oc # xs \\<noteq> [] \\<and>\n       (hd (Oc # xs) = Oc \\<longrightarrow>\n        l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n       (hd (Oc # xs) = Bk \\<longrightarrow>\n        l = Bk \\<up> ln @ Bk # ires \\<and>\n        Oc # xs = Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>ln rn m1 m2.\n       m1 + m2 = Suc (lm ! n) \\<and>\n       hd l # Oc # xs \\<noteq> [] \\<and>\n       (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n        tl l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n        hd l # Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n       (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n        tl l = Bk \\<up> ln @ Bk # ires \\<and>\n        hd l # Oc # xs = Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn m1 m2.\n       m1 + m2 = Suc (lm ! n) \\<and>\n       Oc # xs \\<noteq> [] \\<and>\n       (hd (Oc # xs) = Oc \\<longrightarrow>\n        l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n        Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n       (hd (Oc # xs) = Bk \\<longrightarrow>\n        l = Bk \\<up> ln @ Bk # ires \\<and>\n        Oc # xs = Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>ln rn m1 m2.\n          m1 + m2 = Suc (lm ! n) \\<and>\n          hd l # Oc # xs \\<noteq> [] \\<and>\n          (hd (hd l # Oc # xs) = Oc \\<longrightarrow>\n           tl l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires \\<and>\n           hd l # Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n          (hd (hd l # Oc # xs) = Bk \\<longrightarrow>\n           tl l = Bk \\<up> ln @ Bk # ires \\<and>\n           hd l # Oc # xs = Bk # Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(simp, erule conjE, erule_tac conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn m1 m2.\n       \\<lbrakk>m1 + m2 = Suc (lm ! n);\n        l = Oc \\<up> m1 @ Bk \\<up> ln @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m2 @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lna rna m1a m2a.\n                            m1a + m2a = Suc (lm ! n) \\<and>\n                            (hd (Oc \\<up> m1 @\n                                 Bk \\<up> ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Oc \\<up> m1 @\n                                 Bk \\<up> ln @ Bk # Bk # ires) =\n                             Oc \\<up> m1a @\n                             Bk \\<up> lna @ Bk # Bk # ires \\<and>\n                             Oc # Oc \\<up> m2 @ Bk \\<up> rn =\n                             Oc \\<up> m2a @ Bk \\<up> rna) \\<and>\n                            (hd (Oc \\<up> m1 @\n                                 Bk \\<up> ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Oc \\<up> m1 @\n                                 Bk \\<up> ln @ Bk # Bk # ires) =\n                             Bk \\<up> lna @ Bk # ires \\<and>\n                             Oc \\<up> m2 @ Bk \\<up> rn =\n                             Oc \\<up> (m1a + m2a) @ Bk \\<up> rna)", "apply(rename_tac Ln Rn M1 M2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ln Rn M1 M2.\n       \\<lbrakk>M1 + M2 = Suc (lm ! n);\n        l = Oc \\<up> M1 @ Bk \\<up> Ln @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> M2 @ Bk \\<up> Rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             Oc # Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<up> ln @ Bk # ires \\<and>\n                             Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(case_tac M1, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ln Rn M1.\n       \\<lbrakk>l = Bk \\<up> Ln @ Bk # Bk # ires;\n        xs = Oc \\<up> lm ! n @ Bk \\<up> Rn; M1 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            (hd (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             Oc # Oc # Oc \\<up> lm ! n @ Bk \\<up> Rn =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<up> ln @ Bk # ires \\<and>\n                             Oc # Oc \\<up> lm ! n @ Bk \\<up> Rn =\n                             Oc \\<up> (m1 + m2) @ Bk \\<up> rn)\n 2. \\<And>Ln Rn M1 M2 nat.\n       \\<lbrakk>M1 + M2 = Suc (lm ! n);\n        l = Oc \\<up> M1 @ Bk \\<up> Ln @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> M2 @ Bk \\<up> Rn; M1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             Oc # Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<up> ln @ Bk # ires \\<and>\n                             Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(rule_tac x = Ln in exI, rule_tac x = Rn in exI, \n      rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ln Rn M1.\n       \\<lbrakk>l = Bk \\<up> Ln @ Bk # Bk # ires;\n        xs = Oc \\<up> lm ! n @ Bk \\<up> Rn; M1 = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m2.\n                            0 + m2 = Suc (lm ! n) \\<and>\n                            (hd (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<up> 0 @\n                             Bk \\<up> Ln @ Bk # Bk # ires \\<and>\n                             Oc # Oc # Oc \\<up> lm ! n @ Bk \\<up> Rn =\n                             Oc \\<up> m2 @ Bk \\<up> Rn) \\<and>\n                            (hd (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<up> Ln @ Bk # ires \\<and>\n                             Oc # Oc \\<up> lm ! n @ Bk \\<up> Rn =\n                             Oc \\<up> (0 + m2) @ Bk \\<up> Rn)\n 2. \\<And>Ln Rn M1 M2 nat.\n       \\<lbrakk>M1 + M2 = Suc (lm ! n);\n        l = Oc \\<up> M1 @ Bk \\<up> Ln @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> M2 @ Bk \\<up> Rn; M1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             Oc # Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<up> ln @ Bk # ires \\<and>\n                             Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(case_tac Ln, simp, simp, simp only: exp_ind[THEN sym], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ln Rn M1 M2 nat.\n       \\<lbrakk>M1 + M2 = Suc (lm ! n);\n        l = Oc \\<up> M1 @ Bk \\<up> Ln @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> M2 @ Bk \\<up> Rn; M1 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn m1 m2.\n                            m1 + m2 = Suc (lm ! n) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Oc \\<up> m1 @\n                             Bk \\<up> ln @ Bk # Bk # ires \\<and>\n                             Oc # Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> m2 @ Bk \\<up> rn) \\<and>\n                            (hd (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<longrightarrow>\n                             tl (Oc \\<up> M1 @\n                                 Bk \\<up> Ln @ Bk # Bk # ires) =\n                             Bk \\<up> ln @ Bk # ires \\<and>\n                             Oc \\<up> M2 @ Bk \\<up> Rn =\n                             Oc \\<up> (m1 + m2) @ Bk \\<up> rn)", "apply(rule_tac x = Ln in exI, rule_tac x = Rn in exI, \n      rule_tac x = \"M1-1\" in exI, rule_tac x = \"Suc M2\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_stop_via_jump_over2[simp]: \n  \"\\<lbrakk>mopup_jump_over2 (2 * n + 6, l, Bk # xs) lm n ires\\<rbrakk> \n  \\<Longrightarrow> mopup_stop (0, Bk # l, xs) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over2 (2 * n + 6, l, Bk # xs) lm n ires \\<Longrightarrow>\n    mopup_stop (0, Bk # l, xs) lm n ires", "apply(auto simp: mopup_jump_over2.simps mopup_stop.simps tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn m1 m2.\n       \\<lbrakk>m1 + m2 = Suc (lm ! n);\n        xs = Oc # Oc \\<up> lm ! n @ Bk \\<up> rn;\n        l = Bk \\<up> ln @ Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lna.\n                            Bk # Bk \\<up> ln = Bk \\<up> lna @ [Bk]", "apply(simp add: exp_ind[THEN sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_jump_over2_nonempty[simp]: \"mopup_jump_over2 (2 * n + 6, l, []) lm n ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_jump_over2 (2 * n + 6, l, []) lm n ires = False", "by(auto simp: mopup_jump_over2.simps)"], ["", "declare fetch.simps[simp del]"], ["", "lemma mod_ex2: \"(a mod (2::nat) = 0) = (\\<exists> q. a = 2 * q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even a = (\\<exists>q. a = 2 * q)", "by arith"], ["", "lemma mod_2: \"x mod 2  = 0 \\<or>  x mod 2 = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even x \\<or> x mod 2 = Suc 0", "by arith"], ["", "lemma mopup_inv_step:\n  \"\\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_inv (step (s, l, r) (mopup_a n @ shift mopup_b (2 * n), 0)) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (step0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n)))\n                       lm n ires", "apply(cases r;cases \"hd r\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires; r = [];\n     hd r = Bk\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (step0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n)))\n                       lm n ires\n 2. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires; r = [];\n     hd r = Oc\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (step0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n)))\n                       lm n ires\n 3. \\<And>a list.\n       \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires; r = a # list;\n        hd r = Bk\\<rbrakk>\n       \\<Longrightarrow> mopup_inv\n                          (step0 (s, l, r)\n                            (mopup_a n @ shift mopup_b (2 * n)))\n                          lm n ires\n 4. \\<And>a list.\n       \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires; r = a # list;\n        hd r = Oc\\<rbrakk>\n       \\<Longrightarrow> mopup_inv\n                          (step0 (s, l, r)\n                            (mopup_a n @ shift mopup_b (2 * n)))\n                          lm n ires", "apply(auto split:if_splits simp add:step.simps mopupfetchs fetch.simps(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>r = []; hd [] = Bk; n < length lm; 0 < s; s \\<le> 2 * n;\n     s mod 2 = Suc 0; mopup_bef_erase_a (s, l, []) lm n ires;\n     Suc s \\<noteq> 2 * n; \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc s), Bk # l, []) lm n ires\n 2. \\<lbrakk>r = []; hd [] = Oc; n < length lm; 0 < s; s \\<le> 2 * n;\n     s mod 2 = Suc 0; mopup_bef_erase_a (s, l, []) lm n ires;\n     Suc s \\<noteq> 2 * n; \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc s), Bk # l, []) lm n ires\n 3. \\<And>list.\n       \\<lbrakk>r = Bk # list; n < length lm; 0 < s; s \\<le> 2 * n;\n        s mod 2 = Suc 0; mopup_bef_erase_a (s, l, Bk # list) lm n ires;\n        Suc s \\<noteq> 2 * n; \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc s), Bk # l, list) lm n\n                          ires\n 4. \\<And>list.\n       \\<lbrakk>r = Oc # list; n < length lm; 0 < s; s mod 2 = Suc 0;\n        mopup_bef_erase_a (s, l, Oc # list) lm n ires; Suc s mod 2 = Suc 0;\n        Suc s \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_bef_erase_a (Suc s, l, Bk # list) lm n ires\n 5. \\<And>list.\n       \\<lbrakk>r = Oc # list; n < length lm; 0 < s; s \\<le> 2 * n;\n        mopup_bef_erase_b (s, l, Oc # list) lm n ires; even s\\<rbrakk>\n       \\<Longrightarrow> mopup_inv\n                          (case fetch (mopup_a n @ shift mopup_b (2 * n)) s\n                                 Oc of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (l, Oc # list)))\n                          lm n ires", "apply(drule_tac mopup_false2, simp_all add: mopup_bef_erase_b.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>r = []; hd [] = Oc; n < length lm; 0 < s; s \\<le> 2 * n;\n     s mod 2 = Suc 0; mopup_bef_erase_a (s, l, []) lm n ires;\n     Suc s \\<noteq> 2 * n; \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n    \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc s), Bk # l, []) lm n ires\n 2. \\<And>list.\n       \\<lbrakk>r = Bk # list; n < length lm; 0 < s; s \\<le> 2 * n;\n        s mod 2 = Suc 0; mopup_bef_erase_a (s, l, Bk # list) lm n ires;\n        Suc s \\<noteq> 2 * n; \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc s), Bk # l, list) lm n\n                          ires\n 3. \\<And>list.\n       \\<lbrakk>r = Oc # list; n < length lm; 0 < s; s mod 2 = Suc 0;\n        mopup_bef_erase_a (s, l, Oc # list) lm n ires; Suc s mod 2 = Suc 0;\n        Suc s \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_bef_erase_a (Suc s, l, Bk # list) lm n ires", "apply(drule_tac mopup_false2, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>r = Bk # list; n < length lm; 0 < s; s \\<le> 2 * n;\n        s mod 2 = Suc 0; mopup_bef_erase_a (s, l, Bk # list) lm n ires;\n        Suc s \\<noteq> 2 * n; \\<not> Suc (Suc s) \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_aft_erase_a (Suc (Suc s), Bk # l, list) lm n\n                          ires\n 2. \\<And>list.\n       \\<lbrakk>r = Oc # list; n < length lm; 0 < s; s mod 2 = Suc 0;\n        mopup_bef_erase_a (s, l, Oc # list) lm n ires; Suc s mod 2 = Suc 0;\n        Suc s \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_bef_erase_a (Suc s, l, Bk # list) lm n ires", "apply(drule_tac mopup_false2, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>r = Oc # list; n < length lm; 0 < s; s mod 2 = Suc 0;\n        mopup_bef_erase_a (s, l, Oc # list) lm n ires; Suc s mod 2 = Suc 0;\n        Suc s \\<le> 2 * n\\<rbrakk>\n       \\<Longrightarrow> mopup_bef_erase_a (Suc s, l, Bk # list) lm n ires", "by presburger"], ["", "declare mopup_inv.simps[simp del]"], ["", "lemma mopup_inv_steps: \n  \"\\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk> \\<Longrightarrow> \n     mopup_inv (steps (s, l, r) (mopup_a n @ shift mopup_b (2 * n), 0)  stp) lm n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                         stp)\n                       lm n ires", "proof(induct stp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                         0)\n                       lm n ires\n 2. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>n < length lm;\n                 mopup_inv (s, l, r) lm n ires\\<rbrakk>\n                \\<Longrightarrow> mopup_inv\n                                   (steps0 (s, l, r)\n                                     (mopup_a n @ shift mopup_b (2 * n))\n                                     stp)\n                                   lm n ires;\n        n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n       \\<Longrightarrow> mopup_inv\n                          (steps0 (s, l, r)\n                            (mopup_a n @ shift mopup_b (2 * n)) (Suc stp))\n                          lm n ires", "case (Suc stp)"], ["proof (state)\nthis:\n  \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_inv\n                     (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                       stp)\n                     lm n ires\n  n < length lm\n  mopup_inv (s, l, r) lm n ires\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                         0)\n                       lm n ires\n 2. \\<And>stp.\n       \\<lbrakk>\\<lbrakk>n < length lm;\n                 mopup_inv (s, l, r) lm n ires\\<rbrakk>\n                \\<Longrightarrow> mopup_inv\n                                   (steps0 (s, l, r)\n                                     (mopup_a n @ shift mopup_b (2 * n))\n                                     stp)\n                                   lm n ires;\n        n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n       \\<Longrightarrow> mopup_inv\n                          (steps0 (s, l, r)\n                            (mopup_a n @ shift mopup_b (2 * n)) (Suc stp))\n                          lm n ires", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_inv\n                     (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                       stp)\n                     lm n ires\n  n < length lm\n  mopup_inv (s, l, r) lm n ires", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_inv\n                     (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                       stp)\n                     lm n ires\n  n < length lm\n  mopup_inv (s, l, r) lm n ires\n\ngoal (1 subgoal):\n 1. mopup_inv\n     (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n)) (Suc stp)) lm n\n     ires", "by ( cases \"steps (s, l, r) \n                (mopup_a n @ shift mopup_b (2 * n), 0) stp\"\n        , auto simp add: steps.simps intro:mopup_inv_step)"], ["proof (state)\nthis:\n  mopup_inv (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n)) (Suc stp))\n   lm n ires\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length lm; mopup_inv (s, l, r) lm n ires\\<rbrakk>\n    \\<Longrightarrow> mopup_inv\n                       (steps0 (s, l, r) (mopup_a n @ shift mopup_b (2 * n))\n                         0)\n                       lm n ires", "qed (auto simp add: steps.simps)"], ["", "fun abc_mopup_stage1 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_mopup_stage1 (s, l, r) n = \n           (if s > 0 \\<and> s \\<le> 2*n then 6\n            else if s = 2*n + 1 then 4\n            else if s \\<ge> 2*n + 2 \\<and> s \\<le> 2*n + 4 then 3\n            else if s = 2*n + 5 then 2\n            else if s = 2*n + 6 then 1\n            else 0)\""], ["", "fun abc_mopup_stage2 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_mopup_stage2 (s, l, r) n = \n           (if s > 0 \\<and> s \\<le> 2*n then length r\n            else if s = 2*n + 1 then length r\n            else if s = 2*n + 5 then length l\n            else if s = 2*n + 6 then length l\n            else if s \\<ge> 2*n + 2 \\<and> s \\<le> 2*n + 4 then length r\n            else 0)\""], ["", "fun abc_mopup_stage3 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_mopup_stage3 (s, l, r) n = \n          (if s > 0 \\<and> s \\<le> 2*n then \n              if hd r = Bk then 0\n              else 1\n           else if s = 2*n + 2 then 1 \n           else if s = 2*n + 3 then 0\n           else if s = 2*n + 4 then 2\n           else 0)\""], ["", "definition\n  \"abc_mopup_measure = measures [\\<lambda>(c, n). abc_mopup_stage1 c n, \n                                 \\<lambda>(c, n). abc_mopup_stage2 c n, \n                                 \\<lambda>(c, n). abc_mopup_stage3 c n]\""], ["", "lemma wf_abc_mopup_measure:\n  shows \"wf abc_mopup_measure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf abc_mopup_measure", "unfolding abc_mopup_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures\n         [\\<lambda>(x, y). abc_mopup_stage1 x y,\n          \\<lambda>(x, y). abc_mopup_stage2 x y,\n          \\<lambda>(x, y). abc_mopup_stage3 x y])", "by auto"], ["", "lemma abc_mopup_measure_induct [case_names Step]: \n  \"\\<lbrakk>\\<And>n. \\<not> P (f n) \\<Longrightarrow> (f (Suc n), (f n)) \\<in> abc_mopup_measure\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> P (f n) \\<Longrightarrow>\n        (f (Suc n), f n) \\<in> abc_mopup_measure) \\<Longrightarrow>\n    \\<exists>n. P (f n)", "using wf_abc_mopup_measure"], ["proof (prove)\nusing this:\n  wf abc_mopup_measure\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> P (f n) \\<Longrightarrow>\n        (f (Suc n), f n) \\<in> abc_mopup_measure) \\<Longrightarrow>\n    \\<exists>n. P (f n)", "by (metis wf_iff_no_infinite_down_chain)"], ["", "lemma mopup_erase_nonempty[simp]:\n  \"mopup_bef_erase_a (a, aa, []) lm n ires = False\"\n  \"mopup_bef_erase_b (a, aa, []) lm n ires = False\"\n  \"mopup_aft_erase_b (2 * n + 3, aa, []) lm n ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_bef_erase_a (a, aa, []) lm n ires = False &&&\n    mopup_bef_erase_b (a, aa, []) lm n ires = False &&&\n    mopup_aft_erase_b (2 * n + 3, aa, []) lm n ires = False", "by(auto simp: mopup_bef_erase_a.simps mopup_bef_erase_b.simps mopup_aft_erase_b.simps)"], ["", "declare mopup_inv.simps[simp del]"], ["", "lemma fetch_mopup_a_shift[simp]: \n  assumes \"0 < q\" \"q \\<le> n\"\n  shows \"fetch (mopup_a n @ shift mopup_b (2 * n)) (2*q) Bk = (R, 2*q - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "proof(cases q)"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)\n 2. \\<And>nat.\n       q = Suc nat \\<Longrightarrow>\n       fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "case (Suc nat)"], ["proof (state)\nthis:\n  q = Suc nat\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)\n 2. \\<And>nat.\n       q = Suc nat \\<Longrightarrow>\n       fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "with assms"], ["proof (chain)\npicking this:\n  0 < q\n  q \\<le> n\n  q = Suc nat", "have \"mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! ((4 * nat) + 2)\""], ["proof (prove)\nusing this:\n  0 < q\n  q \\<le> n\n  q = Suc nat\n\ngoal (1 subgoal):\n 1. mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)", "using assms"], ["proof (prove)\nusing this:\n  0 < q\n  q \\<le> n\n  q = Suc nat\n  0 < q\n  q \\<le> n\n\ngoal (1 subgoal):\n 1. mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)", "by (metis Suc_le_lessD add_2_eq_Suc' less_Suc_eq mopup_a_nth numeral_Bit0)"], ["proof (state)\nthis:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)\n 2. \\<And>nat.\n       q = Suc nat \\<Longrightarrow>\n       fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "then"], ["proof (chain)\npicking this:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "using assms Suc"], ["proof (prove)\nusing this:\n  mopup_a n ! (4 * nat + 2) = mopup_a (Suc nat) ! (4 * nat + 2)\n  0 < q\n  q \\<le> n\n  q = Suc nat\n\ngoal (1 subgoal):\n 1. fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "by(auto simp: fetch.simps nth_of.simps nth_append)"], ["proof (state)\nthis:\n  fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)\n\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow>\n    fetch (mopup_a n @ shift mopup_b (2 * n)) (2 * q) Bk = (R, 2 * q - 1)", "qed (insert assms,auto)"], ["", "lemma mopup_halt:\n  assumes \n    less: \"n < length lm\"\n    and inv: \"mopup_inv (Suc 0, l, r) lm n ires\"\n    and f: \"f = (\\<lambda> stp. (steps (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n), 0) stp, n))\"\n    and P: \"P = (\\<lambda> (c, n). is_final c)\"\n  shows \"\\<exists> stp. P (f stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. P (f stp)", "proof (induct rule: abc_mopup_measure_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> P (f stp) \\<Longrightarrow>\n       (f (Suc stp), f stp) \\<in> abc_mopup_measure", "case (Step na)"], ["proof (state)\nthis:\n  \\<not> P (f na)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> P (f stp) \\<Longrightarrow>\n       (f (Suc stp), f stp) \\<in> abc_mopup_measure", "have h: \"\\<not> P (f na)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f na)", "by fact"], ["proof (state)\nthis:\n  \\<not> P (f na)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> P (f stp) \\<Longrightarrow>\n       (f (Suc stp), f stp) \\<in> abc_mopup_measure", "show \"(f (Suc na), f na) \\<in> abc_mopup_measure\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f (Suc na), f na) \\<in> abc_mopup_measure", "proof(simp add: f)"], ["proof (state)\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "obtain a b c where g:\"steps (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n), 0) na = (a, b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na =\n        (a, b, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(case_tac \"steps (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n), 0) na\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na = (a, b, c)\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "then"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na = (a, b, c)", "have \"mopup_inv (a, b, c) lm n ires\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na = (a, b, c)\n\ngoal (1 subgoal):\n 1. mopup_inv (a, b, c) lm n ires", "using inv less mopup_inv_steps[of n lm \"Suc 0\" l r ires na]"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na = (a, b, c)\n  mopup_inv (Suc 0, l, r) lm n ires\n  n < length lm\n  \\<lbrakk>n < length lm; mopup_inv (Suc 0, l, r) lm n ires\\<rbrakk>\n  \\<Longrightarrow> mopup_inv\n                     (steps0 (Suc 0, l, r)\n                       (mopup_a n @ shift mopup_b (2 * n)) na)\n                     lm n ires\n\ngoal (1 subgoal):\n 1. mopup_inv (a, b, c) lm n ires", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mopup_inv (a, b, c) lm n ires\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "moreover"], ["proof (state)\nthis:\n  mopup_inv (a, b, c) lm n ires\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "have \"a > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a", "using h g"], ["proof (prove)\nusing this:\n  \\<not> P (f na)\n  steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na = (a, b, c)\n\ngoal (1 subgoal):\n 1. 0 < a", "apply(simp add: f P)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "ultimately"], ["proof (chain)\npicking this:\n  mopup_inv (a, b, c) lm n ires\n  0 < a", "have \"((step (a, b, c) (mopup_a n @ shift mopup_b (2 * n), 0), n), (a, b, c), n) \\<in> abc_mopup_measure\""], ["proof (prove)\nusing this:\n  mopup_inv (a, b, c) lm n ires\n  0 < a\n\ngoal (1 subgoal):\n 1. ((step0 (a, b, c) (mopup_a n @ shift mopup_b (2 * n)), n), (a, b, c), n)\n    \\<in> abc_mopup_measure", "apply(case_tac c;cases \"hd c\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>mopup_inv (a, b, c) lm n ires; 0 < a; c = [];\n     mopup_inv (a, b, c) lm n ires; 0 < a; hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> ((step0 (a, b, c) (mopup_a n @ shift mopup_b (2 * n)),\n                        n),\n                       (a, b, c), n)\n                      \\<in> abc_mopup_measure\n 2. \\<lbrakk>mopup_inv (a, b, c) lm n ires; 0 < a; c = [];\n     mopup_inv (a, b, c) lm n ires; 0 < a; hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> ((step0 (a, b, c) (mopup_a n @ shift mopup_b (2 * n)),\n                        n),\n                       (a, b, c), n)\n                      \\<in> abc_mopup_measure\n 3. \\<And>aa list.\n       \\<lbrakk>mopup_inv (a, b, c) lm n ires; 0 < a; c = aa # list;\n        mopup_inv (a, b, c) lm n ires; 0 < a; hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> ((step0 (a, b, c)\n                            (mopup_a n @ shift mopup_b (2 * n)),\n                           n),\n                          (a, b, c), n)\n                         \\<in> abc_mopup_measure\n 4. \\<And>aa list.\n       \\<lbrakk>mopup_inv (a, b, c) lm n ires; 0 < a; c = aa # list;\n        mopup_inv (a, b, c) lm n ires; 0 < a; hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> ((step0 (a, b, c)\n                            (mopup_a n @ shift mopup_b (2 * n)),\n                           n),\n                          (a, b, c), n)\n                         \\<in> abc_mopup_measure", "apply(auto split:if_splits simp add:step.simps mopup_inv.simps mopup_bef_erase_b.simps)"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<lbrakk>hd [] = Bk; mopup_jump_over1 (Suc (2 * n), b, []) lm n ires;\n     c = []; a = Suc (2 * n)\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (Suc (2 * n)) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (Suc (2 * n), b, []), n)\n                      \\<in> abc_mopup_measure\n 2. \\<lbrakk>c = []; mopup_aft_erase_a (Suc (Suc (2 * n)), b, []) lm n ires;\n     hd [] = Bk; a = Suc (Suc (2 * n))\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (Suc (Suc (2 * n))) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (Suc (Suc (2 * n)), b, []), n)\n                      \\<in> abc_mopup_measure\n 3. \\<lbrakk>c = []; mopup_aft_erase_c (2 * n + 4, b, []) lm n ires;\n     hd [] = Bk; a = 2 * n + 4\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (2 * n + 4) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (2 * n + 4, b, []), n)\n                      \\<in> abc_mopup_measure\n 4. \\<lbrakk>hd [] = Bk; mopup_left_moving (2 * n + 5, b, []) lm n ires;\n     c = []; a = 2 * n + 5\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (2 * n + 5) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (2 * n + 5, b, []), n)\n                      \\<in> abc_mopup_measure\n 5. \\<lbrakk>hd [] = Oc; mopup_jump_over1 (Suc (2 * n), b, []) lm n ires;\n     c = []; a = Suc (2 * n)\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (Suc (2 * n)) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (Suc (2 * n), b, []), n)\n                      \\<in> abc_mopup_measure\n 6. \\<lbrakk>c = []; mopup_aft_erase_a (Suc (Suc (2 * n)), b, []) lm n ires;\n     hd [] = Oc; a = Suc (Suc (2 * n))\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (Suc (Suc (2 * n))) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (Suc (Suc (2 * n)), b, []), n)\n                      \\<in> abc_mopup_measure\n 7. \\<lbrakk>c = []; mopup_aft_erase_c (2 * n + 4, b, []) lm n ires;\n     hd [] = Oc; a = 2 * n + 4\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (2 * n + 4) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (2 * n + 4, b, []), n)\n                      \\<in> abc_mopup_measure\n 8. \\<lbrakk>hd [] = Oc; mopup_left_moving (2 * n + 5, b, []) lm n ires;\n     c = []; a = 2 * n + 5\\<rbrakk>\n    \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n))\n                              (2 * n + 5) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        n),\n                       (2 * n + 5, b, []), n)\n                      \\<in> abc_mopup_measure\n 9. \\<And>list.\n       \\<lbrakk>0 < a; a \\<le> 2 * n;\n        mopup_bef_erase_a (a, b, Bk # list) lm n ires; c = Bk # list;\n        a mod 2 = Suc 0\\<rbrakk>\n       \\<Longrightarrow> (((Suc (Suc a), Bk # b, list), n),\n                          (a, b, Bk # list), n)\n                         \\<in> abc_mopup_measure\n 10. \\<And>ln m rn.\n        \\<lbrakk>0 < a; a \\<le> 2 * n;\n         c = Bk # Oc \\<up> m @ Bk # <drop (a div 2) lm> @ Bk \\<up> rn;\n         even a; b = Bk \\<up> ln @ Bk # Bk # ires\\<rbrakk>\n        \\<Longrightarrow> ((case fetch (mopup_a n @ shift mopup_b (2 * n)) a\n                                  Bk of\n                            (aa, s') \\<Rightarrow>\n                              (s',\n                               update aa\n                                (Bk \\<up> ln @ Bk # Bk # ires,\n                                 Bk #\n                                 Oc \\<up> m @\n                                 Bk # <drop (a div 2) lm> @ Bk \\<up> rn)),\n                            n),\n                           (a, Bk \\<up> ln @ Bk # Bk # ires,\n                            Bk #\n                            Oc \\<up> m @\n                            Bk # <drop (a div 2) lm> @ Bk \\<up> rn),\n                           n)\n                          \\<in> abc_mopup_measure\nA total of 22 subgoals...", "by (auto split:if_splits simp: mopupfetchs abc_mopup_measure_def )"], ["proof (state)\nthis:\n  ((step0 (a, b, c) (mopup_a n @ shift mopup_b (2 * n)), n), (a, b, c), n)\n  \\<in> abc_mopup_measure\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "thus \"((step (steps (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n), 0) na) \n      (mopup_a n @ shift mopup_b (2 * n), 0), n),\n      steps (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n), 0) na, n)\n      \\<in> abc_mopup_measure\""], ["proof (prove)\nusing this:\n  ((step0 (a, b, c) (mopup_a n @ shift mopup_b (2 * n)), n), (a, b, c), n)\n  \\<in> abc_mopup_measure\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "using g"], ["proof (prove)\nusing this:\n  ((step0 (a, b, c) (mopup_a n @ shift mopup_b (2 * n)), n), (a, b, c), n)\n  \\<in> abc_mopup_measure\n  steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na = (a, b, c)\n\ngoal (1 subgoal):\n 1. ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n       (mopup_a n @ shift mopup_b (2 * n)),\n      n),\n     steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n    \\<in> abc_mopup_measure", "by simp"], ["proof (state)\nthis:\n  ((step0 (steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na)\n     (mopup_a n @ shift mopup_b (2 * n)),\n    n),\n   steps0 (Suc 0, l, r) (mopup_a n @ shift mopup_b (2 * n)) na, n)\n  \\<in> abc_mopup_measure\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f (Suc na), f na) \\<in> abc_mopup_measure\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mopup_inv_start: \n  \"n < length am \\<Longrightarrow> mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length am \\<Longrightarrow>\n    mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires", "apply(cases am;auto simp: mopup_inv.simps mopup_bef_erase_a.simps mopup_jump_over1.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>n < Suc (length list); am = a # list; Suc 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m rn.\n                            <a # list> @ Bk \\<up> k =\n                            Oc \\<up> m @ Bk # <list> @ Bk \\<up> rn\n 2. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           <a # list> @ Bk \\<up> k \\<noteq>\n           Oc #\n           Oc \\<up> (a # list) ! n @\n           Bk # <drop n list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> <a # list> @ Bk \\<up> k =\n                         Oc # Oc \\<up> (a # list) ! n\n 3. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           <a # list> @ Bk \\<up> k \\<noteq>\n           Oc #\n           Oc \\<up> (a # list) ! n @\n           Bk # <drop n list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> length list \\<le> n", "apply(auto simp: tape_of_nl_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>n < Suc (length list); am = a # list; Suc 0 \\<le> n;\n        list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m rn.\n                            Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> k =\n                            Oc \\<up> m @ Bk # <list> @ Bk \\<up> rn\n 2. \\<And>a.\n       \\<lbrakk>am = [a]; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           Oc \\<up> a @ Bk \\<up> k \\<noteq>\n           Oc \\<up> [a] ! n @ Bk # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> a @ Bk \\<up> k = Oc \\<up> [a] ! n\n 3. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           Oc \\<up> a @ Bk # <list> @ Bk \\<up> k \\<noteq>\n           Oc \\<up> (a # list) ! n @ Bk # <drop n list> @ Bk \\<up> rn;\n        list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> a @ Bk # <list> @ Bk \\<up> k =\n                         Oc \\<up> (a # list) ! n\n 4. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           (if list = [] then Oc \\<up> Suc a\n            else Oc \\<up> Suc a @ Bk # <list>) @\n           Bk \\<up> k \\<noteq>\n           Oc #\n           Oc \\<up> (a # list) ! n @\n           Bk # <drop n list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> length list \\<le> n", "apply(rule_tac x = \"Suc (hd am)\" in exI, rule_tac x = k in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>am = [a]; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           Oc \\<up> a @ Bk \\<up> k \\<noteq>\n           Oc \\<up> [a] ! n @ Bk # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> a @ Bk \\<up> k = Oc \\<up> [a] ! n\n 2. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           Oc \\<up> a @ Bk # <list> @ Bk \\<up> k \\<noteq>\n           Oc \\<up> (a # list) ! n @ Bk # <drop n list> @ Bk \\<up> rn;\n        list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> a @ Bk # <list> @ Bk \\<up> k =\n                         Oc \\<up> (a # list) ! n\n 3. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           (if list = [] then Oc \\<up> Suc a\n            else Oc \\<up> Suc a @ Bk # <list>) @\n           Bk \\<up> k \\<noteq>\n           Oc #\n           Oc \\<up> (a # list) ! n @\n           Bk # <drop n list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> length list \\<le> n", "apply(cases k;cases n;force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           Oc \\<up> a @ Bk # <list> @ Bk \\<up> k \\<noteq>\n           Oc \\<up> (a # list) ! n @ Bk # <drop n list> @ Bk \\<up> rn;\n        list \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> a @ Bk # <list> @ Bk \\<up> k =\n                         Oc \\<up> (a # list) ! n\n 2. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           (if list = [] then Oc \\<up> Suc a\n            else Oc \\<up> Suc a @ Bk # <list>) @\n           Bk \\<up> k \\<noteq>\n           Oc #\n           Oc \\<up> (a # list) ! n @\n           Bk # <drop n list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> length list \\<le> n", "apply(cases n; force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>am = a # list; \\<not> Suc 0 \\<le> n;\n        \\<forall>rn.\n           (if list = [] then Oc \\<up> Suc a\n            else Oc \\<up> Suc a @ Bk # <list>) @\n           Bk \\<up> k \\<noteq>\n           Oc #\n           Oc \\<up> (a # list) ! n @\n           Bk # <drop n list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> length list \\<le> n", "by(cases n; force split:if_splits)"], ["", "lemma mopup_correct:\n  assumes less: \"n < length (am::nat list)\"\n    and rs: \"am ! n = rs\"\n  shows \"\\<exists> stp i j. (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp)\n    = (0, Bk\\<up>i @ Bk # Bk # ires, Oc # Oc\\<up> rs @ Bk\\<up>j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "using less"], ["proof (prove)\nusing this:\n  n < length am\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < length am \\<Longrightarrow>\n    \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "have a: \"mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires", "using less"], ["proof (prove)\nusing this:\n  n < length am\n\ngoal (1 subgoal):\n 1. mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires", "apply(simp add: mopup_inv_start)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\n\ngoal (1 subgoal):\n 1. n < length am \\<Longrightarrow>\n    \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "then"], ["proof (chain)\npicking this:\n  mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires", "have \"\\<exists> stp. is_final (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp)\""], ["proof (prove)\nusing this:\n  mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final\n        (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n          (mopup_a n @ shift mopup_b (2 * n)) stp)", "using less mopup_halt[of n am  \"Bk # Bk # ires\" \"<am> @ Bk \\<up> k\" ires\n        \"(\\<lambda>stp. (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp, n))\"\n        \"(\\<lambda>(c, n). is_final c)\"]"], ["proof (prove)\nusing this:\n  mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\n  n < length am\n  \\<lbrakk>n < length am;\n   mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires;\n   (\\<lambda>stp.\n       (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n         (mopup_a n @ shift mopup_b (2 * n)) stp,\n        n)) =\n   (\\<lambda>stp.\n       (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n         (mopup_a n @ shift mopup_b (2 * n)) stp,\n        n));\n   (\\<lambda>(c, n). is_final c) = (\\<lambda>(c, n). is_final c)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp.\n                       case (steps0\n                              (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n                              (mopup_a n @ shift mopup_b (2 * n)) stp,\n                             n) of\n                       (c, n) \\<Rightarrow> is_final c\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final\n        (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n          (mopup_a n @ shift mopup_b (2 * n)) stp)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     is_final\n      (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp)\n\ngoal (1 subgoal):\n 1. n < length am \\<Longrightarrow>\n    \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp.\n     is_final\n      (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp)", "obtain stp where b:\n    \"is_final (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp)\""], ["proof (prove)\nusing this:\n  \\<exists>stp.\n     is_final\n      (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp)\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        is_final\n         (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n           (mopup_a n @ shift mopup_b (2 * n)) stp) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  is_final\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n\ngoal (1 subgoal):\n 1. n < length am \\<Longrightarrow>\n    \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "from a b"], ["proof (chain)\npicking this:\n  mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\n  is_final\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)", "have\n    \"mopup_inv (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp)\n    am n ires\""], ["proof (prove)\nusing this:\n  mopup_inv (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) am n ires\n  is_final\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n\ngoal (1 subgoal):\n 1. mopup_inv\n     (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n       (mopup_a n @ shift mopup_b (2 * n)) stp)\n     am n ires", "apply(rule_tac mopup_inv_steps, simp_all add: less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mopup_inv\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n   am n ires\n\ngoal (1 subgoal):\n 1. n < length am \\<Longrightarrow>\n    \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "from b and this"], ["proof (chain)\npicking this:\n  is_final\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n  mopup_inv\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n   am n ires", "show \"?thesis\""], ["proof (prove)\nusing this:\n  is_final\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n  mopup_inv\n   (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (mopup_a n @ shift mopup_b (2 * n)) stp)\n   am n ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "apply(rule_tac x = stp in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_final\n              (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n                (mopup_a n @ shift mopup_b (2 * n)) stp);\n     mopup_inv\n      (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp)\n      am n ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j.\n                         steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n                          (mopup_a n @ shift mopup_b (2 * n)) stp =\n                         (0, Bk \\<up> i @ Bk # Bk # ires,\n                          Oc # Oc \\<up> rs @ Bk \\<up> j)", "apply(case_tac \"steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) \n      (mopup_a n @ shift mopup_b (2 * n), 0) stp\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>is_final\n                 (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n                   (mopup_a n @ shift mopup_b (2 * n)) stp);\n        mopup_inv\n         (steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n           (mopup_a n @ shift mopup_b (2 * n)) stp)\n         am n ires;\n        steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n         (mopup_a n @ shift mopup_b (2 * n)) stp =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            steps0\n                             (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n                             (mopup_a n @ shift mopup_b (2 * n)) stp =\n                            (0, Bk \\<up> i @ Bk # Bk # ires,\n                             Oc # Oc \\<up> rs @ Bk \\<up> j)", "apply(simp add: mopup_inv.simps mopup_stop.simps rs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a = 0;\n        (\\<exists>ln. b = Bk \\<up> ln @ Bk # Bk # ires) \\<and>\n        (\\<exists>rn. c = <rs> @ Bk \\<up> rn);\n        steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n         (mopup_a n @ shift mopup_b (2 * n)) stp =\n        (0, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j. c = Oc # Oc \\<up> rs @ Bk \\<up> j", "using rs"], ["proof (prove)\nusing this:\n  am ! n = rs\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a = 0;\n        (\\<exists>ln. b = Bk \\<up> ln @ Bk # Bk # ires) \\<and>\n        (\\<exists>rn. c = <rs> @ Bk \\<up> rn);\n        steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n         (mopup_a n @ shift mopup_b (2 * n)) stp =\n        (0, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j. c = Oc # Oc \\<up> rs @ Bk \\<up> j", "apply(simp add: tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp i j.\n     steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n      (mopup_a n @ shift mopup_b (2 * n)) stp =\n     (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_mopup[intro]: \"tm_wf (mopup n, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 (mopup n)", "by(induct n, auto simp add: shift.simps mopup_b_def tm_wf.simps)"], ["", "end"]]}