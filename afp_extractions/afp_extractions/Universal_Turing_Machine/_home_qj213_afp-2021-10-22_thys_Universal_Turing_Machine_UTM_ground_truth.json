{"file_name": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine/UTM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine", "problem_names": ["lemma bin_wc_eq: \"bl_bin xs = bl2wc xs\"", "lemma tape_of_nl_append_one: \"lm \\<noteq> [] \\<Longrightarrow>  <lm @ [a]> = <lm> @ Bk # Oc\\<up>Suc a\"", "lemma tape_of_nl_rev: \"rev (<lm::nat list>) = (<rev lm>)\"", "lemma exp_1[simp]: \"a\\<up>(Suc 0) = [a]\"", "lemma tape_of_nl_cons_app1: \"(<a # xs @ [b]>) = (Oc\\<up>(Suc a) @ Bk # (<xs@ [b]>))\"", "lemma bl_bin_bk_oc[simp]:\n  \"bl_bin (xs @ [Bk, Oc]) = \n  bl_bin xs + 2*2^(length xs)\"", "lemma tape_of_nat[simp]: \"(<a::nat>) = Oc\\<up>(Suc a)\"", "lemma tape_of_nl_cons_app2: \"(<c # xs @ [b]>) = (<c # xs> @ Bk # Oc\\<up>(Suc b))\"", "lemma length_2_elems[simp]: \"length (<aa # a # list>) = Suc (Suc aa) + length (<a # list>)\"", "lemma bl_bin_addition[simp]: \"bl_bin (Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista) @ [Bk, Oc]) =\n              bl_bin (Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista)) + \n              2* 2^(length (Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista)))\"", "lemma bl_bin_2[simp]: \n  \"bl_bin (<aa # list>) + (4 * rs + 4) * 2 ^ (length (<aa # list>) - Suc 0)\n  = bl_bin (Oc\\<up>(Suc aa) @ Bk # <list @ [0]>) + rs * (2 * 2 ^ (aa + length (<list @ [0]>)))\"", "lemma tape_of_nl_app_Suc: \"((<list @ [Suc ab]>)) = (<list @ [ab]>) @ [Oc]\"", "lemma bl_bin_3[simp]: \"bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]> @ [Oc])\n              = bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>) +\n              2^(length (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>))\"", "lemma bl_bin_4[simp]: \"bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>) + (4 * 2 ^ (aa + length (<list @ [ab]>)) +\n         4 * (rs * 2 ^ (aa + length (<list @ [ab]>)))) =\n       bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [Suc ab]>) +\n         rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))\"", "lemma wf_lex_pair[intro]: \"wf lex_pair\"", "lemma wf_wcode_double_case_le[intro]: \"wf wcode_double_case_le\"", "lemma fetch_t_wcode_main[simp]:\n  \"fetch t_wcode_main (Suc 0) Bk = (L, Suc 0)\"\n  \"fetch t_wcode_main (Suc 0) Oc = (L, Suc (Suc 0))\"\n  \"fetch t_wcode_main (Suc (Suc 0)) Oc = (R, 3)\"\n  \"fetch t_wcode_main (Suc (Suc 0)) Bk = (L, 7)\"\n  \"fetch t_wcode_main (Suc (Suc (Suc 0))) Bk = (R, 4)\"\n  \"fetch t_wcode_main (Suc (Suc (Suc 0))) Oc = (W0, 3)\"\n  \"fetch t_wcode_main 4 Bk = (R, 4)\"\n  \"fetch t_wcode_main 4 Oc = (R, 5)\"\n  \"fetch t_wcode_main 5 Oc = (R, 5)\"\n  \"fetch t_wcode_main 5 Bk = (W1, 6)\"\n  \"fetch t_wcode_main 6 Bk = (R, 13)\"\n  \"fetch t_wcode_main 6 Oc = (L, 6)\"\n  \"fetch t_wcode_main 7 Oc = (R, 8)\"\n  \"fetch t_wcode_main 7 Bk = (R, 0)\"\n  \"fetch t_wcode_main 8 Bk = (R, 9)\"\n  \"fetch t_wcode_main 9 Bk = (R, 10)\"\n  \"fetch t_wcode_main 9 Oc = (W0, 9)\"\n  \"fetch t_wcode_main 10 Bk = (R, 10)\"\n  \"fetch t_wcode_main 10 Oc = (R, 11)\"\n  \"fetch t_wcode_main 11 Bk = (W1, 12)\"\n  \"fetch t_wcode_main 11 Oc = (R, 11)\"\n  \"fetch t_wcode_main 12 Oc = (L, 12)\"\n  \"fetch t_wcode_main 12 Bk = (R, t_twice_len + 14)\"", "lemmas wcode_double_case_inv_simps = \n  wcode_on_left_moving_1.simps wcode_on_left_moving_1_O.simps\n  wcode_on_left_moving_1_B.simps wcode_on_checking_1.simps\n  wcode_erase1.simps wcode_on_right_moving_1.simps\n  wcode_goon_right_moving_1.simps wcode_backto_standard_pos.simps", "lemma wcode_on_left_moving_1[simp]:\n  \"wcode_on_left_moving_1 ires rs (b, []) = False\"\n  \"wcode_on_left_moving_1 ires rs (b, r) \\<Longrightarrow> b \\<noteq> []\"", "lemma wcode_on_left_moving_1E[elim]: \"\\<lbrakk>wcode_on_left_moving_1 ires rs (b, Bk # list);\n                tl b = aa \\<and> hd b # Bk # list = ba\\<rbrakk> \\<Longrightarrow> \n               wcode_on_left_moving_1 ires rs (aa, ba)\"", "lemma wcode_on_moving_1_Elim[elim]: \n  \"\\<lbrakk>wcode_on_left_moving_1 ires rs (b, Oc # list); tl b = aa \\<and> hd b # Oc # list = ba\\<rbrakk> \n    \\<Longrightarrow> wcode_on_checking_1 ires rs (aa, ba)\"", "lemma wcode_on_checking_1_Elim[elim]: \"\\<lbrakk>wcode_on_checking_1 ires rs (b, Oc # ba);Oc # b = aa \\<and> list = ba\\<rbrakk>\n  \\<Longrightarrow> wcode_erase1 ires rs (aa, ba)\"", "lemma wcode_on_checking_1_simp[simp]:\n  \"wcode_on_checking_1 ires rs (b, []) = False\" \n  \"wcode_on_checking_1 ires rs (b, Bk # list) = False\"", "lemma wcode_erase1_nonempty_snd[simp]: \"wcode_erase1 ires rs (b, []) = False\"", "lemma wcode_on_right_moving_1_nonempty_snd[simp]: \"wcode_on_right_moving_1 ires rs (b, []) = False\"", "lemma wcode_on_right_moving_1_BkE[elim]:\n  \"\\<lbrakk>wcode_on_right_moving_1 ires rs (b, Bk # ba);  Bk # b = aa \\<and> list = b\\<rbrakk> \\<Longrightarrow> \n  wcode_on_right_moving_1 ires rs (aa, ba)\"", "lemma wcode_on_right_moving_1_OcE[elim]: \n  \"\\<lbrakk>wcode_on_right_moving_1 ires rs (b, Oc # ba); Oc # b = aa \\<and> list = ba\\<rbrakk> \n  \\<Longrightarrow> wcode_goon_right_moving_1 ires rs (aa, ba)\"", "lemma wcode_erase1_BkE[elim]:\n  assumes \"wcode_erase1 ires rs (b, Bk # ba)\" \"Bk # b = aa \\<and> list = ba\" \"c = Bk # ba\"\n  shows \"wcode_on_right_moving_1 ires rs (aa, ba)\"", "lemma wcode_erase1_OcE[elim]: \"\\<lbrakk>wcode_erase1 ires rs (aa, Oc # list);  b = aa \\<and> Bk # list = ba\\<rbrakk> \\<Longrightarrow> \n  wcode_erase1 ires rs (aa, ba)\"", "lemma wcode_goon_right_moving_1_emptyE[elim]:\n  assumes \"wcode_goon_right_moving_1 ires rs (aa, [])\" \"b = aa \\<and> [Oc] = ba\"\n  shows \"wcode_backto_standard_pos ires rs (aa, ba)\"", "lemma wcode_goon_right_moving_1_BkE[elim]: \n  assumes \"wcode_goon_right_moving_1 ires rs (aa, Bk # list)\" \"b = aa \\<and> Oc # list = ba\"\n  shows \"wcode_backto_standard_pos ires rs (aa, ba)\"", "lemma wcode_goon_right_moving_1_OcE[elim]: \n  assumes \"wcode_goon_right_moving_1 ires rs (b, Oc # ba)\" \"Oc # b = aa \\<and> list = ba\"\n  shows \"wcode_goon_right_moving_1 ires rs (aa, ba)\"", "lemma wcode_backto_standard_pos_BkE[elim]: \"\\<lbrakk>wcode_backto_standard_pos ires rs (b, Bk # ba); Bk # b = aa \\<and> list = ba\\<rbrakk> \n  \\<Longrightarrow> wcode_before_double ires rs (aa, ba)\"", "lemma wcode_backto_standard_pos_no_Oc[simp]: \"wcode_backto_standard_pos ires rs ([], Oc # list) = False\"", "lemma wcode_backto_standard_pos_nonempty_snd[simp]: \"wcode_backto_standard_pos ires rs (b, []) = False\"", "lemma wcode_backto_standard_pos_OcE[elim]: \"\\<lbrakk>wcode_backto_standard_pos ires rs (b, Oc # list); tl b = aa; hd b # Oc # list =  ba\\<rbrakk>\n       \\<Longrightarrow> wcode_backto_standard_pos ires rs (aa, ba)\"", "lemma wcode_double_case_first_correctness:\n  \"let P = (\\<lambda> (st, l, r). st = 13) in \n       let Q = (\\<lambda> (st, l, r). wcode_double_case_inv st ires rs (l, r)) in \n       let f = (\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp) in\n       \\<exists> n .P (f n) \\<and> Q (f (n::nat))\"", "lemma tm_append_shift_append_steps: \n  \"\\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); \n  0 < st';\n  length tp1 mod 2 = 0\n  \\<rbrakk>\n  \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2) @ tp2) stp \n  = (st' + length tp1 div 2, l', r')\"", "lemma twice_lemma: \"rec_exec rec_twice [rs] = 2*rs\"", "lemma t_twice_correct: \n  \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n  (tm_of abc_twice @ shift (mopup (Suc 0)) ((length (tm_of abc_twice) div 2))) stp =\n  (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\"", "lemma adjust_fetch0: \n  \"\\<lbrakk>0 < a; a \\<le> length ap div 2;  fetch ap a b = (aa, 0)\\<rbrakk>\n  \\<Longrightarrow> fetch (adjust0 ap) a b = (aa, Suc (length ap div 2))\"", "lemma adjust_fetch_norm: \n  \"\\<lbrakk>st > 0;  st \\<le> length tp div 2; fetch ap st b = (aa, ns); ns \\<noteq> 0\\<rbrakk>\n \\<Longrightarrow>  fetch (adjust0 ap) st b = (aa, ns)\"", "lemma adjust_step_eq: \n  assumes exec: \"step0 (st,l,r) ap = (st', l', r')\"\n    and wf_tm: \"tm_wf (ap, 0)\"\n    and notfinal: \"st' > 0\"\n  shows \"step0 (st, l, r) (adjust0 ap) = (st', l', r')\"", "lemma adjust_steps_eq: \n  assumes exec: \"steps0 (st,l,r) ap stp = (st', l', r')\"\n    and wf_tm: \"tm_wf (ap, 0)\"\n    and notfinal: \"st' > 0\"\n  shows \"steps0 (st, l, r) (adjust0 ap) stp = (st', l', r')\"", "lemma adjust_halt_eq:\n  assumes exec: \"steps0 (1, l, r) ap stp = (0, l', r')\"\n    and tm_wf: \"tm_wf (ap, 0)\" \n  shows \"\\<exists> stp. steps0 (Suc 0, l, r) (adjust0 ap) stp = \n        (Suc (length ap div 2), l', r')\"", "lemma tm_wf_t_twice_compile [simp]: \"tm_wf (t_twice_compile, 0)\"", "lemma t_twice_change_term_state:\n  \"\\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_twice stp\n     = (Suc t_twice_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\"", "lemma length_t_wcode_main_first_part_even[intro]: \"length t_wcode_main_first_part mod 2 = 0\"", "lemma t_twice_append_pre:\n  \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_twice stp\n  = (Suc t_twice_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\n   \\<Longrightarrow> steps0 (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n     (t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n      ([(L, 1), (L, 1)] @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])) stp \n    = (Suc (t_twice_len) + length t_wcode_main_first_part div 2, \n             Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\"", "lemma t_twice_append:\n  \"\\<exists> stp ln rn. steps0 (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n     (t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n      ([(L, 1), (L, 1)] @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])) stp \n    = (Suc (t_twice_len) + length t_wcode_main_first_part div 2, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\"", "lemma mopup_mod2: \"length (mopup k) mod 2  = 0\"", "lemma fetch_t_wcode_main_Oc[simp]: \"fetch t_wcode_main (Suc (t_twice_len + length t_wcode_main_first_part div 2)) Oc\n     = (L, Suc 0)\"", "lemma wcode_jump1: \n  \"\\<exists> stp ln rn. steps0 (Suc (t_twice_len) + length t_wcode_main_first_part div 2,\n                       Bk\\<up>(m) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(n))\n     t_wcode_main stp \n    = (Suc 0, Bk\\<up>(ln) @ Bk # ires, Bk # Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\"", "lemma wcode_main_first_part_len[simp]:\n  \"length t_wcode_main_first_part = 24\"", "lemma wcode_double_case: \n  shows \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n          (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (2 * rs + 2)) @ Bk\\<up>(rn))\"\n    (is \"\\<exists>stp ln rn. ?tm stp ln rn\")", "lemmas wcode_fourtimes_invs = \n  wcode_on_left_moving_2_B.simps wcode_on_left_moving_2.simps\n  wcode_on_left_moving_2_O.simps wcode_on_checking_2.simps\n  wcode_goon_checking.simps wcode_right_move.simps\n  wcode_erase2.simps\n  wcode_on_right_moving_2.simps wcode_goon_right_moving_2.simps\n  wcode_backto_standard_pos_2_B.simps wcode_backto_standard_pos_2_O.simps\n  wcode_backto_standard_pos_2.simps", "lemma wf_wcode_fourtimes_case_le[intro]: \"wf wcode_fourtimes_case_le\"", "lemma nonempty_snd [simp]:\n  \"wcode_on_left_moving_2 ires rs (b, []) = False\"\n  \"wcode_on_checking_2 ires rs (b, []) = False\"\n  \"wcode_goon_checking ires rs (b, []) = False\"\n  \"wcode_right_move ires rs (b, []) = False\"\n  \"wcode_erase2 ires rs (b, []) = False\"\n  \"wcode_on_right_moving_2 ires rs (b, []) = False\"\n  \"wcode_backto_standard_pos_2 ires rs (b, []) = False\"\n  \"wcode_on_checking_2 ires rs (b, Oc # list) = False\"", "lemma wcode_on_left_moving_2[simp]:\n  \"wcode_on_left_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>  wcode_on_left_moving_2 ires rs (tl b, hd b # Bk # list)\"", "lemma wcode_goon_checking_via_2 [simp]: \"wcode_on_checking_2 ires rs (b, Bk # list)\n       \\<Longrightarrow>   wcode_goon_checking ires rs (tl b, hd b # Bk # list)\"", "lemma wcode_erase2_via_move [simp]: \"wcode_right_move ires rs (b, Bk # list) \\<Longrightarrow>  wcode_erase2 ires rs (Bk # b, list)\"", "lemma wcode_on_right_moving_2_via_erase2[simp]:\n  \"wcode_erase2 ires rs (b, Bk # list) \\<Longrightarrow> wcode_on_right_moving_2 ires rs (Bk # b, list)\"", "lemma wcode_on_right_moving_2_move_Bk[simp]: \"wcode_on_right_moving_2 ires rs (b, Bk # list)\n       \\<Longrightarrow> wcode_on_right_moving_2 ires rs (Bk # b, list)\"", "lemma wcode_backto_standard_pos_2_via_right[simp]:\n  \"wcode_goon_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> \n                 wcode_backto_standard_pos_2 ires rs (b, Oc # list)\"", "lemma wcode_on_checking_2_via_left[simp]: \"wcode_on_left_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> \n                     wcode_on_checking_2 ires rs (tl b, hd b # Oc # list)\"", "lemma wcode_backto_standard_pos_2_empty_via_right[simp]:\n  \"wcode_goon_right_moving_2 ires rs (b, []) \\<Longrightarrow>\n              wcode_backto_standard_pos_2 ires rs (b, [Oc])\"", "lemma wcode_goon_checking_cases[simp]: \"wcode_goon_checking ires rs (b, Oc # list) \\<Longrightarrow>\n  (b = [] \\<longrightarrow> wcode_right_move ires rs ([Oc], list)) \\<and>\n  (b \\<noteq> [] \\<longrightarrow> wcode_right_move ires rs (Oc # b, list))\"", "lemma wcode_right_move_no_Oc[simp]: \"wcode_right_move ires rs (b, Oc # list) = False\"", "lemma wcode_erase2_Bk_via_Oc[simp]: \"wcode_erase2 ires rs (b, Oc # list)\n       \\<Longrightarrow> wcode_erase2 ires rs (b, Bk # list)\"", "lemma wcode_goon_right_moving_2_Oc_move[simp]:\n  \"wcode_on_right_moving_2 ires rs (b, Oc # list)\n       \\<Longrightarrow> wcode_goon_right_moving_2 ires rs (Oc # b, list)\"", "lemma wcode_backto_standard_pos_2_exists[simp]: \"wcode_backto_standard_pos_2 ires rs (b, Bk # list)\n       \\<Longrightarrow> (\\<exists>ln. b = Bk # Bk\\<up>(ln) @ Oc # ires) \\<and> (\\<exists>rn. list = Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\"", "lemma wcode_goon_right_moving_2_move_Oc[simp]: \"wcode_goon_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n       wcode_goon_right_moving_2 ires rs (Oc # b, list)\"", "lemma wcode_backto_standard_pos_2_Oc_mv_hd[simp]:\n  \"wcode_backto_standard_pos_2 ires rs (b, Oc # list)    \n            \\<Longrightarrow> wcode_backto_standard_pos_2 ires rs (tl b, hd b # Oc # list)\"", "lemma nonempty_fst[simp]:\n  \"wcode_on_left_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_checking_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_checking ires rs (b, Bk # list) = False\"\n  \"wcode_right_move ires rs (b, Bk # list) \\<Longrightarrow> b\\<noteq> []\" \n  \"wcode_erase2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_backto_standard_pos_2 ires rs (b, Bk # list) \\<Longrightarrow>  b \\<noteq> []\"\n  \"wcode_on_left_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_right_moving_2 ires rs (b, []) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_erase2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_backto_standard_pos_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wcode_fourtimes_case_first_correctness:\n  shows \"let P = (\\<lambda> (st, l, r). st = t_twice_len + 14) in \n  let Q = (\\<lambda> (st, l, r). wcode_fourtimes_case_inv st ires rs (l, r)) in \n  let f = (\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp) in\n  \\<exists> n .P (f n) \\<and> Q (f (n::nat))\"", "lemma primerec_rec_fourtimes_1[intro]: \"primerec rec_fourtimes (Suc 0)\"", "lemma fourtimes_lemma: \"rec_exec rec_fourtimes [rs] = 4 * rs\"", "lemma t_fourtimes_correct: \n  \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n    (tm_of abc_fourtimes @ shift (mopup 1) (length (tm_of abc_fourtimes) div 2)) stp =\n       (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\"", "lemma wf_fourtimes[intro]: \"tm_wf (t_fourtimes_compile, 0)\"", "lemma t_fourtimes_change_term_state:\n  \"\\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_fourtimes stp\n     = (Suc t_fourtimes_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\"", "lemma length_t_twice_even[intro]: \"is_even (length t_twice)\"", "lemma t_fourtimes_append_pre:\n  \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_fourtimes stp\n  = (Suc t_fourtimes_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\n   \\<Longrightarrow> steps0 (Suc 0 + length (t_wcode_main_first_part @ \n              shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2,\n       Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n     ((t_wcode_main_first_part @ \n  shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) @ \n  shift t_fourtimes (length (t_wcode_main_first_part @ \n  shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2) @ ([(L, 1), (L, 1)])) stp \n  = ((Suc t_fourtimes_len) + length (t_wcode_main_first_part @ \n  shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2,\n  Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\"", "lemma split_26_even[simp]: \"(26 + l::nat) div 2 = l div 2 + 13\"", "lemma t_twice_len_plust_14[simp]: \"t_twice_len + 14 =  14 + length (shift t_twice 12) div 2\"", "lemma t_fourtimes_append:\n  \"\\<exists> stp ln rn. \n  steps0 (Suc 0 + length (t_wcode_main_first_part @ shift t_twice\n  (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2, \n  Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n  ((t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n  [(L, 1), (L, 1)]) @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)]) stp \n  = (Suc t_fourtimes_len + length (t_wcode_main_first_part @ shift t_twice\n  (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2, Bk\\<up>(ln) @ Bk # Bk # ires,\n                                                                 Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\"", "lemma even_fourtimes_len: \"length t_fourtimes mod 2 = 0\"", "lemma t_twice_even[simp]: \"2 * (length t_twice div 2) = length t_twice\"", "lemma t_fourtimes_even[simp]: \"2 * (length t_fourtimes div 2) = length t_fourtimes\"", "lemma fetch_t_wcode_14_Oc: \"fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Oc\n             = (L, Suc 0)\"", "lemma fetch_t_wcode_14_Bk: \"fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Bk\n             = (L, Suc 0)\"", "lemma fetch_t_wcode_14 [simp]: \"fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) b\n             = (L, Suc 0)\"", "lemma wcode_jump2: \n  \"\\<exists> stp ln rn. steps0 (t_twice_len + 14 + t_fourtimes_len\n  , Bk # Bk # Bk\\<up>(lnb) @ Oc # ires, Oc\\<up>(Suc (4 * rs + 4)) @ Bk\\<up>(rnb)) t_wcode_main stp =\n  (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (4 * rs + 4)) @ Bk\\<up>(rn))\"", "lemma wcode_fourtimes_case:\n  shows \"\\<exists>stp ln rn.\n  steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n  (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rn))\"", "lemma wf_wcode_halt_case_le[intro]: \"wf wcode_halt_case_le\"", "lemmas wcode_halt_invs = \n  wcode_on_left_moving_3_B.simps wcode_on_left_moving_3_O.simps\n  wcode_on_checking_3.simps wcode_goon_checking_3.simps \n  wcode_on_left_moving_3.simps wcode_stop.simps", "lemma wcode_on_left_moving_3_mv_Bk[simp]: \"wcode_on_left_moving_3 ires rs (b, Bk # list)\n \\<Longrightarrow> wcode_on_left_moving_3 ires rs (tl b, hd b # Bk # list)\"", "lemma wcode_goon_checking_3_cases[simp]: \"wcode_goon_checking_3 ires rs (b, Bk # list) \\<Longrightarrow> \n  (b = [] \\<longrightarrow> wcode_stop ires rs ([Bk], list)) \\<and>\n  (b \\<noteq> [] \\<longrightarrow> wcode_stop ires rs (Bk # b, list))\"", "lemma wcode_on_checking_3_mv_Oc[simp]: \"wcode_on_left_moving_3 ires rs (b, Oc # list) \\<Longrightarrow> \n               wcode_on_checking_3 ires rs (tl b, hd b # Oc # list)\"", "lemma wcode_3_nonempty[simp]:\n  \"wcode_on_left_moving_3 ires rs (b, []) = False\"\n  \"wcode_on_checking_3 ires rs (b, []) = False\"\n  \"wcode_goon_checking_3 ires rs (b, []) = False\"\n  \"wcode_on_left_moving_3 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_checking_3 ires rs (b, Oc # list) = False\"\n  \"wcode_on_left_moving_3 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_checking_3 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_checking_3 ires rs (b, Oc # list) = False\"", "lemma wcode_goon_checking_3_mv_Bk[simp]: \"wcode_on_checking_3 ires rs (b, Bk # list) \\<Longrightarrow> \n  wcode_goon_checking_3 ires rs (tl b, hd b # Bk # list)\"", "lemma t_halt_case_correctness: \n  shows \"let P = (\\<lambda> (st, l, r). st = 0) in \n       let Q = (\\<lambda> (st, l, r). wcode_halt_case_inv st ires rs (l, r)) in \n       let f = (\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp) in\n       \\<exists> n .P (f n) \\<and> Q (f (n::nat))\"", "lemma leading_Oc[intro]: \"\\<exists> xs. (<rev list @ [aa::nat]> :: cell list) = Oc # xs\"", "lemma wcode_halt_case:\n  \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n  t_wcode_main stp  = (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\"", "lemma bl_bin_one[simp]: \"bl_bin [Oc] = 1\"", "lemma twice_power[intro]: \"2 * 2 ^ a = Suc (Suc (2 * bl_bin (Oc \\<up> a)))\"", "lemma t_wcode_main_lemma_pre:\n  \"\\<lbrakk>args \\<noteq> []; lm = <args::nat list>\\<rbrakk> \\<Longrightarrow> \n       \\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev lm @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main\n                    stp\n      = (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin lm + rs * 2^(length lm - 1) ) @ Bk\\<up>(rn))\"", "lemma wf_wcode_prepare_le[intro]: \"wf wcode_prepare_le\"", "lemmas wprepare_invs = wprepare_add_one.simps wprepare_goto_first_end.simps\n  wprepare_erase.simps wprepare_goto_start_pos.simps\n  wprepare_loop_start.simps wprepare_loop_goon.simps\n  wprepare_add_one2.simps", "lemma fetch_t_wcode_prepare[simp]:\n  \"fetch t_wcode_prepare (Suc 0) Bk = (W1, 2)\"\n  \"fetch t_wcode_prepare (Suc 0) Oc = (L, 1)\"\n  \"fetch t_wcode_prepare (Suc (Suc 0)) Bk = (L, 3)\"\n  \"fetch t_wcode_prepare (Suc (Suc 0)) Oc = (R, 2)\"\n  \"fetch t_wcode_prepare (Suc (Suc (Suc 0))) Bk = (R, 4)\"\n  \"fetch t_wcode_prepare (Suc (Suc (Suc 0))) Oc = (W0, 3)\"\n  \"fetch t_wcode_prepare 4 Bk = (R, 4)\"\n  \"fetch t_wcode_prepare 4 Oc = (R, 5)\"\n  \"fetch t_wcode_prepare 5 Oc = (R, 5)\"\n  \"fetch t_wcode_prepare 5 Bk = (R, 6)\"\n  \"fetch t_wcode_prepare 6 Oc = (R, 5)\"\n  \"fetch t_wcode_prepare 6 Bk = (R, 7)\"\n  \"fetch t_wcode_prepare 7 Oc = (L, 0)\"\n  \"fetch t_wcode_prepare 7 Bk = (W1, 7)\"", "lemma wprepare_add_one_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_add_one m lm (b, []) = False\"", "lemma wprepare_goto_first_end_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_goto_first_end m lm (b, []) = False\"", "lemma wprepare_erase_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_erase m lm (b, []) = False\"", "lemma wprepare_goto_start_pos_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_goto_start_pos m lm (b, []) = False\"", "lemma wprepare_loop_start_empty_nonempty_fst[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [])\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\"", "lemma rev_eq: \"rev xs = rev ys \\<Longrightarrow> xs = ys\"", "lemma wprepare_loop_goon_Bk_empty_snd[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [])\\<rbrakk> \\<Longrightarrow> \n                                  wprepare_loop_goon m lm (Bk # b, [])\"", "lemma wprepare_loop_goon_nonempty_fst[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, [])\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_add_one2_Bk_empty[simp]:\"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, [])\\<rbrakk> \\<Longrightarrow> \n  wprepare_add_one2 m lm (Bk # b, [])\"", "lemma wprepare_add_one2_nonempty_fst[simp]: \"wprepare_add_one2 m lm (b, []) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_add_one2_Oc[simp]: \"wprepare_add_one2 m lm (b, []) \\<Longrightarrow> wprepare_add_one2 m lm (b, [Oc])\"", "lemma Bk_not_tape_start[simp]: \"(Bk # list = <(m::nat) # lm> @ ys) = False\"", "lemma wprepare_goto_first_end_cases[simp]:\n  \"\\<lbrakk>lm \\<noteq> []; wprepare_add_one m lm (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> (b = [] \\<longrightarrow> wprepare_goto_first_end m lm ([], Oc # list)) \\<and> \n           (b \\<noteq> [] \\<longrightarrow> wprepare_goto_first_end m lm (b, Oc # list))\"", "lemma wprepare_goto_first_end_Bk_nonempty_fst[simp]:\n  \"wprepare_goto_first_end m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_erase_elem_Bk_rest[simp]: \"wprepare_goto_first_end m lm (b, Bk # list) \\<Longrightarrow>\n                          wprepare_erase m lm (tl b, hd b # Bk # list)\"", "lemma wprepare_erase_Bk_nonempty_fst[simp]: \"wprepare_erase m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_goto_start_pos_Bk[simp]: \"wprepare_erase m lm (b, Bk # list) \\<Longrightarrow> \n                           wprepare_goto_start_pos m lm (Bk # b, list)\"", "lemma wprepare_add_one_Bk_nonempty_snd[simp]: \"\\<lbrakk>wprepare_add_one m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\"", "lemma wprepare_goto_first_end_nonempty_snd_tl[simp]:\n  \"\\<lbrakk>lm \\<noteq> [];  wprepare_goto_first_end m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\"", "lemma wprepare_erase_Bk_nonempty_list[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_erase m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\"", "lemma wprepare_goto_start_pos_Bk_nonempty[simp]: \"\\<lbrakk>lm \\<noteq> [];  wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\"", "lemma wprepare_goto_start_pos_Bk_nonempty_fst[simp]: \"\\<lbrakk>lm \\<noteq> [];  wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_loop_goon_Bk_nonempty[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_loop_goon_wprepare_add_one2_cases[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> \n  (list = [] \\<longrightarrow> wprepare_add_one2 m lm (Bk # b, [])) \\<and> \n  (list \\<noteq> [] \\<longrightarrow> wprepare_add_one2 m lm (Bk # b, list))\"", "lemma wprepare_add_one2_nonempty[simp]: \"wprepare_add_one2 m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_add_one2_cases[simp]: \"wprepare_add_one2 m lm (b, Bk # list) \\<Longrightarrow> \n      (list = [] \\<longrightarrow> wprepare_add_one2 m lm (b, [Oc])) \\<and> \n      (list \\<noteq> [] \\<longrightarrow> wprepare_add_one2 m lm (b, Oc # list))\"", "lemma wprepare_goto_first_end_cases_Oc[simp]: \"wprepare_goto_first_end m lm (b, Oc # list)\n       \\<Longrightarrow> (b = [] \\<longrightarrow> wprepare_goto_first_end m lm ([Oc], list)) \\<and> \n           (b \\<noteq> [] \\<longrightarrow> wprepare_goto_first_end m lm (Oc # b, list))\"", "lemma wprepare_erase_nonempty[simp]: \"wprepare_erase m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_erase_Bk[simp]: \"wprepare_erase m lm (b, Oc # list)\n  \\<Longrightarrow> wprepare_erase m lm (b, Bk # list)\"", "lemma wprepare_goto_start_pos_Bk_move[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> wprepare_goto_start_pos m lm (Bk # b, list)\"", "lemma wprepare_loop_start_b_nonempty[simp]: \"wprepare_loop_start m lm (b, aa) \\<Longrightarrow> b \\<noteq> []\"", "lemma exists_exp_of_Bk[elim]: \"Bk # list = Oc\\<up>(mr) @ Bk\\<up>(rn)  \\<Longrightarrow> \\<exists>rn. list = Bk\\<up>(rn)\"", "lemma wprepare_loop_start_in_middle_Bk_False[simp]: \"wprepare_loop_start_in_middle m lm (b, [Bk]) = False\"", "lemma wprepare_loop_goon_in_middle_Bk_False[simp]: \"wprepare_loop_goon_in_middle m lm (Bk # b, []) = False\"", "lemma wprepare_loop_goon_Bk[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [Bk])\\<rbrakk> \\<Longrightarrow>\n  wprepare_loop_goon m lm (Bk # b, [])\"", "lemma wprepare_loop_goon_in_middle_Bk_False2[simp]: \"wprepare_loop_start_on_rightmost m lm (b, Bk # a # lista)\n \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, a # lista) = False\"", "lemma wprepare_loop_goon_on_rightbmost_Bk_False[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start_on_rightmost m lm (b, Bk # a # lista)\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista)\"", "lemma wprepare_loop_goon_in_middle_Bk_False3[simp]: \n  assumes \"lm \\<noteq> []\" \"wprepare_loop_start_in_middle m lm (b, Bk # a # lista)\"\n  shows \"wprepare_loop_goon_in_middle m lm (Bk # b, a # lista)\" (is \"?t1\")\n    and \"wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False\" (is ?t2)", "lemma wprepare_loop_goon_Bk2[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, Bk # a # lista)\\<rbrakk> \\<Longrightarrow> \n  wprepare_loop_goon m lm (Bk # b, a # lista)\"", "lemma start_2_goon:\n  \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow>\n   (list = [] \\<longrightarrow> wprepare_loop_goon m lm (Bk # b, [])) \\<and>\n  (list \\<noteq> [] \\<longrightarrow> wprepare_loop_goon m lm (Bk # b, list))\"", "lemma add_one_2_add_one: \"wprepare_add_one m lm (b, Oc # list)\n  \\<Longrightarrow> (hd b = Oc \\<longrightarrow> (b = [] \\<longrightarrow> wprepare_add_one m lm ([], Bk # Oc # list)) \\<and>\n                     (b \\<noteq> [] \\<longrightarrow> wprepare_add_one m lm (tl b, Oc # Oc # list))) \\<and>\n  (hd b \\<noteq> Oc \\<longrightarrow> (b = [] \\<longrightarrow> wprepare_add_one m lm ([], Bk # Oc # list)) \\<and>\n                 (b \\<noteq> [] \\<longrightarrow> wprepare_add_one m lm (tl b, hd b # Oc # list)))\"", "lemma wprepare_loop_start_on_rightmost_Oc[simp]: \"wprepare_loop_start_on_rightmost m lm (b, Oc # list) \\<Longrightarrow> \n  wprepare_loop_start_on_rightmost m lm (Oc # b, list)\"", "lemma wprepare_loop_start_in_middle_Oc[simp]:\n  assumes \"wprepare_loop_start_in_middle m lm (b, Oc # list)\"\n  shows \"wprepare_loop_start_in_middle m lm (Oc # b, list)\"", "lemma start_2_start: \"wprepare_loop_start m lm (b, Oc # list) \\<Longrightarrow> \n       wprepare_loop_start m lm (Oc # b, list)\"", "lemma wprepare_loop_goon_Oc_nonempty[simp]: \"wprepare_loop_goon m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_goto_start_pos_Oc_nonempty[simp]: \"wprepare_goto_start_pos m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma wprepare_loop_goon_on_rightmost_Oc_False[simp]: \"wprepare_loop_goon_on_rightmost m lm (b, Oc # list) = False\"", "lemma wprepare_loop1: \"\\<lbrakk>rev b @ Oc\\<up>(mr) =  Oc\\<up>(Suc m) @ Bk # Bk # <lm>; \n         b \\<noteq> []; 0 < mr; Oc # list = Oc\\<up>(mr) @ Bk\\<up>(rn)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start_on_rightmost m lm (Oc # b, list)\"", "lemma wprepare_loop2: \"\\<lbrakk>rev b @ Oc\\<up>(mr) @ Bk # <a # lista> = Oc\\<up>(Suc m) @ Bk # Bk # <lm>;\n                b \\<noteq> []; Oc # list = Oc\\<up>(mr) @ Bk # <(a::nat) # lista> @ Bk\\<up>(rn)\\<rbrakk>\n       \\<Longrightarrow>  wprepare_loop_start_in_middle m lm (Oc # b, list)\"", "lemma wprepare_loop_goon_in_middle_cases[simp]: \"wprepare_loop_goon_in_middle m lm (b, Oc # list) \\<Longrightarrow>\n                wprepare_loop_start_on_rightmost m lm (Oc # b, list) \\<or>\n                wprepare_loop_start_in_middle m lm (Oc # b, list)\"", "lemma wprepare_add_one_b[simp]: \"wprepare_add_one m lm (b, Oc # list)\n       \\<Longrightarrow> b = [] \\<longrightarrow> wprepare_add_one m lm ([], Bk # Oc # list)\"\n  \"wprepare_loop_goon m lm (b, Oc # list)\n  \\<Longrightarrow>  wprepare_loop_start m lm (Oc # b, list)\"", "lemma wprepare_loop_start_on_rightmost_Oc2[simp]: \"wprepare_goto_start_pos m [a] (b, Oc # list)\n              \\<Longrightarrow> wprepare_loop_start_on_rightmost m [a] (Oc # b, list) \"", "lemma wprepare_loop_start_in_middle_2_Oc[simp]:  \"wprepare_goto_start_pos m (a # aa # listaa) (b, Oc # list)\n       \\<Longrightarrow>wprepare_loop_start_in_middle m (a # aa # listaa) (Oc # b, list)\"", "lemma wprepare_loop_start_Oc2[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_goto_start_pos m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start m lm (Oc # b, list)\"", "lemma wprepare_add_one2_Oc_nonempty[simp]: \"wprepare_add_one2 m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"", "lemma add_one_2_stop:\n  \"wprepare_add_one2 m lm (b, Oc # list)      \n  \\<Longrightarrow>  wprepare_stop m lm (tl b, hd b # Oc # list)\"", "lemma wprepare_correctness:\n  assumes h: \"lm \\<noteq> []\"\n  shows \"let P = (\\<lambda> (st, l, r). st = 0) in \n  let Q = (\\<lambda> (st, l, r). wprepare_inv st m lm (l, r)) in \n  let f = (\\<lambda> stp. steps0 (Suc 0, [], (<m # lm>)) t_wcode_prepare stp) in\n    \\<exists> n .P (f n) \\<and> Q (f n)\"", "lemma tm_wf_t_wcode_prepare[intro]: \"tm_wf (t_wcode_prepare, 0)\"", "lemma is_28_even[intro]: \"(28 + (length t_twice_compile + length t_fourtimes_compile)) mod 2 = 0\"", "lemma b_le_28[elim]: \"(a, b) \\<in> set t_wcode_main_first_part \\<Longrightarrow>\n  b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div 2\"", "lemma tm_wf_change_termi:\n  assumes \"tm_wf (tp, 0)\"\n  shows \"list_all (\\<lambda>(acn, st). (st \\<le> Suc (length tp div 2))) (adjust0 tp)\"", "lemma tm_wf_shift:\n  assumes \"list_all (\\<lambda>(acn, st). (st \\<le> y)) tp\"\n  shows \"list_all (\\<lambda>(acn, st). (st \\<le> y + off)) (shift tp off)\"", "lemma length_mopup_1[simp]: \"length (mopup (Suc 0)) = 16\"", "lemma twice_plus_28_elim[elim]: \"(a, b) \\<in> set (shift (adjust0 t_twice_compile) 12) \\<Longrightarrow> \n  b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div 2\"", "lemma length_plus_28_elim2[elim]: \"(a, b) \\<in> set (shift (adjust0 t_fourtimes_compile) (t_twice_len + 13)) \n  \\<Longrightarrow> b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div 2\"", "lemma tm_wf_t_wcode_main[intro]: \"tm_wf (t_wcode_main, 0)\"", "lemma prepare_mainpart_lemma:\n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp ln rn. steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) stp\n              = (0,  Bk # Oc\\<up>(Suc m), Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin (<args>)) @ Bk\\<up>(rn))\"", "lemma tinres_fetch_congr[simp]:  \"tinres r r' \\<Longrightarrow> \n  fetch t ss (read r) = \n  fetch t ss (read r')\"", "lemma nonempty_hd_tinres[simp]: \"\\<lbrakk>tinres r r'; r \\<noteq> []; r' \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd r = hd r'\"", "lemma tinres_nonempty[simp]:\n  \"\\<lbrakk>tinres r []; r \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd r = Bk\"\n  \"\\<lbrakk>tinres [] r'; r' \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd r' = Bk\"\n  \"\\<lbrakk>tinres r [];  r \\<noteq> []\\<rbrakk> \\<Longrightarrow> tinres (tl r) []\"\n  \"tinres r r' \\<Longrightarrow> tinres (b # r) (b # r')\"", "lemma ex_move_tl[intro]: \"\\<exists>na. tl r = tl (r @ Bk\\<up>(n)) @ Bk\\<up>(na) \\<or> tl (r @ Bk\\<up>(n)) = tl r @ Bk\\<up>(na)\"", "lemma tinres_tails[simp]: \"tinres r r' \\<Longrightarrow> tinres (tl r) (tl r')\"", "lemma tinres_empty[simp]: \n  \"\\<lbrakk>tinres [] r'\\<rbrakk> \\<Longrightarrow> tinres [] (tl r')\"\n  \"tinres r [] \\<Longrightarrow> tinres (Bk # tl r) [Bk]\"\n  \"tinres r [] \\<Longrightarrow> tinres (Oc # tl r) [Oc]\"", "lemma tinres_step2:\n  assumes \"tinres r r'\" \"step0 (ss, l, r) t = (sa, la, ra)\" \"step0 (ss, l, r') t = (sb, lb, rb)\"\n  shows \"la = lb \\<and> tinres ra rb \\<and> sa = sb\"", "lemma tinres_steps2: \n  \"\\<lbrakk>tinres r r'; steps0 (ss, l, r) t stp = (sa, la, ra); steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb\"", "lemma fetch_t_wcode_adjust[simp]:\n  \"fetch t_wcode_adjust (Suc 0) Bk = (W1, 1)\"\n  \"fetch t_wcode_adjust (Suc 0) Oc = (R, 2)\"\n  \"fetch t_wcode_adjust (Suc (Suc 0)) Oc = (R, 3)\"\n  \"fetch t_wcode_adjust (Suc (Suc (Suc 0))) Oc = (R, 4)\"\n  \"fetch t_wcode_adjust  (Suc (Suc (Suc 0))) Bk = (R, 3)\"\n  \"fetch t_wcode_adjust 4 Bk = (L, 8)\"\n  \"fetch t_wcode_adjust 4 Oc = (L, 5)\"\n  \"fetch t_wcode_adjust 5 Oc = (W0, 5)\"\n  \"fetch t_wcode_adjust 5 Bk = (L, 6)\"\n  \"fetch t_wcode_adjust 6 Oc = (R, 7)\"\n  \"fetch t_wcode_adjust 6 Bk = (L, 6)\"\n  \"fetch t_wcode_adjust 7 Bk = (W1, 2)\"\n  \"fetch t_wcode_adjust 8 Bk = (L, 9)\"\n  \"fetch t_wcode_adjust 8 Oc = (W0, 8)\"\n  \"fetch t_wcode_adjust 9 Oc = (L, 10)\"\n  \"fetch t_wcode_adjust 9 Bk = (L, 9)\"\n  \"fetch t_wcode_adjust 10 Bk = (L, 11)\"\n  \"fetch t_wcode_adjust 10 Oc = (L, 10)\"\n  \"fetch t_wcode_adjust 11 Oc = (L, 11)\"\n  \"fetch t_wcode_adjust 11 Bk = (R, 0)\"", "lemma wf_lex_square[intro]: \"wf lex_square\"", "lemma wf_wadjust_le[intro]: \"wf wadjust_le\"", "lemma wadjust_start_snd_nonempty[simp]: \"wadjust_start m rs (c, []) = False\"", "lemma wadjust_loop_right_move_fst_nonempty[simp]: \"wadjust_loop_right_move m rs (c, []) \\<Longrightarrow> c \\<noteq> []\"", "lemma wadjust_loop_check_fst_nonempty[simp]: \"wadjust_loop_check m rs (c, []) \\<Longrightarrow> c \\<noteq> []\"", "lemma wadjust_loop_start_snd_nonempty[simp]: \"wadjust_loop_start m rs (c, []) = False\"", "lemma wadjust_erase2_singleton[simp]: \"wadjust_loop_check m rs (c, []) \\<Longrightarrow> wadjust_erase2 m rs (tl c, [hd c])\"", "lemma wadjust_loop_on_left_moving_snd_nonempty[simp]:\n  \"wadjust_loop_on_left_moving m rs (c, []) = False\"\n  \"wadjust_loop_right_move2 m rs (c, []) = False\"\n  \"wadjust_erase2 m rs ([], []) = False\"", "lemma wadjust_on_left_moving_B_Bk1[simp]: \"wadjust_on_left_moving_B m rs \n                 (Oc # Oc # Oc\\<up>(rs) @ Bk # Oc # Oc\\<up>(m), [Bk])\"", "lemma wadjust_on_left_moving_B_Bk2[simp]: \"wadjust_on_left_moving_B m rs \n                 (Bk\\<up>(n) @ Bk # Oc # Oc # Oc\\<up>(rs) @ Bk # Oc # Oc\\<up>(m), [Bk])\"", "lemma wadjust_on_left_moving_singleton[simp]: \"\\<lbrakk>wadjust_erase2 m rs (c, []); c \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n            wadjust_on_left_moving m rs (tl c, [hd c])\"", "lemma wadjust_erase2_cases[simp]: \"wadjust_erase2 m rs (c, [])\n    \\<Longrightarrow> (c = [] \\<longrightarrow> wadjust_on_left_moving m rs ([], [Bk])) \\<and> \n       (c \\<noteq> [] \\<longrightarrow> wadjust_on_left_moving m rs (tl c, [hd c]))\"", "lemma wadjust_on_left_moving_nonempty[simp]:\n  \"wadjust_on_left_moving m rs ([], []) = False\"\n  \"wadjust_on_left_moving_O m rs (c, []) = False\"", "lemma wadjust_on_left_moving_B_singleton_Bk[simp]:\n  \" \\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> []; hd c = Bk\\<rbrakk> \\<Longrightarrow>\n                                      wadjust_on_left_moving_B m rs (tl c, [Bk])\"", "lemma wadjust_on_left_moving_B_singleton_Oc[simp]:\n  \"\\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> []; hd c = Oc\\<rbrakk> \\<Longrightarrow>\n                                  wadjust_on_left_moving_O m rs (tl c, [Oc])\"", "lemma wadjust_on_left_moving_singleton2[simp]:\n  \"\\<lbrakk>wadjust_on_left_moving m rs (c, []); c \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  wadjust_on_left_moving m rs (tl c, [hd c])\"", "lemma wadjust_nonempty[simp]: \"wadjust_goon_left_moving m rs (c, []) = False\"\n  \"wadjust_backto_standard_pos m rs (c, []) = False\"", "lemma wadjust_loop_start_no_Bk[simp]: \"wadjust_loop_start m rs (c, Bk # list) = False\"", "lemma wadjust_loop_check_nonempty[simp]: \"wadjust_loop_check m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"", "lemma wadjust_erase2_via_loop_check_Bk[simp]: \"wadjust_loop_check m rs (c, Bk # list)\n              \\<Longrightarrow>  wadjust_erase2 m rs (tl c, hd c # Bk # list)\"", "lemma wadjust_loop_on_left_moving_B_via_erase[simp]: \"\\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_B m rs (tl c, Bk # Bk # list)\"", "lemma wadjust_loop_on_left_moving_O_Bk_via_erase[simp]:\n  \"\\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); c \\<noteq> []; hd c = Oc\\<rbrakk> \\<Longrightarrow>\n             wadjust_loop_on_left_moving_O m rs (tl c, Oc # Bk # list)\"", "lemma wadjust_loop_on_left_moving_Bk_via_erase[simp]: \"\\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); c \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n                wadjust_loop_on_left_moving m rs (tl c, hd c # Bk # list)\"", "lemma wadjust_loop_on_left_moving_B_Bk_move[simp]:\n  \"\\<lbrakk>wadjust_loop_on_left_moving_B m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow>  wadjust_loop_on_left_moving_B m rs (tl c, Bk # Bk # list)\"", "lemma wadjust_loop_on_left_moving_O_Oc_move[simp]:\n  \"\\<lbrakk>wadjust_loop_on_left_moving_B m rs (c, Bk # list); hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_O m rs (tl c, Oc # Bk # list)\"", "lemma wadjust_loop_erase_nonempty[simp]: \"wadjust_loop_erase m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_loop_on_left_moving m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_loop_right_move2 m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_erase2 m rs (c, Bk # list) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_on_left_moving m rs (c,b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_on_left_moving_O m rs (c, Bk # list) = False\"\n  \"wadjust_goon_left_moving m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_loop_on_left_moving_O m rs (c, Bk # list) = False\"", "lemma wadjust_loop_on_left_moving_Bk_move[simp]:\n  \"wadjust_loop_on_left_moving m rs (c, Bk # list)\n            \\<Longrightarrow> wadjust_loop_on_left_moving m rs (tl c, hd c # Bk # list)\"", "lemma wadjust_loop_start_Oc_via_Bk_move[simp]: \n  \"wadjust_loop_right_move2 m rs (c, Bk # list) \\<Longrightarrow>  wadjust_loop_start m rs (c, Oc # list)\"", "lemma wadjust_on_left_moving_Bk_via_erase[simp]: \"wadjust_erase2 m rs (c, Bk # list) \\<Longrightarrow> \n                 wadjust_on_left_moving m rs (tl c, hd c # Bk # list)\"", "lemma wadjust_on_left_moving_B_Bk_drop_one: \"\\<lbrakk>wadjust_on_left_moving_B m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_B m rs (tl c, Bk # Bk # list)\"", "lemma wadjust_on_left_moving_B_Bk_drop_Oc: \"\\<lbrakk>wadjust_on_left_moving_B m rs (c, Bk # list); hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_O m rs (tl c, Oc # Bk # list)\"", "lemma wadjust_on_left_moving_B_drop[simp]: \"wadjust_on_left_moving  m rs (c, Bk # list) \\<Longrightarrow>  \n                  wadjust_on_left_moving m rs (tl c, hd c # Bk # list)\"", "lemma wadjust_goon_left_moving_O_no_Bk[simp]: \"wadjust_goon_left_moving_O m rs (c, Bk # list) = False\"", "lemma wadjust_backto_standard_pos_via_left_Bk[simp]:\n  \"wadjust_goon_left_moving m rs (c, Bk # list) \\<Longrightarrow>\n  wadjust_backto_standard_pos m rs (tl c, hd c # Bk # list)\"", "lemma wadjust_loop_right_move_Oc[simp]:\n  \"wadjust_loop_start m rs (c, Oc # list) \\<Longrightarrow> wadjust_loop_right_move m rs (Oc # c, list)\"", "lemma wadjust_loop_check_Oc[simp]:\n  assumes \"wadjust_loop_right_move m rs (c, Oc # list)\" \n  shows \"wadjust_loop_check m rs (Oc # c, list)\"", "lemma wadjust_loop_erase_move_Oc[simp]: \"wadjust_loop_check m rs (c, Oc # list) \\<Longrightarrow> \n               wadjust_loop_erase m rs (tl c, hd c # Oc # list)\"", "lemma wadjust_loop_on_move_no_Oc[simp]:\n  \"wadjust_loop_on_left_moving_B m rs (c, Oc # list) = False\"\n  \"wadjust_loop_right_move2 m rs (c, Oc # list) = False\"\n  \"wadjust_loop_on_left_moving m rs (c, Oc # list)\n           \\<Longrightarrow> wadjust_loop_right_move2 m rs (Oc # c, list)\"\n  \"wadjust_on_left_moving_B m rs (c, Oc # list) = False\"\n  \"wadjust_loop_erase m rs (c, Oc # list) \\<Longrightarrow> \n                wadjust_loop_erase m rs (c, Bk # list)\"", "lemma wadjust_goon_left_moving_B_Bk_Oc: \"\\<lbrakk>wadjust_on_left_moving_O m rs (c, Oc # list); hd c = Bk\\<rbrakk> \\<Longrightarrow> \n         wadjust_goon_left_moving_B m rs (tl c, Bk # Oc # list)\"", "lemma wadjust_goon_left_moving_O_Oc_Oc: \"\\<lbrakk>wadjust_on_left_moving_O m rs (c, Oc # list); hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_goon_left_moving_O m rs (tl c, Oc # Oc # list)\"", "lemma wadjust_goon_left_moving_Oc[simp]: \"wadjust_on_left_moving m rs (c, Oc # list) \\<Longrightarrow> \n              wadjust_goon_left_moving m rs (tl c, hd c # Oc # list)\"", "lemma left_moving_Bk_Oc[simp]: \"\\<lbrakk>wadjust_goon_left_moving_O m rs (c, Oc # list); hd c = Bk\\<rbrakk> \n               \\<Longrightarrow> wadjust_goon_left_moving_B m rs (tl c, Bk # Oc # list)\"", "lemma  left_moving_Oc_Oc[simp]: \"\\<lbrakk>wadjust_goon_left_moving_O m rs (c, Oc # list); hd c = Oc\\<rbrakk> \\<Longrightarrow> \n  wadjust_goon_left_moving_O m rs (tl c, Oc # Oc # list)\"", "lemma wadjust_goon_left_moving_B_no_Oc[simp]:\n  \"wadjust_goon_left_moving_B m rs (c, Oc # list) = False\"", "lemma wadjust_goon_left_moving_Oc_move[simp]: \"wadjust_goon_left_moving m rs (c, Oc # list) \\<Longrightarrow> \n  wadjust_goon_left_moving m rs (tl c, hd c # Oc # list)\"", "lemma wadjust_backto_standard_pos_B_no_Oc[simp]:\n  \"wadjust_backto_standard_pos_B m rs (c, Oc # list) = False\"", "lemma wadjust_backto_standard_pos_O_no_Bk[simp]:\n  \"wadjust_backto_standard_pos_O m rs (c, Bk # xs) = False\"", "lemma wadjust_backto_standard_pos_B_Bk_Oc[simp]:\n  \"wadjust_backto_standard_pos_O m rs ([], Oc # list) \\<Longrightarrow> \n  wadjust_backto_standard_pos_B m rs ([], Bk # Oc # list)\"", "lemma wadjust_backto_standard_pos_B_Bk_Oc_via_O[simp]: \n  \"\\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list); c \\<noteq> []; hd c = Bk\\<rbrakk>\n  \\<Longrightarrow> wadjust_backto_standard_pos_B m rs (tl c, Bk # Oc # list)\"", "lemma wadjust_backto_standard_pos_B_Oc_Oc_via_O[simp]: \"\\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list); c \\<noteq> []; hd c = Oc\\<rbrakk>\n          \\<Longrightarrow>  wadjust_backto_standard_pos_O m rs (tl c, Oc # Oc # list)\"", "lemma wadjust_backto_standard_pos_cases[simp]: \"wadjust_backto_standard_pos m rs (c, Oc # list)\n  \\<Longrightarrow> (c = [] \\<longrightarrow> wadjust_backto_standard_pos m rs ([], Bk # Oc # list)) \\<and> \n (c \\<noteq> [] \\<longrightarrow> wadjust_backto_standard_pos m rs (tl c, hd c # Oc # list))\"", "lemma wadjust_loop_right_move_nonempty_snd[simp]: \"wadjust_loop_right_move m rs (c, []) = False\"", "lemma wadjust_loop_erase_nonempty_snd[simp]: \"wadjust_loop_erase m rs (c, []) = False\"", "lemma wadjust_loop_erase_cases2[simp]: \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_erase m rs (c, Bk # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\"", "lemma dropWhile_exp1: \"dropWhile (\\<lambda>a. a = Oc) (Oc\\<up>(n) @ xs) = dropWhile (\\<lambda>a. a = Oc) xs\"", "lemma takeWhile_exp1: \"takeWhile (\\<lambda>a. a = Oc) (Oc\\<up>(n) @ xs) = Oc\\<up>(n) @ takeWhile (\\<lambda>a. a = Oc) xs\"", "lemma wadjust_correctness_helper_1:\n  assumes \"Suc (Suc rs) = a\" \" wadjust_loop_right_move2 m rs (c, Bk # list)\"\n  shows \"a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n                 < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\"", "lemma wadjust_correctness_helper_2:\n  \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\"", "lemma wadjust_loop_check_empty_false[simp]: \"wadjust_loop_check m rs ([], b) = False\"", "lemma wadjust_loop_check_cases: \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_check m rs (c, Oc # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Oc # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Oc # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\"", "lemma wadjust_loop_erase_cases_or: \n  \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_erase m rs (c, Oc # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\"", "lemmas wadjust_correctness_helpers = wadjust_correctness_helper_2 wadjust_correctness_helper_1 wadjust_loop_erase_cases_or wadjust_loop_check_cases", "lemma wadjust_start_Oc[simp]: \"wadjust_start m rs (c, Bk # list)\n       \\<Longrightarrow> wadjust_start m rs (c, Oc # list)\"", "lemma wadjust_stop_Bk[simp]: \"wadjust_backto_standard_pos m rs (c, Bk # list)\n       \\<Longrightarrow> wadjust_stop m rs (Bk # c, list)\"", "lemma wadjust_loop_start_Oc[simp]:\n  assumes \"wadjust_start m rs (c, Oc # list)\"\n  shows \"wadjust_loop_start m rs (Oc # c, list)\"", "lemma erase2_Bk_if_Oc[simp]:\" wadjust_erase2 m rs (c, Oc # list)\n       \\<Longrightarrow> wadjust_erase2 m rs (c, Bk # list)\"", "lemma wadjust_loop_right_move_Bk[simp]: \"wadjust_loop_right_move m rs (c, Bk # list)\n    \\<Longrightarrow> wadjust_loop_right_move m rs (Bk # c, list)\"", "lemma wadjust_correctness:\n  shows \"let P = (\\<lambda> (len, st, l, r). st = 0) in \n  let Q = (\\<lambda> (len, st, l, r). wadjust_inv st m rs (l, r)) in \n  let f = (\\<lambda> stp. (Suc (Suc rs),  steps0 (Suc 0, Bk # Oc\\<up>(Suc m), \n                Bk # Oc # Bk\\<up>(ln) @ Bk #  Oc\\<up>(Suc rs) @ Bk\\<up>(rn)) t_wcode_adjust stp)) in\n    \\<exists> n .P (f n) \\<and> Q (f n)\"", "lemma tm_wf_t_wcode_adjust[intro]: \"tm_wf (t_wcode_adjust, 0)\"", "lemma bl_bin_nonzero[simp]: \"args \\<noteq> [] \\<Longrightarrow> bl_bin (<args::nat list>) > 0\"", "lemma wcode_lemma_pre':\n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp rn. steps0 (Suc 0, [], <m # args>) \n              ((t_wcode_prepare |+| t_wcode_main) |+| t_wcode_adjust) stp\n  = (0,  [Bk],  Oc\\<up>(Suc m) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn))\"", "lemma wcode_lemma_1:\n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp ln rn. steps0 (Suc 0, [], <m # args>)  (t_wcode) stp = \n              (0,  [Bk],  Oc\\<up>(Suc m) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn))\"", "lemma wcode_lemma: \n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp ln rn. steps0 (Suc 0, [], <m # args>)  (t_wcode) stp = \n              (0,  [Bk],  <[m ,bl_bin (<args>)]> @ Bk\\<up>(rn))\"", "lemma tinres_step1: \n  assumes \"tinres l l'\" \"step (ss, l, r) (t, 0) = (sa, la, ra)\" \n    \"step (ss, l', r) (t, 0) = (sb, lb, rb)\"\n  shows \"tinres la lb \\<and> ra = rb \\<and> sa = sb\"", "lemma tinres_steps1: \n  \"\\<lbrakk>tinres l l'; steps (ss, l, r) (t, 0) stp = (sa, la, ra); \n                 steps (ss, l', r) (t, 0) stp = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\"", "lemma tinres_some_exp[simp]: \n  \"tinres (Bk \\<up> m @ [Bk, Bk]) la \\<Longrightarrow> \\<exists>m. la = Bk \\<up> m\"", "lemma t_utm_halt_eq: \n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and exec: \"steps0 (Suc 0, Bk\\<up>(l), <lm::nat list>) tp stp = (0, Bk\\<up>(m), Oc\\<up>(rs)@Bk\\<up>(n))\"\n    and resutl: \"0 < rs\"\n  shows \"\\<exists>stp m n. steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>(i)) t_utm stp = \n                                                (0, Bk\\<up>(m), Oc\\<up>(rs) @ Bk\\<up>(n))\"", "lemma tm_wf_t_wcode[intro]: \"tm_wf (t_wcode, 0)\"", "lemma UTM_halt_lemma_pre: \n  assumes wf_tm: \"tm_wf (tp, 0)\"\n    and result: \"0 < rs\"\n    and args: \"args \\<noteq> []\"\n    and exec: \"steps0 (Suc 0, Bk\\<up>(i), <args::nat list>) tp stp = (0, Bk\\<up>(m), Oc\\<up>(rs)@Bk\\<up>(k))\"\n  shows \"\\<exists>stp m n. steps0 (Suc 0, [], <code tp # args>) UTM_pre stp = \n                                                (0, Bk\\<up>(m), Oc\\<up>(rs) @ Bk\\<up>(n))\"", "lemma UTM_halt_lemma': \n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and result: \"0 < rs\"\n    and args: \"args \\<noteq> []\"\n    and exec: \"steps0 (Suc 0, Bk\\<up>(i), <args::nat list>) tp stp = (0, Bk\\<up>(m), Oc\\<up>(rs)@Bk\\<up>(k))\"\n  shows \"\\<exists>stp m n. steps0 (Suc 0, [], <code tp # args>) UTM stp = \n                                                (0, Bk\\<up>(m), Oc\\<up>(rs) @ Bk\\<up>(n))\"", "lemma nstd_case1: \"0 < a \\<Longrightarrow> NSTD (trpl_code (a, b, c))\"", "lemma nonzero_bl2wc[simp]: \"\\<forall>m. b \\<noteq> Bk\\<up>(m) \\<Longrightarrow> 0 < bl2wc b\"", "lemma nstd_case2: \"\\<forall>m. b \\<noteq> Bk\\<up>(m) \\<Longrightarrow> NSTD (trpl_code (a, b, c))\"", "lemma even_not_odd[elim]: \"Suc (2 * x) = 2 * y \\<Longrightarrow> RR\"", "lemma bl2nat_zero_eq[simp]: \"(bl2nat c 0 = 0) = (\\<exists>n. c = Bk\\<up>(n))\"", "lemma bl2wc_exp_ex: \n  \"\\<lbrakk>Suc (bl2wc c) = 2 ^  m\\<rbrakk> \\<Longrightarrow> \\<exists> rs n. c = Oc\\<up>(rs) @ Bk\\<up>(n)\"", "lemma lg_bin: \n  assumes \"\\<forall>rs n. c \\<noteq> Oc\\<up>(Suc rs) @ Bk\\<up>(n)\" \n    \"bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0\"\n  shows \"bl2wc c = 0\"", "lemma nstd_case3: \n  \"\\<forall>rs n. c \\<noteq> Oc\\<up>(Suc rs) @ Bk\\<up>(n) \\<Longrightarrow>  NSTD (trpl_code (a, b, c))\"", "lemma NSTD_1: \"\\<not> TSTD (a, b, c)\n    \\<Longrightarrow> rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0\"", "lemma nonstop_t_uhalt_eq:\n  \"\\<lbrakk>tm_wf (tp, 0);\n  steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp = (a, b, c);\n  \\<not> TSTD (a, b, c)\\<rbrakk>\n  \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), stp] = Suc 0\"", "lemma nonstop_true:\n  \"\\<lbrakk>tm_wf (tp, 0);\n  \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>y. rec_exec rec_nonstop ([code tp, bl2wc (<lm>), y]) = (Suc 0)\"", "lemma cn_arity:  \"rec_ci (Cn n f gs) = (a, b, c) \\<Longrightarrow> b = n\"", "lemma mn_arity: \"rec_ci (Mn n f) = (a, b, c) \\<Longrightarrow> b = n\"", "lemma F_aprog_uhalt: \n  assumes wf_tm: \"tm_wf (tp,0)\"\n    and unhalt:  \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\"\n    and compile: \"rec_ci rec_F = (F_ap, rs_pos, a_md)\"\n  shows \"{\\<lambda> nl. nl = [code tp, bl2wc (<lm>)] @ 0\\<up>(a_md - rs_pos ) @ suflm} (F_ap) \\<up>\"", "lemma uabc_uhalt': \n  \"\\<lbrakk>tm_wf (tp, 0);\n  \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp));\n  rec_ci rec_F = (ap, pos, md)\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda> nl. nl = [code tp, bl2wc (<lm>)]} ap \\<up>\"", "lemma uabc_uhalt: \n  \"\\<lbrakk>tm_wf (tp, 0); \n  \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda> nl. nl = [code tp, bl2wc (<lm>)]} F_aprog \\<up> \"", "lemma tutm_uhalt': \n  assumes tm_wf:  \"tm_wf (tp,0)\"\n    and unhalt: \"\\<forall> stp. (\\<not> TSTD (steps0 (1, Bk\\<up>(l), <lm>) tp stp))\"\n  shows \"\\<forall> stp. \\<not> is_final (steps0 (1, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)\"", "lemma tinres_commute: \"tinres r r' \\<Longrightarrow> tinres r' r\"", "lemma inres_tape:\n  \"\\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c); steps0 (st, l', r') tp stp = (a', b', c'); \n  tinres l l'; tinres r r'\\<rbrakk>\n  \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'\"", "lemma tape_normalize:\n  assumes \"\\<forall> stp. \\<not> is_final(steps0 (Suc 0, [Bk,Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)\"\n  shows   \"\\<forall> stp. \\<not> is_final (steps0 (Suc 0, Bk\\<up>(m), <[code tp, bl2wc (<lm>)]> @ Bk\\<up>(n)) t_utm stp)\"\n    (is \"\\<forall> stp. ?P stp\")", "lemma tutm_uhalt: \n  \"\\<lbrakk>tm_wf (tp,0);\n    \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <args>) tp stp))\\<rbrakk>\n  \\<Longrightarrow> \\<forall> stp. \\<not> is_final (steps0 (Suc 0, Bk\\<up>(m), <[code tp, bl2wc (<args>)]> @ Bk\\<up>(n)) t_utm stp)\"", "lemma UTM_uhalt_lemma_pre:\n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and exec: \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <args>) tp stp))\"\n    and args: \"args \\<noteq> []\"\n  shows \"\\<forall> stp. \\<not> is_final (steps0 (Suc 0, [], <code tp # args>)  UTM_pre stp)\"", "lemma UTM_uhalt_lemma':\n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and unhalt: \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <args>) tp stp))\"\n    and args: \"args \\<noteq> []\"\n  shows \" \\<forall> stp. \\<not> is_final (steps0 (Suc 0, [], <code tp # args>)  UTM stp)\"", "lemma UTM_halt_lemma:\n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and resut: \"rs > 0\"\n    and args: \"(args::nat list) \\<noteq> []\"\n    and exec: \"{(\\<lambda>tp. tp = (Bk\\<up>i, <args>))} p {(\\<lambda>tp. tp = (Bk\\<up>m, Oc\\<up>rs @ Bk\\<up>k))}\" \n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM {(\\<lambda>tp. (\\<exists> m n. tp = (Bk\\<up>m, Oc\\<up>rs @ Bk\\<up>n)))}\"", "lemma UTM_halt_lemma2:\n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and args: \"(args::nat list) \\<noteq> []\"\n    and exec: \"{(\\<lambda>tp. tp = ([], <args>))} p {(\\<lambda>tp. tp = (Bk\\<up>m, <(n::nat)> @ Bk\\<up>k))}\" \n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM {(\\<lambda>tp. (\\<exists> m k. tp = (Bk\\<up>m, <n> @ Bk\\<up>k)))}\"", "lemma UTM_unhalt_lemma: \n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and unhalt: \"{(\\<lambda>tp. tp = (Bk\\<up>i, <args>))} p \\<up>\"\n    and args: \"args \\<noteq> []\"\n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM \\<up>\"", "lemma UTM_unhalt_lemma2: \n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and unhalt: \"{(\\<lambda>tp. tp = ([], <args>))} p \\<up>\"\n    and args: \"args \\<noteq> []\"\n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM \\<up>\""], "translations": [["", "lemma bin_wc_eq: \"bl_bin xs = bl2wc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin xs = bl2wc xs", "proof(induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. bl_bin [] = bl2wc []\n 2. \\<And>a xs.\n       bl_bin xs = bl2wc xs \\<Longrightarrow>\n       bl_bin (a # xs) = bl2wc (a # xs)", "show \" bl_bin [] = bl2wc []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin [] = bl2wc []", "apply(simp add: bl_bin.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bl_bin [] = bl2wc []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       bl_bin xs = bl2wc xs \\<Longrightarrow>\n       bl_bin (a # xs) = bl2wc (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       bl_bin xs = bl2wc xs \\<Longrightarrow>\n       bl_bin (a # xs) = bl2wc (a # xs)", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       bl_bin xs = bl2wc xs \\<Longrightarrow>\n       bl_bin (a # xs) = bl2wc (a # xs)", "assume \"bl_bin xs = bl2wc xs\""], ["proof (state)\nthis:\n  bl_bin xs = bl2wc xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       bl_bin xs = bl2wc xs \\<Longrightarrow>\n       bl_bin (a # xs) = bl2wc (a # xs)", "thus \" bl_bin (a # xs) = bl2wc (a # xs)\""], ["proof (prove)\nusing this:\n  bl_bin xs = bl2wc xs\n\ngoal (1 subgoal):\n 1. bl_bin (a # xs) = bl2wc (a # xs)", "apply(case_tac a, simp_all add: bl_bin.simps bl2wc.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = Bk; bl_bin xs = bl2nat xs 0\\<rbrakk>\n    \\<Longrightarrow> 2 * bl2nat xs 0 = bl2nat (Bk # xs) 0\n 2. \\<lbrakk>a = Oc; bl_bin xs = bl2nat xs 0\\<rbrakk>\n    \\<Longrightarrow> Suc (2 * bl2nat xs 0) = bl2nat (Oc # xs) 0", "apply(simp_all add: bl2nat.simps bl2nat_double)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bl_bin (a # xs) = bl2wc (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tape_of_nl_append_one: \"lm \\<noteq> [] \\<Longrightarrow>  <lm @ [a]> = <lm> @ Bk # Oc\\<up>Suc a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm \\<noteq> [] \\<Longrightarrow> <lm @ [a]> = <lm> @ Bk # Oc \\<up> Suc a", "apply(induct lm, auto simp: tape_of_nl_cons split:if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tape_of_nl_rev: \"rev (<lm::nat list>) = (<rev lm>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (<lm>) = <rev lm>", "apply(induct lm, simp, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lm.\n       rev (<lm>) = <rev lm> \\<Longrightarrow>\n       rev (<a # lm>) = <rev lm @ [a]>", "apply(auto simp: tape_of_nl_cons tape_of_nl_append_one split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lm.\n       rev (<lm>) = <rev lm> \\<Longrightarrow>\n       Oc \\<up> a @ [Oc] = Oc # Oc \\<up> a", "apply(simp add: exp_ind[THEN sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exp_1[simp]: \"a\\<up>(Suc 0) = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<up> Suc 0 = [a]", "by(simp)"], ["", "lemma tape_of_nl_cons_app1: \"(<a # xs @ [b]>) = (Oc\\<up>(Suc a) @ Bk # (<xs@ [b]>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a # xs @ [b]> = Oc \\<up> Suc a @ Bk # <xs @ [b]>", "apply(case_tac xs; simp add: tape_of_list_def tape_of_nat_list.simps tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_bin_bk_oc[simp]:\n  \"bl_bin (xs @ [Bk, Oc]) = \n  bl_bin xs + 2*2^(length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin (xs @ [Bk, Oc]) = bl_bin xs + 2 * 2 ^ length xs", "apply(simp add: bin_wc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc (xs @ [Bk, Oc]) = bl2wc xs + 2 * 2 ^ length xs", "using bl2nat_cons_oc[of \"xs @ [Bk]\"]"], ["proof (prove)\nusing this:\n  bl2nat ((xs @ [Bk]) @ [Oc]) 0 =\n  bl2nat (xs @ [Bk]) 0 + 2 ^ length (xs @ [Bk])\n\ngoal (1 subgoal):\n 1. bl2wc (xs @ [Bk, Oc]) = bl2wc xs + 2 * 2 ^ length xs", "apply(simp add: bl2nat_cons_bk bl2wc.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tape_of_nat[simp]: \"(<a::nat>) = Oc\\<up>(Suc a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a> = Oc \\<up> Suc a", "apply(simp add: tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tape_of_nl_cons_app2: \"(<c # xs @ [b]>) = (<c # xs> @ Bk # Oc\\<up>(Suc b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "proof(induct \"length xs\" arbitrary: xs c, simp add: tape_of_list_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs c.\n       \\<lbrakk>\\<And>xs c.\n                   x = length xs \\<Longrightarrow>\n                   <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b;\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "fix x xs c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs c.\n       \\<lbrakk>\\<And>xs c.\n                   x = length xs \\<Longrightarrow>\n                   <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b;\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "assume ind: \"\\<And>xs c. x = length xs \\<Longrightarrow> <c # xs @ [b]> = \n    <c # xs> @ Bk # Oc\\<up>(Suc b)\"\n    and h: \"Suc x = length (xs::nat list)\""], ["proof (state)\nthis:\n  x = length ?xs \\<Longrightarrow>\n  <?c # ?xs @ [b]> = <?c # ?xs> @ Bk # Oc \\<up> Suc b\n  Suc x = length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs c.\n       \\<lbrakk>\\<And>xs c.\n                   x = length xs \\<Longrightarrow>\n                   <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b;\n        Suc x = length xs\\<rbrakk>\n       \\<Longrightarrow> <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "show \"<c # xs @ [b]> = <c # xs> @ Bk # Oc\\<up>(Suc b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "proof(cases xs, simp add: tape_of_list_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "fix a list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "assume g: \"xs = a # list\""], ["proof (state)\nthis:\n  xs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "hence k: \"<a # list @ [b]> =  <a # list> @ Bk # Oc\\<up>(Suc b)\""], ["proof (prove)\nusing this:\n  xs = a # list\n\ngoal (1 subgoal):\n 1. <a # list @ [b]> = <a # list> @ Bk # Oc \\<up> Suc b", "apply(rule_tac ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = a # list \\<Longrightarrow> x = length list", "using h"], ["proof (prove)\nusing this:\n  Suc x = length xs\n\ngoal (1 subgoal):\n 1. xs = a # list \\<Longrightarrow> x = length list", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <a # list @ [b]> = <a # list> @ Bk # Oc \\<up> Suc b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "from g and k"], ["proof (chain)\npicking this:\n  xs = a # list\n  <a # list @ [b]> = <a # list> @ Bk # Oc \\<up> Suc b", "show \"<c # xs @ [b]> = <c # xs> @ Bk # Oc\\<up>(Suc b)\""], ["proof (prove)\nusing this:\n  xs = a # list\n  <a # list @ [b]> = <a # list> @ Bk # Oc \\<up> Suc b\n\ngoal (1 subgoal):\n 1. <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b", "apply(simp add: tape_of_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <c # xs @ [b]> = <c # xs> @ Bk # Oc \\<up> Suc b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_2_elems[simp]: \"length (<aa # a # list>) = Suc (Suc aa) + length (<a # list>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (<aa # a # list>) = Suc (Suc aa) + length (<a # list>)", "apply(simp add: tape_of_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_bin_addition[simp]: \"bl_bin (Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista) @ [Bk, Oc]) =\n              bl_bin (Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista)) + \n              2* 2^(length (Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin\n     (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista) @ [Bk, Oc]) =\n    bl_bin (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista)) +\n    2 * 2 ^ length (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista))", "using bl_bin_bk_oc[of \"Oc\\<up>(Suc aa) @ Bk # tape_of_nat_list (a # lista)\"]"], ["proof (prove)\nusing this:\n  bl_bin\n   ((Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista)) @ [Bk, Oc]) =\n  bl_bin (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista)) +\n  2 * 2 ^ length (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista))\n\ngoal (1 subgoal):\n 1. bl_bin\n     (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista) @ [Bk, Oc]) =\n    bl_bin (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista)) +\n    2 * 2 ^ length (Oc \\<up> Suc aa @ Bk # tape_of_nat_list (a # lista))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare replicate_Suc[simp del]"], ["", "lemma bl_bin_2[simp]: \n  \"bl_bin (<aa # list>) + (4 * rs + 4) * 2 ^ (length (<aa # list>) - Suc 0)\n  = bl_bin (Oc\\<up>(Suc aa) @ Bk # <list @ [0]>) + rs * (2 * 2 ^ (aa + length (<list @ [0]>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin (<aa # list>) +\n    (4 * rs + 4) * 2 ^ (length (<aa # list>) - Suc 0) =\n    bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n    rs * (2 * 2 ^ (aa + length (<list @ [0]>)))", "apply(case_tac \"list\", simp add: add_mult_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       bl_bin (<aa # list>) +\n       (4 * rs + 4) * 2 ^ (length (<aa # list>) - Suc 0) =\n       bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n       rs * (2 * 2 ^ (aa + length (<list @ [0]>)))", "apply(simp add: tape_of_nl_cons_app2 add_mult_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       bl_bin (<aa # a # lista>) + 8 * 2 ^ (aa + length (<a # lista>)) =\n       bl_bin (Oc \\<up> Suc aa @ Bk # <a # lista> @ [Bk, Oc])", "apply(simp add: tape_of_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tape_of_nl_app_Suc: \"((<list @ [Suc ab]>)) = (<list @ [ab]>) @ [Oc]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <list @ [Suc ab]> = <list @ [ab]> @ [Oc]", "proof(induct list)"], ["proof (state)\ngoal (2 subgoals):\n 1. <[] @ [Suc ab]> = <[] @ [ab]> @ [Oc]\n 2. \\<And>a list.\n       <list @ [Suc ab]> = <list @ [ab]> @ [Oc] \\<Longrightarrow>\n       <(a # list) @ [Suc ab]> = <(a # list) @ [ab]> @ [Oc]", "case (Cons a list)"], ["proof (state)\nthis:\n  <list @ [Suc ab]> = <list @ [ab]> @ [Oc]\n\ngoal (2 subgoals):\n 1. <[] @ [Suc ab]> = <[] @ [ab]> @ [Oc]\n 2. \\<And>a list.\n       <list @ [Suc ab]> = <list @ [ab]> @ [Oc] \\<Longrightarrow>\n       <(a # list) @ [Suc ab]> = <(a # list) @ [ab]> @ [Oc]", "then"], ["proof (chain)\npicking this:\n  <list @ [Suc ab]> = <list @ [ab]> @ [Oc]", "show ?case"], ["proof (prove)\nusing this:\n  <list @ [Suc ab]> = <list @ [ab]> @ [Oc]\n\ngoal (1 subgoal):\n 1. <(a # list) @ [Suc ab]> = <(a # list) @ [ab]> @ [Oc]", "by(cases list;simp_all add:tape_of_list_def exp_ind)"], ["proof (state)\nthis:\n  <(a # list) @ [Suc ab]> = <(a # list) @ [ab]> @ [Oc]\n\ngoal (1 subgoal):\n 1. <[] @ [Suc ab]> = <[] @ [ab]> @ [Oc]", "qed (simp add: tape_of_list_def exp_ind)"], ["", "lemma bl_bin_3[simp]: \"bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]> @ [Oc])\n              = bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>) +\n              2^(length (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin (Oc # Oc \\<up> aa @ Bk # <list @ [ab]> @ [Oc]) =\n    bl_bin (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) +\n    2 ^ length (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>)", "apply(simp add: bin_wc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc (Oc # Oc \\<up> aa @ Bk # <list @ [ab]> @ [Oc]) =\n    bl2wc (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) +\n    4 * 2 ^ (aa + length (<list @ [ab]>))", "apply(simp add: bl2nat_cons_oc bl2wc.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2nat (Oc # Oc \\<up> aa @ Bk # <list @ [ab]> @ [Oc]) 0 =\n    bl2nat (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) 0 +\n    4 * 2 ^ (aa + length (<list @ [ab]>))", "using bl2nat_cons_oc[of \"Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>\"]"], ["proof (prove)\nusing this:\n  bl2nat ((Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) @ [Oc]) 0 =\n  bl2nat (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) 0 +\n  2 ^ length (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>)\n\ngoal (1 subgoal):\n 1. bl2nat (Oc # Oc \\<up> aa @ Bk # <list @ [ab]> @ [Oc]) 0 =\n    bl2nat (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) 0 +\n    4 * 2 ^ (aa + length (<list @ [ab]>))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bl_bin_4[simp]: \"bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [ab]>) + (4 * 2 ^ (aa + length (<list @ [ab]>)) +\n         4 * (rs * 2 ^ (aa + length (<list @ [ab]>)))) =\n       bl_bin (Oc # Oc\\<up>(aa) @ Bk # <list @ [Suc ab]>) +\n         rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin (Oc # Oc \\<up> aa @ Bk # <list @ [ab]>) +\n    (4 * 2 ^ (aa + length (<list @ [ab]>)) +\n     4 * (rs * 2 ^ (aa + length (<list @ [ab]>)))) =\n    bl_bin (Oc # Oc \\<up> aa @ Bk # <list @ [Suc ab]>) +\n    rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))", "apply(simp add: tape_of_nl_app_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare tape_of_nat[simp del]"], ["", "fun wcode_double_case_inv :: \"nat \\<Rightarrow> bin_inv_t\"\n  where\n    \"wcode_double_case_inv st ires rs (l, r) = \n          (if st = Suc 0 then wcode_on_left_moving_1 ires rs (l, r)\n          else if st = Suc (Suc 0) then wcode_on_checking_1 ires rs (l, r)\n          else if st = 3 then wcode_erase1 ires rs (l, r)\n          else if st = 4 then wcode_on_right_moving_1 ires rs (l, r)\n          else if st = 5 then wcode_goon_right_moving_1 ires rs (l, r)\n          else if st = 6 then wcode_backto_standard_pos ires rs (l, r)\n          else if st = 13 then wcode_before_double ires rs (l, r)\n          else False)\""], ["", "declare wcode_double_case_inv.simps[simp del]"], ["", "fun wcode_double_case_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"wcode_double_case_state (st, l, r) = \n   13 - st\""], ["", "fun wcode_double_case_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"wcode_double_case_step (st, l, r) = \n      (if st = Suc 0 then (length l)\n      else if st = Suc (Suc 0) then (length r)\n      else if st = 3 then \n                 if hd r = Oc then 1 else 0\n      else if st = 4 then (length r)\n      else if st = 5 then (length r)\n      else if st = 6 then (length l)\n      else 0)\""], ["", "fun wcode_double_case_measure :: \"config \\<Rightarrow> nat \\<times> nat\"\n  where\n    \"wcode_double_case_measure (st, l, r) = \n     (wcode_double_case_state (st, l, r), \n      wcode_double_case_step (st, l, r))\""], ["", "definition wcode_double_case_le :: \"(config \\<times> config) set\"\n  where \"wcode_double_case_le \\<equiv> (inv_image lex_pair wcode_double_case_measure)\""], ["", "lemma wf_lex_pair[intro]: \"wf lex_pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf Recursive.lex_pair", "by(auto intro:wf_lex_prod simp:lex_pair_def)"], ["", "lemma wf_wcode_double_case_le[intro]: \"wf wcode_double_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_double_case_le", "by(auto intro:wf_inv_image simp: wcode_double_case_le_def )"], ["", "lemma fetch_t_wcode_main[simp]:\n  \"fetch t_wcode_main (Suc 0) Bk = (L, Suc 0)\"\n  \"fetch t_wcode_main (Suc 0) Oc = (L, Suc (Suc 0))\"\n  \"fetch t_wcode_main (Suc (Suc 0)) Oc = (R, 3)\"\n  \"fetch t_wcode_main (Suc (Suc 0)) Bk = (L, 7)\"\n  \"fetch t_wcode_main (Suc (Suc (Suc 0))) Bk = (R, 4)\"\n  \"fetch t_wcode_main (Suc (Suc (Suc 0))) Oc = (W0, 3)\"\n  \"fetch t_wcode_main 4 Bk = (R, 4)\"\n  \"fetch t_wcode_main 4 Oc = (R, 5)\"\n  \"fetch t_wcode_main 5 Oc = (R, 5)\"\n  \"fetch t_wcode_main 5 Bk = (W1, 6)\"\n  \"fetch t_wcode_main 6 Bk = (R, 13)\"\n  \"fetch t_wcode_main 6 Oc = (L, 6)\"\n  \"fetch t_wcode_main 7 Oc = (R, 8)\"\n  \"fetch t_wcode_main 7 Bk = (R, 0)\"\n  \"fetch t_wcode_main 8 Bk = (R, 9)\"\n  \"fetch t_wcode_main 9 Bk = (R, 10)\"\n  \"fetch t_wcode_main 9 Oc = (W0, 9)\"\n  \"fetch t_wcode_main 10 Bk = (R, 10)\"\n  \"fetch t_wcode_main 10 Oc = (R, 11)\"\n  \"fetch t_wcode_main 11 Bk = (W1, 12)\"\n  \"fetch t_wcode_main 11 Oc = (R, 11)\"\n  \"fetch t_wcode_main 12 Oc = (L, 12)\"\n  \"fetch t_wcode_main 12 Bk = (R, t_twice_len + 14)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((fetch t_wcode_main (Suc 0) Bk = (L, Suc 0) &&&\n       fetch t_wcode_main (Suc 0) Oc = (L, Suc (Suc 0))) &&&\n      fetch t_wcode_main (Suc (Suc 0)) Oc = (R, 3) &&&\n      fetch t_wcode_main (Suc (Suc 0)) Bk = (L, 7) &&&\n      fetch t_wcode_main (Suc (Suc (Suc 0))) Bk = (R, 4)) &&&\n     (fetch t_wcode_main (Suc (Suc (Suc 0))) Oc = (W0, 3) &&&\n      fetch t_wcode_main 4 Bk = (R, 4) &&&\n      fetch t_wcode_main 4 Oc = (R, 5)) &&&\n     fetch t_wcode_main 5 Oc = (R, 5) &&&\n     fetch t_wcode_main 5 Bk = (W1, 6) &&&\n     fetch t_wcode_main 6 Bk = (R, 13)) &&&\n    ((fetch t_wcode_main 6 Oc = (L, 6) &&&\n      fetch t_wcode_main 7 Oc = (R, 8) &&&\n      fetch t_wcode_main 7 Bk = (R, 0)) &&&\n     fetch t_wcode_main 8 Bk = (R, 9) &&&\n     fetch t_wcode_main 9 Bk = (R, 10) &&&\n     fetch t_wcode_main 9 Oc = (W0, 9)) &&&\n    (fetch t_wcode_main 10 Bk = (R, 10) &&&\n     fetch t_wcode_main 10 Oc = (R, 11) &&&\n     fetch t_wcode_main 11 Bk = (W1, 12)) &&&\n    fetch t_wcode_main 11 Oc = (R, 11) &&&\n    fetch t_wcode_main 12 Oc = (L, 12) &&&\n    fetch t_wcode_main 12 Bk = (R, t_twice_len + 14)", "by(auto simp: t_wcode_main_def t_wcode_main_first_part_def fetch.simps numeral)"], ["", "declare wcode_on_checking_1.simps[simp del]"], ["", "lemmas wcode_double_case_inv_simps = \n  wcode_on_left_moving_1.simps wcode_on_left_moving_1_O.simps\n  wcode_on_left_moving_1_B.simps wcode_on_checking_1.simps\n  wcode_erase1.simps wcode_on_right_moving_1.simps\n  wcode_goon_right_moving_1.simps wcode_backto_standard_pos.simps"], ["", "lemma wcode_on_left_moving_1[simp]:\n  \"wcode_on_left_moving_1 ires rs (b, []) = False\"\n  \"wcode_on_left_moving_1 ires rs (b, r) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_left_moving_1 ires rs (b, []) = False &&&\n    (wcode_on_left_moving_1 ires rs (b, r) \\<Longrightarrow> b \\<noteq> [])", "by(auto simp: wcode_on_left_moving_1.simps wcode_on_left_moving_1_B.simps\n      wcode_on_left_moving_1_O.simps)"], ["", "lemma wcode_on_left_moving_1E[elim]: \"\\<lbrakk>wcode_on_left_moving_1 ires rs (b, Bk # list);\n                tl b = aa \\<and> hd b # Bk # list = ba\\<rbrakk> \\<Longrightarrow> \n               wcode_on_left_moving_1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_on_left_moving_1 ires rs (b, Bk # list);\n     tl b = aa \\<and> hd b # Bk # list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_on_left_moving_1 ires rs (aa, ba)", "apply(simp only: wcode_on_left_moving_1.simps wcode_on_left_moving_1_O.simps\n      wcode_on_left_moving_1_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>ml mr rn.\n                 b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                 Bk # list =\n                 Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                 Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n             (\\<exists>ln rn.\n                 b = Oc # ires \\<and>\n                 Bk # list =\n                 Oc #\n                 Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn);\n     tl b = aa \\<and> hd b # Bk # list = ba\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ml mr rn.\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                             ba =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             aa = Oc # ires \\<and>\n                             ba =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                             ba =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             aa = Oc # ires \\<and>\n                             ba =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(case_tac ml, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Oc # ires = aa \\<and>\n                Oc # Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn = ba;\n        b = Oc # aa \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < mr \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn.\n                            ba =\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n 2. \\<And>ml mr rn nat.\n       \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                             ba =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             aa = Oc # ires \\<and>\n                             ba =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 3. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(rule_tac x = \"mr - Suc (Suc 0)\" in exI, rule_tac x = rn in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Oc # ires = aa \\<and>\n                Oc # Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn = ba;\n        b = Oc # aa \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < mr \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> ba =\n                         Oc #\n                         Bk \\<up> (mr - Suc (Suc 0)) @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n 2. \\<And>ml mr rn nat.\n       \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                             ba =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             aa = Oc # ires \\<and>\n                             ba =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 3. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply (smt One_nat_def Suc_diff_Suc append_Cons empty_replicate list.sel(3) neq0_conv replicate_Suc replicate_app_Cons_same tl_append2 tl_replicate)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn nat.\n       \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                             ba =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             aa = Oc # ires \\<and>\n                             ba =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(rule_tac disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn nat.\n       \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr rn.\n                            aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                            ba =\n                            Bk \\<up> mr @\n                            Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                            Suc 0 < ml + mr \\<and> 0 < mr\n 2. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply (metis add_Suc_shift less_SucI list.exhaust_sel list.inject list.simps(3) replicate_Suc_iff_anywhere)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl b = aa \\<and> hd b # Bk # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ml mr rn.\n                          aa = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                          ba =\n                          Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                          Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                      (\\<exists>ln rn.\n                          aa = Oc # ires \\<and>\n                          ba =\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "by simp"], ["", "declare replicate_Suc[simp]"], ["", "lemma wcode_on_moving_1_Elim[elim]: \n  \"\\<lbrakk>wcode_on_left_moving_1 ires rs (b, Oc # list); tl b = aa \\<and> hd b # Oc # list = ba\\<rbrakk> \n    \\<Longrightarrow> wcode_on_checking_1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_on_left_moving_1 ires rs (b, Oc # list);\n     tl b = aa \\<and> hd b # Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_on_checking_1 ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>ml mr rn.\n                 b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n                 Oc # list =\n                 Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                 Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n             (\\<exists>ln rn.\n                 b = Oc # ires \\<and>\n                 Oc # list =\n                 Oc #\n                 Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn);\n     tl b = aa \\<and> hd b # Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = ires \\<and>\n                         ba =\n                         Oc #\n                         Oc #\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tl b = aa \\<and> hd b # Oc # list = ba;\n     \\<exists>ml mr rn.\n        b = Bk \\<up> ml @ Oc # Oc # ires \\<and>\n        Oc # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = ires \\<and>\n                         ba =\n                         Oc #\n                         Oc #\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n 2. \\<lbrakk>tl b = aa \\<and> hd b # Oc # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Oc # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = ires \\<and>\n                         ba =\n                         Oc #\n                         Oc #\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "apply (metis cell.distinct(1) empty_replicate hd_append2 hd_replicate list.sel(1) not_gr_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl b = aa \\<and> hd b # Oc # list = ba;\n     \\<exists>ln rn.\n        b = Oc # ires \\<and>\n        Oc # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = ires \\<and>\n                         ba =\n                         Oc #\n                         Oc #\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma wcode_on_checking_1_Elim[elim]: \"\\<lbrakk>wcode_on_checking_1 ires rs (b, Oc # ba);Oc # b = aa \\<and> list = ba\\<rbrakk>\n  \\<Longrightarrow> wcode_erase1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_on_checking_1 ires rs (b, Oc # ba);\n     Oc # b = aa \\<and> list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_erase1 ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ln rn.\n                b = ires \\<and>\n                Oc # ba =\n                Oc #\n                Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn;\n     Oc # b = aa \\<and> list = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = Oc # ires \\<and>\n                         tl ba =\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<lbrakk>Oc # b = aa \\<and> list = ba;\n        b = ires \\<and>\n        Oc # ba =\n        Oc #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn.\n                            aa = Oc # ires \\<and>\n                            tl ba =\n                            Bk \\<up> ln @\n                            Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "by auto"], ["", "lemma wcode_on_checking_1_simp[simp]:\n  \"wcode_on_checking_1 ires rs (b, []) = False\" \n  \"wcode_on_checking_1 ires rs (b, Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_checking_1 ires rs (b, []) = False &&&\n    wcode_on_checking_1 ires rs (b, Bk # list) = False", "by(auto simp: wcode_double_case_inv_simps)"], ["", "lemma wcode_erase1_nonempty_snd[simp]: \"wcode_erase1 ires rs (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_erase1 ires rs (b, []) = False", "apply(simp add: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_on_right_moving_1_nonempty_snd[simp]: \"wcode_on_right_moving_1 ires rs (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_right_moving_1 ires rs (b, []) = False", "apply(simp add: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_on_right_moving_1_BkE[elim]:\n  \"\\<lbrakk>wcode_on_right_moving_1 ires rs (b, Bk # ba);  Bk # b = aa \\<and> list = b\\<rbrakk> \\<Longrightarrow> \n  wcode_on_right_moving_1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_on_right_moving_1 ires rs (b, Bk # ba);\n     Bk # b = aa \\<and> list = b\\<rbrakk>\n    \\<Longrightarrow> wcode_on_right_moving_1 ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ml mr rn.\n                b = Bk \\<up> ml @ Oc # ires \\<and>\n                Bk # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                Suc 0 < ml + mr;\n     Bk # b = aa \\<and> list = b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ml mr rn.\n                         aa = Bk \\<up> ml @ Oc # ires \\<and>\n                         ba =\n                         Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                         Suc 0 < ml + mr", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Bk # b = aa \\<and> list = b;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Bk # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr rn.\n                            aa = Bk \\<up> ml @ Oc # ires \\<and>\n                            ba =\n                            Bk \\<up> mr @\n                            Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                            Suc 0 < ml + mr", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Bk # b = aa \\<and> list = b;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Bk # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr rn.\n                            aa = Bk \\<up> ml @ Oc # ires \\<and>\n                            ba =\n                            Bk \\<up> mr @\n                            Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                            Suc 0 < ml + mr", "apply(rule_tac x = \"Suc ml\" in exI, rule_tac x = \"mr - Suc 0\" in exI,\n      rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Bk # b = aa \\<and> list = b;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Bk # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> aa = Bk \\<up> Suc ml @ Oc # ires \\<and>\n                         ba =\n                         Bk \\<up> (mr - Suc 0) @\n                         Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                         Suc 0 < Suc ml + (mr - Suc 0)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Bk # Bk \\<up> ml @ Oc # ires = aa \\<and>\n                list = Bk \\<up> ml @ Oc # ires;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Bk # ba = Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> ba =\n                         Bk \\<up> (mr - Suc 0) @\n                         Oc # Oc \\<up> rs @ Bk \\<up> rn \\<and>\n                         (0 < ml \\<or> Suc 0 < mr)", "apply(case_tac mr, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_on_right_moving_1_OcE[elim]: \n  \"\\<lbrakk>wcode_on_right_moving_1 ires rs (b, Oc # ba); Oc # b = aa \\<and> list = ba\\<rbrakk> \n  \\<Longrightarrow> wcode_goon_right_moving_1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_on_right_moving_1 ires rs (b, Oc # ba);\n     Oc # b = aa \\<and> list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_goon_right_moving_1 ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ml mr rn.\n                b = Bk \\<up> ml @ Oc # ires \\<and>\n                Oc # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                Suc 0 < ml + mr;\n     Oc # b = aa \\<and> list = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ml mr ln rn.\n                         aa =\n                         Oc \\<up> ml @\n                         Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                         ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                         ml + mr = Suc rs", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Oc # b = aa \\<and> list = ba;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Oc # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr ln rn.\n                            aa =\n                            Oc \\<up> ml @\n                            Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                            ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                            ml + mr = Suc rs", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Oc # b = aa \\<and> list = ba;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Oc # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr ln rn.\n                            aa =\n                            Oc \\<up> ml @\n                            Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                            ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                            ml + mr = Suc rs", "apply(rule_tac x = \"Suc 0\" in exI, rule_tac x = \"rs\" in exI,\n      rule_tac x = \"ml - Suc (Suc 0)\" in exI, rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Oc # b = aa \\<and> list = ba;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        Oc # ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr\\<rbrakk>\n       \\<Longrightarrow> aa =\n                         Oc \\<up> Suc 0 @\n                         Bk #\n                         Bk # Bk \\<up> (ml - Suc (Suc 0)) @ Oc # ires \\<and>\n                         ba = Oc \\<up> rs @ Bk \\<up> rn \\<and>\n                         Suc 0 + rs = Suc rs", "apply(case_tac mr, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>Oc # Bk \\<up> ml @ Oc # ires = aa \\<and>\n                list = Oc \\<up> rs @ Bk \\<up> rn;\n        b = Bk \\<up> ml @ Oc # ires \\<and>\n        ba = Oc \\<up> rs @ Bk \\<up> rn \\<and> Suc 0 < ml;\n        mr = 0\\<rbrakk>\n       \\<Longrightarrow> aa =\n                         Oc #\n                         Bk # Bk # Bk \\<up> (ml - Suc (Suc 0)) @ Oc # ires", "apply(case_tac ml, simp, case_tac nat, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_erase1_BkE[elim]:\n  assumes \"wcode_erase1 ires rs (b, Bk # ba)\" \"Bk # b = aa \\<and> list = ba\" \"c = Bk # ba\"\n  shows \"wcode_on_right_moving_1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_right_moving_1 ires rs (aa, ba)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wcode_on_right_moving_1 ires rs (aa, ba)", "from assms"], ["proof (chain)\npicking this:\n  wcode_erase1 ires rs (b, Bk # ba)\n  Bk # b = aa \\<and> list = ba\n  c = Bk # ba", "obtain rn ln where \"b = Oc # ires\"\n    \"tl (Bk # ba) = Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  wcode_erase1 ires rs (b, Bk # ba)\n  Bk # b = aa \\<and> list = ba\n  c = Bk # ba\n\ngoal (1 subgoal):\n 1. (\\<And>ln rn.\n        \\<lbrakk>b = Oc # ires;\n         tl (Bk # ba) =\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wcode_double_case_inv_simps"], ["proof (prove)\nusing this:\n  \\<exists>ln rn.\n     b = Oc # ires \\<and>\n     tl (Bk # ba) = Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n  Bk # b = aa \\<and> list = ba\n  c = Bk # ba\n\ngoal (1 subgoal):\n 1. (\\<And>ln rn.\n        \\<lbrakk>b = Oc # ires;\n         tl (Bk # ba) =\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = Oc # ires\n  tl (Bk # ba) = Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. wcode_on_right_moving_1 ires rs (aa, ba)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = Oc # ires\n  tl (Bk # ba) = Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. wcode_on_right_moving_1 ires rs (aa, ba)", "using assms(2-)"], ["proof (prove)\nusing this:\n  b = Oc # ires\n  tl (Bk # ba) = Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n  Bk # b = aa \\<and> list = ba\n  c = Bk # ba\n\ngoal (1 subgoal):\n 1. wcode_on_right_moving_1 ires rs (aa, ba)", "unfolding wcode_double_case_inv_simps"], ["proof (prove)\nusing this:\n  b = Oc # ires\n  tl (Bk # ba) = Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n  Bk # b = aa \\<and> list = ba\n  c = Bk # ba\n\ngoal (1 subgoal):\n 1. \\<exists>ml mr rn.\n       aa = Bk \\<up> ml @ Oc # ires \\<and>\n       ba = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n       Suc 0 < ml + mr", "apply(rule_tac x = \"Suc 0\" in exI, rule_tac x = \"Suc (Suc ln)\" in exI, \n        rule_tac x = rn in exI, simp add: exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wcode_on_right_moving_1 ires rs (aa, ba)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wcode_erase1_OcE[elim]: \"\\<lbrakk>wcode_erase1 ires rs (aa, Oc # list);  b = aa \\<and> Bk # list = ba\\<rbrakk> \\<Longrightarrow> \n  wcode_erase1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_erase1 ires rs (aa, Oc # list);\n     b = aa \\<and> Bk # list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_erase1 ires rs (aa, ba)", "unfolding wcode_double_case_inv_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ln rn.\n                aa = Oc # ires \\<and>\n                tl (Oc # list) =\n                Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn;\n     b = aa \\<and> Bk # list = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = Oc # ires \\<and>\n                         tl ba =\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "by auto auto"], ["", "lemma wcode_goon_right_moving_1_emptyE[elim]:\n  assumes \"wcode_goon_right_moving_1 ires rs (aa, [])\" \"b = aa \\<and> [Oc] = ba\"\n  shows \"wcode_backto_standard_pos ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "from assms"], ["proof (chain)\npicking this:\n  wcode_goon_right_moving_1 ires rs (aa, [])\n  b = aa \\<and> [Oc] = ba", "obtain ml ln rn mr where \"aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires\"\n    \"[] = Oc \\<up> mr @ Bk \\<up> rn\" \"ml + mr = Suc rs\""], ["proof (prove)\nusing this:\n  wcode_goon_right_moving_1 ires rs (aa, [])\n  b = aa \\<and> [Oc] = ba\n\ngoal (1 subgoal):\n 1. (\\<And>ml ln mr rn.\n        \\<lbrakk>aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n         [] = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:wcode_double_case_inv_simps)"], ["proof (state)\nthis:\n  aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires\n  [] = Oc \\<up> mr @ Bk \\<up> rn\n  ml + mr = Suc rs\n\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires\n  [] = Oc \\<up> mr @ Bk \\<up> rn\n  ml + mr = Suc rs\n\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "using assms(2)"], ["proof (prove)\nusing this:\n  aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires\n  [] = Oc \\<up> mr @ Bk \\<up> rn\n  ml + mr = Suc rs\n  b = aa \\<and> [Oc] = ba\n\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n     [] = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     [Oc] = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_backto_standard_pos_B ires rs\n                       (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires,\n                        ba) \\<or>\n                      wcode_backto_standard_pos_O ires rs\n                       (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires, ba)", "apply(rule_tac disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n     [] = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     [Oc] = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_backto_standard_pos_O ires rs\n                       (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires, ba)", "apply(simp only:wcode_backto_standard_pos_O.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n     [] = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     [Oc] = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>mla mr lna rn.\n                         Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires =\n                         Oc \\<up> mla @\n                         Bk # Bk # Bk \\<up> lna @ Oc # ires \\<and>\n                         ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                         mla + mr = Suc (Suc rs) \\<and> 0 < mr", "apply(rule_tac x = ml in exI, rule_tac x = \"Suc 0\" in exI, rule_tac x = ln in exI,\n        rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wcode_backto_standard_pos ires rs (aa, ba)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wcode_goon_right_moving_1_BkE[elim]: \n  assumes \"wcode_goon_right_moving_1 ires rs (aa, Bk # list)\" \"b = aa \\<and> Oc # list = ba\"\n  shows \"wcode_backto_standard_pos ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "from assms"], ["proof (chain)\npicking this:\n  wcode_goon_right_moving_1 ires rs (aa, Bk # list)\n  b = aa \\<and> Oc # list = ba", "obtain ln rn where \"aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\"\n    \"Bk # list = Bk \\<up> rn\" \"b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\" \"ba = Oc # list\""], ["proof (prove)\nusing this:\n  wcode_goon_right_moving_1 ires rs (aa, Bk # list)\n  b = aa \\<and> Oc # list = ba\n\ngoal (1 subgoal):\n 1. (\\<And>ln rn.\n        \\<lbrakk>aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires;\n         Bk # list = Bk \\<up> rn;\n         b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires;\n         ba = Oc # list\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:wcode_double_case_inv_simps)"], ["proof (state)\nthis:\n  aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\n  Bk # list = Bk \\<up> rn\n  b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\n  ba = Oc # list\n\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "thus ?thesis"], ["proof (prove)\nusing this:\n  aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\n  Bk # list = Bk \\<up> rn\n  b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\n  ba = Oc # list\n\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "using assms(2)"], ["proof (prove)\nusing this:\n  aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\n  Bk # list = Bk \\<up> rn\n  b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires\n  ba = Oc # list\n  b = aa \\<and> Oc # list = ba\n\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps wcode_backto_standard_pos_O.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires;\n     Bk # list = Bk \\<up> rn;\n     Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires =\n     Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires;\n     ba = ba;\n     b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires \\<and>\n     Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_backto_standard_pos_B ires rs\n                       (Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires,\n                        ba) \\<or>\n                      (\\<exists>ml mr lna rn.\n                          Oc \\<up> Suc rs @\n                          Bk \\<up> Suc (Suc ln) @ Oc # ires =\n                          Oc \\<up> ml @\n                          Bk # Bk # Bk \\<up> lna @ Oc # ires \\<and>\n                          ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                          ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(rule_tac disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires;\n     Bk # list = Bk \\<up> rn;\n     Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires =\n     Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires;\n     ba = ba;\n     b = Oc \\<up> Suc rs @ Bk \\<up> Suc (Suc ln) @ Oc # ires \\<and>\n     Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ml mr lna rn.\n                         Oc \\<up> Suc rs @\n                         Bk \\<up> Suc (Suc ln) @ Oc # ires =\n                         Oc \\<up> ml @\n                         Bk # Bk # Bk \\<up> lna @ Oc # ires \\<and>\n                         ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                         ml + mr = Suc (Suc rs) \\<and> 0 < mr", "apply(rule exI[of _ \"Suc rs\"], rule exI[of _ \"Suc 0\"], rule_tac x = ln in exI,\n        rule_tac x = \"rn - Suc 0\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>aa = Oc # Oc \\<up> rs @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n     Bk # list = Bk \\<up> rn;\n     b = Oc # Oc \\<up> rs @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> ba = Oc # Bk \\<up> (rn - Suc 0)", "apply(cases rn;auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wcode_backto_standard_pos ires rs (aa, ba)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wcode_goon_right_moving_1_OcE[elim]: \n  assumes \"wcode_goon_right_moving_1 ires rs (b, Oc # ba)\" \"Oc # b = aa \\<and> list = ba\"\n  shows \"wcode_goon_right_moving_1 ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_1 ires rs (aa, ba)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_1 ires rs (aa, ba)", "from assms"], ["proof (chain)\npicking this:\n  wcode_goon_right_moving_1 ires rs (b, Oc # ba)\n  Oc # b = aa \\<and> list = ba", "obtain ml mr ln rn where\n    \"b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\""], ["proof (prove)\nusing this:\n  wcode_goon_right_moving_1 ires rs (b, Oc # ba)\n  Oc # b = aa \\<and> list = ba\n\ngoal (1 subgoal):\n 1. (\\<And>ml ln mr rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding wcode_double_case_inv_simps"], ["proof (prove)\nusing this:\n  \\<exists>ml mr ln rn.\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\n  Oc # b = aa \\<and> list = ba\n\ngoal (1 subgoal):\n 1. (\\<And>ml ln mr rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n  Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\n\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_1 ires rs (aa, ba)", "with assms(2)"], ["proof (chain)\npicking this:\n  Oc # b = aa \\<and> list = ba\n  b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n  Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs", "show ?thesis"], ["proof (prove)\nusing this:\n  Oc # b = aa \\<and> list = ba\n  b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n  Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\n\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_1 ires rs (aa, ba)", "unfolding wcode_double_case_inv_simps"], ["proof (prove)\nusing this:\n  Oc # b = aa \\<and> list = ba\n  b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n  Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\n\ngoal (1 subgoal):\n 1. \\<exists>ml mr ln rn.\n       aa = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs", "apply(rule_tac x = \"Suc ml\" in exI, rule_tac x = \"mr - Suc 0\" in exI, \n        rule_tac x = ln in exI, rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Oc # b = aa \\<and> list = ba;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs;\n     Oc # b = aa \\<and> list = ba;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs;\n     Oc # b = aa \\<and> list = ba;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs;\n     Oc # b = aa \\<and> list = ba;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\\<rbrakk>\n    \\<Longrightarrow> aa =\n                      Oc \\<up> Suc ml @\n                      Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                      ba = Oc \\<up> (mr - Suc 0) @ Bk \\<up> rn \\<and>\n                      Suc ml + (mr - Suc 0) = Suc rs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Oc # Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires = aa;\n     list = ba;\n     b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n     Oc # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs\\<rbrakk>\n    \\<Longrightarrow> ba = Oc \\<up> (mr - Suc 0) @ Bk \\<up> rn \\<and>\n                      ml + (mr - Suc 0) = rs", "apply(case_tac mr, simp, case_tac rn, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wcode_goon_right_moving_1 ires rs (aa, ba)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wcode_backto_standard_pos_BkE[elim]: \"\\<lbrakk>wcode_backto_standard_pos ires rs (b, Bk # ba); Bk # b = aa \\<and> list = ba\\<rbrakk> \n  \\<Longrightarrow> wcode_before_double ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_backto_standard_pos ires rs (b, Bk # ba);\n     Bk # b = aa \\<and> list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_before_double ires rs (aa, ba)", "apply(simp only: wcode_double_case_inv_simps wcode_backto_standard_pos_B.simps\n      wcode_backto_standard_pos_O.simps wcode_before_double.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>ln rn.\n                 b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                 Bk # ba = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n             (\\<exists>ml mr ln rn.\n                 b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                 Bk # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                 ml + mr = Suc (Suc rs) \\<and> 0 < mr);\n     Bk # b = aa \\<and> list = ba\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                         ba = Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Bk # b = aa \\<and> list = ba;\n     \\<exists>ln rn.\n        b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Bk # ba = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                         ba = Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn\n 2. \\<lbrakk>Bk # b = aa \\<and> list = ba;\n     \\<exists>ml mr ln rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Bk # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                         ba = Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ln rn.\n       \\<lbrakk>Bk # b = aa \\<and> list = ba;\n        b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Bk # ba = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn.\n                            aa = Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                            ba = Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn\n 2. \\<lbrakk>Bk # b = aa \\<and> list = ba;\n     \\<exists>ml mr ln rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Bk # ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ln rn.\n                         aa = Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                         ba = Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn", "by auto"], ["", "lemma wcode_backto_standard_pos_no_Oc[simp]: \"wcode_backto_standard_pos ires rs ([], Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs ([], Oc # list) = False", "apply(auto simp: wcode_backto_standard_pos.simps wcode_backto_standard_pos_B.simps\n      wcode_backto_standard_pos_O.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_backto_standard_pos_nonempty_snd[simp]: \"wcode_backto_standard_pos ires rs (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos ires rs (b, []) = False", "apply(auto simp: wcode_backto_standard_pos.simps wcode_backto_standard_pos_B.simps\n      wcode_backto_standard_pos_O.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_backto_standard_pos_OcE[elim]: \"\\<lbrakk>wcode_backto_standard_pos ires rs (b, Oc # list); tl b = aa; hd b # Oc # list =  ba\\<rbrakk>\n       \\<Longrightarrow> wcode_backto_standard_pos ires rs (aa, ba)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wcode_backto_standard_pos ires rs (b, Oc # list); tl b = aa;\n     hd b # Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> wcode_backto_standard_pos ires rs (aa, ba)", "apply(simp only:  wcode_backto_standard_pos.simps wcode_backto_standard_pos_B.simps\n      wcode_backto_standard_pos_O.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<exists>ln rn.\n                 b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                 Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n             (\\<exists>ml mr ln rn.\n                 b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                 Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                 ml + mr = Suc (Suc rs) \\<and> 0 < mr);\n     tl b = aa; hd b # Oc # list = ba\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ln rn.\n                          aa = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba =\n                          Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n                      (\\<exists>ml mr ln rn.\n                          aa =\n                          Oc \\<up> ml @\n                          Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                          ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tl b = aa; hd b # Oc # list = ba;\n     \\<exists>ln rn.\n        b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ln rn.\n                          aa = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba =\n                          Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n                      (\\<exists>ml mr ln rn.\n                          aa =\n                          Oc \\<up> ml @\n                          Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                          ml + mr = Suc (Suc rs) \\<and> 0 < mr)\n 2. \\<lbrakk>tl b = aa; hd b # Oc # list = ba;\n     \\<exists>ml mr ln rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ln rn.\n                          aa = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba =\n                          Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n                      (\\<exists>ml mr ln rn.\n                          aa =\n                          Oc \\<up> ml @\n                          Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                          ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl b = aa; hd b # Oc # list = ba;\n     \\<exists>ml mr ln rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ln rn.\n                          aa = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba =\n                          Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n                      (\\<exists>ml mr ln rn.\n                          aa =\n                          Oc \\<up> ml @\n                          Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                          ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                          ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>tl b = aa; hd b # Oc # list = ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ln rn.\n                             aa = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                             ba =\n                             Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<or>\n                         (\\<exists>ml mr ln rn.\n                             aa =\n                             Oc \\<up> ml @\n                             Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n                             ba = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                             ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ln.\n                             aa = Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                         (\\<exists>rn.\n                             ba =\n                             Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<or>\n                         (\\<exists>ml.\n                             (\\<exists>ln.\n                                 aa =\n                                 Oc \\<up> ml @\n                                 Bk # Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                             (\\<exists>mr.\n                                 (\\<exists>rn.\n                                     ba = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                 ml + mr = Suc (Suc rs) \\<and> 0 < mr))", "apply (rename_tac ml mr ln rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ln.\n                             aa = Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                         (\\<exists>rn.\n                             ba =\n                             Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<or>\n                         (\\<exists>ml.\n                             (\\<exists>ln.\n                                 aa =\n                                 Oc \\<up> ml @\n                                 Bk # Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                             (\\<exists>mr.\n                                 (\\<exists>rn.\n                                     ba = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                 ml + mr = Suc (Suc rs) \\<and> 0 < mr))", "apply(case_tac ml)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ln.\n                             aa = Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                         (\\<exists>rn.\n                             ba =\n                             Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<or>\n                         (\\<exists>ml.\n                             (\\<exists>ln.\n                                 aa =\n                                 Oc \\<up> ml @\n                                 Bk # Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                             (\\<exists>mr.\n                                 (\\<exists>rn.\n                                     ba = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                 ml + mr = Suc (Suc rs) \\<and> 0 < mr))\n 2. \\<And>ml mr ln rn nat.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ln.\n                             aa = Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                         (\\<exists>rn.\n                             ba =\n                             Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<or>\n                         (\\<exists>ml.\n                             (\\<exists>ln.\n                                 aa =\n                                 Oc \\<up> ml @\n                                 Bk # Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                             (\\<exists>mr.\n                                 (\\<exists>rn.\n                                     ba = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                 ml + mr = Suc (Suc rs) \\<and> 0 < mr))", "apply(rule_tac disjI1, rule_tac conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln. aa = Bk # Bk \\<up> ln @ Oc # ires\n 2. \\<And>ml mr ln rn.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn.\n                            ba = Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn\n 3. \\<And>ml mr ln rn nat.\n       \\<lbrakk>tl (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) = aa;\n        hd (Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires) #\n        Oc \\<up> mr @ Bk \\<up> rn =\n        ba;\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ln.\n                             aa = Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                         (\\<exists>rn.\n                             ba =\n                             Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<or>\n                         (\\<exists>ml.\n                             (\\<exists>ln.\n                                 aa =\n                                 Oc \\<up> ml @\n                                 Bk # Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n                             (\\<exists>mr.\n                                 (\\<exists>rn.\n                                     ba = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                 ml + mr = Suc (Suc rs) \\<and> 0 < mr))", "apply(rule_tac x = ln  in exI, force, rule_tac x = rn in exI, force, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare nth_of.simps[simp del] fetch.simps[simp del]"], ["", "lemma wcode_double_case_first_correctness:\n  \"let P = (\\<lambda> (st, l, r). st = 13) in \n       let Q = (\\<lambda> (st, l, r). wcode_double_case_inv st ires rs (l, r)) in \n       let f = (\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp) in\n       \\<exists> n .P (f n) \\<and> Q (f (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?P = \"(\\<lambda> (st, l, r). st = 13)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?Q = \"(\\<lambda> (st, l, r). wcode_double_case_inv st ires rs (l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?f = \"(\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "have \"\\<exists> n. ?P (?f n) \\<and> ?Q (?f (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>na.\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow> st = 13) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r))", "proof(rule_tac halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?LE\n 2. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)\n 3. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)\n 4. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 13) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> ?LE", "show \"wf wcode_double_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_double_case_le", "by auto"], ["proof (state)\nthis:\n  wf wcode_double_case_le\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 13) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_double_case_le", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 13) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_double_case_le", "show \"\\<forall> na. \\<not> ?P (?f na) \\<and> ?Q (?f na) \\<longrightarrow>\n                   ?Q (?f (Suc na)) \\<and> (?f (Suc na), ?f na) \\<in> wcode_double_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 13) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_double_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_double_case_le", "proof(rule_tac allI, case_tac \"?f na\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na a b c.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n        t_wcode_main na =\n       (a, b, c) \\<Longrightarrow>\n       a \\<noteq> 13 \\<and>\n       wcode_double_case_inv a ires rs (b, c) \\<longrightarrow>\n       (case step0 (a, b, c) t_wcode_main of\n        (st, x) \\<Rightarrow> wcode_double_case_inv st ires rs x) \\<and>\n       (step0 (a, b, c) t_wcode_main, a, b, c) \\<in> wcode_double_case_le", "fix na a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na a b c.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n        t_wcode_main na =\n       (a, b, c) \\<Longrightarrow>\n       a \\<noteq> 13 \\<and>\n       wcode_double_case_inv a ires rs (b, c) \\<longrightarrow>\n       (case step0 (a, b, c) t_wcode_main of\n        (st, x) \\<Rightarrow> wcode_double_case_inv st ires rs x) \\<and>\n       (step0 (a, b, c) t_wcode_main, a, b, c) \\<in> wcode_double_case_le", "show \"a \\<noteq> 13 \\<and> wcode_double_case_inv a ires rs (b, c) \\<longrightarrow>\n               (case step0 (a, b, c) t_wcode_main of (st, x) \\<Rightarrow> \n                   wcode_double_case_inv st ires rs x) \\<and> \n                (step0 (a, b, c) t_wcode_main, a, b, c) \\<in> wcode_double_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 13 \\<and>\n    wcode_double_case_inv a ires rs (b, c) \\<longrightarrow>\n    (case step0 (a, b, c) t_wcode_main of\n     (st, x) \\<Rightarrow> wcode_double_case_inv st ires rs x) \\<and>\n    (step0 (a, b, c) t_wcode_main, a, b, c) \\<in> wcode_double_case_le", "apply(rule_tac impI, simp add: wcode_double_case_inv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 13 \\<and>\n    (if a = Suc 0 then wcode_on_left_moving_1 ires rs (b, c)\n     else if a = Suc (Suc 0) then wcode_on_checking_1 ires rs (b, c)\n          else if a = 3 then wcode_erase1 ires rs (b, c)\n               else if a = 4 then wcode_on_right_moving_1 ires rs (b, c)\n                    else if a = 5\n                         then wcode_goon_right_moving_1 ires rs (b, c)\n                         else if a = 6\n                              then wcode_backto_standard_pos ires rs (b, c)\n                              else if a = 13\n                                   then wcode_before_double ires rs (b, c)\n                                   else False) \\<Longrightarrow>\n    (case step0 (a, b, c) t_wcode_main of\n     (st, x) \\<Rightarrow> wcode_double_case_inv st ires rs x) \\<and>\n    (step0 (a, b, c) t_wcode_main, a, b, c) \\<in> wcode_double_case_le", "apply(auto split: if_splits simp: step.simps, \n            case_tac [!] c, simp_all, case_tac [!] \"(c::cell list)!0\")"], ["proof (prove)\ngoal (32 subgoals):\n 1. \\<And>st aa ba aaa list.\n       \\<lbrakk>a = Suc 0; wcode_on_left_moving_1 ires rs (b, aaa # list);\n        (case fetch t_wcode_main (Suc 0) aaa of\n         (a, s') \\<Rightarrow> (s', update a (b, aaa # list))) =\n        (st, aa, ba);\n        c = aaa # list; c ! 0 = Bk\\<rbrakk>\n       \\<Longrightarrow> wcode_double_case_inv st ires rs (aa, ba)\n 2. \\<And>st aa ba aaa list.\n       \\<lbrakk>a = Suc 0; wcode_on_left_moving_1 ires rs (b, aaa # list);\n        (case fetch t_wcode_main (Suc 0) aaa of\n         (a, s') \\<Rightarrow> (s', update a (b, aaa # list))) =\n        (st, aa, ba);\n        c = aaa # list; c ! 0 = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_double_case_inv st ires rs (aa, ba)\n 3. \\<And>aa list.\n       \\<lbrakk>a = Suc 0; wcode_on_left_moving_1 ires rs (b, aa # list);\n        c = aa # list; c ! 0 = Bk\\<rbrakk>\n       \\<Longrightarrow> (case fetch t_wcode_main (Suc 0) aa of\n                          (aaa, s') \\<Rightarrow>\n                            (s', update aaa (b, aa # list)),\n                          Suc 0, b, aa # list)\n                         \\<in> wcode_double_case_le\n 4. \\<And>aa list.\n       \\<lbrakk>a = Suc 0; wcode_on_left_moving_1 ires rs (b, aa # list);\n        c = aa # list; c ! 0 = Oc\\<rbrakk>\n       \\<Longrightarrow> (case fetch t_wcode_main (Suc 0) aa of\n                          (aaa, s') \\<Rightarrow>\n                            (s', update aaa (b, aa # list)),\n                          Suc 0, b, aa # list)\n                         \\<in> wcode_double_case_le\n 5. \\<And>st aa ba aaa list.\n       \\<lbrakk>a = Suc (Suc 0);\n        wcode_on_checking_1 ires rs ([], aaa # list); b = [];\n        (case fetch t_wcode_main (Suc (Suc 0)) aaa of\n         (a, s') \\<Rightarrow> (s', update a ([], aaa # list))) =\n        (st, aa, ba);\n        c = aaa # list; c ! 0 = Bk\\<rbrakk>\n       \\<Longrightarrow> wcode_double_case_inv st ires rs (aa, ba)\n 6. \\<And>st aa ba aaa list.\n       \\<lbrakk>a = Suc (Suc 0);\n        wcode_on_checking_1 ires rs ([], aaa # list); b = [];\n        (case fetch t_wcode_main (Suc (Suc 0)) aaa of\n         (a, s') \\<Rightarrow> (s', update a ([], aaa # list))) =\n        (st, aa, ba);\n        c = aaa # list; c ! 0 = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_double_case_inv st ires rs (aa, ba)\n 7. \\<And>aa list.\n       \\<lbrakk>a = Suc (Suc 0);\n        wcode_on_checking_1 ires rs ([], aa # list); b = []; c = aa # list;\n        c ! 0 = Bk\\<rbrakk>\n       \\<Longrightarrow> (case fetch t_wcode_main (Suc (Suc 0)) aa of\n                          (aaa, s') \\<Rightarrow>\n                            (s', update aaa ([], aa # list)),\n                          Suc (Suc 0), [], aa # list)\n                         \\<in> wcode_double_case_le\n 8. \\<And>aa list.\n       \\<lbrakk>a = Suc (Suc 0);\n        wcode_on_checking_1 ires rs ([], aa # list); b = []; c = aa # list;\n        c ! 0 = Oc\\<rbrakk>\n       \\<Longrightarrow> (case fetch t_wcode_main (Suc (Suc 0)) aa of\n                          (aaa, s') \\<Rightarrow>\n                            (s', update aaa ([], aa # list)),\n                          Suc (Suc 0), [], aa # list)\n                         \\<in> wcode_double_case_le\n 9. \\<And>st aa ba aaa list.\n       \\<lbrakk>a = Suc (Suc 0);\n        wcode_on_checking_1 ires rs (b, aaa # list); b \\<noteq> [];\n        (case fetch t_wcode_main (Suc (Suc 0)) aaa of\n         (a, s') \\<Rightarrow> (s', update a (b, aaa # list))) =\n        (st, aa, ba);\n        c = aaa # list; c ! 0 = Bk\\<rbrakk>\n       \\<Longrightarrow> wcode_double_case_inv st ires rs (aa, ba)\n 10. \\<And>st aa ba aaa list.\n        \\<lbrakk>a = Suc (Suc 0);\n         wcode_on_checking_1 ires rs (b, aaa # list); b \\<noteq> [];\n         (case fetch t_wcode_main (Suc (Suc 0)) aaa of\n          (a, s') \\<Rightarrow> (s', update a (b, aaa # list))) =\n         (st, aa, ba);\n         c = aaa # list; c ! 0 = Oc\\<rbrakk>\n        \\<Longrightarrow> wcode_double_case_inv st ires rs (aa, ba)\nA total of 32 subgoals...", "apply(simp_all add: wcode_double_case_inv.simps wcode_double_case_le_def\n            lex_pair_def)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>st aa list.\n       \\<lbrakk>a = st; wcode_on_left_moving_1 ires rs (b, Bk # list);\n        Suc 0 = st; c = Bk # list; aa = Bk\\<rbrakk>\n       \\<Longrightarrow> wcode_on_left_moving_1 ires rs\n                          (tl b, hd b # Bk # list)\n 2. \\<And>st aa list.\n       \\<lbrakk>a = Suc 0; wcode_on_left_moving_1 ires rs (b, Oc # list);\n        Suc (Suc 0) = st; c = Oc # list; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_on_checking_1 ires rs\n                          (tl b, hd b # Oc # list)\n 3. \\<And>st ba aa.\n       \\<lbrakk>a = Suc (Suc 0); wcode_on_checking_1 ires rs ([], Oc # ba);\n        b = []; Suc (Suc (Suc 0)) = st; c = Oc # ba; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_erase1 ires rs ([Oc], ba)\n 4. \\<And>st ba aa.\n       \\<lbrakk>a = Suc (Suc 0); wcode_on_checking_1 ires rs (b, Oc # ba);\n        b \\<noteq> []; Suc (Suc (Suc 0)) = st; c = Oc # ba; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_erase1 ires rs (Oc # b, ba)\n 5. \\<And>st ba aa.\n       \\<lbrakk>a = Suc (Suc (Suc 0)); wcode_erase1 ires rs (b, Bk # ba);\n        st = 4; c = Bk # ba; aa = Bk\\<rbrakk>\n       \\<Longrightarrow> wcode_on_right_moving_1 ires rs (Bk # b, ba)\n 6. \\<And>st aa list.\n       \\<lbrakk>a = st; wcode_erase1 ires rs (b, Oc # list);\n        Suc (Suc (Suc 0)) = st; c = Oc # list; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_erase1 ires rs (b, Bk # list)\n 7. \\<And>st ba aa.\n       \\<lbrakk>a = 4; wcode_on_right_moving_1 ires rs (b, Bk # ba); st = 4;\n        c = Bk # ba; aa = Bk\\<rbrakk>\n       \\<Longrightarrow> wcode_on_right_moving_1 ires rs (Bk # b, ba)\n 8. \\<And>st ba aa.\n       \\<lbrakk>a = 4; wcode_on_right_moving_1 ires rs (b, Oc # ba); st = 5;\n        c = Oc # ba; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> wcode_goon_right_moving_1 ires rs (Oc # b, ba)\n 9. \\<lbrakk>a = 5; wcode_goon_right_moving_1 ires rs (b, []); c = [];\n     [] ! 0 = Bk\\<rbrakk>\n    \\<Longrightarrow> wcode_backto_standard_pos ires rs (b, [Oc])\n 10. \\<lbrakk>a = 5; wcode_goon_right_moving_1 ires rs (b, []); c = [];\n      [] ! 0 = Oc\\<rbrakk>\n     \\<Longrightarrow> wcode_backto_standard_pos ires rs (b, [Oc])\nA total of 15 subgoals...", "apply(auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<noteq> 13 \\<and>\n  wcode_double_case_inv a ires rs (b, c) \\<longrightarrow>\n  (case step0 (a, b, c) t_wcode_main of\n   (st, x) \\<Rightarrow> wcode_double_case_inv st ires rs x) \\<and>\n  (step0 (a, b, c) t_wcode_main, a, b, c) \\<in> wcode_double_case_le\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>na.\n     \\<not> (case steps0\n                   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                   t_wcode_main na of\n             (st, l, r) \\<Rightarrow> st = 13) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow>\n        wcode_double_case_inv st ires rs (l, r)) \\<longrightarrow>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main (Suc na) of\n      (st, l, r) \\<Rightarrow>\n        wcode_double_case_inv st ires rs (l, r)) \\<and>\n     (steps0\n       (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n       t_wcode_main (Suc na),\n      steps0\n       (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n       t_wcode_main na)\n     \\<in> wcode_double_case_le\n\ngoal (2 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)", "show \"?Q (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)", "apply(simp add: steps.simps wcode_double_case_inv.simps \n          wcode_on_left_moving_1.simps\n          wcode_on_left_moving_1_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ml.\n        Bk # Bk \\<up> m = Bk \\<up> ml \\<and>\n        (\\<exists>mr.\n            (\\<exists>rn.\n                Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n                Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n            Suc 0 < ml + mr \\<and> 0 < mr)) \\<or>\n    wcode_on_left_moving_1_O ires rs\n     (Bk # Bk \\<up> m @ Oc # Oc # ires, Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)", "apply(rule_tac disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ml.\n       Bk # Bk \\<up> m = Bk \\<up> ml \\<and>\n       (\\<exists>mr.\n           (\\<exists>rn.\n               Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n               Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n           Suc 0 < ml + mr \\<and> 0 < mr)", "apply(rule_tac x = \"Suc m\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>mr.\n       (\\<exists>rn.\n           Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n           Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n       (0 < m \\<or> 0 < mr) \\<and> 0 < mr", "apply(rule_tac x = \"Suc 0\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main 0 of\n  (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r)\n\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)", "show \"\\<not> ?P (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 13)", "apply(simp add: steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main 0 of\n          (st, l, r) \\<Rightarrow> st = 13)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>na.\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> st = 13) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "thus \"let P = \\<lambda>(st, l, r). st = 13;\n    Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n    f = steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)\""], ["proof (prove)\nusing this:\n  \\<exists>na.\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> st = 13) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> wcode_double_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 13;\n        Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  let P = \\<lambda>(st, l, r). st = 13;\n      Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_append_shift_append_steps: \n  \"\\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); \n  0 < st';\n  length tp1 mod 2 = 0\n  \\<rbrakk>\n  \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2) @ tp2) stp \n  = (st' + length tp1 div 2, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); 0 < st';\n     is_even (length tp1)\\<rbrakk>\n    \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r)\n                       (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n                      (st' + length tp1 div 2, l', r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); 0 < st';\n     is_even (length tp1)\\<rbrakk>\n    \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r)\n                       (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n                      (st' + length tp1 div 2, l', r')", "assume h: \n    \"steps0 (st, l, r) tp stp = (st', l', r')\"\n    \"0 < st'\"\n    \"length tp1 mod 2 = 0 \""], ["proof (state)\nthis:\n  steps0 (st, l, r) tp stp = (st', l', r')\n  0 < st'\n  is_even (length tp1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); 0 < st';\n     is_even (length tp1)\\<rbrakk>\n    \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r)\n                       (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n                      (st' + length tp1 div 2, l', r')", "from h"], ["proof (chain)\npicking this:\n  steps0 (st, l, r) tp stp = (st', l', r')\n  0 < st'\n  is_even (length tp1)", "have \n    \"steps (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2), 0) stp = \n                            (st' + length tp1 div 2, l', r')\""], ["proof (prove)\nusing this:\n  steps0 (st, l, r) tp stp = (st', l', r')\n  0 < st'\n  is_even (length tp1)\n\ngoal (1 subgoal):\n 1. steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2))\n     stp =\n    (st' + length tp1 div 2, l', r')", "by(rule_tac tm_append_second_steps_eq, simp_all)"], ["proof (state)\nthis:\n  steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2))\n   stp =\n  (st' + length tp1 div 2, l', r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); 0 < st';\n     is_even (length tp1)\\<rbrakk>\n    \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r)\n                       (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n                      (st' + length tp1 div 2, l', r')", "then"], ["proof (chain)\npicking this:\n  steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2))\n   stp =\n  (st' + length tp1 div 2, l', r')", "have \"steps (st + length tp1 div 2, l, r) ((tp1 @ shift tp (length tp1 div 2)) @ tp2, 0) stp = \n                            (st' + length tp1 div 2, l', r')\""], ["proof (prove)\nusing this:\n  steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2))\n   stp =\n  (st' + length tp1 div 2, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (st + length tp1 div 2, l, r)\n     ((tp1 @ shift tp (length tp1 div 2)) @ tp2) stp =\n    (st' + length tp1 div 2, l', r')", "using h"], ["proof (prove)\nusing this:\n  steps0 (st + length tp1 div 2, l, r) (tp1 @ shift tp (length tp1 div 2))\n   stp =\n  (st' + length tp1 div 2, l', r')\n  steps0 (st, l, r) tp stp = (st', l', r')\n  0 < st'\n  is_even (length tp1)\n\ngoal (1 subgoal):\n 1. steps0 (st + length tp1 div 2, l, r)\n     ((tp1 @ shift tp (length tp1 div 2)) @ tp2) stp =\n    (st' + length tp1 div 2, l', r')", "apply(rule_tac tm_append_first_steps_eq, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (st + length tp1 div 2, l, r)\n   ((tp1 @ shift tp (length tp1 div 2)) @ tp2) stp =\n  (st' + length tp1 div 2, l', r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) tp stp = (st', l', r'); 0 < st';\n     is_even (length tp1)\\<rbrakk>\n    \\<Longrightarrow> steps0 (st + length tp1 div 2, l, r)\n                       (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n                      (st' + length tp1 div 2, l', r')", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  steps0 (st + length tp1 div 2, l, r)\n   ((tp1 @ shift tp (length tp1 div 2)) @ tp2) stp =\n  (st' + length tp1 div 2, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (st + length tp1 div 2, l, r)\n     (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n    (st' + length tp1 div 2, l', r')", "by simp"], ["proof (state)\nthis:\n  steps0 (st + length tp1 div 2, l, r)\n   (tp1 @ shift tp (length tp1 div 2) @ tp2) stp =\n  (st' + length tp1 div 2, l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "declare start_of.simps[simp del]"], ["", "lemma twice_lemma: \"rec_exec rec_twice [rs] = 2*rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_twice [rs] = 2 * rs", "by(auto simp: rec_twice_def rec_exec.simps)"], ["", "lemma t_twice_correct: \n  \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n  (tm_of abc_twice @ shift (mopup (Suc 0)) ((length (tm_of abc_twice) div 2))) stp =\n  (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (tm_of abc_twice @\n         shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n        stp =\n       (0, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "proof(case_tac \"rec_ci rec_twice\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_twice = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_twice @\n            shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_twice = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_twice @\n            shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "assume h: \"rec_ci rec_twice = (a, b, c)\""], ["proof (state)\nthis:\n  rec_ci rec_twice = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_twice = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_twice @\n            shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "have \"\\<exists>stp m l. steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk\\<up>(n)) (tm_of abc_twice @ shift (mopup (length [rs])) \n    (length (tm_of abc_twice) div 2)) stp = (0, Bk\\<up>(m) @ Bk # Bk # ires, Oc\\<up>(Suc (rec_exec rec_twice [rs])) @ Bk\\<up>(l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m l.\n       steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n        (tm_of abc_twice @\n         shift (mopup (length [rs])) (length (tm_of abc_twice) div 2))\n        stp =\n       (0, Bk \\<up> m @ Bk # Bk # ires,\n        Oc \\<up> Suc (rec_exec rec_twice [rs]) @ Bk \\<up> l)", "thm  recursive_compile_to_tm_correct1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m l.\n       steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n        (tm_of abc_twice @\n         shift (mopup (length [rs])) (length (tm_of abc_twice) div 2))\n        stp =\n       (0, Bk \\<up> m @ Bk # Bk # ires,\n        Oc \\<up> Suc (rec_exec rec_twice [rs]) @ Bk \\<up> l)", "proof(rule_tac recursive_compile_to_tm_correct1)"], ["proof (state)\ngoal (3 subgoals):\n 1. rec_ci rec_twice = (?ap, ?ary, ?fp)\n 2. terminate rec_twice [rs]\n 3. tm_of abc_twice = tm_of (?ap [+] dummy_abc (length [rs]))", "show \"rec_ci rec_twice = (a, b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_ci rec_twice = (a, b, c)", "by (simp add: h)"], ["proof (state)\nthis:\n  rec_ci rec_twice = (a, b, c)\n\ngoal (2 subgoals):\n 1. terminate rec_twice [rs]\n 2. tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. terminate rec_twice [rs]\n 2. tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))", "show \"terminate rec_twice [rs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_twice [rs]", "apply(rule_tac primerec_terminate, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_twice (Suc 0)", "apply(simp add: rec_twice_def, auto simp: constn.simps numeral_2_eq_2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. primerec s ?k16\n 2. Suc 0 = ?k16\n 3. primerec s ?k19\n 4. Suc 0 = ?k19\n 5. primerec z (Suc 0)", "by(auto)"], ["proof (state)\nthis:\n  terminate rec_twice [rs]\n\ngoal (1 subgoal):\n 1. tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))", "show \"tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))", "using h"], ["proof (prove)\nusing this:\n  rec_ci rec_twice = (a, b, c)\n\ngoal (1 subgoal):\n 1. tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))", "by(simp add: abc_twice_def)"], ["proof (state)\nthis:\n  tm_of abc_twice = tm_of (a [+] dummy_abc (length [rs]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp m l.\n     steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n      (tm_of abc_twice @\n       shift (mopup (length [rs])) (length (tm_of abc_twice) div 2))\n      stp =\n     (0, Bk \\<up> m @ Bk # Bk # ires,\n      Oc \\<up> Suc (rec_exec rec_twice [rs]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_twice = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_twice @\n            shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>stp m l.\n     steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n      (tm_of abc_twice @\n       shift (mopup (length [rs])) (length (tm_of abc_twice) div 2))\n      stp =\n     (0, Bk \\<up> m @ Bk # Bk # ires,\n      Oc \\<up> Suc (rec_exec rec_twice [rs]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (tm_of abc_twice @\n         shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n        stp =\n       (0, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(simp add: tape_of_list_def tape_of_nat_def rec_exec.simps twice_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_twice @\n       shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare adjust.simps[simp]"], ["", "lemma adjust_fetch0: \n  \"\\<lbrakk>0 < a; a \\<le> length ap div 2;  fetch ap a b = (aa, 0)\\<rbrakk>\n  \\<Longrightarrow> fetch (adjust0 ap) a b = (aa, Suc (length ap div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a; a \\<le> length ap div 2; fetch ap a b = (aa, 0)\\<rbrakk>\n    \\<Longrightarrow> fetch (adjust0 ap) a b = (aa, Suc (length ap div 2))", "apply(case_tac b, auto simp: fetch.simps nth_of.simps nth_map\n      split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < a; a \\<le> length ap div 2; fetch ap a Bk = (aa, 0);\n     b = Bk\\<rbrakk>\n    \\<Longrightarrow> fetch\n                       (map (\\<lambda>(a, s).\n                                (a, if s = 0 then Suc (length ap div 2)\n                                    else s))\n                         ap)\n                       a Bk =\n                      (aa, Suc (length ap div 2))\n 2. \\<lbrakk>0 < a; a \\<le> length ap div 2; fetch ap a Oc = (aa, 0);\n     b = Oc\\<rbrakk>\n    \\<Longrightarrow> fetch\n                       (map (\\<lambda>(a, s).\n                                (a, if s = 0 then Suc (length ap div 2)\n                                    else s))\n                         ap)\n                       a Oc =\n                      (aa, Suc (length ap div 2))", "apply(case_tac [!] a, auto simp: fetch.simps nth_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma adjust_fetch_norm: \n  \"\\<lbrakk>st > 0;  st \\<le> length tp div 2; fetch ap st b = (aa, ns); ns \\<noteq> 0\\<rbrakk>\n \\<Longrightarrow>  fetch (adjust0 ap) st b = (aa, ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < st; st \\<le> length tp div 2; fetch ap st b = (aa, ns);\n     ns \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fetch (adjust0 ap) st b = (aa, ns)", "apply(case_tac b, auto simp: fetch.simps nth_of.simps nth_map\n      split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < st; st \\<le> length tp div 2; fetch ap st Bk = (aa, ns);\n     0 < ns; b = Bk\\<rbrakk>\n    \\<Longrightarrow> fetch\n                       (map (\\<lambda>(a, s).\n                                (a, if s = 0 then Suc (length ap div 2)\n                                    else s))\n                         ap)\n                       st Bk =\n                      (aa, ns)\n 2. \\<lbrakk>0 < st; st \\<le> length tp div 2; fetch ap st Oc = (aa, ns);\n     0 < ns; b = Oc\\<rbrakk>\n    \\<Longrightarrow> fetch\n                       (map (\\<lambda>(a, s).\n                                (a, if s = 0 then Suc (length ap div 2)\n                                    else s))\n                         ap)\n                       st Oc =\n                      (aa, ns)", "apply(case_tac [!] st, auto simp: fetch.simps nth_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare adjust.simps[simp del]"], ["", "lemma adjust_step_eq: \n  assumes exec: \"step0 (st,l,r) ap = (st', l', r')\"\n    and wf_tm: \"tm_wf (ap, 0)\"\n    and notfinal: \"st' > 0\"\n  shows \"step0 (st, l, r) (adjust0 ap) = (st', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step0 (st, l, r) (adjust0 ap) = (st', l', r')", "using assms"], ["proof (prove)\nusing this:\n  step0 (st, l, r) ap = (st', l', r')\n  tm_wf0 ap\n  0 < st'\n\ngoal (1 subgoal):\n 1. step0 (st, l, r) (adjust0 ap) = (st', l', r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap;\n     0 < st'\\<rbrakk>\n    \\<Longrightarrow> step0 (st, l, r) (adjust0 ap) = (st', l', r')", "have \"st > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < st", "using assms"], ["proof (prove)\nusing this:\n  step0 (st, l, r) ap = (st', l', r')\n  tm_wf0 ap\n  0 < st'\n\ngoal (1 subgoal):\n 1. 0 < st", "by(case_tac st, simp_all add: step.simps fetch.simps)"], ["proof (state)\nthis:\n  0 < st\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap;\n     0 < st'\\<rbrakk>\n    \\<Longrightarrow> step0 (st, l, r) (adjust0 ap) = (st', l', r')", "moreover"], ["proof (state)\nthis:\n  0 < st\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap;\n     0 < st'\\<rbrakk>\n    \\<Longrightarrow> step0 (st, l, r) (adjust0 ap) = (st', l', r')", "hence \"st \\<le> (length ap) div 2\""], ["proof (prove)\nusing this:\n  0 < st\n\ngoal (1 subgoal):\n 1. st \\<le> length ap div 2", "using assms"], ["proof (prove)\nusing this:\n  0 < st\n  step0 (st, l, r) ap = (st', l', r')\n  tm_wf0 ap\n  0 < st'\n\ngoal (1 subgoal):\n 1. st \\<le> length ap div 2", "apply(case_tac \"st \\<le> (length ap) div 2\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < st; step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap;\n     0 < st'; \\<not> st \\<le> length ap div 2\\<rbrakk>\n    \\<Longrightarrow> st \\<le> length ap div 2", "apply(case_tac st, auto simp: step.simps fetch.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>(case fetch ap (Suc nat) (read r) of\n                 (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                (st', l', r');\n        tm_wf0 ap; 0 < st'; \\<not> Suc nat \\<le> length ap div 2;\n        st = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"read r\", simp_all add: fetch.simps \n        nth_of.simps adjust.simps tm_wf.simps split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>\\<not> length ap \\<le> 2 * nat; 2 \\<le> length ap;\n        is_even (length ap);\n        \\<forall>x\\<in>set ap.\n           case x of (a, s) \\<Rightarrow> s \\<le> length ap div 2;\n        (case ap ! (2 * nat) of\n         (a, s') \\<Rightarrow> (s', update a (l, []))) =\n        (st', l', r');\n        0 < st'; \\<not> Suc nat \\<le> length ap div 2; st = Suc nat;\n        r = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>nat.\n       \\<lbrakk>\\<not> length ap \\<le> 2 * nat; 2 \\<le> length ap;\n        is_even (length ap);\n        \\<forall>x\\<in>set ap.\n           case x of (a, s) \\<Rightarrow> s \\<le> length ap div 2;\n        (case ap ! (2 * nat) of\n         (a, s') \\<Rightarrow> (s', update a (l, r))) =\n        (st', l', r');\n        0 < st'; \\<not> Suc nat \\<le> length ap div 2; st = Suc nat;\n        r \\<noteq> []; hd r = Bk\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp: mod_ex2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  st \\<le> length ap div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap;\n     0 < st'\\<rbrakk>\n    \\<Longrightarrow> step0 (st, l, r) (adjust0 ap) = (st', l', r')", "ultimately"], ["proof (chain)\npicking this:\n  0 < st\n  st \\<le> length ap div 2", "have \"fetch (adjust0 ap) st (read r) = fetch ap st (read r)\""], ["proof (prove)\nusing this:\n  0 < st\n  st \\<le> length ap div 2\n\ngoal (1 subgoal):\n 1. fetch (adjust0 ap) st (read r) = fetch ap st (read r)", "using assms"], ["proof (prove)\nusing this:\n  0 < st\n  st \\<le> length ap div 2\n  step0 (st, l, r) ap = (st', l', r')\n  tm_wf0 ap\n  0 < st'\n\ngoal (1 subgoal):\n 1. fetch (adjust0 ap) st (read r) = fetch ap st (read r)", "apply(case_tac \"fetch ap st (read r)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>0 < st; st \\<le> length ap div 2;\n        step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap; 0 < st';\n        fetch ap st (read r) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fetch (adjust0 ap) st (read r) =\n                         fetch ap st (read r)", "apply(drule_tac adjust_fetch_norm, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>st \\<le> length ap div 2;\n        step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap; 0 < st';\n        fetch ap st (read r) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> 0 < b", "apply(simp add: step.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fetch (adjust0 ap) st (read r) = fetch ap st (read r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>step0 (st, l, r) ap = (st', l', r'); tm_wf0 ap;\n     0 < st'\\<rbrakk>\n    \\<Longrightarrow> step0 (st, l, r) (adjust0 ap) = (st', l', r')", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  fetch (adjust0 ap) st (read r) = fetch ap st (read r)\n\ngoal (1 subgoal):\n 1. step0 (st, l, r) (adjust0 ap) = (st', l', r')", "using exec"], ["proof (prove)\nusing this:\n  fetch (adjust0 ap) st (read r) = fetch ap st (read r)\n  step0 (st, l, r) ap = (st', l', r')\n\ngoal (1 subgoal):\n 1. step0 (st, l, r) (adjust0 ap) = (st', l', r')", "by(simp add: step.simps)"], ["proof (state)\nthis:\n  step0 (st, l, r) (adjust0 ap) = (st', l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "declare adjust.simps[simp del]"], ["", "lemma adjust_steps_eq: \n  assumes exec: \"steps0 (st,l,r) ap stp = (st', l', r')\"\n    and wf_tm: \"tm_wf (ap, 0)\"\n    and notfinal: \"st' > 0\"\n  shows \"steps0 (st, l, r) (adjust0 ap) stp = (st', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) stp = (st', l', r')", "using exec notfinal"], ["proof (prove)\nusing this:\n  steps0 (st, l, r) ap stp = (st', l', r')\n  0 < st'\n\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) stp = (st', l', r')", "proof(induct stp arbitrary: st' l' r')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>st' l' r'.\n       \\<lbrakk>steps0 (st, l, r) ap 0 = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) 0 = (st', l', r')\n 2. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "case 0"], ["proof (state)\nthis:\n  steps0 (st, l, r) ap 0 = (st', l', r')\n  0 < st'\n\ngoal (2 subgoals):\n 1. \\<And>st' l' r'.\n       \\<lbrakk>steps0 (st, l, r) ap 0 = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) 0 = (st', l', r')\n 2. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "thus \"?case\""], ["proof (prove)\nusing this:\n  steps0 (st, l, r) ap 0 = (st', l', r')\n  0 < st'\n\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) 0 = (st', l', r')", "by(simp add: steps.simps)"], ["proof (state)\nthis:\n  steps0 (st, l, r) (adjust0 ap) 0 = (st', l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "case (Suc stp st' l' r')"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (st, l, r) ap stp = (?st', ?l', ?r'); 0 < ?st'\\<rbrakk>\n  \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp = (?st', ?l', ?r')\n  steps0 (st, l, r) ap (Suc stp) = (st', l', r')\n  0 < st'\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "have ind: \"\\<And>st' l' r'. \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r'); 0 < st'\\<rbrakk> \n    \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp = (st', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>st' l' r'.\n       \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp = (st', l', r')", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (st, l, r) ap stp = (?st', ?l', ?r'); 0 < ?st'\\<rbrakk>\n  \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp = (?st', ?l', ?r')\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "have h: \"steps0 (st, l, r) ap (Suc stp) = (st', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (st, l, r) ap (Suc stp) = (st', l', r')", "by fact"], ["proof (state)\nthis:\n  steps0 (st, l, r) ap (Suc stp) = (st', l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "have g:   \"0 < st'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < st'", "by fact"], ["proof (state)\nthis:\n  0 < st'\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "obtain st'' l'' r'' where a: \"steps0 (st, l, r) ap stp = (st'', l'', r'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st'' l'' r''.\n        steps0 (st, l, r) ap stp = (st'', l'', r'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  steps0 (st, l, r) ap stp = (st'', l'', r'')\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "hence c:\"0 < st''\""], ["proof (prove)\nusing this:\n  steps0 (st, l, r) ap stp = (st'', l'', r'')\n\ngoal (1 subgoal):\n 1. 0 < st''", "using h g"], ["proof (prove)\nusing this:\n  steps0 (st, l, r) ap stp = (st'', l'', r'')\n  steps0 (st, l, r) ap (Suc stp) = (st', l', r')\n  0 < st'\n\ngoal (1 subgoal):\n 1. 0 < st''", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) ap stp = (st'', l'', r'');\n     step0 (st'', l'', r'') ap = (st', l', r'); 0 < st'\\<rbrakk>\n    \\<Longrightarrow> 0 < st''", "apply(case_tac st'', auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < st''\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "hence b: \"steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')\""], ["proof (prove)\nusing this:\n  0 < st''\n\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')", "using a"], ["proof (prove)\nusing this:\n  0 < st''\n  steps0 (st, l, r) ap stp = (st'', l'', r'')\n\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')", "by(rule_tac ind, simp_all)"], ["proof (state)\nthis:\n  steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')\n\ngoal (1 subgoal):\n 1. \\<And>stp st' l' r'.\n       \\<lbrakk>\\<And>st' l' r'.\n                   \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r');\n                    0 < st'\\<rbrakk>\n                   \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) stp =\n                                     (st', l', r');\n        steps0 (st, l, r) ap (Suc stp) = (st', l', r'); 0 < st'\\<rbrakk>\n       \\<Longrightarrow> steps0 (st, l, r) (adjust0 ap) (Suc stp) =\n                         (st', l', r')", "thus \"?case\""], ["proof (prove)\nusing this:\n  steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')\n\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) (Suc stp) = (st', l', r')", "using assms a b h g"], ["proof (prove)\nusing this:\n  steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')\n  steps0 (st, l, r) ap stp = (st', l', r')\n  tm_wf0 ap\n  0 < st'\n  steps0 (st, l, r) ap stp = (st'', l'', r'')\n  steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'')\n  steps0 (st, l, r) ap (Suc stp) = (st', l', r')\n  0 < st'\n\ngoal (1 subgoal):\n 1. steps0 (st, l, r) (adjust0 ap) (Suc stp) = (st', l', r')", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) ap stp = (st', l', r'); tm_wf0 ap; 0 < st';\n     steps0 (st, l, r) ap stp = (st'', l'', r'');\n     steps0 (st, l, r) (adjust0 ap) stp = (st'', l'', r'');\n     step0 (st'', l'', r'') ap = (st', l', r'); 0 < st'\\<rbrakk>\n    \\<Longrightarrow> step0 (st'', l'', r'') (adjust0 ap) = (st', l', r')", "apply(rule_tac adjust_step_eq, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (st, l, r) (adjust0 ap) (Suc stp) = (st', l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adjust_halt_eq:\n  assumes exec: \"steps0 (1, l, r) ap stp = (0, l', r')\"\n    and tm_wf: \"tm_wf (ap, 0)\" \n  shows \"\\<exists> stp. steps0 (Suc 0, l, r) (adjust0 ap) stp = \n        (Suc (length ap div 2), l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "have \"\\<exists> stp. \\<not> is_final (steps0 (1, l, r) ap stp) \\<and> (steps0 (1, l, r) ap (Suc stp) = (0, l', r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       \\<not> is_final (steps0 (1, l, r) ap stp) \\<and>\n       steps0 (1, l, r) ap (Suc stp) = (0, l', r')", "using exec"], ["proof (prove)\nusing this:\n  steps0 (1, l, r) ap stp = (0, l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       \\<not> is_final (steps0 (1, l, r) ap stp) \\<and>\n       steps0 (1, l, r) ap (Suc stp) = (0, l', r')", "by(erule_tac before_final)"], ["proof (state)\nthis:\n  \\<exists>stp.\n     \\<not> is_final (steps0 (1, l, r) ap stp) \\<and>\n     steps0 (1, l, r) ap (Suc stp) = (0, l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp.\n     \\<not> is_final (steps0 (1, l, r) ap stp) \\<and>\n     steps0 (1, l, r) ap (Suc stp) = (0, l', r')", "obtain stpa where a: \n    \"\\<not> is_final (steps0 (1, l, r) ap stpa) \\<and> (steps0 (1, l, r) ap (Suc stpa) = (0, l', r'))\""], ["proof (prove)\nusing this:\n  \\<exists>stp.\n     \\<not> is_final (steps0 (1, l, r) ap stp) \\<and>\n     steps0 (1, l, r) ap (Suc stp) = (0, l', r')\n\ngoal (1 subgoal):\n 1. (\\<And>stpa.\n        \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n        steps0 (1, l, r) ap (Suc stpa) = (0, l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "obtain sa la ra where b:\"steps0 (1, l, r) ap stpa = (sa, la, ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa la ra.\n        steps0 (1, l, r) ap stpa = (sa, la, ra) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "hence c: \"steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)\""], ["proof (prove)\nusing this:\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)", "using assms a"], ["proof (prove)\nusing this:\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n  steps0 (1, l, r) ap stp = (0, l', r')\n  tm_wf0 ap\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)", "apply(rule_tac adjust_steps_eq, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "have d: \"sa \\<le> length ap div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa \\<le> length ap div 2", "using steps_in_range[of  \"(l, r)\" ap stpa] a tm_wf b"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> is_final (steps0 (1, l, r) ap stpa); tm_wf0 ap\\<rbrakk>\n  \\<Longrightarrow> fst (steps0 (1, l, r) ap stpa) \\<le> length ap div 2\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n  tm_wf0 ap\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. sa \\<le> length ap div 2", "by(simp)"], ["proof (state)\nthis:\n  sa \\<le> length ap div 2\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "obtain ac ns where e: \"fetch ap sa (read ra) = (ac, ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ac ns.\n        fetch ap sa (read ra) = (ac, ns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  fetch ap sa (read ra) = (ac, ns)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "hence f: \"ns = 0\""], ["proof (prove)\nusing this:\n  fetch ap sa (read ra) = (ac, ns)\n\ngoal (1 subgoal):\n 1. ns = 0", "using b a"], ["proof (prove)\nusing this:\n  fetch ap sa (read ra) = (ac, ns)\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n\ngoal (1 subgoal):\n 1. ns = 0", "apply(simp add: step_red step.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ns = 0\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "have k: \"fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2))", "using a b c d e f"], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n  steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)\n  sa \\<le> length ap div 2\n  fetch ap sa (read ra) = (ac, ns)\n  ns = 0\n\ngoal (1 subgoal):\n 1. fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2))", "apply(rule_tac adjust_fetch0, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2))\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "from a b e f k and c"], ["proof (chain)\npicking this:\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n  fetch ap sa (read ra) = (ac, ns)\n  ns = 0\n  fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2))\n  steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n  steps0 (1, l, r) ap (Suc stpa) = (0, l', r')\n  steps0 (1, l, r) ap stpa = (sa, la, ra)\n  fetch ap sa (read ra) = (ac, ns)\n  ns = 0\n  fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2))\n  steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, l, r) (adjust0 ap) stp =\n       (Suc (length ap div 2), l', r')", "apply(rule_tac x = \"Suc stpa\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) ap stpa) \\<and>\n             steps0 (1, l, r) ap (Suc stpa) = (0, l', r');\n     steps0 (1, l, r) ap stpa = (sa, la, ra);\n     fetch ap sa (read ra) = (ac, ns); ns = 0;\n     fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2));\n     steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra)\\<rbrakk>\n    \\<Longrightarrow> steps0 (Suc 0, l, r) (adjust0 ap) (Suc stpa) =\n                      (Suc (length ap div 2), l', r')", "apply(simp add: step_red, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, l, r) ap stpa = (sa, la, ra);\n     fetch ap sa (read ra) = (ac, 0); ns = 0;\n     fetch (adjust0 ap) sa (read ra) = (ac, Suc (length ap div 2));\n     steps0 (Suc 0, l, r) (adjust0 ap) stpa = (sa, la, ra); 0 < sa;\n     step0 (sa, la, ra) ap = (0, l', r')\\<rbrakk>\n    \\<Longrightarrow> step0 (sa, la, ra) (adjust0 ap) =\n                      (Suc (length ap div 2), l', r')", "apply(simp add: step.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     steps0 (Suc 0, l, r) (adjust0 ap) stp = (Suc (length ap div 2), l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "declare tm_wf.simps[simp del]"], ["", "lemma tm_wf_t_twice_compile [simp]: \"tm_wf (t_twice_compile, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_twice_compile", "apply(simp only: t_twice_compile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0\n     (tm_of abc_twice @ shift (mopup 1) (length (tm_of abc_twice) div 2))", "apply(rule_tac wf_tm_from_abacus, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_twice_change_term_state:\n  \"\\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_twice stp\n     = (Suc t_twice_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "have \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n    (tm_of abc_twice @ shift (mopup (Suc 0)) ((length (tm_of abc_twice) div 2))) stp =\n    (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (tm_of abc_twice @\n         shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n        stp =\n       (0, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "by(rule_tac t_twice_correct)"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_twice @\n       shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_twice @\n       shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "obtain stp ln rn where \" steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n    (tm_of abc_twice @ shift (mopup (Suc 0)) ((length (tm_of abc_twice) div 2))) stp =\n    (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_twice @\n       shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stp ln rn.\n        steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n         (tm_of abc_twice @\n          shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n         stp =\n        (0, Bk \\<up> ln @ Bk # Bk # ires,\n         Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (tm_of abc_twice @\n    shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n   stp =\n  (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "hence \"\\<exists> stp. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n    (adjust0 t_twice_compile) stp\n     = (Suc (length t_twice_compile div 2), Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (tm_of abc_twice @\n    shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n   stp =\n  (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (adjust0 t_twice_compile) stp =\n       (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(rule_tac stp = stp in adjust_halt_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     (tm_of abc_twice @\n      shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n     stp =\n    (0, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    steps0 (1, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice_compile\n     stp =\n    (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n 2. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     (tm_of abc_twice @\n      shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n     stp =\n    (0, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    tm_wf0 t_twice_compile", "apply(simp add: t_twice_compile_def, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (adjust0 t_twice_compile) stp =\n     (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (adjust0 t_twice_compile) stp =\n     (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "obtain stpb where \n    \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n    (adjust0 t_twice_compile) stpb\n     = (Suc (length t_twice_compile div 2), Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (adjust0 t_twice_compile) stp =\n     (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb.\n        steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n         (adjust0 t_twice_compile) stpb =\n        (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n         Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (adjust0 t_twice_compile) stpb =\n  (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n   Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (adjust0 t_twice_compile) stpb =\n  (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n   Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(simp add: t_twice_def t_twice_len_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> n)\n     (adjust0 t_twice_compile) stpb =\n    (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n     Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> n)\n        (adjust0 t_twice_compile) stp =\n       (Suc (length t_twice_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n        Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)", "by metis"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n      stp =\n     (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_t_wcode_main_first_part_even[intro]: \"length t_wcode_main_first_part mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length t_wcode_main_first_part)", "apply(auto simp: t_wcode_main_first_part_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_twice_append_pre:\n  \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_twice stp\n  = (Suc t_twice_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\n   \\<Longrightarrow> steps0 (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n     (t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n      ([(L, 1), (L, 1)] @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])) stp \n    = (Suc (t_twice_len) + length t_wcode_main_first_part div 2, \n             Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n     stp =\n    (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    steps0\n     (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n      Oc \\<up> Suc rs @ Bk \\<up> n)\n     (t_wcode_main_first_part @\n      shift t_twice (length t_wcode_main_first_part div 2) @\n      [(L, 1), (L, 1)] @\n      shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n     stp =\n    (Suc t_twice_len + length t_wcode_main_first_part div 2,\n     Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "by(rule_tac tm_append_shift_append_steps, auto)"], ["", "lemma t_twice_append:\n  \"\\<exists> stp ln rn. steps0 (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n     (t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n      ([(L, 1), (L, 1)] @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])) stp \n    = (Suc (t_twice_len) + length t_wcode_main_first_part div 2, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n         Oc \\<up> Suc rs @ Bk \\<up> n)\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)] @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_twice_len + length t_wcode_main_first_part div 2,\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "using t_twice_change_term_state[of ires rs n]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n      stp =\n     (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n         Oc \\<up> Suc rs @ Bk \\<up> n)\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)] @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_twice_len + length t_wcode_main_first_part div 2,\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<exists>ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_twice stp =\n          (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n            Oc \\<up> Suc rs @ Bk \\<up> n)\n           (t_wcode_main_first_part @\n            shift t_twice (length t_wcode_main_first_part div 2) @\n            [(L, 1), (L, 1)] @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_twice_len + length t_wcode_main_first_part div 2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln.\n       \\<exists>rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_twice stp =\n          (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n            Oc \\<up> Suc rs @ Bk \\<up> n)\n           (t_wcode_main_first_part @\n            shift t_twice (length t_wcode_main_first_part div 2) @\n            [(L, 1), (L, 1)] @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_twice_len + length t_wcode_main_first_part div 2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_twice\n        stp =\n       (Suc t_twice_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n            Oc \\<up> Suc rs @ Bk \\<up> n)\n           (t_wcode_main_first_part @\n            shift t_twice (length t_wcode_main_first_part div 2) @\n            [(L, 1), (L, 1)] @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_twice_len + length t_wcode_main_first_part div 2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(drule_tac t_twice_append_pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n         Oc \\<up> Suc rs @ Bk \\<up> n)\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)] @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_twice_len + length t_wcode_main_first_part div 2,\n        Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n            Oc \\<up> Suc rs @ Bk \\<up> n)\n           (t_wcode_main_first_part @\n            shift t_twice (length t_wcode_main_first_part div 2) @\n            [(L, 1), (L, 1)] @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_twice_len + length t_wcode_main_first_part div 2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(rename_tac stp ln rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n         Oc \\<up> Suc rs @ Bk \\<up> n)\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)] @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_twice_len + length t_wcode_main_first_part div 2,\n        Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n            Oc \\<up> Suc rs @ Bk \\<up> n)\n           (t_wcode_main_first_part @\n            shift t_twice (length t_wcode_main_first_part div 2) @\n            [(L, 1), (L, 1)] @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_twice_len + length t_wcode_main_first_part div 2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(rule_tac x = stp in exI, rule_tac x = ln in exI, rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n         Oc \\<up> Suc rs @ Bk \\<up> n)\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)] @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_twice_len + length t_wcode_main_first_part div 2,\n        Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       steps0\n        (Suc 0 + length t_wcode_main_first_part div 2, Bk # Bk # ires,\n         Oc \\<up> Suc rs @ Bk \\<up> n)\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)] @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_twice_len + length t_wcode_main_first_part div 2,\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mopup_mod2: \"length (mopup k) mod 2  = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (mopup k))", "by(auto simp: mopup.simps)"], ["", "lemma fetch_t_wcode_main_Oc[simp]: \"fetch t_wcode_main (Suc (t_twice_len + length t_wcode_main_first_part div 2)) Oc\n     = (L, Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch t_wcode_main\n     (Suc (t_twice_len + length t_wcode_main_first_part div 2)) Oc =\n    (L, Suc 0)", "apply(subgoal_tac \"length (t_twice) mod 2 = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_even (length t_twice) \\<Longrightarrow>\n    fetch t_wcode_main\n     (Suc (t_twice_len + length t_wcode_main_first_part div 2)) Oc =\n    (L, Suc 0)\n 2. is_even (length t_twice)", "apply(simp add: t_wcode_main_def nth_append fetch.simps t_wcode_main_first_part_def \n      nth_of.simps t_twice_len_def, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length t_twice)", "apply(simp add: t_twice_def t_twice_compile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (mopup (Suc 0)))", "using mopup_mod2[of 1]"], ["proof (prove)\nusing this:\n  is_even (length (mopup 1))\n\ngoal (1 subgoal):\n 1. is_even (length (mopup (Suc 0)))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_jump1: \n  \"\\<exists> stp ln rn. steps0 (Suc (t_twice_len) + length t_wcode_main_first_part div 2,\n                       Bk\\<up>(m) @ Bk # Bk # ires, Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(n))\n     t_wcode_main stp \n    = (Suc 0, Bk\\<up>(ln) @ Bk # ires, Bk # Oc\\<up>(Suc (2 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc t_twice_len + length t_wcode_main_first_part div 2,\n         Bk \\<up> m @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk \\<up> ln @ Bk # ires,\n        Bk # Oc \\<up> Suc (2 * rs) @ Bk \\<up> rn)", "apply(rule_tac x = \"Suc 0\" in exI, rule_tac x = \"m\" in exI, rule_tac x = n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0\n     (Suc t_twice_len + length t_wcode_main_first_part div 2,\n      Bk \\<up> m @ Bk # Bk # ires, Oc \\<up> Suc (2 * rs) @ Bk \\<up> n)\n     t_wcode_main (Suc 0) =\n    (Suc 0, Bk \\<up> m @ Bk # ires, Bk # Oc \\<up> Suc (2 * rs) @ Bk \\<up> n)", "apply(simp add: steps.simps step.simps exp_ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (Bk \\<up> m @ Bk # Bk # ires) = Bk \\<up> m @ Bk # ires \\<and>\n    hd (Bk \\<up> m @ Bk # Bk # ires) = Bk", "apply(case_tac m, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       m = Suc nat \\<Longrightarrow> Bk \\<up> nat @ [Bk] = Bk # Bk \\<up> nat", "apply(simp add: exp_ind[THEN sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_main_first_part_len[simp]:\n  \"length t_wcode_main_first_part = 24\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t_wcode_main_first_part = 24", "apply(simp add: t_wcode_main_first_part_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_double_case: \n  shows \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n          (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (2 * rs + 2)) @ Bk\\<up>(rn))\"\n    (is \"\\<exists>stp ln rn. ?tm stp ln rn\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from wcode_double_case_first_correctness[of ires rs m n]"], ["proof (chain)\npicking this:\n  let P = \\<lambda>(st, l, r). st = 13;\n      Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)", "obtain na ln rn where\n    \"steps0 (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires, Bk # Oc # Oc \\<up> rs @ Bk \\<up> n) t_wcode_main na\n      = (13, Bk # Bk # Bk \\<up> ln @ Oc # ires, Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn)\""], ["proof (prove)\nusing this:\n  let P = \\<lambda>(st, l, r). st = 13;\n      Q = \\<lambda>(st, l, r). wcode_double_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal (1 subgoal):\n 1. (\\<And>na ln rn.\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n         t_wcode_main na =\n        (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n         Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: wcode_double_case_inv.simps wcode_before_double.simps)"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n   t_wcode_main na =\n  (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n   Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "hence \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n          (13,  Bk # Bk # Bk\\<up>(ln) @ Oc # ires, Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n   t_wcode_main na =\n  (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n   Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "by(case_tac \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, \n           Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main na\", auto)"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "obtain stpa lna rna where stp1: \n    \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stpa = \n    (13, Bk # Bk # Bk\\<up>(lna) @ Oc # ires, Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rna))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (13, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpa lna rna.\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main stpa =\n        (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from t_twice_append[of \"Bk\\<up>(lna) @ Oc # ires\" \"Suc rs\" rna]"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0 + length t_wcode_main_first_part div 2,\n       Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n      (t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)] @\n       shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n      stp =\n     (Suc t_twice_len + length t_wcode_main_first_part div 2,\n      Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n      Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)", "obtain stp ln rn\n    where \"steps0 (Suc 0 + length t_wcode_main_first_part div 2,\n                   Bk # Bk # Bk \\<up> lna @ Oc # ires, Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n                  (t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n                   [(L, 1), (L, 1)] @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)]) stp =\n           (Suc t_twice_len + length t_wcode_main_first_part div 2, \n            Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires, Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0 + length t_wcode_main_first_part div 2,\n       Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n      (t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)] @\n       shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n      stp =\n     (Suc t_twice_len + length t_wcode_main_first_part div 2,\n      Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n      Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stp ln rn.\n        steps0\n         (Suc 0 + length t_wcode_main_first_part div 2,\n          Bk # Bk # Bk \\<up> lna @ Oc # ires,\n          Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)] @\n          shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n         stp =\n        (Suc t_twice_len + length t_wcode_main_first_part div 2,\n         Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0 + length t_wcode_main_first_part div 2,\n    Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n   (t_wcode_main_first_part @\n    shift t_twice (length t_wcode_main_first_part div 2) @\n    [(L, 1), (L, 1)] @\n    shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n   stp =\n  (Suc t_twice_len + length t_wcode_main_first_part div 2,\n   Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "hence \"\\<exists> stp ln rn. steps0 (13, Bk # Bk # Bk\\<up>(lna) @ Oc # ires, Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rna)) t_wcode_main stp =\n    (13 + t_twice_len, Bk # Bk # Bk\\<up>(ln) @ Oc # ires, Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0 + length t_wcode_main_first_part div 2,\n    Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n   (t_wcode_main_first_part @\n    shift t_twice (length t_wcode_main_first_part div 2) @\n    [(L, 1), (L, 1)] @\n    shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n   stp =\n  (Suc t_twice_len + length t_wcode_main_first_part div 2,\n   Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (13 + t_twice_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "using t_twice_append[of \"Bk\\<up>(lna) @ Oc # ires\" \"Suc rs\" rna]"], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0 + length t_wcode_main_first_part div 2,\n    Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n   (t_wcode_main_first_part @\n    shift t_twice (length t_wcode_main_first_part div 2) @\n    [(L, 1), (L, 1)] @\n    shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n   stp =\n  (Suc t_twice_len + length t_wcode_main_first_part div 2,\n   Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0 + length t_wcode_main_first_part div 2,\n       Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n      (t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)] @\n       shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n      stp =\n     (Suc t_twice_len + length t_wcode_main_first_part div 2,\n      Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n      Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (13 + t_twice_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n               Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n              (t_wcode_main_first_part @\n               shift t_twice 12 @\n               (L, Suc 0) #\n               (L, Suc 0) #\n               shift t_fourtimes (t_twice_len + 13) @\n               [(L, Suc 0), (L, Suc 0)])\n              stp =\n             (13 + t_twice_len,\n              Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n              Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn);\n     \\<exists>stp ln rn.\n        steps0\n         (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n          Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n         (t_wcode_main_first_part @\n          shift t_twice 12 @\n          (L, Suc 0) #\n          (L, Suc 0) #\n          shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n         stp =\n        (13 + t_twice_len, Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp ln rn.\n                         steps0\n                          (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n                           Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n                          t_wcode_main stp =\n                         (13 + t_twice_len,\n                          Bk # Bk # Bk \\<up> ln @ Oc # ires,\n                          Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)", "apply(rule_tac x = stp in exI, rule_tac x = \"ln + lna\" in exI, \n        rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n               Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n              (t_wcode_main_first_part @\n               shift t_twice 12 @\n               (L, Suc 0) #\n               (L, Suc 0) #\n               shift t_fourtimes (t_twice_len + 13) @\n               [(L, Suc 0), (L, Suc 0)])\n              stp =\n             (13 + t_twice_len,\n              Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n              Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn);\n     \\<exists>stp ln rn.\n        steps0\n         (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n          Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n         (t_wcode_main_first_part @\n          shift t_twice 12 @\n          (L, Suc 0) #\n          (L, Suc 0) #\n          shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n         stp =\n        (13 + t_twice_len, Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)\\<rbrakk>\n    \\<Longrightarrow> steps0\n                       (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n                        Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n                       t_wcode_main stp =\n                      (13 + t_twice_len,\n                       Bk # Bk # Bk \\<up> (ln + lna) @ Oc # ires,\n                       Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)", "apply(simp add: t_wcode_main_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n               Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n              (t_wcode_main_first_part @\n               shift t_twice 12 @\n               (L, Suc 0) #\n               (L, Suc 0) #\n               shift t_fourtimes (t_twice_len + 13) @\n               [(L, Suc 0), (L, Suc 0)])\n              stp =\n             (13 + t_twice_len,\n              Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n              Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn);\n     \\<exists>stp ln rn.\n        steps0\n         (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n          Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n         (t_wcode_main_first_part @\n          shift t_twice 12 @\n          (L, Suc 0) #\n          (L, Suc 0) #\n          shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n         stp =\n        (13 + t_twice_len, Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)\\<rbrakk>\n    \\<Longrightarrow> Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna =\n                      Bk # Bk # Bk \\<up> (ln + lna)", "apply(simp add: replicate_Suc[THEN sym] replicate_add [THEN sym] del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (13 + t_twice_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (13 + t_twice_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "obtain stpb lnb rnb where stp2: \n    \"steps0 (13, Bk # Bk # Bk\\<up>(lna) @ Oc # ires, Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rna)) t_wcode_main stpb =\n    (13 + t_twice_len, Bk # Bk # Bk\\<up>(lnb) @ Oc # ires, Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rnb))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (13 + t_twice_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb lnb rnb.\n        steps0\n         (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n          Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n         t_wcode_main stpb =\n        (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n   Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from wcode_jump1[of lnb \"Oc # ires\" \"Suc rs\" rnb]"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc t_twice_len + length t_wcode_main_first_part div 2,\n       Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n       Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n      Bk # Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)", "obtain stp ln rn where\n    \"steps0 (Suc t_twice_len + length t_wcode_main_first_part div 2, \n             Bk \\<up> lnb @ Bk # Bk # Oc # ires, Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rnb) t_wcode_main stp =\n     (Suc 0, Bk \\<up> ln @ Bk # Oc # ires, Bk # Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc t_twice_len + length t_wcode_main_first_part div 2,\n       Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n       Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n      Bk # Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stp ln rn.\n        steps0\n         (Suc t_twice_len + length t_wcode_main_first_part div 2,\n          Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n          Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rnb)\n         t_wcode_main stp =\n        (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n         Bk # Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  steps0\n   (Suc t_twice_len + length t_wcode_main_first_part div 2,\n    Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n    Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rnb)\n   t_wcode_main stp =\n  (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n   Bk # Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "hence \"steps0 (13 + t_twice_len, Bk # Bk # Bk\\<up>(lnb) @ Oc # ires,\n    Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rnb)) t_wcode_main stp = \n       (Suc 0,  Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc t_twice_len + length t_wcode_main_first_part div 2,\n    Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n    Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rnb)\n   t_wcode_main stp =\n  (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n   Bk # Oc \\<up> Suc (2 * Suc rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. steps0\n     (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n      Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n     t_wcode_main stp =\n    (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n     Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "apply(auto simp add: t_wcode_main_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0\n     (13 + t_twice_len, Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n      Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rnb)\n     (t_wcode_main_first_part @\n      shift t_twice 12 @\n      (L, Suc 0) #\n      (L, Suc 0) #\n      shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n     stp =\n    (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n     Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    steps0\n     (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n      Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rnb)\n     (t_wcode_main_first_part @\n      shift t_twice 12 @\n      (L, Suc 0) #\n      (L, Suc 0) #\n      shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n     stp =\n    (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n     Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn)", "apply(subgoal_tac \"Bk\\<up>(lnb) @ Bk # Bk # Oc # ires = Bk # Bk # Bk\\<up>(lnb) @ Oc # ires\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>steps0\n              (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n               Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rnb)\n              (t_wcode_main_first_part @\n               shift t_twice 12 @\n               (L, Suc 0) #\n               (L, Suc 0) #\n               shift t_fourtimes (t_twice_len + 13) @\n               [(L, Suc 0), (L, Suc 0)])\n              stp =\n             (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n              Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn);\n     Bk \\<up> lnb @ [Bk, Bk] = Bk # Bk # Bk \\<up> lnb\\<rbrakk>\n    \\<Longrightarrow> Bk \\<up> ln @ [Bk] = Bk # Bk \\<up> ln\n 2. steps0\n     (13 + t_twice_len, Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n      Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rnb)\n     (t_wcode_main_first_part @\n      shift t_twice 12 @\n      (L, Suc 0) #\n      (L, Suc 0) #\n      shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n     stp =\n    (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n     Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    Bk \\<up> lnb @ Bk # Bk # Oc # ires = Bk # Bk # Bk \\<up> lnb @ Oc # ires", "apply(simp add: replicate_Suc[THEN sym] exp_ind[THEN sym] del: replicate_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0\n     (13 + t_twice_len, Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n      Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rnb)\n     (t_wcode_main_first_part @\n      shift t_twice 12 @\n      (L, Suc 0) #\n      (L, Suc 0) #\n      shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n     stp =\n    (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n     Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    Bk \\<up> lnb @ Bk # Bk # Oc # ires = Bk # Bk # Bk \\<up> lnb @ Oc # ires", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0\n     (13 + t_twice_len, Bk \\<up> lnb @ Bk # Bk # Oc # ires,\n      Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rnb)\n     (t_wcode_main_first_part @\n      shift t_twice 12 @\n      (L, Suc 0) #\n      (L, Suc 0) #\n      shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n     stp =\n    (Suc 0, Bk \\<up> ln @ Bk # Oc # ires,\n     Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    Bk \\<up> lnb @ [Bk, Bk] = Bk # Bk # Bk \\<up> lnb", "apply(simp add: replicate_Suc[THEN sym] exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0\n   (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n   t_wcode_main stp =\n  (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n   Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "hence \"\\<exists>stp ln rn. steps0 (13 + t_twice_len, Bk # Bk # Bk\\<up>(lnb) @ Oc # ires,\n    Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rnb)) t_wcode_main stp = \n       (Suc 0,  Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0\n   (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n   t_wcode_main stp =\n  (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n   Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "by blast"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "obtain stpc lnc rnc where stp3: \n    \"steps0 (13 + t_twice_len, Bk # Bk # Bk\\<up>(lnb) @ Oc # ires,\n    Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rnb)) t_wcode_main stpc = \n       (Suc 0,  Bk # Bk\\<up>(lnc) @ Oc # ires, Bk # Oc\\<up>(Suc (Suc (Suc (2 *rs)))) @ Bk\\<up>(rnc))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpc lnc rnc.\n        steps0\n         (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n          Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n         t_wcode_main stpc =\n        (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n         Bk #\n         Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n   t_wcode_main stpc =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnc)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "from stp1 stp2 stp3"], ["proof (chain)\npicking this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n  steps0\n   (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n   Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n  steps0\n   (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n   t_wcode_main stpc =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnc)", "have \"?tm (stpa + stpb + stpc) lnc rnc\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n  steps0\n   (13, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (Suc rs) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n   Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n  steps0\n   (13 + t_twice_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnb)\n   t_wcode_main stpc =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rnc)\n\ngoal (1 subgoal):\n 1. steps0\n     (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n     t_wcode_main (stpa + stpb + stpc) =\n    (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n     Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rnc)", "by simp"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main (stpa + stpb + stpc) =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rnc)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main (stpa + stpb + stpc) =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rnc)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "by blast"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Begin: fourtime_case*)"], ["", "fun wcode_on_left_moving_2_B :: \"bin_inv_t\"\n  where\n    \"wcode_on_left_moving_2_B ires rs (l, r) =\n     (\\<exists> ml mr rn. l = Bk\\<up>(ml) @ Oc # Bk # Oc # ires \\<and>\n                 r = Bk\\<up>(mr) @ Oc\\<up>(Suc rs) @ Bk\\<up>(rn) \\<and> \n                 ml + mr > Suc 0 \\<and> mr > 0)\""], ["", "fun wcode_on_left_moving_2_O :: \"bin_inv_t\"\n  where\n    \"wcode_on_left_moving_2_O ires rs (l, r) =\n     (\\<exists> ln rn. l = Bk # Oc # ires \\<and>\n               r = Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_on_left_moving_2 :: \"bin_inv_t\"\n  where\n    \"wcode_on_left_moving_2 ires rs (l, r) = \n      (wcode_on_left_moving_2_B ires rs (l, r) \\<or> \n      wcode_on_left_moving_2_O ires rs (l, r))\""], ["", "fun wcode_on_checking_2 :: \"bin_inv_t\"\n  where\n    \"wcode_on_checking_2 ires rs (l, r) =\n       (\\<exists> ln rn. l = Oc#ires \\<and> \n                 r = Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_goon_checking :: \"bin_inv_t\"\n  where\n    \"wcode_goon_checking ires rs (l, r) =\n       (\\<exists> ln rn. l = ires \\<and>\n                 r = Oc # Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_right_move :: \"bin_inv_t\"\n  where\n    \"wcode_right_move ires rs (l, r) = \n     (\\<exists> ln rn. l = Oc # ires \\<and>\n                 r = Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_erase2 :: \"bin_inv_t\"\n  where\n    \"wcode_erase2 ires rs (l, r) = \n        (\\<exists> ln rn. l = Bk # Oc # ires \\<and>\n                 tl r = Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_on_right_moving_2 :: \"bin_inv_t\"\n  where\n    \"wcode_on_right_moving_2 ires rs (l, r) = \n        (\\<exists> ml mr rn. l = Bk\\<up>(ml) @ Oc # ires \\<and> \n                     r = Bk\\<up>(mr) @ Oc\\<up>(Suc rs) @ Bk\\<up>(rn) \\<and> ml + mr > Suc 0)\""], ["", "fun wcode_goon_right_moving_2 :: \"bin_inv_t\"\n  where\n    \"wcode_goon_right_moving_2 ires rs (l, r) = \n        (\\<exists> ml mr ln rn. l = Oc\\<up>(ml) @ Bk # Bk # Bk\\<up>(ln) @ Oc # ires \\<and>\n                        r = Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and> ml + mr = Suc rs)\""], ["", "fun wcode_backto_standard_pos_2_B :: \"bin_inv_t\"\n  where\n    \"wcode_backto_standard_pos_2_B ires rs (l, r) = \n           (\\<exists> ln rn. l = Bk # Bk\\<up>(ln) @ Oc # ires \\<and> \n                     r = Bk # Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["", "fun wcode_backto_standard_pos_2_O :: \"bin_inv_t\"\n  where\n    \"wcode_backto_standard_pos_2_O ires rs (l, r) = \n          (\\<exists> ml mr ln rn. l = Oc\\<up>(ml )@ Bk # Bk # Bk\\<up>(ln) @ Oc # ires \\<and> \n                          r = Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and> \n                          ml + mr = (Suc (Suc rs)) \\<and> mr > 0)\""], ["", "fun wcode_backto_standard_pos_2 :: \"bin_inv_t\"\n  where\n    \"wcode_backto_standard_pos_2 ires rs (l, r) = \n           (wcode_backto_standard_pos_2_O ires rs (l, r) \\<or> \n           wcode_backto_standard_pos_2_B ires rs (l, r))\""], ["", "fun wcode_before_fourtimes :: \"bin_inv_t\"\n  where\n    \"wcode_before_fourtimes ires rs (l, r) = \n          (\\<exists> ln rn. l = Bk # Bk # Bk\\<up>(ln) @ Oc # ires \\<and> \n                    r = Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["", "declare wcode_on_left_moving_2_B.simps[simp del] wcode_on_left_moving_2.simps[simp del]\n  wcode_on_left_moving_2_O.simps[simp del] wcode_on_checking_2.simps[simp del]\n  wcode_goon_checking.simps[simp del] wcode_right_move.simps[simp del]\n  wcode_erase2.simps[simp del]\n  wcode_on_right_moving_2.simps[simp del] wcode_goon_right_moving_2.simps[simp del]\n  wcode_backto_standard_pos_2_B.simps[simp del] wcode_backto_standard_pos_2_O.simps[simp del]\n  wcode_backto_standard_pos_2.simps[simp del]"], ["", "lemmas wcode_fourtimes_invs = \n  wcode_on_left_moving_2_B.simps wcode_on_left_moving_2.simps\n  wcode_on_left_moving_2_O.simps wcode_on_checking_2.simps\n  wcode_goon_checking.simps wcode_right_move.simps\n  wcode_erase2.simps\n  wcode_on_right_moving_2.simps wcode_goon_right_moving_2.simps\n  wcode_backto_standard_pos_2_B.simps wcode_backto_standard_pos_2_O.simps\n  wcode_backto_standard_pos_2.simps"], ["", "fun wcode_fourtimes_case_inv :: \"nat \\<Rightarrow> bin_inv_t\"\n  where\n    \"wcode_fourtimes_case_inv st ires rs (l, r) = \n           (if st = Suc 0 then wcode_on_left_moving_2 ires rs (l, r)\n            else if st = Suc (Suc 0) then wcode_on_checking_2 ires rs (l, r)\n            else if st = 7 then wcode_goon_checking ires rs (l, r)\n            else if st = 8 then wcode_right_move ires rs (l, r)\n            else if st = 9 then wcode_erase2 ires rs (l, r)\n            else if st = 10 then wcode_on_right_moving_2 ires rs (l, r)\n            else if st = 11 then wcode_goon_right_moving_2 ires rs (l, r)\n            else if st = 12 then wcode_backto_standard_pos_2 ires rs (l, r)\n            else if st = t_twice_len + 14 then wcode_before_fourtimes ires rs (l, r)\n            else False)\""], ["", "declare wcode_fourtimes_case_inv.simps[simp del]"], ["", "fun wcode_fourtimes_case_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"wcode_fourtimes_case_state (st, l, r) = 13 - st\""], ["", "fun wcode_fourtimes_case_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"wcode_fourtimes_case_step (st, l, r) = \n         (if st = Suc 0 then length l\n          else if st = 9 then \n           (if hd r = Oc then 1\n            else 0)\n          else if st = 10 then length r\n          else if st = 11 then length r\n          else if st = 12 then length l\n          else 0)\""], ["", "fun wcode_fourtimes_case_measure :: \"config \\<Rightarrow> nat \\<times> nat\"\n  where\n    \"wcode_fourtimes_case_measure (st, l, r) = \n     (wcode_fourtimes_case_state (st, l, r), \n      wcode_fourtimes_case_step (st, l, r))\""], ["", "definition wcode_fourtimes_case_le :: \"(config \\<times> config) set\"\n  where \"wcode_fourtimes_case_le \\<equiv> (inv_image lex_pair wcode_fourtimes_case_measure)\""], ["", "lemma wf_wcode_fourtimes_case_le[intro]: \"wf wcode_fourtimes_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_fourtimes_case_le", "by(auto simp: wcode_fourtimes_case_le_def)"], ["", "lemma nonempty_snd [simp]:\n  \"wcode_on_left_moving_2 ires rs (b, []) = False\"\n  \"wcode_on_checking_2 ires rs (b, []) = False\"\n  \"wcode_goon_checking ires rs (b, []) = False\"\n  \"wcode_right_move ires rs (b, []) = False\"\n  \"wcode_erase2 ires rs (b, []) = False\"\n  \"wcode_on_right_moving_2 ires rs (b, []) = False\"\n  \"wcode_backto_standard_pos_2 ires rs (b, []) = False\"\n  \"wcode_on_checking_2 ires rs (b, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((wcode_on_left_moving_2 ires rs (b, []) = False &&&\n      wcode_on_checking_2 ires rs (b, []) = False) &&&\n     wcode_goon_checking ires rs (b, []) = False &&&\n     wcode_right_move ires rs (b, []) = False) &&&\n    (wcode_erase2 ires rs (b, []) = False &&&\n     wcode_on_right_moving_2 ires rs (b, []) = False) &&&\n    wcode_backto_standard_pos_2 ires rs (b, []) = False &&&\n    wcode_on_checking_2 ires rs (b, Oc # list) = False", "by(auto simp: wcode_fourtimes_invs)"], ["", "lemma wcode_on_left_moving_2[simp]:\n  \"wcode_on_left_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>  wcode_on_left_moving_2 ires rs (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_left_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_on_left_moving_2 ires rs (tl b, hd b # Bk # list)", "apply(simp only: wcode_fourtimes_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ml mr rn.\n        b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        b = Bk # Oc # ires \\<and>\n        Bk # list =\n        Oc #\n        Bk \\<up> ln @\n        Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn) \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>ml mr rn.\n       b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n       Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n       Suc 0 < ml + mr \\<and> 0 < mr \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Oc # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn.\n       b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n       Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n       Suc 0 < ml + mr \\<and> 0 < mr \\<Longrightarrow>\n       (\\<exists>ml mr rn.\n           tl b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n           hd b # Bk # list =\n           Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n           Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n       (\\<exists>ln rn.\n           tl b = Bk # Oc # ires \\<and>\n           hd b # Bk # list =\n           Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Oc # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(simp add: gr1_conv_Suc exp_ind replicate_app_Cons_same split:hd_repeat_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn.\n       b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n       Bk # list = Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn \\<and>\n       (\\<exists>nat. ml + mr = Suc (Suc nat)) \\<and>\n       0 < mr \\<Longrightarrow>\n       (ml = 0 \\<longrightarrow>\n        (\\<exists>ln rna.\n            Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn =\n            Bk # Bk # Bk \\<up> ln @ Oc # Oc \\<up> rs @ Bk \\<up> rna)) \\<and>\n       (\\<forall>nat.\n           ml = Suc nat \\<longrightarrow>\n           (\\<exists>mra.\n               (\\<exists>rna.\n                   Bk # Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                   Bk \\<up> mra @ Oc # Oc \\<up> rs @ Bk \\<up> rna) \\<and>\n               (\\<exists>nata. nat + mra = Suc (Suc nata)) \\<and> 0 < mra))\n 2. \\<exists>ln rn.\n       b = Bk # Oc # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Oc # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply (auto simp add: gr0_conv_Suc[symmetric] replicate_app_Cons_same split:hd_repeat_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn nat.\n       \\<lbrakk>b = Oc # Bk # Oc # ires;\n        list = Bk # Bk \\<up> nat @ Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna.\n                            Bk \\<up> nat @ Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                            Bk \\<up> ln @ Oc # Oc \\<up> rs @ Bk \\<up> rna\n 2. \\<And>mr rn nat nata.\n       \\<lbrakk>b = Bk # Bk \\<up> nata @ Oc # Bk # Oc # ires;\n        Bk # list = Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn; 0 < mr;\n        nata + mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mra.\n                            (\\<exists>rna.\n                                Bk #\n                                Bk \\<up> mr @\n                                Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                                Bk \\<up> mra @\n                                Oc # Oc \\<up> rs @ Bk \\<up> rna) \\<and>\n                            (\\<exists>nat.\n                                nata + mra = Suc (Suc nat)) \\<and>\n                            0 < mra", "by force+"], ["", "lemma wcode_goon_checking_via_2 [simp]: \"wcode_on_checking_2 ires rs (b, Bk # list)\n       \\<Longrightarrow>   wcode_goon_checking ires rs (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_checking_2 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_goon_checking ires rs (tl b, hd b # Bk # list)", "unfolding wcode_fourtimes_invs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln rn.\n       b = Oc # ires \\<and>\n       Bk # list =\n       Bk #\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>ln rn.\n       tl b = ires \\<and>\n       hd b # Bk # list =\n       Oc # Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "by auto"], ["", "lemma wcode_erase2_via_move [simp]: \"wcode_right_move ires rs (b, Bk # list) \\<Longrightarrow>  wcode_erase2 ires rs (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_right_move ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_erase2 ires rs (Bk # b, list)", "by (auto simp:wcode_fourtimes_invs ) auto"], ["", "lemma wcode_on_right_moving_2_via_erase2[simp]:\n  \"wcode_erase2 ires rs (b, Bk # list) \\<Longrightarrow> wcode_on_right_moving_2 ires rs (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_erase2 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_on_right_moving_2 ires rs (Bk # b, list)", "apply(auto simp:wcode_fourtimes_invs )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<lbrakk>b = Bk # Oc # ires;\n        list =\n        Bk \\<up> ln @ Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            [Bk, Bk] = Bk \\<up> ml \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rna.\n                                    Bk \\<up> ln @\n                                    Bk #\n                                    Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                                    Bk \\<up> mr @\n                                    Oc # Oc \\<up> rs @ Bk \\<up> rna) \\<and>\n                                Suc 0 < ml + mr)", "apply(rule_tac x = \"Suc (Suc 0)\" in exI, simp add: exp_ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<lbrakk>b = Bk # Oc # ires;\n        list =\n        Bk \\<up> ln @ Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr rna.\n                            Bk \\<up> ln @\n                            Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                            Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rna", "by (metis replicate_Suc_iff_anywhere replicate_app_Cons_same)"], ["", "lemma wcode_on_right_moving_2_move_Bk[simp]: \"wcode_on_right_moving_2 ires rs (b, Bk # list)\n       \\<Longrightarrow> wcode_on_right_moving_2 ires rs (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_on_right_moving_2 ires rs (Bk # b, list)", "apply(auto simp: wcode_fourtimes_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # ires; Suc 0 < ml + mr;\n        Bk # list = Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            Bk # Bk \\<up> ml = Bk \\<up> mla \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list =\n                                    Bk \\<up> mr @\n                                    Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n                                Suc 0 < mla + mr)", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # ires; Suc 0 < ml + mr;\n        Bk # list = Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            Bk # Bk \\<up> ml = Bk \\<up> mla \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list =\n                                    Bk \\<up> mr @\n                                    Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n                                Suc 0 < mla + mr)", "apply(rule_tac x = \"Suc ml\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # ires; Suc 0 < ml + mr;\n        Bk # list = Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr.\n                            (\\<exists>rn.\n                                list =\n                                Bk \\<up> mr @\n                                Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n                            (0 < ml \\<or> 0 < mr)", "apply(rule_tac x = \"mr - 1\" in exI, case_tac mr,auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_backto_standard_pos_2_via_right[simp]:\n  \"wcode_goon_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> \n                 wcode_backto_standard_pos_2 ires rs (b, Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_backto_standard_pos_2 ires rs (b, Oc # list)", "apply(simp add: wcode_fourtimes_invs, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<lbrakk>b = Oc # Oc \\<up> rs @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n        Bk # list = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            (\\<exists>lna.\n                                Oc # Oc \\<up> rs @ Bk # Bk # Bk \\<up> ln =\n                                Oc \\<up> ml @ Bk # Bk # Bk \\<up> lna) \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    Oc # list =\n                                    Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "by (metis add.right_neutral add_Suc_shift append_Cons list.sel(3)\n      replicate.simps(1) replicate_Suc replicate_Suc_iff_anywhere self_append_conv2\n      tl_replicate zero_less_Suc)"], ["", "lemma wcode_on_checking_2_via_left[simp]: \"wcode_on_left_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> \n                     wcode_on_checking_2 ires rs (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_left_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n    wcode_on_checking_2 ires rs (tl b, hd b # Oc # list)", "by(auto simp: wcode_fourtimes_invs)"], ["", "lemma wcode_backto_standard_pos_2_empty_via_right[simp]:\n  \"wcode_goon_right_moving_2 ires rs (b, []) \\<Longrightarrow>\n              wcode_backto_standard_pos_2 ires rs (b, [Oc])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_2 ires rs (b, []) \\<Longrightarrow>\n    wcode_backto_standard_pos_2 ires rs (b, [Oc])", "by (auto simp add: wcode_fourtimes_invs) force"], ["", "lemma wcode_goon_checking_cases[simp]: \"wcode_goon_checking ires rs (b, Oc # list) \\<Longrightarrow>\n  (b = [] \\<longrightarrow> wcode_right_move ires rs ([Oc], list)) \\<and>\n  (b \\<noteq> [] \\<longrightarrow> wcode_right_move ires rs (Oc # b, list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_goon_checking ires rs (b, Oc # list) \\<Longrightarrow>\n    (b = [] \\<longrightarrow> wcode_right_move ires rs ([Oc], list)) \\<and>\n    (b \\<noteq> [] \\<longrightarrow>\n     wcode_right_move ires rs (Oc # b, list))", "apply(simp only: wcode_fourtimes_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln rn.\n       b = ires \\<and>\n       Oc # list =\n       Oc #\n       Bk #\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (b = [] \\<longrightarrow>\n     (\\<exists>ln rn.\n         [Oc] = Oc # ires \\<and>\n         list =\n         Bk #\n         Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)) \\<and>\n    (b \\<noteq> [] \\<longrightarrow>\n     (\\<exists>ln rn.\n         Oc # b = Oc # ires \\<and>\n         list =\n         Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn))", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       b = ires \\<and>\n       Oc # list =\n       Oc #\n       Bk #\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n       (b = [] \\<longrightarrow>\n        (\\<exists>ln rn.\n            [Oc] = Oc # ires \\<and>\n            list =\n            Bk #\n            Oc #\n            Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)) \\<and>\n       (b \\<noteq> [] \\<longrightarrow>\n        (\\<exists>ln rn.\n            Oc # b = Oc # ires \\<and>\n            list =\n            Bk #\n            Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_right_move_no_Oc[simp]: \"wcode_right_move ires rs (b, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_right_move ires rs (b, Oc # list) = False", "apply(auto simp: wcode_fourtimes_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_erase2_Bk_via_Oc[simp]: \"wcode_erase2 ires rs (b, Oc # list)\n       \\<Longrightarrow> wcode_erase2 ires rs (b, Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_erase2 ires rs (b, Oc # list) \\<Longrightarrow>\n    wcode_erase2 ires rs (b, Bk # list)", "apply(auto simp: wcode_fourtimes_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_goon_right_moving_2_Oc_move[simp]:\n  \"wcode_on_right_moving_2 ires rs (b, Oc # list)\n       \\<Longrightarrow> wcode_goon_right_moving_2 ires rs (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n    wcode_goon_right_moving_2 ires rs (Oc # b, list)", "apply(auto simp: wcode_fourtimes_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml rn.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # ires; Suc 0 < ml;\n        list = Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            (\\<exists>ln.\n                                Oc # Bk \\<up> ml =\n                                Oc \\<up> mla @ Bk # Bk # Bk \\<up> ln) \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rna.\n                                    Oc \\<up> rs @ Bk \\<up> rn =\n                                    Oc \\<up> mr @ Bk \\<up> rna) \\<and>\n                                mla + mr = Suc rs)", "apply(rule_tac x = \"Suc 0\" in exI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml rn.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # ires; Suc 0 < ml;\n        list = Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln. Bk \\<up> ml = Bk # Bk # Bk \\<up> ln", "apply(rule_tac x = \"ml - 2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml rn.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # ires; Suc 0 < ml;\n        list = Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> ml = Bk # Bk # Bk \\<up> (ml - 2)", "apply(case_tac ml, simp, case_tac \"ml - 1\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_backto_standard_pos_2_exists[simp]: \"wcode_backto_standard_pos_2 ires rs (b, Bk # list)\n       \\<Longrightarrow> (\\<exists>ln. b = Bk # Bk\\<up>(ln) @ Oc # ires) \\<and> (\\<exists>rn. list = Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos_2 ires rs (b, Bk # list) \\<Longrightarrow>\n    (\\<exists>ln. b = Bk # Bk \\<up> ln @ Oc # ires) \\<and>\n    (\\<exists>rn. list = Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "by(simp add: wcode_fourtimes_invs)"], ["", "lemma wcode_goon_right_moving_2_move_Oc[simp]: \"wcode_goon_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n       wcode_goon_right_moving_2 ires rs (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_goon_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n    wcode_goon_right_moving_2 ires rs (Oc # b, list)", "apply(simp only:wcode_fourtimes_invs, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml ln mr rn.\n       \\<lbrakk>b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n        ml + mr = Suc rs; Oc # list = Oc \\<up> mr @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            (\\<exists>lna.\n                                Oc # Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln =\n                                Oc \\<up> mla @\n                                Bk # Bk # Bk \\<up> lna) \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc rs)", "apply(rename_tac ml ln mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml ln mr rn.\n       \\<lbrakk>b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires;\n        ml + mr = Suc rs; Oc # list = Oc \\<up> mr @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            (\\<exists>lna.\n                                Oc # Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln =\n                                Oc \\<up> mla @\n                                Bk # Bk # Bk \\<up> lna) \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc rs)", "apply(case_tac mr;force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_backto_standard_pos_2_Oc_mv_hd[simp]:\n  \"wcode_backto_standard_pos_2 ires rs (b, Oc # list)    \n            \\<Longrightarrow> wcode_backto_standard_pos_2 ires rs (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_backto_standard_pos_2 ires rs (b, Oc # list) \\<Longrightarrow>\n    wcode_backto_standard_pos_2 ires rs (tl b, hd b # Oc # list)", "apply(simp only: wcode_fourtimes_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ml mr ln rn.\n        b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        Oc # list =\n        Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    (\\<exists>ml mr ln rn.\n        tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>ml mr ln rn.\n       b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<Longrightarrow>\n    (\\<exists>ml mr ln rn.\n        tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # list =\n       Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr ln rn.\n        tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr ln rn.\n       b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<Longrightarrow>\n       (\\<exists>ml mr ln rn.\n           tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n           hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n           ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n       (\\<exists>ln rn.\n           tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n           hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # list =\n       Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr ln rn.\n        tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "apply(rename_tac ml mr ln rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr ln rn.\n       b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<Longrightarrow>\n       (\\<exists>ml mr ln rn.\n           tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n           hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n           ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n       (\\<exists>ln rn.\n           tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n           hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n       Oc # list =\n       Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr ln rn.\n        tl b = Oc \\<up> ml @ Bk # Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc (Suc rs) \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk \\<up> ln @ Oc # ires \\<and>\n        hd b # Oc # list = Bk # Oc \\<up> Suc (Suc rs) @ Bk \\<up> rn)", "by (case_tac ml, force,force,force)"], ["", "lemma nonempty_fst[simp]:\n  \"wcode_on_left_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_checking_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_checking ires rs (b, Bk # list) = False\"\n  \"wcode_right_move ires rs (b, Bk # list) \\<Longrightarrow> b\\<noteq> []\" \n  \"wcode_erase2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_backto_standard_pos_2 ires rs (b, Bk # list) \\<Longrightarrow>  b \\<noteq> []\"\n  \"wcode_on_left_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_right_moving_2 ires rs (b, []) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_erase2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_backto_standard_pos_2 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((wcode_on_left_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>\n       b \\<noteq> []) &&&\n      (wcode_on_checking_2 ires rs (b, Bk # list) \\<Longrightarrow>\n       b \\<noteq> []) &&&\n      wcode_goon_checking ires rs (b, Bk # list) = False) &&&\n     ((wcode_right_move ires rs (b, Bk # list) \\<Longrightarrow>\n       b \\<noteq> []) &&&\n      (wcode_erase2 ires rs (b, Bk # list) \\<Longrightarrow>\n       b \\<noteq> [])) &&&\n     (wcode_on_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>\n      b \\<noteq> []) &&&\n     (wcode_goon_right_moving_2 ires rs (b, Bk # list) \\<Longrightarrow>\n      b \\<noteq> [])) &&&\n    ((wcode_backto_standard_pos_2 ires rs (b, Bk # list) \\<Longrightarrow>\n      b \\<noteq> []) &&&\n     (wcode_on_left_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n      b \\<noteq> []) &&&\n     (wcode_goon_right_moving_2 ires rs (b, []) \\<Longrightarrow>\n      b \\<noteq> [])) &&&\n    ((wcode_erase2 ires rs (b, Oc # list) \\<Longrightarrow>\n      b \\<noteq> []) &&&\n     (wcode_on_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n      b \\<noteq> [])) &&&\n    (wcode_goon_right_moving_2 ires rs (b, Oc # list) \\<Longrightarrow>\n     b \\<noteq> []) &&&\n    (wcode_backto_standard_pos_2 ires rs (b, Oc # list) \\<Longrightarrow>\n     b \\<noteq> [])", "by(auto simp: wcode_fourtimes_invs)"], ["", "lemma wcode_fourtimes_case_first_correctness:\n  shows \"let P = (\\<lambda> (st, l, r). st = t_twice_len + 14) in \n  let Q = (\\<lambda> (st, l, r). wcode_fourtimes_case_inv st ires rs (l, r)) in \n  let f = (\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp) in\n  \\<exists> n .P (f n) \\<and> Q (f (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?P = \"(\\<lambda> (st, l, r). st = t_twice_len + 14)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?Q = \"(\\<lambda> (st, l, r). wcode_fourtimes_case_inv st ires rs (l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?f = \"(\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "have \"\\<exists> n . ?P (?f n) \\<and> ?Q (?f (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>na.\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r))", "proof(rule_tac halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?LE\n 2. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n 3. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)\n 4. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> ?LE", "show \"wf wcode_fourtimes_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_fourtimes_case_le", "by auto"], ["proof (state)\nthis:\n  wf wcode_fourtimes_case_le\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_fourtimes_case_le", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_fourtimes_case_le", "have \"\\<not> ?P (?f na) \\<and> ?Q (?f na) \\<longrightarrow>\n                  ?Q (?f (Suc na)) \\<and> (?f (Suc na), ?f na) \\<in> wcode_fourtimes_case_le\" for na"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main na of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n    (case steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main na of\n     (st, l, r) \\<Rightarrow>\n       wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n    (case steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main (Suc na) of\n     (st, l, r) \\<Rightarrow>\n       wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n    (steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main (Suc na),\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main na)\n    \\<in> wcode_fourtimes_case_le", "apply(cases \"?f na\", rule_tac impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                  Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                 t_wcode_main na =\n                (a, b, c);\n        \\<not> (case steps0\n                      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                      t_wcode_main na of\n                (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n        (case steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main na of\n         (st, l, r) \\<Rightarrow>\n           wcode_fourtimes_case_inv st ires rs (l, r))\\<rbrakk>\n       \\<Longrightarrow> (case steps0\n                                (Suc 0,\n                                 Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                                t_wcode_main (Suc na) of\n                          (st, l, r) \\<Rightarrow>\n                            wcode_fourtimes_case_inv st ires rs\n                             (l, r)) \\<and>\n                         (steps0\n                           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                           t_wcode_main (Suc na),\n                          steps0\n                           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                           t_wcode_main na)\n                         \\<in> wcode_fourtimes_case_le", "apply(simp add: step_red step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                  Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                 t_wcode_main na =\n                (a, b, c);\n        a \\<noteq> t_twice_len + 14 \\<and>\n        wcode_fourtimes_case_inv a ires rs (b, c)\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_main a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, x) \\<Rightarrow>\n                             wcode_fourtimes_case_inv st ires rs x) \\<and>\n                          (case fetch t_wcode_main a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_fourtimes_case_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_main a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, x) \\<Rightarrow>\n                             wcode_fourtimes_case_inv st ires rs x) \\<and>\n                          (case fetch t_wcode_main a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_fourtimes_case_le)", "apply(case_tac \"snd (snd (?f na))\", simp, case_tac [2] \"hd (snd (snd (?f na)))\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                  Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                 t_wcode_main na =\n                (a, b, []);\n        a \\<noteq> t_twice_len + 14 \\<and>\n        wcode_fourtimes_case_inv a ires rs (b, []);\n        c = []\\<rbrakk>\n       \\<Longrightarrow> (case case fetch t_wcode_main a Bk of\n                               (a, s') \\<Rightarrow>\n                                 (s', update a (b, [])) of\n                          (st, x) \\<Rightarrow>\n                            wcode_fourtimes_case_inv st ires rs x) \\<and>\n                         (case fetch t_wcode_main a Bk of\n                          (a, s') \\<Rightarrow> (s', update a (b, [])),\n                          a, b, [])\n                         \\<in> wcode_fourtimes_case_le\n 2. \\<And>a b c aa list.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                  Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                 t_wcode_main na =\n                (a, b, Bk # list);\n        a \\<noteq> t_twice_len + 14 \\<and>\n        wcode_fourtimes_case_inv a ires rs (b, Bk # list);\n        c = Bk # list; aa = Bk\\<rbrakk>\n       \\<Longrightarrow> (case case fetch t_wcode_main a Bk of\n                               (a, s') \\<Rightarrow>\n                                 (s', update a (b, Bk # list)) of\n                          (st, x) \\<Rightarrow>\n                            wcode_fourtimes_case_inv st ires rs x) \\<and>\n                         (case fetch t_wcode_main a Bk of\n                          (a, s') \\<Rightarrow>\n                            (s', update a (b, Bk # list)),\n                          a, b, Bk # list)\n                         \\<in> wcode_fourtimes_case_le\n 3. \\<And>a b c aa list.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                  Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                 t_wcode_main na =\n                (a, b, Oc # list);\n        a \\<noteq> t_twice_len + 14 \\<and>\n        wcode_fourtimes_case_inv a ires rs (b, Oc # list);\n        c = Oc # list; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> (case case fetch t_wcode_main a Oc of\n                               (a, s') \\<Rightarrow>\n                                 (s', update a (b, Oc # list)) of\n                          (st, x) \\<Rightarrow>\n                            wcode_fourtimes_case_inv st ires rs x) \\<and>\n                         (case fetch t_wcode_main a Oc of\n                          (a, s') \\<Rightarrow>\n                            (s', update a (b, Oc # list)),\n                          a, b, Oc # list)\n                         \\<in> wcode_fourtimes_case_le", "apply(simp_all add: wcode_fourtimes_case_inv.simps\n          wcode_fourtimes_case_le_def lex_pair_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa list.\n       \\<lbrakk>c = Bk # list; aa = Bk;\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n         t_wcode_main na =\n        (12, b, Bk # list);\n        a = 12; wcode_backto_standard_pos_2 ires rs (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn.\n                            list = Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn", "by(auto simp: wcode_backto_standard_pos_2.simps wcode_backto_standard_pos_2_O.simps\n          wcode_backto_standard_pos_2_B.simps gr0_conv_Suc)"], ["proof (state)\nthis:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main ?na1 of\n          (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main ?na1 of\n   (st, l, r) \\<Rightarrow>\n     wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc ?na1) of\n   (st, l, r) \\<Rightarrow>\n     wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n  (steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main (Suc ?na1),\n   steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main ?na1)\n  \\<in> wcode_fourtimes_case_le\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_fourtimes_case_le", "thus \"\\<forall> na. \\<not> ?P (?f na) \\<and> ?Q (?f na) \\<longrightarrow>\n                  ?Q (?f (Suc na)) \\<and> (?f (Suc na), ?f na) \\<in> wcode_fourtimes_case_le\""], ["proof (prove)\nusing this:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main ?na1 of\n          (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main ?na1 of\n   (st, l, r) \\<Rightarrow>\n     wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc ?na1) of\n   (st, l, r) \\<Rightarrow>\n     wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n  (steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main (Suc ?na1),\n   steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main ?na1)\n  \\<in> wcode_fourtimes_case_le\n\ngoal (1 subgoal):\n 1. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_fourtimes_case_le", "by auto"], ["proof (state)\nthis:\n  \\<forall>na.\n     \\<not> (case steps0\n                   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                   t_wcode_main na of\n             (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow>\n        wcode_fourtimes_case_inv st ires rs (l, r)) \\<longrightarrow>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main (Suc na) of\n      (st, l, r) \\<Rightarrow>\n        wcode_fourtimes_case_inv st ires rs (l, r)) \\<and>\n     (steps0\n       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n       t_wcode_main (Suc na),\n      steps0\n       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n       t_wcode_main na)\n     \\<in> wcode_fourtimes_case_le\n\ngoal (2 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)", "show \"?Q (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)", "apply(simp add: steps.simps wcode_fourtimes_case_inv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_left_moving_2 ires rs\n     (Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n      Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)", "apply(simp add: wcode_on_left_moving_2.simps wcode_on_left_moving_2_B.simps \n          wcode_on_left_moving_2_O.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ml.\n       Bk # Bk \\<up> m = Bk \\<up> ml \\<and>\n       (\\<exists>mr.\n           (\\<exists>rn.\n               Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n               Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n           Suc 0 < ml + mr \\<and> 0 < mr)", "apply(rule_tac x = \"Suc m\" in exI, simp )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>mr.\n       (\\<exists>rn.\n           Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n           Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n       (0 < m \\<or> 0 < mr) \\<and> 0 < mr", "apply(rule_tac x =\"Suc 0\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main 0 of\n  (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r)\n\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)", "show \"\\<not> ?P (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = t_twice_len + 14)", "apply(simp add: steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main 0 of\n          (st, l, r) \\<Rightarrow> st = t_twice_len + 14)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>na.\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>na.\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> st = t_twice_len + 14) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> wcode_fourtimes_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n        Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "apply(erule_tac exE, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n      Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition t_fourtimes_len :: \"nat\"\n  where\n    \"t_fourtimes_len = (length t_fourtimes div 2)\""], ["", "lemma primerec_rec_fourtimes_1[intro]: \"primerec rec_fourtimes (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primerec rec_fourtimes (Suc 0)", "apply(auto simp: rec_fourtimes_def numeral_4_eq_4 constn.simps)"], ["proof (prove)\ngoal (9 subgoals):\n 1. primerec s ?k15\n 2. Suc 0 = ?k15\n 3. primerec s ?k18\n 4. Suc 0 = ?k18\n 5. primerec s ?k21\n 6. Suc 0 = ?k21\n 7. primerec s ?k24\n 8. Suc 0 = ?k24\n 9. primerec z (Suc 0)", "by auto"], ["", "lemma fourtimes_lemma: \"rec_exec rec_fourtimes [rs] = 4 * rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_fourtimes [rs] = 4 * rs", "by(simp add: rec_exec.simps rec_fourtimes_def)"], ["", "lemma t_fourtimes_correct: \n  \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n    (tm_of abc_fourtimes @ shift (mopup 1) (length (tm_of abc_fourtimes) div 2)) stp =\n       (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (tm_of abc_fourtimes @\n         shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n        stp =\n       (0, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "proof(case_tac \"rec_ci rec_fourtimes\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_fourtimes = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_fourtimes @\n            shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_fourtimes = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_fourtimes @\n            shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "assume h: \"rec_ci rec_fourtimes = (a, b, c)\""], ["proof (state)\nthis:\n  rec_ci rec_fourtimes = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_fourtimes = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_fourtimes @\n            shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "have \"\\<exists>stp m l. steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk\\<up>(n)) (tm_of abc_fourtimes @ shift (mopup (length [rs])) \n    (length (tm_of abc_fourtimes) div 2)) stp = (0, Bk\\<up>(m) @ Bk # Bk # ires, Oc\\<up>(Suc (rec_exec rec_fourtimes [rs])) @ Bk\\<up>(l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m l.\n       steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n        (tm_of abc_fourtimes @\n         shift (mopup (length [rs])) (length (tm_of abc_fourtimes) div 2))\n        stp =\n       (0, Bk \\<up> m @ Bk # Bk # ires,\n        Oc \\<up> Suc (rec_exec rec_fourtimes [rs]) @ Bk \\<up> l)", "thm recursive_compile_to_tm_correct1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m l.\n       steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n        (tm_of abc_fourtimes @\n         shift (mopup (length [rs])) (length (tm_of abc_fourtimes) div 2))\n        stp =\n       (0, Bk \\<up> m @ Bk # Bk # ires,\n        Oc \\<up> Suc (rec_exec rec_fourtimes [rs]) @ Bk \\<up> l)", "proof(rule_tac recursive_compile_to_tm_correct1)"], ["proof (state)\ngoal (3 subgoals):\n 1. rec_ci rec_fourtimes = (?ap, ?ary, ?fp)\n 2. terminate rec_fourtimes [rs]\n 3. tm_of abc_fourtimes = tm_of (?ap [+] dummy_abc (length [rs]))", "show \"rec_ci rec_fourtimes = (a, b, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_ci rec_fourtimes = (a, b, c)", "by (simp add: h)"], ["proof (state)\nthis:\n  rec_ci rec_fourtimes = (a, b, c)\n\ngoal (2 subgoals):\n 1. terminate rec_fourtimes [rs]\n 2. tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. terminate rec_fourtimes [rs]\n 2. tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))", "show \"terminate rec_fourtimes [rs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_fourtimes [rs]", "apply(rule_tac primerec_terminate)"], ["proof (prove)\ngoal (2 subgoals):\n 1. primerec rec_fourtimes ?x\n 2. length [rs] = ?x", "by auto"], ["proof (state)\nthis:\n  terminate rec_fourtimes [rs]\n\ngoal (1 subgoal):\n 1. tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))", "show \"tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))", "using h"], ["proof (prove)\nusing this:\n  rec_ci rec_fourtimes = (a, b, c)\n\ngoal (1 subgoal):\n 1. tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))", "by(simp add: abc_fourtimes_def)"], ["proof (state)\nthis:\n  tm_of abc_fourtimes = tm_of (a [+] dummy_abc (length [rs]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp m l.\n     steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n      (tm_of abc_fourtimes @\n       shift (mopup (length [rs])) (length (tm_of abc_fourtimes) div 2))\n      stp =\n     (0, Bk \\<up> m @ Bk # Bk # ires,\n      Oc \\<up> Suc (rec_exec rec_fourtimes [rs]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       rec_ci rec_fourtimes = (a, b, c) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           (tm_of abc_fourtimes @\n            shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n           stp =\n          (0, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>stp m l.\n     steps0 (Suc 0, Bk # Bk # ires, <[rs]> @ Bk \\<up> n)\n      (tm_of abc_fourtimes @\n       shift (mopup (length [rs])) (length (tm_of abc_fourtimes) div 2))\n      stp =\n     (0, Bk \\<up> m @ Bk # Bk # ires,\n      Oc \\<up> Suc (rec_exec rec_fourtimes [rs]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (tm_of abc_fourtimes @\n         shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n        stp =\n       (0, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(simp add: tape_of_list_def tape_of_nat_def fourtimes_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_fourtimes @\n       shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_fourtimes[intro]: \"tm_wf (t_fourtimes_compile, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_fourtimes_compile", "apply(simp only: t_fourtimes_compile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0\n     (tm_of abc_fourtimes @\n      shift (mopup 1) (length (tm_of abc_fourtimes) div 2))", "apply(rule_tac wf_tm_from_abacus, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_fourtimes_change_term_state:\n  \"\\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_fourtimes stp\n     = (Suc t_fourtimes_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "have \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n    (tm_of abc_fourtimes @ shift (mopup 1) ((length (tm_of abc_fourtimes) div 2))) stp =\n    (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (tm_of abc_fourtimes @\n         shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n        stp =\n       (0, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "by(rule_tac t_fourtimes_correct)"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_fourtimes @\n       shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_fourtimes @\n       shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "obtain stp ln rn where \n    \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) \n    (tm_of abc_fourtimes @ shift (mopup 1) ((length (tm_of abc_fourtimes) div 2))) stp =\n    (0, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (tm_of abc_fourtimes @\n       shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n      stp =\n     (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stp ln rn.\n        steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n         (tm_of abc_fourtimes @\n          shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n         stp =\n        (0, Bk \\<up> ln @ Bk # Bk # ires,\n         Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (tm_of abc_fourtimes @\n    shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n   stp =\n  (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "hence \"\\<exists> stp. steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n    (adjust0 t_fourtimes_compile) stp\n     = (Suc (length t_fourtimes_compile div 2), Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (tm_of abc_fourtimes @\n    shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n   stp =\n  (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        (adjust0 t_fourtimes_compile) stp =\n       (Suc (length t_fourtimes_compile div 2),\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(rule_tac stp = stp in adjust_halt_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     (tm_of abc_fourtimes @\n      shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n     stp =\n    (0, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    steps0 (1, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     t_fourtimes_compile stp =\n    (0, Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n 2. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     (tm_of abc_fourtimes @\n      shift (mopup 1) (length (tm_of abc_fourtimes) div 2))\n     stp =\n    (0, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    tm_wf0 t_fourtimes_compile", "apply(simp add: t_fourtimes_compile_def, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (adjust0 t_fourtimes_compile) stp =\n     (Suc (length t_fourtimes_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (adjust0 t_fourtimes_compile) stp =\n     (Suc (length t_fourtimes_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "obtain stpb where \n    \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n    (adjust0 t_fourtimes_compile) stpb\n     = (Suc (length t_fourtimes_compile div 2), Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      (adjust0 t_fourtimes_compile) stp =\n     (Suc (length t_fourtimes_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb.\n        steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n         (adjust0 t_fourtimes_compile) stpb =\n        (Suc (length t_fourtimes_compile div 2),\n         Bk \\<up> ln @ Bk # Bk # ires,\n         Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (adjust0 t_fourtimes_compile) stpb =\n  (Suc (length t_fourtimes_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n   Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n   (adjust0 t_fourtimes_compile) stpb =\n  (Suc (length t_fourtimes_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n   Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(simp add: t_fourtimes_def t_fourtimes_len_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> n)\n     (adjust0 t_fourtimes_compile) stpb =\n    (Suc (length t_fourtimes_compile div 2), Bk \\<up> ln @ Bk # Bk # ires,\n     Oc # Oc \\<up> (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> n)\n        (adjust0 t_fourtimes_compile) stp =\n       (Suc (length t_fourtimes_compile div 2),\n        Bk \\<up> ln @ Bk # Bk # ires, Oc # Oc \\<up> (4 * rs) @ Bk \\<up> rn)", "by metis"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_fourtimes stp =\n     (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_t_twice_even[intro]: \"is_even (length t_twice)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length t_twice)", "by(auto simp: t_twice_def t_twice_compile_def intro!:mopup_mod2)"], ["", "lemma t_fourtimes_append_pre:\n  \"steps0 (Suc 0, Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_fourtimes stp\n  = (Suc t_fourtimes_len, Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\n   \\<Longrightarrow> steps0 (Suc 0 + length (t_wcode_main_first_part @ \n              shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2,\n       Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n     ((t_wcode_main_first_part @ \n  shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) @ \n  shift t_fourtimes (length (t_wcode_main_first_part @ \n  shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2) @ ([(L, 1), (L, 1)])) stp \n  = ((Suc t_fourtimes_len) + length (t_wcode_main_first_part @ \n  shift t_twice (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2,\n  Bk\\<up>(ln) @ Bk # Bk # ires, Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_fourtimes\n     stp =\n    (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    steps0\n     (Suc 0 +\n      length\n       (t_wcode_main_first_part @\n        shift t_twice (length t_wcode_main_first_part div 2) @\n        [(L, 1), (L, 1)]) div\n      2,\n      Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     ((t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)]) @\n      shift t_fourtimes\n       (length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2) @\n      [(L, 1), (L, 1)])\n     stp =\n    (Suc t_fourtimes_len +\n     length\n      (t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)]) div\n     2,\n     Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "using length_t_twice_even"], ["proof (prove)\nusing this:\n  is_even (length t_twice)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n) t_fourtimes\n     stp =\n    (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n     Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n    steps0\n     (Suc 0 +\n      length\n       (t_wcode_main_first_part @\n        shift t_twice (length t_wcode_main_first_part div 2) @\n        [(L, 1), (L, 1)]) div\n      2,\n      Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n     ((t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)]) @\n      shift t_fourtimes\n       (length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2) @\n      [(L, 1), (L, 1)])\n     stp =\n    (Suc t_fourtimes_len +\n     length\n      (t_wcode_main_first_part @\n       shift t_twice (length t_wcode_main_first_part div 2) @\n       [(L, 1), (L, 1)]) div\n     2,\n     Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "by(intro tm_append_shift_append_steps, auto)"], ["", "lemma split_26_even[simp]: \"(26 + l::nat) div 2 = l div 2 + 13\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (26 + l) div 2 = l div 2 + 13", "by(simp)"], ["", "lemma t_twice_len_plust_14[simp]: \"t_twice_len + 14 =  14 + length (shift t_twice 12) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_twice_len + 14 = 14 + length (shift t_twice 12) div 2", "apply(simp add: t_twice_def t_twice_len_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_fourtimes_append:\n  \"\\<exists> stp ln rn. \n  steps0 (Suc 0 + length (t_wcode_main_first_part @ shift t_twice\n  (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2, \n  Bk # Bk # ires, Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n  ((t_wcode_main_first_part @ shift t_twice (length t_wcode_main_first_part div 2) @\n  [(L, 1), (L, 1)]) @ shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)]) stp \n  = (Suc t_fourtimes_len + length (t_wcode_main_first_part @ shift t_twice\n  (length t_wcode_main_first_part div 2) @ [(L, 1), (L, 1)]) div 2, Bk\\<up>(ln) @ Bk # Bk # ires,\n                                                                 Oc\\<up>(Suc (4 * rs)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0 +\n         length\n          (t_wcode_main_first_part @\n           shift t_twice (length t_wcode_main_first_part div 2) @\n           [(L, 1), (L, 1)]) div\n         2,\n         Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        ((t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_fourtimes_len +\n        length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2,\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "using t_fourtimes_change_term_state[of ires rs n]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_fourtimes stp =\n     (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n      Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0 +\n         length\n          (t_wcode_main_first_part @\n           shift t_twice (length t_wcode_main_first_part div 2) @\n           [(L, 1), (L, 1)]) div\n         2,\n         Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        ((t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_fourtimes_len +\n        length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2,\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<exists>ln rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_fourtimes stp =\n          (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 +\n            length\n             (t_wcode_main_first_part @\n              shift t_twice (length t_wcode_main_first_part div 2) @\n              [(L, 1), (L, 1)]) div\n            2,\n            Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           ((t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_fourtimes_len +\n           length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln.\n       \\<exists>rn.\n          steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_fourtimes stp =\n          (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 +\n            length\n             (t_wcode_main_first_part @\n              shift t_twice (length t_wcode_main_first_part div 2) @\n              [(L, 1), (L, 1)]) div\n            2,\n            Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           ((t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_fourtimes_len +\n           length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0 (Suc 0, Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_fourtimes stp =\n       (Suc t_fourtimes_len, Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 +\n            length\n             (t_wcode_main_first_part @\n              shift t_twice (length t_wcode_main_first_part div 2) @\n              [(L, 1), (L, 1)]) div\n            2,\n            Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           ((t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_fourtimes_len +\n           length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(drule_tac t_fourtimes_append_pre)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (Suc 0 +\n         length\n          (t_wcode_main_first_part @\n           shift t_twice (length t_wcode_main_first_part div 2) @\n           [(L, 1), (L, 1)]) div\n         2,\n         Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        ((t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) @\n         shift t_fourtimes\n          (length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2) @\n         [(L, 1), (L, 1)])\n        stp =\n       (Suc t_fourtimes_len +\n        length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2,\n        Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0 +\n            length\n             (t_wcode_main_first_part @\n              shift t_twice (length t_wcode_main_first_part div 2) @\n              [(L, 1), (L, 1)]) div\n            2,\n            Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n           ((t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_fourtimes_len +\n           length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2,\n           Bk \\<up> ln @ Bk # Bk # ires,\n           Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(rule_tac x = stp in exI, rule_tac x = ln in exI, rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (Suc 0 +\n         length\n          (t_wcode_main_first_part @\n           shift t_twice (length t_wcode_main_first_part div 2) @\n           [(L, 1), (L, 1)]) div\n         2,\n         Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        ((t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) @\n         shift t_fourtimes\n          (length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2) @\n         [(L, 1), (L, 1)])\n        stp =\n       (Suc t_fourtimes_len +\n        length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2,\n        Bk \\<up> ln @ Bk # Bk # ires,\n        Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       steps0\n        (Suc 0 +\n         length\n          (t_wcode_main_first_part @\n           shift t_twice (length t_wcode_main_first_part div 2) @\n           [(L, 1), (L, 1)]) div\n         2,\n         Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> n)\n        ((t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_fourtimes_len +\n        length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2,\n        Bk \\<up> ln @ Bk # Bk # ires, Oc \\<up> Suc (4 * rs) @ Bk \\<up> rn)", "apply(simp add: t_twice_len_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma even_fourtimes_len: \"length t_fourtimes mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length t_fourtimes)", "apply(auto simp: t_fourtimes_def t_fourtimes_compile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (mopup (Suc 0)))", "by (metis mopup_mod2)"], ["", "lemma t_twice_even[simp]: \"2 * (length t_twice div 2) = length t_twice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (length t_twice div 2) = length t_twice", "using length_t_twice_even"], ["proof (prove)\nusing this:\n  is_even (length t_twice)\n\ngoal (1 subgoal):\n 1. 2 * (length t_twice div 2) = length t_twice", "by arith"], ["", "lemma t_fourtimes_even[simp]: \"2 * (length t_fourtimes div 2) = length t_fourtimes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (length t_fourtimes div 2) = length t_fourtimes", "using even_fourtimes_len"], ["proof (prove)\nusing this:\n  is_even (length t_fourtimes)\n\ngoal (1 subgoal):\n 1. 2 * (length t_fourtimes div 2) = length t_fourtimes", "by arith"], ["", "lemma fetch_t_wcode_14_Oc: \"fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Oc\n             = (L, Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Oc =\n    (L, Suc 0)", "apply(subgoal_tac \"14 = Suc 13\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 14 = Suc 13 \\<Longrightarrow>\n    fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Oc =\n    (L, Suc 0)\n 2. 14 = Suc 13", "apply(simp only: fetch.simps add_Suc nth_of.simps t_wcode_main_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 14 = Suc 13 \\<Longrightarrow>\n    (case if length\n              (t_wcode_main_first_part @\n               shift t_twice 12 @\n               [(L, 1), (L, 1)] @\n               shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n             \\<le> 2 * (13 + length t_twice div 2 + t_fourtimes_len) + 1\n          then None\n          else Some\n                ((t_wcode_main_first_part @\n                  shift t_twice 12 @\n                  [(L, 1), (L, 1)] @\n                  shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)]) !\n                 (2 * (13 + length t_twice div 2 + t_fourtimes_len) + 1)) of\n     None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n    (L, Suc 0)\n 2. 14 = Suc 13", "apply(simp add:length_t_twice_even t_fourtimes_len_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 14 = Suc 13", "by arith"], ["", "lemma fetch_t_wcode_14_Bk: \"fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Bk\n             = (L, Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Bk =\n    (L, Suc 0)", "apply(subgoal_tac \"14 = Suc 13\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 14 = Suc 13 \\<Longrightarrow>\n    fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) Bk =\n    (L, Suc 0)\n 2. 14 = Suc 13", "apply(simp only: fetch.simps add_Suc nth_of.simps t_wcode_main_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 14 = Suc 13 \\<Longrightarrow>\n    (case if length\n              (t_wcode_main_first_part @\n               shift t_twice 12 @\n               [(L, 1), (L, 1)] @\n               shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n             \\<le> 2 * (13 + length t_twice div 2 + t_fourtimes_len)\n          then None\n          else Some\n                ((t_wcode_main_first_part @\n                  shift t_twice 12 @\n                  [(L, 1), (L, 1)] @\n                  shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)]) !\n                 (2 * (13 + length t_twice div 2 + t_fourtimes_len))) of\n     None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n    (L, Suc 0)\n 2. 14 = Suc 13", "apply(simp add:length_t_twice_even t_fourtimes_len_def nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 14 = Suc 13", "by arith"], ["", "lemma fetch_t_wcode_14 [simp]: \"fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) b\n             = (L, Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch t_wcode_main (14 + length t_twice div 2 + t_fourtimes_len) b =\n    (L, Suc 0)", "apply(case_tac b, simp_all add:fetch_t_wcode_14_Bk fetch_t_wcode_14_Oc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_jump2: \n  \"\\<exists> stp ln rn. steps0 (t_twice_len + 14 + t_fourtimes_len\n  , Bk # Bk # Bk\\<up>(lnb) @ Oc # ires, Oc\\<up>(Suc (4 * rs + 4)) @ Bk\\<up>(rnb)) t_wcode_main stp =\n  (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (4 * rs + 4)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (t_twice_len + 14 + t_fourtimes_len,\n         Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(rule_tac x = \"Suc 0\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln rn.\n       steps0\n        (t_twice_len + 14 + t_fourtimes_len,\n         Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n        t_wcode_main (Suc 0) =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(simp add: steps.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln rn.\n       step0\n        (14 + length t_twice div 2 + t_fourtimes_len,\n         Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rnb)\n        t_wcode_main =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "apply(rule_tac x = lnb in exI, rule_tac x = rnb in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. step0\n     (14 + length t_twice div 2 + t_fourtimes_len,\n      Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n      Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rnb)\n     t_wcode_main =\n    (Suc 0, Bk # Bk \\<up> lnb @ Oc # ires,\n     Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rnb)", "apply(simp add: step.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_fourtimes_case:\n  shows \"\\<exists>stp ln rn.\n  steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n  (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "have \"\\<exists>stp ln rn.\n  steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n  (t_twice_len + 14, Bk # Bk # Bk\\<up>(ln) @ Oc # ires, Oc\\<up>(Suc (rs + 1)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (t_twice_len + 14, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (rs + 1) @ Bk \\<up> rn)", "using wcode_fourtimes_case_first_correctness[of ires rs m n]"], ["proof (prove)\nusing this:\n  let P = \\<lambda>(st, l, r). st = t_twice_len + 14;\n      Q = \\<lambda>(st, l, r). wcode_fourtimes_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (t_twice_len + 14, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (rs + 1) @ Bk \\<up> rn)", "by (auto simp add: wcode_fourtimes_case_inv.simps) auto"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (t_twice_len + 14, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (rs + 1) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (t_twice_len + 14, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (rs + 1) @ Bk \\<up> rn)", "obtain stpa lna rna where stp1:\n    \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Oc # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stpa =\n  (t_twice_len + 14, Bk # Bk # Bk\\<up>(lna) @ Oc # ires, Oc\\<up>(Suc (rs + 1)) @ Bk\\<up>(rna))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (t_twice_len + 14, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (rs + 1) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpa lna rna.\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main stpa =\n        (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "have \"\\<exists>stp ln rn. steps0 (t_twice_len + 14, Bk # Bk # Bk\\<up>(lna) @ Oc # ires, Oc\\<up>(Suc (rs + 1)) @ Bk\\<up>(rna))\n                     t_wcode_main stp =\n          (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk\\<up>(ln) @ Oc # ires,  Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (t_twice_len + 14 + t_fourtimes_len,\n        Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "using t_fourtimes_append[of \" Bk\\<up>(lna) @ Oc # ires\" \"rs + 1\" rna]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0 +\n       length\n        (t_wcode_main_first_part @\n         shift t_twice (length t_wcode_main_first_part div 2) @\n         [(L, 1), (L, 1)]) div\n       2,\n       Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      ((t_wcode_main_first_part @\n        shift t_twice (length t_wcode_main_first_part div 2) @\n        [(L, 1), (L, 1)]) @\n       shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n      stp =\n     (Suc t_fourtimes_len +\n      length\n       (t_wcode_main_first_part @\n        shift t_twice (length t_wcode_main_first_part div 2) @\n        [(L, 1), (L, 1)]) div\n      2,\n      Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n      Oc \\<up> Suc (4 * (rs + 1)) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (t_twice_len + 14 + t_fourtimes_len,\n        Bk # Bk # Bk \\<up> ln @ Oc # ires,\n        Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<exists>ln rn.\n          steps0\n           (Suc 0 +\n            length\n             (t_wcode_main_first_part @\n              shift t_twice (length t_wcode_main_first_part div 2) @\n              [(L, 1), (L, 1)]) div\n            2,\n            Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n           ((t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_fourtimes_len +\n           length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2,\n           Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n           Oc \\<up> Suc (4 * (rs + 1)) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n           t_wcode_main stp =\n          (t_twice_len + 14 + t_fourtimes_len,\n           Bk # Bk # Bk \\<up> ln @ Oc # ires,\n           Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln.\n       \\<exists>rn.\n          steps0\n           (Suc 0 +\n            length\n             (t_wcode_main_first_part @\n              shift t_twice (length t_wcode_main_first_part div 2) @\n              [(L, 1), (L, 1)]) div\n            2,\n            Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n           ((t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) @\n            shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n           stp =\n          (Suc t_fourtimes_len +\n           length\n            (t_wcode_main_first_part @\n             shift t_twice (length t_wcode_main_first_part div 2) @\n             [(L, 1), (L, 1)]) div\n           2,\n           Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n           Oc \\<up> Suc (4 * (rs + 1)) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n           t_wcode_main stp =\n          (t_twice_len + 14 + t_fourtimes_len,\n           Bk # Bk # Bk \\<up> ln @ Oc # ires,\n           Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (Suc 0 +\n         length\n          (t_wcode_main_first_part @\n           shift t_twice (length t_wcode_main_first_part div 2) @\n           [(L, 1), (L, 1)]) div\n         2,\n         Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n        ((t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) @\n         shift t_fourtimes (t_twice_len + 13) @ [(L, 1), (L, 1)])\n        stp =\n       (Suc t_fourtimes_len +\n        length\n         (t_wcode_main_first_part @\n          shift t_twice (length t_wcode_main_first_part div 2) @\n          [(L, 1), (L, 1)]) div\n        2,\n        Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n        Oc \\<up> Suc (4 * (rs + 1)) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n           t_wcode_main stp =\n          (t_twice_len + 14 + t_fourtimes_len,\n           Bk # Bk # Bk \\<up> ln @ Oc # ires,\n           Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(simp add: t_wcode_main_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (14 + length t_twice div 2, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n        (t_wcode_main_first_part @\n         shift t_twice 12 @\n         (L, Suc 0) #\n         (L, Suc 0) #\n         shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n        stp =\n       (14 + (t_fourtimes_len + length t_twice div 2),\n        Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n        Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (14 + length t_twice div 2, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n           (t_wcode_main_first_part @\n            shift t_twice 12 @\n            (L, Suc 0) #\n            (L, Suc 0) #\n            shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n           stp =\n          (14 + length t_twice div 2 + t_fourtimes_len,\n           Bk # Bk # Bk \\<up> ln @ Oc # ires,\n           Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "apply(rename_tac stp ln rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (14 + length t_twice div 2, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n        (t_wcode_main_first_part @\n         shift t_twice 12 @\n         (L, Suc 0) #\n         (L, Suc 0) #\n         shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n        stp =\n       (14 + (t_fourtimes_len + length t_twice div 2),\n        Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n        Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (14 + length t_twice div 2, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n            Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n           (t_wcode_main_first_part @\n            shift t_twice 12 @\n            (L, Suc 0) #\n            (L, Suc 0) #\n            shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n           stp =\n          (14 + length t_twice div 2 + t_fourtimes_len,\n           Bk # Bk # Bk \\<up> ln @ Oc # ires,\n           Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "apply(rule_tac x = stp in exI, \n        rule_tac x = \"ln + lna\" in exI,\n        rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       steps0\n        (14 + length t_twice div 2, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n         Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna)\n        (t_wcode_main_first_part @\n         shift t_twice 12 @\n         (L, Suc 0) #\n         (L, Suc 0) #\n         shift t_fourtimes (t_twice_len + 13) @ [(L, Suc 0), (L, Suc 0)])\n        stp =\n       (14 + (t_fourtimes_len + length t_twice div 2),\n        Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna @ Oc # ires,\n        Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn) \\<Longrightarrow>\n       Bk \\<up> ln @ Bk # Bk # Bk \\<up> lna = Bk # Bk # Bk \\<up> (ln + lna)", "apply(simp add: replicate_Suc[THEN sym] replicate_add[THEN sym] del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "obtain stpb lnb rnb where stp2:\n    \"steps0 (t_twice_len + 14, Bk # Bk # Bk\\<up>(lna) @ Oc # ires, Oc\\<up>(Suc (rs + 1)) @ Bk\\<up>(rna))\n                     t_wcode_main stpb =\n       (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk\\<up>(lnb) @ Oc # ires,  Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rnb))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> ln @ Oc # ires,\n      Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb lnb rnb.\n        steps0\n         (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n          Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n         t_wcode_main stpb =\n        (t_twice_len + 14 + t_fourtimes_len,\n         Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n   Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "have \"\\<exists>stp ln rn. steps0 (t_twice_len + 14 + t_fourtimes_len,\n    Bk # Bk # Bk\\<up>(lnb) @ Oc # ires,  Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rnb))\n    t_wcode_main stp =\n    (Suc 0, Bk # Bk\\<up>(ln) @ Oc # ires, Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (t_twice_len + 14 + t_fourtimes_len,\n         Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n         Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(rule wcode_jump2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (t_twice_len + 14 + t_fourtimes_len,\n       Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (t_twice_len + 14 + t_fourtimes_len,\n       Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "obtain stpc lnc rnc where stp3: \n    \"steps0 (t_twice_len + 14 + t_fourtimes_len,\n    Bk # Bk # Bk\\<up>(lnb) @ Oc # ires,  Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rnb))\n    t_wcode_main stpc =\n    (Suc 0, Bk # Bk\\<up>(lnc) @ Oc # ires, Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rnc))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (t_twice_len + 14 + t_fourtimes_len,\n       Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpc lnc rnc.\n        steps0\n         (t_twice_len + 14 + t_fourtimes_len,\n          Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n          Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n         t_wcode_main stpc =\n        (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n         Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n   t_wcode_main stpc =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "from stp1 stp2 stp3"], ["proof (chain)\npicking this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n  steps0\n   (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n   Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n  steps0\n   (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n   t_wcode_main stpc =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n   Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n  steps0\n   (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n    Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n   Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n  steps0\n   (t_twice_len + 14 + t_fourtimes_len, Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n    Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n   t_wcode_main stpc =\n  (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n   Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "apply(rule_tac x = \"stpa + stpb + stpc\" in exI,\n        rule_tac x = lnc in exI, rule_tac x = rnc in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main stpa =\n             (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n              Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna);\n     steps0\n      (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      t_wcode_main stpb =\n     (t_twice_len + 14 + t_fourtimes_len,\n      Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n      Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb);\n     steps0\n      (t_twice_len + 14 + t_fourtimes_len,\n       Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n      t_wcode_main stpc =\n     (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc);\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stpa =\n     (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n      Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna);\n     steps0\n      (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      t_wcode_main stpb =\n     (t_twice_len + 14 + t_fourtimes_len,\n      Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n      Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb);\n     steps0\n      (t_twice_len + 14 + t_fourtimes_len,\n       Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n      t_wcode_main stpc =\n     (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc);\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stpa =\n     (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n      Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna);\n     steps0\n      (t_twice_len + 14, Bk # Bk # Bk \\<up> lna @ Oc # ires,\n       Oc \\<up> Suc (rs + 1) @ Bk \\<up> rna)\n      t_wcode_main stpb =\n     (t_twice_len + 14 + t_fourtimes_len,\n      Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n      Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb);\n     steps0\n      (t_twice_len + 14 + t_fourtimes_len,\n       Bk # Bk # Bk \\<up> lnb @ Oc # ires,\n       Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnb)\n      t_wcode_main stpc =\n     (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc)\\<rbrakk>\n    \\<Longrightarrow> steps0\n                       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n                        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                       t_wcode_main (stpa + stpb + stpc) =\n                      (Suc 0, Bk # Bk \\<up> lnc @ Oc # ires,\n                       Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rnc)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun wcode_on_left_moving_3_B :: \"bin_inv_t\"\n  where\n    \"wcode_on_left_moving_3_B ires rs (l, r) = \n       (\\<exists> ml mr rn. l = Bk\\<up>(ml) @ Oc # Bk # Bk # ires \\<and>\n                    r = Bk\\<up>(mr) @ Oc\\<up>(Suc rs) @ Bk\\<up>(rn) \\<and> \n                    ml + mr > Suc 0 \\<and> mr > 0 )\""], ["", "fun wcode_on_left_moving_3_O :: \"bin_inv_t\"\n  where\n    \"wcode_on_left_moving_3_O ires rs (l, r) = \n         (\\<exists> ln rn. l = Bk # Bk # ires \\<and>\n                   r = Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_on_left_moving_3 :: \"bin_inv_t\"\n  where\n    \"wcode_on_left_moving_3 ires rs (l, r) = \n       (wcode_on_left_moving_3_B ires rs (l, r) \\<or>  \n        wcode_on_left_moving_3_O ires rs (l, r))\""], ["", "fun wcode_on_checking_3 :: \"bin_inv_t\"\n  where\n    \"wcode_on_checking_3 ires rs (l, r) = \n         (\\<exists> ln rn. l = Bk # ires \\<and>\n             r = Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_goon_checking_3 :: \"bin_inv_t\"\n  where\n    \"wcode_goon_checking_3 ires rs (l, r) = \n         (\\<exists> ln rn. l = ires \\<and>\n             r = Bk # Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_stop :: \"bin_inv_t\"\n  where\n    \"wcode_stop ires rs (l, r) = \n          (\\<exists> ln rn. l = Bk # ires \\<and>\n             r = Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wcode_halt_case_inv :: \"nat \\<Rightarrow> bin_inv_t\"\n  where\n    \"wcode_halt_case_inv st ires rs (l, r) = \n          (if st = 0 then wcode_stop ires rs (l, r)\n           else if st = Suc 0 then wcode_on_left_moving_3 ires rs (l, r)\n           else if st = Suc (Suc 0) then wcode_on_checking_3 ires rs (l, r)\n           else if st = 7 then wcode_goon_checking_3 ires rs (l, r)\n           else False)\""], ["", "fun wcode_halt_case_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"wcode_halt_case_state (st, l, r) = \n           (if st = 1 then 5\n            else if st = Suc (Suc 0) then 4\n            else if st = 7 then 3\n            else 0)\""], ["", "fun wcode_halt_case_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"wcode_halt_case_step (st, l, r) = \n         (if st = 1 then length l\n         else 0)\""], ["", "fun wcode_halt_case_measure :: \"config \\<Rightarrow> nat \\<times> nat\"\n  where\n    \"wcode_halt_case_measure (st, l, r) = \n     (wcode_halt_case_state (st, l, r), \n      wcode_halt_case_step (st, l, r))\""], ["", "definition wcode_halt_case_le :: \"(config \\<times> config) set\"\n  where \"wcode_halt_case_le \\<equiv> (inv_image lex_pair wcode_halt_case_measure)\""], ["", "lemma wf_wcode_halt_case_le[intro]: \"wf wcode_halt_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_halt_case_le", "by(auto simp: wcode_halt_case_le_def)"], ["", "declare wcode_on_left_moving_3_B.simps[simp del] wcode_on_left_moving_3_O.simps[simp del]  \n  wcode_on_checking_3.simps[simp del] wcode_goon_checking_3.simps[simp del] \n  wcode_on_left_moving_3.simps[simp del] wcode_stop.simps[simp del]"], ["", "lemmas wcode_halt_invs = \n  wcode_on_left_moving_3_B.simps wcode_on_left_moving_3_O.simps\n  wcode_on_checking_3.simps wcode_goon_checking_3.simps \n  wcode_on_left_moving_3.simps wcode_stop.simps"], ["", "lemma wcode_on_left_moving_3_mv_Bk[simp]: \"wcode_on_left_moving_3 ires rs (b, Bk # list)\n \\<Longrightarrow> wcode_on_left_moving_3 ires rs (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_left_moving_3 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_on_left_moving_3 ires rs (tl b, hd b # Bk # list)", "apply(simp only: wcode_halt_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ml mr rn.\n        b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        b = Bk # Bk # ires \\<and>\n        Bk # list =\n        Oc #\n        Bk \\<up> ln @\n        Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn) \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>ml mr rn.\n       b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n       Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n       Suc 0 < ml + mr \\<and> 0 < mr \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn.\n       b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n       Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n       Suc 0 < ml + mr \\<and> 0 < mr \\<Longrightarrow>\n       (\\<exists>ml mr rn.\n           tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n           hd b # Bk # list =\n           Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n           Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n       (\\<exists>ln rn.\n           tl b = Bk # Bk # ires \\<and>\n           hd b # Bk # list =\n           Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn.\n       b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n       Bk # list = Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n       Suc 0 < ml + mr \\<and> 0 < mr \\<Longrightarrow>\n       (\\<exists>ml mr rn.\n           tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n           hd b # Bk # list =\n           Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n           Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n       (\\<exists>ln rn.\n           tl b = Bk # Bk # ires \\<and>\n           hd b # Bk # list =\n           Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(case_tac ml, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn \\<and>\n                Suc 0 < mr \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rna.\n                            Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                            Bk \\<up> ln @\n                            Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rna\n 2. \\<And>ml mr rn nat.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             tl b = Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 3. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(rule_tac x = \"mr - 2\" in exI, rule_tac x = rn in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn \\<and>\n                Suc 0 < mr \\<and> 0 < mr;\n        ml = 0\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                         Bk \\<up> (mr - 2) @\n                         Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\n 2. \\<And>ml mr rn nat.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             tl b = Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 3. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(case_tac mr, force, simp add: exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ml mr rn nat.\n       \\<lbrakk>b = Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> nat @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn \\<and>\n                0 < nat;\n        ml = 0; mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> nat = Bk \\<up> (nat - Suc 0) @ [Bk]\n 2. \\<And>ml mr rn nat.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             tl b = Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 3. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(case_tac \"mr - 1\", force, simp add: exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr rn nat.\n       \\<lbrakk>b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                Bk # list =\n                Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                Suc 0 < ml + mr \\<and> 0 < mr;\n        ml = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ml mr rn.\n                             tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Bk \\<up> mr @\n                             Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n                             Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n                         (\\<exists>ln rn.\n                             tl b = Bk # Bk # ires \\<and>\n                             hd b # Bk # list =\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln rn.\n       b = Bk # Bk # ires \\<and>\n       Bk # list =\n       Oc #\n       Bk \\<up> ln @\n       Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>ml mr rn.\n        tl b = Bk \\<up> ml @ Oc # Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Bk \\<up> mr @ Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n        Suc 0 < ml + mr \\<and> 0 < mr) \\<or>\n    (\\<exists>ln rn.\n        tl b = Bk # Bk # ires \\<and>\n        hd b # Bk # list =\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_goon_checking_3_cases[simp]: \"wcode_goon_checking_3 ires rs (b, Bk # list) \\<Longrightarrow> \n  (b = [] \\<longrightarrow> wcode_stop ires rs ([Bk], list)) \\<and>\n  (b \\<noteq> [] \\<longrightarrow> wcode_stop ires rs (Bk # b, list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_goon_checking_3 ires rs (b, Bk # list) \\<Longrightarrow>\n    (b = [] \\<longrightarrow> wcode_stop ires rs ([Bk], list)) \\<and>\n    (b \\<noteq> [] \\<longrightarrow> wcode_stop ires rs (Bk # b, list))", "apply(auto simp: wcode_halt_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_on_checking_3_mv_Oc[simp]: \"wcode_on_left_moving_3 ires rs (b, Oc # list) \\<Longrightarrow> \n               wcode_on_checking_3 ires rs (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_left_moving_3 ires rs (b, Oc # list) \\<Longrightarrow>\n    wcode_on_checking_3 ires rs (tl b, hd b # Oc # list)", "by(simp add:wcode_halt_invs)"], ["", "lemma wcode_3_nonempty[simp]:\n  \"wcode_on_left_moving_3 ires rs (b, []) = False\"\n  \"wcode_on_checking_3 ires rs (b, []) = False\"\n  \"wcode_goon_checking_3 ires rs (b, []) = False\"\n  \"wcode_on_left_moving_3 ires rs (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_checking_3 ires rs (b, Oc # list) = False\"\n  \"wcode_on_left_moving_3 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_on_checking_3 ires rs (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\"\n  \"wcode_goon_checking_3 ires rs (b, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((wcode_on_left_moving_3 ires rs (b, []) = False &&&\n      wcode_on_checking_3 ires rs (b, []) = False) &&&\n     wcode_goon_checking_3 ires rs (b, []) = False &&&\n     (wcode_on_left_moving_3 ires rs (b, Oc # list) \\<Longrightarrow>\n      b \\<noteq> [])) &&&\n    (wcode_on_checking_3 ires rs (b, Oc # list) = False &&&\n     (wcode_on_left_moving_3 ires rs (b, Bk # list) \\<Longrightarrow>\n      b \\<noteq> [])) &&&\n    (wcode_on_checking_3 ires rs (b, Bk # list) \\<Longrightarrow>\n     b \\<noteq> []) &&&\n    wcode_goon_checking_3 ires rs (b, Oc # list) = False", "by(auto simp: wcode_halt_invs)"], ["", "lemma wcode_goon_checking_3_mv_Bk[simp]: \"wcode_on_checking_3 ires rs (b, Bk # list) \\<Longrightarrow> \n  wcode_goon_checking_3 ires rs (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wcode_on_checking_3 ires rs (b, Bk # list) \\<Longrightarrow>\n    wcode_goon_checking_3 ires rs (tl b, hd b # Bk # list)", "apply(auto simp: wcode_halt_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_halt_case_correctness: \n  shows \"let P = (\\<lambda> (st, l, r). st = 0) in \n       let Q = (\\<lambda> (st, l, r). wcode_halt_case_inv st ires rs (l, r)) in \n       let f = (\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp) in\n       \\<exists> n .P (f n) \\<and> Q (f (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?P = \"(\\<lambda> (st, l, r). st = 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?Q = \"(\\<lambda> (st, l, r). wcode_halt_case_inv st ires rs (l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?f = \"(\\<lambda> stp. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "have \"\\<exists> n. ?P (?f n) \\<and> ?Q (?f (n::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>na.\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r))", "proof(rule_tac halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?LE\n 2. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 3. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 4. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> ?LE", "show \"wf wcode_halt_case_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_halt_case_le", "by auto"], ["proof (state)\nthis:\n  wf wcode_halt_case_le\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "fix na"], ["proof (state)\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "obtain a b c where abc:\"?f na = (a,b,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na =\n        (a, b, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"?f na\",auto)"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main na =\n  (a, b, c)\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "hence \"\\<not> ?P (?f na) \\<and> ?Q (?f na) \\<Longrightarrow>\n                    ?Q (?f (Suc na)) \\<and> (?f (Suc na), ?f na) \\<in> wcode_halt_case_le\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main na =\n  (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main na of\n            (st, l, r) \\<Rightarrow> st = 0) \\<and>\n    (case steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main na of\n     (st, l, r) \\<Rightarrow>\n       wcode_halt_case_inv st ires rs (l, r)) \\<Longrightarrow>\n    (case steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main (Suc na) of\n     (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)) \\<and>\n    (steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main (Suc na),\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main na)\n    \\<in> wcode_halt_case_le", "apply(simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a \\<and>\n             (if a = 0 then wcode_stop ires rs (b, c)\n              else if a = Suc 0 then wcode_on_left_moving_3 ires rs (b, c)\n                   else if a = Suc (Suc 0)\n                        then wcode_on_checking_3 ires rs (b, c)\n                        else if a = 7\n                             then wcode_goon_checking_3 ires rs (b, c)\n                             else False);\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n      t_wcode_main na =\n     (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> (c = [] \\<longrightarrow>\n                       (case case fetch t_wcode_main a Bk of\n                             (a, s') \\<Rightarrow> (s', update a (b, [])) of\n                        (st, l, r) \\<Rightarrow>\n                          (st = 7 \\<longrightarrow>\n                           wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                          (st \\<noteq> 7 \\<longrightarrow>\n                           (st = Suc (Suc 0) \\<longrightarrow>\n                            wcode_on_checking_3 ires rs (l, r)) \\<and>\n                           (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                            (st = Suc 0 \\<longrightarrow>\n                             wcode_on_left_moving_3 ires rs (l, r)) \\<and>\n                            (st \\<noteq> Suc 0 \\<longrightarrow>\n                             (st = 0 \\<longrightarrow>\n                              wcode_stop ires rs (l, r)) \\<and>\n                             st = 0)))) \\<and>\n                       (case fetch t_wcode_main a Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        a, b, [])\n                       \\<in> wcode_halt_case_le) \\<and>\n                      (c \\<noteq> [] \\<longrightarrow>\n                       (case case fetch t_wcode_main a (hd c) of\n                             (a, s') \\<Rightarrow> (s', update a (b, c)) of\n                        (st, l, r) \\<Rightarrow>\n                          (st = 7 \\<longrightarrow>\n                           wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                          (st \\<noteq> 7 \\<longrightarrow>\n                           (st = Suc (Suc 0) \\<longrightarrow>\n                            wcode_on_checking_3 ires rs (l, r)) \\<and>\n                           (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                            (st = Suc 0 \\<longrightarrow>\n                             wcode_on_left_moving_3 ires rs (l, r)) \\<and>\n                            (st \\<noteq> Suc 0 \\<longrightarrow>\n                             (st = 0 \\<longrightarrow>\n                              wcode_stop ires rs (l, r)) \\<and>\n                             st = 0)))) \\<and>\n                       (case fetch t_wcode_main a (hd c) of\n                        (a, s') \\<Rightarrow> (s', update a (b, c)),\n                        a, b, c)\n                       \\<in> wcode_halt_case_le)", "apply(cases c;cases \"hd c\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < a \\<and>\n             (if a = 0 then wcode_stop ires rs (b, c)\n              else if a = Suc 0 then wcode_on_left_moving_3 ires rs (b, c)\n                   else if a = Suc (Suc 0)\n                        then wcode_on_checking_3 ires rs (b, c)\n                        else if a = 7\n                             then wcode_goon_checking_3 ires rs (b, c)\n                             else False);\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n      t_wcode_main na =\n     (a, b, c);\n     c = []; hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> (c = [] \\<longrightarrow>\n                       (case case fetch t_wcode_main a Bk of\n                             (a, s') \\<Rightarrow> (s', update a (b, [])) of\n                        (st, l, r) \\<Rightarrow>\n                          (st = 7 \\<longrightarrow>\n                           wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                          (st \\<noteq> 7 \\<longrightarrow>\n                           (st = Suc (Suc 0) \\<longrightarrow>\n                            wcode_on_checking_3 ires rs (l, r)) \\<and>\n                           (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                            (st = Suc 0 \\<longrightarrow>\n                             wcode_on_left_moving_3 ires rs (l, r)) \\<and>\n                            (st \\<noteq> Suc 0 \\<longrightarrow>\n                             (st = 0 \\<longrightarrow>\n                              wcode_stop ires rs (l, r)) \\<and>\n                             st = 0)))) \\<and>\n                       (case fetch t_wcode_main a Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        a, b, [])\n                       \\<in> wcode_halt_case_le) \\<and>\n                      (c \\<noteq> [] \\<longrightarrow>\n                       (case case fetch t_wcode_main a (hd c) of\n                             (a, s') \\<Rightarrow> (s', update a (b, c)) of\n                        (st, l, r) \\<Rightarrow>\n                          (st = 7 \\<longrightarrow>\n                           wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                          (st \\<noteq> 7 \\<longrightarrow>\n                           (st = Suc (Suc 0) \\<longrightarrow>\n                            wcode_on_checking_3 ires rs (l, r)) \\<and>\n                           (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                            (st = Suc 0 \\<longrightarrow>\n                             wcode_on_left_moving_3 ires rs (l, r)) \\<and>\n                            (st \\<noteq> Suc 0 \\<longrightarrow>\n                             (st = 0 \\<longrightarrow>\n                              wcode_stop ires rs (l, r)) \\<and>\n                             st = 0)))) \\<and>\n                       (case fetch t_wcode_main a (hd c) of\n                        (a, s') \\<Rightarrow> (s', update a (b, c)),\n                        a, b, c)\n                       \\<in> wcode_halt_case_le)\n 2. \\<lbrakk>0 < a \\<and>\n             (if a = 0 then wcode_stop ires rs (b, c)\n              else if a = Suc 0 then wcode_on_left_moving_3 ires rs (b, c)\n                   else if a = Suc (Suc 0)\n                        then wcode_on_checking_3 ires rs (b, c)\n                        else if a = 7\n                             then wcode_goon_checking_3 ires rs (b, c)\n                             else False);\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n      t_wcode_main na =\n     (a, b, c);\n     c = []; hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> (c = [] \\<longrightarrow>\n                       (case case fetch t_wcode_main a Bk of\n                             (a, s') \\<Rightarrow> (s', update a (b, [])) of\n                        (st, l, r) \\<Rightarrow>\n                          (st = 7 \\<longrightarrow>\n                           wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                          (st \\<noteq> 7 \\<longrightarrow>\n                           (st = Suc (Suc 0) \\<longrightarrow>\n                            wcode_on_checking_3 ires rs (l, r)) \\<and>\n                           (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                            (st = Suc 0 \\<longrightarrow>\n                             wcode_on_left_moving_3 ires rs (l, r)) \\<and>\n                            (st \\<noteq> Suc 0 \\<longrightarrow>\n                             (st = 0 \\<longrightarrow>\n                              wcode_stop ires rs (l, r)) \\<and>\n                             st = 0)))) \\<and>\n                       (case fetch t_wcode_main a Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        a, b, [])\n                       \\<in> wcode_halt_case_le) \\<and>\n                      (c \\<noteq> [] \\<longrightarrow>\n                       (case case fetch t_wcode_main a (hd c) of\n                             (a, s') \\<Rightarrow> (s', update a (b, c)) of\n                        (st, l, r) \\<Rightarrow>\n                          (st = 7 \\<longrightarrow>\n                           wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                          (st \\<noteq> 7 \\<longrightarrow>\n                           (st = Suc (Suc 0) \\<longrightarrow>\n                            wcode_on_checking_3 ires rs (l, r)) \\<and>\n                           (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                            (st = Suc 0 \\<longrightarrow>\n                             wcode_on_left_moving_3 ires rs (l, r)) \\<and>\n                            (st \\<noteq> Suc 0 \\<longrightarrow>\n                             (st = 0 \\<longrightarrow>\n                              wcode_stop ires rs (l, r)) \\<and>\n                             st = 0)))) \\<and>\n                       (case fetch t_wcode_main a (hd c) of\n                        (a, s') \\<Rightarrow> (s', update a (b, c)),\n                        a, b, c)\n                       \\<in> wcode_halt_case_le)\n 3. \\<And>aa list.\n       \\<lbrakk>0 < a \\<and>\n                (if a = 0 then wcode_stop ires rs (b, c)\n                 else if a = Suc 0\n                      then wcode_on_left_moving_3 ires rs (b, c)\n                      else if a = Suc (Suc 0)\n                           then wcode_on_checking_3 ires rs (b, c)\n                           else if a = 7\n                                then wcode_goon_checking_3 ires rs (b, c)\n                                else False);\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n         t_wcode_main na =\n        (a, b, c);\n        c = aa # list; hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_main a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, l, r) \\<Rightarrow>\n                             (st = 7 \\<longrightarrow>\n                              wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                             (st \\<noteq> 7 \\<longrightarrow>\n                              (st = Suc (Suc 0) \\<longrightarrow>\n                               wcode_on_checking_3 ires rs (l, r)) \\<and>\n                              (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                               (st = Suc 0 \\<longrightarrow>\n                                wcode_on_left_moving_3 ires rs\n                                 (l, r)) \\<and>\n                               (st \\<noteq> Suc 0 \\<longrightarrow>\n                                (st = 0 \\<longrightarrow>\n                                 wcode_stop ires rs (l, r)) \\<and>\n                                st = 0)))) \\<and>\n                          (case fetch t_wcode_main a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_halt_case_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_main a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, l, r) \\<Rightarrow>\n                             (st = 7 \\<longrightarrow>\n                              wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                             (st \\<noteq> 7 \\<longrightarrow>\n                              (st = Suc (Suc 0) \\<longrightarrow>\n                               wcode_on_checking_3 ires rs (l, r)) \\<and>\n                              (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                               (st = Suc 0 \\<longrightarrow>\n                                wcode_on_left_moving_3 ires rs\n                                 (l, r)) \\<and>\n                               (st \\<noteq> Suc 0 \\<longrightarrow>\n                                (st = 0 \\<longrightarrow>\n                                 wcode_stop ires rs (l, r)) \\<and>\n                                st = 0)))) \\<and>\n                          (case fetch t_wcode_main a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_halt_case_le)\n 4. \\<And>aa list.\n       \\<lbrakk>0 < a \\<and>\n                (if a = 0 then wcode_stop ires rs (b, c)\n                 else if a = Suc 0\n                      then wcode_on_left_moving_3 ires rs (b, c)\n                      else if a = Suc (Suc 0)\n                           then wcode_on_checking_3 ires rs (b, c)\n                           else if a = 7\n                                then wcode_goon_checking_3 ires rs (b, c)\n                                else False);\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n         t_wcode_main na =\n        (a, b, c);\n        c = aa # list; hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_main a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, l, r) \\<Rightarrow>\n                             (st = 7 \\<longrightarrow>\n                              wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                             (st \\<noteq> 7 \\<longrightarrow>\n                              (st = Suc (Suc 0) \\<longrightarrow>\n                               wcode_on_checking_3 ires rs (l, r)) \\<and>\n                              (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                               (st = Suc 0 \\<longrightarrow>\n                                wcode_on_left_moving_3 ires rs\n                                 (l, r)) \\<and>\n                               (st \\<noteq> Suc 0 \\<longrightarrow>\n                                (st = 0 \\<longrightarrow>\n                                 wcode_stop ires rs (l, r)) \\<and>\n                                st = 0)))) \\<and>\n                          (case fetch t_wcode_main a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_halt_case_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_main a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, l, r) \\<Rightarrow>\n                             (st = 7 \\<longrightarrow>\n                              wcode_goon_checking_3 ires rs (l, r)) \\<and>\n                             (st \\<noteq> 7 \\<longrightarrow>\n                              (st = Suc (Suc 0) \\<longrightarrow>\n                               wcode_on_checking_3 ires rs (l, r)) \\<and>\n                              (st \\<noteq> Suc (Suc 0) \\<longrightarrow>\n                               (st = Suc 0 \\<longrightarrow>\n                                wcode_on_left_moving_3 ires rs\n                                 (l, r)) \\<and>\n                               (st \\<noteq> Suc 0 \\<longrightarrow>\n                                (st = 0 \\<longrightarrow>\n                                 wcode_stop ires rs (l, r)) \\<and>\n                                st = 0)))) \\<and>\n                          (case fetch t_wcode_main a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_halt_case_le)", "apply(auto simp: wcode_halt_case_le_def lex_pair_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main na of\n          (st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na of\n   (st, l, r) \\<Rightarrow>\n     wcode_halt_case_inv st ires rs (l, r)) \\<Longrightarrow>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na) of\n   (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)) \\<and>\n  (steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main (Suc na),\n   steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main na)\n  \\<in> wcode_halt_case_le\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "}"], ["proof (state)\nthis:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main ?na3 of\n          (st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main ?na3 of\n   (st, l, r) \\<Rightarrow>\n     wcode_halt_case_inv st ires rs (l, r)) \\<Longrightarrow>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc ?na3) of\n   (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)) \\<and>\n  (steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main (Suc ?na3),\n   steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main ?na3)\n  \\<in> wcode_halt_case_le\n\ngoal (3 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "thus \"\\<forall> na. \\<not> ?P (?f na) \\<and> ?Q (?f na) \\<longrightarrow> \n                    ?Q (?f (Suc na)) \\<and> (?f (Suc na), ?f na) \\<in> wcode_halt_case_le\""], ["proof (prove)\nusing this:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main ?na3 of\n          (st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main ?na3 of\n   (st, l, r) \\<Rightarrow>\n     wcode_halt_case_inv st ires rs (l, r)) \\<Longrightarrow>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc ?na3) of\n   (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)) \\<and>\n  (steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main (Suc ?na3),\n   steps0\n    (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n     Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n    t_wcode_main ?na3)\n  \\<in> wcode_halt_case_le\n\ngoal (1 subgoal):\n 1. \\<forall>na.\n       \\<not> (case steps0\n                     (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                      Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                     t_wcode_main na of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main na of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n       (case steps0\n              (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main (Suc na) of\n        (st, l, r) \\<Rightarrow>\n          wcode_halt_case_inv st ires rs (l, r)) \\<and>\n       (steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main (Suc na),\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main na)\n       \\<in> wcode_halt_case_le", "by blast"], ["proof (state)\nthis:\n  \\<forall>na.\n     \\<not> (case steps0\n                   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                   t_wcode_main na of\n             (st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow>\n        wcode_halt_case_inv st ires rs (l, r)) \\<longrightarrow>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main (Suc na) of\n      (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)) \\<and>\n     (steps0\n       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n       t_wcode_main (Suc na),\n      steps0\n       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n        Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n       t_wcode_main na)\n     \\<in> wcode_halt_case_le\n\ngoal (2 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n 2. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)", "show \"?Q (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case steps0\n          (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n          t_wcode_main 0 of\n    (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)", "apply(simp add: steps.simps wcode_halt_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ml.\n       Bk # Bk \\<up> m = Bk \\<up> ml \\<and>\n       (\\<exists>mr.\n           (\\<exists>rn.\n               Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n               Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n           Suc 0 < ml + mr \\<and> 0 < mr)", "apply(rule_tac x = \"Suc m\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>mr.\n       (\\<exists>rn.\n           Bk # Oc # Oc \\<up> rs @ Bk \\<up> n =\n           Bk \\<up> mr @ Oc # Oc \\<up> rs @ Bk \\<up> rn) \\<and>\n       (0 < m \\<or> 0 < mr) \\<and> 0 < mr", "apply(rule_tac x = \"Suc 0\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main 0 of\n  (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r)\n\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)", "show \"\\<not> ?P (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case steps0\n                  (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                   Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                  t_wcode_main 0 of\n            (st, l, r) \\<Rightarrow> st = 0)", "apply(simp add: steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> (case steps0\n                (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                 Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                t_wcode_main 0 of\n          (st, l, r) \\<Rightarrow> st = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>na.\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>na.\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case steps0\n            (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n             Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n            t_wcode_main na of\n      (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n        f = steps0\n             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n             t_wcode_main\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  let P = \\<lambda>(st, l, r). st = 0;\n      Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare wcode_halt_case_inv.simps[simp del]"], ["", "lemma leading_Oc[intro]: \"\\<exists> xs. (<rev list @ [aa::nat]> :: cell list) = Oc # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. <rev list @ [aa]> = Oc # xs", "apply(case_tac \"rev list\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       rev list = a # lista \\<Longrightarrow>\n       \\<exists>xs. <rev list @ [aa]> = Oc # xs", "apply(simp add: tape_of_nl_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_halt_case:\n  \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n))\n  t_wcode_main stp  = (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "let ?P = \"\\<lambda>(st, l, r). st = 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "let ?Q = \"\\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "let ?f = \"steps0 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires, Bk # Oc \\<up> Suc rs @ Bk \\<up> n) t_wcode_main\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "from t_halt_case_correctness[of ires rs m n]"], ["proof (chain)\npicking this:\n  let P = \\<lambda>(st, l, r). st = 0;\n      Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)", "obtain n where \"?P (?f n) \\<and> ?Q (?f n)\""], ["proof (prove)\nusing this:\n  let P = \\<lambda>(st, l, r). st = 0;\n      Q = \\<lambda>(st, l, r). wcode_halt_case_inv st ires rs (l, r);\n      f = steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal (1 subgoal):\n 1. (\\<And>na.\n        (case steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main na of\n         (st, l, r) \\<Rightarrow> st = 0) \\<and>\n        (case steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main na of\n         (st, l, r) \\<Rightarrow>\n           wcode_halt_case_inv st ires rs (l, r)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main n of\n   (st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main n of\n   (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main n of\n   (st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main n of\n   (st, l, r) \\<Rightarrow> wcode_halt_case_inv st ires rs (l, r))\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(simp add: wcode_halt_case_inv.simps wcode_stop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n           t_wcode_main n of\n     (st, l, r) \\<Rightarrow> st = 0) \\<and>\n    (case steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n           t_wcode_main n of\n     (st, l, r) \\<Rightarrow>\n       if st = 0 then wcode_stop ires rs (l, r)\n       else if st = Suc 0 then wcode_on_left_moving_3 ires rs (l, r)\n            else if st = Suc (Suc 0) then wcode_on_checking_3 ires rs (l, r)\n                 else if st = 7 then wcode_goon_checking_3 ires rs (l, r)\n                      else False) \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)", "apply(case_tac \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # Bk # ires,\n                Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(case steps0\n                       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                        Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                       t_wcode_main n of\n                 (st, l, r) \\<Rightarrow> st = 0) \\<and>\n                (case steps0\n                       (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                        Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                       t_wcode_main n of\n                 (st, l, r) \\<Rightarrow>\n                   if st = 0 then wcode_stop ires rs (l, r)\n                   else if st = Suc 0\n                        then wcode_on_left_moving_3 ires rs (l, r)\n                        else if st = Suc (Suc 0)\n                             then wcode_on_checking_3 ires rs (l, r)\n                             else if st = 7\n                                  then wcode_goon_checking_3 ires rs (l, r)\n                                  else False);\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main n =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                              Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)", "apply(auto simp: wcode_halt_case_inv.simps wcode_stop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c ln rn.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                  Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                 t_wcode_main n =\n                (a, b, c);\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n          Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n         t_wcode_main n =\n        (0, Bk # ires,\n         Bk #\n         Oc #\n         Bk \\<up> ln @ Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n                              Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)", "by auto"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bl_bin_one[simp]: \"bl_bin [Oc] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl_bin [Oc] = 1", "apply(simp add: bl_bin.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma twice_power[intro]: \"2 * 2 ^ a = Suc (Suc (2 * bl_bin (Oc \\<up> a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 2 ^ a = Suc (Suc (2 * bl_bin (Oc \\<up> a)))", "apply(induct a, auto simp: bl_bin.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare replicate_Suc[simp del]"], ["", "lemma t_wcode_main_lemma_pre:\n  \"\\<lbrakk>args \\<noteq> []; lm = <args::nat list>\\<rbrakk> \\<Longrightarrow> \n       \\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev lm @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main\n                    stp\n      = (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin lm + rs * 2^(length lm - 1) ) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>args \\<noteq> []; lm = <args>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp ln rn.\n                         steps0\n                          (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                          t_wcode_main stp =\n                         (0, Bk # ires,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk #\n                          Bk #\n                          Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @\n                          Bk \\<up> rn)", "proof(induct \"length args\" arbitrary: args lm rs m n, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x args lm rs m n.\n       \\<lbrakk>\\<And>args lm rs m n.\n                   \\<lbrakk>x = length args; args \\<noteq> [];\n                    lm = <args>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk # Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn);\n        Suc x = length args; args \\<noteq> []; lm = <args>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "fix x args lm rs m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x args lm rs m n.\n       \\<lbrakk>\\<And>args lm rs m n.\n                   \\<lbrakk>x = length args; args \\<noteq> [];\n                    lm = <args>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk # Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn);\n        Suc x = length args; args \\<noteq> []; lm = <args>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "assume ind:\n    \"\\<And>args lm rs m n.\n    \\<lbrakk>x = length args; (args::nat list) \\<noteq> []; lm = <args>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp ln rn.\n    steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev lm @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n    (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk\\<up>(rn))\"\n    and h: \"Suc x = length args\" \"(args::nat list) \\<noteq> []\" \"lm = <args>\""], ["proof (state)\nthis:\n  \\<lbrakk>x = length ?args; ?args \\<noteq> []; ?lm = <?args>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp ln rn.\n                       steps0\n                        (Suc 0, Bk # Bk \\<up> ?m @ rev ?lm @ Bk # Bk # ires,\n                         Bk # Oc \\<up> Suc ?rs @ Bk \\<up> ?n)\n                        t_wcode_main stp =\n                       (0, Bk # ires,\n                        Bk #\n                        Oc #\n                        Bk \\<up> ln @\n                        Bk #\n                        Bk #\n                        Oc \\<up> (bl_bin ?lm + ?rs * 2 ^ (length ?lm - 1)) @\n                        Bk \\<up> rn)\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>\n\ngoal (1 subgoal):\n 1. \\<And>x args lm rs m n.\n       \\<lbrakk>\\<And>args lm rs m n.\n                   \\<lbrakk>x = length args; args \\<noteq> [];\n                    lm = <args>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk # Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn);\n        Suc x = length args; args \\<noteq> []; lm = <args>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "from h"], ["proof (chain)\npicking this:\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>", "have \"\\<exists> (a::nat) xs. args = xs @ [a]\""], ["proof (prove)\nusing this:\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>\n\ngoal (1 subgoal):\n 1. \\<exists>a xs. args = xs @ [a]", "apply(rule_tac x = \"last args\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc x = length args; args \\<noteq> []; lm = <args>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs. args = xs @ [last args]", "apply(rule_tac x = \"butlast args\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>a xs. args = xs @ [a]\n\ngoal (1 subgoal):\n 1. \\<And>x args lm rs m n.\n       \\<lbrakk>\\<And>args lm rs m n.\n                   \\<lbrakk>x = length args; args \\<noteq> [];\n                    lm = <args>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk # Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn);\n        Suc x = length args; args \\<noteq> []; lm = <args>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>a xs. args = xs @ [a]", "obtain a xs where \"args = xs @ [a]\""], ["proof (prove)\nusing this:\n  \\<exists>a xs. args = xs @ [a]\n\ngoal (1 subgoal):\n 1. (\\<And>xs a. args = xs @ [a] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  args = xs @ [a]\n\ngoal (1 subgoal):\n 1. \\<And>x args lm rs m n.\n       \\<lbrakk>\\<And>args lm rs m n.\n                   \\<lbrakk>x = length args; args \\<noteq> [];\n                    lm = <args>\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk # Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn);\n        Suc x = length args; args \\<noteq> []; lm = <args>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "from h and this"], ["proof (chain)\npicking this:\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>\n  args = xs @ [a]", "show\n    \"\\<exists>stp ln rn.\n    steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev lm @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n    (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>\n  args = xs @ [a]\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn)", "proof(case_tac \"xs::nat list\", simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = []; x = 0; lm = Oc \\<up> Suc a; args = [a]\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp ln rn.\n                         steps0\n                          (Suc 0,\n                           Bk #\n                           Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                           Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                          t_wcode_main stp =\n                         (0, Bk # ires,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk #\n                          Bk #\n                          Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n                          Bk \\<up> rn)\n 2. \\<And>aa list.\n       \\<lbrakk>Suc x = length args; args \\<noteq> []; lm = <args>;\n        args = xs @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "show \"\\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires, Bk # Oc \\<up> Suc rs @ Bk \\<up> n) t_wcode_main stp =\n          (0, Bk # ires, Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @ Bk \\<up> rn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk # Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @ Bk \\<up> rn)", "proof(induct \"a\" arbitrary: m n rs ires, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n rs ires.\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<And>a m n rs ires.\n       (\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main stp =\n              (0, Bk # ires,\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n               Bk \\<up> rn)) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk #\n           Oc #\n           Bk \\<up> ln @\n           Bk #\n           Bk #\n           Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n           Bk \\<up> rn)", "fix m n rs ires"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n rs ires.\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n 2. \\<And>a m n rs ires.\n       (\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main stp =\n              (0, Bk # ires,\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n               Bk \\<up> rn)) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk #\n           Oc #\n           Bk \\<up> ln @\n           Bk #\n           Bk #\n           Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n           Bk \\<up> rn)", "show \"\\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires, Bk # Oc \\<up> Suc rs @ Bk \\<up> n) t_wcode_main stp =\n          (0, Bk # ires, Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)", "apply(rule_tac wcode_halt_case)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<And>a m n rs ires.\n       (\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main stp =\n              (0, Bk # ires,\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n               Bk \\<up> rn)) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk #\n           Oc #\n           Bk \\<up> ln @\n           Bk #\n           Bk #\n           Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n           Bk \\<up> rn)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m n rs ires.\n       (\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main stp =\n              (0, Bk # ires,\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n               Bk \\<up> rn)) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk #\n           Oc #\n           Bk \\<up> ln @\n           Bk #\n           Bk #\n           Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n           Bk \\<up> rn)", "fix a m n rs ires"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m n rs ires.\n       (\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main stp =\n              (0, Bk # ires,\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n               Bk \\<up> rn)) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk #\n           Oc #\n           Bk \\<up> ln @\n           Bk #\n           Bk #\n           Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n           Bk \\<up> rn)", "assume ind2:\n        \"\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0 (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires, Bk # Oc \\<up> Suc rs @ Bk \\<up> n) t_wcode_main stp =\n              (0, Bk # ires, Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @ Bk \\<up> rn)\""], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> ?m @ Oc \\<up> Suc a @ Bk # Bk # ?ires,\n       Bk # Oc \\<up> Suc ?rs @ Bk \\<up> ?n)\n      t_wcode_main stp =\n     (0, Bk # ?ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin (Oc \\<up> Suc a) + ?rs * 2 ^ a) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<And>a m n rs ires.\n       (\\<And>m n rs ires.\n           \\<exists>stp ln rn.\n              steps0\n               (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n                Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n               t_wcode_main stp =\n              (0, Bk # ires,\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @\n               Bk \\<up> rn)) \\<Longrightarrow>\n       \\<exists>stp ln rn.\n          steps0\n           (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n            Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n           t_wcode_main stp =\n          (0, Bk # ires,\n           Bk #\n           Oc #\n           Bk \\<up> ln @\n           Bk #\n           Bk #\n           Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n           Bk \\<up> rn)", "show \" \\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires, Bk # Oc \\<up> Suc rs @ Bk \\<up> n) t_wcode_main stp =\n          (0, Bk # ires, Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @ Bk \\<up> rn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "have \"\\<exists>stp ln rn.\n          steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev (<Suc a>) @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n          (Suc 0, Bk # Bk\\<up>(ln) @ rev (<a>) @ Bk # Bk # ires, Bk # Oc\\<up>(Suc (2 * rs + 2)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ rev (<a>) @ Bk # Bk # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "apply(simp add: tape_of_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc \\<up> Suc a @ Bk # Bk # ires,\n        Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "using wcode_double_case[of m \"Oc\\<up>(a) @ Bk # Bk # ires\" rs n]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Oc # Oc \\<up> a @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # Oc \\<up> a @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc \\<up> Suc a @ Bk # Bk # ires,\n        Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rn)", "apply(simp add: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ rev (<a>) @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ rev (<a>) @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "obtain stpa lna rna where stp1:  \n          \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev (<Suc a>) @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stpa =\n          (Suc 0, Bk # Bk\\<up>(lna) @ rev (<a>) @ Bk # Bk # ires, Bk # Oc\\<up>(Suc (2 * rs + 2)) @ Bk\\<up>(rna))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ rev (<a>) @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpa lna rna.\n        steps0\n         (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main stpa =\n        (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "moreover"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "have \n          \"\\<exists>stp ln rn.\n          steps0 (Suc 0,  Bk # Bk\\<up>(lna) @ rev (<a::nat>) @ Bk # Bk # ires, Bk # Oc\\<up>(Suc (2 * rs + 2)) @ Bk\\<up>(rna)) t_wcode_main stp =\n          (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin (<a>) + (2*rs + 2)  * 2 ^ a) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rn)", "using ind2[of lna ires \"2*rs + 2\" rna]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ Oc \\<up> Suc a @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (Oc \\<up> Suc a) + (2 * rs + 2) * 2 ^ a) @\n      Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rn)", "by(simp add: tape_of_list_def tape_of_nat_def)"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rn)", "obtain stpb lnb rnb where stp2:  \n          \"steps0 (Suc 0,  Bk # Bk\\<up>(lna) @ rev (<a>) @ Bk # Bk # ires, Bk # Oc\\<up>(Suc (2 * rs + 2)) @ Bk\\<up>(rna)) t_wcode_main stpb =\n          (0, Bk # ires, Bk # Oc # Bk\\<up>(lnb) @ Bk # Bk # Oc\\<up>(bl_bin (<a>) + (2*rs + 2)  * 2 ^ a) @ Bk\\<up>(rnb))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb lnb rnb.\n        steps0\n         (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n          Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n         t_wcode_main stpb =\n        (0, Bk # ires,\n         Bk #\n         Oc #\n         Bk \\<up> lnb @\n         Bk #\n         Bk #\n         Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @\n         Bk \\<up> rnb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk # Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rnb)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "from stp1 and stp2"], ["proof (chain)\npicking this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk # Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rnb)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ rev (<Suc a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ rev (<a>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk # Bk # Oc \\<up> (bl_bin (<a>) + (2 * rs + 2) * 2 ^ a) @ Bk \\<up> rnb)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n        Bk \\<up> rn)", "apply(rule_tac x = \"stpa + stpb\" in exI,\n              rule_tac x = lnb in exI, rule_tac x = rnb in exI, simp add: tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (Suc 0,\n               Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n               Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n              t_wcode_main stpa =\n             (Suc 0, Bk # Bk \\<up> lna @ Oc \\<up> Suc a @ Bk # Bk # ires,\n              Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rna);\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ Oc \\<up> Suc a @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (Suc (Suc (2 * rs))) @ Bk \\<up> rna)\n      t_wcode_main stpb =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> lnb @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (Oc \\<up> Suc a) + (2 * 2 ^ a + 2 * rs * 2 ^ a)) @\n      Bk \\<up> rnb)\\<rbrakk>\n    \\<Longrightarrow> bl_bin (Oc \\<up> Suc a) + 2 * 2 ^ a =\n                      bl_bin (Oc \\<up> Suc (Suc a))", "apply(simp add:  bl_bin.simps replicate_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (Suc 0,\n               Bk # Bk \\<up> m @ Oc # Oc # Oc \\<up> a @ Bk # Bk # ires,\n               Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n              t_wcode_main stpa =\n             (Suc 0, Bk # Bk \\<up> lna @ Oc # Oc \\<up> a @ Bk # Bk # ires,\n              Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rna);\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ Oc # Oc \\<up> a @ Bk # Bk # ires,\n       Bk # Oc # Oc # Oc # Oc \\<up> (2 * rs) @ Bk \\<up> rna)\n      t_wcode_main stpb =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> lnb @\n      Bk #\n      Bk #\n      Oc #\n      Oc \\<up> (2 * bl_bin (Oc \\<up> a) + (2 * 2 ^ a + 2 * rs * 2 ^ a)) @\n      Bk \\<up> rnb)\\<rbrakk>\n    \\<Longrightarrow> 2 * 2 ^ a = Suc (Suc (2 * bl_bin (Oc \\<up> a)))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n      Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc (Suc a) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (Oc \\<up> Suc (Suc a)) + rs * 2 ^ Suc a) @\n      Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc \\<up> Suc a @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin (Oc \\<up> Suc a) + rs * 2 ^ a) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc x = length args; args \\<noteq> []; lm = <args>;\n        args = xs @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc x = length args; args \\<noteq> []; lm = <args>;\n        args = xs @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "fix aa list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc x = length args; args \\<noteq> []; lm = <args>;\n        args = xs @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "assume g: \"Suc x = length args\" \"args \\<noteq> []\" \"lm = <args>\" \"args = xs @ [a::nat]\" \"xs = (aa::nat) # list\""], ["proof (state)\nthis:\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>\n  args = xs @ [a]\n  xs = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>Suc x = length args; args \\<noteq> []; lm = <args>;\n        args = xs @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin lm +\n rs * 2 ^ (length lm - 1)) @\n                             Bk \\<up> rn)", "thus \"\\<exists>stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(m) @ rev lm @ Bk # Bk # ires, Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n      (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  Suc x = length args\n  args \\<noteq> []\n  lm = <args>\n  args = xs @ [a]\n  xs = aa # list\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn)", "proof(induct a arbitrary: m n rs args lm, simp_all add: tape_of_nl_rev del: subst_all, \n        simp only: tape_of_nl_cons_app1, simp del: subst_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n rs args lm.\n       \\<lbrakk>lm = Oc \\<up> Suc aa @ Bk # <list @ [0]>;\n        args = aa # list @ [0]; x = Suc (length list);\n        <aa # list @ [a]> = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        lm = Oc \\<up> Suc aa @ Bk # <list @ [a]>; args = aa # list @ [a];\n        xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin\n  (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n                             Bk \\<up> rn)\n 2. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lm = <aa # list @ [a]>;\n        args = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "fix m n rs args lm"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n rs args lm.\n       \\<lbrakk>lm = Oc \\<up> Suc aa @ Bk # <list @ [0]>;\n        args = aa # list @ [0]; x = Suc (length list);\n        <aa # list @ [a]> = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        lma__ = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin\n  (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n                             Bk \\<up> rn)\n 2. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "have \"\\<exists>stp ln rn.\n        steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # rev (<(aa::nat) # list>) @ Bk # Bk # ires,\n        Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n        (Suc 0, Bk # Bk\\<up>(ln) @ rev (<aa # list>) @ Bk # Bk # ires, \n        Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ rev (<aa # list>) @ Bk # Bk # ires,\n        Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "proof(simp add: tape_of_nl_rev)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ <rev list @ [aa]> @ Bk # Bk # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "have \"\\<exists> xs. (<rev list @ [aa]>) = Oc # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. <rev list @ [aa]> = Oc # xs", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs. <rev list @ [aa]> = Oc # xs\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ <rev list @ [aa]> @ Bk # Bk # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>xs. <rev list @ [aa]> = Oc # xs", "obtain xs where \"(<rev list @ [aa]>) = Oc # xs\""], ["proof (prove)\nusing this:\n  \\<exists>xs. <rev list @ [aa]> = Oc # xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        <rev list @ [aa]> = Oc # xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  <rev list @ [aa]> = Oc # xs\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ <rev list @ [aa]> @ Bk # Bk # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "thus \"\\<exists>stp ln rn.\n            steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n            Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n            (Suc 0, Bk # Bk\\<up>(ln) @ <rev list @ [aa]> @ Bk # Bk # ires, Bk # Oc\\<up>(5 + 4 * rs) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  <rev list @ [aa]> = Oc # xs\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ <rev list @ [aa]> @ Bk # Bk # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <rev list @ [aa]> = Oc # xs \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # xs @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # xs @ Bk # Bk # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "using wcode_fourtimes_case[of m \"xs @ Bk # Bk # ires\" rs n]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # xs @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ Oc # xs @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. <rev list @ [aa]> = Oc # xs \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # Oc # xs @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0, Bk # Bk \\<up> ln @ Oc # xs @ Bk # Bk # ires,\n        Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ <rev list @ [aa]> @ Bk # Bk # ires,\n      Bk # Oc \\<up> (5 + 4 * rs) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ rev (<aa # list>) @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (2 subgoals):\n 1. \\<And>m n rs args lm.\n       \\<lbrakk>lm = Oc \\<up> Suc aa @ Bk # <list @ [0]>;\n        args = aa # list @ [0]; x = Suc (length list);\n        <aa # list @ [a]> = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        lma__ = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin\n  (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n                             Bk \\<up> rn)\n 2. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ rev (<aa # list>) @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)", "obtain stpa lna rna where stp1:\n        \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n        Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stpa =\n        (Suc 0, Bk # Bk\\<up>(lna) @ rev (<aa # list>) @ Bk # Bk # ires, \n        Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rna))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0, Bk # Bk \\<up> ln @ rev (<aa # list>) @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpa lna rna.\n        steps0\n         (Suc 0,\n          Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n          Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n         t_wcode_main stpa =\n        (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n\ngoal (2 subgoals):\n 1. \\<And>m n rs args lm.\n       \\<lbrakk>lm = Oc \\<up> Suc aa @ Bk # <list @ [0]>;\n        args = aa # list @ [0]; x = Suc (length list);\n        <aa # list @ [a]> = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        lma__ = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin\n  (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n                             Bk \\<up> rn)\n 2. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "from g"], ["proof (chain)\npicking this:\n  Suc x = length argsa__\n  argsa__ \\<noteq> []\n  lma__ = <argsa__>\n  argsa__ = xs @ [a]\n  xs = aa # list", "have \n        \"\\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(lna) @ rev (<(aa::nat) # list>) @ Bk # Bk # ires, \n        Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rna)) t_wcode_main stp = (0, Bk # ires, \n        Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin (<aa#list>)+ (4*rs + 4) * 2^(length (<aa#list>) - 1) ) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  Suc x = length argsa__\n  argsa__ \\<noteq> []\n  lma__ = <argsa__>\n  argsa__ = xs @ [a]\n  xs = aa # list\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (<aa # list>) +\n                  (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n        Bk \\<up> rn)", "apply(rule_tac args = \"(aa::nat)#list\" in ind, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list>) +\n                (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n      Bk \\<up> rn)\n\ngoal (2 subgoals):\n 1. \\<And>m n rs args lm.\n       \\<lbrakk>lm = Oc \\<up> Suc aa @ Bk # <list @ [0]>;\n        args = aa # list @ [0]; x = Suc (length list);\n        <aa # list @ [a]> = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        lma__ = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin\n  (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n                             Bk \\<up> rn)\n 2. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list>) +\n                (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n      Bk \\<up> rn)", "obtain stpb lnb rnb where stp2:\n        \"steps0 (Suc 0, Bk # Bk\\<up>(lna) @ rev (<(aa::nat) # list>) @ Bk # Bk # ires, \n         Bk # Oc\\<up>(Suc (4*rs + 4)) @ Bk\\<up>(rna)) t_wcode_main stpb = (0, Bk # ires, \n         Bk # Oc # Bk\\<up>(lnb) @ Bk # Bk # Oc\\<up>(bl_bin (<aa#list>)+ (4*rs + 4) * 2^(length (<aa#list>) - 1) ) @ Bk\\<up>(rnb))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list>) +\n                (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n      Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb lnb rnb.\n        steps0\n         (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n          Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n         t_wcode_main stpb =\n        (0, Bk # ires,\n         Bk #\n         Oc #\n         Bk \\<up> lnb @\n         Bk #\n         Bk #\n         Oc \\<up> (bl_bin (<aa # list>) +\n                   (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n         Bk \\<up> rnb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list>) +\n             (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n   Bk \\<up> rnb)\n\ngoal (2 subgoals):\n 1. \\<And>m n rs args lm.\n       \\<lbrakk>lm = Oc \\<up> Suc aa @ Bk # <list @ [0]>;\n        args = aa # list @ [0]; x = Suc (length list);\n        <aa # list @ [a]> = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        lma__ = Oc \\<up> Suc aa @ Bk # <list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin\n  (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n                             Bk \\<up> rn)\n 2. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "from stp1 and stp2 and h"], ["proof (chain)\npicking this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list>) +\n             (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n   Bk \\<up> rnb)\n  Suc x = length argsa__\n  argsa__ \\<noteq> []\n  lma__ = <argsa__>", "show \"\\<exists>stp ln rn.\n         steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n         (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk #\n         Bk # Oc\\<up>(bl_bin (Oc\\<up>(Suc aa) @ Bk # <list @ [0]>) + rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ Oc # Bk # rev (<aa # list>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ rev (<aa # list>) @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (4 * rs + 4) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list>) +\n             (4 * rs + 4) * 2 ^ (length (<aa # list>) - 1)) @\n   Bk \\<up> rnb)\n  Suc x = length argsa__\n  argsa__ \\<noteq> []\n  lma__ = <argsa__>\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n        Bk \\<up> rn)", "apply(rule_tac x = \"stpa + stpb\" in exI, rule_tac x = lnb in exI,\n            rule_tac x = rnb in exI, simp add: steps_add tape_of_nl_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk # Bk \\<up> m @ Oc # Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [0]>) +\n                rs * (2 * 2 ^ (aa + length (<list @ [0]>)))) @\n      Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lm = <aa # list @ [a]>;\n        args = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "fix ab m n rs args lm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "assume ind2:\n        \"\\<And> m n rs args lm.\n         \\<lbrakk>lm = <aa # list @ [ab]>; args = aa # list @ [ab]\\<rbrakk>\n         \\<Longrightarrow> \\<exists>stp ln rn.\n         steps0 (Suc 0, Bk # Bk\\<up>(m) @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n         (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk #\n         Bk # Oc\\<up>(bl_bin (<aa # list @ [ab]>) + rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @ Bk\\<up>(rn))\"\n        and k: \"args = aa # list @ [Suc ab]\" \"lm = <aa # list @ [Suc ab]>\""], ["proof (state)\nthis:\n  \\<lbrakk>?lm = <aa # list @ [ab]>; ?args = aa # list @ [ab]\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp ln rn.\n                       steps0\n                        (Suc 0,\n                         Bk #\n                         Bk \\<up> ?m @\n                         <ab # rev list @ [aa]> @ Bk # Bk # ires,\n                         Bk # Oc \\<up> Suc ?rs @ Bk \\<up> ?n)\n                        t_wcode_main stp =\n                       (0, Bk # ires,\n                        Bk #\n                        Oc #\n                        Bk \\<up> ln @\n                        Bk #\n                        Bk #\n                        Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n                                  ?rs *\n                                  2 ^\n                                  (length (<aa # list @ [ab]>) - Suc 0)) @\n                        Bk \\<up> rn)\n  args = aa # list @ [Suc ab]\n  lm = <aa # list @ [Suc ab]>\n\ngoal (1 subgoal):\n 1. \\<And>ab m n rs args lm.\n       \\<lbrakk>\\<And>m n rs args lm.\n                   \\<lbrakk>lm = <aa # list @ [ab]>;\n                    args = aa # list @ [ab]\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stp ln rn.\n  steps0\n   (Suc 0, Bk # Bk \\<up> m @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n   t_wcode_main stp =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> ln @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             rs * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rn);\n        lm = <aa # list @ [Suc ab]>; args = aa # list @ [Suc ab];\n        x = Suc (length list); lma__ = <aa # list @ [a]>;\n        argsa__ = aa # list @ [a]; xs = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp ln rn.\n                            steps0\n                             (Suc 0,\n                              Bk #\n                              Bk \\<up> m @\n                              <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n                              Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n                             t_wcode_main stp =\n                            (0, Bk # ires,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk #\n                             Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n                             Bk \\<up> rn)", "show \"\\<exists>stp ln rn.\n         steps0 (Suc 0, Bk # Bk\\<up>(m) @ <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n         (0, Bk # ires,Bk # Oc # Bk\\<up>(ln) @ Bk # \n         Bk # Oc\\<up>(bl_bin (<aa # list @ [Suc ab]>) + rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk # Bk \\<up> m @ <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n                  rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n        Bk \\<up> rn)", "proof(simp add: tape_of_nl_cons_app1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n        Bk \\<up> rn)", "have \"\\<exists>stp ln rn.\n           steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc\\<up>(Suc (Suc ab)) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires, \n           Bk # Oc # Oc\\<up>(rs) @ Bk\\<up>(n)) t_wcode_main stp\n           = (Suc 0, Bk # Bk\\<up>(ln) @ Oc\\<up>(Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n           Bk # Oc\\<up>(Suc (2*rs + 2)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0,\n        Bk #\n        Bk \\<up> ln @\n        Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "using wcode_double_case[of m \"Oc\\<up>(ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires\"\n              rs n]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk #\n       Bk \\<up> m @\n       Oc # Oc # Oc \\<up> ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0,\n      Bk #\n      Bk \\<up> ln @\n      Oc # Oc \\<up> ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (Suc 0,\n        Bk #\n        Bk \\<up> ln @\n        Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n        Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "apply(simp add: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk #\n       Bk \\<up> m @\n       Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0,\n      Bk #\n      Bk \\<up> ln @\n      Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n        Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk #\n       Bk \\<up> m @\n       Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0,\n      Bk #\n      Bk \\<up> ln @\n      Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)", "obtain stpa lna rna where stp1:\n          \"steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc\\<up>(Suc (Suc ab)) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires, \n           Bk # Oc # Oc\\<up>(rs) @ Bk\\<up>(n)) t_wcode_main stpa\n           = (Suc 0, Bk # Bk\\<up>(lna) @ Oc\\<up>(Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n           Bk # Oc\\<up>(Suc (2*rs + 2)) @ Bk\\<up>(rna))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk #\n       Bk \\<up> m @\n       Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (Suc 0,\n      Bk #\n      Bk \\<up> ln @\n      Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n      Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpa lna rna.\n        steps0\n         (Suc 0,\n          Bk #\n          Bk \\<up> m @\n          Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n          Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n         t_wcode_main stpa =\n        (Suc 0,\n         Bk #\n         Bk \\<up> lna @\n         Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0,\n    Bk #\n    Bk \\<up> m @\n    Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0,\n   Bk #\n   Bk \\<up> lna @ Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n        Bk \\<up> rn)", "from k"], ["proof (chain)\npicking this:\n  args = aa # list @ [Suc ab]\n  lm = <aa # list @ [Suc ab]>", "have \n          \"\\<exists> stp ln rn. steps0 (Suc 0, Bk # Bk\\<up>(lna) @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n           Bk # Oc\\<up>(Suc (2*rs + 2)) @ Bk\\<up>(rna)) t_wcode_main stp\n           = (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk #\n           Bk # Oc\\<up>(bl_bin (<aa # list @ [ab]> ) +  (2*rs + 2)* 2^(length (<aa # list @ [ab]>) - Suc 0)) @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  args = aa # list @ [Suc ab]\n  lm = <aa # list @ [Suc ab]>\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n                  (2 * rs + 2) *\n                  2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n        Bk \\<up> rn)", "apply(rule_tac ind2, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n                (2 * rs + 2) * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n      Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n        Bk \\<up> rn)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n                (2 * rs + 2) * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n      Bk \\<up> rn)", "obtain stpb lnb rnb where stp2: \n          \"steps0 (Suc 0, Bk # Bk\\<up>(lna) @  <ab # rev list @ [aa]> @ Bk # Bk # ires,\n           Bk # Oc\\<up>(Suc (2*rs + 2)) @ Bk\\<up>(rna)) t_wcode_main stpb\n           = (0, Bk # ires, Bk # Oc # Bk\\<up>(lnb) @ Bk #\n           Bk # Oc\\<up>(bl_bin (<aa # list @ [ab]> ) +  (2*rs + 2)* 2^(length (<aa # list @ [ab]>) - Suc 0)) @ Bk\\<up>(rnb))\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n                (2 * rs + 2) * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n      Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb lnb rnb.\n        steps0\n         (Suc 0,\n          Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n          Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n         t_wcode_main stpb =\n        (0, Bk # ires,\n         Bk #\n         Oc #\n         Bk \\<up> lnb @\n         Bk #\n         Bk #\n         Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n                   (2 * rs + 2) *\n                   2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n         Bk \\<up> rnb) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             (2 * rs + 2) * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rnb)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n        Bk \\<up> rn)", "from stp1 and stp2"], ["proof (chain)\npicking this:\n  steps0\n   (Suc 0,\n    Bk #\n    Bk \\<up> m @\n    Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0,\n   Bk #\n   Bk \\<up> lna @ Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             (2 * rs + 2) * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rnb)", "show \n          \"\\<exists>stp ln rn.\n           steps0 (Suc 0, Bk # Bk\\<up>(m) @ Oc\\<up>(Suc (Suc ab)) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n           Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(n)) t_wcode_main stp =\n           (0, Bk # ires, Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # \n           Oc\\<up>(bl_bin (Oc\\<up>(Suc aa) @ Bk # <list @ [Suc ab]>) + rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) \n           @ Bk\\<up>(rn))\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0,\n    Bk #\n    Bk \\<up> m @\n    Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc # Oc \\<up> rs @ Bk \\<up> n)\n   t_wcode_main stpa =\n  (Suc 0,\n   Bk #\n   Bk \\<up> lna @ Oc \\<up> Suc ab @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n   Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n  steps0\n   (Suc 0, Bk # Bk \\<up> lna @ <ab # rev list @ [aa]> @ Bk # Bk # ires,\n    Bk # Oc \\<up> Suc (2 * rs + 2) @ Bk \\<up> rna)\n   t_wcode_main stpb =\n  (0, Bk # ires,\n   Bk #\n   Oc #\n   Bk \\<up> lnb @\n   Bk #\n   Bk #\n   Oc \\<up> (bl_bin (<aa # list @ [ab]>) +\n             (2 * rs + 2) * 2 ^ (length (<aa # list @ [ab]>) - Suc 0)) @\n   Bk \\<up> rnb)\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0\n        (Suc 0,\n         Bk #\n         Bk \\<up> m @\n         Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n         Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n        t_wcode_main stp =\n       (0, Bk # ires,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk #\n        Bk #\n        Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                  rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n        Bk \\<up> rn)", "apply(rule_tac x = \"stpa + stpb\" in exI, rule_tac x = lnb in exI,\n              rule_tac x = rnb in exI, simp add: steps_add tape_of_nl_cons_app1 replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0,\n       Bk #\n       Bk \\<up> m @\n       Oc \\<up> Suc (Suc ab) @ Bk # <rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (Oc \\<up> Suc aa @ Bk # <list @ [Suc ab]>) +\n                rs * (2 * 2 ^ (aa + length (<list @ [Suc ab]>)))) @\n      Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ <Suc ab # rev list @ [aa]> @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<aa # list @ [Suc ab]>) +\n                rs * 2 ^ (length (<aa # list @ [Suc ab]>) - Suc 0)) @\n      Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0\n      (Suc 0, Bk # Bk \\<up> m @ rev lm @ Bk # Bk # ires,\n       Bk # Oc \\<up> Suc rs @ Bk \\<up> n)\n      t_wcode_main stp =\n     (0, Bk # ires,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk # Oc \\<up> (bl_bin lm + rs * 2 ^ (length lm - 1)) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition t_wcode_prepare :: \"instr list\"\n  where\n    \"t_wcode_prepare \\<equiv> \n         [(W1, 2), (L, 1), (L, 3), (R, 2), (R, 4), (W0, 3),\n          (R, 4), (R, 5), (R, 6), (R, 5), (R, 7), (R, 5),\n          (W1, 7), (L, 0)]\""], ["", "fun wprepare_add_one :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_add_one m lm (l, r) = \n      (\\<exists> rn. l = [] \\<and>\n               (r = <m # lm> @ Bk\\<up>(rn) \\<or> \n                r = Bk # <m # lm> @ Bk\\<up>(rn)))\""], ["", "fun wprepare_goto_first_end :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_goto_first_end m lm (l, r) = \n      (\\<exists> ml mr rn. l = Oc\\<up>(ml) \\<and>\n                      r = Oc\\<up>(mr) @ Bk # <lm> @ Bk\\<up>(rn) \\<and>\n                      ml + mr = Suc (Suc m))\""], ["", "fun wprepare_erase :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow>  bool\"\n  where\n    \"wprepare_erase m lm (l, r) = \n     (\\<exists> rn. l = Oc\\<up>(Suc m) \\<and> \n               tl r = Bk # <lm> @ Bk\\<up>(rn))\""], ["", "fun wprepare_goto_start_pos_B :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_goto_start_pos_B m lm (l, r) = \n     (\\<exists> rn. l = Bk # Oc\\<up>(Suc m) \\<and>\n               r = Bk # <lm> @ Bk\\<up>(rn))\""], ["", "fun wprepare_goto_start_pos_O :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_goto_start_pos_O m lm (l, r) = \n     (\\<exists> rn. l = Bk # Bk # Oc\\<up>(Suc m) \\<and>\n               r = <lm> @ Bk\\<up>(rn))\""], ["", "fun wprepare_goto_start_pos :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_goto_start_pos m lm (l, r) = \n       (wprepare_goto_start_pos_B m lm (l, r) \\<or>\n        wprepare_goto_start_pos_O m lm (l, r))\""], ["", "fun wprepare_loop_start_on_rightmost :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_loop_start_on_rightmost m lm (l, r) = \n     (\\<exists> rn mr. rev l @ r = Oc\\<up>(Suc m) @ Bk # Bk # <lm> @ Bk\\<up>(rn) \\<and> l \\<noteq> [] \\<and>\n                       r = Oc\\<up>(mr) @ Bk\\<up>(rn))\""], ["", "fun wprepare_loop_start_in_middle :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_loop_start_in_middle m lm (l, r) =\n     (\\<exists> rn (mr:: nat) (lm1::nat list). \n  rev l @ r = Oc\\<up>(Suc m) @ Bk # Bk # <lm> @ Bk\\<up>(rn) \\<and> l \\<noteq> [] \\<and>\n  r = Oc\\<up>(mr) @ Bk # <lm1> @ Bk\\<up>(rn) \\<and> lm1 \\<noteq> [])\""], ["", "fun wprepare_loop_start :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_loop_start m lm (l, r) = (wprepare_loop_start_on_rightmost m lm (l, r) \\<or> \n                                      wprepare_loop_start_in_middle m lm (l, r))\""], ["", "fun wprepare_loop_goon_on_rightmost :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_loop_goon_on_rightmost m lm (l, r) = \n     (\\<exists> rn. l = Bk # <rev lm> @ Bk # Bk # Oc\\<up>(Suc m) \\<and>\n               r = Bk\\<up>(rn))\""], ["", "fun wprepare_loop_goon_in_middle :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_loop_goon_in_middle m lm (l, r) = \n     (\\<exists> rn (mr:: nat) (lm1::nat list). \n  rev l @ r = Oc\\<up>(Suc m) @ Bk # Bk # <lm> @ Bk\\<up>(rn) \\<and> l \\<noteq> [] \\<and>\n                     (if lm1 = [] then r = Oc\\<up>(mr) @ Bk\\<up>(rn) \n                     else r = Oc\\<up>(mr) @ Bk # <lm1> @ Bk\\<up>(rn)) \\<and> mr > 0)\""], ["", "fun wprepare_loop_goon :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_loop_goon m lm (l, r) = \n              (wprepare_loop_goon_in_middle m lm (l, r) \\<or> \n               wprepare_loop_goon_on_rightmost m lm (l, r))\""], ["", "fun wprepare_add_one2 :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_add_one2 m lm (l, r) =\n          (\\<exists> rn. l = Bk # Bk # <rev lm> @ Bk # Bk # Oc\\<up>(Suc m) \\<and>\n               (r = [] \\<or> tl r = Bk\\<up>(rn)))\""], ["", "fun wprepare_stop :: \"nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_stop m lm (l, r) = \n         (\\<exists> rn. l = Bk # <rev lm> @ Bk # Bk # Oc\\<up>(Suc m) \\<and>\n               r = Bk # Oc # Bk\\<up>(rn))\""], ["", "fun wprepare_inv :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wprepare_inv st m lm (l, r) = \n        (if st = 0 then wprepare_stop m lm (l, r) \n         else if st = Suc 0 then wprepare_add_one m lm (l, r)\n         else if st = Suc (Suc 0) then wprepare_goto_first_end m lm (l, r)\n         else if st = Suc (Suc (Suc 0)) then wprepare_erase m lm (l, r)\n         else if st = 4 then wprepare_goto_start_pos m lm (l, r)\n         else if st = 5 then wprepare_loop_start m lm (l, r)\n         else if st = 6 then wprepare_loop_goon m lm (l, r)\n         else if st = 7 then wprepare_add_one2 m lm (l, r)\n         else False)\""], ["", "fun wprepare_stage :: \"config \\<Rightarrow> nat\"\n  where\n    \"wprepare_stage (st, l, r) = \n      (if st \\<ge> 1 \\<and> st \\<le> 4 then 3\n       else if st = 5 \\<or> st = 6 then 2\n       else 1)\""], ["", "fun wprepare_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"wprepare_state (st, l, r) = \n       (if st = 1 then 4\n        else if st = Suc (Suc 0) then 3\n        else if st = Suc (Suc (Suc 0)) then 2\n        else if st = 4 then 1\n        else if st = 7 then 2\n        else 0)\""], ["", "fun wprepare_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"wprepare_step (st, l, r) = \n      (if st = 1 then (if hd r = Oc then Suc (length l)\n                       else 0)\n       else if st = Suc (Suc 0) then length r\n       else if st = Suc (Suc (Suc 0)) then (if hd r = Oc then 1\n                            else 0)\n       else if st = 4 then length r\n       else if st = 5 then Suc (length r)\n       else if st = 6 then (if r = [] then 0 else Suc (length r))\n       else if st = 7 then (if (r \\<noteq> [] \\<and> hd r = Oc) then 0\n                            else 1)\n       else 0)\""], ["", "fun wcode_prepare_measure :: \"config \\<Rightarrow> nat \\<times> nat \\<times> nat\"\n  where\n    \"wcode_prepare_measure (st, l, r) = \n     (wprepare_stage (st, l, r), \n      wprepare_state (st, l, r), \n      wprepare_step (st, l, r))\""], ["", "definition wcode_prepare_le :: \"(config \\<times> config) set\"\n  where \"wcode_prepare_le \\<equiv> (inv_image lex_triple wcode_prepare_measure)\""], ["", "lemma wf_wcode_prepare_le[intro]: \"wf wcode_prepare_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wcode_prepare_le", "by(auto intro:wf_inv_image simp: wcode_prepare_le_def \n      lex_triple_def)"], ["", "declare wprepare_add_one.simps[simp del] wprepare_goto_first_end.simps[simp del]\n  wprepare_erase.simps[simp del] wprepare_goto_start_pos.simps[simp del]\n  wprepare_loop_start.simps[simp del] wprepare_loop_goon.simps[simp del]\n  wprepare_add_one2.simps[simp del]"], ["", "lemmas wprepare_invs = wprepare_add_one.simps wprepare_goto_first_end.simps\n  wprepare_erase.simps wprepare_goto_start_pos.simps\n  wprepare_loop_start.simps wprepare_loop_goon.simps\n  wprepare_add_one2.simps"], ["", "declare wprepare_inv.simps[simp del]"], ["", "lemma fetch_t_wcode_prepare[simp]:\n  \"fetch t_wcode_prepare (Suc 0) Bk = (W1, 2)\"\n  \"fetch t_wcode_prepare (Suc 0) Oc = (L, 1)\"\n  \"fetch t_wcode_prepare (Suc (Suc 0)) Bk = (L, 3)\"\n  \"fetch t_wcode_prepare (Suc (Suc 0)) Oc = (R, 2)\"\n  \"fetch t_wcode_prepare (Suc (Suc (Suc 0))) Bk = (R, 4)\"\n  \"fetch t_wcode_prepare (Suc (Suc (Suc 0))) Oc = (W0, 3)\"\n  \"fetch t_wcode_prepare 4 Bk = (R, 4)\"\n  \"fetch t_wcode_prepare 4 Oc = (R, 5)\"\n  \"fetch t_wcode_prepare 5 Oc = (R, 5)\"\n  \"fetch t_wcode_prepare 5 Bk = (R, 6)\"\n  \"fetch t_wcode_prepare 6 Oc = (R, 5)\"\n  \"fetch t_wcode_prepare 6 Bk = (R, 7)\"\n  \"fetch t_wcode_prepare 7 Oc = (L, 0)\"\n  \"fetch t_wcode_prepare 7 Bk = (W1, 7)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((fetch t_wcode_prepare (Suc 0) Bk = (W1, 2) &&&\n      fetch t_wcode_prepare (Suc 0) Oc = (L, 1) &&&\n      fetch t_wcode_prepare (Suc (Suc 0)) Bk = (L, 3)) &&&\n     (fetch t_wcode_prepare (Suc (Suc 0)) Oc = (R, 2) &&&\n      fetch t_wcode_prepare (Suc (Suc (Suc 0))) Bk = (R, 4)) &&&\n     fetch t_wcode_prepare (Suc (Suc (Suc 0))) Oc = (W0, 3) &&&\n     fetch t_wcode_prepare 4 Bk = (R, 4)) &&&\n    (fetch t_wcode_prepare 4 Oc = (R, 5) &&&\n     fetch t_wcode_prepare 5 Oc = (R, 5) &&&\n     fetch t_wcode_prepare 5 Bk = (R, 6)) &&&\n    (fetch t_wcode_prepare 6 Oc = (R, 5) &&&\n     fetch t_wcode_prepare 6 Bk = (R, 7)) &&&\n    fetch t_wcode_prepare 7 Oc = (L, 0) &&&\n    fetch t_wcode_prepare 7 Bk = (W1, 7)", "unfolding fetch.simps t_wcode_prepare_def nth_of.simps\n    numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((case if length\n                [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                 (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                 (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n               \\<le> Suc 1 * 0\n            then None\n            else Some\n                  ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                    (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                    (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                   (Suc 1 * 0)) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (W1, Suc 1) &&&\n      (case if length\n                [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                 (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                 (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n               \\<le> Suc 1 * 0 + 1\n            then None\n            else Some\n                  ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                    (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                    (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                   (Suc 1 * 0 + 1)) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, 1) &&&\n      (case if length\n                [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                 (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                 (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n               \\<le> Suc 1 * Suc 0\n            then None\n            else Some\n                  ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                    (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                    (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                   (Suc 1 * Suc 0)) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, Suc (Suc 1))) &&&\n     ((case if length\n                [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                 (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                 (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n               \\<le> Suc 1 * Suc 0 + 1\n            then None\n            else Some\n                  ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                    (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                    (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                   (Suc 1 * Suc 0 + 1)) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (R, Suc 1) &&&\n      (case if length\n                [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                 (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                 (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                 (R, Suc (Suc (Suc (Suc 1)))),\n                 (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n               \\<le> Suc 1 * Suc (Suc 0)\n            then None\n            else Some\n                  ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                    (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                    (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                    (R, Suc (Suc (Suc (Suc 1)))),\n                    (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                   (Suc 1 * Suc (Suc 0))) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (R, Suc (Suc (Suc 1)))) &&&\n     (case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc 0) + 1\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc 0) + 1)) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (W0, Suc (Suc 1)) &&&\n     (case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc 1)\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc 1))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc 1)))) &&&\n    ((case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc 1) + 1\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc 1) + 1)) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc 1)))) &&&\n     (case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc (Suc 1)) + 1\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc (Suc 1)) + 1)) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc 1)))) &&&\n     (case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc (Suc 1))\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc (Suc 1)))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc (Suc 1)))))) &&&\n    ((case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc (Suc (Suc 1))) + 1\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc (Suc (Suc 1))) + 1)) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc 1)))) &&&\n     (case if length\n               [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                (R, Suc (Suc (Suc (Suc 1)))),\n                (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n              \\<le> Suc 1 * Suc (Suc (Suc (Suc 1)))\n           then None\n           else Some\n                 ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                   (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                   (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                   (R, Suc (Suc (Suc (Suc 1)))),\n                   (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                  (Suc 1 * Suc (Suc (Suc (Suc 1))))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc (Suc (Suc 1))))))) &&&\n    (case if length\n              [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n               (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n               (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n               (R, Suc (Suc (Suc (Suc (Suc 1))))),\n               (R, Suc (Suc (Suc (Suc 1)))),\n               (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n               (R, Suc (Suc (Suc (Suc 1)))),\n               (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n             \\<le> Suc 1 * Suc (Suc (Suc (Suc (Suc 1)))) + 1\n          then None\n          else Some\n                ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                  (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                  (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                  (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                  (R, Suc (Suc (Suc (Suc 1)))),\n                  (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                  (R, Suc (Suc (Suc (Suc 1)))),\n                  (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                 (Suc 1 * Suc (Suc (Suc (Suc (Suc 1)))) + 1)) of\n     None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n    (L, 0) &&&\n    (case if length\n              [(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n               (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n               (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n               (R, Suc (Suc (Suc (Suc (Suc 1))))),\n               (R, Suc (Suc (Suc (Suc 1)))),\n               (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n               (R, Suc (Suc (Suc (Suc 1)))),\n               (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)]\n             \\<le> Suc 1 * Suc (Suc (Suc (Suc (Suc 1))))\n          then None\n          else Some\n                ([(W1, Suc 1), (L, 1), (L, Suc (Suc 1)), (R, Suc 1),\n                  (R, Suc (Suc (Suc 1))), (W0, Suc (Suc 1)),\n                  (R, Suc (Suc (Suc 1))), (R, Suc (Suc (Suc (Suc 1)))),\n                  (R, Suc (Suc (Suc (Suc (Suc 1))))),\n                  (R, Suc (Suc (Suc (Suc 1)))),\n                  (R, Suc (Suc (Suc (Suc (Suc (Suc 1)))))),\n                  (R, Suc (Suc (Suc (Suc 1)))),\n                  (W1, Suc (Suc (Suc (Suc (Suc (Suc 1)))))), (L, 0)] !\n                 (Suc 1 * Suc (Suc (Suc (Suc (Suc 1)))))) of\n     None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n    (W1, Suc (Suc (Suc (Suc (Suc (Suc 1))))))", "by auto"], ["", "lemma wprepare_add_one_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_add_one m lm (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm \\<noteq> [] \\<Longrightarrow> wprepare_add_one m lm (b, []) = False", "apply(simp add: wprepare_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_first_end_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_goto_first_end m lm (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm \\<noteq> [] \\<Longrightarrow>\n    wprepare_goto_first_end m lm (b, []) = False", "apply(simp add: wprepare_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_erase_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_erase m lm (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm \\<noteq> [] \\<Longrightarrow> wprepare_erase m lm (b, []) = False", "apply(simp add: wprepare_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_start_pos_nonempty_snd[simp]: \"lm \\<noteq> [] \\<Longrightarrow> wprepare_goto_start_pos m lm (b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm \\<noteq> [] \\<Longrightarrow>\n    wprepare_goto_start_pos m lm (b, []) = False", "apply(simp add: wprepare_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_start_empty_nonempty_fst[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [])\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> []", "apply(simp add: wprepare_invs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rev_eq: \"rev xs = rev ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs = rev ys \\<Longrightarrow> xs = ys", "by auto"], ["", "lemma wprepare_loop_goon_Bk_empty_snd[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [])\\<rbrakk> \\<Longrightarrow> \n                                  wprepare_loop_goon m lm (Bk # b, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon m lm (Bk # b, [])", "apply(simp only: wprepare_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_on_rightmost m lm (b, []) \\<or>\n     wprepare_loop_start_in_middle m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, []) \\<or>\n                      wprepare_loop_goon_on_rightmost m lm (Bk # b, [])", "apply(erule_tac disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_on_rightmost m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, []) \\<or>\n                      wprepare_loop_goon_on_rightmost m lm (Bk # b, [])\n 2. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_in_middle m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, []) \\<or>\n                      wprepare_loop_goon_on_rightmost m lm (Bk # b, [])", "apply(rule_tac disjI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_on_rightmost m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_on_rightmost m lm (Bk # b, [])\n 2. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_in_middle m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, []) \\<or>\n                      wprepare_loop_goon_on_rightmost m lm (Bk # b, [])", "apply(simp add: wprepare_loop_start_on_rightmost.simps\n      wprepare_loop_goon_on_rightmost.simps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; rev b = Oc \\<up> Suc m @ Bk # Bk # <lm>;\n     b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> b = <rev lm> @ Bk # Bk # Oc \\<up> Suc m", "apply(rule_tac rev_eq, simp add: tape_of_nl_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_nonempty_fst[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, [])\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> []", "apply(simp only: wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_add_one2_Bk_empty[simp]:\"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, [])\\<rbrakk> \\<Longrightarrow> \n  wprepare_add_one2 m lm (Bk # b, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, [])\\<rbrakk>\n    \\<Longrightarrow> wprepare_add_one2 m lm (Bk # b, [])", "apply(simp only: wprepare_invs, auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_add_one2_nonempty_fst[simp]: \"wprepare_add_one2 m lm (b, []) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one2 m lm (b, []) \\<Longrightarrow> b \\<noteq> []", "apply(simp only: wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_add_one2_Oc[simp]: \"wprepare_add_one2 m lm (b, []) \\<Longrightarrow> wprepare_add_one2 m lm (b, [Oc])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one2 m lm (b, []) \\<Longrightarrow>\n    wprepare_add_one2 m lm (b, [Oc])", "apply(simp only: wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Bk_not_tape_start[simp]: \"(Bk # list = <(m::nat) # lm> @ ys) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Bk # list = <m # lm> @ ys) = False", "apply(case_tac lm, auto simp: tape_of_nl_cons replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_first_end_cases[simp]:\n  \"\\<lbrakk>lm \\<noteq> []; wprepare_add_one m lm (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> (b = [] \\<longrightarrow> wprepare_goto_first_end m lm ([], Oc # list)) \\<and> \n           (b \\<noteq> [] \\<longrightarrow> wprepare_goto_first_end m lm (b, Oc # list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_add_one m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (b = [] \\<longrightarrow>\n                       wprepare_goto_first_end m lm ([], Oc # list)) \\<and>\n                      (b \\<noteq> [] \\<longrightarrow>\n                       wprepare_goto_first_end m lm (b, Oc # list))", "apply(simp only: wprepare_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     \\<exists>rn.\n        b = [] \\<and>\n        (Bk # list = <m # lm> @ Bk \\<up> rn \\<or>\n         Bk # list = Bk # <m # lm> @ Bk \\<up> rn)\\<rbrakk>\n    \\<Longrightarrow> (b = [] \\<longrightarrow>\n                       (\\<exists>ml mr rn.\n                           [] = Oc \\<up> ml \\<and>\n                           Oc # list =\n                           Oc \\<up> mr @ Bk # <lm> @ Bk \\<up> rn \\<and>\n                           ml + mr = Suc (Suc m))) \\<and>\n                      (b \\<noteq> [] \\<longrightarrow>\n                       (\\<exists>ml mr rn.\n                           b = Oc \\<up> ml \\<and>\n                           Oc # list =\n                           Oc \\<up> mr @ Bk # <lm> @ Bk \\<up> rn \\<and>\n                           ml + mr = Suc (Suc m)))", "apply(auto simp: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = [];\n        list = Oc \\<up> Suc m @ Bk # <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Oc \\<up> Suc m @ Bk # <lm> @ Bk \\<up> rn =\n                            Oc \\<up> Suc (Suc m) @ Bk # <lm> @ Bk \\<up> rna", "apply(cases lm, auto simp add:tape_of_list_def replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_first_end_Bk_nonempty_fst[simp]:\n  \"wprepare_goto_first_end m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_goto_first_end m lm (b, Bk # list) \\<Longrightarrow>\n    b \\<noteq> []", "apply(simp only: wprepare_invs , auto simp: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare replicate_Suc[simp]"], ["", "lemma wprepare_erase_elem_Bk_rest[simp]: \"wprepare_goto_first_end m lm (b, Bk # list) \\<Longrightarrow>\n                          wprepare_erase m lm (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_goto_first_end m lm (b, Bk # list) \\<Longrightarrow>\n    wprepare_erase m lm (tl b, hd b # Bk # list)", "by(simp add: wprepare_invs)"], ["", "lemma wprepare_erase_Bk_nonempty_fst[simp]: \"wprepare_erase m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_erase m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []", "by(simp add: wprepare_invs)"], ["", "lemma wprepare_goto_start_pos_Bk[simp]: \"wprepare_erase m lm (b, Bk # list) \\<Longrightarrow> \n                           wprepare_goto_start_pos m lm (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_erase m lm (b, Bk # list) \\<Longrightarrow>\n    wprepare_goto_start_pos m lm (Bk # b, list)", "apply(simp only: wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_add_one_Bk_nonempty_snd[simp]: \"\\<lbrakk>wprepare_add_one m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one m lm (b, Bk # list) \\<Longrightarrow> list \\<noteq> []", "apply(simp only: wprepare_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn.\n       b = [] \\<and>\n       (Bk # list = <m # lm> @ Bk \\<up> rn \\<or>\n        Bk # list = Bk # <m # lm> @ Bk \\<up> rn) \\<Longrightarrow>\n    list \\<noteq> []", "apply(case_tac lm, simp_all add: tape_of_list_def tape_of_nat_def, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_first_end_nonempty_snd_tl[simp]:\n  \"\\<lbrakk>lm \\<noteq> [];  wprepare_goto_first_end m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_goto_first_end m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> list \\<noteq> []", "by(simp only: wprepare_invs, auto)"], ["", "lemma wprepare_erase_Bk_nonempty_list[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_erase m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_erase m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> list \\<noteq> []", "apply(simp only: wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_start_pos_Bk_nonempty[simp]: \"\\<lbrakk>lm \\<noteq> [];  wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> list \\<noteq> []", "by(cases lm;cases list;simp only: wprepare_invs, auto)"], ["", "lemma wprepare_goto_start_pos_Bk_nonempty_fst[simp]: \"\\<lbrakk>lm \\<noteq> [];  wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> []", "apply(simp only: wprepare_invs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_goto_start_pos_B m lm (b, Bk # list) \\<or>\n     wprepare_goto_start_pos_O m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> []", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_Bk_nonempty[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> []", "apply(simp only: wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_wprepare_add_one2_cases[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow> \n  (list = [] \\<longrightarrow> wprepare_add_one2 m lm (Bk # b, [])) \\<and> \n  (list \\<noteq> [] \\<longrightarrow> wprepare_add_one2 m lm (Bk # b, list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_goon m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (list = [] \\<longrightarrow>\n                       wprepare_add_one2 m lm (Bk # b, [])) \\<and>\n                      (list \\<noteq> [] \\<longrightarrow>\n                       wprepare_add_one2 m lm (Bk # b, list))", "unfolding wprepare_invs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_goon_in_middle m lm (b, Bk # list) \\<or>\n     wprepare_loop_goon_on_rightmost m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (list = [] \\<longrightarrow>\n                       (\\<exists>rn.\n                           Bk # b =\n                           Bk #\n                           Bk # <rev lm> @ Bk # Bk # Oc \\<up> Suc m \\<and>\n                           ([] = [] \\<or> tl [] = Bk \\<up> rn))) \\<and>\n                      (list \\<noteq> [] \\<longrightarrow>\n                       (\\<exists>rn.\n                           Bk # b =\n                           Bk #\n                           Bk # <rev lm> @ Bk # Bk # Oc \\<up> Suc m \\<and>\n                           (list = [] \\<or> tl list = Bk \\<up> rn)))", "apply(cases list;auto split:nat.split if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lista rn.\n       \\<lbrakk>list = a # lista; lm \\<noteq> [];\n        b = Bk # <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        Bk # a # lista = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn. lista = Bk \\<up> rn", "by (metis list.sel(3) tl_replicate)"], ["", "lemma wprepare_add_one2_nonempty[simp]: \"wprepare_add_one2 m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one2 m lm (b, Bk # list) \\<Longrightarrow> b \\<noteq> []", "apply(simp only: wprepare_invs, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_add_one2_cases[simp]: \"wprepare_add_one2 m lm (b, Bk # list) \\<Longrightarrow> \n      (list = [] \\<longrightarrow> wprepare_add_one2 m lm (b, [Oc])) \\<and> \n      (list \\<noteq> [] \\<longrightarrow> wprepare_add_one2 m lm (b, Oc # list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one2 m lm (b, Bk # list) \\<Longrightarrow>\n    (list = [] \\<longrightarrow> wprepare_add_one2 m lm (b, [Oc])) \\<and>\n    (list \\<noteq> [] \\<longrightarrow>\n     wprepare_add_one2 m lm (b, Oc # list))", "apply(simp only:  wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_first_end_cases_Oc[simp]: \"wprepare_goto_first_end m lm (b, Oc # list)\n       \\<Longrightarrow> (b = [] \\<longrightarrow> wprepare_goto_first_end m lm ([Oc], list)) \\<and> \n           (b \\<noteq> [] \\<longrightarrow> wprepare_goto_first_end m lm (Oc # b, list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_goto_first_end m lm (b, Oc # list) \\<Longrightarrow>\n    (b = [] \\<longrightarrow>\n     wprepare_goto_first_end m lm ([Oc], list)) \\<and>\n    (b \\<noteq> [] \\<longrightarrow>\n     wprepare_goto_first_end m lm (Oc # b, list))", "apply(simp only:  wprepare_invs, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn.\n       \\<lbrakk>b = [];\n        list = Oc # Oc \\<up> m @ Bk # <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            [Oc] = Oc \\<up> ml \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rna.\n                                    Oc #\n                                    Oc \\<up> m @ Bk # <lm> @ Bk \\<up> rn =\n                                    Oc \\<up> mr @\n                                    Bk # <lm> @ Bk \\<up> rna) \\<and>\n                                ml + mr = Suc (Suc m))\n 2. \\<And>ml mr rn.\n       \\<lbrakk>b = Oc \\<up> ml; ml + mr = Suc (Suc m);\n        Oc # list = Oc \\<up> mr @ Bk # <lm> @ Bk \\<up> rn; 0 < ml\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list =\n                                    Oc \\<up> mr @\n                                    Bk # <lm> @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc (Suc m))", "apply(rule_tac x = 1 in exI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Oc \\<up> ml; ml + mr = Suc (Suc m);\n        Oc # list = Oc \\<up> mr @ Bk # <lm> @ Bk \\<up> rn; 0 < ml\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list =\n                                    Oc \\<up> mr @\n                                    Bk # <lm> @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc (Suc m))", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>b = Oc \\<up> ml; ml + mr = Suc (Suc m);\n        Oc # list = Oc \\<up> mr @ Bk # <lm> @ Bk \\<up> rn; 0 < ml\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    list =\n                                    Oc \\<up> mr @\n                                    Bk # <lm> @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc (Suc m))", "apply(case_tac mr, simp_all add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn nat.\n       \\<lbrakk>b = Oc \\<up> ml; ml + nat = Suc m;\n        list = Oc \\<up> nat @ Bk # <lm> @ Bk \\<up> rn; 0 < ml;\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rna.\n                                    Oc \\<up> nat @ Bk # <lm> @ Bk \\<up> rn =\n                                    Oc \\<up> mr @\n                                    Bk # <lm> @ Bk \\<up> rna) \\<and>\n                                mla + mr = Suc (Suc m))", "apply(case_tac ml, simp_all add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn nat nata.\n       \\<lbrakk>b = Oc # Oc \\<up> nata; nata + nat = m;\n        list = Oc \\<up> nat @ Bk # <lm> @ Bk \\<up> rn; mr = Suc nat;\n        ml = Suc nata\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            Oc # Oc # Oc \\<up> nata = Oc \\<up> ml \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rna.\n                                    Oc \\<up> nat @ Bk # <lm> @ Bk \\<up> rn =\n                                    Oc \\<up> mr @\n                                    Bk # <lm> @ Bk \\<up> rna) \\<and>\n                                ml + mr = Suc (Suc m))", "apply(rule_tac x = \"Suc ml\" in exI, simp_all add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn nat nata.\n       \\<lbrakk>b = Oc # Oc \\<up> nata; nata + nat = m;\n        list = Oc \\<up> nat @ Bk # <lm> @ Bk \\<up> rn; mr = Suc nat;\n        ml = Suc nata\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr.\n                            (\\<exists>rna.\n                                Oc \\<up> nat @ Bk # <lm> @ Bk \\<up> rn =\n                                Oc \\<up> mr @\n                                Bk # <lm> @ Bk \\<up> rna) \\<and>\n                            nata + mr = m", "apply(rule_tac x = \"mr - 1\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_erase_nonempty[simp]: \"wprepare_erase m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_erase m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []", "apply(simp only: wprepare_invs, auto simp: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_erase_Bk[simp]: \"wprepare_erase m lm (b, Oc # list)\n  \\<Longrightarrow> wprepare_erase m lm (b, Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_erase m lm (b, Oc # list) \\<Longrightarrow>\n    wprepare_erase m lm (b, Bk # list)", "apply(simp  only:wprepare_invs, auto simp: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_start_pos_Bk_move[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> wprepare_goto_start_pos m lm (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_goto_start_pos m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wprepare_goto_start_pos m lm (Bk # b, list)", "apply(simp only:wprepare_invs, auto)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn;\n        \\<forall>rn. list \\<noteq> Bk # <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn;\n        \\<forall>rn. list \\<noteq> Bk # <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn;\n        \\<forall>rn. list \\<noteq> <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn;\n        \\<forall>rn. list \\<noteq> <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = Bk # Bk # Oc # Oc \\<up> m;\n        Bk # list = <lm> @ Bk \\<up> rn;\n        \\<forall>rn. list \\<noteq> <lm> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn. list = Bk # <lm> @ Bk \\<up> rn", "apply(case_tac [!] lm, simp, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_start_b_nonempty[simp]: \"wprepare_loop_start m lm (b, aa) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start m lm (b, aa) \\<Longrightarrow> b \\<noteq> []", "apply(simp only:wprepare_invs, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exists_exp_of_Bk[elim]: \"Bk # list = Oc\\<up>(mr) @ Bk\\<up>(rn)  \\<Longrightarrow> \\<exists>rn. list = Bk\\<up>(rn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bk # list = Oc \\<up> mr @ Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>rn. list = Bk \\<up> rn", "apply(case_tac mr, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Bk # list = Bk \\<up> rn; mr = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rn. list = Bk \\<up> rn", "apply(case_tac rn, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_start_in_middle_Bk_False[simp]: \"wprepare_loop_start_in_middle m lm (b, [Bk]) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start_in_middle m lm (b, [Bk]) = False", "by(auto)"], ["", "declare wprepare_loop_start_in_middle.simps[simp del]"], ["", "declare wprepare_loop_start_on_rightmost.simps[simp del] \n  wprepare_loop_goon_in_middle.simps[simp del]\n  wprepare_loop_goon_on_rightmost.simps[simp del]"], ["", "lemma wprepare_loop_goon_in_middle_Bk_False[simp]: \"wprepare_loop_goon_in_middle m lm (Bk # b, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_goon_in_middle m lm (Bk # b, []) = False", "apply(simp add: wprepare_loop_goon_in_middle.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_Bk[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [Bk])\\<rbrakk> \\<Longrightarrow>\n  wprepare_loop_goon m lm (Bk # b, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, [Bk])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon m lm (Bk # b, [])", "unfolding wprepare_invs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_on_rightmost m lm (b, [Bk]) \\<or>\n     wprepare_loop_start_in_middle m lm (b, [Bk])\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, []) \\<or>\n                      wprepare_loop_goon_on_rightmost m lm (Bk # b, [])", "apply(auto simp add: wprepare_loop_goon_on_rightmost.simps \n      wprepare_loop_start_on_rightmost.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> [];\n        b = rev (<lm>) @ Bk \\<up> rn @ Bk \\<up> rn @ Oc \\<up> m @ [Oc];\n        [Bk] = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> rev (<lm>) @\n                         Bk \\<up> rn @ Bk \\<up> rn @ Oc \\<up> m @ [Oc] =\n                         <rev lm> @ Bk # Bk # Oc # Oc \\<up> m", "apply(rule_tac rev_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> [];\n        b = rev (<lm>) @ Bk \\<up> rn @ Bk \\<up> rn @ Oc \\<up> m @ [Oc];\n        [Bk] = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> rev (rev (<lm>) @\n                              Bk \\<up> rn @\n                              Bk \\<up> rn @ Oc \\<up> m @ [Oc]) =\n                         rev (<rev lm> @ Bk # Bk # Oc # Oc \\<up> m)", "apply(simp add: tape_of_nl_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> [];\n        b = <rev lm> @ Bk \\<up> rn @ Bk \\<up> rn @ Oc \\<up> m @ [Oc];\n        [Bk] = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc # Oc \\<up> m = Oc \\<up> m @ [Oc]", "apply(simp add: exp_ind replicate_Suc[THEN sym] del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_in_middle_Bk_False2[simp]: \"wprepare_loop_start_on_rightmost m lm (b, Bk # a # lista)\n \\<Longrightarrow> wprepare_loop_goon_in_middle m lm (Bk # b, a # lista) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start_on_rightmost m lm\n     (b, Bk # a # lista) \\<Longrightarrow>\n    wprepare_loop_goon_in_middle m lm (Bk # b, a # lista) = False", "apply(auto simp: wprepare_loop_start_on_rightmost.simps\n      wprepare_loop_goon_in_middle.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_on_rightbmost_Bk_False[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start_on_rightmost m lm (b, Bk # a # lista)\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_on_rightmost m lm (b, Bk # a # lista)\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_on_rightmost m lm\n                       (Bk # b, a # lista)", "apply(simp only: wprepare_loop_start_on_rightmost.simps\n      wprepare_loop_goon_on_rightmost.simps, auto simp: tape_of_nl_rev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc \\<up> m @ [Oc];\n        Bk # a # lista = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> m @ [Oc] = Oc # Oc \\<up> m\n 2. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc \\<up> m @ [Oc];\n        Bk # a # lista = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn. a # lista = Bk \\<up> rn", "apply(simp add: replicate_Suc[THEN sym] exp_ind tape_of_nl_rev del: replicate_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>lm \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc \\<up> m @ [Oc];\n        Bk # a # lista = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn. a # lista = Bk \\<up> rn", "by (meson Cons_replicate_eq)"], ["", "lemma wprepare_loop_goon_in_middle_Bk_False3[simp]: \n  assumes \"lm \\<noteq> []\" \"wprepare_loop_start_in_middle m lm (b, Bk # a # lista)\"\n  shows \"wprepare_loop_goon_in_middle m lm (Bk # b, a # lista)\" (is \"?t1\")\n    and \"wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False\" (is ?t2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_goon_in_middle m lm (Bk # b, a # lista) &&&\n    wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. wprepare_loop_goon_in_middle m lm (Bk # b, a # lista)\n 2. wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False", "from assms"], ["proof (chain)\npicking this:\n  lm \\<noteq> []\n  wprepare_loop_start_in_middle m lm (b, Bk # a # lista)", "obtain rn mr lm1 where *:\"rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\"\n    \"b \\<noteq> []\" \"Bk # a # lista = Oc \\<up> mr @ Bk # <lm1::nat list> @ Bk \\<up> rn\" \"lm1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  lm \\<noteq> []\n  wprepare_loop_start_in_middle m lm (b, Bk # a # lista)\n\ngoal (1 subgoal):\n 1. (\\<And>mr lm1 rn.\n        \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <lm1> =\n                 Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n         b \\<noteq> [];\n         Bk # a # lista = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n         lm1 \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wprepare_loop_start_in_middle.simps)"], ["proof (state)\nthis:\n  rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\n  b \\<noteq> []\n  Bk # a # lista = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\n  lm1 \\<noteq> []\n\ngoal (2 subgoals):\n 1. wprepare_loop_goon_in_middle m lm (Bk # b, a # lista)\n 2. wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False", "thus ?t1"], ["proof (prove)\nusing this:\n  rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\n  b \\<noteq> []\n  Bk # a # lista = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\n  lm1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. wprepare_loop_goon_in_middle m lm (Bk # b, a # lista)", "apply(simp add: wprepare_loop_start_in_middle.simps\n        wprepare_loop_goon_in_middle.simps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> []; lm1 \\<noteq> []; mr = 0;\n     a # lista = <lm1> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna.\n                         rev b @ Bk # <lm1> @ Bk \\<up> rn =\n                         Oc #\n                         Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rna \\<and>\n                         (\\<exists>mr.\n                             (\\<exists>lm1a.\n                                 (lm1a = [] \\<longrightarrow>\n                                  <lm1> @ Bk \\<up> rn =\n                                  Oc \\<up> mr @ Bk \\<up> rna) \\<and>\n                                 (lm1a \\<noteq> [] \\<longrightarrow>\n                                  <lm1> @ Bk \\<up> rn =\n                                  Oc \\<up> mr @\n                                  Bk # <lm1a> @ Bk \\<up> rna)) \\<and>\n                             0 < mr)", "apply(rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> []; lm1 \\<noteq> []; mr = 0;\n     a # lista = <lm1> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>mr.\n                         (\\<exists>lm1a.\n                             (lm1a = [] \\<longrightarrow>\n                              <lm1> = Oc \\<up> mr) \\<and>\n                             (lm1a \\<noteq> [] \\<longrightarrow>\n                              <lm1> = Oc \\<up> mr @ Bk # <lm1a>)) \\<and>\n                         0 < mr", "apply(case_tac mr, simp_all add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> []; lm1 \\<noteq> []; a # lista = <lm1> @ Bk \\<up> rn;\n     mr = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>mr.\n                         (\\<exists>lm1a.\n                             (lm1a = [] \\<longrightarrow>\n                              <lm1> = Oc \\<up> mr) \\<and>\n                             (lm1a \\<noteq> [] \\<longrightarrow>\n                              <lm1> = Oc \\<up> mr @ Bk # <lm1a>)) \\<and>\n                         0 < mr", "apply(case_tac lm1, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rev b @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        b \\<noteq> []; lm1 \\<noteq> []; a # lista = <lm1> @ Bk \\<up> rn;\n        mr = 0; lm1 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr.\n                            (\\<exists>lm1a.\n                                (lm1a = [] \\<longrightarrow>\n                                 <lm1> = Oc \\<up> mr) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 <lm1> = Oc \\<up> mr @ Bk # <lm1a>)) \\<and>\n                            0 < mr", "apply(rule_tac x = \"Suc (hd lm1)\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rev b @ Bk # <aa # list> = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        b \\<noteq> []; a # lista = <aa # list> @ Bk \\<up> rn; mr = 0;\n        lm1 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1.\n                            (lm1 = [] \\<longrightarrow>\n                             <aa # list> = Oc # Oc \\<up> aa) \\<and>\n                            (lm1 \\<noteq> [] \\<longrightarrow>\n                             <aa # list> = Oc # Oc \\<up> aa @ Bk # <lm1>)", "apply(rule_tac x = \"tl lm1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>rev b @ Bk # <aa # list> = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        b \\<noteq> []; a # lista = <aa # list> @ Bk \\<up> rn; mr = 0;\n        lm1 = aa # list\\<rbrakk>\n       \\<Longrightarrow> (tl lm1 = [] \\<longrightarrow>\n                          <aa # list> = Oc # Oc \\<up> aa) \\<and>\n                         (tl lm1 \\<noteq> [] \\<longrightarrow>\n                          <aa # list> = Oc # Oc \\<up> aa @ Bk # <tl lm1>)", "apply(case_tac \"tl lm1\", simp_all add: tape_of_list_def  tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wprepare_loop_goon_in_middle m lm (Bk # b, a # lista)\n\ngoal (1 subgoal):\n 1. wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False", "from *"], ["proof (chain)\npicking this:\n  rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\n  b \\<noteq> []\n  Bk # a # lista = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\n  lm1 \\<noteq> []", "show ?t2"], ["proof (prove)\nusing this:\n  rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\n  b \\<noteq> []\n  Bk # a # lista = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\n  lm1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False", "apply(simp add: wprepare_loop_start_in_middle.simps\n        wprepare_loop_goon_on_rightmost.simps del:split_head_repeat, auto simp del:split_head_repeat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rna.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Oc \\<up> mr @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk # Bk \\<up> rna = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n        lm1 \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = Bk \\<up> rna\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Oc \\<up> mr @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk # Bk \\<up> rna = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n        lm1 \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = Bk \\<up> rna\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac mr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rna.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Oc \\<up> mr @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk # Bk \\<up> rna = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n        lm1 \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = Bk \\<up> rna; mr = 0\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Oc \\<up> mr @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk # Bk \\<up> rna = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n        lm1 \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = Bk \\<up> rna; mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 3. \\<And>rna.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Oc \\<up> mr @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk # Bk \\<up> rna = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n        lm1 \\<noteq> []; b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = Bk \\<up> rna\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac  \"lm1::nat list\", simp_all, case_tac \"tl lm1\", simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rna aa list.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Bk # Oc # Oc \\<up> aa =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk \\<up> rna = Oc # Oc \\<up> aa @ Bk \\<up> rn;\n        b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a = Oc \\<and> lista = Oc \\<up> aa @ Bk \\<up> rn; mr = 0; lm1 = [aa];\n        list = []\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna aa list aaa listaa.\n       \\<lbrakk>Oc \\<up> m @\n                Oc # Bk # Bk # rev (<rev lm>) @ Bk # <aa # aaa # listaa> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        Bk \\<up> rna = <aa # aaa # listaa> @ Bk \\<up> rn;\n        b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = <aa # aaa # listaa> @ Bk \\<up> rn; mr = 0;\n        lm1 = aa # aaa # listaa; list = aaa # listaa\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 3. \\<And>rna.\n       \\<lbrakk>Oc \\<up> m @ Oc # Bk # Bk # rev (<rev lm>) @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        mr = 0 \\<and> Bk \\<up> rna = <lm1> @ Bk \\<up> rn; lm1 \\<noteq> [];\n        b = <rev lm> @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = <lm1> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: tape_of_list_def )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rna aa.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @ Bk # Oc # Oc \\<up> aa =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        Bk \\<up> rna = Oc # Oc \\<up> aa @ Bk \\<up> rn;\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m; mr = 0;\n        lm1 = [aa]; a = Oc; lista = Oc \\<up> aa @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna aa aaa listaa.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # <aa> @ Bk # tape_of_nat_list (aaa # listaa) =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        Bk \\<up> rna =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        mr = 0; lm1 = aa # aaa # listaa\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 3. \\<And>rna.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # tape_of_nat_list lm1 =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        lm1 \\<noteq> [];\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = tape_of_nat_list lm1 @ Bk \\<up> rn; mr = 0;\n        Bk \\<up> rna = tape_of_nat_list lm1 @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac [!] rna, simp_all add: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rna aa aaa listaa nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # <aa> @ Bk # tape_of_nat_list (aaa # listaa) =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        Bk # Bk \\<up> nat =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        mr = 0; lm1 = aa # aaa # listaa; rna = Suc nat\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # tape_of_nat_list lm1 =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        lm1 \\<noteq> [];\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = tape_of_nat_list lm1 @ Bk \\<up> rn; mr = 0;\n        Bk # Bk \\<up> nat = tape_of_nat_list lm1 @ Bk \\<up> rn;\n        rna = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac mr, simp_all add: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rna aa aaa listaa nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # <aa> @ Bk # tape_of_nat_list (aaa # listaa) =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        Bk # Bk \\<up> nat =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        lm1 = aa # aaa # listaa; rna = Suc nat; mr = 0\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # tape_of_nat_list lm1 =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        lm1 \\<noteq> [];\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = tape_of_nat_list lm1 @ Bk \\<up> rn; mr = 0;\n        Bk # Bk \\<up> nat = tape_of_nat_list lm1 @ Bk \\<up> rn;\n        rna = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac lm1, simp, case_tac list, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rna aa aaa listaa nat ab list ac listb.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # <aa> @ Bk # tape_of_nat_list (aaa # listaa) =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        Bk # Bk \\<up> nat =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista =\n        <aa> @ Bk # tape_of_nat_list (aaa # listaa) @ Bk \\<up> rn;\n        lm1 = aa # aaa # listaa; rna = Suc nat; mr = 0; lm1 = ab # list;\n        list = ac # listb\\<rbrakk>\n       \\<Longrightarrow> lm = []\n 2. \\<And>rna nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # tape_of_nat_list lm1 =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        lm1 \\<noteq> [];\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = tape_of_nat_list lm1 @ Bk \\<up> rn; mr = 0;\n        Bk # Bk \\<up> nat = tape_of_nat_list lm1 @ Bk \\<up> rn;\n        rna = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all add: tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rna nat.\n       \\<lbrakk>Oc \\<up> m @\n                Oc #\n                Bk #\n                Bk #\n                rev (tape_of_nat_list (rev lm)) @\n                Bk # tape_of_nat_list lm1 =\n                Oc # Oc \\<up> m @ Bk # Bk # tape_of_nat_list lm;\n        lm1 \\<noteq> [];\n        b = tape_of_nat_list (rev lm) @ Bk # Bk # Oc # Oc \\<up> m;\n        a # lista = tape_of_nat_list lm1 @ Bk \\<up> rn; mr = 0;\n        Bk # Bk \\<up> nat = tape_of_nat_list lm1 @ Bk \\<up> rn;\n        rna = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Bk_not_tape_start tape_of_list_def tape_of_nat_list.elims)"], ["proof (state)\nthis:\n  wprepare_loop_goon_on_rightmost m lm (Bk # b, a # lista) = False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wprepare_loop_goon_Bk2[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, Bk # a # lista)\\<rbrakk> \\<Longrightarrow> \n  wprepare_loop_goon m lm (Bk # b, a # lista)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start m lm (b, Bk # a # lista)\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon m lm (Bk # b, a # lista)", "apply(simp add: wprepare_loop_start.simps \n      wprepare_loop_goon.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start_on_rightmost m lm (b, Bk # a # lista) \\<or>\n     wprepare_loop_start_in_middle m lm (b, Bk # a # lista)\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_goon_in_middle m lm\n                       (Bk # b, a # lista) \\<or>\n                      wprepare_loop_goon_on_rightmost m lm\n                       (Bk # b, a # lista)", "apply(erule_tac disjE, simp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_2_goon:\n  \"\\<lbrakk>lm \\<noteq> []; wprepare_loop_start m lm (b, Bk # list)\\<rbrakk> \\<Longrightarrow>\n   (list = [] \\<longrightarrow> wprepare_loop_goon m lm (Bk # b, [])) \\<and>\n  (list \\<noteq> [] \\<longrightarrow> wprepare_loop_goon m lm (Bk # b, list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_loop_start m lm (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (list = [] \\<longrightarrow>\n                       wprepare_loop_goon m lm (Bk # b, [])) \\<and>\n                      (list \\<noteq> [] \\<longrightarrow>\n                       wprepare_loop_goon m lm (Bk # b, list))", "apply(case_tac list, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_one_2_add_one: \"wprepare_add_one m lm (b, Oc # list)\n  \\<Longrightarrow> (hd b = Oc \\<longrightarrow> (b = [] \\<longrightarrow> wprepare_add_one m lm ([], Bk # Oc # list)) \\<and>\n                     (b \\<noteq> [] \\<longrightarrow> wprepare_add_one m lm (tl b, Oc # Oc # list))) \\<and>\n  (hd b \\<noteq> Oc \\<longrightarrow> (b = [] \\<longrightarrow> wprepare_add_one m lm ([], Bk # Oc # list)) \\<and>\n                 (b \\<noteq> [] \\<longrightarrow> wprepare_add_one m lm (tl b, hd b # Oc # list)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one m lm (b, Oc # list) \\<Longrightarrow>\n    (hd b = Oc \\<longrightarrow>\n     (b = [] \\<longrightarrow>\n      wprepare_add_one m lm ([], Bk # Oc # list)) \\<and>\n     (b \\<noteq> [] \\<longrightarrow>\n      wprepare_add_one m lm (tl b, Oc # Oc # list))) \\<and>\n    (hd b \\<noteq> Oc \\<longrightarrow>\n     (b = [] \\<longrightarrow>\n      wprepare_add_one m lm ([], Bk # Oc # list)) \\<and>\n     (b \\<noteq> [] \\<longrightarrow>\n      wprepare_add_one m lm (tl b, hd b # Oc # list)))", "unfolding wprepare_add_one.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn.\n       b = [] \\<and>\n       (Oc # list = <m # lm> @ Bk \\<up> rn \\<or>\n        Oc # list = Bk # <m # lm> @ Bk \\<up> rn) \\<Longrightarrow>\n    (hd b = Oc \\<longrightarrow>\n     (b = [] \\<longrightarrow>\n      (\\<exists>rn.\n          [] = [] \\<and>\n          (Bk # Oc # list = <m # lm> @ Bk \\<up> rn \\<or>\n           Bk # Oc # list = Bk # <m # lm> @ Bk \\<up> rn))) \\<and>\n     (b \\<noteq> [] \\<longrightarrow>\n      (\\<exists>rn.\n          tl b = [] \\<and>\n          (Oc # Oc # list = <m # lm> @ Bk \\<up> rn \\<or>\n           Oc # Oc # list = Bk # <m # lm> @ Bk \\<up> rn)))) \\<and>\n    (hd b \\<noteq> Oc \\<longrightarrow>\n     (b = [] \\<longrightarrow>\n      (\\<exists>rn.\n          [] = [] \\<and>\n          (Bk # Oc # list = <m # lm> @ Bk \\<up> rn \\<or>\n           Bk # Oc # list = Bk # <m # lm> @ Bk \\<up> rn))) \\<and>\n     (b \\<noteq> [] \\<longrightarrow>\n      (\\<exists>rn.\n          tl b = [] \\<and>\n          (hd b # Oc # list = <m # lm> @ Bk \\<up> rn \\<or>\n           hd b # Oc # list = Bk # <m # lm> @ Bk \\<up> rn))))", "by auto"], ["", "lemma wprepare_loop_start_on_rightmost_Oc[simp]: \"wprepare_loop_start_on_rightmost m lm (b, Oc # list) \\<Longrightarrow> \n  wprepare_loop_start_on_rightmost m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start_on_rightmost m lm (b, Oc # list) \\<Longrightarrow>\n    wprepare_loop_start_on_rightmost m lm (Oc # b, list)", "apply(simp add: wprepare_loop_start_on_rightmost.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn.\n       rev b @ Oc # list =\n       Oc # Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rn \\<and>\n       b \\<noteq> [] \\<and>\n       (\\<exists>mr.\n           Oc # list = Oc \\<up> mr @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>rn.\n       rev b @ Oc # list =\n       Oc # Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rn \\<and>\n       (\\<exists>mr. list = Oc \\<up> mr @ Bk \\<up> rn)", "by (metis Cons_replicate_eq cell.distinct(1) list.sel(3) self_append_conv2 tl_append2 tl_replicate)"], ["", "lemma wprepare_loop_start_in_middle_Oc[simp]:\n  assumes \"wprepare_loop_start_in_middle m lm (b, Oc # list)\"\n  shows \"wprepare_loop_start_in_middle m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start_in_middle m lm (Oc # b, list)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wprepare_loop_start_in_middle m lm (Oc # b, list)", "from assms"], ["proof (chain)\npicking this:\n  wprepare_loop_start_in_middle m lm (b, Oc # list)", "obtain mr lm1 rn\n    where \"rev b @ Oc \\<up> mr @ Bk # <lm1::nat list> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\"\n      \"Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\" \"lm1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  wprepare_loop_start_in_middle m lm (b, Oc # list)\n\ngoal (1 subgoal):\n 1. (\\<And>mr lm1 rn.\n        \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <lm1> =\n                 Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n         Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n         lm1 \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: wprepare_loop_start_in_middle.simps)"], ["proof (state)\nthis:\n  rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\n  Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\n  lm1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. wprepare_loop_start_in_middle m lm (Oc # b, list)", "thus ?thesis"], ["proof (prove)\nusing this:\n  rev b @ Oc \\<up> mr @ Bk # <lm1> = Oc # Oc \\<up> m @ Bk # Bk # <lm>\n  Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn\n  lm1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. wprepare_loop_start_in_middle m lm (Oc # b, list)", "apply(auto simp add: wprepare_loop_start_in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <lm1> =\n             Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n     lm1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna.\n                         rev b @ Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn =\n                         Oc #\n                         Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rna \\<and>\n                         (\\<exists>mr lm1.\n                             list =\n                             Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rna \\<and>\n                             lm1 \\<noteq> [])", "apply(rule_tac x = rn in exI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <lm1> =\n             Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn;\n     lm1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>mr lm1.\n                         list =\n                         Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn \\<and>\n                         lm1 \\<noteq> []", "apply(case_tac mr, simp, simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>rev b @ Oc # Oc \\<up> nat @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        list = Oc \\<up> nat @ Bk # <lm1> @ Bk \\<up> rn; lm1 \\<noteq> [];\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr lm1a.\n                            Oc \\<up> nat @ Bk # <lm1> =\n                            Oc \\<up> mr @ Bk # <lm1a> \\<and>\n                            lm1a \\<noteq> []", "apply(rule_tac x = \"mr - 1\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>rev b @ Oc # Oc \\<up> nat @ Bk # <lm1> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        list = Oc \\<up> nat @ Bk # <lm1> @ Bk \\<up> rn; lm1 \\<noteq> [];\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a.\n                            <lm1> = <lm1a> \\<and> lm1a \\<noteq> []", "apply(rule_tac x = lm1 in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wprepare_loop_start_in_middle m lm (Oc # b, list)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_2_start: \"wprepare_loop_start m lm (b, Oc # list) \\<Longrightarrow> \n       wprepare_loop_start m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start m lm (b, Oc # list) \\<Longrightarrow>\n    wprepare_loop_start m lm (Oc # b, list)", "apply(simp add: wprepare_loop_start.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_start_on_rightmost m lm (b, Oc # list) \\<or>\n    wprepare_loop_start_in_middle m lm (b, Oc # list) \\<Longrightarrow>\n    wprepare_loop_start_on_rightmost m lm (Oc # b, list) \\<or>\n    wprepare_loop_start_in_middle m lm (Oc # b, list)", "apply(erule_tac disjE, simp_all )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_Oc_nonempty[simp]: \"wprepare_loop_goon m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_goon m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []", "apply(simp add: wprepare_loop_goon.simps     \n      wprepare_loop_goon_in_middle.simps \n      wprepare_loop_goon_on_rightmost.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn.\n       rev b @ Oc # list =\n       Oc # Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rn \\<and>\n       b \\<noteq> [] \\<and>\n       (\\<exists>mr.\n           (\\<exists>lm1.\n               if lm1 = [] then Oc # list = Oc \\<up> mr @ Bk \\<up> rn\n               else Oc # list =\n                    Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn) \\<and>\n           0 < mr) \\<Longrightarrow>\n    b \\<noteq> []", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_goto_start_pos_Oc_nonempty[simp]: \"wprepare_goto_start_pos m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_goto_start_pos m lm (b, Oc # list) \\<Longrightarrow>\n    b \\<noteq> []", "apply(simp add: wprepare_goto_start_pos.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_on_rightmost_Oc_False[simp]: \"wprepare_loop_goon_on_rightmost m lm (b, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_goon_on_rightmost m lm (b, Oc # list) = False", "apply(simp add: wprepare_loop_goon_on_rightmost.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop1: \"\\<lbrakk>rev b @ Oc\\<up>(mr) =  Oc\\<up>(Suc m) @ Bk # Bk # <lm>; \n         b \\<noteq> []; 0 < mr; Oc # list = Oc\\<up>(mr) @ Bk\\<up>(rn)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start_on_rightmost m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr = Oc \\<up> Suc m @ Bk # Bk # <lm>;\n     b \\<noteq> []; 0 < mr; Oc # list = Oc \\<up> mr @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_start_on_rightmost m lm (Oc # b, list)", "apply(simp add: wprepare_loop_start_on_rightmost.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> []; 0 < mr; Oc # list = Oc \\<up> mr @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna.\n                         rev b @ Oc \\<up> mr @ Bk \\<up> rn =\n                         Oc #\n                         Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rna \\<and>\n                         (\\<exists>mr. list = Oc \\<up> mr @ Bk \\<up> rna)", "apply(rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr = Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> []; 0 < mr; Oc # list = Oc \\<up> mr @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>mr. list = Oc \\<up> mr @ Bk \\<up> rn", "apply(case_tac mr, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop2: \"\\<lbrakk>rev b @ Oc\\<up>(mr) @ Bk # <a # lista> = Oc\\<up>(Suc m) @ Bk # Bk # <lm>;\n                b \\<noteq> []; Oc # list = Oc\\<up>(mr) @ Bk # <(a::nat) # lista> @ Bk\\<up>(rn)\\<rbrakk>\n       \\<Longrightarrow>  wprepare_loop_start_in_middle m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <a # lista> =\n             Oc \\<up> Suc m @ Bk # Bk # <lm>;\n     b \\<noteq> [];\n     Oc # list = Oc \\<up> mr @ Bk # <a # lista> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_start_in_middle m lm (Oc # b, list)", "apply(simp add: wprepare_loop_start_in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <a # lista> =\n             Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> [];\n     Oc # list = Oc \\<up> mr @ Bk # <a # lista> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rna.\n                         rev b @\n                         Oc \\<up> mr @ Bk # <a # lista> @ Bk \\<up> rn =\n                         Oc #\n                         Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rna \\<and>\n                         (\\<exists>mr lm1.\n                             list =\n                             Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rna \\<and>\n                             lm1 \\<noteq> [])", "apply(rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rev b @ Oc \\<up> mr @ Bk # <a # lista> =\n             Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n     b \\<noteq> [];\n     Oc # list = Oc \\<up> mr @ Bk # <a # lista> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>mr lm1.\n                         list =\n                         Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn \\<and>\n                         lm1 \\<noteq> []", "apply(case_tac mr, simp_all add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>rev b @ Oc # Oc \\<up> nat @ Bk # <a # lista> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        b \\<noteq> []; list = Oc \\<up> nat @ Bk # <a # lista> @ Bk \\<up> rn;\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr lm1.\n                            Oc \\<up> nat @ Bk # <a # lista> =\n                            Oc \\<up> mr @ Bk # <lm1> \\<and>\n                            lm1 \\<noteq> []", "apply(rename_tac nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>rev b @ Oc # Oc \\<up> nat @ Bk # <a # lista> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        b \\<noteq> []; list = Oc \\<up> nat @ Bk # <a # lista> @ Bk \\<up> rn;\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr lm1.\n                            Oc \\<up> nat @ Bk # <a # lista> =\n                            Oc \\<up> mr @ Bk # <lm1> \\<and>\n                            lm1 \\<noteq> []", "apply(rule_tac x = nat in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>rev b @ Oc # Oc \\<up> nat @ Bk # <a # lista> =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm>;\n        b \\<noteq> []; list = Oc \\<up> nat @ Bk # <a # lista> @ Bk \\<up> rn;\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1.\n                            <a # lista> = <lm1> \\<and> lm1 \\<noteq> []", "apply(rule_tac x = \"a#lista\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_goon_in_middle_cases[simp]: \"wprepare_loop_goon_in_middle m lm (b, Oc # list) \\<Longrightarrow>\n                wprepare_loop_start_on_rightmost m lm (Oc # b, list) \\<or>\n                wprepare_loop_start_in_middle m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_loop_goon_in_middle m lm (b, Oc # list) \\<Longrightarrow>\n    wprepare_loop_start_on_rightmost m lm (Oc # b, list) \\<or>\n    wprepare_loop_start_in_middle m lm (Oc # b, list)", "apply(simp add: wprepare_loop_goon_in_middle.simps split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn mr lm1.\n       \\<lbrakk>rev b @ Oc # list =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rn;\n        b \\<noteq> []; 0 < mr;\n        (lm1 = [] \\<longrightarrow>\n         Oc # list = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n        (lm1 = [] \\<or>\n         Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start_on_rightmost m lm\n                          (Oc # b, list) \\<or>\n                         wprepare_loop_start_in_middle m lm (Oc # b, list)", "apply(rename_tac lm1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn mr lm1.\n       \\<lbrakk>rev b @ Oc # list =\n                Oc # Oc \\<up> m @ Bk # Bk # <lm> @ Bk \\<up> rn;\n        b \\<noteq> []; 0 < mr;\n        (lm1 = [] \\<longrightarrow>\n         Oc # list = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n        (lm1 = [] \\<or>\n         Oc # list = Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start_on_rightmost m lm\n                          (Oc # b, list) \\<or>\n                         wprepare_loop_start_in_middle m lm (Oc # b, list)", "apply(case_tac lm1, simp_all add: wprepare_loop1 wprepare_loop2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_add_one_b[simp]: \"wprepare_add_one m lm (b, Oc # list)\n       \\<Longrightarrow> b = [] \\<longrightarrow> wprepare_add_one m lm ([], Bk # Oc # list)\"\n  \"wprepare_loop_goon m lm (b, Oc # list)\n  \\<Longrightarrow>  wprepare_loop_start m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wprepare_add_one m lm (b, Oc # list) \\<Longrightarrow>\n     b = [] \\<longrightarrow>\n     wprepare_add_one m lm ([], Bk # Oc # list)) &&&\n    (wprepare_loop_goon m lm (b, Oc # list) \\<Longrightarrow>\n     wprepare_loop_start m lm (Oc # b, list))", "apply(auto simp add: wprepare_add_one.simps wprepare_loop_goon.simps\n      wprepare_loop_start.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_start_on_rightmost_Oc2[simp]: \"wprepare_goto_start_pos m [a] (b, Oc # list)\n              \\<Longrightarrow> wprepare_loop_start_on_rightmost m [a] (Oc # b, list) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_goto_start_pos m [a] (b, Oc # list) \\<Longrightarrow>\n    wprepare_loop_start_on_rightmost m [a] (Oc # b, list)", "apply(auto simp: wprepare_goto_start_pos.simps \n      wprepare_loop_start_on_rightmost.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc \\<up> m @\n                            Oc # Bk # Bk # Oc # Oc \\<up> a @ Bk \\<up> rn =\n                            Oc #\n                            Oc \\<up> m @\n                            Bk # Bk # Oc # Oc \\<up> a @ Bk \\<up> rna \\<and>\n                            (\\<exists>mr.\n                                Oc \\<up> a @ Bk \\<up> rn =\n                                Oc \\<up> mr @ Bk \\<up> rna)", "apply(rename_tac rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc \\<up> m @\n                            Oc # Bk # Bk # Oc # Oc \\<up> a @ Bk \\<up> rn =\n                            Oc #\n                            Oc \\<up> m @\n                            Bk # Bk # Oc # Oc \\<up> a @ Bk \\<up> rna \\<and>\n                            (\\<exists>mr.\n                                Oc \\<up> a @ Bk \\<up> rn =\n                                Oc \\<up> mr @ Bk \\<up> rna)", "apply(rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> m @ [Oc] = Oc # Oc \\<up> m", "apply(simp add: replicate_Suc[THEN sym] exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_start_in_middle_2_Oc[simp]:  \"wprepare_goto_start_pos m (a # aa # listaa) (b, Oc # list)\n       \\<Longrightarrow>wprepare_loop_start_in_middle m (a # aa # listaa) (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_goto_start_pos m (a # aa # listaa)\n     (b, Oc # list) \\<Longrightarrow>\n    wprepare_loop_start_in_middle m (a # aa # listaa) (Oc # b, list)", "apply(auto simp: wprepare_goto_start_pos.simps\n      wprepare_loop_start_in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        Oc # list = <a # aa # listaa> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc \\<up> m @\n                            Oc # Bk # Bk # <a # aa # listaa> @ Bk \\<up> rn =\n                            Oc #\n                            Oc \\<up> m @\n                            Bk #\n                            Bk # <a # aa # listaa> @ Bk \\<up> rna \\<and>\n                            (\\<exists>mr lm1.\n                                list =\n                                Oc \\<up> mr @\n                                Bk # <lm1> @ Bk \\<up> rna \\<and>\n                                lm1 \\<noteq> [])", "apply(rename_tac rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        Oc # list = <a # aa # listaa> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc \\<up> m @\n                            Oc # Bk # Bk # <a # aa # listaa> @ Bk \\<up> rn =\n                            Oc #\n                            Oc \\<up> m @\n                            Bk #\n                            Bk # <a # aa # listaa> @ Bk \\<up> rna \\<and>\n                            (\\<exists>mr lm1.\n                                list =\n                                Oc \\<up> mr @\n                                Bk # <lm1> @ Bk \\<up> rna \\<and>\n                                lm1 \\<noteq> [])", "apply(rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        Oc # list = <a # aa # listaa> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> m @ [Oc] = Oc # Oc \\<up> m \\<and>\n                         (\\<exists>mr lm1.\n                             list =\n                             Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn \\<and>\n                             lm1 \\<noteq> [])", "apply(simp add: exp_ind[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        Oc # list = <a # aa # listaa> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr lm1.\n                            list =\n                            Oc \\<up> mr @ Bk # <lm1> @ Bk \\<up> rn \\<and>\n                            lm1 \\<noteq> []", "apply(rule_tac x = a in exI, rule_tac x = \"aa#listaa\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>b = Bk # Bk # Oc # Oc \\<up> m;\n        Oc # list = <a # aa # listaa> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> list =\n                         Oc \\<up> a @ Bk # <aa # listaa> @ Bk \\<up> rn", "apply(simp add: tape_of_nl_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wprepare_loop_start_Oc2[simp]: \"\\<lbrakk>lm \\<noteq> []; wprepare_goto_start_pos m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start m lm (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm \\<noteq> [];\n     wprepare_goto_start_pos m lm (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> wprepare_loop_start m lm (Oc # b, list)", "by(cases lm;cases \"tl lm\", auto simp add: wprepare_loop_start.simps)"], ["", "lemma wprepare_add_one2_Oc_nonempty[simp]: \"wprepare_add_one2 m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one2 m lm (b, Oc # list) \\<Longrightarrow> b \\<noteq> []", "apply(auto simp: wprepare_add_one2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_one_2_stop:\n  \"wprepare_add_one2 m lm (b, Oc # list)      \n  \\<Longrightarrow>  wprepare_stop m lm (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wprepare_add_one2 m lm (b, Oc # list) \\<Longrightarrow>\n    wprepare_stop m lm (tl b, hd b # Oc # list)", "apply(simp add: wprepare_add_one2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare wprepare_stop.simps[simp del]"], ["", "lemma wprepare_correctness:\n  assumes h: \"lm \\<noteq> []\"\n  shows \"let P = (\\<lambda> (st, l, r). st = 0) in \n  let Q = (\\<lambda> (st, l, r). wprepare_inv st m lm (l, r)) in \n  let f = (\\<lambda> stp. steps0 (Suc 0, [], (<m # lm>)) t_wcode_prepare stp) in\n    \\<exists> n .P (f n) \\<and> Q (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?P = \"(\\<lambda> (st, l, r). st = 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?Q = \"(\\<lambda> (st, l, r). wprepare_inv st m lm (l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?f = \"(\\<lambda> stp. steps0 (Suc 0, [], (<m # lm>)) t_wcode_prepare stp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "have \"\\<exists> n. ?P (?f n) \\<and> ?Q (?f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n        (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n        (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r))", "proof(rule_tac halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?LE\n 2. case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare 0 of\n    (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r)\n 3. \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare 0 of\n            (st, l, r) \\<Rightarrow> st = 0)\n 4. \\<forall>n.\n       \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n        (st, l, r) \\<Rightarrow>\n          wprepare_inv st m lm (l, r)) \\<longrightarrow>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n) of\n        (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r)) \\<and>\n       (steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n),\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n)\n       \\<in> ?LE", "show \"\\<forall> n. \\<not> ?P (?f n) \\<and> ?Q (?f n) \\<longrightarrow> \n                 ?Q (?f (Suc n)) \\<and> (?f (Suc n), ?f n) \\<in> wcode_prepare_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n        (st, l, r) \\<Rightarrow>\n          wprepare_inv st m lm (l, r)) \\<longrightarrow>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n) of\n        (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r)) \\<and>\n       (steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n),\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n)\n       \\<in> wcode_prepare_le", "using h"], ["proof (prove)\nusing this:\n  lm \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n               (st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n        (st, l, r) \\<Rightarrow>\n          wprepare_inv st m lm (l, r)) \\<longrightarrow>\n       (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n) of\n        (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r)) \\<and>\n       (steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n),\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n)\n       \\<in> wcode_prepare_le", "apply(rule_tac allI, rule_tac impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>lm \\<noteq> []; lm \\<noteq> [];\n        \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n                (st, l, r) \\<Rightarrow> st = 0) \\<and>\n        (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n         (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r))\\<rbrakk>\n       \\<Longrightarrow> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n                                (Suc n) of\n                          (st, l, r) \\<Rightarrow>\n                            wprepare_inv st m lm (l, r)) \\<and>\n                         (steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n                           (Suc n),\n                          steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n)\n                         \\<in> wcode_prepare_le", "apply(rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>lm \\<noteq> []; lm \\<noteq> [];\n        \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n                (st, l, r) \\<Rightarrow> st = 0) \\<and>\n        (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n         (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r))\\<rbrakk>\n       \\<Longrightarrow> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n                                (Suc n) of\n                          (st, l, r) \\<Rightarrow>\n                            wprepare_inv st m lm (l, r)) \\<and>\n                         (steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n                           (Suc n),\n                          steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n)\n                         \\<in> wcode_prepare_le", "apply(case_tac \"?f n\", simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b c.\n       \\<lbrakk>lm \\<noteq> []; 0 < a \\<and> wprepare_inv a m lm (b, c);\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_prepare_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_prepare_le)", "apply(rename_tac c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b c.\n       \\<lbrakk>lm \\<noteq> []; 0 < a \\<and> wprepare_inv a m lm (b, c);\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_prepare_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_prepare_le)", "apply(case_tac c, simp, case_tac [2] aa)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n a b c.\n       \\<lbrakk>lm \\<noteq> []; 0 < a \\<and> wprepare_inv a m lm (b, []);\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n = (a, b, []);\n        c = []\\<rbrakk>\n       \\<Longrightarrow> (case case fetch t_wcode_prepare a Bk of\n                               (a, s') \\<Rightarrow>\n                                 (s', update a (b, [])) of\n                          (st, x) \\<Rightarrow>\n                            wprepare_inv st m lm x) \\<and>\n                         (case fetch t_wcode_prepare a Bk of\n                          (a, s') \\<Rightarrow> (s', update a (b, [])),\n                          a, b, [])\n                         \\<in> wcode_prepare_le\n 2. \\<And>n a b c aa list.\n       \\<lbrakk>lm \\<noteq> []; 0 < a \\<and> wprepare_inv a m lm (b, c);\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n = (a, b, c);\n        c = aa # list; aa = Bk\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_prepare_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_prepare_le)\n 3. \\<And>n a b c aa list.\n       \\<lbrakk>lm \\<noteq> []; 0 < a \\<and> wprepare_inv a m lm (b, c);\n        steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n = (a, b, c);\n        c = aa # list; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> (c = [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a Bk of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, [])) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a Bk of\n                           (a, s') \\<Rightarrow> (s', update a (b, [])),\n                           a, b, [])\n                          \\<in> wcode_prepare_le) \\<and>\n                         (c \\<noteq> [] \\<longrightarrow>\n                          (case case fetch t_wcode_prepare a (hd c) of\n                                (a, s') \\<Rightarrow>\n                                  (s', update a (b, c)) of\n                           (st, x) \\<Rightarrow>\n                             wprepare_inv st m lm x) \\<and>\n                          (case fetch t_wcode_prepare a (hd c) of\n                           (a, s') \\<Rightarrow> (s', update a (b, c)),\n                           a, b, c)\n                          \\<in> wcode_prepare_le)", "apply(simp_all add: wprepare_inv.simps wcode_prepare_le_def lex_triple_def lex_pair_def\n          split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (5, b, Bk # list);\n        c = Bk # list; aa = Bk; lm \\<noteq> []; a = 5;\n        wprepare_loop_start m lm (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> (list = [] \\<longrightarrow>\n                          wprepare_loop_goon m lm (Bk # b, [])) \\<and>\n                         (list \\<noteq> [] \\<longrightarrow>\n                          wprepare_loop_goon m lm (Bk # b, list))\n 2. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (Suc 0, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = Suc 0;\n        wprepare_add_one m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> (hd b = Oc \\<longrightarrow>\n                          b \\<noteq> [] \\<longrightarrow>\n                          wprepare_add_one m lm\n                           (tl b, Oc # Oc # list)) \\<and>\n                         (hd b \\<noteq> Oc \\<longrightarrow>\n                          b \\<noteq> [] \\<longrightarrow>\n                          wprepare_add_one m lm (tl b, hd b # Oc # list))\n 3. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (5, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = 5;\n        wprepare_loop_start m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start m lm (Oc # b, list)\n 4. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (7, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = 7;\n        wprepare_add_one2 m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> (hd b = Oc \\<longrightarrow>\n                          wprepare_stop m lm (tl b, Oc # Oc # list)) \\<and>\n                         (hd b \\<noteq> Oc \\<longrightarrow>\n                          wprepare_stop m lm (tl b, hd b # Oc # list))", "(* slow *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (5, b, Bk # list);\n        c = Bk # list; aa = Bk; lm \\<noteq> []; a = 5;\n        wprepare_loop_start m lm (b, Bk # list)\\<rbrakk>\n       \\<Longrightarrow> (list = [] \\<longrightarrow>\n                          wprepare_loop_goon m lm (Bk # b, [])) \\<and>\n                         (list \\<noteq> [] \\<longrightarrow>\n                          wprepare_loop_goon m lm (Bk # b, list))\n 2. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (Suc 0, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = Suc 0;\n        wprepare_add_one m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> (hd b = Oc \\<longrightarrow>\n                          b \\<noteq> [] \\<longrightarrow>\n                          wprepare_add_one m lm\n                           (tl b, Oc # Oc # list)) \\<and>\n                         (hd b \\<noteq> Oc \\<longrightarrow>\n                          b \\<noteq> [] \\<longrightarrow>\n                          wprepare_add_one m lm (tl b, hd b # Oc # list))\n 3. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (5, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = 5;\n        wprepare_loop_start m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> wprepare_loop_start m lm (Oc # b, list)\n 4. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (7, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = 7;\n        wprepare_add_one2 m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> (hd b = Oc \\<longrightarrow>\n                          wprepare_stop m lm (tl b, Oc # Oc # list)) \\<and>\n                         (hd b \\<noteq> Oc \\<longrightarrow>\n                          wprepare_stop m lm (tl b, hd b # Oc # list))", "apply(simp_all add: start_2_goon  start_2_start\n          add_one_2_add_one add_one_2_stop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b c aa list.\n       \\<lbrakk>steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n =\n                (7, b, Oc # list);\n        c = Oc # list; aa = Oc; lm \\<noteq> []; a = 7;\n        wprepare_add_one2 m lm (b, Oc # list)\\<rbrakk>\n       \\<Longrightarrow> hd b = Oc \\<longrightarrow>\n                         wprepare_stop m lm (tl b, Oc # Oc # list)", "apply(auto simp: wprepare_add_one2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n             (st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n      (st, l, r) \\<Rightarrow>\n        wprepare_inv st m lm (l, r)) \\<longrightarrow>\n     (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n) of\n      (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r)) \\<and>\n     (steps0 (Suc 0, [], <m # lm>) t_wcode_prepare (Suc n),\n      steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n)\n     \\<in> wcode_prepare_le\n\ngoal (3 subgoals):\n 1. wf wcode_prepare_le\n 2. case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare 0 of\n    (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r)\n 3. \\<not> (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare 0 of\n            (st, l, r) \\<Rightarrow> st = 0)", "qed (auto simp add: steps.simps wprepare_inv.simps wprepare_invs)"], ["proof (state)\nthis:\n  \\<exists>n.\n     (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n      (st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n      (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n      (st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case steps0 (Suc 0, [], <m # lm>) t_wcode_prepare n of\n      (st, l, r) \\<Rightarrow> wprepare_inv st m lm (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(st, l, r). st = 0;\n        Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n        f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  let P = \\<lambda>(st, l, r). st = 0;\n      Q = \\<lambda>(st, l, r). wprepare_inv st m lm (l, r);\n      f = steps0 (Suc 0, [], <m # lm>) t_wcode_prepare\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_wf_t_wcode_prepare[intro]: \"tm_wf (t_wcode_prepare, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode_prepare", "apply(simp add:tm_wf.simps t_wcode_prepare_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_28_even[intro]: \"(28 + (length t_twice_compile + length t_fourtimes_compile)) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (28 + (length t_twice_compile + length t_fourtimes_compile))", "by(auto simp: t_twice_compile_def t_fourtimes_compile_def)"], ["", "lemma b_le_28[elim]: \"(a, b) \\<in> set t_wcode_main_first_part \\<Longrightarrow>\n  b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set t_wcode_main_first_part \\<Longrightarrow>\n    b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div\n            2", "apply(auto simp: t_wcode_main_first_part_def t_twice_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tm_wf_change_termi:\n  assumes \"tm_wf (tp, 0)\"\n  shows \"list_all (\\<lambda>(acn, st). (st \\<le> Suc (length tp div 2))) (adjust0 tp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "fix acn st n"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "assume \"tp ! n = (acn, st)\" \"n < length tp\" \"0 < st\""], ["proof (state)\nthis:\n  tp ! n = (acn, st)\n  n < length tp\n  0 < st\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "hence \"(acn, st)\\<in>set tp\""], ["proof (prove)\nusing this:\n  tp ! n = (acn, st)\n  n < length tp\n  0 < st\n\ngoal (1 subgoal):\n 1. (acn, st) \\<in> set tp", "by (metis nth_mem)"], ["proof (state)\nthis:\n  (acn, st) \\<in> set tp\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "with assms tm_wf.simps"], ["proof (chain)\npicking this:\n  tm_wf0 tp\n  tm_wf (?p, ?off) =\n  (2 \\<le> length ?p \\<and>\n   is_even (length ?p) \\<and>\n   (\\<forall>(a, s)\\<in>set ?p.\n       s \\<le> length ?p div 2 + ?off \\<and> ?off \\<le> s))\n  (acn, st) \\<in> set tp", "have \"st \\<le> length tp div 2 + 0\""], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  tm_wf (?p, ?off) =\n  (2 \\<le> length ?p \\<and>\n   is_even (length ?p) \\<and>\n   (\\<forall>(a, s)\\<in>set ?p.\n       s \\<le> length ?p div 2 + ?off \\<and> ?off \\<le> s))\n  (acn, st) \\<in> set tp\n\ngoal (1 subgoal):\n 1. st \\<le> length tp div 2 + 0", "by auto"], ["proof (state)\nthis:\n  st \\<le> length tp div 2 + 0\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "hence \"st \\<le> Suc (length tp div 2)\""], ["proof (prove)\nusing this:\n  st \\<le> length tp div 2 + 0\n\ngoal (1 subgoal):\n 1. st \\<le> Suc (length tp div 2)", "by auto"], ["proof (state)\nthis:\n  st \\<le> Suc (length tp div 2)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>tp ! ?n2 = (?acn2, ?st2); ?n2 < length tp; 0 < ?st2\\<rbrakk>\n  \\<Longrightarrow> ?st2 \\<le> Suc (length tp div 2)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>tp ! ?n2 = (?acn2, ?st2); ?n2 < length tp; 0 < ?st2\\<rbrakk>\n  \\<Longrightarrow> ?st2 \\<le> Suc (length tp div 2)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2))\n     (adjust0 tp)", "by(auto simp: tm_wf.simps List.list_all_length adjust.simps split: if_splits prod.split)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> Suc (length tp div 2)) (adjust0 tp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_wf_shift:\n  assumes \"list_all (\\<lambda>(acn, st). (st \\<le> y)) tp\"\n  shows \"list_all (\\<lambda>(acn, st). (st \\<le> y + off)) (shift tp off)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> y + off) (shift tp off)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> y + off) (shift tp off)", "have [dest!]:\"\\<And> P Q n. \\<forall>n. Q n \\<longrightarrow> P n \\<Longrightarrow> Q n \\<Longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P Q n.\n       \\<lbrakk>\\<forall>n. Q n \\<longrightarrow> P n; Q n\\<rbrakk>\n       \\<Longrightarrow> P n", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>n. ?Q n \\<longrightarrow> ?P n; ?Q ?n\\<rbrakk>\n  \\<Longrightarrow> ?P ?n\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> y + off) (shift tp off)", "from assms"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>(acn, st). st \\<le> y) tp", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(acn, st). st \\<le> y) tp\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> y + off) (shift tp off)", "by(auto simp: tm_wf.simps List.list_all_length shift.simps)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> y + off) (shift tp off)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare length_tp'[simp del]"], ["", "lemma length_mopup_1[simp]: \"length (mopup (Suc 0)) = 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mopup (Suc 0)) = 16", "apply(auto simp: mopup.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma twice_plus_28_elim[elim]: \"(a, b) \\<in> set (shift (adjust0 t_twice_compile) 12) \\<Longrightarrow> \n  b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> set (shift (adjust0 t_twice_compile) 12) \\<Longrightarrow>\n    b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div\n            2", "apply(simp add: t_twice_compile_def t_fourtimes_compile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "assume g: \"(a, b)\n    \\<in> set (shift\n            (adjust\n              (tm_of abc_twice @\n               shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n              (Suc ((length (tm_of abc_twice) + 16) div 2)))\n            12)\""], ["proof (state)\nthis:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_twice @\n                 shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                (Suc ((length (tm_of abc_twice) + 16) div 2)))\n              12)\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "moreover"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_twice @\n                 shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                (Suc ((length (tm_of abc_twice) + 16) div 2)))\n              12)\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "have \"length (tm_of abc_twice) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (tm_of abc_twice))", "by auto"], ["proof (state)\nthis:\n  is_even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "moreover"], ["proof (state)\nthis:\n  is_even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "have \"length (tm_of abc_fourtimes) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (tm_of abc_fourtimes))", "by auto"], ["proof (state)\nthis:\n  is_even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "ultimately"], ["proof (chain)\npicking this:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_twice @\n                 shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                (Suc ((length (tm_of abc_twice) + 16) div 2)))\n              12)\n  is_even (length (tm_of abc_twice))\n  is_even (length (tm_of abc_fourtimes))", "have \"list_all (\\<lambda>(acn, st). (st \\<le> (60 + (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div 2)) \n    (shift (adjust0 t_twice_compile) 12)\""], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_twice @\n                 shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                (Suc ((length (tm_of abc_twice) + 16) div 2)))\n              12)\n  is_even (length (tm_of abc_twice))\n  is_even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st).\n         st \\<le> (60 +\n                   (length (tm_of abc_twice) +\n                    length (tm_of abc_fourtimes))) div\n                  2)\n     (shift (adjust0 t_twice_compile) 12)", "proof(auto simp add: mod_ex1 del: adjust.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "assume \"even (length (tm_of abc_twice))\""], ["proof (state)\nthis:\n  even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "then"], ["proof (chain)\npicking this:\n  even (length (tm_of abc_twice))", "obtain q where q:\"length (tm_of abc_twice) = 2 * q\""], ["proof (prove)\nusing this:\n  even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        length (tm_of abc_twice) = 2 * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (tm_of abc_twice) = 2 * q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "assume \"even (length (tm_of abc_fourtimes))\""], ["proof (state)\nthis:\n  even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "then"], ["proof (chain)\npicking this:\n  even (length (tm_of abc_fourtimes))", "obtain qa where qa:\"length (tm_of abc_fourtimes) = 2 * qa\""], ["proof (prove)\nusing this:\n  even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. (\\<And>qa.\n        length (tm_of abc_fourtimes) = 2 * qa \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "note h = q qa"], ["proof (state)\nthis:\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "hence \"list_all (\\<lambda>(acn, st). st \\<le> (18 + (q + qa)) + 12) (shift (adjust0 t_twice_compile) 12)\""], ["proof (prove)\nusing this:\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa) + 12)\n     (shift (adjust0 t_twice_compile) 12)", "proof(rule_tac tm_wf_shift t_twice_compile_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (tm_of abc_twice) = 2 * q;\n     length (tm_of abc_fourtimes) = 2 * qa\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa))\n                       (adjust0 t_twice_compile)", "have \"list_all (\\<lambda>(acn, st). st \\<le> Suc (length t_twice_compile div 2)) (adjust0 t_twice_compile)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st). st \\<le> Suc (length t_twice_compile div 2))\n     (adjust0 t_twice_compile)", "by(rule_tac tm_wf_change_termi, auto)"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> Suc (length t_twice_compile div 2))\n   (adjust0 t_twice_compile)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length (tm_of abc_twice) = 2 * q;\n     length (tm_of abc_fourtimes) = 2 * qa\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa))\n                       (adjust0 t_twice_compile)", "thus \"list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa)) (adjust0 t_twice_compile)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(acn, st). st \\<le> Suc (length t_twice_compile div 2))\n   (adjust0 t_twice_compile)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa))\n     (adjust0 t_twice_compile)", "using h"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(acn, st). st \\<le> Suc (length t_twice_compile div 2))\n   (adjust0 t_twice_compile)\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa))\n     (adjust0 t_twice_compile)", "apply(simp add: t_twice_compile_def, auto simp: List.list_all_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa))\n   (adjust0 t_twice_compile)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa) + 12)\n   (shift (adjust0 t_twice_compile) 12)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_twice @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_twice) div 2))\n                           (9 + length (tm_of abc_twice) div 2))\n                         12);\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift (adjust0 t_twice_compile) 12)", "thus \"list_all (\\<lambda>(acn, st). st \\<le> 30 + (length (tm_of abc_twice) div 2 + length (tm_of abc_fourtimes) div 2))\n     (shift (adjust0 t_twice_compile) 12)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa) + 12)\n   (shift (adjust0 t_twice_compile) 12)\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st).\n         st \\<le> 30 +\n                  (length (tm_of abc_twice) div 2 +\n                   length (tm_of abc_fourtimes) div 2))\n     (shift (adjust0 t_twice_compile) 12)", "using h"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(acn, st). st \\<le> 18 + (q + qa) + 12)\n   (shift (adjust0 t_twice_compile) 12)\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st).\n         st \\<le> 30 +\n                  (length (tm_of abc_twice) div 2 +\n                   length (tm_of abc_fourtimes) div 2))\n     (shift (adjust0 t_twice_compile) 12)", "by simp"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> 30 +\n                (length (tm_of abc_twice) div 2 +\n                 length (tm_of abc_fourtimes) div 2))\n   (shift (adjust0 t_twice_compile) 12)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> (60 +\n                 (length (tm_of abc_twice) +\n                  length (tm_of abc_fourtimes))) div\n                2)\n   (shift (adjust0 t_twice_compile) 12)\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "thus \"b \\<le> (60 + (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div 2\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> (60 +\n                 (length (tm_of abc_twice) +\n                  length (tm_of abc_fourtimes))) div\n                2)\n   (shift (adjust0 t_twice_compile) 12)\n\ngoal (1 subgoal):\n 1. b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "using g"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> (60 +\n                 (length (tm_of abc_twice) +\n                  length (tm_of abc_fourtimes))) div\n                2)\n   (shift (adjust0 t_twice_compile) 12)\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_twice @\n                 shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                (Suc ((length (tm_of abc_twice) + 16) div 2)))\n              12)\n\ngoal (1 subgoal):\n 1. b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "apply(auto simp:t_twice_compile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all\n              (\\<lambda>(acn, st).\n                  st \\<le> (60 +\n                            (length (tm_of abc_twice) +\n                             length (tm_of abc_fourtimes))) div\n                           2)\n              (shift\n                (adjust\n                  (tm_of abc_twice @\n                   shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                  (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                12);\n     (a, b)\n     \\<in> set (shift\n                 (adjust\n                   (tm_of abc_twice @\n                    shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                   (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                 12)\\<rbrakk>\n    \\<Longrightarrow> b \\<le> (60 +\n                               (length (tm_of abc_twice) +\n                                length (tm_of abc_fourtimes))) div\n                              2", "apply(simp add: Ball_set[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (shift\n                                  (adjust\n                                    (tm_of abc_twice @\n                                     shift (mopup (Suc 0))\n(length (tm_of abc_twice) div 2))\n                                    (Suc\n((length (tm_of abc_twice) + 16) div 2)))\n                                  12).\n                case x of\n                (acn, st) \\<Rightarrow>\n                  st \\<le> (60 +\n                            (length (tm_of abc_twice) +\n                             length (tm_of abc_fourtimes))) div\n                           2;\n     (a, b)\n     \\<in> set (shift\n                 (adjust\n                   (tm_of abc_twice @\n                    shift (mopup (Suc 0)) (length (tm_of abc_twice) div 2))\n                   (Suc ((length (tm_of abc_twice) + 16) div 2)))\n                 12)\\<rbrakk>\n    \\<Longrightarrow> b \\<le> (60 +\n                               (length (tm_of abc_twice) +\n                                length (tm_of abc_fourtimes))) div\n                              2", "apply(erule_tac x = \"(a, b)\" in ballE, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  b \\<le> (60 +\n           (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n          2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_plus_28_elim2[elim]: \"(a, b) \\<in> set (shift (adjust0 t_fourtimes_compile) (t_twice_len + 13)) \n  \\<Longrightarrow> b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift (adjust0 t_fourtimes_compile)\n                (t_twice_len + 13)) \\<Longrightarrow>\n    b \\<le> (28 + (length t_twice_compile + length t_fourtimes_compile)) div\n            2", "apply(simp add: t_twice_compile_def t_fourtimes_compile_def t_twice_len_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "assume g: \"(a, b)\n    \\<in> set (shift\n             (adjust (tm_of abc_fourtimes @ shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n               (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n             (length t_twice div 2 + 13))\""], ["proof (state)\nthis:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_fourtimes @\n                 shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n                (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n              (length t_twice div 2 + 13))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "moreover"], ["proof (state)\nthis:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_fourtimes @\n                 shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n                (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n              (length t_twice div 2 + 13))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "have \"length (tm_of abc_twice) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (tm_of abc_twice))", "by auto"], ["proof (state)\nthis:\n  is_even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "moreover"], ["proof (state)\nthis:\n  is_even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "have \"length (tm_of abc_fourtimes) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (tm_of abc_fourtimes))", "by auto"], ["proof (state)\nthis:\n  is_even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "ultimately"], ["proof (chain)\npicking this:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_fourtimes @\n                 shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n                (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n              (length t_twice div 2 + 13))\n  is_even (length (tm_of abc_twice))\n  is_even (length (tm_of abc_fourtimes))", "have \"list_all (\\<lambda>(acn, st). (st \\<le> (60 + (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div 2)) \n    (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0))\n    (length (tm_of abc_fourtimes) div 2))) (length t_twice div 2 + 13))\""], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_fourtimes @\n                 shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n                (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n              (length t_twice div 2 + 13))\n  is_even (length (tm_of abc_twice))\n  is_even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st).\n         st \\<le> (60 +\n                   (length (tm_of abc_twice) +\n                    length (tm_of abc_fourtimes))) div\n                  2)\n     (shift\n       (adjust0\n         (tm_of abc_fourtimes @\n          shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2)))\n       (length t_twice div 2 + 13))", "proof(auto simp: mod_ex1 t_twice_def t_twice_compile_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "assume \"even (length (tm_of abc_twice))\""], ["proof (state)\nthis:\n  even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "then"], ["proof (chain)\npicking this:\n  even (length (tm_of abc_twice))", "obtain q where q:\"length (tm_of abc_twice) = 2 * q\""], ["proof (prove)\nusing this:\n  even (length (tm_of abc_twice))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        length (tm_of abc_twice) = 2 * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (tm_of abc_twice) = 2 * q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "assume \"even (length (tm_of abc_fourtimes))\""], ["proof (state)\nthis:\n  even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "then"], ["proof (chain)\npicking this:\n  even (length (tm_of abc_fourtimes))", "obtain qa where qa:\"length (tm_of abc_fourtimes) = 2 * qa\""], ["proof (prove)\nusing this:\n  even (length (tm_of abc_fourtimes))\n\ngoal (1 subgoal):\n 1. (\\<And>qa.\n        length (tm_of abc_fourtimes) = 2 * qa \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "note h = q qa"], ["proof (state)\nthis:\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "hence \"list_all (\\<lambda>(acn, st). st \\<le> (9 + qa + (21 + q)))\n      (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa)) (21 + q))\""], ["proof (prove)\nusing this:\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 9 + qa + (21 + q))\n     (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n       (21 + q))", "proof(rule_tac tm_wf_shift t_twice_compile_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (tm_of abc_twice) = 2 * q;\n     length (tm_of abc_fourtimes) = 2 * qa\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>(acn, st). st \\<le> 9 + qa)\n                       (adjust0\n                         (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))", "have \"list_all (\\<lambda>(acn, st). st \\<le> Suc (length (tm_of abc_fourtimes @ shift \n        (mopup (Suc 0)) qa) div 2)) (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st).\n         st \\<le> Suc (length\n                        (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa) div\n                       2))\n     (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))", "apply(rule_tac tm_wf_change_termi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa)", "using wf_fourtimes h"], ["proof (prove)\nusing this:\n  tm_wf0 t_fourtimes_compile\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. tm_wf0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa)", "apply(simp add: t_fourtimes_compile_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> Suc (length\n                      (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa) div\n                     2))\n   (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>length (tm_of abc_twice) = 2 * q;\n     length (tm_of abc_fourtimes) = 2 * qa\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>(acn, st). st \\<le> 9 + qa)\n                       (adjust0\n                         (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))", "thus \"list_all (\\<lambda>(acn, st). st \\<le> 9 + qa)\n        (adjust (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa)\n          (Suc (length (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa) div\n                2)))\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> Suc (length\n                      (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa) div\n                     2))\n   (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 9 + qa)\n     (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))", "using h"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> Suc (length\n                      (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa) div\n                     2))\n   (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n  length (tm_of abc_twice) = 2 * q\n  length (tm_of abc_fourtimes) = 2 * qa\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 9 + qa)\n     (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> 9 + qa)\n   (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (\\<lambda>(acn, st). st \\<le> 9 + qa + (21 + q))\n   (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n     (21 + q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b)\n             \\<in> set (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2));\n     even (length (tm_of abc_twice));\n     even (length (tm_of abc_fourtimes))\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))", "thus \"list_all\n     (\\<lambda>(acn, st). st \\<le> 30 + (length (tm_of abc_twice) div 2 + length (tm_of abc_fourtimes) div 2))\n     (shift\n       (adjust (tm_of abc_fourtimes @ shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n         (9 + length (tm_of abc_fourtimes) div 2))\n       (21 + length (tm_of abc_twice) div 2))\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(acn, st). st \\<le> 9 + qa + (21 + q))\n   (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n     (21 + q))\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>(acn, st).\n         st \\<le> 30 +\n                  (length (tm_of abc_twice) div 2 +\n                   length (tm_of abc_fourtimes) div 2))\n     (shift\n       (adjust\n         (tm_of abc_fourtimes @\n          shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n         (9 + length (tm_of abc_fourtimes) div 2))\n       (21 + length (tm_of abc_twice) div 2))", "apply(subgoal_tac \"qa + q = q + qa\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all (\\<lambda>(acn, st). st \\<le> 9 + qa + (21 + q))\n              (shift\n                (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n                (21 + q));\n     qa + q = q + qa\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>(acn, st).\n                           st \\<le> 30 +\n                                    (length (tm_of abc_twice) div 2 +\n                                     length (tm_of abc_fourtimes) div 2))\n                       (shift\n                         (adjust\n                           (tm_of abc_fourtimes @\n                            shift (mopup (Suc 0))\n                             (length (tm_of abc_fourtimes) div 2))\n                           (9 + length (tm_of abc_fourtimes) div 2))\n                         (21 + length (tm_of abc_twice) div 2))\n 2. list_all (\\<lambda>(acn, st). st \\<le> 9 + qa + (21 + q))\n     (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n       (21 + q)) \\<Longrightarrow>\n    qa + q = q + qa", "apply(simp add: h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>(acn, st). st \\<le> 9 + qa + (21 + q))\n     (shift (adjust0 (tm_of abc_fourtimes @ shift (mopup (Suc 0)) qa))\n       (21 + q)) \\<Longrightarrow>\n    qa + q = q + qa", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> 30 +\n                (length (tm_of abc_twice) div 2 +\n                 length (tm_of abc_fourtimes) div 2))\n   (shift\n     (adjust\n       (tm_of abc_fourtimes @\n        shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n       (9 + length (tm_of abc_fourtimes) div 2))\n     (21 + length (tm_of abc_twice) div 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> (60 +\n                 (length (tm_of abc_twice) +\n                  length (tm_of abc_fourtimes))) div\n                2)\n   (shift\n     (adjust0\n       (tm_of abc_fourtimes @\n        shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2)))\n     (length t_twice div 2 + 13))\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> set (shift\n                (adjust\n                  (tm_of abc_fourtimes @\n                   shift (mopup (Suc 0))\n                    (length (tm_of abc_fourtimes) div 2))\n                  (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                (length t_twice div 2 + 13)) \\<Longrightarrow>\n    b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "thus \"b \\<le> (60 + (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div 2\""], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> (60 +\n                 (length (tm_of abc_twice) +\n                  length (tm_of abc_fourtimes))) div\n                2)\n   (shift\n     (adjust0\n       (tm_of abc_fourtimes @\n        shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2)))\n     (length t_twice div 2 + 13))\n\ngoal (1 subgoal):\n 1. b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "using g"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>(acn, st).\n       st \\<le> (60 +\n                 (length (tm_of abc_twice) +\n                  length (tm_of abc_fourtimes))) div\n                2)\n   (shift\n     (adjust0\n       (tm_of abc_fourtimes @\n        shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2)))\n     (length t_twice div 2 + 13))\n  (a, b)\n  \\<in> set (shift\n              (adjust\n                (tm_of abc_fourtimes @\n                 shift (mopup (Suc 0)) (length (tm_of abc_fourtimes) div 2))\n                (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n              (length t_twice div 2 + 13))\n\ngoal (1 subgoal):\n 1. b \\<le> (60 +\n             (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n            2", "apply(simp add: Ball_set[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (shift\n                                  (adjust\n                                    (tm_of abc_fourtimes @\n                                     shift (mopup (Suc 0))\n(length (tm_of abc_fourtimes) div 2))\n                                    (Suc\n((length (tm_of abc_fourtimes) + 16) div 2)))\n                                  (length t_twice div 2 + 13)).\n                case x of\n                (acn, st) \\<Rightarrow>\n                  st \\<le> (60 +\n                            (length (tm_of abc_twice) +\n                             length (tm_of abc_fourtimes))) div\n                           2;\n     (a, b)\n     \\<in> set (shift\n                 (adjust\n                   (tm_of abc_fourtimes @\n                    shift (mopup (Suc 0))\n                     (length (tm_of abc_fourtimes) div 2))\n                   (Suc ((length (tm_of abc_fourtimes) + 16) div 2)))\n                 (length t_twice div 2 + 13))\\<rbrakk>\n    \\<Longrightarrow> b \\<le> (60 +\n                               (length (tm_of abc_twice) +\n                                length (tm_of abc_fourtimes))) div\n                              2", "apply(erule_tac x = \"(a, b)\" in ballE, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  b \\<le> (60 +\n           (length (tm_of abc_twice) + length (tm_of abc_fourtimes))) div\n          2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_wf_t_wcode_main[intro]: \"tm_wf (t_wcode_main, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode_main", "by(auto simp: t_wcode_main_def tm_wf.simps\n      t_twice_def t_fourtimes_def del: List.list_all_iff)"], ["", "declare tm_comp.simps[simp del]"], ["", "lemma prepare_mainpart_lemma:\n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp ln rn. steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) stp\n              = (0,  Bk # Oc\\<up>(Suc m), Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin (<args>)) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "let ?P1 = \"(\\<lambda> (l, r). (l::cell list) = [] \\<and> r = <m # args>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "let ?Q1 = \"(\\<lambda> (l, r). wprepare_stop m args (l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "let ?P2 = ?Q1"], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "let ?Q2 = \"(\\<lambda> (l, r). (\\<exists> ln rn. l = Bk # Oc\\<up>(Suc m) \\<and>\n                           r =  Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin (<args>)) @ Bk\\<up>(rn)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "let ?P3 = \"\\<lambda> tp. False\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "assume h: \"args \\<noteq> []\""], ["proof (state)\nthis:\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "have \"{?P1} t_wcode_prepare |+| t_wcode_main {?Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk # Oc \\<up> Suc m \\<and>\n           r =\n           Bk #\n           Oc #\n           Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}", "proof(rule_tac Hoare_plus_halt)"], ["proof (state)\ngoal (3 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <m # args>} t_wcode_prepare {?Q}\n 2. {?Q} t_wcode_main\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk # Oc \\<up> Suc m \\<and>\n           r =\n           Bk #\n           Oc #\n           Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}\n 3. tm_wf0 t_wcode_prepare", "show \"{?P1} t_wcode_prepare {?Q1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <m # args>} t_wcode_prepare\n    {\\<lambda>(l, r). wprepare_stop m args (l, r)}", "proof(rule_tac Hoare_haltI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <m # args>) t_wcode_prepare n) \\<and>\n       wprepare_stop m\n        args holds_for steps0 (Suc 0, [], <m # args>) t_wcode_prepare n", "show \"\\<exists>n. is_final (steps0 (Suc 0, [], <m # args>) t_wcode_prepare n) \\<and>\n        wprepare_stop m args holds_for steps0 (Suc 0, [], <m # args>) t_wcode_prepare n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <m # args>) t_wcode_prepare n) \\<and>\n       wprepare_stop m\n        args holds_for steps0 (Suc 0, [], <m # args>) t_wcode_prepare n", "using wprepare_correctness[of args m,OF h]"], ["proof (prove)\nusing this:\n  let P = \\<lambda>(st, l, r). st = 0;\n      Q = \\<lambda>(st, l, r). wprepare_inv st m args (l, r);\n      f = steps0 (Suc 0, [], <m # args>) t_wcode_prepare\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <m # args>) t_wcode_prepare n) \\<and>\n       wprepare_stop m\n        args holds_for steps0 (Suc 0, [], <m # args>) t_wcode_prepare n", "apply(auto simp add: wprepare_inv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>steps0 (Suc 0, [], <m # args>) t_wcode_prepare n =\n                (0, a, b);\n        wprepare_stop m args (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <m # args>) t_wcode_prepare\n                               n) \\<and>\n                            wprepare_stop m\n                             args holds_for steps0 (Suc 0, [], <m # args>)\n       t_wcode_prepare n", "by (metis holds_for.simps is_finalI)"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final (steps0 (Suc 0, [], <m # args>) t_wcode_prepare n) \\<and>\n     wprepare_stop m\n      args holds_for steps0 (Suc 0, [], <m # args>) t_wcode_prepare n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>} t_wcode_prepare\n  {\\<lambda>(l, r). wprepare_stop m args (l, r)}\n\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r). wprepare_stop m args (l, r)} t_wcode_main\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk # Oc \\<up> Suc m \\<and>\n           r =\n           Bk #\n           Oc #\n           Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}\n 2. tm_wf0 t_wcode_prepare", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r). wprepare_stop m args (l, r)} t_wcode_main\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk # Oc \\<up> Suc m \\<and>\n           r =\n           Bk #\n           Oc #\n           Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}\n 2. tm_wf0 t_wcode_prepare", "show \"{?P2} t_wcode_main {?Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). wprepare_stop m args (l, r)} t_wcode_main\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk # Oc \\<up> Suc m \\<and>\n           r =\n           Bk #\n           Oc #\n           Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}", "proof(rule_tac Hoare_haltI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       wprepare_stop m args (l, r) \\<Longrightarrow>\n       \\<exists>n.\n          is_final (steps0 (Suc 0, l, r) t_wcode_main n) \\<and>\n          (\\<lambda>(l, r).\n              l = Bk # Oc # Oc \\<up> m \\<and>\n              (\\<exists>ln rn.\n                  r =\n                  Bk #\n                  Oc #\n                  Bk \\<up> ln @\n                  Bk #\n                  Bk #\n                  Oc \\<up> bl_bin (<args>) @\n                  Bk \\<up> rn)) holds_for steps0 (Suc 0, l, r) t_wcode_main\n     n", "fix l r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       wprepare_stop m args (l, r) \\<Longrightarrow>\n       \\<exists>n.\n          is_final (steps0 (Suc 0, l, r) t_wcode_main n) \\<and>\n          (\\<lambda>(l, r).\n              l = Bk # Oc # Oc \\<up> m \\<and>\n              (\\<exists>ln rn.\n                  r =\n                  Bk #\n                  Oc #\n                  Bk \\<up> ln @\n                  Bk #\n                  Bk #\n                  Oc \\<up> bl_bin (<args>) @\n                  Bk \\<up> rn)) holds_for steps0 (Suc 0, l, r) t_wcode_main\n     n", "assume \"wprepare_stop m args (l, r)\""], ["proof (state)\nthis:\n  wprepare_stop m args (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       wprepare_stop m args (l, r) \\<Longrightarrow>\n       \\<exists>n.\n          is_final (steps0 (Suc 0, l, r) t_wcode_main n) \\<and>\n          (\\<lambda>(l, r).\n              l = Bk # Oc # Oc \\<up> m \\<and>\n              (\\<exists>ln rn.\n                  r =\n                  Bk #\n                  Oc #\n                  Bk \\<up> ln @\n                  Bk #\n                  Bk #\n                  Oc \\<up> bl_bin (<args>) @\n                  Bk \\<up> rn)) holds_for steps0 (Suc 0, l, r) t_wcode_main\n     n", "thus \"\\<exists>n. is_final (steps0 (Suc 0, l, r) t_wcode_main n) \\<and>\n              (\\<lambda>(l, r). l = Bk # Oc # Oc \\<up> m \\<and> (\\<exists>ln rn. r = Bk # Oc # Bk \\<up> ln @ \n        Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)) holds_for steps0 (Suc 0, l, r) t_wcode_main n\""], ["proof (prove)\nusing this:\n  wprepare_stop m args (l, r)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, l, r) t_wcode_main n) \\<and>\n       (\\<lambda>(l, r).\n           l = Bk # Oc # Oc \\<up> m \\<and>\n           (\\<exists>ln rn.\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, l, r) t_wcode_main n", "proof(auto simp: wprepare_stop.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>l = Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m;\n        r = Bk # Oc # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0\n                               (Suc 0,\n                                Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n                                Bk # Oc # Bk \\<up> rn)\n                               t_wcode_main n) \\<and>\n                            (\\<lambda>(l, r).\n                                l = Bk # Oc # Oc \\<up> m \\<and>\n                                (\\<exists>ln rn.\n                                    r =\n                                    Bk #\n                                    Oc #\n                                    Bk \\<up> ln @\n                                    Bk #\n                                    Bk #\n                                    Oc \\<up> bl_bin (<args>) @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n                        Bk # Oc # Bk \\<up> rn)\n                       t_wcode_main n", "fix rn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>l = Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m;\n        r = Bk # Oc # Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0\n                               (Suc 0,\n                                Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n                                Bk # Oc # Bk \\<up> rn)\n                               t_wcode_main n) \\<and>\n                            (\\<lambda>(l, r).\n                                l = Bk # Oc # Oc \\<up> m \\<and>\n                                (\\<exists>ln rn.\n                                    r =\n                                    Bk #\n                                    Oc #\n                                    Bk \\<up> ln @\n                                    Bk #\n                                    Bk #\n                                    Oc \\<up> bl_bin (<args>) @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n                        Bk # Oc # Bk \\<up> rn)\n                       t_wcode_main n", "show \" \\<exists>n. is_final (steps0 (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m, Bk # Oc # Bk \\<up> rn) t_wcode_main n) \\<and>\n          (\\<lambda>(l, r). l = Bk # Oc # Oc \\<up> m \\<and>\n          (\\<exists>ln rn. r = Bk # Oc # Bk \\<up> ln @\n          Bk # Bk # Oc \\<up> bl_bin (<args>) @\n          Bk \\<up> rn)) holds_for steps0 (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m, Bk # Oc # Bk \\<up> rn) t_wcode_main n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n           Bk # Oc # Bk \\<up> rn)\n          t_wcode_main n) \\<and>\n       (\\<lambda>(l, r).\n           l = Bk # Oc # Oc \\<up> m \\<and>\n           (\\<exists>ln rn.\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0\n  (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n   Bk # Oc # Bk \\<up> rn)\n  t_wcode_main n", "using t_wcode_main_lemma_pre[of \"args\" \"<args>\" 0 \"Oc\\<up>(Suc m)\" 0 rn,OF h refl]"], ["proof (prove)\nusing this:\n  \\<exists>stp ln rna.\n     steps0\n      (Suc 0, Bk # Bk \\<up> 0 @ rev (<args>) @ Bk # Bk # Oc \\<up> Suc m,\n       Bk # Oc \\<up> Suc 0 @ Bk \\<up> rn)\n      t_wcode_main stp =\n     (0, Bk # Oc \\<up> Suc m,\n      Bk #\n      Oc #\n      Bk \\<up> ln @\n      Bk #\n      Bk #\n      Oc \\<up> (bl_bin (<args>) + 0 * 2 ^ (length (<args>) - 1)) @\n      Bk \\<up> rna)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n           Bk # Oc # Bk \\<up> rn)\n          t_wcode_main n) \\<and>\n       (\\<lambda>(l, r).\n           l = Bk # Oc # Oc \\<up> m \\<and>\n           (\\<exists>ln rn.\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0\n  (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n   Bk # Oc # Bk \\<up> rn)\n  t_wcode_main n", "apply(auto simp: tape_of_nl_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rna.\n       steps0\n        (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n         Bk # Oc # Bk \\<up> rn)\n        t_wcode_main stp =\n       (0, Bk # Oc # Oc \\<up> m,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rna) \\<Longrightarrow>\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n              Bk # Oc # Bk \\<up> rn)\n             t_wcode_main n) \\<and>\n          (\\<lambda>(l, r).\n              l = Bk # Oc # Oc \\<up> m \\<and>\n              (\\<exists>ln rn.\n                  r =\n                  Bk #\n                  Oc #\n                  Bk \\<up> ln @\n                  Bk #\n                  Bk #\n                  Oc \\<up> bl_bin (<args>) @\n                  Bk \\<up> rn)) holds_for steps0\n     (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n      Bk # Oc # Bk \\<up> rn)\n     t_wcode_main n", "apply(rename_tac stp ln rna)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rna.\n       steps0\n        (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n         Bk # Oc # Bk \\<up> rn)\n        t_wcode_main stp =\n       (0, Bk # Oc # Oc \\<up> m,\n        Bk #\n        Oc #\n        Bk \\<up> ln @\n        Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rna) \\<Longrightarrow>\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n              Bk # Oc # Bk \\<up> rn)\n             t_wcode_main n) \\<and>\n          (\\<lambda>(l, r).\n              l = Bk # Oc # Oc \\<up> m \\<and>\n              (\\<exists>ln rn.\n                  r =\n                  Bk #\n                  Oc #\n                  Bk \\<up> ln @\n                  Bk #\n                  Bk #\n                  Oc \\<up> bl_bin (<args>) @\n                  Bk \\<up> rn)) holds_for steps0\n     (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n      Bk # Oc # Bk \\<up> rn)\n     t_wcode_main n", "apply(rule_tac x = stp in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final\n      (steps0\n        (Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m,\n         Bk # Oc # Bk \\<up> rn)\n        t_wcode_main n) \\<and>\n     (\\<lambda>(l, r).\n         l = Bk # Oc # Oc \\<up> m \\<and>\n         (\\<exists>ln rn.\n             r =\n             Bk #\n             Oc #\n             Bk \\<up> ln @\n             Bk #\n             Bk #\n             Oc \\<up> bl_bin (<args>) @\n             Bk \\<up> rn)) holds_for steps0\n(Suc 0, Bk # <rev args> @ Bk # Bk # Oc # Oc \\<up> m, Bk # Oc # Bk \\<up> rn)\nt_wcode_main n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final (steps0 (Suc 0, l, r) t_wcode_main n) \\<and>\n     (\\<lambda>(l, r).\n         l = Bk # Oc # Oc \\<up> m \\<and>\n         (\\<exists>ln rn.\n             r =\n             Bk #\n             Oc #\n             Bk \\<up> ln @\n             Bk #\n             Bk #\n             Oc \\<up> bl_bin (<args>) @\n             Bk \\<up> rn)) holds_for steps0 (Suc 0, l, r) t_wcode_main n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). wprepare_stop m args (l, r)} t_wcode_main\n  {\\<lambda>(l, r).\n      \\<exists>ln rn.\n         l = Bk # Oc \\<up> Suc m \\<and>\n         r =\n         Bk #\n         Oc #\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}\n\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode_prepare", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode_prepare", "show \"tm_wf0 t_wcode_prepare\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode_prepare", "by auto"], ["proof (state)\nthis:\n  tm_wf0 t_wcode_prepare\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n  t_wcode_prepare |+| t_wcode_main\n  {\\<lambda>(l, r).\n      \\<exists>ln rn.\n         l = Bk # Oc \\<up> Suc m \\<and>\n         r =\n         Bk #\n         Oc #\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "then"], ["proof (chain)\npicking this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n  t_wcode_prepare |+| t_wcode_main\n  {\\<lambda>(l, r).\n      \\<exists>ln rn.\n         l = Bk # Oc \\<up> Suc m \\<and>\n         r =\n         Bk #\n         Oc #\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}", "obtain n \n    where \"\\<And> tp. (case tp of (l, r) \\<Rightarrow> l = [] \\<and> r = <m # args>) \\<longrightarrow>\n       (is_final (steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n            (\\<lambda>(l, r).\n                \\<exists>ln rn.\n                   l = Bk # Oc \\<up> Suc m \\<and>\n                   r = Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn) holds_for steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main) n)\""], ["proof (prove)\nusing this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n  t_wcode_prepare |+| t_wcode_main\n  {\\<lambda>(l, r).\n      \\<exists>ln rn.\n         l = Bk # Oc \\<up> Suc m \\<and>\n         r =\n         Bk #\n         Oc #\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>tp.\n            (case tp of\n             (l, r) \\<Rightarrow>\n               l = [] \\<and> r = <m # args>) \\<longrightarrow>\n            is_final\n             (steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n            (\\<lambda>(l, r).\n                \\<exists>ln rn.\n                   l = Bk # Oc \\<up> Suc m \\<and>\n                   r =\n                   Bk #\n                   Oc #\n                   Bk \\<up> ln @\n                   Bk #\n                   Bk #\n                   Oc \\<up> bl_bin (<args>) @\n                   Bk \\<up> rn) holds_for steps0 (1, tp)\n     (t_wcode_prepare |+| t_wcode_main) n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Hoare_halt_def"], ["proof (prove)\nusing this:\n  \\<forall>tp.\n     (case tp of\n      (l, r) \\<Rightarrow> l = [] \\<and> r = <m # args>) \\<longrightarrow>\n     (\\<exists>n.\n         is_final\n          (steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n         (\\<lambda>(l, r).\n             \\<exists>ln rn.\n                l = Bk # Oc \\<up> Suc m \\<and>\n                r =\n                Bk #\n                Oc #\n                Bk \\<up> ln @\n                Bk #\n                Bk #\n                Oc \\<up> bl_bin (<args>) @\n                Bk \\<up> rn) holds_for steps0 (1, tp)\n  (t_wcode_prepare |+| t_wcode_main) n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (\\<And>tp.\n            (case tp of\n             (l, r) \\<Rightarrow>\n               l = [] \\<and> r = <m # args>) \\<longrightarrow>\n            is_final\n             (steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n            (\\<lambda>(l, r).\n                \\<exists>ln rn.\n                   l = Bk # Oc \\<up> Suc m \\<and>\n                   r =\n                   Bk #\n                   Oc #\n                   Bk \\<up> ln @\n                   Bk #\n                   Bk #\n                   Oc \\<up> bl_bin (<args>) @\n                   Bk \\<up> rn) holds_for steps0 (1, tp)\n     (t_wcode_prepare |+| t_wcode_main) n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (case ?tp1 of\n   (l, r) \\<Rightarrow> l = [] \\<and> r = <m # args>) \\<longrightarrow>\n  is_final (steps0 (1, ?tp1) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n  (\\<lambda>(l, r).\n      \\<exists>ln rn.\n         l = Bk # Oc \\<up> Suc m \\<and>\n         r =\n         Bk #\n         Oc #\n         Bk \\<up> ln @\n         Bk #\n         Bk #\n         Oc \\<up> bl_bin (<args>) @\n         Bk \\<up> rn) holds_for steps0 (1, ?tp1)\n                                 (t_wcode_prepare |+| t_wcode_main) n\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  (case ?tp1 of\n   (l, r) \\<Rightarrow> l = [] \\<and> r = <m # args>) \\<longrightarrow>\n  is_final (steps0 (1, ?tp1) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n  (\\<lambda>(l, r).\n      \\<exists>ln rn.\n         l = Bk # Oc \\<up> Suc m \\<and>\n         r =\n         Bk #\n         Oc #\n         Bk \\<up> ln @\n         Bk #\n         Bk #\n         Oc \\<up> bl_bin (<args>) @\n         Bk \\<up> rn) holds_for steps0 (1, ?tp1)\n                                 (t_wcode_prepare |+| t_wcode_main) n\n\ngoal (1 subgoal):\n 1. \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        stp =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "apply(rule_tac x = n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tp.\n        (case tp of\n         (l, r) \\<Rightarrow>\n           l = [] \\<and> r = <m # args>) \\<longrightarrow>\n        is_final\n         (steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n        (\\<lambda>(l, r).\n            \\<exists>ln rn.\n               l = Bk # Oc \\<up> Suc m \\<and>\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn) holds_for steps0 (1, tp)\n (t_wcode_prepare |+| t_wcode_main) n) \\<Longrightarrow>\n    \\<exists>ln rn.\n       steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) n =\n       (0, Bk # Oc \\<up> Suc m,\n        Bk #\n        Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "apply(case_tac \"(steps0 (Suc 0, [], <m # args>)\n      (adjust0 t_wcode_prepare @ shift t_wcode_main (length t_wcode_prepare div 2)) n)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>tp.\n                   (case tp of\n                    (l, r) \\<Rightarrow>\n                      l = [] \\<and> r = <m # args>) \\<longrightarrow>\n                   is_final\n                    (steps0 (1, tp) (t_wcode_prepare |+| t_wcode_main)\n                      n) \\<and>\n                   (\\<lambda>(l, r).\n                       \\<exists>ln rn.\n                          l = Bk # Oc \\<up> Suc m \\<and>\n                          r =\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk #\n                          Bk #\n                          Oc \\<up> bl_bin (<args>) @\n                          Bk \\<up> rn) holds_for steps0 (1, tp)\n            (t_wcode_prepare |+| t_wcode_main) n;\n        steps0 (Suc 0, [], <m # args>)\n         (adjust0 t_wcode_prepare @\n          shift t_wcode_main (length t_wcode_prepare div 2))\n         n =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ln rn.\n                            steps0 (Suc 0, [], <m # args>)\n                             (t_wcode_prepare |+| t_wcode_main) n =\n                            (0, Bk # Oc \\<up> Suc m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk #\n                             Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "apply(auto simp: tm_comp.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) stp =\n     (0, Bk # Oc \\<up> Suc m,\n      Bk #\n      Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition tinres :: \"cell list \\<Rightarrow> cell list \\<Rightarrow> bool\"\n  where\n    \"tinres xs ys = (\\<exists>n. xs = ys @ Bk \\<up> n \\<or> ys = xs @ Bk \\<up> n)\""], ["", "lemma tinres_fetch_congr[simp]:  \"tinres r r' \\<Longrightarrow> \n  fetch t ss (read r) = \n  fetch t ss (read r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres r r' \\<Longrightarrow> fetch t ss (read r) = fetch t ss (read r')", "apply(simp add: fetch.simps, auto split: if_splits simp: tinres_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>r = Bk \\<up> n; r' = [];\n        fetch t ss (hd (Bk \\<up> n)) \\<noteq> fetch t ss Bk\\<rbrakk>\n       \\<Longrightarrow> n = 0\n 2. \\<And>n.\n       \\<lbrakk>r' = Bk \\<up> n; r = [];\n        fetch t ss Bk \\<noteq> fetch t ss (hd (Bk \\<up> n))\\<rbrakk>\n       \\<Longrightarrow> n = 0", "using hd_replicate"], ["proof (prove)\nusing this:\n  ?n \\<noteq> 0 \\<Longrightarrow> hd (?x \\<up> ?n) = ?x\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>r = Bk \\<up> n; r' = [];\n        fetch t ss (hd (Bk \\<up> n)) \\<noteq> fetch t ss Bk\\<rbrakk>\n       \\<Longrightarrow> n = 0\n 2. \\<And>n.\n       \\<lbrakk>r' = Bk \\<up> n; r = [];\n        fetch t ss Bk \\<noteq> fetch t ss (hd (Bk \\<up> n))\\<rbrakk>\n       \\<Longrightarrow> n = 0", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>r' = Bk \\<up> n; r = [];\n        fetch t ss Bk \\<noteq> fetch t ss (hd (Bk \\<up> n))\\<rbrakk>\n       \\<Longrightarrow> n = 0", "using hd_replicate"], ["proof (prove)\nusing this:\n  ?n \\<noteq> 0 \\<Longrightarrow> hd (?x \\<up> ?n) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>r' = Bk \\<up> n; r = [];\n        fetch t ss Bk \\<noteq> fetch t ss (hd (Bk \\<up> n))\\<rbrakk>\n       \\<Longrightarrow> n = 0", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nonempty_hd_tinres[simp]: \"\\<lbrakk>tinres r r'; r \\<noteq> []; r' \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd r = hd r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tinres r r'; r \\<noteq> []; r' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd r = hd r'", "apply(auto simp: tinres_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tinres_nonempty[simp]:\n  \"\\<lbrakk>tinres r []; r \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd r = Bk\"\n  \"\\<lbrakk>tinres [] r'; r' \\<noteq> []\\<rbrakk> \\<Longrightarrow> hd r' = Bk\"\n  \"\\<lbrakk>tinres r [];  r \\<noteq> []\\<rbrakk> \\<Longrightarrow> tinres (tl r) []\"\n  \"tinres r r' \\<Longrightarrow> tinres (b # r) (b # r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>tinres r []; r \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> hd r = Bk) &&&\n     (\\<lbrakk>tinres [] r'; r' \\<noteq> []\\<rbrakk>\n      \\<Longrightarrow> hd r' = Bk)) &&&\n    (\\<lbrakk>tinres r []; r \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> tinres (tl r) []) &&&\n    (tinres r r' \\<Longrightarrow> tinres (b # r) (b # r'))", "by(auto simp: tinres_def)"], ["", "lemma ex_move_tl[intro]: \"\\<exists>na. tl r = tl (r @ Bk\\<up>(n)) @ Bk\\<up>(na) \\<or> tl (r @ Bk\\<up>(n)) = tl r @ Bk\\<up>(na)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>na.\n       tl r = tl (r @ Bk \\<up> n) @ Bk \\<up> na \\<or>\n       tl (r @ Bk \\<up> n) = tl r @ Bk \\<up> na", "apply(case_tac r, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. r = [] \\<Longrightarrow>\n    \\<exists>na. n \\<le> Suc 0 \\<and> na = 0 \\<or> n - Suc 0 = na\n 2. \\<And>a list.\n       r = a # list \\<Longrightarrow>\n       \\<exists>na.\n          tl r = tl (r @ Bk \\<up> n) @ Bk \\<up> na \\<or>\n          tl (r @ Bk \\<up> n) = tl r @ Bk \\<up> na", "by(case_tac n, auto)"], ["", "lemma tinres_tails[simp]: \"tinres r r' \\<Longrightarrow> tinres (tl r) (tl r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres r r' \\<Longrightarrow> tinres (tl r) (tl r')", "apply(auto simp: tinres_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       r = r' @ Bk \\<up> n \\<Longrightarrow>\n       \\<exists>na.\n          tl (r' @ Bk \\<up> n) = tl r' @ Bk \\<up> na \\<or>\n          tl r' = tl (r' @ Bk \\<up> n) @ Bk \\<up> na", "by(case_tac r', auto)"], ["", "lemma tinres_empty[simp]: \n  \"\\<lbrakk>tinres [] r'\\<rbrakk> \\<Longrightarrow> tinres [] (tl r')\"\n  \"tinres r [] \\<Longrightarrow> tinres (Bk # tl r) [Bk]\"\n  \"tinres r [] \\<Longrightarrow> tinres (Oc # tl r) [Oc]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tinres [] r' \\<Longrightarrow> tinres [] (tl r')) &&&\n    (tinres r [] \\<Longrightarrow> tinres (Bk # tl r) [Bk]) &&&\n    (tinres r [] \\<Longrightarrow> tinres (Oc # tl r) [Oc])", "by(auto simp: tinres_def)"], ["", "lemma tinres_step2:\n  assumes \"tinres r r'\" \"step0 (ss, l, r) t = (sa, la, ra)\" \"step0 (ss, l, r') t = (sb, lb, rb)\"\n  shows \"la = lb \\<and> tinres ra rb \\<and> sa = sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb \\<and> sa = sb", "proof (cases \"fetch t ss (read r')\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       fetch t ss (read r') = (a, b) \\<Longrightarrow>\n       la = lb \\<and> tinres ra rb \\<and> sa = sb", "case (Pair a b)"], ["proof (state)\nthis:\n  fetch t ss (read r') = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       fetch t ss (read r') = (a, b) \\<Longrightarrow>\n       la = lb \\<and> tinres ra rb \\<and> sa = sb", "have sa:\"sa = sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa = sb", "using assms Pair"], ["proof (prove)\nusing this:\n  tinres r r'\n  step0 (ss, l, r) t = (sa, la, ra)\n  step0 (ss, l, r') t = (sb, lb, rb)\n  fetch t ss (read r') = (a, b)\n\ngoal (1 subgoal):\n 1. sa = sb", "by(force simp: step.simps)"], ["proof (state)\nthis:\n  sa = sb\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       fetch t ss (read r') = (a, b) \\<Longrightarrow>\n       la = lb \\<and> tinres ra rb \\<and> sa = sb", "have \"la = lb \\<and> tinres ra rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb", "using assms Pair"], ["proof (prove)\nusing this:\n  tinres r r'\n  step0 (ss, l, r) t = (sa, la, ra)\n  step0 (ss, l, r') t = (sb, lb, rb)\n  fetch t ss (read r') = (a, b)\n\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb", "by(cases a, auto simp: step.simps split: if_splits)"], ["proof (state)\nthis:\n  la = lb \\<and> tinres ra rb\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       fetch t ss (read r') = (a, b) \\<Longrightarrow>\n       la = lb \\<and> tinres ra rb \\<and> sa = sb", "thus ?thesis"], ["proof (prove)\nusing this:\n  la = lb \\<and> tinres ra rb\n\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb \\<and> sa = sb", "using sa"], ["proof (prove)\nusing this:\n  la = lb \\<and> tinres ra rb\n  sa = sb\n\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb \\<and> sa = sb", "by auto"], ["proof (state)\nthis:\n  la = lb \\<and> tinres ra rb \\<and> sa = sb\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tinres_steps2: \n  \"\\<lbrakk>tinres r r'; steps0 (ss, l, r) t stp = (sa, la, ra); steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tinres r r'; steps0 (ss, l, r) t stp = (sa, la, ra);\n     steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "proof(induct stp arbitrary: sa la ra sb lb rb)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sa la ra sb lb rb.\n       \\<lbrakk>tinres r r'; steps0 (ss, l, r) t 0 = (sa, la, ra);\n        steps0 (ss, l, r') t 0 = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb\n 2. \\<And>stp sa la ra sb lb rb.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>tinres r r';\n                    steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; steps0 (ss, l, r) t (Suc stp) = (sa, la, ra);\n        steps0 (ss, l, r') t (Suc stp) = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "case (Suc stp sa la ra sb lb rb)"], ["proof (state)\nthis:\n  \\<lbrakk>tinres r r'; steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l, r') t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> ?la = ?lb \\<and> tinres ?ra ?rb \\<and> ?sa = ?sb\n  tinres r r'\n  steps0 (ss, l, r) t (Suc stp) = (sa, la, ra)\n  steps0 (ss, l, r') t (Suc stp) = (sb, lb, rb)\n\ngoal (2 subgoals):\n 1. \\<And>sa la ra sb lb rb.\n       \\<lbrakk>tinres r r'; steps0 (ss, l, r) t 0 = (sa, la, ra);\n        steps0 (ss, l, r') t 0 = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb\n 2. \\<And>stp sa la ra sb lb rb.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>tinres r r';\n                    steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; steps0 (ss, l, r) t (Suc stp) = (sa, la, ra);\n        steps0 (ss, l, r') t (Suc stp) = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tinres r r'; steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l, r') t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> ?la = ?lb \\<and> tinres ?ra ?rb \\<and> ?sa = ?sb\n  tinres r r'\n  steps0 (ss, l, r) t (Suc stp) = (sa, la, ra)\n  steps0 (ss, l, r') t (Suc stp) = (sb, lb, rb)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>tinres r r'; steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l, r') t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> ?la = ?lb \\<and> tinres ?ra ?rb \\<and> ?sa = ?sb\n  tinres r r'\n  steps0 (ss, l, r) t (Suc stp) = (sa, la, ra)\n  steps0 (ss, l, r') t (Suc stp) = (sb, lb, rb)\n\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb \\<and> sa = sb", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>sa la ra sb lb rb.\n                \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                 steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n                \\<Longrightarrow> la = lb \\<and>\n                                  tinres ra rb \\<and> sa = sb;\n     tinres r r'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n     step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "apply(case_tac \"(steps0 (ss, l, r) t stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n        step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stp = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "apply(case_tac \"(steps0 (ss, l, r') t stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n        step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stp = (a, b, c);\n        steps0 (ss, l, r') t stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n        step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stp = (a, b, c);\n        steps0 (ss, l, r') t stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "fix stp a b c aa ba ca"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stpa__ = (sa, la, ra);\n                    steps0 (ss, l, r') t stpa__ = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; step0 (steps0 (ss, l, r) t stpa__) t = (sa, la, ra);\n        step0 (steps0 (ss, l, r') t stpa__) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stpa__ = (a, b, c);\n        steps0 (ss, l, r') t stpa__ = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "assume ind: \"\\<And>sa la ra sb lb rb. \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra); \n    steps0 (ss, l, r') t stp = (sb, lb, rb)\\<rbrakk> \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb\"\n      and h: \" tinres r r'\" \"step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra)\"\n      \"step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb)\" \"steps0 (ss, l, r) t stp = (a, b, c)\" \n      \"steps0 (ss, l, r') t stp = (aa, ba, ca)\""], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l, r') t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> ?la = ?lb \\<and> tinres ?ra ?rb \\<and> ?sa = ?sb\n  tinres r r'\n  step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra)\n  step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb)\n  steps0 (ss, l, r) t stp = (a, b, c)\n  steps0 (ss, l, r') t stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stpa__ = (sa, la, ra);\n                    steps0 (ss, l, r') t stpa__ = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; step0 (steps0 (ss, l, r) t stpa__) t = (sa, la, ra);\n        step0 (steps0 (ss, l, r') t stpa__) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stpa__ = (a, b, c);\n        steps0 (ss, l, r') t stpa__ = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "have \"b = ba \\<and> tinres c ca \\<and> a = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = ba \\<and> tinres c ca \\<and> a = aa", "apply(rule_tac ind, simp_all add: h)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  b = ba \\<and> tinres c ca \\<and> a = aa\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stpa__ = (sa, la, ra);\n                    steps0 (ss, l, r') t stpa__ = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> la = lb \\<and>\n                                     tinres ra rb \\<and> sa = sb;\n        tinres r r'; step0 (steps0 (ss, l, r) t stpa__) t = (sa, la, ra);\n        step0 (steps0 (ss, l, r') t stpa__) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stpa__ = (a, b, c);\n        steps0 (ss, l, r') t stpa__ = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "thus \"la = lb \\<and> tinres ra rb \\<and> sa = sb\""], ["proof (prove)\nusing this:\n  b = ba \\<and> tinres c ca \\<and> a = aa\n\ngoal (1 subgoal):\n 1. la = lb \\<and> tinres ra rb \\<and> sa = sb", "apply(rule_tac l = b  and r = c  and ss = a and r' = ca   \n          and t = t in tinres_step2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b = ba \\<and> tinres c ca \\<and> a = aa \\<Longrightarrow> tinres c ca\n 2. b = ba \\<and> tinres c ca \\<and> a = aa \\<Longrightarrow>\n    step0 (a, b, c) t = (sa, la, ra)\n 3. b = ba \\<and> tinres c ca \\<and> a = aa \\<Longrightarrow>\n    step0 (a, b, ca) t = (sb, lb, rb)", "using h"], ["proof (prove)\nusing this:\n  tinres r r'\n  step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra)\n  step0 (steps0 (ss, l, r') t stp) t = (sb, lb, rb)\n  steps0 (ss, l, r) t stp = (a, b, c)\n  steps0 (ss, l, r') t stp = (aa, ba, ca)\n\ngoal (3 subgoals):\n 1. b = ba \\<and> tinres c ca \\<and> a = aa \\<Longrightarrow> tinres c ca\n 2. b = ba \\<and> tinres c ca \\<and> a = aa \\<Longrightarrow>\n    step0 (a, b, c) t = (sa, la, ra)\n 3. b = ba \\<and> tinres c ca \\<and> a = aa \\<Longrightarrow>\n    step0 (a, b, ca) t = (sb, lb, rb)", "apply(simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  la = lb \\<and> tinres ra rb \\<and> sa = sb\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  la = lb \\<and> tinres ra rb \\<and> sa = sb\n\ngoal (1 subgoal):\n 1. \\<And>sa la ra sb lb rb.\n       \\<lbrakk>tinres r r'; steps0 (ss, l, r) t 0 = (sa, la, ra);\n        steps0 (ss, l, r') t 0 = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> la = lb \\<and> tinres ra rb \\<and> sa = sb", "qed (simp add: steps.simps)"], ["", "definition t_wcode_adjust :: \"instr list\"\n  where\n    \"t_wcode_adjust = [(W1, 1), (R, 2), (Nop, 2), (R, 3), (R, 3), (R, 4), \n                   (L, 8), (L, 5), (L, 6), (W0, 5), (L, 6), (R, 7), \n                   (W1, 2), (Nop, 7), (L, 9), (W0, 8), (L, 9), (L, 10), \n                    (L, 11), (L, 10), (R, 0), (L, 11)]\""], ["", "lemma fetch_t_wcode_adjust[simp]:\n  \"fetch t_wcode_adjust (Suc 0) Bk = (W1, 1)\"\n  \"fetch t_wcode_adjust (Suc 0) Oc = (R, 2)\"\n  \"fetch t_wcode_adjust (Suc (Suc 0)) Oc = (R, 3)\"\n  \"fetch t_wcode_adjust (Suc (Suc (Suc 0))) Oc = (R, 4)\"\n  \"fetch t_wcode_adjust  (Suc (Suc (Suc 0))) Bk = (R, 3)\"\n  \"fetch t_wcode_adjust 4 Bk = (L, 8)\"\n  \"fetch t_wcode_adjust 4 Oc = (L, 5)\"\n  \"fetch t_wcode_adjust 5 Oc = (W0, 5)\"\n  \"fetch t_wcode_adjust 5 Bk = (L, 6)\"\n  \"fetch t_wcode_adjust 6 Oc = (R, 7)\"\n  \"fetch t_wcode_adjust 6 Bk = (L, 6)\"\n  \"fetch t_wcode_adjust 7 Bk = (W1, 2)\"\n  \"fetch t_wcode_adjust 8 Bk = (L, 9)\"\n  \"fetch t_wcode_adjust 8 Oc = (W0, 8)\"\n  \"fetch t_wcode_adjust 9 Oc = (L, 10)\"\n  \"fetch t_wcode_adjust 9 Bk = (L, 9)\"\n  \"fetch t_wcode_adjust 10 Bk = (L, 11)\"\n  \"fetch t_wcode_adjust 10 Oc = (L, 10)\"\n  \"fetch t_wcode_adjust 11 Oc = (L, 11)\"\n  \"fetch t_wcode_adjust 11 Bk = (R, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((fetch t_wcode_adjust (Suc 0) Bk = (W1, 1) &&&\n       fetch t_wcode_adjust (Suc 0) Oc = (R, 2)) &&&\n      fetch t_wcode_adjust (Suc (Suc 0)) Oc = (R, 3) &&&\n      fetch t_wcode_adjust (Suc (Suc (Suc 0))) Oc = (R, 4) &&&\n      fetch t_wcode_adjust (Suc (Suc (Suc 0))) Bk = (R, 3)) &&&\n     (fetch t_wcode_adjust 4 Bk = (L, 8) &&&\n      fetch t_wcode_adjust 4 Oc = (L, 5)) &&&\n     fetch t_wcode_adjust 5 Oc = (W0, 5) &&&\n     fetch t_wcode_adjust 5 Bk = (L, 6) &&&\n     fetch t_wcode_adjust 6 Oc = (R, 7)) &&&\n    ((fetch t_wcode_adjust 6 Bk = (L, 6) &&&\n      fetch t_wcode_adjust 7 Bk = (W1, 2)) &&&\n     fetch t_wcode_adjust 8 Bk = (L, 9) &&&\n     fetch t_wcode_adjust 8 Oc = (W0, 8) &&&\n     fetch t_wcode_adjust 9 Oc = (L, 10)) &&&\n    (fetch t_wcode_adjust 9 Bk = (L, 9) &&&\n     fetch t_wcode_adjust 10 Bk = (L, 11)) &&&\n    fetch t_wcode_adjust 10 Oc = (L, 10) &&&\n    fetch t_wcode_adjust 11 Oc = (L, 11) &&&\n    fetch t_wcode_adjust 11 Bk = (R, 0)", "by(auto simp: fetch.simps t_wcode_adjust_def nth_of.simps numeral)"], ["", "fun wadjust_start :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_start m rs (l, r) = \n         (\\<exists> ln rn. l = Bk # Oc\\<up>(Suc m) \\<and>\n                   tl r = Oc # Bk\\<up>(ln) @ Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn))\""], ["", "fun wadjust_loop_start :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_start m rs (l, r) = \n          (\\<exists> ln rn ml mr. l = Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m)  \\<and>\n                          r = Oc # Bk\\<up>(ln) @ Bk # Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and>\n                          ml + mr = Suc (Suc rs) \\<and> mr > 0)\""], ["", "fun wadjust_loop_right_move :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_right_move m rs (l, r) = \n   (\\<exists> ml mr nl nr rn. l = Bk\\<up>(nl) @ Oc # Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m) \\<and>\n                      r = Bk\\<up>(nr) @ Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and>\n                      ml + mr = Suc (Suc rs) \\<and> mr > 0 \\<and>\n                      nl + nr > 0)\""], ["", "fun wadjust_loop_check :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_check m rs (l, r) = \n  (\\<exists> ml mr ln rn. l = Oc # Bk\\<up>(ln) @ Bk # Oc # Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m) \\<and>\n                  r = Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and> ml + mr = (Suc rs))\""], ["", "fun wadjust_loop_erase :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_erase m rs (l, r) = \n    (\\<exists> ml mr ln rn. l = Bk\\<up>(ln) @ Bk # Oc # Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m) \\<and>\n                    tl r = Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and> ml + mr = (Suc rs) \\<and> mr > 0)\""], ["", "fun wadjust_loop_on_left_moving_O :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_on_left_moving_O m rs (l, r) = \n      (\\<exists> ml mr ln rn. l = Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m )\\<and>\n                      r = Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and>\n                      ml + mr = Suc rs \\<and> mr > 0)\""], ["", "fun wadjust_loop_on_left_moving_B :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_on_left_moving_B m rs (l, r) = \n      (\\<exists> ml mr nl nr rn. l = Bk\\<up>(nl) @ Oc # Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m) \\<and>\n                         r = Bk\\<up>(nr) @ Bk # Bk # Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and> \n                         ml + mr = Suc rs \\<and> mr > 0)\""], ["", "fun wadjust_loop_on_left_moving :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_on_left_moving m rs (l, r) = \n       (wadjust_loop_on_left_moving_O m rs (l, r) \\<or>\n       wadjust_loop_on_left_moving_B m rs (l, r))\""], ["", "fun wadjust_loop_right_move2 :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_loop_right_move2 m rs (l, r) = \n        (\\<exists> ml mr ln rn. l = Oc # Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m) \\<and>\n                        r = Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and>\n                        ml + mr = Suc rs \\<and> mr > 0)\""], ["", "fun wadjust_erase2 :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_erase2 m rs (l, r) = \n     (\\<exists> ln rn. l = Bk\\<up>(ln) @ Bk # Oc # Oc\\<up>(Suc rs) @ Bk # Oc\\<up>(Suc m) \\<and>\n                     tl r = Bk\\<up>(rn))\""], ["", "fun wadjust_on_left_moving_O :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_on_left_moving_O m rs (l, r) = \n        (\\<exists> rn. l = Oc\\<up>(Suc rs) @ Bk # Oc\\<up>(Suc m) \\<and>\n                  r = Oc # Bk\\<up>(rn))\""], ["", "fun wadjust_on_left_moving_B :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_on_left_moving_B m rs (l, r) = \n         (\\<exists> ln rn. l = Bk\\<up>(ln) @ Oc # Oc\\<up>(Suc rs) @ Bk # Oc\\<up>(Suc m) \\<and>\n                   r = Bk\\<up>(rn))\""], ["", "fun wadjust_on_left_moving :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_on_left_moving m rs (l, r) = \n      (wadjust_on_left_moving_O m rs (l, r) \\<or>\n       wadjust_on_left_moving_B m rs (l, r))\""], ["", "fun wadjust_goon_left_moving_B :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where \n    \"wadjust_goon_left_moving_B m rs (l, r) = \n        (\\<exists> rn. l = Oc\\<up>(Suc m) \\<and> \n               r = Bk # Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["", "fun wadjust_goon_left_moving_O :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_goon_left_moving_O m rs (l, r) = \n      (\\<exists> ml mr rn. l = Oc\\<up>(ml) @ Bk # Oc\\<up>(Suc m) \\<and>\n                      r = Oc\\<up>(mr) @ Bk\\<up>(rn) \\<and> \n                      ml + mr = Suc (Suc rs) \\<and> mr > 0)\""], ["", "fun wadjust_goon_left_moving :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_goon_left_moving m rs (l, r) = \n            (wadjust_goon_left_moving_B m rs (l, r) \\<or>\n             wadjust_goon_left_moving_O m rs (l, r))\""], ["", "fun wadjust_backto_standard_pos_B :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_backto_standard_pos_B m rs (l, r) =\n        (\\<exists> rn. l = [] \\<and> \n               r = Bk # Oc\\<up>(Suc m )@ Bk # Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["", "fun wadjust_backto_standard_pos_O :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_backto_standard_pos_O m rs (l, r) = \n      (\\<exists> ml mr rn. l = Oc\\<up>(ml) \\<and>\n                      r = Oc\\<up>(mr) @ Bk # Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn) \\<and> \n                      ml + mr = Suc m \\<and> mr > 0)\""], ["", "fun wadjust_backto_standard_pos :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_backto_standard_pos m rs (l, r) = \n        (wadjust_backto_standard_pos_B m rs (l, r) \\<or> \n        wadjust_backto_standard_pos_O m rs (l, r))\""], ["", "fun wadjust_stop :: \"nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_stop m rs (l, r) =\n        (\\<exists> rn. l = [Bk] \\<and> \n               r = Oc\\<up>(Suc m )@ Bk # Oc\\<up>(Suc (Suc rs)) @ Bk\\<up>(rn))\""], ["", "declare wadjust_start.simps[simp del]  wadjust_loop_start.simps[simp del]\n  wadjust_loop_right_move.simps[simp del]  wadjust_loop_check.simps[simp del]\n  wadjust_loop_erase.simps[simp del] wadjust_loop_on_left_moving.simps[simp del]\n  wadjust_loop_right_move2.simps[simp del] wadjust_erase2.simps[simp del]\n  wadjust_on_left_moving_O.simps[simp del] wadjust_on_left_moving_B.simps[simp del]\n  wadjust_on_left_moving.simps[simp del] wadjust_goon_left_moving_B.simps[simp del]\n  wadjust_goon_left_moving_O.simps[simp del] wadjust_goon_left_moving.simps[simp del]\n  wadjust_backto_standard_pos.simps[simp del] wadjust_backto_standard_pos_B.simps[simp del]\n  wadjust_backto_standard_pos_O.simps[simp del] wadjust_stop.simps[simp del]"], ["", "fun wadjust_inv :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"wadjust_inv st m rs (l, r) = \n       (if st = Suc 0 then wadjust_start m rs (l, r) \n        else if st = Suc (Suc 0) then wadjust_loop_start m rs (l, r)\n        else if st = Suc (Suc (Suc 0)) then wadjust_loop_right_move m rs (l, r)\n        else if st = 4 then wadjust_loop_check m rs (l, r)\n        else if st = 5 then wadjust_loop_erase m rs (l, r)\n        else if st = 6 then wadjust_loop_on_left_moving m rs (l, r)\n        else if st = 7 then wadjust_loop_right_move2 m rs (l, r)\n        else if st = 8 then wadjust_erase2 m rs (l, r)\n        else if st = 9 then wadjust_on_left_moving m rs (l, r)\n        else if st = 10 then wadjust_goon_left_moving m rs (l, r)\n        else if st = 11 then wadjust_backto_standard_pos m rs (l, r)\n        else if st = 0 then wadjust_stop m rs (l, r)\n        else False\n)\""], ["", "declare wadjust_inv.simps[simp del]"], ["", "fun wadjust_phase :: \"nat \\<Rightarrow> config \\<Rightarrow> nat\"\n  where\n    \"wadjust_phase rs (st, l, r) = \n         (if st = 1 then 3 \n          else if st \\<ge> 2 \\<and> st \\<le> 7 then 2\n          else if st \\<ge> 8 \\<and> st \\<le> 11 then 1\n          else 0)\""], ["", "fun wadjust_stage :: \"nat \\<Rightarrow> config \\<Rightarrow> nat\"\n  where\n    \"wadjust_stage rs (st, l, r) = \n           (if st \\<ge> 2 \\<and> st \\<le> 7 then \n                  rs - length (takeWhile (\\<lambda> a. a = Oc) \n                          (tl (dropWhile (\\<lambda> a. a = Oc) (rev l @ r))))\n            else 0)\""], ["", "fun wadjust_state :: \"nat \\<Rightarrow> config \\<Rightarrow> nat\"\n  where\n    \"wadjust_state rs (st, l, r) = \n       (if st \\<ge> 2 \\<and> st \\<le> 7 then 8 - st\n        else if st \\<ge> 8 \\<and> st \\<le> 11 then 12 - st\n        else 0)\""], ["", "fun wadjust_step :: \"nat \\<Rightarrow> config \\<Rightarrow> nat\"\n  where\n    \"wadjust_step rs (st, l, r) = \n       (if st = 1 then (if hd r = Bk then 1\n                        else 0) \n        else if st = 3 then length r\n        else if st = 5 then (if hd r = Oc then 1\n                             else 0)\n        else if st = 6 then length l\n        else if st = 8 then (if hd r = Oc then 1\n                             else 0)\n        else if st = 9 then length l\n        else if st = 10 then length l\n        else if st = 11 then (if hd r = Bk then 0\n                              else Suc (length l))\n        else 0)\""], ["", "fun wadjust_measure :: \"(nat \\<times> config) \\<Rightarrow> nat \\<times> nat \\<times> nat \\<times> nat\"\n  where\n    \"wadjust_measure (rs, (st, l, r)) = \n     (wadjust_phase rs (st, l, r), \n      wadjust_stage rs (st, l, r),\n      wadjust_state rs (st, l, r), \n      wadjust_step rs (st, l, r))\""], ["", "definition wadjust_le :: \"((nat \\<times> config) \\<times> nat \\<times> config) set\"\n  where \"wadjust_le \\<equiv> (inv_image lex_square wadjust_measure)\""], ["", "lemma wf_lex_square[intro]: \"wf lex_square\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf lex_square", "by(auto intro:wf_lex_prod simp: Abacus.lex_pair_def lex_square_def \n      Abacus.lex_triple_def)"], ["", "lemma wf_wadjust_le[intro]: \"wf wadjust_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wadjust_le", "by(auto intro:wf_inv_image simp: wadjust_le_def\n      Abacus.lex_triple_def Abacus.lex_pair_def)"], ["", "lemma wadjust_start_snd_nonempty[simp]: \"wadjust_start m rs (c, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_start m rs (c, []) = False", "apply(auto simp: wadjust_start.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_right_move_fst_nonempty[simp]: \"wadjust_loop_right_move m rs (c, []) \\<Longrightarrow> c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) \\<Longrightarrow> c \\<noteq> []", "apply(auto simp: wadjust_loop_right_move.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_check_fst_nonempty[simp]: \"wadjust_loop_check m rs (c, []) \\<Longrightarrow> c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (c, []) \\<Longrightarrow> c \\<noteq> []", "apply(simp only: wadjust_loop_check.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_start_snd_nonempty[simp]: \"wadjust_loop_start m rs (c, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (c, []) = False", "apply(simp add: wadjust_loop_start.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_erase2_singleton[simp]: \"wadjust_loop_check m rs (c, []) \\<Longrightarrow> wadjust_erase2 m rs (tl c, [hd c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (c, []) \\<Longrightarrow>\n    wadjust_erase2 m rs (tl c, [hd c])", "apply(simp only: wadjust_loop_check.simps wadjust_erase2.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_on_left_moving_snd_nonempty[simp]:\n  \"wadjust_loop_on_left_moving m rs (c, []) = False\"\n  \"wadjust_loop_right_move2 m rs (c, []) = False\"\n  \"wadjust_erase2 m rs ([], []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_on_left_moving m rs (c, []) = False &&&\n    wadjust_loop_right_move2 m rs (c, []) = False &&&\n    wadjust_erase2 m rs ([], []) = False", "by(auto simp: wadjust_loop_on_left_moving.simps\n      wadjust_loop_right_move2.simps\n      wadjust_erase2.simps)"], ["", "lemma wadjust_on_left_moving_B_Bk1[simp]: \"wadjust_on_left_moving_B m rs \n                 (Oc # Oc # Oc\\<up>(rs) @ Bk # Oc # Oc\\<up>(m), [Bk])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_on_left_moving_B m rs\n     (Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m, [Bk])", "apply(simp add: wadjust_on_left_moving_B.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_on_left_moving_B_Bk2[simp]: \"wadjust_on_left_moving_B m rs \n                 (Bk\\<up>(n) @ Bk # Oc # Oc # Oc\\<up>(rs) @ Bk # Oc # Oc\\<up>(m), [Bk])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_on_left_moving_B m rs\n     (Bk \\<up> n @ Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m, [Bk])", "apply(simp add: wadjust_on_left_moving_B.simps , auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ln. Bk \\<up> n @ [Bk] = Bk \\<up> ln", "apply(rule_tac x = \"Suc n\" in exI, simp add: exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_on_left_moving_singleton[simp]: \"\\<lbrakk>wadjust_erase2 m rs (c, []); c \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n            wadjust_on_left_moving m rs (tl c, [hd c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_erase2 m rs (c, []); c \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving m rs (tl c, [hd c])", "unfolding wadjust_erase2.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ln rn.\n                c =\n                Bk \\<up> ln @\n                Bk # Oc # Oc \\<up> Suc rs @ Bk # Oc \\<up> Suc m \\<and>\n                tl [] = Bk \\<up> rn;\n     c \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving m rs (tl c, [hd c])", "apply(auto simp add: wadjust_on_left_moving.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ln.\n       \\<lbrakk>c =\n                Bk \\<up> ln @\n                Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        \\<not> wadjust_on_left_moving_B m rs\n                (tl (Bk \\<up> ln @\n                     Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m),\n                 [hd (Bk \\<up> ln @\n                      Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)]);\n        \\<not> wadjust_on_left_moving_O m rs\n                (tl (Bk \\<up> ln @\n                     Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m),\n                 [hd (Bk \\<up> ln @\n                      Bk #\n                      Oc #\n                      Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)])\\<rbrakk>\n       \\<Longrightarrow> ln = 0\n 2. \\<And>ln.\n       \\<lbrakk>c =\n                Bk \\<up> ln @\n                Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        \\<not> wadjust_on_left_moving_B m rs\n                (tl (Bk \\<up> ln @\n                     Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m),\n                 [hd (Bk \\<up> ln @\n                      Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)]);\n        \\<not> wadjust_on_left_moving_O m rs\n                (tl (Bk \\<up> ln @\n                     Bk # Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m),\n                 [hd (Bk \\<up> ln @\n                      Bk #\n                      Oc #\n                      Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)])\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (no_types, lifting) empty_replicate hd_append hd_replicate list.sel(1) list.sel(3)\n      self_append_conv2 tl_append2 tl_replicate\n      wadjust_on_left_moving_B_Bk1 wadjust_on_left_moving_B_Bk2)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_erase2_cases[simp]: \"wadjust_erase2 m rs (c, [])\n    \\<Longrightarrow> (c = [] \\<longrightarrow> wadjust_on_left_moving m rs ([], [Bk])) \\<and> \n       (c \\<noteq> [] \\<longrightarrow> wadjust_on_left_moving m rs (tl c, [hd c]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_erase2 m rs (c, []) \\<Longrightarrow>\n    (c = [] \\<longrightarrow> wadjust_on_left_moving m rs ([], [Bk])) \\<and>\n    (c \\<noteq> [] \\<longrightarrow>\n     wadjust_on_left_moving m rs (tl c, [hd c]))", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_on_left_moving_nonempty[simp]:\n  \"wadjust_on_left_moving m rs ([], []) = False\"\n  \"wadjust_on_left_moving_O m rs (c, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_on_left_moving m rs ([], []) = False &&&\n    wadjust_on_left_moving_O m rs (c, []) = False", "apply(auto simp: wadjust_on_left_moving.simps \n      wadjust_on_left_moving_O.simps wadjust_on_left_moving_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_on_left_moving_B_singleton_Bk[simp]:\n  \" \\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> []; hd c = Bk\\<rbrakk> \\<Longrightarrow>\n                                      wadjust_on_left_moving_B m rs (tl c, [Bk])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> [];\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_B m rs (tl c, [Bk])", "apply(auto simp add: wadjust_on_left_moving_B.simps hd_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln.\n       \\<lbrakk>(if ln = 0\n                 then hd (Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)\n                 else hd (Bk \\<up> ln)) =\n                Bk;\n        c = Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        \\<forall>lna.\n           tl (Bk \\<up> ln @\n               Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) \\<noteq>\n           Bk \\<up> lna @\n           Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis cell.distinct(1) empty_replicate list.sel(1) tl_append2 tl_replicate)"], ["", "lemma wadjust_on_left_moving_B_singleton_Oc[simp]:\n  \"\\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> []; hd c = Oc\\<rbrakk> \\<Longrightarrow>\n                                  wadjust_on_left_moving_O m rs (tl c, [Oc])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> [];\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_O m rs (tl c, [Oc])", "apply(auto simp add: wadjust_on_left_moving_B.simps wadjust_on_left_moving_O.simps hd_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ln.\n       \\<lbrakk>(if ln = 0\n                 then hd (Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)\n                 else hd (Bk \\<up> ln)) =\n                Oc;\n        c = Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        tl (Bk \\<up> ln @\n            Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) \\<noteq>\n        Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> ln = 0\n 2. \\<And>ln.\n       \\<lbrakk>(if ln = 0\n                 then hd (Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m)\n                 else hd (Bk \\<up> ln)) =\n                Oc;\n        c = Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        tl (Bk \\<up> ln @\n            Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) \\<noteq>\n        Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis cell.distinct(1) empty_replicate hd_replicate list.sel(3) self_append_conv2)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_on_left_moving_singleton2[simp]:\n  \"\\<lbrakk>wadjust_on_left_moving m rs (c, []); c \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  wadjust_on_left_moving m rs (tl c, [hd c])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving m rs (c, []); c \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving m rs (tl c, [hd c])", "apply(simp add: wadjust_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_B m rs (c, []); c \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_O m rs (tl c, [hd c]) \\<or>\n                      wadjust_on_left_moving_B m rs (tl c, [hd c])", "apply(case_tac \"hd c\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_nonempty[simp]: \"wadjust_goon_left_moving m rs (c, []) = False\"\n  \"wadjust_backto_standard_pos m rs (c, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_goon_left_moving m rs (c, []) = False &&&\n    wadjust_backto_standard_pos m rs (c, []) = False", "by(auto simp: wadjust_goon_left_moving.simps wadjust_goon_left_moving_B.simps\n      wadjust_goon_left_moving_O.simps wadjust_backto_standard_pos.simps\n      wadjust_backto_standard_pos_B.simps wadjust_backto_standard_pos_O.simps)"], ["", "lemma wadjust_loop_start_no_Bk[simp]: \"wadjust_loop_start m rs (c, Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (c, Bk # list) = False", "apply(auto simp: wadjust_loop_start.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_check_nonempty[simp]: \"wadjust_loop_check m rs (c, b) \\<Longrightarrow> c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (c, b) \\<Longrightarrow> c \\<noteq> []", "apply(simp only: wadjust_loop_check.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_erase2_via_loop_check_Bk[simp]: \"wadjust_loop_check m rs (c, Bk # list)\n              \\<Longrightarrow>  wadjust_erase2 m rs (tl c, hd c # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_erase2 m rs (tl c, hd c # Bk # list)", "by (auto simp: wadjust_loop_check.simps wadjust_erase2.simps)"], ["", "declare wadjust_loop_on_left_moving_O.simps[simp del]\n  wadjust_loop_on_left_moving_B.simps[simp del]"], ["", "lemma wadjust_loop_on_left_moving_B_via_erase[simp]: \"\\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_B m rs (tl c, Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_B m rs\n                       (tl c, Bk # Bk # list)", "unfolding wadjust_loop_erase.simps wadjust_loop_on_left_moving_B.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ml mr ln rn.\n                c =\n                Bk \\<up> ln @\n                Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                tl (Bk # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                ml + mr = Suc rs \\<and> 0 < mr;\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ml mr nl nr rn.\n                         tl c =\n                         Bk \\<up> nl @\n                         Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                         Bk # Bk # list =\n                         Bk \\<up> nr @\n                         Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                         ml + mr = Suc rs \\<and> 0 < mr", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>hd c = Bk;\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        tl (Bk # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr nl nr rn.\n                            tl c =\n                            Bk \\<up> nl @\n                            Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                            Bk # Bk # list =\n                            Bk \\<up> nr @\n                            Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                            ml + mr = Suc rs \\<and> 0 < mr", "apply(rename_tac ml mr ln rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>hd c = Bk;\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        tl (Bk # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr nl nr rn.\n                            tl c =\n                            Bk \\<up> nl @\n                            Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                            Bk # Bk # list =\n                            Bk \\<up> nr @\n                            Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                            ml + mr = Suc rs \\<and> 0 < mr", "apply(rule_tac x = ml in exI, rule_tac x = mr in exI, \n      rule_tac x = ln in exI, rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>hd c = Bk;\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        tl (Bk # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn.\n                            tl c =\n                            Bk \\<up> ln @\n                            Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                            Bk # Bk # list =\n                            Bk \\<up> 0 @\n                            Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                            ml + mr = Suc rs \\<and> 0 < mr", "apply(case_tac ln, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn nat.\n       \\<lbrakk>c =\n                Bk #\n                Bk \\<up> nat @ Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs; 0 < mr\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> nat @ [Bk] = Bk # Bk \\<up> nat", "apply(simp add: exp_ind [THEN sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_on_left_moving_O_Bk_via_erase[simp]:\n  \"\\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); c \\<noteq> []; hd c = Oc\\<rbrakk> \\<Longrightarrow>\n             wadjust_loop_on_left_moving_O m rs (tl c, Oc # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); c \\<noteq> [];\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_O m rs\n                       (tl c, Oc # Bk # list)", "apply(auto simp: wadjust_loop_erase.simps wadjust_loop_on_left_moving_O.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml ln mr rn.\n       \\<lbrakk>hd (Bk \\<up> ln @\n                    Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) =\n                Oc;\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        \\<forall>mla.\n           tl (Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) =\n           Oc \\<up> mla @ Bk # Oc # Oc \\<up> m \\<longrightarrow>\n           (\\<forall>mra.\n               mla + mra = Suc rs \\<longrightarrow>\n               (\\<forall>ln rna.\n                   Bk # Oc \\<up> mr @ Bk \\<up> rn \\<noteq>\n                   Bk \\<up> ln @\n                   Bk # Bk # Oc \\<up> mra @ Bk \\<up> rna) \\<or>\n               mra = 0);\n        list = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs; 0 < mr\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis cell.distinct(1) empty_replicate hd_append hd_replicate list.sel(1))"], ["", "lemma wadjust_loop_on_left_moving_Bk_via_erase[simp]: \"\\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); c \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n                wadjust_loop_on_left_moving m rs (tl c, hd c # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_loop_erase m rs (c, Bk # list); c \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving m rs\n                       (tl c, hd c # Bk # list)", "apply(case_tac \"hd c\", simp_all add:wadjust_loop_on_left_moving.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_on_left_moving_B_Bk_move[simp]:\n  \"\\<lbrakk>wadjust_loop_on_left_moving_B m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow>  wadjust_loop_on_left_moving_B m rs (tl c, Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_loop_on_left_moving_B m rs (c, Bk # list);\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_B m rs\n                       (tl c, Bk # Bk # list)", "apply(simp only: wadjust_loop_on_left_moving_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ml mr nl nr rn.\n                c =\n                Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                Bk # list =\n                Bk \\<up> nr @ Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                ml + mr = Suc rs \\<and> 0 < mr;\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ml mr nl nr rn.\n                         tl c =\n                         Bk \\<up> nl @\n                         Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                         Bk # Bk # list =\n                         Bk \\<up> nr @\n                         Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                         ml + mr = Suc rs \\<and> 0 < mr", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr nl nr rn.\n       \\<lbrakk>hd c = Bk;\n        c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        Bk # list = Bk \\<up> nr @ Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<and> 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr nl nr rn.\n                            tl c =\n                            Bk \\<up> nl @\n                            Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                            Bk # Bk # list =\n                            Bk \\<up> nr @\n                            Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                            ml + mr = Suc rs \\<and> 0 < mr", "by (metis (no_types, lifting) cell.distinct(1) list.sel(1)\n      replicate_Suc_iff_anywhere self_append_conv2 tl_append2 tl_replicate)"], ["", "lemma wadjust_loop_on_left_moving_O_Oc_move[simp]:\n  \"\\<lbrakk>wadjust_loop_on_left_moving_B m rs (c, Bk # list); hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_O m rs (tl c, Oc # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_loop_on_left_moving_B m rs (c, Bk # list);\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_loop_on_left_moving_O m rs\n                       (tl c, Oc # Bk # list)", "apply(simp only: wadjust_loop_on_left_moving_O.simps \n      wadjust_loop_on_left_moving_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>ml mr nl nr rn.\n                c =\n                Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                Bk # list =\n                Bk \\<up> nr @ Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                ml + mr = Suc rs \\<and> 0 < mr;\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ml mr ln rn.\n                         tl c = Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n                         Oc # Bk # list =\n                         Oc #\n                         Bk \\<up> ln @\n                         Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n                         ml + mr = Suc rs \\<and> 0 < mr", "by (metis cell.distinct(1) empty_replicate hd_append hd_replicate list.sel(3) self_append_conv2)"], ["", "lemma wadjust_loop_erase_nonempty[simp]: \"wadjust_loop_erase m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_loop_on_left_moving m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_loop_right_move2 m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_erase2 m rs (c, Bk # list) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_on_left_moving m rs (c,b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_on_left_moving_O m rs (c, Bk # list) = False\"\n  \"wadjust_goon_left_moving m rs (c, b) \\<Longrightarrow> c \\<noteq> []\"\n  \"wadjust_loop_on_left_moving_O m rs (c, Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((wadjust_loop_erase m rs (c, b) \\<Longrightarrow> c \\<noteq> []) &&&\n      (wadjust_loop_on_left_moving m rs (c, b) \\<Longrightarrow>\n       c \\<noteq> [])) &&&\n     (wadjust_loop_right_move2 m rs (c, b) \\<Longrightarrow>\n      c \\<noteq> []) &&&\n     (wadjust_erase2 m rs (c, Bk # list) \\<Longrightarrow>\n      c \\<noteq> [])) &&&\n    ((wadjust_on_left_moving m rs (c, b) \\<Longrightarrow>\n      c \\<noteq> []) &&&\n     wadjust_on_left_moving_O m rs (c, Bk # list) = False) &&&\n    (wadjust_goon_left_moving m rs (c, b) \\<Longrightarrow>\n     c \\<noteq> []) &&&\n    wadjust_loop_on_left_moving_O m rs (c, Bk # list) = False", "by(auto simp: wadjust_loop_erase.simps wadjust_loop_on_left_moving.simps \n      wadjust_loop_on_left_moving_O.simps wadjust_loop_on_left_moving_B.simps\n      wadjust_loop_right_move2.simps wadjust_erase2.simps\n      wadjust_on_left_moving.simps\n      wadjust_on_left_moving_O.simps\n      wadjust_on_left_moving_B.simps wadjust_goon_left_moving.simps\n      wadjust_goon_left_moving_B.simps\n      wadjust_goon_left_moving_O.simps)"], ["", "lemma wadjust_loop_on_left_moving_Bk_move[simp]:\n  \"wadjust_loop_on_left_moving m rs (c, Bk # list)\n            \\<Longrightarrow> wadjust_loop_on_left_moving m rs (tl c, hd c # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_on_left_moving m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_loop_on_left_moving m rs (tl c, hd c # Bk # list)", "apply(simp add: wadjust_loop_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_on_left_moving_B m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_loop_on_left_moving_O m rs (tl c, hd c # Bk # list) \\<or>\n    wadjust_loop_on_left_moving_B m rs (tl c, hd c # Bk # list)", "apply(case_tac \"hd c\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_start_Oc_via_Bk_move[simp]: \n  \"wadjust_loop_right_move2 m rs (c, Bk # list) \\<Longrightarrow>  wadjust_loop_start m rs (c, Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move2 m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_loop_start m rs (c, Oc # list)", "apply(auto simp: wadjust_loop_right_move2.simps wadjust_loop_start.simps replicate_app_Cons_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       \\<lbrakk>c = Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Bk # Bk \\<up> ln @ Oc \\<up> mr @ Bk \\<up> rn;\n        ml + mr = Suc rs; 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lna rna mla.\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            (\\<exists>mra.\n                                Bk \\<up> ln @ Oc \\<up> mr @ Bk \\<up> rn =\n                                Bk \\<up> lna @\n                                Oc \\<up> mra @ Bk \\<up> rna \\<and>\n                                mla + mra = Suc (Suc rs) \\<and> 0 < mra)", "by (metis add_Suc replicate_Suc)"], ["", "lemma wadjust_on_left_moving_Bk_via_erase[simp]: \"wadjust_erase2 m rs (c, Bk # list) \\<Longrightarrow> \n                 wadjust_on_left_moving m rs (tl c, hd c # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_erase2 m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_on_left_moving m rs (tl c, hd c # Bk # list)", "apply(auto simp: wadjust_erase2.simps wadjust_on_left_moving.simps replicate_app_Cons_same\n      wadjust_on_left_moving_O.simps wadjust_on_left_moving_B.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ln rn.\n       \\<lbrakk>c =\n                Bk #\n                Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        list = Bk \\<up> rn;\n        \\<forall>rna. Bk # Bk # Bk \\<up> rn \\<noteq> Bk \\<up> rna\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ln rn.\n       \\<lbrakk>c =\n                Bk #\n                Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        list = Bk \\<up> rn;\n        \\<forall>rna. Bk # Bk # Bk \\<up> rn \\<noteq> Bk \\<up> rna\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis exp_ind replicate_append_same)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_on_left_moving_B_Bk_drop_one: \"\\<lbrakk>wadjust_on_left_moving_B m rs (c, Bk # list); hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_B m rs (tl c, Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_B m rs (c, Bk # list);\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_B m rs (tl c, Bk # Bk # list)", "apply(auto simp: wadjust_on_left_moving_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<lbrakk>hd (Bk \\<up> ln @\n                    Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) =\n                Bk;\n        c = Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        Bk # list = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lna.\n                            tl (Bk \\<up> ln @\n                                Oc #\n                                Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) =\n                            Bk \\<up> lna @\n                            Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m", "by (metis cell.distinct(1) hd_append list.sel(1) tl_append2 tl_replicate)"], ["", "lemma wadjust_on_left_moving_B_Bk_drop_Oc: \"\\<lbrakk>wadjust_on_left_moving_B m rs (c, Bk # list); hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_O m rs (tl c, Oc # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_B m rs (c, Bk # list);\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_on_left_moving_O m rs (tl c, Oc # Bk # list)", "apply(auto simp: wadjust_on_left_moving_O.simps wadjust_on_left_moving_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<lbrakk>hd (Bk \\<up> ln @\n                    Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) =\n                Oc;\n        c = Bk \\<up> ln @ Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        Bk # list = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> ln @\n                             Oc # Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m) =\n                         Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m", "by (metis cell.distinct(1) empty_replicate hd_append hd_replicate list.sel(3) self_append_conv2)"], ["", "lemma wadjust_on_left_moving_B_drop[simp]: \"wadjust_on_left_moving  m rs (c, Bk # list) \\<Longrightarrow>  \n                  wadjust_on_left_moving m rs (tl c, hd c # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_on_left_moving m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_on_left_moving m rs (tl c, hd c # Bk # list)", "by(cases \"hd c\", auto simp:wadjust_on_left_moving.simps wadjust_on_left_moving_B_Bk_drop_one\n      wadjust_on_left_moving_B_Bk_drop_Oc)"], ["", "lemma wadjust_goon_left_moving_O_no_Bk[simp]: \"wadjust_goon_left_moving_O m rs (c, Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_goon_left_moving_O m rs (c, Bk # list) = False", "by (auto simp add: wadjust_goon_left_moving_O.simps)"], ["", "lemma wadjust_backto_standard_pos_via_left_Bk[simp]:\n  \"wadjust_goon_left_moving m rs (c, Bk # list) \\<Longrightarrow>\n  wadjust_backto_standard_pos m rs (tl c, hd c # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_goon_left_moving m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_backto_standard_pos m rs (tl c, hd c # Bk # list)", "by(case_tac \"hd c\", simp_all add: wadjust_backto_standard_pos.simps wadjust_goon_left_moving.simps\n      wadjust_goon_left_moving_B.simps wadjust_backto_standard_pos_O.simps)"], ["", "lemma wadjust_loop_right_move_Oc[simp]:\n  \"wadjust_loop_start m rs (c, Oc # list) \\<Longrightarrow> wadjust_loop_right_move m rs (Oc # c, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (c, Oc # list) \\<Longrightarrow>\n    wadjust_loop_right_move m rs (Oc # c, list)", "apply(auto simp add: wadjust_loop_start.simps wadjust_loop_right_move.simps\n      simp del:split_head_repeat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn ml mr.\n       \\<lbrakk>c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Bk \\<up> ln @ Bk # Oc \\<up> mr @ Bk \\<up> rn;\n        ml + mr = Suc (Suc rs); 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla mra nl.\n                            Oc # Oc \\<up> ml =\n                            Bk \\<up> nl @ Oc # Oc \\<up> mla \\<and>\n                            (\\<exists>nr.\n                                (\\<exists>rna.\n                                    Bk \\<up> ln @\n                                    Bk # Oc \\<up> mr @ Bk \\<up> rn =\n                                    Bk \\<up> nr @\n                                    Oc \\<up> mra @ Bk \\<up> rna) \\<and>\n                                mla + mra = Suc (Suc rs) \\<and>\n                                0 < mra \\<and> (0 < nl \\<or> 0 < nr))", "apply(rename_tac ln rn ml mr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn ml mr.\n       \\<lbrakk>c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Bk \\<up> ln @ Bk # Oc \\<up> mr @ Bk \\<up> rn;\n        ml + mr = Suc (Suc rs); 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla mra nl.\n                            Oc # Oc \\<up> ml =\n                            Bk \\<up> nl @ Oc # Oc \\<up> mla \\<and>\n                            (\\<exists>nr.\n                                (\\<exists>rna.\n                                    Bk \\<up> ln @\n                                    Bk # Oc \\<up> mr @ Bk \\<up> rn =\n                                    Bk \\<up> nr @\n                                    Oc \\<up> mra @ Bk \\<up> rna) \\<and>\n                                mla + mra = Suc (Suc rs) \\<and>\n                                0 < mra \\<and> (0 < nl \\<or> 0 < nr))", "apply(rule_tac x = ml in exI, rule_tac x = mr in exI, \n      rule_tac x = 0 in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ln rn ml mr.\n       \\<lbrakk>c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Bk \\<up> ln @ Bk # Oc \\<up> mr @ Bk \\<up> rn;\n        ml + mr = Suc (Suc rs); 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nr.\n                            (\\<exists>rna.\n                                Bk \\<up> ln @\n                                Bk # Oc \\<up> mr @ Bk \\<up> rn =\n                                Bk \\<up> nr @\n                                Oc \\<up> mr @ Bk \\<up> rna) \\<and>\n                            0 < nr", "apply(rule_tac x = \"Suc ln\" in exI, simp add: exp_ind del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_check_Oc[simp]:\n  assumes \"wadjust_loop_right_move m rs (c, Oc # list)\" \n  shows \"wadjust_loop_check m rs (Oc # c, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (Oc # c, list)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (Oc # c, list)", "from assms"], ["proof (chain)\npicking this:\n  wadjust_loop_right_move m rs (c, Oc # list)", "obtain ml mr nl nr rn\n    where \"c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> m @ [Oc]\"\n      \"Oc # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn\"\n      \"ml + mr = Suc (Suc rs)\" \"0 < mr\" \"0 < nl + nr\""], ["proof (prove)\nusing this:\n  wadjust_loop_right_move m rs (c, Oc # list)\n\ngoal (1 subgoal):\n 1. (\\<And>nl ml nr mr rn.\n        \\<lbrakk>c =\n                 Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> m @ [Oc];\n         Oc # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn;\n         ml + mr = Suc (Suc rs); 0 < mr; 0 < nl + nr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding wadjust_loop_right_move.simps exp_ind \n      wadjust_loop_check.simps"], ["proof (prove)\nusing this:\n  \\<exists>ml mr nl nr rn.\n     c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> m @ [Oc] \\<and>\n     Oc # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n     ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<and> 0 < nl + nr\n\ngoal (1 subgoal):\n 1. (\\<And>nl ml nr mr rn.\n        \\<lbrakk>c =\n                 Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> m @ [Oc];\n         Oc # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn;\n         ml + mr = Suc (Suc rs); 0 < mr; 0 < nl + nr\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> m @ [Oc]\n  Oc # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn\n  ml + mr = Suc (Suc rs)\n  0 < mr\n  0 < nl + nr\n\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (Oc # c, list)", "hence \"\\<exists>ln. Oc # c = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m\"\n    \"\\<exists>rn. list = Oc \\<up> (mr - 1) @ Bk \\<up> rn\" \"ml + (mr - 1) = Suc rs\""], ["proof (prove)\nusing this:\n  c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> m @ [Oc]\n  Oc # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn\n  ml + mr = Suc (Suc rs)\n  0 < mr\n  0 < nl + nr\n\ngoal (1 subgoal):\n 1. \\<exists>ln.\n       Oc # c =\n       Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m &&&\n    \\<exists>rn. list = Oc \\<up> (mr - 1) @ Bk \\<up> rn &&&\n    ml + (mr - 1) = Suc rs", "by(cases nl;cases nr;cases mr;force simp add: wadjust_loop_right_move.simps exp_ind \n        wadjust_loop_check.simps replicate_append_same)+"], ["proof (state)\nthis:\n  \\<exists>ln.\n     Oc # c = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m\n  \\<exists>rn. list = Oc \\<up> (mr - 1) @ Bk \\<up> rn\n  ml + (mr - 1) = Suc rs\n\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (Oc # c, list)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ln.\n     Oc # c = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m\n  \\<exists>rn. list = Oc \\<up> (mr - 1) @ Bk \\<up> rn\n  ml + (mr - 1) = Suc rs\n\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (Oc # c, list)", "unfolding wadjust_loop_check.simps"], ["proof (prove)\nusing this:\n  \\<exists>ln.\n     Oc # c = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m\n  \\<exists>rn. list = Oc \\<up> (mr - 1) @ Bk \\<up> rn\n  ml + (mr - 1) = Suc rs\n\ngoal (1 subgoal):\n 1. \\<exists>ml mr ln rn.\n       Oc # c =\n       Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       list = Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc rs", "by auto"], ["proof (state)\nthis:\n  wadjust_loop_check m rs (Oc # c, list)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wadjust_loop_erase_move_Oc[simp]: \"wadjust_loop_check m rs (c, Oc # list) \\<Longrightarrow> \n               wadjust_loop_erase m rs (tl c, hd c # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs (c, Oc # list) \\<Longrightarrow>\n    wadjust_loop_erase m rs (tl c, hd c # Oc # list)", "apply(simp only: wadjust_loop_check.simps wadjust_loop_erase.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ml mr ln rn.\n       c =\n       Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc rs \\<Longrightarrow>\n    \\<exists>ml mr ln rn.\n       tl c =\n       Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       tl (hd c # Oc # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc rs \\<and> 0 < mr", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       c =\n       Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc rs \\<Longrightarrow>\n       \\<exists>ml mr ln rn.\n          tl c =\n          Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n          tl (hd c # Oc # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n          ml + mr = Suc rs \\<and> 0 < mr", "using Cons_replicate_eq"], ["proof (prove)\nusing this:\n  (?x # ?xs = ?y \\<up> ?n) =\n  (?x = ?y \\<and> 0 < ?n \\<and> ?xs = ?x \\<up> (?n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>ml mr ln rn.\n       c =\n       Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       Oc # list = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc rs \\<Longrightarrow>\n       \\<exists>ml mr ln rn.\n          tl c =\n          Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n          tl (hd c # Oc # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n          ml + mr = Suc rs \\<and> 0 < mr", "by fastforce"], ["", "lemma wadjust_loop_on_move_no_Oc[simp]:\n  \"wadjust_loop_on_left_moving_B m rs (c, Oc # list) = False\"\n  \"wadjust_loop_right_move2 m rs (c, Oc # list) = False\"\n  \"wadjust_loop_on_left_moving m rs (c, Oc # list)\n           \\<Longrightarrow> wadjust_loop_right_move2 m rs (Oc # c, list)\"\n  \"wadjust_on_left_moving_B m rs (c, Oc # list) = False\"\n  \"wadjust_loop_erase m rs (c, Oc # list) \\<Longrightarrow> \n                wadjust_loop_erase m rs (c, Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wadjust_loop_on_left_moving_B m rs (c, Oc # list) = False &&&\n     wadjust_loop_right_move2 m rs (c, Oc # list) = False) &&&\n    (wadjust_loop_on_left_moving m rs (c, Oc # list) \\<Longrightarrow>\n     wadjust_loop_right_move2 m rs (Oc # c, list)) &&&\n    wadjust_on_left_moving_B m rs (c, Oc # list) = False &&&\n    (wadjust_loop_erase m rs (c, Oc # list) \\<Longrightarrow>\n     wadjust_loop_erase m rs (c, Bk # list))", "by(auto simp: wadjust_loop_on_left_moving_B.simps wadjust_loop_on_left_moving_O.simps\n      wadjust_loop_right_move2.simps replicate_app_Cons_same wadjust_loop_on_left_moving.simps\n      wadjust_on_left_moving_B.simps wadjust_loop_erase.simps)"], ["", "lemma wadjust_goon_left_moving_B_Bk_Oc: \"\\<lbrakk>wadjust_on_left_moving_O m rs (c, Oc # list); hd c = Bk\\<rbrakk> \\<Longrightarrow> \n         wadjust_goon_left_moving_B m rs (tl c, Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_O m rs (c, Oc # list);\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_goon_left_moving_B m rs (tl c, Bk # Oc # list)", "apply(auto simp: wadjust_on_left_moving_O.simps \n      wadjust_goon_left_moving_B.simps )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_goon_left_moving_O_Oc_Oc: \"\\<lbrakk>wadjust_on_left_moving_O m rs (c, Oc # list); hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_goon_left_moving_O m rs (tl c, Oc # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_on_left_moving_O m rs (c, Oc # list);\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_goon_left_moving_O m rs (tl c, Oc # Oc # list)", "apply(auto simp: wadjust_on_left_moving_O.simps \n      wadjust_goon_left_moving_O.simps )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<lbrakk>c = Oc # Oc \\<up> rs @ Bk # Oc # Oc \\<up> m;\n        list = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Oc # Bk \\<up> rn =\n                            Oc \\<up> 2 @ Bk \\<up> rna", "apply(auto simp:  numeral_2_eq_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_goon_left_moving_Oc[simp]: \"wadjust_on_left_moving m rs (c, Oc # list) \\<Longrightarrow> \n              wadjust_goon_left_moving m rs (tl c, hd c # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_on_left_moving m rs (c, Oc # list) \\<Longrightarrow>\n    wadjust_goon_left_moving m rs (tl c, hd c # Oc # list)", "by(cases \"hd c\"; force simp: wadjust_on_left_moving.simps wadjust_goon_left_moving.simps\n      wadjust_goon_left_moving_B_Bk_Oc wadjust_goon_left_moving_O_Oc_Oc)+"], ["", "lemma left_moving_Bk_Oc[simp]: \"\\<lbrakk>wadjust_goon_left_moving_O m rs (c, Oc # list); hd c = Bk\\<rbrakk> \n               \\<Longrightarrow> wadjust_goon_left_moving_B m rs (tl c, Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_goon_left_moving_O m rs (c, Oc # list);\n     hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_goon_left_moving_B m rs (tl c, Bk # Oc # list)", "apply(auto simp: wadjust_goon_left_moving_O.simps wadjust_goon_left_moving_B.simps hd_append\n      dest!: gr0_implies_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml rn ma.\n       \\<lbrakk>(if ml = 0 then hd (Bk # Oc # Oc \\<up> m)\n                 else hd (Oc \\<up> ml)) =\n                Bk;\n        c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> ma @ Bk \\<up> rn; ml + ma = Suc rs\\<rbrakk>\n       \\<Longrightarrow> tl (Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) =\n                         Oc # Oc \\<up> m\n 2. \\<And>ml rn ma.\n       \\<lbrakk>(if ml = 0 then hd (Bk # Oc # Oc \\<up> m)\n                 else hd (Oc \\<up> ml)) =\n                Bk;\n        c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> ma @ Bk \\<up> rn; ml + ma = Suc rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc \\<up> ma @ Bk \\<up> rn =\n                            Oc # Oc \\<up> rs @ Bk \\<up> rna", "apply (metis cell.distinct(1) empty_replicate hd_replicate list.sel(3) self_append_conv2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml rn ma.\n       \\<lbrakk>(if ml = 0 then hd (Bk # Oc # Oc \\<up> m)\n                 else hd (Oc \\<up> ml)) =\n                Bk;\n        c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> ma @ Bk \\<up> rn; ml + ma = Suc rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc \\<up> ma @ Bk \\<up> rn =\n                            Oc # Oc \\<up> rs @ Bk \\<up> rna", "by (metis add_cancel_right_left cell.distinct(1) hd_replicate replicate_Suc_iff_anywhere)"], ["", "lemma  left_moving_Oc_Oc[simp]: \"\\<lbrakk>wadjust_goon_left_moving_O m rs (c, Oc # list); hd c = Oc\\<rbrakk> \\<Longrightarrow> \n  wadjust_goon_left_moving_O m rs (tl c, Oc # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_goon_left_moving_O m rs (c, Oc # list);\n     hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_goon_left_moving_O m rs (tl c, Oc # Oc # list)", "apply(auto simp: wadjust_goon_left_moving_O.simps wadjust_goon_left_moving_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>hd (Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) = Oc;\n        c = Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        Oc # list = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc (Suc rs);\n        0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla.\n                            tl (Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) =\n                            Oc \\<up> mla @ Bk # Oc # Oc \\<up> m \\<and>\n                            (\\<exists>mra.\n                                (\\<exists>rna.\n                                    Oc # Oc \\<up> mr @ Bk \\<up> rn =\n                                    Oc \\<up> mra @ Bk \\<up> rna) \\<and>\n                                mla + mra = Suc (Suc rs) \\<and> 0 < mra)", "apply(rename_tac mlx mrx rnx)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mlx mrx rnx.\n       \\<lbrakk>hd (Oc \\<up> mlx @ Bk # Oc # Oc \\<up> m) = Oc;\n        c = Oc \\<up> mlx @ Bk # Oc # Oc \\<up> m;\n        Oc # list = Oc \\<up> mrx @ Bk \\<up> rnx; mlx + mrx = Suc (Suc rs);\n        0 < mrx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            tl (Oc \\<up> mlx @ Bk # Oc # Oc \\<up> m) =\n                            Oc \\<up> ml @ Bk # Oc # Oc \\<up> m \\<and>\n                            (\\<exists>mr.\n                                (\\<exists>rn.\n                                    Oc # Oc \\<up> mrx @ Bk \\<up> rnx =\n                                    Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                ml + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(rule_tac x = \"mlx - 1\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mlx mrx rnx.\n       \\<lbrakk>hd (Oc \\<up> mlx @ Bk # Oc # Oc \\<up> m) = Oc;\n        c = Oc \\<up> mlx @ Bk # Oc # Oc \\<up> m;\n        Oc # list = Oc \\<up> mrx @ Bk \\<up> rnx; mlx + mrx = Suc (Suc rs);\n        0 < mrx\\<rbrakk>\n       \\<Longrightarrow> tl (Oc \\<up> mlx @ Bk # Oc # Oc \\<up> m) =\n                         Oc \\<up> (mlx - Suc 0) @\n                         Bk # Oc # Oc \\<up> m \\<and>\n                         (\\<exists>mr.\n                             (\\<exists>rn.\n                                 Oc # Oc \\<up> mrx @ Bk \\<up> rnx =\n                                 Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                             mlx - Suc 0 + mr = Suc (Suc rs) \\<and> 0 < mr)", "apply(case_tac mlx, simp_all add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mlx mrx rnx nat.\n       \\<lbrakk>c = Oc # Oc \\<up> nat @ Bk # Oc # Oc \\<up> m;\n        Oc # list = Oc \\<up> mrx @ Bk \\<up> rnx; nat + mrx = Suc rs;\n        0 < mrx; mlx = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr.\n                            (\\<exists>rn.\n                                Oc # Oc \\<up> mrx @ Bk \\<up> rnx =\n                                Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                            nat + mr = Suc (Suc rs) \\<and> 0 < mr", "apply(rule_tac x = \"Suc mrx\" in exI, auto simp: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_goon_left_moving_B_no_Oc[simp]:\n  \"wadjust_goon_left_moving_B m rs (c, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_goon_left_moving_B m rs (c, Oc # list) = False", "apply(auto simp: wadjust_goon_left_moving_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_goon_left_moving_Oc_move[simp]: \"wadjust_goon_left_moving m rs (c, Oc # list) \\<Longrightarrow> \n  wadjust_goon_left_moving m rs (tl c, hd c # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_goon_left_moving m rs (c, Oc # list) \\<Longrightarrow>\n    wadjust_goon_left_moving m rs (tl c, hd c # Oc # list)", "by(cases \"hd c\",auto simp: wadjust_goon_left_moving.simps)"], ["", "lemma wadjust_backto_standard_pos_B_no_Oc[simp]:\n  \"wadjust_backto_standard_pos_B m rs (c, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_backto_standard_pos_B m rs (c, Oc # list) = False", "apply(simp add: wadjust_backto_standard_pos_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_backto_standard_pos_O_no_Bk[simp]:\n  \"wadjust_backto_standard_pos_O m rs (c, Bk # xs) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_backto_standard_pos_O m rs (c, Bk # xs) = False", "by(simp add: wadjust_backto_standard_pos_O.simps)"], ["", "lemma wadjust_backto_standard_pos_B_Bk_Oc[simp]:\n  \"wadjust_backto_standard_pos_O m rs ([], Oc # list) \\<Longrightarrow> \n  wadjust_backto_standard_pos_B m rs ([], Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_backto_standard_pos_O m rs ([], Oc # list) \\<Longrightarrow>\n    wadjust_backto_standard_pos_B m rs ([], Bk # Oc # list)", "apply(auto simp: wadjust_backto_standard_pos_O.simps\n      wadjust_backto_standard_pos_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_backto_standard_pos_B_Bk_Oc_via_O[simp]: \n  \"\\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list); c \\<noteq> []; hd c = Bk\\<rbrakk>\n  \\<Longrightarrow> wadjust_backto_standard_pos_B m rs (tl c, Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list);\n     c \\<noteq> []; hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> wadjust_backto_standard_pos_B m rs\n                       (tl c, Bk # Oc # list)", "apply(simp add:wadjust_backto_standard_pos_O.simps \n      wadjust_backto_standard_pos_B.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_backto_standard_pos_B_Oc_Oc_via_O[simp]: \"\\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list); c \\<noteq> []; hd c = Oc\\<rbrakk>\n          \\<Longrightarrow>  wadjust_backto_standard_pos_O m rs (tl c, Oc # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list);\n     c \\<noteq> []; hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> wadjust_backto_standard_pos_O m rs\n                       (tl c, Oc # Oc # list)", "apply(simp add: wadjust_backto_standard_pos_O.simps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr rn.\n       \\<lbrakk>0 < ml; c = Oc \\<up> ml;\n        Oc # list = Oc \\<up> mr @ Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn;\n        ml + mr = Suc m; 0 < mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mra.\n                            (\\<exists>rna.\n                                Oc #\n                                Oc \\<up> mr @\n                                Bk # Oc # Oc # Oc \\<up> rs @ Bk \\<up> rn =\n                                Oc \\<up> mra @\n                                Bk #\n                                Oc # Oc # Oc \\<up> rs @ Bk \\<up> rna) \\<and>\n                            ml + mra - Suc 0 = Suc m \\<and> 0 < mra", "by force"], ["", "lemma wadjust_backto_standard_pos_cases[simp]: \"wadjust_backto_standard_pos m rs (c, Oc # list)\n  \\<Longrightarrow> (c = [] \\<longrightarrow> wadjust_backto_standard_pos m rs ([], Bk # Oc # list)) \\<and> \n (c \\<noteq> [] \\<longrightarrow> wadjust_backto_standard_pos m rs (tl c, hd c # Oc # list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_backto_standard_pos m rs (c, Oc # list) \\<Longrightarrow>\n    (c = [] \\<longrightarrow>\n     wadjust_backto_standard_pos m rs ([], Bk # Oc # list)) \\<and>\n    (c \\<noteq> [] \\<longrightarrow>\n     wadjust_backto_standard_pos m rs (tl c, hd c # Oc # list))", "apply(auto simp: wadjust_backto_standard_pos.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wadjust_backto_standard_pos_O m rs (c, Oc # list);\n     c \\<noteq> [];\n     \\<not> wadjust_backto_standard_pos_O m rs\n             (tl c, hd c # Oc # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_backto_standard_pos_B m rs\n                       (tl c, hd c # Oc # list)", "apply(case_tac \"hd c\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_right_move_nonempty_snd[simp]: \"wadjust_loop_right_move m rs (c, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "fix nl ml mr rn nr"], ["proof (state)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "have \"(c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        [] = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and> ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<and> 0 < nl + nr) =\n    False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n     [] = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n     ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<and> 0 < nl + nr) =\n    False", "by auto"], ["proof (state)\nthis:\n  (c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n   [] = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n   ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<and> 0 < nl + nr) =\n  False\n\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "}"], ["proof (state)\nthis:\n  (c = Bk \\<up> ?nl2 @ Oc # Oc \\<up> ?ml2 @ Bk # Oc \\<up> Suc m \\<and>\n   [] = Bk \\<up> ?nr2 @ Oc \\<up> ?mr2 @ Bk \\<up> ?rn2 \\<and>\n   ?ml2 + ?mr2 = Suc (Suc rs) \\<and> 0 < ?mr2 \\<and> 0 < ?nl2 + ?nr2) =\n  False\n\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "note t=this"], ["proof (state)\nthis:\n  (c = Bk \\<up> ?nl2 @ Oc # Oc \\<up> ?ml2 @ Bk # Oc \\<up> Suc m \\<and>\n   [] = Bk \\<up> ?nr2 @ Oc \\<up> ?mr2 @ Bk \\<up> ?rn2 \\<and>\n   ?ml2 + ?mr2 = Suc (Suc rs) \\<and> 0 < ?mr2 \\<and> 0 < ?nl2 + ?nr2) =\n  False\n\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "thus ?thesis"], ["proof (prove)\nusing this:\n  (c = Bk \\<up> ?nl2 @ Oc # Oc \\<up> ?ml2 @ Bk # Oc \\<up> Suc m \\<and>\n   [] = Bk \\<up> ?nr2 @ Oc \\<up> ?mr2 @ Bk \\<up> ?rn2 \\<and>\n   ?ml2 + ?mr2 = Suc (Suc rs) \\<and> 0 < ?mr2 \\<and> 0 < ?nl2 + ?nr2) =\n  False\n\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, []) = False", "unfolding wadjust_loop_right_move.simps t"], ["proof (prove)\nusing this:\n  False = False\n\ngoal (1 subgoal):\n 1. (\\<exists>ml mr nl nr rn. False) = False", "by blast"], ["proof (state)\nthis:\n  wadjust_loop_right_move m rs (c, []) = False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wadjust_loop_erase_nonempty_snd[simp]: \"wadjust_loop_erase m rs (c, []) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_erase m rs (c, []) = False", "apply(simp only: wadjust_loop_erase.simps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_erase_cases2[simp]: \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_erase m rs (c, Bk # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     wadjust_loop_erase m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Bk # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))", "apply(simp only: wadjust_loop_erase.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     \\<exists>ml mr ln rn.\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        tl (Bk # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Bk # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))", "apply(rule_tac disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     \\<exists>ml mr ln rn.\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n        tl (Bk # list) = Oc \\<up> mr @ Bk \\<up> rn \\<and>\n        ml + mr = Suc rs \\<and> 0 < mr\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))", "apply(case_tac c, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dropWhile_exp1: \"dropWhile (\\<lambda>a. a = Oc) (Oc\\<up>(n) @ xs) = dropWhile (\\<lambda>a. a = Oc) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dropWhile (\\<lambda>a. a = Oc) (Oc \\<up> n @ xs) =\n    dropWhile (\\<lambda>a. a = Oc) xs", "apply(induct n, simp_all add: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma takeWhile_exp1: \"takeWhile (\\<lambda>a. a = Oc) (Oc\\<up>(n) @ xs) = Oc\\<up>(n) @ takeWhile (\\<lambda>a. a = Oc) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>a. a = Oc) (Oc \\<up> n @ xs) =\n    Oc \\<up> n @ takeWhile (\\<lambda>a. a = Oc) xs", "apply(induct n, simp_all add: )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_correctness_helper_1:\n  assumes \"Suc (Suc rs) = a\" \" wadjust_loop_right_move2 m rs (c, Bk # list)\"\n  shows \"a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n                 < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a -\n    length\n     (takeWhile (\\<lambda>a. a = Oc)\n       (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n    < a -\n      length\n       (takeWhile (\\<lambda>a. a = Oc)\n         (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a -\n    length\n     (takeWhile (\\<lambda>a. a = Oc)\n       (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n    < a -\n      length\n       (takeWhile (\\<lambda>a. a = Oc)\n         (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))", "have \"ml + mr = Suc rs \\<Longrightarrow> 0 < mr \\<Longrightarrow>\n       rs - (ml + length (takeWhile (\\<lambda>a. a = Oc) list))\n       < Suc rs -\n         (ml +\n          length\n           (takeWhile (\\<lambda>a. a = Oc)\n             (Bk \\<up> ln @ Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn))) \"\n    for ml mr ln rn"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ml + mr = Suc rs; 0 < mr\\<rbrakk>\n    \\<Longrightarrow> rs -\n                      (ml + length (takeWhile (\\<lambda>a. a = Oc) list))\n                      < Suc rs -\n                        (ml +\n                         length\n                          (takeWhile (\\<lambda>a. a = Oc)\n                            (Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> mr @ Bk \\<up> rn)))", "by(cases ln, auto)"], ["proof (state)\nthis:\n  \\<lbrakk>?ml + ?mr = Suc rs; 0 < ?mr\\<rbrakk>\n  \\<Longrightarrow> rs -\n                    (?ml + length (takeWhile (\\<lambda>a. a = Oc) list))\n                    < Suc rs -\n                      (?ml +\n                       length\n                        (takeWhile (\\<lambda>a. a = Oc)\n                          (Bk \\<up> ?ln @\n                           Bk # Bk # Oc \\<up> ?mr @ Bk \\<up> ?rn)))\n\ngoal (1 subgoal):\n 1. a -\n    length\n     (takeWhile (\\<lambda>a. a = Oc)\n       (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n    < a -\n      length\n       (takeWhile (\\<lambda>a. a = Oc)\n         (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ml + ?mr = Suc rs; 0 < ?mr\\<rbrakk>\n  \\<Longrightarrow> rs -\n                    (?ml + length (takeWhile (\\<lambda>a. a = Oc) list))\n                    < Suc rs -\n                      (?ml +\n                       length\n                        (takeWhile (\\<lambda>a. a = Oc)\n                          (Bk \\<up> ?ln @\n                           Bk # Bk # Oc \\<up> ?mr @ Bk \\<up> ?rn)))\n\ngoal (1 subgoal):\n 1. a -\n    length\n     (takeWhile (\\<lambda>a. a = Oc)\n       (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n    < a -\n      length\n       (takeWhile (\\<lambda>a. a = Oc)\n         (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ml + ?mr = Suc rs; 0 < ?mr\\<rbrakk>\n  \\<Longrightarrow> rs -\n                    (?ml + length (takeWhile (\\<lambda>a. a = Oc) list))\n                    < Suc rs -\n                      (?ml +\n                       length\n                        (takeWhile (\\<lambda>a. a = Oc)\n                          (Bk \\<up> ?ln @\n                           Bk # Bk # Oc \\<up> ?mr @ Bk \\<up> ?rn)))\n  Suc (Suc rs) = a\n  wadjust_loop_right_move2 m rs (c, Bk # list)\n\ngoal (1 subgoal):\n 1. a -\n    length\n     (takeWhile (\\<lambda>a. a = Oc)\n       (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n    < a -\n      length\n       (takeWhile (\\<lambda>a. a = Oc)\n         (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))", "by (auto simp: wadjust_loop_right_move2.simps dropWhile_exp1 takeWhile_exp1)"], ["proof (state)\nthis:\n  a -\n  length\n   (takeWhile (\\<lambda>a. a = Oc)\n     (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\n  < a -\n    length\n     (takeWhile (\\<lambda>a. a = Oc)\n       (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wadjust_correctness_helper_2:\n  \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Bk # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     wadjust_loop_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Bk # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))", "apply(subgoal_tac \"c \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     wadjust_loop_on_left_moving m rs (c, Bk # list); c \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Bk # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))\n 2. \\<lbrakk>Suc (Suc rs) = a;\n     wadjust_loop_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> c \\<noteq> []", "apply(case_tac c, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_check_empty_false[simp]: \"wadjust_loop_check m rs ([], b) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_check m rs ([], b) = False", "apply(simp add: wadjust_loop_check.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_check_cases: \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_check m rs (c, Oc # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Oc # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev (tl c) @ hd c # Oc # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     wadjust_loop_check m rs (c, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Oc # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Oc # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev (tl c) @ hd c # Oc # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Oc # list))))", "apply(case_tac \"c\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_erase_cases_or: \n  \"\\<lbrakk>Suc (Suc rs) = a;  wadjust_loop_erase m rs (c, Oc # list)\\<rbrakk>\n  \\<Longrightarrow> a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list))))\n  < a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list)))) \\<or>\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Bk # list)))) =\n  a - length (takeWhile (\\<lambda>a. a = Oc) (tl (dropWhile (\\<lambda>a. a = Oc) (rev c @ Oc # list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     wadjust_loop_erase m rs (c, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Oc # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Oc # list))))", "apply(simp add: wadjust_loop_erase.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     \\<exists>ml.\n        (\\<exists>ln.\n            c =\n            Bk \\<up> ln @\n            Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) \\<and>\n        (\\<exists>mr.\n            (\\<exists>rn. list = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n            ml + mr = Suc rs \\<and> 0 < mr)\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list))))\n                      < a -\n                        length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (tl (dropWhile (\\<lambda>a. a = Oc)\n                                 (rev c @ Oc # list)))) \\<or>\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Oc # list))))", "apply(rule_tac disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc rs) = a;\n     \\<exists>ml.\n        (\\<exists>ln.\n            c =\n            Bk \\<up> ln @\n            Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m) \\<and>\n        (\\<exists>mr.\n            (\\<exists>rn. list = Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n            ml + mr = Suc rs \\<and> 0 < mr)\\<rbrakk>\n    \\<Longrightarrow> a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Bk # list)))) =\n                      a -\n                      length\n                       (takeWhile (\\<lambda>a. a = Oc)\n                         (tl (dropWhile (\\<lambda>a. a = Oc)\n                               (rev c @ Oc # list))))", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml ln mr rn.\n       \\<lbrakk>a = Suc (Suc rs);\n        c = Bk \\<up> ln @ Bk # Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        list = Oc \\<up> mr @ Bk \\<up> rn; ml + mr = Suc rs; 0 < mr\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc rs) -\n                         length\n                          (takeWhile (\\<lambda>a. a = Oc)\n                            (tl (dropWhile (\\<lambda>a. a = Oc)\n                                  (Oc \\<up> m @\n                                   Oc #\n                                   Bk #\n                                   Oc \\<up> ml @\n                                   Oc #\n                                   Bk #\n                                   Bk \\<up> ln @\n                                   Bk # Oc \\<up> mr @ Bk \\<up> rn)))) =\n                         Suc (Suc rs) -\n                         length\n                          (takeWhile (\\<lambda>a. a = Oc)\n                            (tl (dropWhile (\\<lambda>a. a = Oc)\n                                  (Oc \\<up> m @\n                                   Oc #\n                                   Bk #\n                                   Oc \\<up> ml @\n                                   Oc #\n                                   Bk #\n                                   Bk \\<up> ln @\n                                   Oc # Oc \\<up> mr @ Bk \\<up> rn))))", "apply(simp add: dropWhile_exp1 takeWhile_exp1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas wadjust_correctness_helpers = wadjust_correctness_helper_2 wadjust_correctness_helper_1 wadjust_loop_erase_cases_or wadjust_loop_check_cases"], ["", "declare numeral_2_eq_2[simp del]"], ["", "lemma wadjust_start_Oc[simp]: \"wadjust_start m rs (c, Bk # list)\n       \\<Longrightarrow> wadjust_start m rs (c, Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_start m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_start m rs (c, Oc # list)", "apply(auto simp: wadjust_start.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_stop_Bk[simp]: \"wadjust_backto_standard_pos m rs (c, Bk # list)\n       \\<Longrightarrow> wadjust_stop m rs (Bk # c, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_backto_standard_pos m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_stop m rs (Bk # c, list)", "apply(auto simp: wadjust_backto_standard_pos.simps \n      wadjust_stop.simps wadjust_backto_standard_pos_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_start_Oc[simp]:\n  assumes \"wadjust_start m rs (c, Oc # list)\"\n  shows \"wadjust_loop_start m rs (Oc # c, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (Oc # c, list)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (Oc # c, list)", "from assms[unfolded wadjust_start.simps]"], ["proof (chain)\npicking this:\n  \\<exists>ln rn.\n     c = Bk # Oc \\<up> Suc m \\<and>\n     tl (Oc # list) = Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn", "obtain ln rn where\n    \"c = Bk # Oc # Oc \\<up> m\" \"list = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\""], ["proof (prove)\nusing this:\n  \\<exists>ln rn.\n     c = Bk # Oc \\<up> Suc m \\<and>\n     tl (Oc # list) = Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. (\\<And>ln rn.\n        \\<lbrakk>c = Bk # Oc # Oc \\<up> m;\n         list =\n         Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  c = Bk # Oc # Oc \\<up> m\n  list = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (Oc # c, list)", "hence \"Oc # c = Oc \\<up> 1 @ Bk # Oc \\<up> Suc m \\<and>\n       list = Oc # Bk \\<up> ln @ Bk # Oc \\<up>Suc rs @ Bk \\<up> rn \\<and> 1 + (Suc rs) = Suc (Suc rs) \\<and> 0 < Suc rs\""], ["proof (prove)\nusing this:\n  c = Bk # Oc # Oc \\<up> m\n  list = Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. Oc # c = Oc \\<up> 1 @ Bk # Oc \\<up> Suc m \\<and>\n    list = Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n    1 + Suc rs = Suc (Suc rs) \\<and> 0 < Suc rs", "by auto"], ["proof (state)\nthis:\n  Oc # c = Oc \\<up> 1 @ Bk # Oc \\<up> Suc m \\<and>\n  list = Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n  1 + Suc rs = Suc (Suc rs) \\<and> 0 < Suc rs\n\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (Oc # c, list)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Oc # c = Oc \\<up> 1 @ Bk # Oc \\<up> Suc m \\<and>\n  list = Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n  1 + Suc rs = Suc (Suc rs) \\<and> 0 < Suc rs\n\ngoal (1 subgoal):\n 1. wadjust_loop_start m rs (Oc # c, list)", "unfolding wadjust_loop_start.simps"], ["proof (prove)\nusing this:\n  Oc # c = Oc \\<up> 1 @ Bk # Oc \\<up> Suc m \\<and>\n  list = Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn \\<and>\n  1 + Suc rs = Suc (Suc rs) \\<and> 0 < Suc rs\n\ngoal (1 subgoal):\n 1. \\<exists>ln rn ml mr.\n       Oc # c = Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       list = Oc # Bk \\<up> ln @ Bk # Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and> 0 < mr", "by blast"], ["proof (state)\nthis:\n  wadjust_loop_start m rs (Oc # c, list)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erase2_Bk_if_Oc[simp]:\" wadjust_erase2 m rs (c, Oc # list)\n       \\<Longrightarrow> wadjust_erase2 m rs (c, Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_erase2 m rs (c, Oc # list) \\<Longrightarrow>\n    wadjust_erase2 m rs (c, Bk # list)", "apply(auto simp: wadjust_erase2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_loop_right_move_Bk[simp]: \"wadjust_loop_right_move m rs (c, Bk # list)\n    \\<Longrightarrow> wadjust_loop_right_move m rs (Bk # c, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wadjust_loop_right_move m rs (c, Bk # list) \\<Longrightarrow>\n    wadjust_loop_right_move m rs (Bk # c, list)", "apply(simp only: wadjust_loop_right_move.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ml mr nl nr rn.\n       c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       Bk # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and>\n       0 < mr \\<and> 0 < nl + nr \\<Longrightarrow>\n    \\<exists>ml mr nl nr rn.\n       Bk # c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<and> 0 < nl + nr", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ml mr nl nr rn.\n       c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n       Bk # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n       ml + mr = Suc (Suc rs) \\<and>\n       0 < mr \\<and> 0 < nl + nr \\<Longrightarrow>\n       \\<exists>ml mr nl nr rn.\n          Bk # c =\n          Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc \\<up> Suc m \\<and>\n          list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn \\<and>\n          ml + mr = Suc (Suc rs) \\<and> 0 < mr \\<and> 0 < nl + nr", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ml mr nl nr rn.\n       \\<lbrakk>c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        Bk # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn;\n        ml + mr = Suc (Suc rs); 0 < mr; 0 < nl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla mr nla.\n                            Bk # Bk \\<up> nl @ Oc # Oc \\<up> ml =\n                            Bk \\<up> nla @ Oc # Oc \\<up> mla \\<and>\n                            (\\<exists>nr.\n                                (\\<exists>rn.\n                                    list =\n                                    Bk \\<up> nr @\n                                    Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc (Suc rs) \\<and>\n                                0 < mr \\<and> (0 < nla \\<or> 0 < nr))\n 2. \\<And>ml mr nl nr rn.\n       \\<lbrakk>c = Bk \\<up> nl @ Oc # Oc \\<up> ml @ Bk # Oc # Oc \\<up> m;\n        Bk # list = Bk \\<up> nr @ Oc \\<up> mr @ Bk \\<up> rn;\n        ml + mr = Suc (Suc rs); 0 < mr; 0 < nr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla mr nla.\n                            Bk # Bk \\<up> nl @ Oc # Oc \\<up> ml =\n                            Bk \\<up> nla @ Oc # Oc \\<up> mla \\<and>\n                            (\\<exists>nr.\n                                (\\<exists>rn.\n                                    list =\n                                    Bk \\<up> nr @\n                                    Oc \\<up> mr @ Bk \\<up> rn) \\<and>\n                                mla + mr = Suc (Suc rs) \\<and>\n                                0 < mr \\<and> (0 < nla \\<or> 0 < nr))", "apply (metis cell.distinct(1) empty_replicate hd_append hd_replicate less_SucI\n      list.sel(1) list.sel(3) neq0_conv replicate_Suc_iff_anywhere tl_append2 tl_replicate)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wadjust_correctness:\n  shows \"let P = (\\<lambda> (len, st, l, r). st = 0) in \n  let Q = (\\<lambda> (len, st, l, r). wadjust_inv st m rs (l, r)) in \n  let f = (\\<lambda> stp. (Suc (Suc rs),  steps0 (Suc 0, Bk # Oc\\<up>(Suc m), \n                Bk # Oc # Bk\\<up>(ln) @ Bk #  Oc\\<up>(Suc rs) @ Bk\\<up>(rn)) t_wcode_adjust stp)) in\n    \\<exists> n .P (f n) \\<and> Q (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?P = \"(\\<lambda> (len, st, l, r). st = 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?Q = \"\\<lambda> (len, st, l, r). wadjust_inv st m rs (l, r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "let ?f = \"\\<lambda> stp. (Suc (Suc rs),  steps0 (Suc 0, Bk # Oc\\<up>(Suc m), \n                Bk # Oc # Bk\\<up>(ln) @ Bk # Oc\\<up>(Suc rs) @ Bk\\<up>(rn)) t_wcode_adjust stp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "have \"\\<exists> n. ?P (?f n) \\<and> ?Q (?f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r))", "proof(rule_tac halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?LE\n 2. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 3. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 4. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> ?LE", "show \"wf wadjust_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf wadjust_le", "by auto"], ["proof (state)\nthis:\n  wf wadjust_le\n\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "assume a:\"\\<not> ?P (?f n) \\<and> ?Q (?f n)\""], ["proof (state)\nthis:\n  \\<not> (case (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust n) of\n          (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust n) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r))\n\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "have \"?Q (?f (Suc n)) \\<and> (?f (Suc n), ?f n) \\<in> wadjust_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (Suc (Suc rs),\n           steps0\n            (Suc 0, Bk # Oc \\<up> Suc m,\n             Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n            t_wcode_adjust (Suc n)) of\n     (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n    ((Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust (Suc n)),\n     Suc (Suc rs),\n     steps0\n      (Suc 0, Bk # Oc \\<up> Suc m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n      t_wcode_adjust n)\n    \\<in> wadjust_le", "proof(cases \"?f n\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       (Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n) =\n       (a, b, c, d) \\<Longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "case (fields a b c d)"], ["proof (state)\nthis:\n  (Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n) =\n  (a, b, c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       (Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n) =\n       (a, b, c, d) \\<Longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "then"], ["proof (chain)\npicking this:\n  (Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n) =\n  (a, b, c, d)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n) =\n  (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (case (Suc (Suc rs),\n           steps0\n            (Suc 0, Bk # Oc \\<up> Suc m,\n             Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n            t_wcode_adjust (Suc n)) of\n     (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n    ((Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust (Suc n)),\n     Suc (Suc rs),\n     steps0\n      (Suc 0, Bk # Oc \\<up> Suc m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n      t_wcode_adjust n)\n    \\<in> wadjust_le", "proof(cases d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) =\n             (a, b, c, d);\n     d = []\\<rbrakk>\n    \\<Longrightarrow> (case (Suc (Suc rs),\n                             steps0\n                              (Suc 0, Bk # Oc \\<up> Suc m,\n                               Bk #\n                               Oc #\n                               Bk \\<up> ln @\n                               Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                              t_wcode_adjust (Suc n)) of\n                       (len, st, l, r) \\<Rightarrow>\n                         wadjust_inv st m rs (l, r)) \\<and>\n                      ((Suc (Suc rs),\n                        steps0\n                         (Suc 0, Bk # Oc \\<up> Suc m,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                         t_wcode_adjust (Suc n)),\n                       Suc (Suc rs),\n                       steps0\n                        (Suc 0, Bk # Oc \\<up> Suc m,\n                         Bk #\n                         Oc #\n                         Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                        t_wcode_adjust n)\n                      \\<in> wadjust_le\n 2. \\<And>aa list.\n       \\<lbrakk>(Suc (Suc rs),\n                 steps0\n                  (Suc 0, Bk # Oc \\<up> Suc m,\n                   Bk #\n                   Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                  t_wcode_adjust n) =\n                (a, b, c, d);\n        d = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case (Suc (Suc rs),\n                                steps0\n                                 (Suc 0, Bk # Oc \\<up> Suc m,\n                                  Bk #\n                                  Oc #\n                                  Bk \\<up> ln @\n                                  Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                                 t_wcode_adjust (Suc n)) of\n                          (len, st, l, r) \\<Rightarrow>\n                            wadjust_inv st m rs (l, r)) \\<and>\n                         ((Suc (Suc rs),\n                           steps0\n                            (Suc 0, Bk # Oc \\<up> Suc m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                            t_wcode_adjust (Suc n)),\n                          Suc (Suc rs),\n                          steps0\n                           (Suc 0, Bk # Oc \\<up> Suc m,\n                            Bk #\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                           t_wcode_adjust n)\n                         \\<in> wadjust_le", "case Nil"], ["proof (state)\nthis:\n  d = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) =\n             (a, b, c, d);\n     d = []\\<rbrakk>\n    \\<Longrightarrow> (case (Suc (Suc rs),\n                             steps0\n                              (Suc 0, Bk # Oc \\<up> Suc m,\n                               Bk #\n                               Oc #\n                               Bk \\<up> ln @\n                               Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                              t_wcode_adjust (Suc n)) of\n                       (len, st, l, r) \\<Rightarrow>\n                         wadjust_inv st m rs (l, r)) \\<and>\n                      ((Suc (Suc rs),\n                        steps0\n                         (Suc 0, Bk # Oc \\<up> Suc m,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                         t_wcode_adjust (Suc n)),\n                       Suc (Suc rs),\n                       steps0\n                        (Suc 0, Bk # Oc \\<up> Suc m,\n                         Bk #\n                         Oc #\n                         Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                        t_wcode_adjust n)\n                      \\<in> wadjust_le\n 2. \\<And>aa list.\n       \\<lbrakk>(Suc (Suc rs),\n                 steps0\n                  (Suc 0, Bk # Oc \\<up> Suc m,\n                   Bk #\n                   Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                  t_wcode_adjust n) =\n                (a, b, c, d);\n        d = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case (Suc (Suc rs),\n                                steps0\n                                 (Suc 0, Bk # Oc \\<up> Suc m,\n                                  Bk #\n                                  Oc #\n                                  Bk \\<up> ln @\n                                  Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                                 t_wcode_adjust (Suc n)) of\n                          (len, st, l, r) \\<Rightarrow>\n                            wadjust_inv st m rs (l, r)) \\<and>\n                         ((Suc (Suc rs),\n                           steps0\n                            (Suc 0, Bk # Oc \\<up> Suc m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                            t_wcode_adjust (Suc n)),\n                          Suc (Suc rs),\n                          steps0\n                           (Suc 0, Bk # Oc \\<up> Suc m,\n                            Bk #\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                           t_wcode_adjust n)\n                         \\<in> wadjust_le", "then"], ["proof (chain)\npicking this:\n  d = []", "show ?thesis"], ["proof (prove)\nusing this:\n  d = []\n\ngoal (1 subgoal):\n 1. (case (Suc (Suc rs),\n           steps0\n            (Suc 0, Bk # Oc \\<up> Suc m,\n             Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n            t_wcode_adjust (Suc n)) of\n     (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n    ((Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust (Suc n)),\n     Suc (Suc rs),\n     steps0\n      (Suc 0, Bk # Oc \\<up> Suc m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n      t_wcode_adjust n)\n    \\<in> wadjust_le", "using a fields"], ["proof (prove)\nusing this:\n  d = []\n  \\<not> (case (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust n) of\n          (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust n) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r))\n  (Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n) =\n  (a, b, c, d)\n\ngoal (1 subgoal):\n 1. (case (Suc (Suc rs),\n           steps0\n            (Suc 0, Bk # Oc \\<up> Suc m,\n             Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n            t_wcode_adjust (Suc n)) of\n     (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n    ((Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust (Suc n)),\n     Suc (Suc rs),\n     steps0\n      (Suc 0, Bk # Oc \\<up> Suc m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n      t_wcode_adjust n)\n    \\<in> wadjust_le", "apply(simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d = []; 0 < b \\<and> wadjust_inv b m rs (c, []);\n     Suc (Suc rs) = a \\<and>\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (b, c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust b Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust b Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, b, c, [])\n                      \\<in> wadjust_le", "apply(simp_all only: wadjust_inv.simps split: if_splits)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>d = []; b = Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc 0, c, []);\n     0 < Suc 0 \\<and> wadjust_start m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust (Suc 0) Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust (Suc 0) Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, Suc 0, c, [])\n                      \\<in> wadjust_le\n 2. \\<lbrakk>d = []; Suc (Suc 0) \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc (Suc 0), c, []);\n     b = Suc (Suc 0);\n     0 < Suc (Suc 0) \\<and> wadjust_loop_start m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust (Suc (Suc 0)) Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust (Suc (Suc 0)) Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, Suc (Suc 0), c, [])\n                      \\<in> wadjust_le\n 3. \\<lbrakk>d = []; Suc (Suc (Suc 0)) \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc (Suc (Suc 0)), c, []);\n     Suc (Suc (Suc 0)) \\<noteq> Suc (Suc 0); b = Suc (Suc (Suc 0));\n     0 < Suc (Suc (Suc 0)) \\<and>\n     wadjust_loop_right_move m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust (Suc (Suc (Suc 0)))\n                                  Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust (Suc (Suc (Suc 0)))\n                                 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, Suc (Suc (Suc 0)), c, [])\n                      \\<in> wadjust_le\n 4. \\<lbrakk>d = []; 4 \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (4, c, []);\n     4 \\<noteq> Suc (Suc 0); 4 \\<noteq> Suc (Suc (Suc 0)); b = 4;\n     0 < 4 \\<and> wadjust_loop_check m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 4 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 4 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, 4, c, [])\n                      \\<in> wadjust_le\n 5. \\<lbrakk>d = []; 5 \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (5, c, []);\n     5 \\<noteq> Suc (Suc 0); 5 \\<noteq> Suc (Suc (Suc 0)); 5 \\<noteq> 4;\n     b = 5; 0 < 5 \\<and> wadjust_loop_erase m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 5 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 5 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, 5, c, [])\n                      \\<in> wadjust_le\n 6. \\<lbrakk>d = []; 6 \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (6, c, []);\n     6 \\<noteq> Suc (Suc 0); 6 \\<noteq> Suc (Suc (Suc 0)); 6 \\<noteq> 4;\n     6 \\<noteq> 5; b = 6;\n     0 < 6 \\<and> wadjust_loop_on_left_moving m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 6 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 6 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, 6, c, [])\n                      \\<in> wadjust_le\n 7. \\<lbrakk>d = []; 7 \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (7, c, []);\n     7 \\<noteq> Suc (Suc 0); 7 \\<noteq> Suc (Suc (Suc 0)); 7 \\<noteq> 4;\n     7 \\<noteq> 5; 7 \\<noteq> 6; b = 7;\n     0 < 7 \\<and> wadjust_loop_right_move2 m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 7 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 7 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, 7, c, [])\n                      \\<in> wadjust_le\n 8. \\<lbrakk>d = []; 8 \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (8, c, []);\n     8 \\<noteq> Suc (Suc 0); 8 \\<noteq> Suc (Suc (Suc 0)); 8 \\<noteq> 4;\n     8 \\<noteq> 5; 8 \\<noteq> 6; 8 \\<noteq> 7; b = 8;\n     0 < 8 \\<and> wadjust_erase2 m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 8 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 8 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, 8, c, [])\n                      \\<in> wadjust_le\n 9. \\<lbrakk>d = []; 9 \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (9, c, []);\n     9 \\<noteq> Suc (Suc 0); 9 \\<noteq> Suc (Suc (Suc 0)); 9 \\<noteq> 4;\n     9 \\<noteq> 5; 9 \\<noteq> 6; 9 \\<noteq> 7; 9 \\<noteq> 8; b = 9;\n     0 < 9 \\<and> wadjust_on_left_moving m rs (c, [])\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 9 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 9 Bk of\n                           (a, s') \\<Rightarrow> (s', update a (c, []))),\n                       a, 9, c, [])\n                      \\<in> wadjust_le\n 10. \\<lbrakk>d = []; 10 \\<noteq> Suc 0; Suc (Suc rs) = a;\n      steps0\n       (Suc 0, Bk # Oc # Oc \\<up> m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n       t_wcode_adjust n =\n      (10, c, []);\n      10 \\<noteq> Suc (Suc 0); 10 \\<noteq> Suc (Suc (Suc 0)); 10 \\<noteq> 4;\n      10 \\<noteq> 5; 10 \\<noteq> 6; 10 \\<noteq> 7; 10 \\<noteq> 8;\n      10 \\<noteq> 9; b = 10;\n      0 < 10 \\<and> wadjust_goon_left_moving m rs (c, [])\\<rbrakk>\n     \\<Longrightarrow> (case case fetch t_wcode_adjust 10 Bk of\n                             (a, s') \\<Rightarrow> (s', update a (c, [])) of\n                        (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                       ((a, case fetch t_wcode_adjust 10 Bk of\n                            (a, s') \\<Rightarrow> (s', update a (c, []))),\n                        a, 10, c, [])\n                       \\<in> wadjust_le\nA total of 13 subgoals...", "apply(simp_all add: wadjust_inv.simps wadjust_le_def\n                wadjust_correctness_helpers\n                Abacus.lex_triple_def Abacus.lex_pair_def lex_square_def  split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\nthis:\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n  ((Suc (Suc rs),\n    steps0\n     (Suc 0, Bk # Oc \\<up> Suc m,\n      Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n     t_wcode_adjust (Suc n)),\n   Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n)\n  \\<in> wadjust_le\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>(Suc (Suc rs),\n                 steps0\n                  (Suc 0, Bk # Oc \\<up> Suc m,\n                   Bk #\n                   Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                  t_wcode_adjust n) =\n                (a, b, c, d);\n        d = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case (Suc (Suc rs),\n                                steps0\n                                 (Suc 0, Bk # Oc \\<up> Suc m,\n                                  Bk #\n                                  Oc #\n                                  Bk \\<up> ln @\n                                  Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                                 t_wcode_adjust (Suc n)) of\n                          (len, st, l, r) \\<Rightarrow>\n                            wadjust_inv st m rs (l, r)) \\<and>\n                         ((Suc (Suc rs),\n                           steps0\n                            (Suc 0, Bk # Oc \\<up> Suc m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                            t_wcode_adjust (Suc n)),\n                          Suc (Suc rs),\n                          steps0\n                           (Suc 0, Bk # Oc \\<up> Suc m,\n                            Bk #\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                           t_wcode_adjust n)\n                         \\<in> wadjust_le", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>(Suc (Suc rs),\n                 steps0\n                  (Suc 0, Bk # Oc \\<up> Suc m,\n                   Bk #\n                   Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                  t_wcode_adjust n) =\n                (a, b, c, d);\n        d = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case (Suc (Suc rs),\n                                steps0\n                                 (Suc 0, Bk # Oc \\<up> Suc m,\n                                  Bk #\n                                  Oc #\n                                  Bk \\<up> ln @\n                                  Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                                 t_wcode_adjust (Suc n)) of\n                          (len, st, l, r) \\<Rightarrow>\n                            wadjust_inv st m rs (l, r)) \\<and>\n                         ((Suc (Suc rs),\n                           steps0\n                            (Suc 0, Bk # Oc \\<up> Suc m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                            t_wcode_adjust (Suc n)),\n                          Suc (Suc rs),\n                          steps0\n                           (Suc 0, Bk # Oc \\<up> Suc m,\n                            Bk #\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                           t_wcode_adjust n)\n                         \\<in> wadjust_le", "case (Cons aa list)"], ["proof (state)\nthis:\n  d = aa # list\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>(Suc (Suc rs),\n                 steps0\n                  (Suc 0, Bk # Oc \\<up> Suc m,\n                   Bk #\n                   Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                  t_wcode_adjust n) =\n                (a, b, c, d);\n        d = aa # list\\<rbrakk>\n       \\<Longrightarrow> (case (Suc (Suc rs),\n                                steps0\n                                 (Suc 0, Bk # Oc \\<up> Suc m,\n                                  Bk #\n                                  Oc #\n                                  Bk \\<up> ln @\n                                  Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                                 t_wcode_adjust (Suc n)) of\n                          (len, st, l, r) \\<Rightarrow>\n                            wadjust_inv st m rs (l, r)) \\<and>\n                         ((Suc (Suc rs),\n                           steps0\n                            (Suc 0, Bk # Oc \\<up> Suc m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                            t_wcode_adjust (Suc n)),\n                          Suc (Suc rs),\n                          steps0\n                           (Suc 0, Bk # Oc \\<up> Suc m,\n                            Bk #\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                           t_wcode_adjust n)\n                         \\<in> wadjust_le", "then"], ["proof (chain)\npicking this:\n  d = aa # list", "show ?thesis"], ["proof (prove)\nusing this:\n  d = aa # list\n\ngoal (1 subgoal):\n 1. (case (Suc (Suc rs),\n           steps0\n            (Suc 0, Bk # Oc \\<up> Suc m,\n             Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n            t_wcode_adjust (Suc n)) of\n     (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n    ((Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust (Suc n)),\n     Suc (Suc rs),\n     steps0\n      (Suc 0, Bk # Oc \\<up> Suc m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n      t_wcode_adjust n)\n    \\<in> wadjust_le", "using a fields Nil Cons"], ["proof (prove)\nusing this:\n  d = aa # list\n  \\<not> (case (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust n) of\n          (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust n) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r))\n  (Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n) =\n  (a, b, c, d)\n  ([], []) \\<in> listrel ?r\n  d = aa # list\n\ngoal (1 subgoal):\n 1. (case (Suc (Suc rs),\n           steps0\n            (Suc 0, Bk # Oc \\<up> Suc m,\n             Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n            t_wcode_adjust (Suc n)) of\n     (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n    ((Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust (Suc n)),\n     Suc (Suc rs),\n     steps0\n      (Suc 0, Bk # Oc \\<up> Suc m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n      t_wcode_adjust n)\n    \\<in> wadjust_le", "apply((case_tac aa); simp add: step.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (Suc rs) = a \\<and>\n             steps0\n              (Suc 0, Bk # Oc # Oc \\<up> m,\n               Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n              t_wcode_adjust n =\n             (b, c, Bk # list);\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk;\n     0 < b \\<and> wadjust_inv b m rs (c, Bk # list);\n     \\<And>r. ([], []) \\<in> listrel r; d = Bk # list\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust b Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust b Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, b, c, Bk # list)\n                      \\<in> wadjust_le\n 2. \\<lbrakk>Suc (Suc rs) = a \\<and>\n             steps0\n              (Suc 0, Bk # Oc # Oc \\<up> m,\n               Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n              t_wcode_adjust n =\n             (b, c, Oc # list);\n     \\<And>r. ([], []) \\<in> listrel r; aa = Oc;\n     0 < b \\<and> wadjust_inv b m rs (c, Oc # list);\n     \\<And>r. ([], []) \\<in> listrel r; d = Oc # list\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust b Oc of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Oc # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust b Oc of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Oc # list))),\n                       a, b, c, Oc # list)\n                      \\<in> wadjust_le", "apply(simp_all only: wadjust_inv.simps split: if_splits)"], ["proof (prove)\ngoal (26 subgoals):\n 1. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; b = Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc 0, c, Bk # list);\n     0 < Suc 0 \\<and> wadjust_start m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust (Suc 0) Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust (Suc 0) Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, Suc 0, c, Bk # list)\n                      \\<in> wadjust_le\n 2. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc 0) \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc (Suc 0), c, Bk # list);\n     b = Suc (Suc 0);\n     0 < Suc (Suc 0) \\<and> wadjust_loop_start m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust (Suc (Suc 0)) Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust (Suc (Suc 0)) Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, Suc (Suc 0), c, Bk # list)\n                      \\<in> wadjust_le\n 3. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk;\n     Suc (Suc (Suc 0)) \\<noteq> Suc 0; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc (Suc (Suc 0)), c, Bk # list);\n     Suc (Suc (Suc 0)) \\<noteq> Suc (Suc 0); b = Suc (Suc (Suc 0));\n     0 < Suc (Suc (Suc 0)) \\<and>\n     wadjust_loop_right_move m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust (Suc (Suc (Suc 0)))\n                                  Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust (Suc (Suc (Suc 0)))\n                                 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, Suc (Suc (Suc 0)), c, Bk # list)\n                      \\<in> wadjust_le\n 4. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 4 \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (4, c, Bk # list);\n     4 \\<noteq> Suc (Suc 0); 4 \\<noteq> Suc (Suc (Suc 0)); b = 4;\n     0 < 4 \\<and> wadjust_loop_check m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 4 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 4 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, 4, c, Bk # list)\n                      \\<in> wadjust_le\n 5. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 5 \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (5, c, Bk # list);\n     5 \\<noteq> Suc (Suc 0); 5 \\<noteq> Suc (Suc (Suc 0)); 5 \\<noteq> 4;\n     b = 5; 0 < 5 \\<and> wadjust_loop_erase m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 5 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 5 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, 5, c, Bk # list)\n                      \\<in> wadjust_le\n 6. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 6 \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (6, c, Bk # list);\n     6 \\<noteq> Suc (Suc 0); 6 \\<noteq> Suc (Suc (Suc 0)); 6 \\<noteq> 4;\n     6 \\<noteq> 5; b = 6;\n     0 < 6 \\<and> wadjust_loop_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 6 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 6 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, 6, c, Bk # list)\n                      \\<in> wadjust_le\n 7. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 7 \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (7, c, Bk # list);\n     7 \\<noteq> Suc (Suc 0); 7 \\<noteq> Suc (Suc (Suc 0)); 7 \\<noteq> 4;\n     7 \\<noteq> 5; 7 \\<noteq> 6; b = 7;\n     0 < 7 \\<and> wadjust_loop_right_move2 m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 7 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 7 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, 7, c, Bk # list)\n                      \\<in> wadjust_le\n 8. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 8 \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (8, c, Bk # list);\n     8 \\<noteq> Suc (Suc 0); 8 \\<noteq> Suc (Suc (Suc 0)); 8 \\<noteq> 4;\n     8 \\<noteq> 5; 8 \\<noteq> 6; 8 \\<noteq> 7; b = 8;\n     0 < 8 \\<and> wadjust_erase2 m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 8 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 8 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, 8, c, Bk # list)\n                      \\<in> wadjust_le\n 9. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 9 \\<noteq> Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (9, c, Bk # list);\n     9 \\<noteq> Suc (Suc 0); 9 \\<noteq> Suc (Suc (Suc 0)); 9 \\<noteq> 4;\n     9 \\<noteq> 5; 9 \\<noteq> 6; 9 \\<noteq> 7; 9 \\<noteq> 8; b = 9;\n     0 < 9 \\<and> wadjust_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> (case case fetch t_wcode_adjust 9 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list)) of\n                       (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                      ((a, case fetch t_wcode_adjust 9 Bk of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (c, Bk # list))),\n                       a, 9, c, Bk # list)\n                      \\<in> wadjust_le\n 10. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n      \\<And>r. ([], []) \\<in> listrel r; aa = Bk; 10 \\<noteq> Suc 0;\n      Suc (Suc rs) = a;\n      steps0\n       (Suc 0, Bk # Oc # Oc \\<up> m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n       t_wcode_adjust n =\n      (10, c, Bk # list);\n      10 \\<noteq> Suc (Suc 0); 10 \\<noteq> Suc (Suc (Suc 0)); 10 \\<noteq> 4;\n      10 \\<noteq> 5; 10 \\<noteq> 6; 10 \\<noteq> 7; 10 \\<noteq> 8;\n      10 \\<noteq> 9; b = 10;\n      0 < 10 \\<and> wadjust_goon_left_moving m rs (c, Bk # list)\\<rbrakk>\n     \\<Longrightarrow> (case case fetch t_wcode_adjust 10 Bk of\n                             (a, s') \\<Rightarrow>\n                               (s', update a (c, Bk # list)) of\n                        (st, x) \\<Rightarrow> wadjust_inv st m rs x) \\<and>\n                       ((a, case fetch t_wcode_adjust 10 Bk of\n                            (a, s') \\<Rightarrow>\n                              (s', update a (c, Bk # list))),\n                        a, 10, c, Bk # list)\n                       \\<in> wadjust_le\nA total of 26 subgoals...", "apply(simp_all)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; b = Suc 0;\n     Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc 0, c, Bk # list);\n     wadjust_start m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv (Suc 0) m rs (c, Oc # list) \\<and>\n                      ((a, Suc 0, c, Oc # list), a, Suc 0, c, Bk # list)\n                      \\<in> wadjust_le\n 2. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (Suc (Suc (Suc 0)), c, Bk # list);\n     b = Suc (Suc (Suc 0));\n     wadjust_loop_right_move m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv (Suc (Suc (Suc 0))) m rs\n                       (Bk # c, list) \\<and>\n                      ((a, Suc (Suc (Suc 0)), Bk # c, list), a,\n                       Suc (Suc (Suc 0)), c, Bk # list)\n                      \\<in> wadjust_le\n 3. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (4, c, Bk # list);\n     b = 4; wadjust_loop_check m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 8 m rs (tl c, hd c # Bk # list) \\<and>\n                      ((a, 8, tl c, hd c # Bk # list), a, 4, c, Bk # list)\n                      \\<in> wadjust_le\n 4. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (5, c, Bk # list);\n     b = 5; wadjust_loop_erase m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 6 m rs (tl c, hd c # Bk # list) \\<and>\n                      ((a, 6, tl c, hd c # Bk # list), a, 5, c, Bk # list)\n                      \\<in> wadjust_le\n 5. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (6, c, Bk # list);\n     b = 6; wadjust_loop_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 6 m rs (tl c, hd c # Bk # list) \\<and>\n                      ((a, 6, tl c, hd c # Bk # list), a, 6, c, Bk # list)\n                      \\<in> wadjust_le\n 6. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (7, c, Bk # list);\n     b = 7; wadjust_loop_right_move2 m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 2 m rs (c, Oc # list) \\<and>\n                      ((a, 2, c, Oc # list), a, 7, c, Bk # list)\n                      \\<in> wadjust_le\n 7. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (8, c, Bk # list);\n     b = 8; wadjust_erase2 m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 9 m rs (tl c, hd c # Bk # list) \\<and>\n                      ((a, 9, tl c, hd c # Bk # list), a, 8, c, Bk # list)\n                      \\<in> wadjust_le\n 8. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (9, c, Bk # list);\n     b = 9; wadjust_on_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 9 m rs (tl c, hd c # Bk # list) \\<and>\n                      ((a, 9, tl c, hd c # Bk # list), a, 9, c, Bk # list)\n                      \\<in> wadjust_le\n 9. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n     \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n     steps0\n      (Suc 0, Bk # Oc # Oc \\<up> m,\n       Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n      t_wcode_adjust n =\n     (10, c, Bk # list);\n     b = 10; wadjust_goon_left_moving m rs (c, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> wadjust_inv 11 m rs (tl c, hd c # Bk # list) \\<and>\n                      ((a, 11, tl c, hd c # Bk # list), a, 10, c, Bk # list)\n                      \\<in> wadjust_le\n 10. \\<lbrakk>\\<And>r. ([], []) \\<in> listrel r; d = Bk # list;\n      \\<And>r. ([], []) \\<in> listrel r; aa = Bk; Suc (Suc rs) = a;\n      steps0\n       (Suc 0, Bk # Oc # Oc \\<up> m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc # Oc \\<up> rs @ Bk \\<up> rn)\n       t_wcode_adjust n =\n      (11, c, Bk # list);\n      b = 11; wadjust_backto_standard_pos m rs (c, Bk # list)\\<rbrakk>\n     \\<Longrightarrow> wadjust_inv 0 m rs (Bk # c, list) \\<and>\n                       ((a, 0, Bk # c, list), a, 11, c, Bk # list)\n                       \\<in> wadjust_le\nA total of 20 subgoals...", "apply(simp_all add: wadjust_inv.simps wadjust_le_def\n                wadjust_correctness_helpers\n                Abacus.lex_triple_def Abacus.lex_pair_def lex_square_def  split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\nthis:\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n  ((Suc (Suc rs),\n    steps0\n     (Suc 0, Bk # Oc \\<up> Suc m,\n      Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n     t_wcode_adjust (Suc n)),\n   Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n)\n  \\<in> wadjust_le\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n  ((Suc (Suc rs),\n    steps0\n     (Suc 0, Bk # Oc \\<up> Suc m,\n      Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n     t_wcode_adjust (Suc n)),\n   Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n)\n  \\<in> wadjust_le\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n  ((Suc (Suc rs),\n    steps0\n     (Suc 0, Bk # Oc \\<up> Suc m,\n      Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n     t_wcode_adjust (Suc n)),\n   Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust n)\n  \\<in> wadjust_le\n\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "}"], ["proof (state)\nthis:\n  \\<not> (case (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust ?n4) of\n          (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust ?n4) of\n   (len, st, l, r) \\<Rightarrow>\n     wadjust_inv st m rs (l, r)) \\<Longrightarrow>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc ?n4)) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n  ((Suc (Suc rs),\n    steps0\n     (Suc 0, Bk # Oc \\<up> Suc m,\n      Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n     t_wcode_adjust (Suc ?n4)),\n   Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust ?n4)\n  \\<in> wadjust_le\n\ngoal (3 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)\n 3. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "thus \"\\<forall> n. \\<not> ?P (?f n) \\<and> ?Q (?f n) \\<longrightarrow> \n                 ?Q (?f (Suc n)) \\<and> (?f (Suc n), ?f n) \\<in> wadjust_le\""], ["proof (prove)\nusing this:\n  \\<not> (case (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust ?n4) of\n          (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust ?n4) of\n   (len, st, l, r) \\<Rightarrow>\n     wadjust_inv st m rs (l, r)) \\<Longrightarrow>\n  (case (Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc ?n4)) of\n   (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n  ((Suc (Suc rs),\n    steps0\n     (Suc 0, Bk # Oc \\<up> Suc m,\n      Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n     t_wcode_adjust (Suc ?n4)),\n   Suc (Suc rs),\n   steps0\n    (Suc 0, Bk # Oc \\<up> Suc m,\n     Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n    t_wcode_adjust ?n4)\n  \\<in> wadjust_le\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> (case (Suc (Suc rs),\n                     steps0\n                      (Suc 0, Bk # Oc \\<up> Suc m,\n                       Bk #\n                       Oc #\n                       Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                      t_wcode_adjust n) of\n               (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust n) of\n        (len, st, l, r) \\<Rightarrow>\n          wadjust_inv st m rs (l, r)) \\<longrightarrow>\n       (case (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust (Suc n)) of\n        (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n       ((Suc (Suc rs),\n         steps0\n          (Suc 0, Bk # Oc \\<up> Suc m,\n           Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n          t_wcode_adjust (Suc n)),\n        Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust n)\n       \\<in> wadjust_le", "by auto"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> (case (Suc (Suc rs),\n                   steps0\n                    (Suc 0, Bk # Oc \\<up> Suc m,\n                     Bk #\n                     Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                    t_wcode_adjust n) of\n             (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case (Suc (Suc rs),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow>\n        wadjust_inv st m rs (l, r)) \\<longrightarrow>\n     (case (Suc (Suc rs),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n             t_wcode_adjust (Suc n)) of\n      (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)) \\<and>\n     ((Suc (Suc rs),\n       steps0\n        (Suc 0, Bk # Oc \\<up> Suc m,\n         Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n        t_wcode_adjust (Suc n)),\n      Suc (Suc rs),\n      steps0\n       (Suc 0, Bk # Oc \\<up> Suc m,\n        Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n       t_wcode_adjust n)\n     \\<in> wadjust_le\n\ngoal (2 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n 2. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)", "show \"?Q (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (Suc (Suc rs),\n          steps0\n           (Suc 0, Bk # Oc \\<up> Suc m,\n            Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n           t_wcode_adjust 0) of\n    (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)", "by(auto simp add: steps.simps wadjust_inv.simps wadjust_start.simps)"], ["proof (state)\nthis:\n  case (Suc (Suc rs),\n        steps0\n         (Suc 0, Bk # Oc \\<up> Suc m,\n          Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n         t_wcode_adjust 0) of\n  (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r)\n\ngoal (1 subgoal):\n 1. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)", "show \"\\<not> ?P (?f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case (Suc (Suc rs),\n                  steps0\n                   (Suc 0, Bk # Oc \\<up> Suc m,\n                    Bk #\n                    Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                   t_wcode_adjust 0) of\n            (len, st, l, r) \\<Rightarrow> st = 0)", "by (simp add: steps.simps)"], ["proof (state)\nthis:\n  \\<not> (case (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust 0) of\n          (len, st, l, r) \\<Rightarrow> st = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n.\n     (case (Suc (Suc rs),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case (Suc (Suc rs),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "thus\"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     (case (Suc (Suc rs),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case (Suc (Suc rs),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow> wadjust_inv st m rs (l, r))\n\ngoal (1 subgoal):\n 1. let P = \\<lambda>(len, st, l, r). st = 0;\n        Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n        f = \\<lambda>stp.\n               (Suc (Suc rs),\n                steps0\n                 (Suc 0, Bk # Oc \\<up> Suc m,\n                  Bk #\n                  Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n                 t_wcode_adjust stp)\n    in \\<exists>n. P (f n) \\<and> Q (f n)", "by simp"], ["proof (state)\nthis:\n  let P = \\<lambda>(len, st, l, r). st = 0;\n      Q = \\<lambda>(len, st, l, r). wadjust_inv st m rs (l, r);\n      f = \\<lambda>stp.\n             (Suc (Suc rs),\n              steps0\n               (Suc 0, Bk # Oc \\<up> Suc m,\n                Bk # Oc # Bk \\<up> ln @ Bk # Oc \\<up> Suc rs @ Bk \\<up> rn)\n               t_wcode_adjust stp)\n  in \\<exists>n. P (f n) \\<and> Q (f n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_wf_t_wcode_adjust[intro]: \"tm_wf (t_wcode_adjust, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode_adjust", "by(auto simp: t_wcode_adjust_def tm_wf.simps)"], ["", "lemma bl_bin_nonzero[simp]: \"args \\<noteq> [] \\<Longrightarrow> bl_bin (<args::nat list>) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow> 0 < bl_bin (<args>)", "by(cases args)\n    (auto simp: tape_of_nl_cons bl_bin.simps)"], ["", "lemma wcode_lemma_pre':\n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp rn. steps0 (Suc 0, [], <m # args>) \n              ((t_wcode_prepare |+| t_wcode_main) |+| t_wcode_adjust) stp\n  = (0,  [Bk],  Oc\\<up>(Suc m) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "let ?P1 = \"\\<lambda> (l, r). l = [] \\<and> r = <m # args>\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "let ?Q1 = \"\\<lambda>(l, r). l = Bk # Oc\\<up>(Suc m) \\<and>\n    (\\<exists>ln rn. r = Bk # Oc # Bk\\<up>(ln) @ Bk # Bk # Oc\\<up>(bl_bin (<args>)) @ Bk\\<up>(rn))\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "let ?P2 = ?Q1"], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "let ?Q2 = \"\\<lambda> (l, r). (wadjust_stop m (bl_bin (<args>) - 1) (l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "let ?P3 = \"\\<lambda> tp. False\""], ["proof (state)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "assume h: \"args \\<noteq> []\""], ["proof (state)\nthis:\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "hence a: \"bl_bin (<args>) > 0\""], ["proof (prove)\nusing this:\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < bl_bin (<args>)", "using h"], ["proof (prove)\nusing this:\n  args \\<noteq> []\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < bl_bin (<args>)", "by simp"], ["proof (state)\nthis:\n  0 < bl_bin (<args>)\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "hence \"{?P1} (t_wcode_prepare |+| t_wcode_main) |+| t_wcode_adjust {?Q2}\""], ["proof (prove)\nusing this:\n  0 < bl_bin (<args>)\n\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}", "proof(rule_tac Hoare_plus_halt)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main {?Q1}\n 2. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {?Q1} t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}\n 3. 0 < bl_bin (<args>) \\<Longrightarrow>\n    tm_wf0 (t_wcode_prepare |+| t_wcode_main)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main {?Q1}\n 2. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {?Q1} t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}\n 3. 0 < bl_bin (<args>) \\<Longrightarrow>\n    tm_wf0 (t_wcode_prepare |+| t_wcode_main)", "show \"tm_wf (t_wcode_prepare |+| t_wcode_main, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 (t_wcode_prepare |+| t_wcode_main)", "by(rule_tac tm_comp_wf, auto)"], ["proof (state)\nthis:\n  tm_wf0 (t_wcode_prepare |+| t_wcode_main)\n\ngoal (2 subgoals):\n 1. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main {?Q1}\n 2. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {?Q1} t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main {?Q1}\n 2. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {?Q1} t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}", "show \"{?P1} t_wcode_prepare |+| t_wcode_main {?Q1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n    t_wcode_prepare |+| t_wcode_main\n    {\\<lambda>(l, r).\n        l = Bk # Oc \\<up> Suc m \\<and>\n        (\\<exists>ln rn.\n            r =\n            Bk #\n            Oc #\n            Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)}", "proof(rule_tac Hoare_haltI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n          n) \\<and>\n       (\\<lambda>(l, r).\n           l = Bk # Oc # Oc \\<up> m \\<and>\n           (\\<exists>ln rn.\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <m # args>)\n  (t_wcode_prepare |+| t_wcode_main) n", "show \n        \"\\<exists>n. is_final (steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n        (\\<lambda>(l, r). l = Bk # Oc # Oc \\<up> m \\<and>\n        (\\<exists>ln rn. r = Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn))\n        holds_for steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n          n) \\<and>\n       (\\<lambda>(l, r).\n           l = Bk # Oc # Oc \\<up> m \\<and>\n           (\\<exists>ln rn.\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <m # args>)\n  (t_wcode_prepare |+| t_wcode_main) n", "using h prepare_mainpart_lemma[of args m]"], ["proof (prove)\nusing this:\n  args \\<noteq> []\n  args \\<noteq> [] \\<Longrightarrow>\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main) stp =\n     (0, Bk # Oc \\<up> Suc m,\n      Bk #\n      Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n          n) \\<and>\n       (\\<lambda>(l, r).\n           l = Bk # Oc # Oc \\<up> m \\<and>\n           (\\<exists>ln rn.\n               r =\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <m # args>)\n  (t_wcode_prepare |+| t_wcode_main) n", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       \\<lbrakk>args \\<noteq> [];\n        steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n         stp =\n        (0, Bk # Oc # Oc \\<up> m,\n         Bk #\n         Oc #\n         Bk \\<up> ln @\n         Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <m # args>)\n                               (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n                            (\\<lambda>(l, r).\n                                l = Bk # Oc # Oc \\<up> m \\<and>\n                                (\\<exists>ln rn.\n                                    r =\n                                    Bk #\n                                    Oc #\n                                    Bk \\<up> ln @\n                                    Bk #\n                                    Bk #\n                                    Oc \\<up> bl_bin (<args>) @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, [], <m # args>)\n                       (t_wcode_prepare |+| t_wcode_main) n", "apply(rename_tac stp ln rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       \\<lbrakk>args \\<noteq> [];\n        steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n         stp =\n        (0, Bk # Oc # Oc \\<up> m,\n         Bk #\n         Oc #\n         Bk \\<up> ln @\n         Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <m # args>)\n                               (t_wcode_prepare |+| t_wcode_main) n) \\<and>\n                            (\\<lambda>(l, r).\n                                l = Bk # Oc # Oc \\<up> m \\<and>\n                                (\\<exists>ln rn.\n                                    r =\n                                    Bk #\n                                    Oc #\n                                    Bk \\<up> ln @\n                                    Bk #\n                                    Bk #\n                                    Oc \\<up> bl_bin (<args>) @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, [], <m # args>)\n                       (t_wcode_prepare |+| t_wcode_main) n", "apply(rule_tac x = stp in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp ln rn.\n       \\<lbrakk>args \\<noteq> [];\n        steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n         stp =\n        (0, Bk # Oc # Oc \\<up> m,\n         Bk #\n         Oc #\n         Bk \\<up> ln @\n         Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lna rna.\n                            Bk \\<up> ln @\n                            Bk #\n                            Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn =\n                            Bk \\<up> lna @\n                            Bk #\n                            Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rna", "apply(rule_tac x = ln in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final\n      (steps0 (Suc 0, [], <m # args>) (t_wcode_prepare |+| t_wcode_main)\n        n) \\<and>\n     (\\<lambda>(l, r).\n         l = Bk # Oc # Oc \\<up> m \\<and>\n         (\\<exists>ln rn.\n             r =\n             Bk #\n             Oc #\n             Bk \\<up> ln @\n             Bk #\n             Bk #\n             Oc \\<up> bl_bin (<args>) @\n             Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <m # args>)\n(t_wcode_prepare |+| t_wcode_main) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n  t_wcode_prepare |+| t_wcode_main\n  {\\<lambda>(l, r).\n      l = Bk # Oc \\<up> Suc m \\<and>\n      (\\<exists>ln rn.\n          r =\n          Bk #\n          Oc #\n          Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)}\n\ngoal (1 subgoal):\n 1. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {\\<lambda>(l, r).\n        l = Bk # Oc \\<up> Suc m \\<and>\n        (\\<exists>ln rn.\n            r =\n            Bk #\n            Oc #\n            Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)}\n    t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < bl_bin (<args>) \\<Longrightarrow>\n    {\\<lambda>(l, r).\n        l = Bk # Oc \\<up> Suc m \\<and>\n        (\\<exists>ln rn.\n            r =\n            Bk #\n            Oc #\n            Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)}\n    t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}", "show \"{?P2} t_wcode_adjust {?Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = Bk # Oc \\<up> Suc m \\<and>\n        (\\<exists>ln rn.\n            r =\n            Bk #\n            Oc #\n            Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)}\n    t_wcode_adjust\n    {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}", "proof(rule_tac Hoare_haltI, auto del: replicate_Suc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, Bk # Oc # Oc \\<up> m,\n              Bk #\n              Oc #\n              Bk \\<up> ln @\n              Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n             t_wcode_adjust n) \\<and>\n          wadjust_stop m\n           (bl_bin (<args>) -\n            Suc 0) holds_for steps0\n                              (Suc 0, Bk # Oc # Oc \\<up> m,\n                               Bk #\n                               Oc #\n                               Bk \\<up> ln @\n                               Bk #\n                               Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                              t_wcode_adjust n", "fix ln rn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, Bk # Oc # Oc \\<up> m,\n              Bk #\n              Oc #\n              Bk \\<up> ln @\n              Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n             t_wcode_adjust n) \\<and>\n          wadjust_stop m\n           (bl_bin (<args>) -\n            Suc 0) holds_for steps0\n                              (Suc 0, Bk # Oc # Oc \\<up> m,\n                               Bk #\n                               Oc #\n                               Bk \\<up> ln @\n                               Bk #\n                               Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                              t_wcode_adjust n", "obtain n a b where \"steps0\n        (Suc 0, Bk # Oc \\<up> m @ [Oc],\n         Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n        t_wcode_adjust n = (0, a, b)\"\n        \"wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n a b.\n        \\<lbrakk>steps0\n                  (Suc 0, Bk # Oc \\<up> m @ [Oc],\n                   Bk #\n                   Oc #\n                   Bk \\<up> ln @\n                   Bk #\n                   Bk #\n                   Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n                  t_wcode_adjust n =\n                 (0, a, b);\n         wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wadjust_correctness[of m \"bl_bin (<args>) - 1\" \"Suc ln\" rn,unfolded Let_def]"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     (case (Suc (Suc (bl_bin (<args>) - 1)),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk #\n              Oc #\n              Bk \\<up> Suc ln @\n              Bk # Oc \\<up> Suc (bl_bin (<args>) - 1) @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow> st = 0) \\<and>\n     (case (Suc (Suc (bl_bin (<args>) - 1)),\n            steps0\n             (Suc 0, Bk # Oc \\<up> Suc m,\n              Bk #\n              Oc #\n              Bk \\<up> Suc ln @\n              Bk # Oc \\<up> Suc (bl_bin (<args>) - 1) @ Bk \\<up> rn)\n             t_wcode_adjust n) of\n      (len, st, l, r) \\<Rightarrow>\n        wadjust_inv st m (bl_bin (<args>) - 1) (l, r))\n\ngoal (1 subgoal):\n 1. (\\<And>n a b.\n        \\<lbrakk>steps0\n                  (Suc 0, Bk # Oc \\<up> m @ [Oc],\n                   Bk #\n                   Oc #\n                   Bk \\<up> ln @\n                   Bk #\n                   Bk #\n                   Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n                  t_wcode_adjust n =\n                 (0, a, b);\n         wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp del: replicate_Suc add: replicate_Suc[THEN sym] exp_ind, auto)"], ["proof (state)\nthis:\n  steps0\n   (Suc 0, Bk # Oc \\<up> m @ [Oc],\n    Bk #\n    Oc #\n    Bk \\<up> ln @\n    Bk # Bk # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n   t_wcode_adjust n =\n  (0, a, b)\n  wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>ln rn.\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, Bk # Oc # Oc \\<up> m,\n              Bk #\n              Oc #\n              Bk \\<up> ln @\n              Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n             t_wcode_adjust n) \\<and>\n          wadjust_stop m\n           (bl_bin (<args>) -\n            Suc 0) holds_for steps0\n                              (Suc 0, Bk # Oc # Oc \\<up> m,\n                               Bk #\n                               Oc #\n                               Bk \\<up> ln @\n                               Bk #\n                               Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                              t_wcode_adjust n", "thus \"\\<exists>n. is_final (steps0 (Suc 0, Bk # Oc # Oc \\<up> m, \n        Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn) t_wcode_adjust n) \\<and>\n        wadjust_stop m (bl_bin (<args>) - Suc 0) holds_for steps0\n        (Suc 0, Bk # Oc # Oc \\<up> m, Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn) t_wcode_adjust n\""], ["proof (prove)\nusing this:\n  steps0\n   (Suc 0, Bk # Oc \\<up> m @ [Oc],\n    Bk #\n    Oc #\n    Bk \\<up> ln @\n    Bk # Bk # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n   t_wcode_adjust n =\n  (0, a, b)\n  wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, Bk # Oc # Oc \\<up> m,\n           Bk #\n           Oc #\n           Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n          t_wcode_adjust n) \\<and>\n       wadjust_stop m\n        (bl_bin (<args>) -\n         Suc 0) holds_for steps0\n                           (Suc 0, Bk # Oc # Oc \\<up> m,\n                            Bk #\n                            Oc #\n                            Bk \\<up> ln @\n                            Bk #\n                            Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                           t_wcode_adjust n", "apply(rule_tac x = n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (Suc 0, Bk # Oc \\<up> m @ [Oc],\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n              t_wcode_adjust n =\n             (0, a, b);\n     wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\\<rbrakk>\n    \\<Longrightarrow> is_final\n                       (steps0\n                         (Suc 0, Bk # Oc # Oc \\<up> m,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                         t_wcode_adjust n) \\<and>\n                      wadjust_stop m\n                       (bl_bin (<args>) -\n                        Suc 0) holds_for steps0\n    (Suc 0, Bk # Oc # Oc \\<up> m,\n     Bk #\n     Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n    t_wcode_adjust n", "using a"], ["proof (prove)\nusing this:\n  0 < bl_bin (<args>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0\n              (Suc 0, Bk # Oc \\<up> m @ [Oc],\n               Bk #\n               Oc #\n               Bk \\<up> ln @\n               Bk #\n               Bk # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Oc # Bk \\<up> rn)\n              t_wcode_adjust n =\n             (0, a, b);\n     wadjust_inv 0 m (bl_bin (<args>) - Suc 0) (a, b)\\<rbrakk>\n    \\<Longrightarrow> is_final\n                       (steps0\n                         (Suc 0, Bk # Oc # Oc \\<up> m,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                         t_wcode_adjust n) \\<and>\n                      wadjust_stop m\n                       (bl_bin (<args>) -\n                        Suc 0) holds_for steps0\n    (Suc 0, Bk # Oc # Oc \\<up> m,\n     Bk #\n     Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n    t_wcode_adjust n", "apply(case_tac \"bl_bin (<args>)\", simp, simp del: replicate_Suc add: exp_ind wadjust_inv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk # Oc \\<up> m @ [Oc],\n                  Bk #\n                  Oc #\n                  Bk \\<up> ln @ Bk # Bk # Oc \\<up> nat @ Oc # Bk \\<up> rn)\n                 t_wcode_adjust n =\n                (0, a, b);\n        wadjust_stop m nat (a, b); bl_bin (<args>) = Suc nat\\<rbrakk>\n       \\<Longrightarrow> is_final\n                          (steps0\n                            (Suc 0, Bk # Oc # Oc \\<up> m,\n                             Bk #\n                             Oc #\n                             Bk \\<up> ln @\n                             Bk # Bk # Oc \\<up> nat @ Oc # Bk \\<up> rn)\n                            t_wcode_adjust n) \\<and>\n                         wadjust_stop m\n                          nat holds_for steps0\n   (Suc 0, Bk # Oc # Oc \\<up> m,\n    Bk # Oc # Bk \\<up> ln @ Bk # Bk # Oc \\<up> nat @ Oc # Bk \\<up> rn)\n   t_wcode_adjust n", "by (simp add: replicate_append_same)"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final\n      (steps0\n        (Suc 0, Bk # Oc # Oc \\<up> m,\n         Bk #\n         Oc #\n         Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n        t_wcode_adjust n) \\<and>\n     wadjust_stop m\n      (bl_bin (<args>) -\n       Suc 0) holds_for steps0\n                         (Suc 0, Bk # Oc # Oc \\<up> m,\n                          Bk #\n                          Oc #\n                          Bk \\<up> ln @\n                          Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n                         t_wcode_adjust n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r).\n      l = Bk # Oc \\<up> Suc m \\<and>\n      (\\<exists>ln rn.\n          r =\n          Bk #\n          Oc #\n          Bk \\<up> ln @ Bk # Bk # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)}\n  t_wcode_adjust\n  {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n  t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n  {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n  t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n  {\\<lambda>(l, r). wadjust_stop m (bl_bin (<args>) - 1) (l, r)}\n\ngoal (1 subgoal):\n 1. \\<exists>stp rn.\n       steps0 (Suc 0, [], <m # args>)\n        (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "apply(simp add: Hoare_halt_def, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n                t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n                {wadjust_stop m (bl_bin (<args>) - Suc 0)};\n        is_final\n         (steps0 (Suc 0, [], <m # args>)\n           (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) n);\n        wadjust_stop m\n         (bl_bin (<args>) -\n          Suc 0) holds_for steps0 (Suc 0, [], <m # args>)\n                            (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)\n                            n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp rn.\n                            steps0 (Suc 0, [], <m # args>)\n                             (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)\n                             stp =\n                            (0, [Bk],\n                             Oc #\n                             Oc \\<up> m @\n                             Bk #\n                             Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "apply(rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>{\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n                t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n                {wadjust_stop m (bl_bin (<args>) - Suc 0)};\n        is_final\n         (steps0 (Suc 0, [], <m # args>)\n           (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) n);\n        wadjust_stop m\n         (bl_bin (<args>) -\n          Suc 0) holds_for steps0 (Suc 0, [], <m # args>)\n                            (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)\n                            n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp rn.\n                            steps0 (Suc 0, [], <m # args>)\n                             (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)\n                             stp =\n                            (0, [Bk],\n                             Oc #\n                             Oc \\<up> m @\n                             Bk #\n                             Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "apply(case_tac \"(steps0 (Suc 0, [], <(m::nat) # args>) \n      ((t_wcode_prepare |+| t_wcode_main) |+| t_wcode_adjust) n)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b c.\n       \\<lbrakk>{\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n                t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n                {wadjust_stop m (bl_bin (<args>) - Suc 0)};\n        is_final\n         (steps0 (Suc 0, [], <m # args>)\n           (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) n);\n        wadjust_stop m\n         (bl_bin (<args>) -\n          Suc 0) holds_for steps0 (Suc 0, [], <m # args>)\n                            (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)\n                            n;\n        steps0 (Suc 0, [], <m # args>)\n         (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) n =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp rn.\n                            steps0 (Suc 0, [], <m # args>)\n                             (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)\n                             stp =\n                            (0, [Bk],\n                             Oc #\n                             Oc \\<up> m @\n                             Bk #\n                             Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)", "apply(rule_tac x = n in exI, auto simp: wadjust_stop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n rn.\n       \\<lbrakk>{\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n                t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n                {wadjust_stop m (bl_bin (<args>) - Suc 0)};\n        steps0 (Suc 0, [], <m # args>)\n         (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) n =\n        (0, [Bk],\n         Oc #\n         Oc \\<up> m @\n         Bk #\n         Oc #\n         Oc # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc #\n                            Oc \\<up> (bl_bin (<args>) - Suc 0) @\n                            Bk \\<up> rn =\n                            Oc \\<up> bl_bin (<args>) @ Bk \\<up> rna", "using a"], ["proof (prove)\nusing this:\n  0 < bl_bin (<args>)\n\ngoal (1 subgoal):\n 1. \\<And>n rn.\n       \\<lbrakk>{\\<lambda>(l, r). l = [] \\<and> r = <m # args>}\n                t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust\n                {wadjust_stop m (bl_bin (<args>) - Suc 0)};\n        steps0 (Suc 0, [], <m # args>)\n         (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) n =\n        (0, [Bk],\n         Oc #\n         Oc \\<up> m @\n         Bk #\n         Oc #\n         Oc # Oc \\<up> (bl_bin (<args>) - Suc 0) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc #\n                            Oc \\<up> (bl_bin (<args>) - Suc 0) @\n                            Bk \\<up> rn =\n                            Oc \\<up> bl_bin (<args>) @ Bk \\<up> rna", "apply(case_tac \"bl_bin (<args>)\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp rn.\n     steps0 (Suc 0, [], <m # args>)\n      (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust) stp =\n     (0, [Bk],\n      Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The initialization TM \\<open>t_wcode\\<close>.\n\\<close>"], ["", "definition t_wcode :: \"instr list\"\n  where\n    \"t_wcode = (t_wcode_prepare |+| t_wcode_main) |+| t_wcode_adjust        \""], ["", "text \\<open>\n  The correctness of \\<open>t_wcode\\<close>.\n\\<close>"], ["", "lemma wcode_lemma_1:\n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp ln rn. steps0 (Suc 0, [], <m # args>)  (t_wcode) stp = \n              (0,  [Bk],  Oc\\<up>(Suc m) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) t_wcode stp =\n       (0, [Bk],\n        Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "apply(simp add: wcode_lemma_pre' t_wcode_def del: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wcode_lemma: \n  \"args \\<noteq> [] \\<Longrightarrow> \n  \\<exists> stp ln rn. steps0 (Suc 0, [], <m # args>)  (t_wcode) stp = \n              (0,  [Bk],  <[m ,bl_bin (<args>)]> @ Bk\\<up>(rn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) t_wcode stp =\n       (0, [Bk], <[m, bl_bin (<args>)]> @ Bk \\<up> rn)", "using wcode_lemma_1[of args m]"], ["proof (prove)\nusing this:\n  args \\<noteq> [] \\<Longrightarrow>\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <m # args>) t_wcode stp =\n     (0, [Bk],\n      Oc \\<up> Suc m @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow>\n    \\<exists>stp ln rn.\n       steps0 (Suc 0, [], <m # args>) t_wcode stp =\n       (0, [Bk], <[m, bl_bin (<args>)]> @ Bk \\<up> rn)", "apply(simp add: t_wcode_def tape_of_list_def tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>The universal TM\\<close>"], ["", "text \\<open>\n  This section gives the explicit construction of {\\em Universal Turing Machine}, defined as \\<open>UTM\\<close> and proves its \n  correctness. It is pretty easy by composing the partial results we have got so far.\n\\<close>"], ["", "definition UTM :: \"instr list\"\n  where\n    \"UTM = (let (aprog, rs_pos, a_md) = rec_ci rec_F in \n          let abc_F = aprog [+] dummy_abc (Suc (Suc 0)) in \n          (t_wcode |+| (tm_of abc_F @ shift (mopup (Suc (Suc 0))) (length (tm_of abc_F) div 2))))\""], ["", "definition F_aprog :: \"abc_prog\"\n  where\n    \"F_aprog \\<equiv> (let (aprog, rs_pos, a_md) = rec_ci rec_F in \n                       aprog [+] dummy_abc (Suc (Suc 0)))\""], ["", "definition F_tprog :: \"instr list\"\n  where\n    \"F_tprog = tm_of (F_aprog)\""], ["", "definition t_utm :: \"instr list\"\n  where\n    \"t_utm \\<equiv>\n     F_tprog @ shift (mopup (Suc (Suc 0))) (length F_tprog div 2)\""], ["", "definition UTM_pre :: \"instr list\"\n  where\n    \"UTM_pre = t_wcode |+| t_utm\""], ["", "lemma tinres_step1: \n  assumes \"tinres l l'\" \"step (ss, l, r) (t, 0) = (sa, la, ra)\" \n    \"step (ss, l', r) (t, 0) = (sb, lb, rb)\"\n  shows \"tinres la lb \\<and> ra = rb \\<and> sa = sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "proof(cases \"r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = [] \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\n 2. \\<And>a list.\n       r = a # list \\<Longrightarrow>\n       tinres la lb \\<and> ra = rb \\<and> sa = sb", "case Nil"], ["proof (state)\nthis:\n  r = []\n\ngoal (2 subgoals):\n 1. r = [] \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\n 2. \\<And>a list.\n       r = a # list \\<Longrightarrow>\n       tinres la lb \\<and> ra = rb \\<and> sa = sb", "then"], ["proof (chain)\npicking this:\n  r = []", "show ?thesis"], ["proof (prove)\nusing this:\n  r = []\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "using assms"], ["proof (prove)\nusing this:\n  r = []\n  tinres l l'\n  step0 (ss, l, r) t = (sa, la, ra)\n  step0 (ss, l', r) t = (sb, lb, rb)\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "by (cases \"(fetch t ss Bk)\";cases \"fst (fetch t ss Bk)\";auto simp:step.simps split:if_splits)"], ["proof (state)\nthis:\n  tinres la lb \\<and> ra = rb \\<and> sa = sb\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       r = a # list \\<Longrightarrow>\n       tinres la lb \\<and> ra = rb \\<and> sa = sb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       r = a # list \\<Longrightarrow>\n       tinres la lb \\<and> ra = rb \\<and> sa = sb", "case (Cons a list)"], ["proof (state)\nthis:\n  r = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       r = a # list \\<Longrightarrow>\n       tinres la lb \\<and> ra = rb \\<and> sa = sb", "then"], ["proof (chain)\npicking this:\n  r = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  r = a # list\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "using assms"], ["proof (prove)\nusing this:\n  r = a # list\n  tinres l l'\n  step0 (ss, l, r) t = (sa, la, ra)\n  step0 (ss, l', r) t = (sb, lb, rb)\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "by (cases \"(fetch t ss a)\";cases \"fst (fetch t ss a)\";auto simp:step.simps split:if_splits)"], ["proof (state)\nthis:\n  tinres la lb \\<and> ra = rb \\<and> sa = sb\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tinres_steps1: \n  \"\\<lbrakk>tinres l l'; steps (ss, l, r) (t, 0) stp = (sa, la, ra); \n                 steps (ss, l', r) (t, 0) stp = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tinres l l'; steps0 (ss, l, r) t stp = (sa, la, ra);\n     steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "proof (induct stp arbitrary: sa la ra sb lb rb)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sa la ra sb lb rb.\n       \\<lbrakk>tinres l l'; steps0 (ss, l, r) t 0 = (sa, la, ra);\n        steps0 (ss, l', r) t 0 = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\n 2. \\<And>stp sa la ra sb lb rb.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>tinres l l';\n                    steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l'; steps0 (ss, l, r) t (Suc stp) = (sa, la, ra);\n        steps0 (ss, l', r) t (Suc stp) = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "case (Suc stp)"], ["proof (state)\nthis:\n  \\<lbrakk>tinres l l'; steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l', r) t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> tinres ?la ?lb \\<and> ?ra = ?rb \\<and> ?sa = ?sb\n  tinres l l'\n  steps0 (ss, l, r) t (Suc stp) = (sa, la, ra)\n  steps0 (ss, l', r) t (Suc stp) = (sb, lb, rb)\n\ngoal (2 subgoals):\n 1. \\<And>sa la ra sb lb rb.\n       \\<lbrakk>tinres l l'; steps0 (ss, l, r) t 0 = (sa, la, ra);\n        steps0 (ss, l', r) t 0 = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\n 2. \\<And>stp sa la ra sb lb rb.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>tinres l l';\n                    steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l'; steps0 (ss, l, r) t (Suc stp) = (sa, la, ra);\n        steps0 (ss, l', r) t (Suc stp) = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tinres l l'; steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l', r) t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> tinres ?la ?lb \\<and> ?ra = ?rb \\<and> ?sa = ?sb\n  tinres l l'\n  steps0 (ss, l, r) t (Suc stp) = (sa, la, ra)\n  steps0 (ss, l', r) t (Suc stp) = (sb, lb, rb)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>tinres l l'; steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l', r) t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> tinres ?la ?lb \\<and> ?ra = ?rb \\<and> ?sa = ?sb\n  tinres l l'\n  steps0 (ss, l, r) t (Suc stp) = (sa, la, ra)\n  steps0 (ss, l', r) t (Suc stp) = (sb, lb, rb)\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>sa la ra sb lb rb.\n                \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                 steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n                \\<Longrightarrow> tinres la lb \\<and>\n                                  ra = rb \\<and> sa = sb;\n     tinres l l'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n     step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb)\\<rbrakk>\n    \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "apply(case_tac \"(steps (ss, l, r) (t, 0) stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n        step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stp = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "apply(case_tac \"(steps (ss, l', r) (t, 0) stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n        step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stp = (a, b, c);\n        steps0 (ss, l', r) t stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stp = (sa, la, ra);\n                    steps0 (ss, l', r) t stp = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l'; step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra);\n        step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb);\n        steps0 (ss, l, r) t stp = (a, b, c);\n        steps0 (ss, l', r) t stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "fix stp sa la ra sb lb rb a b c aa ba ca"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stpa__ = (sa, la, ra);\n                    steps0 (ss, l', r) t stpa__ = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l';\n        step0 (steps0 (ss, l, r) t stpa__) t = (saa__, laa__, raa__);\n        step0 (steps0 (ss, l', r) t stpa__) t = (sba__, lba__, rba__);\n        steps0 (ss, l, r) t stpa__ = (a, b, c);\n        steps0 (ss, l', r) t stpa__ = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres laa__ lba__ \\<and>\n                         raa__ = rba__ \\<and> saa__ = sba__", "assume ind: \"\\<And>sa la ra sb lb rb. \\<lbrakk>steps (ss, l, r) (t, 0) stp = (sa, (la::cell list), ra); \n          steps (ss, l', r) (t, 0) stp = (sb, lb, rb)\\<rbrakk> \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb\"\n      and h: \" tinres l l'\" \"step (steps (ss, l, r) (t, 0) stp) (t, 0) = (sa, la, ra)\"\n      \"step (steps (ss, l', r) (t, 0) stp) (t, 0) = (sb, lb, rb)\" \"steps (ss, l, r) (t, 0) stp = (a, b, c)\" \n      \"steps (ss, l', r) (t, 0) stp = (aa, ba, ca)\""], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l', r) t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> tinres ?la ?lb \\<and> ?ra = ?rb \\<and> ?sa = ?sb\n  tinres l l'\n  step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra)\n  step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb)\n  steps0 (ss, l, r) t stp = (a, b, c)\n  steps0 (ss, l', r) t stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stpa__ = (sa, la, ra);\n                    steps0 (ss, l', r) t stpa__ = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l';\n        step0 (steps0 (ss, l, r) t stpa__) t = (saa__, laa__, raa__);\n        step0 (steps0 (ss, l', r) t stpa__) t = (sba__, lba__, rba__);\n        steps0 (ss, l, r) t stpa__ = (a, b, c);\n        steps0 (ss, l', r) t stpa__ = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres laa__ lba__ \\<and>\n                         raa__ = rba__ \\<and> saa__ = sba__", "have \"tinres b ba \\<and> c = ca \\<and> a = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres b ba \\<and> c = ca \\<and> a = aa", "using ind h"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps0 (ss, l, r) t stp = (?sa, ?la, ?ra);\n   steps0 (ss, l', r) t stp = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> tinres ?la ?lb \\<and> ?ra = ?rb \\<and> ?sa = ?sb\n  tinres l l'\n  step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra)\n  step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb)\n  steps0 (ss, l, r) t stp = (a, b, c)\n  steps0 (ss, l', r) t stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. tinres b ba \\<and> c = ca \\<and> a = aa", "by metis"], ["proof (state)\nthis:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>\\<And>sa la ra sb lb rb.\n                   \\<lbrakk>steps0 (ss, l, r) t stpa__ = (sa, la, ra);\n                    steps0 (ss, l', r) t stpa__ = (sb, lb, rb)\\<rbrakk>\n                   \\<Longrightarrow> tinres la lb \\<and>\n                                     ra = rb \\<and> sa = sb;\n        tinres l l';\n        step0 (steps0 (ss, l, r) t stpa__) t = (saa__, laa__, raa__);\n        step0 (steps0 (ss, l', r) t stpa__) t = (sba__, lba__, rba__);\n        steps0 (ss, l, r) t stpa__ = (a, b, c);\n        steps0 (ss, l', r) t stpa__ = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres laa__ lba__ \\<and>\n                         raa__ = rba__ \\<and> saa__ = sba__", "thus \"tinres la lb \\<and> ra = rb \\<and> sa = sb\""], ["proof (prove)\nusing this:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "using tinres_step1 h"], ["proof (prove)\nusing this:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n  \\<lbrakk>tinres ?l ?l'; step0 (?ss, ?l, ?r) ?t = (?sa, ?la, ?ra);\n   step0 (?ss, ?l', ?r) ?t = (?sb, ?lb, ?rb)\\<rbrakk>\n  \\<Longrightarrow> tinres ?la ?lb \\<and> ?ra = ?rb \\<and> ?sa = ?sb\n  tinres l l'\n  step0 (steps0 (ss, l, r) t stp) t = (sa, la, ra)\n  step0 (steps0 (ss, l', r) t stp) t = (sb, lb, rb)\n  steps0 (ss, l, r) t stp = (a, b, c)\n  steps0 (ss, l', r) t stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. tinres la lb \\<and> ra = rb \\<and> sa = sb", "by metis"], ["proof (state)\nthis:\n  tinres la lb \\<and> ra = rb \\<and> sa = sb\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tinres la lb \\<and> ra = rb \\<and> sa = sb\n\ngoal (1 subgoal):\n 1. \\<And>sa la ra sb lb rb.\n       \\<lbrakk>tinres l l'; steps0 (ss, l, r) t 0 = (sa, la, ra);\n        steps0 (ss, l', r) t 0 = (sb, lb, rb)\\<rbrakk>\n       \\<Longrightarrow> tinres la lb \\<and> ra = rb \\<and> sa = sb", "qed (simp add: steps.simps)"], ["", "lemma tinres_some_exp[simp]: \n  \"tinres (Bk \\<up> m @ [Bk, Bk]) la \\<Longrightarrow> \\<exists>m. la = Bk \\<up> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres (Bk \\<up> m @ [Bk, Bk]) la \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "unfolding tinres_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "let ?c1 = \"\\<lambda> n. Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "let ?c2 = \"\\<lambda> n. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "assume \"\\<exists>n. ?c1 n \\<or> ?c2 n\""], ["proof (state)\nthis:\n  \\<exists>n.\n     Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n     la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "then"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n     la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n", "obtain n where \"?c1 n \\<or> ?c2 n\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n     la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n        la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n  la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "then"], ["proof (chain)\npicking this:\n  Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n  la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n", "consider \"?c1 n\" | \"?c2 n\""], ["proof (prove)\nusing this:\n  Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n  la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n             thesis;\n     la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n           ?thesis;\n   la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<or>\n       la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n           ?thesis;\n   la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>m. la = Bk \\<up> m", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m\n 2. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "case 1"], ["proof (state)\nthis:\n  Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n\n\ngoal (2 subgoals):\n 1. Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m\n 2. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "hence \"Bk \\<up> Suc (Suc m) = la @ Bk \\<up> n\""], ["proof (prove)\nusing this:\n  Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. Bk \\<up> Suc (Suc m) = la @ Bk \\<up> n", "by (metis exp_ind append_Cons append_eq_append_conv2 self_append_conv2)"], ["proof (state)\nthis:\n  Bk \\<up> Suc (Suc m) = la @ Bk \\<up> n\n\ngoal (2 subgoals):\n 1. Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m\n 2. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "hence \"la = Bk \\<up> (Suc (Suc m) - n)\""], ["proof (prove)\nusing this:\n  Bk \\<up> Suc (Suc m) = la @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. la = Bk \\<up> (Suc (Suc m) - n)", "by (metis replicate_add append_eq_append_conv diff_add_inverse2 length_append length_replicate)"], ["proof (state)\nthis:\n  la = Bk \\<up> (Suc (Suc m) - n)\n\ngoal (2 subgoals):\n 1. Bk \\<up> m @ [Bk, Bk] = la @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m\n 2. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "then"], ["proof (chain)\npicking this:\n  la = Bk \\<up> (Suc (Suc m) - n)", "show ?thesis"], ["proof (prove)\nusing this:\n  la = Bk \\<up> (Suc (Suc m) - n)\n\ngoal (1 subgoal):\n 1. \\<exists>m. la = Bk \\<up> m", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. la = Bk \\<up> m\n\ngoal (1 subgoal):\n 1. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "case 2"], ["proof (state)\nthis:\n  la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "hence \"la = Bk \\<up> (m + Suc (Suc n))\""], ["proof (prove)\nusing this:\n  la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. la = Bk \\<up> (m + Suc (Suc n))", "by (metis append_Cons append_eq_append_conv2 replicate_Suc replicate_add self_append_conv2)"], ["proof (state)\nthis:\n  la = Bk \\<up> (m + Suc (Suc n))\n\ngoal (1 subgoal):\n 1. la = (Bk \\<up> m @ [Bk, Bk]) @ Bk \\<up> n \\<Longrightarrow>\n    \\<exists>m. la = Bk \\<up> m", "then"], ["proof (chain)\npicking this:\n  la = Bk \\<up> (m + Suc (Suc n))", "show ?thesis"], ["proof (prove)\nusing this:\n  la = Bk \\<up> (m + Suc (Suc n))\n\ngoal (1 subgoal):\n 1. \\<exists>m. la = Bk \\<up> m", "by blast"], ["proof (state)\nthis:\n  \\<exists>m. la = Bk \\<up> m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m. la = Bk \\<up> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma t_utm_halt_eq: \n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and exec: \"steps0 (Suc 0, Bk\\<up>(l), <lm::nat list>) tp stp = (0, Bk\\<up>(m), Oc\\<up>(rs)@Bk\\<up>(n))\"\n    and resutl: \"0 < rs\"\n  shows \"\\<exists>stp m n. steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>(i)) t_utm stp = \n                                                (0, Bk\\<up>(m), Oc\\<up>(rs) @ Bk\\<up>(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "obtain ap arity fp where a: \"rec_ci rec_F = (ap, arity, fp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ap arity fp.\n        rec_ci rec_F = (ap, arity, fp) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  rec_ci rec_F = (ap, arity, fp)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "moreover"], ["proof (state)\nthis:\n  rec_ci rec_F = (ap, arity, fp)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "have b: \"rec_exec rec_F [code tp, (bl2wc (<lm>))] = (rs - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "using assms"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  0 < rs\n\ngoal (1 subgoal):\n 1. rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0", "apply(rule_tac F_correct, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "have \"\\<exists> stp m l. steps0 (Suc 0, Bk # Bk # [], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>i)\n    (F_tprog @ shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2)) stp\n    = (0, Bk\\<up>m @ Bk # Bk # [], Oc\\<up>Suc (rec_exec rec_F [code tp, (bl2wc (<lm>))]) @ Bk\\<up>l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m l.\n       steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @\n         shift (mopup (length [code tp, bl2wc (<lm>)]))\n          (length F_tprog div 2))\n        stp =\n       (0, Bk \\<up> m @ [Bk, Bk],\n        Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)", "proof(rule_tac recursive_compile_to_tm_correct1)"], ["proof (state)\ngoal (3 subgoals):\n 1. rec_ci rec_F = (?ap, ?ary, ?fp)\n 2. terminate rec_F [code tp, bl2wc (<lm>)]\n 3. F_tprog = tm_of (?ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "show \"rec_ci rec_F = (ap, arity, fp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_ci rec_F = (ap, arity, fp)", "using a"], ["proof (prove)\nusing this:\n  rec_ci rec_F = (ap, arity, fp)\n\ngoal (1 subgoal):\n 1. rec_ci rec_F = (ap, arity, fp)", "by simp"], ["proof (state)\nthis:\n  rec_ci rec_F = (ap, arity, fp)\n\ngoal (2 subgoals):\n 1. terminate rec_F [code tp, bl2wc (<lm>)]\n 2. F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. terminate rec_F [code tp, bl2wc (<lm>)]\n 2. F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "show \"terminate rec_F [code tp, bl2wc (<lm>)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_F [code tp, bl2wc (<lm>)]", "using assms"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  0 < rs\n\ngoal (1 subgoal):\n 1. terminate rec_F [code tp, bl2wc (<lm>)]", "by(rule_tac terminate_F, simp_all)"], ["proof (state)\nthis:\n  terminate rec_F [code tp, bl2wc (<lm>)]\n\ngoal (1 subgoal):\n 1. F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "show \"F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "using a"], ["proof (prove)\nusing this:\n  rec_ci rec_F = (ap, arity, fp)\n\ngoal (1 subgoal):\n 1. F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))", "apply(simp add: F_tprog_def F_aprog_def numeral_2_eq_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  F_tprog = tm_of (ap [+] dummy_abc (length [code tp, bl2wc (<lm>)]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp m l.\n     steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @\n       shift (mopup (length [code tp, bl2wc (<lm>)]))\n        (length F_tprog div 2))\n      stp =\n     (0, Bk \\<up> m @ [Bk, Bk],\n      Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp m l.\n     steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @\n       shift (mopup (length [code tp, bl2wc (<lm>)]))\n        (length F_tprog div 2))\n      stp =\n     (0, Bk \\<up> m @ [Bk, Bk],\n      Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)", "obtain stp m l where \n    \"steps0 (Suc 0, Bk # Bk # [], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>i)\n    (F_tprog @ shift (mopup (length [code tp, (bl2wc (<lm>))])) (length F_tprog div 2)) stp\n    = (0, Bk\\<up>m @ Bk # Bk # [], Oc\\<up>Suc (rec_exec rec_F [code tp, (bl2wc (<lm>))]) @ Bk\\<up>l)\""], ["proof (prove)\nusing this:\n  \\<exists>stp m l.\n     steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @\n       shift (mopup (length [code tp, bl2wc (<lm>)]))\n        (length F_tprog div 2))\n      stp =\n     (0, Bk \\<up> m @ [Bk, Bk],\n      Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. (\\<And>stp m l.\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n         (F_tprog @\n          shift (mopup (length [code tp, bl2wc (<lm>)]))\n           (length F_tprog div 2))\n         stp =\n        (0, Bk \\<up> m @ [Bk, Bk],\n         Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n         Bk \\<up> l) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "hence \"\\<exists> m. steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>i)\n    (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp\n    = (0, Bk\\<up>m, Oc\\<up>Suc (rs - 1) @ Bk\\<up>l)\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n     (F_tprog @\n      shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n     stp =\n    (0, Bk \\<up> m @ [Bk, Bk],\n     Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n     Bk \\<up> l) \\<Longrightarrow>\n    \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "assume g: \"steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @ shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2)) stp =\n      (0, Bk \\<up> m @ [Bk, Bk], Oc \\<up> Suc ((rec_exec rec_F [code tp, bl2wc (<lm>)])) @ Bk \\<up> l)\""], ["proof (state)\nthis:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n     (F_tprog @\n      shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n     stp =\n    (0, Bk \\<up> m @ [Bk, Bk],\n     Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n     Bk \\<up> l) \\<Longrightarrow>\n    \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "moreover"], ["proof (state)\nthis:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n     (F_tprog @\n      shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n     stp =\n    (0, Bk \\<up> m @ [Bk, Bk],\n     Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n     Bk \\<up> l) \\<Longrightarrow>\n    \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "have \"tinres [Bk, Bk] [Bk]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres [Bk, Bk] [Bk]", "apply(auto simp: tinres_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tinres [Bk, Bk] [Bk]\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n     (F_tprog @\n      shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n     stp =\n    (0, Bk \\<up> m @ [Bk, Bk],\n     Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n     Bk \\<up> l) \\<Longrightarrow>\n    \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "moreover"], ["proof (state)\nthis:\n  tinres [Bk, Bk] [Bk]\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n     (F_tprog @\n      shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n     stp =\n    (0, Bk \\<up> m @ [Bk, Bk],\n     Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n     Bk \\<up> l) \\<Longrightarrow>\n    \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "obtain sa la ra where \"steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>i)\n    (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp = (sa, la, ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa la ra.\n        steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n         (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n        (sa, la, ra) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(case_tac \"steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk\\<up>i)\n    (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n  (sa, la, ra)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n     (F_tprog @\n      shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n     stp =\n    (0, Bk \\<up> m @ [Bk, Bk],\n     Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @\n     Bk \\<up> l) \\<Longrightarrow>\n    \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "ultimately"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n  tinres [Bk, Bk] [Bk]\n  steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n  (sa, la, ra)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n  tinres [Bk, Bk] [Bk]\n  steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n  (sa, la, ra)\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "using b"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @\n    shift (mopup (length [code tp, bl2wc (<lm>)])) (length F_tprog div 2))\n   stp =\n  (0, Bk \\<up> m @ [Bk, Bk],\n   Oc \\<up> Suc (rec_exec rec_F [code tp, bl2wc (<lm>)]) @ Bk \\<up> l)\n  tinres [Bk, Bk] [Bk]\n  steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n   (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n  (sa, la, ra)\n  rec_exec rec_F [code tp, bl2wc (<lm>)] = rs - Suc 0\n\ngoal (1 subgoal):\n 1. \\<exists>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)", "apply(drule_tac la = \"Bk\\<up>m @ [Bk, Bk]\" in tinres_steps1, auto simp: numeral_2_eq_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>m.\n     steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n     (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m.\n     steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n     (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>m.\n     steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n      (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n     (0, Bk \\<up> m, Oc \\<up> Suc (rs - 1) @ Bk \\<up> l)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n        stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m,\n        Oc # Oc \\<up> (rs - Suc 0) @ Bk \\<up> l) \\<Longrightarrow>\n       \\<exists>stp m n.\n          steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n           stp =\n          (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(rule_tac x = stp in exI, simp add: t_utm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m,\n        Oc # Oc \\<up> (rs - Suc 0) @ Bk \\<up> l) \\<Longrightarrow>\n       \\<exists>m n.\n          steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n           (F_tprog @ shift (mopup (Suc (Suc 0))) (length F_tprog div 2))\n           stp =\n          (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "using assms"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  0 < rs\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n        (F_tprog @ shift (mopup 2) (length F_tprog div 2)) stp =\n       (0, Bk \\<up> m,\n        Oc # Oc \\<up> (rs - Suc 0) @ Bk \\<up> l) \\<Longrightarrow>\n       \\<exists>m n.\n          steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i)\n           (F_tprog @ shift (mopup (Suc (Suc 0))) (length F_tprog div 2))\n           stp =\n          (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(case_tac rs, simp_all add: numeral_2_eq_2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp m n.\n     steps0 (Suc 0, [Bk], <[code tp, bl2wc (<lm>)]> @ Bk \\<up> i) t_utm\n      stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_wf_t_wcode[intro]: \"tm_wf (t_wcode, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode", "apply(simp add: t_wcode_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 (t_wcode_prepare |+| t_wcode_main |+| t_wcode_adjust)", "apply(rule_tac tm_comp_wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tm_wf0 (t_wcode_prepare |+| t_wcode_main)\n 2. tm_wf0 t_wcode_adjust", "apply(rule_tac tm_comp_wf, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UTM_halt_lemma_pre: \n  assumes wf_tm: \"tm_wf (tp, 0)\"\n    and result: \"0 < rs\"\n    and args: \"args \\<noteq> []\"\n    and exec: \"steps0 (Suc 0, Bk\\<up>(i), <args::nat list>) tp stp = (0, Bk\\<up>(m), Oc\\<up>(rs)@Bk\\<up>(k))\"\n  shows \"\\<exists>stp m n. steps0 (Suc 0, [], <code tp # args>) UTM_pre stp = \n                                                (0, Bk\\<up>(m), Oc\\<up>(rs) @ Bk\\<up>(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "let ?Q2 = \"\\<lambda> (l, r). (\\<exists> ln rn. l = Bk\\<up>(ln) \\<and> r = Oc\\<up>(rs) @ Bk\\<up>(rn))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "let ?P1 = \"\\<lambda> (l, r). l = [] \\<and> r = <code tp # args>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "let ?Q1 = \"\\<lambda> (l, r). (l = [Bk] \\<and>\n    (\\<exists> rn. r = Oc\\<up>(Suc (code tp)) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "let ?P2 = ?Q1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "let ?P3 = \"\\<lambda> (l, r). False\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "have \"{?P1} (t_wcode |+| t_utm) {?Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode |+| t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}", "proof(rule_tac Hoare_plus_halt)"], ["proof (state)\ngoal (3 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode {?Q}\n 2. {?Q} t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}\n 3. tm_wf0 t_wcode", "show \"tm_wf (t_wcode, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode", "by auto"], ["proof (state)\nthis:\n  tm_wf0 t_wcode\n\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode {?Q}\n 2. {?Q} t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode {?Q}\n 2. {?Q} t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}", "show \"{?P1} t_wcode {?Q1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode\n    {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}", "apply(rule_tac Hoare_haltI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <code tp # args>) t_wcode n) \\<and>\n       (\\<lambda>(l, r).\n           l = [Bk] \\<and>\n           (\\<exists>rn.\n               r =\n               Oc #\n               Oc \\<up> code tp @\n               Bk #\n               Oc #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <code tp # args>)\n  t_wcode n", "using wcode_lemma_1[of args \"code tp\"] args"], ["proof (prove)\nusing this:\n  args \\<noteq> [] \\<Longrightarrow>\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <code tp # args>) t_wcode stp =\n     (0, [Bk],\n      Oc \\<up> Suc (code tp) @\n      Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <code tp # args>) t_wcode n) \\<and>\n       (\\<lambda>(l, r).\n           l = [Bk] \\<and>\n           (\\<exists>rn.\n               r =\n               Oc #\n               Oc \\<up> code tp @\n               Bk #\n               Oc #\n               Oc \\<up> bl_bin (<args>) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <code tp # args>)\n  t_wcode n", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp rn.\n       \\<lbrakk>args \\<noteq> [];\n        steps0 (Suc 0, [], <code tp # args>) t_wcode stp =\n        (0, [Bk],\n         Oc #\n         Oc \\<up> code tp @\n         Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <code tp # args>) t_wcode\n                               n) \\<and>\n                            (\\<lambda>(l, r).\n                                l = [Bk] \\<and>\n                                (\\<exists>rn.\n                                    r =\n                                    Oc #\n                                    Oc \\<up> code tp @\n                                    Bk #\n                                    Oc #\n                                    Oc \\<up> bl_bin (<args>) @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, [], <code tp # args>) t_wcode n", "by (metis (mono_tags, lifting) holds_for.simps is_finalI old.prod.case)"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode\n  {\\<lambda>(l, r).\n      l = [Bk] \\<and>\n      (\\<exists>rn.\n          r =\n          Oc \\<up> Suc (code tp) @\n          Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}", "show \"{?P2} t_utm {?Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        \\<exists>ln rn.\n           l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}", "proof(rule_tac Hoare_haltI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, [Bk],\n              Oc #\n              Oc \\<up> code tp @\n              Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n             t_utm n) \\<and>\n          (\\<lambda>(l, r).\n              (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n              (\\<exists>rn.\n                  r =\n                  Oc \\<up> rs @\n                  Bk \\<up> rn)) holds_for steps0\n     (Suc 0, [Bk],\n      Oc #\n      Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n     t_utm n", "fix rn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, [Bk],\n              Oc #\n              Oc \\<up> code tp @\n              Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n             t_utm n) \\<and>\n          (\\<lambda>(l, r).\n              (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n              (\\<exists>rn.\n                  r =\n                  Oc \\<up> rs @\n                  Bk \\<up> rn)) holds_for steps0\n     (Suc 0, [Bk],\n      Oc #\n      Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n     t_utm n", "show \"\\<exists>n. is_final (steps0 (Suc 0, [Bk], Oc # Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn) t_utm n) \\<and>\n        (\\<lambda>(l, r). (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n        (\\<exists>rn. r = Oc \\<up> rs @ Bk \\<up> rn)) holds_for steps0 (Suc 0, [Bk],\n        Oc # Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn) t_utm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc #\n           Oc \\<up> code tp @\n           Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n          t_utm n) \\<and>\n       (\\<lambda>(l, r).\n           (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n           (\\<exists>rn.\n               r =\n               Oc \\<up> rs @\n               Bk \\<up> rn)) holds_for steps0\n  (Suc 0, [Bk],\n   Oc # Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n  t_utm n", "using t_utm_halt_eq[of tp i \"args\" stp m rs k rn] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>tm_wf0 tp;\n   steps0 (Suc 0, Bk \\<up> i, <args>) tp stp =\n   (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k);\n   0 < rs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp m n.\n                       steps0\n                        (Suc 0, [Bk],\n                         <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n                        t_utm stp =\n                       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n  args \\<noteq> []\n  steps0 (Suc 0, Bk \\<up> i, <args>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc #\n           Oc \\<up> code tp @\n           Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n          t_utm n) \\<and>\n       (\\<lambda>(l, r).\n           (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n           (\\<exists>rn.\n               r =\n               Oc \\<up> rs @\n               Bk \\<up> rn)) holds_for steps0\n  (Suc 0, [Bk],\n   Oc # Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n  t_utm n", "apply(auto simp: bin_wc_eq tape_of_list_def tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpa ma n.\n       \\<lbrakk>tm_wf0 tp; 0 < rs; args \\<noteq> [];\n        steps0 (Suc 0, Bk \\<up> i, tape_of_nat_list args) tp stp =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k);\n        steps0\n         (Suc 0, [Bk],\n          Oc #\n          Oc \\<up> code tp @\n          Bk # Oc # Oc \\<up> bl2wc (tape_of_nat_list args) @ Bk \\<up> rn)\n         t_utm stpa =\n        (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0\n                               (Suc 0, [Bk],\n                                Oc #\n                                Oc \\<up> code tp @\n                                Bk #\n                                Oc #\n                                Oc \\<up> bl2wc (tape_of_nat_list args) @\n                                Bk \\<up> rn)\n                               t_utm n) \\<and>\n                            (\\<lambda>(l, r).\n                                (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n                                (\\<exists>rn.\n                                    r =\n                                    Oc \\<up> rs @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, [Bk],\n                        Oc #\n                        Oc \\<up> code tp @\n                        Bk #\n                        Oc #\n                        Oc \\<up> bl2wc (tape_of_nat_list args) @\n                        Bk \\<up> rn)\n                       t_utm n", "apply(rename_tac stpa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpa ma stpaa.\n       \\<lbrakk>tm_wf0 tp; 0 < rs; args \\<noteq> [];\n        steps0 (Suc 0, Bk \\<up> i, tape_of_nat_list args) tp stp =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k);\n        steps0\n         (Suc 0, [Bk],\n          Oc #\n          Oc \\<up> code tp @\n          Bk # Oc # Oc \\<up> bl2wc (tape_of_nat_list args) @ Bk \\<up> rn)\n         t_utm stpa =\n        (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> stpaa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0\n                               (Suc 0, [Bk],\n                                Oc #\n                                Oc \\<up> code tp @\n                                Bk #\n                                Oc #\n                                Oc \\<up> bl2wc (tape_of_nat_list args) @\n                                Bk \\<up> rn)\n                               t_utm n) \\<and>\n                            (\\<lambda>(l, r).\n                                (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n                                (\\<exists>rn.\n                                    r =\n                                    Oc \\<up> rs @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, [Bk],\n                        Oc #\n                        Oc \\<up> code tp @\n                        Bk #\n                        Oc #\n                        Oc \\<up> bl2wc (tape_of_nat_list args) @\n                        Bk \\<up> rn)\n                       t_utm n", "apply(rule_tac x = stpa in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final\n      (steps0\n        (Suc 0, [Bk],\n         Oc #\n         Oc \\<up> code tp @\n         Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\n        t_utm n) \\<and>\n     (\\<lambda>(l, r).\n         (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n         (\\<exists>rn.\n             r =\n             Oc \\<up> rs @\n             Bk \\<up> rn)) holds_for steps0\n(Suc 0, [Bk],\n Oc # Oc \\<up> code tp @ Bk # Oc # Oc \\<up> bl_bin (<args>) @ Bk \\<up> rn)\nt_utm n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r).\n      l = [Bk] \\<and>\n      (\\<exists>rn.\n          r =\n          Oc \\<up> Suc (code tp) @\n          Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n  t_utm\n  {\\<lambda>(l, r).\n      \\<exists>ln rn. l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode |+| t_utm\n  {\\<lambda>(l, r).\n      \\<exists>ln rn. l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode |+| t_utm\n  {\\<lambda>(l, r).\n      \\<exists>ln rn. l = Bk \\<up> ln \\<and> r = Oc \\<up> rs @ Bk \\<up> rn}\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(auto simp: Hoare_halt_def UTM_pre_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>is_final\n                 (steps0 (Suc 0, [], <code tp # args>) (t_wcode |+| t_utm)\n                   n);\n        (\\<lambda>(l, r).\n            (\\<exists>ln. l = Bk \\<up> ln) \\<and>\n            (\\<exists>rn.\n                r =\n                Oc \\<up> rs @\n                Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <code tp # args>)\n   (t_wcode |+| t_utm) n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp m n.\n                            steps0 (Suc 0, [], <code tp # args>)\n                             (t_wcode |+| t_utm) stp =\n                            (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(case_tac \"steps0 (Suc 0, [], <code tp # args>) (t_wcode |+| t_utm) n\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b c.\n       \\<lbrakk>a = 0;\n        (\\<exists>ln. b = Bk \\<up> ln) \\<and>\n        (\\<exists>rn. c = Oc \\<up> rs @ Bk \\<up> rn);\n        steps0 (Suc 0, [], <code tp # args>) (t_wcode |+| t_utm) n =\n        (0, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp m n.\n                            steps0 (Suc 0, [], <code tp # args>)\n                             (t_wcode |+| t_utm) stp =\n                            (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>stp m n.\n     steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>UTM\\<close>, the halt case.\n\\<close>"], ["", "lemma UTM_halt_lemma': \n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and result: \"0 < rs\"\n    and args: \"args \\<noteq> []\"\n    and exec: \"steps0 (Suc 0, Bk\\<up>(i), <args::nat list>) tp stp = (0, Bk\\<up>(m), Oc\\<up>(rs)@Bk\\<up>(k))\"\n  shows \"\\<exists>stp m n. steps0 (Suc 0, [], <code tp # args>) UTM stp = \n                                                (0, Bk\\<up>(m), Oc\\<up>(rs) @ Bk\\<up>(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "using UTM_halt_lemma_pre[of tp rs args i stp m k] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>tm_wf0 tp; 0 < rs; args \\<noteq> [];\n   steps0 (Suc 0, Bk \\<up> i, <args>) tp stp =\n   (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp m n.\n                       steps0 (Suc 0, [], <code tp # args>) UTM_pre stp =\n                       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 tp\n  0 < rs\n  args \\<noteq> []\n  steps0 (Suc 0, Bk \\<up> i, <args>) tp stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>stp m n.\n       steps0 (Suc 0, [], <code tp # args>) UTM stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(simp add: UTM_pre_def t_utm_def UTM_def F_aprog_def F_tprog_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>stp m n.\n                steps0 (Suc 0, [], <code tp # args>)\n                 (t_wcode |+| tm_of\n                               (case rec_ci rec_F of\n                                (aprog, rs_pos, a_md) \\<Rightarrow>\n                                  aprog [+] dummy_abc (Suc (Suc 0))) @\n                              shift (mopup (Suc (Suc 0)))\n                               (length\n                                 (tm_of\n                                   (case rec_ci rec_F of\n                                    (aprog, rs_pos, a_md) \\<Rightarrow>\naprog [+] dummy_abc (Suc (Suc 0)))) div\n                                2))\n                 stp =\n                (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n);\n     tm_wf0 tp; 0 < rs; args \\<noteq> [];\n     steps0 (Suc 0, Bk \\<up> i, <args>) tp stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp m n.\n                         steps0 (Suc 0, [], <code tp # args>)\n                          (case rec_ci rec_F of\n                           (aprog, rs_pos, a_md) \\<Rightarrow>\n                             t_wcode |+| tm_of\n    (aprog [+] dummy_abc (Suc (Suc 0))) @\n   shift (mopup (Suc (Suc 0)))\n    (length (tm_of (aprog [+] dummy_abc (Suc (Suc 0)))) div 2))\n                          stp =\n                         (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)", "apply(case_tac \"rec_ci rec_F\", simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition TSTD:: \"config \\<Rightarrow> bool\"\n  where\n    \"TSTD c = (let (st, l, r) = c in \n             st = 0 \\<and> (\\<exists> m. l = Bk\\<up>(m)) \\<and> (\\<exists> rs n. r = Oc\\<up>(Suc rs) @ Bk\\<up>(n)))\""], ["", "lemma nstd_case1: \"0 < a \\<Longrightarrow> NSTD (trpl_code (a, b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<Longrightarrow> NSTD (trpl_code (a, b, c))", "by(simp add: NSTD.simps trpl_code.simps)"], ["", "lemma nonzero_bl2wc[simp]: \"\\<forall>m. b \\<noteq> Bk\\<up>(m) \\<Longrightarrow> 0 < bl2wc b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> 0 < bl2wc b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> 0 < bl2wc b", "have \"\\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> bl2wc b = 0 \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m; bl2wc b = 0\\<rbrakk>\n    \\<Longrightarrow> False", "proof(induct b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>m. [] \\<noteq> Bk \\<up> m; bl2wc [] = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m;\n                 bl2wc b = 0\\<rbrakk>\n                \\<Longrightarrow> False;\n        \\<forall>m. a # b \\<noteq> Bk \\<up> m; bl2wc (a # b) = 0\\<rbrakk>\n       \\<Longrightarrow> False", "case (Cons a b)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m; bl2wc b = 0\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<forall>m. a # b \\<noteq> Bk \\<up> m\n  bl2wc (a # b) = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>m. [] \\<noteq> Bk \\<up> m; bl2wc [] = 0\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>\\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m;\n                 bl2wc b = 0\\<rbrakk>\n                \\<Longrightarrow> False;\n        \\<forall>m. a # b \\<noteq> Bk \\<up> m; bl2wc (a # b) = 0\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m; bl2wc b = 0\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<forall>m. a # b \\<noteq> Bk \\<up> m\n  bl2wc (a # b) = 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m; bl2wc b = 0\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<forall>m. a # b \\<noteq> Bk \\<up> m\n  bl2wc (a # b) = 0\n\ngoal (1 subgoal):\n 1. False", "apply(simp add: bl2wc.simps, case_tac a, simp_all \n          add: bl2nat.simps bl2nat_double)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n     \\<forall>m. Bk # b \\<noteq> Bk \\<up> m; bl2nat b 0 = 0;\n     \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False; bl2wc b = 0;\n     a = Bk;\n     \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> False", "apply(case_tac \"\\<exists> m. b = Bk\\<up>(m)\", erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n        \\<forall>m. Bk # b \\<noteq> Bk \\<up> m; bl2nat b 0 = 0;\n        \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n        bl2wc b = 0; a = Bk;\n        \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n        b = Bk \\<up> m\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n     \\<forall>m. Bk # b \\<noteq> Bk \\<up> m; bl2nat b 0 = 0;\n     \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False; bl2wc b = 0;\n     a = Bk; \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n     \\<nexists>m. b = Bk \\<up> m\\<rbrakk>\n    \\<Longrightarrow> False", "apply(metis append_Nil2 replicate_Suc_iff_anywhere)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n     \\<forall>m. Bk # b \\<noteq> Bk \\<up> m; bl2nat b 0 = 0;\n     \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False; bl2wc b = 0;\n     a = Bk; \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> False;\n     \\<nexists>m. b = Bk \\<up> m\\<rbrakk>\n    \\<Longrightarrow> False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>m. [] \\<noteq> Bk \\<up> m; bl2wc [] = 0\\<rbrakk>\n    \\<Longrightarrow> False", "qed auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m; bl2wc b = 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> 0 < bl2wc b", "thus \"\\<forall>m. b \\<noteq> Bk\\<up>(m) \\<Longrightarrow> 0 < bl2wc b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>m. b \\<noteq> Bk \\<up> m; bl2wc b = 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> 0 < bl2wc b", "by auto"], ["proof (state)\nthis:\n  \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow> 0 < bl2wc b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nstd_case2: \"\\<forall>m. b \\<noteq> Bk\\<up>(m) \\<Longrightarrow> NSTD (trpl_code (a, b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. b \\<noteq> Bk \\<up> m \\<Longrightarrow>\n    NSTD (trpl_code (a, b, c))", "apply(simp add: NSTD.simps trpl_code.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma even_not_odd[elim]: \"Suc (2 * x) = 2 * y \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (2 * x) = 2 * y \\<Longrightarrow> RR", "proof(induct x arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. Suc (2 * 0) = 2 * y \\<Longrightarrow> RR\n 2. \\<And>x y.\n       \\<lbrakk>\\<And>y. Suc (2 * x) = 2 * y \\<Longrightarrow> RR;\n        Suc (2 * Suc x) = 2 * y\\<rbrakk>\n       \\<Longrightarrow> RR", "case (Suc x)"], ["proof (state)\nthis:\n  Suc (2 * x) = 2 * ?y \\<Longrightarrow> RR\n  Suc (2 * Suc x) = 2 * y\n\ngoal (2 subgoals):\n 1. \\<And>y. Suc (2 * 0) = 2 * y \\<Longrightarrow> RR\n 2. \\<And>x y.\n       \\<lbrakk>\\<And>y. Suc (2 * x) = 2 * y \\<Longrightarrow> RR;\n        Suc (2 * Suc x) = 2 * y\\<rbrakk>\n       \\<Longrightarrow> RR", "thus ?case"], ["proof (prove)\nusing this:\n  Suc (2 * x) = 2 * ?y \\<Longrightarrow> RR\n  Suc (2 * Suc x) = 2 * y\n\ngoal (1 subgoal):\n 1. RR", "by(cases y;auto)"], ["proof (state)\nthis:\n  RR\n\ngoal (1 subgoal):\n 1. \\<And>y. Suc (2 * 0) = 2 * y \\<Longrightarrow> RR", "qed auto"], ["", "declare replicate_Suc[simp del]"], ["", "lemma bl2nat_zero_eq[simp]: \"(bl2nat c 0 = 0) = (\\<exists>n. c = Bk\\<up>(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bl2nat c 0 = 0) = (\\<exists>n. c = Bk \\<up> n)", "proof(induct c)"], ["proof (state)\ngoal (2 subgoals):\n 1. (bl2nat [] 0 = 0) = (\\<exists>n. [] = Bk \\<up> n)\n 2. \\<And>a c.\n       (bl2nat c 0 = 0) = (\\<exists>n. c = Bk \\<up> n) \\<Longrightarrow>\n       (bl2nat (a # c) 0 = 0) = (\\<exists>n. a # c = Bk \\<up> n)", "case (Cons a c)"], ["proof (state)\nthis:\n  (bl2nat c 0 = 0) = (\\<exists>n. c = Bk \\<up> n)\n\ngoal (2 subgoals):\n 1. (bl2nat [] 0 = 0) = (\\<exists>n. [] = Bk \\<up> n)\n 2. \\<And>a c.\n       (bl2nat c 0 = 0) = (\\<exists>n. c = Bk \\<up> n) \\<Longrightarrow>\n       (bl2nat (a # c) 0 = 0) = (\\<exists>n. a # c = Bk \\<up> n)", "then"], ["proof (chain)\npicking this:\n  (bl2nat c 0 = 0) = (\\<exists>n. c = Bk \\<up> n)", "show ?case"], ["proof (prove)\nusing this:\n  (bl2nat c 0 = 0) = (\\<exists>n. c = Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. (bl2nat (a # c) 0 = 0) = (\\<exists>n. a # c = Bk \\<up> n)", "by (cases a;auto simp: bl2nat.simps bl2nat_double Cons_replicate_eq)"], ["proof (state)\nthis:\n  (bl2nat (a # c) 0 = 0) = (\\<exists>n. a # c = Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. (bl2nat [] 0 = 0) = (\\<exists>n. [] = Bk \\<up> n)", "qed (auto simp: bl2nat.simps)"], ["", "lemma bl2wc_exp_ex: \n  \"\\<lbrakk>Suc (bl2wc c) = 2 ^  m\\<rbrakk> \\<Longrightarrow> \\<exists> rs n. c = Oc\\<up>(rs) @ Bk\\<up>(n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n    \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n", "proof(induct c arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "case (Cons a c m)"], ["proof (state)\nthis:\n  Suc (bl2wc c) = 2 ^ ?m \\<Longrightarrow>\n  \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\n  Suc (bl2wc (a # c)) = 2 ^ m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "{"], ["proof (state)\nthis:\n  Suc (bl2wc c) = 2 ^ ?m \\<Longrightarrow>\n  \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\n  Suc (bl2wc (a # c)) = 2 ^ m\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "have \"Bk # Bk \\<up> n = Oc \\<up> 0 @ Bk \\<up> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bk # Bk \\<up> n = Oc \\<up> 0 @ Bk \\<up> Suc n", "by (auto simp:replicate_Suc)"], ["proof (state)\nthis:\n  Bk # Bk \\<up> n = Oc \\<up> 0 @ Bk \\<up> Suc n\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "hence \"\\<exists>rs na. Bk # Bk \\<up> n = Oc \\<up> rs @ Bk \\<up> na\""], ["proof (prove)\nusing this:\n  Bk # Bk \\<up> n = Oc \\<up> 0 @ Bk \\<up> Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>rs na. Bk # Bk \\<up> n = Oc \\<up> rs @ Bk \\<up> na", "by blast"], ["proof (state)\nthis:\n  \\<exists>rs na. Bk # Bk \\<up> n = Oc \\<up> rs @ Bk \\<up> na\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "}"], ["proof (state)\nthis:\n  \\<exists>rs na. Bk # Bk \\<up> ?n2 = Oc \\<up> rs @ Bk \\<up> na\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n\n 2. \\<And>a c m.\n       \\<lbrakk>\\<And>m.\n                   Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n                   \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n;\n        Suc (bl2wc (a # c)) = 2 ^ m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "with Cons"], ["proof (chain)\npicking this:\n  Suc (bl2wc c) = 2 ^ ?m \\<Longrightarrow>\n  \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\n  Suc (bl2wc (a # c)) = 2 ^ m\n  \\<exists>rs na. Bk # Bk \\<up> ?n2 = Oc \\<up> rs @ Bk \\<up> na", "show ?case"], ["proof (prove)\nusing this:\n  Suc (bl2wc c) = 2 ^ ?m \\<Longrightarrow>\n  \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\n  Suc (bl2wc (a # c)) = 2 ^ m\n  \\<exists>rs na. Bk # Bk \\<up> ?n2 = Oc \\<up> rs @ Bk \\<up> na\n\ngoal (1 subgoal):\n 1. \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n", "apply(cases a, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc (2 * bl2wc c) = 2 ^ m;\n     \\<And>n. \\<exists>na. Bk # Bk \\<up> n = Bk \\<up> na; a = Bk;\n     \\<And>m.\n        Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n        \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. Bk # c = Bk \\<up> n\n 2. \\<lbrakk>Suc (bl2wc (Oc # c)) = 2 ^ m;\n     \\<And>n. \\<exists>na. Bk # Bk \\<up> n = Bk \\<up> na; a = Oc;\n     \\<And>m.\n        Suc (bl2wc c) = 2 ^ m \\<Longrightarrow>\n        \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs n. Oc # c = Oc \\<up> rs @ Bk \\<up> n", "apply(case_tac m, simp_all add: bl2wc.simps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (bl2nat (Oc # c) 0) = 2 ^ m;\n     \\<And>n. \\<exists>na. Bk # Bk \\<up> n = Bk \\<up> na; a = Oc;\n     \\<And>m.\n        Suc (bl2nat c 0) = 2 ^ m \\<Longrightarrow>\n        \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs n. Oc # c = Oc \\<up> rs @ Bk \\<up> n", "apply(simp add: bl2wc.simps bl2nat.simps bl2nat_double Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc (Suc (2 * bl2nat c 0)) = 2 ^ m;\n     \\<And>n. \\<exists>na. Bk # Bk \\<up> n = Bk \\<up> na; a = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rs n. Oc # c = Oc \\<up> rs @ Bk \\<up> n", "apply(case_tac m, simp, simp add: bin_wc_eq bl2wc.simps twice_power )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>bl2nat c 0 = 2 ^ nat - Suc 0;\n        \\<And>n. \\<exists>na. Bk # Bk \\<up> n = Bk \\<up> na; a = Oc;\n        m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs n. Oc # c = Oc \\<up> rs @ Bk \\<up> n", "by (metis Cons.hyps Suc_pred bl2wc.simps neq0_conv power_not_zero\n        replicate_Suc_iff_anywhere zero_neq_numeral)"], ["proof (state)\nthis:\n  \\<exists>rs n. a # c = Oc \\<up> rs @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       Suc (bl2wc []) = 2 ^ m \\<Longrightarrow>\n       \\<exists>rs n. [] = Oc \\<up> rs @ Bk \\<up> n", "qed (simp add: bl2wc.simps bl2nat.simps)"], ["", "lemma lg_bin: \n  assumes \"\\<forall>rs n. c \\<noteq> Oc\\<up>(Suc rs) @ Bk\\<up>(n)\" \n    \"bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0\"\n  shows \"bl2wc c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bl2wc c = 0", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n\n  bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0", "obtain rs nat n where *:\"2 ^ rs - Suc 0 = nat\"\n    \"c = Oc \\<up> rs @ Bk \\<up> n\""], ["proof (prove)\nusing this:\n  \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n\n  bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>rs nat n.\n        \\<lbrakk>2 ^ rs - Suc 0 = nat; c = Oc \\<up> rs @ Bk \\<up> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bl2wc_exp_ex[of c \"lg (Suc (bl2wc c)) 2\"]"], ["proof (prove)\nusing this:\n  \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n\n  bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0\n  Suc (bl2wc c) = 2 ^ lg (Suc (bl2wc c)) 2 \\<Longrightarrow>\n  \\<exists>rs n. c = Oc \\<up> rs @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. (\\<And>rs nat n.\n        \\<lbrakk>2 ^ rs - Suc 0 = nat; c = Oc \\<up> rs @ Bk \\<up> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(case_tac \"(2::nat) ^ lg (Suc (bl2wc c)) 2\", \n        simp, simp, erule_tac exE, erule_tac exE, simp)"], ["proof (state)\nthis:\n  2 ^ rs - Suc 0 = nat\n  c = Oc \\<up> rs @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. bl2wc c = 0", "have r:\"bl2wc (Oc \\<up> rs) = nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bl2wc (Oc \\<up> rs) = nat", "by (metis \"*\"(1) bl2nat_exp_zero bl2wc.elims)"], ["proof (state)\nthis:\n  bl2wc (Oc \\<up> rs) = nat\n\ngoal (1 subgoal):\n 1. bl2wc c = 0", "hence \"Suc (bl2wc c) = 2^rs\""], ["proof (prove)\nusing this:\n  bl2wc (Oc \\<up> rs) = nat\n\ngoal (1 subgoal):\n 1. Suc (bl2wc c) = 2 ^ rs", "using *"], ["proof (prove)\nusing this:\n  bl2wc (Oc \\<up> rs) = nat\n  2 ^ rs - Suc 0 = nat\n  c = Oc \\<up> rs @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. Suc (bl2wc c) = 2 ^ rs", "by(case_tac \"(2::nat)^rs\", auto)"], ["proof (state)\nthis:\n  Suc (bl2wc c) = 2 ^ rs\n\ngoal (1 subgoal):\n 1. bl2wc c = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc (bl2wc c) = 2 ^ rs\n\ngoal (1 subgoal):\n 1. bl2wc c = 0", "using * assms(1)"], ["proof (prove)\nusing this:\n  Suc (bl2wc c) = 2 ^ rs\n  2 ^ rs - Suc 0 = nat\n  c = Oc \\<up> rs @ Bk \\<up> n\n  \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n\n\ngoal (1 subgoal):\n 1. bl2wc c = 0", "apply(drule_tac bl2wc_exp_ex, simp, erule_tac exE, erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rsa na.\n       \\<lbrakk>\\<forall>rsa na.\n                   Oc \\<up> rs @ Bk \\<up> n \\<noteq>\n                   Oc \\<up> Suc rsa @ Bk \\<up> na;\n        Suc (bl2wc (Oc \\<up> rs)) = 2 ^ rs; 2 ^ rs - Suc 0 = nat;\n        c = Oc \\<up> rs @ Bk \\<up> n; Suc (bl2wc c) = 2 ^ rs;\n        2 ^ rs - Suc 0 = nat; c = Oc \\<up> rs @ Bk \\<up> n;\n        \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n;\n        Suc (bl2wc c) = 2 ^ rs; 2 ^ rs - Suc 0 = nat;\n        c = Oc \\<up> rs @ Bk \\<up> n;\n        \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n;\n        Oc \\<up> rs @ Bk \\<up> n = Oc \\<up> rsa @ Bk \\<up> na\\<rbrakk>\n       \\<Longrightarrow> bl2wc (Oc \\<up> rs) = 0", "by(case_tac rs, simp, simp)"], ["proof (state)\nthis:\n  bl2wc c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nstd_case3: \n  \"\\<forall>rs n. c \\<noteq> Oc\\<up>(Suc rs) @ Bk\\<up>(n) \\<Longrightarrow>  NSTD (trpl_code (a, b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n \\<Longrightarrow>\n    NSTD (trpl_code (a, b, c))", "apply(simp add: NSTD.simps trpl_code.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n \\<Longrightarrow>\n    bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0 \\<longrightarrow>\n    0 < a \\<or> 0 < bl2wc b \\<or> bl2wc c = 0", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n;\n     bl2wc c = 2 ^ lg (Suc (bl2wc c)) 2 - Suc 0; a = 0; 0 < bl2wc c\\<rbrakk>\n    \\<Longrightarrow> 0 < bl2wc b", "apply(drule_tac lg_bin, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma NSTD_1: \"\\<not> TSTD (a, b, c)\n    \\<Longrightarrow> rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> TSTD (a, b, c) \\<Longrightarrow>\n    rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0", "using NSTD_lemma1[of \"trpl_code (a, b, c)\"]\n    NSTD_lemma2[of \"trpl_code (a, b, c)\"]"], ["proof (prove)\nusing this:\n  rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0 \\<or>\n  rec_exec rec_NSTD [trpl_code (a, b, c)] = 0\n  (rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0) =\n  NSTD (trpl_code (a, b, c))\n\ngoal (1 subgoal):\n 1. \\<not> TSTD (a, b, c) \\<Longrightarrow>\n    rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0", "apply(simp add: TSTD_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a \\<or>\n             (\\<forall>m. b \\<noteq> Bk \\<up> m) \\<or>\n             (\\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n);\n     NSTD (trpl_code (a, b, c)) \\<or>\n     rec_exec rec_NSTD [trpl_code (a, b, c)] = 0;\n     (rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0) =\n     NSTD (trpl_code (a, b, c))\\<rbrakk>\n    \\<Longrightarrow> NSTD (trpl_code (a, b, c))", "apply(erule_tac disjE, erule_tac nstd_case1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NSTD (trpl_code (a, b, c)) \\<or>\n             rec_exec rec_NSTD [trpl_code (a, b, c)] = 0;\n     (rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0) =\n     NSTD (trpl_code (a, b, c));\n     (\\<forall>m. b \\<noteq> Bk \\<up> m) \\<or>\n     (\\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n)\\<rbrakk>\n    \\<Longrightarrow> NSTD (trpl_code (a, b, c))", "apply(erule_tac disjE, erule_tac nstd_case2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NSTD (trpl_code (a, b, c)) \\<or>\n             rec_exec rec_NSTD [trpl_code (a, b, c)] = 0;\n     (rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0) =\n     NSTD (trpl_code (a, b, c));\n     \\<forall>rs n. c \\<noteq> Oc \\<up> Suc rs @ Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> NSTD (trpl_code (a, b, c))", "apply(erule_tac nstd_case3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nonstop_t_uhalt_eq:\n  \"\\<lbrakk>tm_wf (tp, 0);\n  steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp = (a, b, c);\n  \\<not> TSTD (a, b, c)\\<rbrakk>\n  \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), stp] = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c);\n     \\<not> TSTD (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), stp] =\n                      Suc 0", "apply(simp add: rec_nonstop_def rec_exec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c);\n     \\<not> TSTD (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_NSTD\n                       [rec_exec rec_conf [code tp, bl2wc (<lm>), stp]] =\n                      Suc 0", "apply(subgoal_tac \n      \"rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n  trpl_code (a, b, c)\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tm_wf0 tp; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c);\n     \\<not> TSTD (a, b, c);\n     rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n     trpl_code (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_NSTD [trpl_code (a, b, c)] = Suc 0\n 2. \\<lbrakk>tm_wf0 tp; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c);\n     \\<not> TSTD (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n                      trpl_code (a, b, c)", "apply(erule_tac NSTD_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c);\n     \\<not> TSTD (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n                      trpl_code (a, b, c)", "using rec_t_eq_steps[of tp l lm stp]"], ["proof (prove)\nusing this:\n  tm_wf0 tp \\<Longrightarrow>\n  trpl_code (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp) =\n  rec_exec rec_conf [code tp, bl2wc (<lm>), stp]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp; steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp = (a, b, c);\n     \\<not> TSTD (a, b, c)\\<rbrakk>\n    \\<Longrightarrow> rec_exec rec_conf [code tp, bl2wc (<lm>), stp] =\n                      trpl_code (a, b, c)", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nonstop_true:\n  \"\\<lbrakk>tm_wf (tp, 0);\n  \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>y. rec_exec rec_nonstop ([code tp, bl2wc (<lm>), y]) = (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y.\n                         rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] =\n                         Suc 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp.\n           \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] =\n                         Suc 0", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp.\n           \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] =\n                         Suc 0", "assume a:\"tm_wf0 tp\" \"\\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\""], ["proof (state)\nthis:\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp.\n           \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] =\n                         Suc 0", "hence \"\\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp y)\""], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\n\ngoal (1 subgoal):\n 1. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp y)", "by auto"], ["proof (state)\nthis:\n  \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp.\n           \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n       \\<Longrightarrow> rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] =\n                         Suc 0", "thus \"rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] = Suc 0\""], ["proof (prove)\nusing this:\n  \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp y)\n\ngoal (1 subgoal):\n 1. rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] = Suc 0", "by (cases \"steps0 (Suc 0, Bk\\<up>(l), <lm>) tp y\")\n      (auto intro: nonstop_t_uhalt_eq[OF a(1)])"], ["proof (state)\nthis:\n  rec_exec rec_nonstop [code tp, bl2wc (<lm>), y] = Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cn_arity:  \"rec_ci (Cn n f gs) = (a, b, c) \\<Longrightarrow> b = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_ci (Cn n f gs) = (a, b, c) \\<Longrightarrow> b = n", "by(case_tac \"rec_ci f\", simp add: rec_ci.simps)"], ["", "lemma mn_arity: \"rec_ci (Mn n f) = (a, b, c) \\<Longrightarrow> b = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_ci (Mn n f) = (a, b, c) \\<Longrightarrow> b = n", "by(case_tac \"rec_ci f\", simp add: rec_ci.simps)"], ["", "lemma F_aprog_uhalt: \n  assumes wf_tm: \"tm_wf (tp,0)\"\n    and unhalt:  \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\"\n    and compile: \"rec_ci rec_F = (F_ap, rs_pos, a_md)\"\n  shows \"{\\<lambda> nl. nl = [code tp, bl2wc (<lm>)] @ 0\\<up>(a_md - rs_pos ) @ suflm} (F_ap) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "using compile"], ["proof (prove)\nusing this:\n  rec_ci rec_F = (F_ap, rs_pos, a_md)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "proof(simp only: rec_F_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "assume h: \"rec_ci (Cn (Suc (Suc 0)) rec_valu [Cn (Suc (Suc 0)) rec_right [Cn (Suc (Suc 0)) \n    rec_conf [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n    (F_ap, rs_pos, a_md)\""], ["proof (state)\nthis:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_valu\n     [Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]]]) =\n  (F_ap, rs_pos, a_md)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "moreover"], ["proof (state)\nthis:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_valu\n     [Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]]]) =\n  (F_ap, rs_pos, a_md)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "hence \"rs_pos = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_valu\n     [Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]]]) =\n  (F_ap, rs_pos, a_md)\n\ngoal (1 subgoal):\n 1. rs_pos = Suc (Suc 0)", "using cn_arity"], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_valu\n     [Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]]]) =\n  (F_ap, rs_pos, a_md)\n  rec_ci (Cn ?n ?f ?gs) = (?a, ?b, ?c) \\<Longrightarrow> ?b = ?n\n\ngoal (1 subgoal):\n 1. rs_pos = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  rs_pos = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "moreover"], ["proof (state)\nthis:\n  rs_pos = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "obtain ap1 ar1 ft1 where a: \"rec_ci \n    (Cn (Suc (Suc 0)) rec_right \n    [Cn (Suc (Suc 0)) rec_conf [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]) = (ap1, ar1, ft1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ap1 ar1 ft1.\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, ar1, ft1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(case_tac \"rec_ci (Cn (Suc (Suc 0)) rec_right [Cn (Suc (Suc 0)) \n      rec_conf [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]])\", auto)"], ["proof (state)\nthis:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "moreover"], ["proof (state)\nthis:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "hence b: \"ar1 = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n\ngoal (1 subgoal):\n 1. ar1 = Suc (Suc 0)", "using cn_arity"], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n  rec_ci (Cn ?n ?f ?gs) = (?a, ?b, ?c) \\<Longrightarrow> ?b = ?n\n\ngoal (1 subgoal):\n 1. ar1 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  ar1 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. rec_ci\n     (Cn (Suc (Suc 0)) rec_valu\n       [Cn (Suc (Suc 0)) rec_right\n         [Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]]]) =\n    (F_ap, rs_pos, a_md) \\<Longrightarrow>\n    {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "ultimately"], ["proof (chain)\npicking this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_valu\n     [Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]]]) =\n  (F_ap, rs_pos, a_md)\n  rs_pos = Suc (Suc 0)\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n  ar1 = Suc (Suc 0)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_valu\n     [Cn (Suc (Suc 0)) rec_right\n       [Cn (Suc (Suc 0)) rec_conf\n         [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n          rec_halt]]]) =\n  (F_ap, rs_pos, a_md)\n  rs_pos = Suc (Suc 0)\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n  ar1 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n    F_ap \\<up>", "proof(rule_tac i = 0 in cn_unhalt_case, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_valu\n                   [Cn (Suc (Suc 0)) rec_right\n                     [Cn (Suc (Suc 0)) rec_conf\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n                (F_ap, Suc (Suc 0), a_md);\n        rs_pos = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n                         ap1 \\<up>", "fix anything"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_valu\n                   [Cn (Suc (Suc 0)) rec_right\n                     [Cn (Suc (Suc 0)) rec_conf\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n                (F_ap, Suc (Suc 0), a_md);\n        rs_pos = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n                         ap1 \\<up>", "obtain ap2 ar2 ft2 where c: \n      \"rec_ci (Cn (Suc (Suc 0)) rec_conf [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt])\n      = (ap2, ar2, ft2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ap2 ar2 ft2.\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]) =\n        (ap2, ar2, ft2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(case_tac \"rec_ci (Cn (Suc (Suc 0)) rec_conf\n        [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt])\", auto)"], ["proof (state)\nthis:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_valu\n                   [Cn (Suc (Suc 0)) rec_right\n                     [Cn (Suc (Suc 0)) rec_conf\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n                (F_ap, Suc (Suc 0), a_md);\n        rs_pos = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n                         ap1 \\<up>", "moreover"], ["proof (state)\nthis:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_valu\n                   [Cn (Suc (Suc 0)) rec_right\n                     [Cn (Suc (Suc 0)) rec_conf\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n                (F_ap, Suc (Suc 0), a_md);\n        rs_pos = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n                         ap1 \\<up>", "hence d:\"ar2 = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n\ngoal (1 subgoal):\n 1. ar2 = Suc (Suc 0)", "using cn_arity"], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n  rec_ci (Cn ?n ?f ?gs) = (?a, ?b, ?c) \\<Longrightarrow> ?b = ?n\n\ngoal (1 subgoal):\n 1. ar2 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  ar2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_valu\n                   [Cn (Suc (Suc 0)) rec_right\n                     [Cn (Suc (Suc 0)) rec_conf\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n                (F_ap, Suc (Suc 0), a_md);\n        rs_pos = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n                         ap1 \\<up>", "ultimately"], ["proof (chain)\npicking this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n  ar2 = Suc (Suc 0)", "have \"{\\<lambda>nl. nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft1 - Suc (Suc 0)) @ anything} ap1 \\<up>\""], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n  ar2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n    ap1 \\<up>", "using a b c d"], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n  ar2 = Suc (Suc 0)\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_right\n     [Cn (Suc (Suc 0)) rec_conf\n       [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        rec_halt]]) =\n  (ap1, ar1, ft1)\n  ar1 = Suc (Suc 0)\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n  ar2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n    ap1 \\<up>", "proof(rule_tac i = 0 in cn_unhalt_case, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_right\n                   [Cn (Suc (Suc 0)) rec_conf\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]) =\n                (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]) =\n        (ap2, Suc (Suc 0), ft2);\n        ar2 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n                         ap2 \\<up>", "fix anything"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_right\n                   [Cn (Suc (Suc 0)) rec_conf\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]) =\n                (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]) =\n        (ap2, Suc (Suc 0), ft2);\n        ar2 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n                         ap2 \\<up>", "obtain ap3 ar3 ft3 where e: \"rec_ci rec_halt = (ap3, ar3, ft3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ap3 ar3 ft3.\n        rec_ci rec_halt = (ap3, ar3, ft3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(case_tac \"rec_ci rec_halt\", auto)"], ["proof (state)\nthis:\n  rec_ci rec_halt = (ap3, ar3, ft3)\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_right\n                   [Cn (Suc (Suc 0)) rec_conf\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]) =\n                (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]) =\n        (ap2, Suc (Suc 0), ft2);\n        ar2 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n                         ap2 \\<up>", "hence f: \"ar3 = Suc (Suc 0)\""], ["proof (prove)\nusing this:\n  rec_ci rec_halt = (ap3, ar3, ft3)\n\ngoal (1 subgoal):\n 1. ar3 = Suc (Suc 0)", "using mn_arity"], ["proof (prove)\nusing this:\n  rec_ci rec_halt = (ap3, ar3, ft3)\n  rec_ci (Mn ?n ?f) = (?a, ?b, ?c) \\<Longrightarrow> ?b = ?n\n\ngoal (1 subgoal):\n 1. ar3 = Suc (Suc 0)", "by(simp add: rec_halt_def)"], ["proof (state)\nthis:\n  ar3 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_right\n                   [Cn (Suc (Suc 0)) rec_conf\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]) =\n                (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]) =\n        (ap2, Suc (Suc 0), ft2);\n        ar2 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n                         ap2 \\<up>", "have \"{\\<lambda>nl. nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft2 - Suc (Suc 0)) @ anything} ap2 \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n    ap2 \\<up>", "using c d e f"], ["proof (prove)\nusing this:\n  rec_ci\n   (Cn (Suc (Suc 0)) rec_conf\n     [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), rec_halt]) =\n  (ap2, ar2, ft2)\n  ar2 = Suc (Suc 0)\n  rec_ci rec_halt = (ap3, ar3, ft3)\n  ar3 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n    ap2 \\<up>", "proof(rule_tac i = 2 in cn_unhalt_case, auto simp: rec_halt_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n                         ap3 \\<up>\n 2. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 3. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "fix anything"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n                         ap3 \\<up>\n 2. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 3. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "have \"{\\<lambda>nl. nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft3 - Suc (Suc 0)) @ anything} ap3 \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n    ap3 \\<up>", "using e f"], ["proof (prove)\nusing this:\n  rec_ci rec_halt = (ap3, ar3, ft3)\n  ar3 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n    ap3 \\<up>", "proof(rule_tac mn_unhalt_case, auto simp: rec_halt_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> terminate rec_nonstop [code tp, bl2wc (<lm>), i]\n 2. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> terminate rec_nonstop [code tp, bl2wc (<lm>), i]\n 2. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "show \"terminate rec_nonstop [code tp, bl2wc (<lm>), i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminate rec_nonstop [code tp, bl2wc (<lm>), i]", "by(rule_tac primerec_terminate, auto)"], ["proof (state)\nthis:\n  terminate rec_nonstop [code tp, bl2wc (<lm>), i]\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>rec_ci (Mn (Suc (Suc 0)) rec_nonstop) =\n                (ap3, Suc (Suc 0), ft3);\n        ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "show \"0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "using assms"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\n  rec_ci rec_F = (F_ap, rs_pos, a_md)\n\ngoal (1 subgoal):\n 1. 0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]", "by(drule_tac nonstop_true, auto)"], ["proof (state)\nthis:\n  0 < rec_exec rec_nonstop [code tp, bl2wc (<lm>), i]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n  ap3 \\<up>\n\ngoal (3 subgoals):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n                         ap3 \\<up>\n 2. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 3. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "thus \"{\\<lambda>nl. nl = code tp # bl2wc (<lm>) # 0 \\<up> (ft3 - Suc (Suc 0)) @ anything} ap3 \\<up>\""], ["proof (prove)\nusing this:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n  ap3 \\<up>\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        code tp # bl2wc (<lm>) # 0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n    ap3 \\<up>", "by simp"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = code tp # bl2wc (<lm>) # 0 \\<up> (ft3 - Suc (Suc 0)) @ anything}\n  ap3 \\<up>\n\ngoal (2 subgoals):\n 1. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 2. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 2. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "fix apj arj ftj j  anything"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 2. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "assume \"j<2\" \"rec_ci ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), Mn (Suc (Suc 0)) rec_nonstop] ! j) = (apj, arj, ftj)\""], ["proof (state)\nthis:\n  j < 2\n  rec_ci\n   ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n     Mn (Suc (Suc 0)) rec_nonstop] !\n    j) =\n  (apj, arj, ftj)\n\ngoal (2 subgoals):\n 1. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 2. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "hence \"{\\<lambda>nl. nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ftj - arj) @ anything} apj\n          {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)] @\n            rec_exec ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), Mn (Suc (Suc 0)) rec_nonstop] ! j) [code tp, bl2wc (<lm>)] # \n               0 \\<up> (ftj - Suc arj) @ anything}\""], ["proof (prove)\nusing this:\n  j < 2\n  rec_ci\n   ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n     Mn (Suc (Suc 0)) rec_nonstop] !\n    j) =\n  (apj, arj, ftj)\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ftj - arj) @ anything}\n    apj\n    {\\<lambda>nl.\n        nl =\n        [code tp, bl2wc (<lm>)] @\n        rec_exec\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j)\n         [code tp, bl2wc (<lm>)] #\n        0 \\<up> (ftj - Suc arj) @ anything}", "apply(rule_tac recursive_compile_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < 2;\n     rec_ci\n      ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        Mn (Suc (Suc 0)) rec_nonstop] !\n       j) =\n     (apj, arj, ftj)\\<rbrakk>\n    \\<Longrightarrow> terminate\n                       ([recf.id (Suc (Suc 0)) 0,\n                         recf.id (Suc (Suc 0)) (Suc 0),\n                         Mn (Suc (Suc 0)) rec_nonstop] !\n                        j)\n                       [code tp, bl2wc (<lm>)]\n 2. \\<lbrakk>j < 2;\n     rec_ci\n      ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n        Mn (Suc (Suc 0)) rec_nonstop] !\n       j) =\n     (apj, arj, ftj)\\<rbrakk>\n    \\<Longrightarrow> rec_ci\n                       ([recf.id (Suc (Suc 0)) 0,\n                         recf.id (Suc (Suc 0)) (Suc 0),\n                         Mn (Suc (Suc 0)) rec_nonstop] !\n                        j) =\n                      (apj, arj, ftj)", "apply(case_tac j, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rec_ci (recf.id (Suc (Suc 0)) 0) = (apj, arj, ftj);\n     j = 0\\<rbrakk>\n    \\<Longrightarrow> terminate (recf.id (Suc (Suc 0)) 0)\n                       [code tp, bl2wc (<lm>)]\n 2. \\<lbrakk>rec_ci (recf.id (Suc (Suc 0)) (Suc 0)) = (apj, arj, ftj);\n     j = Suc 0\\<rbrakk>\n    \\<Longrightarrow> terminate (recf.id (Suc (Suc 0)) (Suc 0))\n                       [code tp, bl2wc (<lm>)]", "apply(rule_tac [!] primerec_terminate)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>rec_ci (recf.id (Suc (Suc 0)) 0) = (apj, arj, ftj);\n     j = 0\\<rbrakk>\n    \\<Longrightarrow> primerec (recf.id (Suc (Suc 0)) 0) ?x5\n 2. \\<lbrakk>rec_ci (recf.id (Suc (Suc 0)) 0) = (apj, arj, ftj);\n     j = 0\\<rbrakk>\n    \\<Longrightarrow> length [code tp, bl2wc (<lm>)] = ?x5\n 3. \\<lbrakk>rec_ci (recf.id (Suc (Suc 0)) (Suc 0)) = (apj, arj, ftj);\n     j = Suc 0\\<rbrakk>\n    \\<Longrightarrow> primerec (recf.id (Suc (Suc 0)) (Suc 0)) ?x4\n 4. \\<lbrakk>rec_ci (recf.id (Suc (Suc 0)) (Suc 0)) = (apj, arj, ftj);\n     j = Suc 0\\<rbrakk>\n    \\<Longrightarrow> length [code tp, bl2wc (<lm>)] = ?x4", "by(auto)"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ftj - arj) @ anything}\n  apj\n  {\\<lambda>nl.\n      nl =\n      [code tp, bl2wc (<lm>)] @\n      rec_exec\n       ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n         Mn (Suc (Suc 0)) rec_nonstop] !\n        j)\n       [code tp, bl2wc (<lm>)] #\n      0 \\<up> (ftj - Suc arj) @ anything}\n\ngoal (2 subgoals):\n 1. \\<And>apj arj ftj j anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        j < 2;\n        rec_ci\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j) =\n        (apj, arj, ftj);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n                         apj\n                         {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             rec_exec\n                              ([recf.id (Suc (Suc 0)) 0,\n                                recf.id (Suc (Suc 0)) (Suc 0),\n                                Mn (Suc (Suc 0)) rec_nonstop] !\n                               j)\n                              [code tp, bl2wc (<lm>)] #\n                             0 \\<up> (ftj - Suc arj) @ anything}\n 2. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "thus \"{\\<lambda>nl. nl = code tp # bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything} apj\n          {\\<lambda>nl. nl = code tp # bl2wc (<lm>) # rec_exec ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0))\n          (Suc 0), Mn (Suc (Suc 0)) rec_nonstop] ! j) [code tp, bl2wc (<lm>)] # 0 \\<up> (ftj - Suc arj) @ anything}\""], ["proof (prove)\nusing this:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ftj - arj) @ anything}\n  apj\n  {\\<lambda>nl.\n      nl =\n      [code tp, bl2wc (<lm>)] @\n      rec_exec\n       ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n         Mn (Suc (Suc 0)) rec_nonstop] !\n        j)\n       [code tp, bl2wc (<lm>)] #\n      0 \\<up> (ftj - Suc arj) @ anything}\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl = code tp # bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n    apj\n    {\\<lambda>nl.\n        nl =\n        code tp #\n        bl2wc (<lm>) #\n        rec_exec\n         ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n           Mn (Suc (Suc 0)) rec_nonstop] !\n          j)\n         [code tp, bl2wc (<lm>)] #\n        0 \\<up> (ftj - Suc arj) @ anything}", "by simp"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = code tp # bl2wc (<lm>) # 0 \\<up> (ftj - arj) @ anything}\n  apj\n  {\\<lambda>nl.\n      nl =\n      code tp #\n      bl2wc (<lm>) #\n      rec_exec\n       ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n         Mn (Suc (Suc 0)) rec_nonstop] !\n        j)\n       [code tp, bl2wc (<lm>)] #\n      0 \\<up> (ftj - Suc arj) @ anything}\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "assume \"(j::nat) < 2\""], ["proof (state)\nthis:\n  j < 2\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_conf\n                   [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n                    Mn (Suc (Suc 0)) rec_nonstop]) =\n                (ap2, Suc (Suc 0), ft2);\n        rec_ci (Mn (Suc (Suc 0)) rec_nonstop) = (ap3, Suc (Suc 0), ft3);\n        ar2 = Suc (Suc 0); ar3 = Suc (Suc 0); j < 2\\<rbrakk>\n       \\<Longrightarrow> terminate\n                          ([recf.id (Suc (Suc 0)) 0,\n                            recf.id (Suc (Suc 0)) (Suc 0),\n                            Mn (Suc (Suc 0)) rec_nonstop] !\n                           j)\n                          [code tp, bl2wc (<lm>)]", "thus \"terminate ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0), Mn (Suc (Suc 0)) rec_nonstop] ! j)\n          [code tp, bl2wc (<lm>)]\""], ["proof (prove)\nusing this:\n  j < 2\n\ngoal (1 subgoal):\n 1. terminate\n     ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n       Mn (Suc (Suc 0)) rec_nonstop] !\n      j)\n     [code tp, bl2wc (<lm>)]", "by(case_tac j, auto intro!: primerec_terminate)"], ["proof (state)\nthis:\n  terminate\n   ([recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n     Mn (Suc (Suc 0)) rec_nonstop] !\n    j)\n   [code tp, bl2wc (<lm>)]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n  ap2 \\<up>\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_right\n                   [Cn (Suc (Suc 0)) rec_conf\n                     [recf.id (Suc (Suc 0)) 0,\n                      recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]) =\n                (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_conf\n           [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n            rec_halt]) =\n        (ap2, Suc (Suc 0), ft2);\n        ar2 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n                         ap2 \\<up>", "thus \"{\\<lambda>nl. nl = code tp # bl2wc (<lm>) # 0 \\<up> (ft2 - Suc (Suc 0)) @ anything} ap2 \\<up>\""], ["proof (prove)\nusing this:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n  ap2 \\<up>\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        code tp # bl2wc (<lm>) # 0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n    ap2 \\<up>", "by simp"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = code tp # bl2wc (<lm>) # 0 \\<up> (ft2 - Suc (Suc 0)) @ anything}\n  ap2 \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n  ap1 \\<up>\n\ngoal (1 subgoal):\n 1. \\<And>anything.\n       \\<lbrakk>rec_ci\n                 (Cn (Suc (Suc 0)) rec_valu\n                   [Cn (Suc (Suc 0)) rec_right\n                     [Cn (Suc (Suc 0)) rec_conf\n                       [recf.id (Suc (Suc 0)) 0,\n                        recf.id (Suc (Suc 0)) (Suc 0), rec_halt]]]) =\n                (F_ap, Suc (Suc 0), a_md);\n        rs_pos = Suc (Suc 0);\n        rec_ci\n         (Cn (Suc (Suc 0)) rec_right\n           [Cn (Suc (Suc 0)) rec_conf\n             [recf.id (Suc (Suc 0)) 0, recf.id (Suc (Suc 0)) (Suc 0),\n              rec_halt]]) =\n        (ap1, Suc (Suc 0), ft1);\n        ar1 = Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>nl.\n                             nl =\n                             code tp #\n                             bl2wc (<lm>) #\n                             0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n                         ap1 \\<up>", "thus \"{\\<lambda>nl. nl = code tp # bl2wc (<lm>) # 0 \\<up> (ft1 - Suc (Suc 0)) @ anything} ap1 \\<up>\""], ["proof (prove)\nusing this:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n  ap1 \\<up>\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl.\n        nl =\n        code tp # bl2wc (<lm>) # 0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n    ap1 \\<up>", "by simp"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = code tp # bl2wc (<lm>) # 0 \\<up> (ft1 - Suc (Suc 0)) @ anything}\n  ap1 \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>nl.\n      nl = [code tp, bl2wc (<lm>)] @ 0 \\<up> (a_md - rs_pos) @ suflm}\n  F_ap \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uabc_uhalt': \n  \"\\<lbrakk>tm_wf (tp, 0);\n  \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp));\n  rec_ci rec_F = (ap, pos, md)\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda> nl. nl = [code tp, bl2wc (<lm>)]} ap \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n     rec_ci rec_F = (ap, pos, md)\\<rbrakk>\n    \\<Longrightarrow> {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]} ap \\<up>", "proof(frule_tac F_ap = ap and rs_pos = pos and a_md = md\n    and suflm = \"[]\" in F_aprog_uhalt, auto simp: abc_Hoare_unhalt_def, \n    case_tac \"abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n        rec_ci rec_F = (ap, pos, md);\n        \\<forall>n.\n           abc_notfinal\n            (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap\n              n)\n            ap;\n        abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length ap", "fix n a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n        rec_ci rec_F = (ap, pos, md);\n        \\<forall>n.\n           abc_notfinal\n            (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap\n              n)\n            ap;\n        abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length ap", "assume h: \n    \"\\<forall>n. abc_notfinal (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\"\n    \"abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\" \n    \"tm_wf (tp, 0)\" \n    \"rec_ci rec_F = (ap, pos, md)\""], ["proof (state)\nthis:\n  \\<forall>n.\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\n  tm_wf0 tp\n  rec_ci rec_F = (ap, pos, md)\n\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n        rec_ci rec_F = (ap, pos, md);\n        \\<forall>n.\n           abc_notfinal\n            (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap\n              n)\n            ap;\n        abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length ap", "moreover"], ["proof (state)\nthis:\n  \\<forall>n.\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\n  tm_wf0 tp\n  rec_ci rec_F = (ap, pos, md)\n\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n        rec_ci rec_F = (ap, pos, md);\n        \\<forall>n.\n           abc_notfinal\n            (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap\n              n)\n            ap;\n        abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length ap", "have a: \"ap \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ap \\<noteq> []", "using h rec_ci_not_null[of \"rec_F\" pos md]"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\n  tm_wf0 tp\n  rec_ci rec_F = (ap, pos, md)\n  rec_ci rec_F \\<noteq> ([], pos, md)\n\ngoal (1 subgoal):\n 1. ap \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ap \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>n a b.\n       \\<lbrakk>tm_wf0 tp;\n        \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n        rec_ci rec_F = (ap, pos, md);\n        \\<forall>n.\n           abc_notfinal\n            (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap\n              n)\n            ap;\n        abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length ap", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\n  tm_wf0 tp\n  rec_ci rec_F = (ap, pos, md)\n  ap \\<noteq> []", "show \"a < length ap\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\n  tm_wf0 tp\n  rec_ci rec_F = (ap, pos, md)\n  ap \\<noteq> []\n\ngoal (1 subgoal):\n 1. a < length ap", "proof(erule_tac x = n in allE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b);\n     tm_wf0 tp; rec_ci rec_F = (ap, pos, md); ap \\<noteq> [];\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n)\n      ap\\<rbrakk>\n    \\<Longrightarrow> a < length ap", "assume g: \"abc_notfinal (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\""], ["proof (state)\nthis:\n  abc_notfinal\n   (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b);\n     tm_wf0 tp; rec_ci rec_F = (ap, pos, md); ap \\<noteq> [];\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n)\n      ap\\<rbrakk>\n    \\<Longrightarrow> a < length ap", "obtain ss nl where b : \"abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n = (ss, nl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss nl.\n        abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n        (ss, nl) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n  (ss, nl)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b);\n     tm_wf0 tp; rec_ci rec_F = (ap, pos, md); ap \\<noteq> [];\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n)\n      ap\\<rbrakk>\n    \\<Longrightarrow> a < length ap", "then"], ["proof (chain)\npicking this:\n  abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n  (ss, nl)", "have c: \"ss < length ap\""], ["proof (prove)\nusing this:\n  abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n  (ss, nl)\n\ngoal (1 subgoal):\n 1. ss < length ap", "using g"], ["proof (prove)\nusing this:\n  abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n  (ss, nl)\n  abc_notfinal\n   (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n\ngoal (1 subgoal):\n 1. ss < length ap", "by simp"], ["proof (state)\nthis:\n  ss < length ap\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b);\n     tm_wf0 tp; rec_ci rec_F = (ap, pos, md); ap \\<noteq> [];\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n)\n      ap\\<rbrakk>\n    \\<Longrightarrow> a < length ap", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  ss < length ap\n\ngoal (1 subgoal):\n 1. a < length ap", "using a b c"], ["proof (prove)\nusing this:\n  ss < length ap\n  ap \\<noteq> []\n  abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n  (ss, nl)\n  ss < length ap\n\ngoal (1 subgoal):\n 1. a < length ap", "using abc_list_crsp_steps[of \"[code tp, bl2wc (<lm>)]\"\n          \"md - pos\" ap n ss nl] h"], ["proof (prove)\nusing this:\n  ss < length ap\n  ap \\<noteq> []\n  abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n =\n  (ss, nl)\n  ss < length ap\n  \\<lbrakk>abc_steps_l (0, [code tp, bl2wc (<lm>)] @ 0 \\<up> (md - pos)) ap\n            n =\n           (ss, nl);\n   ap \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>lma.\n                       abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n =\n                       (ss, lma) \\<and>\n                       abc_list_crsp nl lma\n  \\<forall>n.\n     abc_notfinal\n      (abc_steps_l (0, code tp # bl2wc (<lm>) # 0 \\<up> (md - pos)) ap n) ap\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) ap n = (a, b)\n  tm_wf0 tp\n  rec_ci rec_F = (ap, pos, md)\n\ngoal (1 subgoal):\n 1. a < length ap", "by(simp)"], ["proof (state)\nthis:\n  a < length ap\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a < length ap\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uabc_uhalt: \n  \"\\<lbrakk>tm_wf (tp, 0); \n  \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda> nl. nl = [code tp, bl2wc (<lm>)]} F_aprog \\<up> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]}\n                      F_aprog \\<up>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]}\n                      F_aprog \\<up>", "obtain a b c where abc:\"rec_ci rec_F = (a,b,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        rec_ci rec_F = (a, b, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"rec_ci rec_F\") force"], ["proof (state)\nthis:\n  rec_ci rec_F = (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]}\n                      F_aprog \\<up>", "assume a:\"tm_wf (tp, 0)\" \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <lm>) tp stp))\""], ["proof (state)\nthis:\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]}\n                      F_aprog \\<up>", "from uabc_uhalt'[OF a abc] abc_Hoare_plus_unhalt1"], ["proof (chain)\npicking this:\n  {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]} a \\<up>\n  {?P} ?A \\<up> \\<Longrightarrow> {?P} ?A [+] ?B \\<up>", "show \"{\\<lambda> nl. nl = [code tp, bl2wc (<lm>)]} F_aprog \\<up>\""], ["proof (prove)\nusing this:\n  {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]} a \\<up>\n  {?P} ?A \\<up> \\<Longrightarrow> {?P} ?A [+] ?B \\<up>\n\ngoal (1 subgoal):\n 1. {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]} F_aprog \\<up>", "by(simp add: F_aprog_def abc)"], ["proof (state)\nthis:\n  {\\<lambda>nl. nl = [code tp, bl2wc (<lm>)]} F_aprog \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tutm_uhalt': \n  assumes tm_wf:  \"tm_wf (tp,0)\"\n    and unhalt: \"\\<forall> stp. (\\<not> TSTD (steps0 (1, Bk\\<up>(l), <lm>) tp stp))\"\n  shows \"\\<forall> stp. \\<not> is_final (steps0 (1, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final\n               (steps0 (1, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)", "unfolding t_utm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final\n               (steps0 (1, [Bk, Bk], <[code tp, bl2wc (<lm>)]>)\n                 (F_tprog @\n                  shift (mopup (Suc (Suc 0))) (length F_tprog div 2))\n                 stp)", "proof(rule_tac compile_correct_unhalt, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. F_tprog = tm_of ?ap\n 2. crsp (layout_of ?ap) (0, ?lm)\n     (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) ?ires\n 3. \\<And>stp as am.\n       abc_steps_l (0, ?lm) ?ap stp = (as, am) \\<Longrightarrow>\n       as < length ?ap", "show \"F_tprog = tm_of F_aprog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F_tprog = tm_of F_aprog", "by(simp add:  F_tprog_def)"], ["proof (state)\nthis:\n  F_tprog = tm_of F_aprog\n\ngoal (2 subgoals):\n 1. crsp (layout_of F_aprog) (0, ?lm)\n     (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) ?ires\n 2. \\<And>stp as am.\n       abc_steps_l (0, ?lm) F_aprog stp = (as, am) \\<Longrightarrow>\n       as < length F_aprog", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. crsp (layout_of F_aprog) (0, ?lm)\n     (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) ?ires\n 2. \\<And>stp as am.\n       abc_steps_l (0, ?lm) F_aprog stp = (as, am) \\<Longrightarrow>\n       as < length F_aprog", "show \"crsp (layout_of F_aprog) (0, [code tp, bl2wc (<lm>)]) (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>)  []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crsp (layout_of F_aprog) (0, [code tp, bl2wc (<lm>)])\n     (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) []", "by(auto simp: crsp.simps start_of.simps)"], ["proof (state)\nthis:\n  crsp (layout_of F_aprog) (0, [code tp, bl2wc (<lm>)])\n   (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) []\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp =\n       (as, am) \\<Longrightarrow>\n       as < length F_aprog", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp =\n       (as, am) \\<Longrightarrow>\n       as < length F_aprog", "fix stp a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp =\n       (as, am) \\<Longrightarrow>\n       as < length F_aprog", "show \"abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp = (a, b) \\<Longrightarrow> a < length F_aprog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp =\n    (a, b) \\<Longrightarrow>\n    a < length F_aprog", "using assms"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (1, Bk \\<up> l, <lm>) tp stp)\n\ngoal (1 subgoal):\n 1. abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp =\n    (a, b) \\<Longrightarrow>\n    a < length F_aprog", "apply(drule_tac uabc_uhalt, auto simp: abc_Hoare_unhalt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp = (a, b);\n     \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <lm>) tp stp);\n     \\<forall>n.\n        abc_notfinal (abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog n)\n         F_aprog;\n     tm_wf0 tp\\<rbrakk>\n    \\<Longrightarrow> a < length F_aprog", "by(erule_tac x = stp in allE, erule_tac x = stp in allE, simp)"], ["proof (state)\nthis:\n  abc_steps_l (0, [code tp, bl2wc (<lm>)]) F_aprog stp =\n  (a, b) \\<Longrightarrow>\n  a < length F_aprog\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tinres_commute: \"tinres r r' \\<Longrightarrow> tinres r' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres r r' \\<Longrightarrow> tinres r' r", "apply(auto simp: tinres_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inres_tape:\n  \"\\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c); steps0 (st, l', r') tp stp = (a', b', c'); \n  tinres l l'; tinres r r'\\<rbrakk>\n  \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n     steps0 (st, l', r') tp stp = (a', b', c'); tinres l l';\n     tinres r r'\\<rbrakk>\n    \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "proof(case_tac \"steps0 (st, l', r) tp stp\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n        steps0 (st, l', r') tp stp = (a', b', c'); tinres l l'; tinres r r';\n        steps0 (st, l', r) tp stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "fix aa ba ca"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n        steps0 (st, l', r') tp stp = (a', b', c'); tinres l l'; tinres r r';\n        steps0 (st, l', r) tp stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "assume h: \"steps0 (st, l, r) tp stp = (a, b, c)\" \n    \"steps0 (st, l', r') tp stp = (a', b', c')\"\n    \"tinres l l'\" \"tinres r r'\"\n    \"steps0 (st, l', r) tp stp = (aa, ba, ca)\""], ["proof (state)\nthis:\n  steps0 (st, l, r) tp stp = (a, b, c)\n  steps0 (st, l', r') tp stp = (a', b', c')\n  tinres l l'\n  tinres r r'\n  steps0 (st, l', r) tp stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n        steps0 (st, l', r') tp stp = (a', b', c'); tinres l l'; tinres r r';\n        steps0 (st, l', r) tp stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "have \"tinres b ba \\<and> c = ca \\<and> a = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinres b ba \\<and> c = ca \\<and> a = aa", "using h"], ["proof (prove)\nusing this:\n  steps0 (st, l, r) tp stp = (a, b, c)\n  steps0 (st, l', r') tp stp = (a', b', c')\n  tinres l l'\n  tinres r r'\n  steps0 (st, l', r) tp stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. tinres b ba \\<and> c = ca \\<and> a = aa", "apply(rule_tac tinres_steps1, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n        steps0 (st, l', r') tp stp = (a', b', c'); tinres l l'; tinres r r';\n        steps0 (st, l', r) tp stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "moreover"], ["proof (state)\nthis:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n        steps0 (st, l', r') tp stp = (a', b', c'); tinres l l'; tinres r r';\n        steps0 (st, l', r) tp stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "have \"b' = ba \\<and> tinres c' ca \\<and> a' =  aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' = ba \\<and> tinres c' ca \\<and> a' = aa", "using h"], ["proof (prove)\nusing this:\n  steps0 (st, l, r) tp stp = (a, b, c)\n  steps0 (st, l', r') tp stp = (a', b', c')\n  tinres l l'\n  tinres r r'\n  steps0 (st, l', r) tp stp = (aa, ba, ca)\n\ngoal (1 subgoal):\n 1. b' = ba \\<and> tinres c' ca \\<and> a' = aa", "apply(rule_tac tinres_steps2, auto intro: tinres_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  b' = ba \\<and> tinres c' ca \\<and> a' = aa\n\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>steps0 (st, l, r) tp stp = (a, b, c);\n        steps0 (st, l', r') tp stp = (a', b', c'); tinres l l'; tinres r r';\n        steps0 (st, l', r) tp stp = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> a = a' \\<and> tinres b b' \\<and> tinres c c'", "ultimately"], ["proof (chain)\npicking this:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n  b' = ba \\<and> tinres c' ca \\<and> a' = aa", "show \"?thesis\""], ["proof (prove)\nusing this:\n  tinres b ba \\<and> c = ca \\<and> a = aa\n  b' = ba \\<and> tinres c' ca \\<and> a' = aa\n\ngoal (1 subgoal):\n 1. a = a' \\<and> tinres b b' \\<and> tinres c c'", "apply(auto intro: tinres_commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a = a' \\<and> tinres b b' \\<and> tinres c c'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tape_normalize:\n  assumes \"\\<forall> stp. \\<not> is_final(steps0 (Suc 0, [Bk,Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)\"\n  shows   \"\\<forall> stp. \\<not> is_final (steps0 (Suc 0, Bk\\<up>(m), <[code tp, bl2wc (<lm>)]> @ Bk\\<up>(n)) t_utm stp)\"\n    (is \"\\<forall> stp. ?P stp\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final\n               (steps0\n                 (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n                 t_utm stp)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0\n                 (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n                 t_utm stp)", "fix stp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0\n                 (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n                 t_utm stp)", "from assms[rule_format,of stp]"], ["proof (chain)\npicking this:\n  \\<not> is_final\n          (steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)", "show \"?P stp\""], ["proof (prove)\nusing this:\n  \\<not> is_final\n          (steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp)\n\ngoal (1 subgoal):\n 1. \\<not> is_final\n            (steps0\n              (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n              t_utm stp)", "apply(case_tac \"steps0 (Suc 0, Bk\\<up>(m), <[code tp, bl2wc (<lm>)]> @ Bk\\<up>(n)) t_utm stp\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n                 t_utm stp =\n                (a, b, c);\n        \\<not> is_final\n                (steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm\n                  stp)\\<rbrakk>\n       \\<Longrightarrow> 0 < a", "apply(case_tac \"steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>steps0\n                 (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n                 t_utm stp =\n                (a, b, c);\n        0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> 0 < a", "apply(drule_tac inres_tape, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres (Bk \\<up> m) [Bk, Bk]\n 2. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> tinres (<[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n                          (<[code tp, bl2wc (<lm>)]>)", "apply(auto simp: tinres_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            Bk \\<up> m = Bk # Bk # Bk \\<up> n \\<or>\n                            [Bk, Bk] = Bk \\<up> m @ Bk \\<up> n", "apply(case_tac \"m > Suc (Suc 0)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            Bk \\<up> m = Bk # Bk # Bk \\<up> n \\<or>\n                            [Bk, Bk] = Bk \\<up> m @ Bk \\<up> n\n 2. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        \\<not> Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            Bk \\<up> m = Bk # Bk # Bk \\<up> n \\<or>\n                            [Bk, Bk] = Bk \\<up> m @ Bk \\<up> n", "apply(rule_tac x = \"m - Suc (Suc 0)\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> m =\n                         Bk # Bk # Bk \\<up> (m - Suc (Suc 0)) \\<or>\n                         [Bk, Bk] = Bk \\<up> m @ Bk \\<up> (m - Suc (Suc 0))\n 2. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        \\<not> Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            Bk \\<up> m = Bk # Bk # Bk \\<up> n \\<or>\n                            [Bk, Bk] = Bk \\<up> m @ Bk \\<up> n", "apply(case_tac m, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba ca nat.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        Suc 0 < nat; m = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> Suc nat =\n                         Bk # Bk # Bk \\<up> (nat - Suc 0) \\<or>\n                         [Bk, Bk] =\n                         Bk \\<up> Suc nat @ Bk \\<up> (nat - Suc 0)\n 2. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        \\<not> Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            Bk \\<up> m = Bk # Bk # Bk \\<up> n \\<or>\n                            [Bk, Bk] = Bk \\<up> m @ Bk \\<up> n", "apply(metis Suc_lessD Suc_pred replicate_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        \\<not> Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            Bk \\<up> m = Bk # Bk # Bk \\<up> n \\<or>\n                            [Bk, Bk] = Bk \\<up> m @ Bk \\<up> n", "apply(rule_tac x = \"2 - m\" in exI, simp add: replicate_add[THEN sym])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba ca.\n       \\<lbrakk>0 < aa;\n        steps0 (Suc 0, [Bk, Bk], <[code tp, bl2wc (<lm>)]>) t_utm stp =\n        (aa, ba, ca);\n        \\<not> Suc (Suc 0) < m\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> m = Bk # Bk # Bk \\<up> (2 - m) \\<or>\n                         [Bk, Bk] = Bk \\<up> 2", "apply(simp only: numeral_2_eq_2, simp add: replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> is_final\n          (steps0\n            (Suc 0, Bk \\<up> m, <[code tp, bl2wc (<lm>)]> @ Bk \\<up> n)\n            t_utm stp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tutm_uhalt: \n  \"\\<lbrakk>tm_wf (tp,0);\n    \\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <args>) tp stp))\\<rbrakk>\n  \\<Longrightarrow> \\<forall> stp. \\<not> is_final (steps0 (Suc 0, Bk\\<up>(m), <[code tp, bl2wc (<args>)]> @ Bk\\<up>(n)) t_utm stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <args>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>stp.\n                         \\<not> is_final\n                                 (steps0\n                                   (Suc 0, Bk \\<up> m,\n                                    <[code tp, bl2wc (<args>)]> @\n                                    Bk \\<up> n)\n                                   t_utm stp)", "apply(rule_tac tape_normalize)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tm_wf0 tp;\n     \\<forall>stp.\n        \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <args>) tp stp)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>stp.\n                         \\<not> is_final\n                                 (steps0\n                                   (Suc 0, [Bk, Bk],\n                                    <[code tp, bl2wc (<args>)]>)\n                                   t_utm stp)", "apply(rule_tac tutm_uhalt'[simplified], simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UTM_uhalt_lemma_pre:\n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and exec: \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <args>) tp stp))\"\n    and args: \"args \\<noteq> []\"\n  shows \"\\<forall> stp. \\<not> is_final (steps0 (Suc 0, [], <code tp # args>)  UTM_pre stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "let ?P1 = \"\\<lambda> (l, r). l = [] \\<and> r = <code tp # args>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "let ?Q1 = \"\\<lambda> (l, r). (l = [Bk] \\<and>\n             (\\<exists> rn. r = Oc\\<up>(Suc (code tp)) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "let ?P2 = ?Q1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "have \"{?P1} (t_wcode |+| t_utm) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>}\n    t_wcode |+| t_utm \\<up>", "proof(rule_tac Hoare_plus_unhalt)"], ["proof (state)\ngoal (3 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode {?Q}\n 2. {?Q} t_utm \\<up>\n 3. tm_wf0 t_wcode", "show \"tm_wf (t_wcode, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode", "by auto"], ["proof (state)\nthis:\n  tm_wf0 t_wcode\n\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode {?Q}\n 2. {?Q} t_utm \\<up>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode {?Q}\n 2. {?Q} t_utm \\<up>", "show \"{?P1} t_wcode {?Q1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode\n    {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}", "apply(rule_tac Hoare_haltI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <code tp # args>) t_wcode n) \\<and>\n       (\\<lambda>(l, r).\n           l = [Bk] \\<and>\n           (\\<exists>rn.\n               r =\n               Oc \\<up> Suc (code tp) @\n               Bk #\n               Oc \\<up> Suc (bl_bin (<args>)) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <code tp # args>)\n  t_wcode n", "using wcode_lemma_1[of args \"code tp\"] args"], ["proof (prove)\nusing this:\n  args \\<noteq> [] \\<Longrightarrow>\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <code tp # args>) t_wcode stp =\n     (0, [Bk],\n      Oc \\<up> Suc (code tp) @\n      Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final (steps0 (Suc 0, [], <code tp # args>) t_wcode n) \\<and>\n       (\\<lambda>(l, r).\n           l = [Bk] \\<and>\n           (\\<exists>rn.\n               r =\n               Oc \\<up> Suc (code tp) @\n               Bk #\n               Oc \\<up> Suc (bl_bin (<args>)) @\n               Bk \\<up> rn)) holds_for steps0 (Suc 0, [], <code tp # args>)\n  t_wcode n", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp rn.\n       \\<lbrakk>args \\<noteq> [];\n        steps0 (Suc 0, [], <code tp # args>) t_wcode stp =\n        (0, [Bk],\n         Oc \\<up> Suc (code tp) @\n         Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <code tp # args>) t_wcode\n                               n) \\<and>\n                            (\\<lambda>(l, r).\n                                l = [Bk] \\<and>\n                                (\\<exists>rn.\n                                    r =\n                                    Oc \\<up> Suc (code tp) @\n                                    Bk #\n                                    Oc \\<up> Suc (bl_bin (<args>)) @\n                                    Bk \\<up> rn)) holds_for steps0\n                       (Suc 0, [], <code tp # args>) t_wcode n", "by (metis (mono_tags, lifting) holds_for.simps is_finalI old.prod.case)"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>} t_wcode\n  {\\<lambda>(l, r).\n      l = [Bk] \\<and>\n      (\\<exists>rn.\n          r =\n          Oc \\<up> Suc (code tp) @\n          Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm \\<up>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm \\<up>", "show \"{?P2} t_utm \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code tp) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm \\<up>", "proof(rule_tac Hoare_unhaltI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n rn.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc \\<up> Suc (code tp) @\n           Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n          t_utm n) \\<Longrightarrow>\n       False", "fix n rn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n rn.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc \\<up> Suc (code tp) @\n           Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n          t_utm n) \\<Longrightarrow>\n       False", "assume h: \"is_final (steps0 (Suc 0, [Bk], Oc \\<up> Suc (code tp) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn) t_utm n)\""], ["proof (state)\nthis:\n  is_final\n   (steps0\n     (Suc 0, [Bk],\n      Oc \\<up> Suc (code tp) @\n      Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n     t_utm n)\n\ngoal (1 subgoal):\n 1. \\<And>n rn.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc \\<up> Suc (code tp) @\n           Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n          t_utm n) \\<Longrightarrow>\n       False", "have \"\\<forall> stp. \\<not> is_final (steps0 (Suc 0, Bk\\<up>(Suc 0), <[code tp, bl2wc (<args>)]> @ Bk\\<up>(rn)) t_utm stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final\n               (steps0\n                 (Suc 0, Bk \\<up> Suc 0,\n                  <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n                 t_utm stp)", "using assms"], ["proof (prove)\nusing this:\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <args>) tp stp)\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final\n               (steps0\n                 (Suc 0, Bk \\<up> Suc 0,\n                  <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n                 t_utm stp)", "apply(rule_tac tutm_uhalt, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>stp.\n     \\<not> is_final\n             (steps0\n               (Suc 0, Bk \\<up> Suc 0,\n                <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n               t_utm stp)\n\ngoal (1 subgoal):\n 1. \\<And>n rn.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc \\<up> Suc (code tp) @\n           Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n          t_utm n) \\<Longrightarrow>\n       False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<forall>stp.\n     \\<not> is_final\n             (steps0\n               (Suc 0, Bk \\<up> Suc 0,\n                <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n               t_utm stp)\n\ngoal (1 subgoal):\n 1. False", "using h"], ["proof (prove)\nusing this:\n  \\<forall>stp.\n     \\<not> is_final\n             (steps0\n               (Suc 0, Bk \\<up> Suc 0,\n                <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n               t_utm stp)\n  is_final\n   (steps0\n     (Suc 0, [Bk],\n      Oc \\<up> Suc (code tp) @\n      Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n     t_utm n)\n\ngoal (1 subgoal):\n 1. False", "apply(erule_tac x = n in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_final\n              (steps0\n                (Suc 0, [Bk],\n                 Oc \\<up> Suc (code tp) @\n                 Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n                t_utm n);\n     \\<not> is_final\n             (steps0\n               (Suc 0, Bk \\<up> Suc 0,\n                <[code tp, bl2wc (<args>)]> @ Bk \\<up> rn)\n               t_utm n)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp add: tape_of_list_def bin_wc_eq tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r).\n      l = [Bk] \\<and>\n      (\\<exists>rn.\n          r =\n          Oc \\<up> Suc (code tp) @\n          Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n  t_utm \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>}\n  t_wcode |+| t_utm \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code tp # args>}\n  t_wcode |+| t_utm \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)", "apply(simp add: Hoare_unhalt_def UTM_pre_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>stp.\n     \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM_pre stp)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The correctness of \\<open>UTM\\<close>, the unhalt case.\n\\<close>"], ["", "lemma UTM_uhalt_lemma':\n  assumes tm_wf: \"tm_wf (tp, 0)\"\n    and unhalt: \"\\<forall> stp. (\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(l), <args>) tp stp))\"\n    and args: \"args \\<noteq> []\"\n  shows \" \\<forall> stp. \\<not> is_final (steps0 (Suc 0, [], <code tp # args>)  UTM stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM stp)", "using UTM_uhalt_lemma_pre[of tp l args] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>tm_wf0 tp;\n   \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <args>) tp stp);\n   args \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<forall>stp.\n                       \\<not> is_final\n                               (steps0 (Suc 0, [], <code tp # args>) UTM_pre\n                                 stp)\n  tm_wf0 tp\n  \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <args>) tp stp)\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code tp # args>) UTM stp)", "apply(simp add: UTM_pre_def t_utm_def UTM_def F_aprog_def F_tprog_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>stp.\n                \\<not> is_final\n                        (steps0 (Suc 0, [], <code tp # args>)\n                          (t_wcode |+| tm_of\n  (case rec_ci rec_F of\n   (aprog, rs_pos, a_md) \\<Rightarrow> aprog [+] dummy_abc (Suc (Suc 0))) @\n shift (mopup (Suc (Suc 0)))\n  (length\n    (tm_of\n      (case rec_ci rec_F of\n       (aprog, rs_pos, a_md) \\<Rightarrow>\n         aprog [+] dummy_abc (Suc (Suc 0)))) div\n   2))\n                          stp);\n     tm_wf0 tp;\n     \\<forall>stp. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> l, <args>) tp stp);\n     args \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>stp.\n                         \\<not> is_final\n                                 (steps0 (Suc 0, [], <code tp # args>)\n                                   (case rec_ci rec_F of\n                                    (aprog, rs_pos, a_md) \\<Rightarrow>\nt_wcode |+| tm_of (aprog [+] dummy_abc (Suc (Suc 0))) @\n            shift (mopup (Suc (Suc 0)))\n             (length (tm_of (aprog [+] dummy_abc (Suc (Suc 0)))) div 2))\n                                   stp)", "apply(case_tac \"rec_ci rec_F\", simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma UTM_halt_lemma:\n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and resut: \"rs > 0\"\n    and args: \"(args::nat list) \\<noteq> []\"\n    and exec: \"{(\\<lambda>tp. tp = (Bk\\<up>i, <args>))} p {(\\<lambda>tp. tp = (Bk\\<up>m, Oc\\<up>rs @ Bk\\<up>k))}\" \n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM {(\\<lambda>tp. (\\<exists> m n. tp = (Bk\\<up>m, Oc\\<up>rs @ Bk\\<up>n)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "let ?steps0 = \"steps0 (Suc 0, [], <code p # args>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "let ?stepsBk = \"steps0 (Suc 0, Bk\\<up>i, <args>) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "from wcode_lemma_1[OF args,of \"code p\"]"], ["proof (chain)\npicking this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <code p # args>) t_wcode stp =\n     (0, [Bk],\n      Oc \\<up> Suc (code p) @\n      Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)", "obtain stp ln rn where\n    wcl1:\"?steps0 t_wcode stp =\n     (0, [Bk], Oc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\""], ["proof (prove)\nusing this:\n  \\<exists>stp ln rn.\n     steps0 (Suc 0, [], <code p # args>) t_wcode stp =\n     (0, [Bk],\n      Oc \\<up> Suc (code p) @\n      Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. (\\<And>stp rn.\n        steps0 (Suc 0, [], <code p # args>) t_wcode stp =\n        (0, [Bk],\n         Oc \\<up> Suc (code p) @\n         Bk #\n         Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  steps0 (Suc 0, [], <code p # args>) t_wcode stp =\n  (0, [Bk],\n   Oc \\<up> Suc (code p) @\n   Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "from exec Hoare_halt_def"], ["proof (chain)\npicking this:\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\n  {?P} ?p {?Q} \\<equiv>\n  \\<forall>tp.\n     ?P tp \\<longrightarrow>\n     (\\<exists>n.\n         is_final (steps0 (1, tp) ?p n) \\<and>\n         ?Q holds_for steps0 (1, tp) ?p n)", "obtain n where\n    n:\"{\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\"\n    \"is_final (?stepsBk n)\"\n    \"(\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)) holds_for steps0 (Suc 0, Bk \\<up> i, <args>) p n\""], ["proof (prove)\nusing this:\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\n  {?P} ?p {?Q} \\<equiv>\n  \\<forall>tp.\n     ?P tp \\<longrightarrow>\n     (\\<exists>n.\n         is_final (steps0 (1, tp) ?p n) \\<and>\n         ?Q holds_for steps0 (1, tp) ?p n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>{\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n                 {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)};\n         is_final (steps0 (Suc 0, Bk \\<up> i, <args>) p n);\n         (\\<lambda>tp.\n             tp =\n             (Bk \\<up> m,\n              Oc \\<up> rs @\n              Bk \\<up> k)) holds_for steps0 (Suc 0, Bk \\<up> i, <args>) p\nn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\n  is_final (steps0 (Suc 0, Bk \\<up> i, <args>) p n)\n  (\\<lambda>tp.\n      tp =\n      (Bk \\<up> m,\n       Oc \\<up> rs @\n       Bk \\<up> k)) holds_for steps0 (Suc 0, Bk \\<up> i, <args>) p n\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "obtain a where a:\"a = fst (rec_ci rec_F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        a = fst (rec_ci rec_F) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = fst (rec_ci rec_F)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "have \"{(\\<lambda> (l, r). l = [] \\<and> r = <code p # args>)} (t_wcode |+| t_utm)\n          {(\\<lambda> (l, r). (\\<exists> m. l = Bk\\<up>m) \\<and> (\\<exists> n. r = Oc\\<up>rs @ Bk\\<up>n))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode |+| t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}", "proof(rule_tac Hoare_plus_halt)"], ["proof (state)\ngoal (3 subgoals):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode {?Q}\n 2. {?Q} t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n 3. tm_wf0 t_wcode", "show \"{\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode {\\<lambda> (l, r). (l = [Bk] \\<and>\n    (\\<exists> rn. r = Oc\\<up>(Suc (code p)) @ Bk # Oc\\<up>(Suc (bl_bin (<args>))) @ Bk\\<up>(rn)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode\n    {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}", "using wcl1"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, [], <code p # args>) t_wcode stp =\n  (0, [Bk],\n   Oc \\<up> Suc (code p) @\n   Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode\n    {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}", "by (auto intro!:Hoare_haltI exI[of _ stp])"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode\n  {\\<lambda>(l, r).\n      l = [Bk] \\<and>\n      (\\<exists>rn.\n          r =\n          Oc \\<up> Suc (code p) @\n          Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n 2. tm_wf0 t_wcode", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n 2. tm_wf0 t_wcode", "have \"\\<exists> stp. (?stepsBk stp = (0, Bk\\<up>m, Oc\\<up>rs @ Bk\\<up>k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)", "using n"], ["proof (prove)\nusing this:\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\n  is_final (steps0 (Suc 0, Bk \\<up> i, <args>) p n)\n  (\\<lambda>tp.\n      tp =\n      (Bk \\<up> m,\n       Oc \\<up> rs @\n       Bk \\<up> k)) holds_for steps0 (Suc 0, Bk \\<up> i, <args>) p n\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)", "by (case_tac \"?stepsBk n\", auto)"], ["proof (state)\nthis:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n 2. tm_wf0 t_wcode", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)", "obtain stp where k: \"steps0 (Suc 0, Bk\\<up>i, <args>) p stp = (0, Bk\\<up>m, Oc\\<up>rs @ Bk\\<up>k)\""], ["proof (prove)\nusing this:\n  \\<exists>stp.\n     steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n        (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (2 subgoals):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n 2. tm_wf0 t_wcode", "thus \"{\\<lambda>(l, r). l = [Bk] \\<and> (\\<exists>rn. r = Oc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n      t_utm {\\<lambda>(l, r). (\\<exists>m. l = Bk \\<up> m) \\<and> (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. {\\<lambda>(l, r).\n        l = [Bk] \\<and>\n        (\\<exists>rn.\n            r =\n            Oc \\<up> Suc (code p) @\n            Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n    t_utm\n    {\\<lambda>(l, r).\n        (\\<exists>m. l = Bk \\<up> m) \\<and>\n        (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}", "proof(rule_tac Hoare_haltI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k) \\<Longrightarrow>\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, [Bk],\n              Oc \\<up> Suc (code p) @\n              Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n             t_utm n) \\<and>\n          (\\<lambda>(l, r).\n              (\\<exists>m. l = Bk \\<up> m) \\<and>\n              (\\<exists>n.\n                  r =\n                  Oc \\<up> rs @\n                  Bk \\<up> n)) holds_for steps0\n    (Suc 0, [Bk],\n     Oc \\<up> Suc (code p) @\n     Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n    t_utm n", "fix rn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>rn.\n       steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k) \\<Longrightarrow>\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, [Bk],\n              Oc \\<up> Suc (code p) @\n              Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n             t_utm n) \\<and>\n          (\\<lambda>(l, r).\n              (\\<exists>m. l = Bk \\<up> m) \\<and>\n              (\\<exists>n.\n                  r =\n                  Oc \\<up> rs @\n                  Bk \\<up> n)) holds_for steps0\n    (Suc 0, [Bk],\n     Oc \\<up> Suc (code p) @\n     Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n    t_utm n", "from t_utm_halt_eq[OF assms(1) k assms(2),of rn] assms k"], ["proof (chain)\npicking this:\n  \\<exists>stp m n.\n     steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n      stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 p\n  0 < rs\n  args \\<noteq> []\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\n  steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)", "have \"\\<exists> ma n stp. steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm stp =\n       (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> n)\""], ["proof (prove)\nusing this:\n  \\<exists>stp m n.\n     steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n      stp =\n     (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)\n  tm_wf0 p\n  0 < rs\n  args \\<noteq> []\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)}\n  steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n  (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>ma n stp.\n       steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n        stp =\n       (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> n)", "by (auto simp add: bin_wc_eq)"], ["proof (state)\nthis:\n  \\<exists>ma n stp.\n     steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n      stp =\n     (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. \\<And>rn.\n       steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k) \\<Longrightarrow>\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, [Bk],\n              Oc \\<up> Suc (code p) @\n              Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n             t_utm n) \\<and>\n          (\\<lambda>(l, r).\n              (\\<exists>m. l = Bk \\<up> m) \\<and>\n              (\\<exists>n.\n                  r =\n                  Oc \\<up> rs @\n                  Bk \\<up> n)) holds_for steps0\n    (Suc 0, [Bk],\n     Oc \\<up> Suc (code p) @\n     Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n    t_utm n", "then"], ["proof (chain)\npicking this:\n  \\<exists>ma n stp.\n     steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n      stp =\n     (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> n)", "obtain stpx m' n' where\n        t:\"steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm stpx =\n       (0, Bk \\<up> m', Oc \\<up> rs @ Bk \\<up> n')\""], ["proof (prove)\nusing this:\n  \\<exists>ma n stp.\n     steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n      stp =\n     (0, Bk \\<up> ma, Oc \\<up> rs @ Bk \\<up> n)\n\ngoal (1 subgoal):\n 1. (\\<And>stpx m' n'.\n        steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n         stpx =\n        (0, Bk \\<up> m', Oc \\<up> rs @ Bk \\<up> n') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n   stpx =\n  (0, Bk \\<up> m', Oc \\<up> rs @ Bk \\<up> n')\n\ngoal (1 subgoal):\n 1. \\<And>rn.\n       steps0 (Suc 0, Bk \\<up> i, <args>) p stp =\n       (0, Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> k) \\<Longrightarrow>\n       \\<exists>n.\n          is_final\n           (steps0\n             (Suc 0, [Bk],\n              Oc \\<up> Suc (code p) @\n              Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n             t_utm n) \\<and>\n          (\\<lambda>(l, r).\n              (\\<exists>m. l = Bk \\<up> m) \\<and>\n              (\\<exists>n.\n                  r =\n                  Oc \\<up> rs @\n                  Bk \\<up> n)) holds_for steps0\n    (Suc 0, [Bk],\n     Oc \\<up> Suc (code p) @\n     Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n    t_utm n", "show \"\\<exists>n. is_final (steps0 (Suc 0, [Bk], Oc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn) t_utm n) \\<and>\n             (\\<lambda>(l, r). (\\<exists>m. l = Bk \\<up> m) \\<and> (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)) holds_for steps0 \n         (Suc 0, [Bk], Oc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn) t_utm n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc \\<up> Suc (code p) @\n           Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n          t_utm n) \\<and>\n       (\\<lambda>(l, r).\n           (\\<exists>m. l = Bk \\<up> m) \\<and>\n           (\\<exists>n.\n               r =\n               Oc \\<up> rs @\n               Bk \\<up> n)) holds_for steps0\n (Suc 0, [Bk],\n  Oc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n t_utm n", "using t"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, [Bk], <[code p, bl2wc (<args>)]> @ Bk \\<up> rn) t_utm\n   stpx =\n  (0, Bk \\<up> m', Oc \\<up> rs @ Bk \\<up> n')\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       is_final\n        (steps0\n          (Suc 0, [Bk],\n           Oc \\<up> Suc (code p) @\n           Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n          t_utm n) \\<and>\n       (\\<lambda>(l, r).\n           (\\<exists>m. l = Bk \\<up> m) \\<and>\n           (\\<exists>n.\n               r =\n               Oc \\<up> rs @\n               Bk \\<up> n)) holds_for steps0\n (Suc 0, [Bk],\n  Oc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n t_utm n", "by(auto simp: bin_wc_eq tape_of_list_def tape_of_nat_def intro:exI[of _ stpx])"], ["proof (state)\nthis:\n  \\<exists>n.\n     is_final\n      (steps0\n        (Suc 0, [Bk],\n         Oc \\<up> Suc (code p) @\n         Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n        t_utm n) \\<and>\n     (\\<lambda>(l, r).\n         (\\<exists>m. l = Bk \\<up> m) \\<and>\n         (\\<exists>n.\n             r =\n             Oc \\<up> rs @\n             Bk \\<up> n)) holds_for steps0\n                                     (Suc 0, [Bk],\nOc \\<up> Suc (code p) @ Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)\n                                     t_utm n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r).\n      l = [Bk] \\<and>\n      (\\<exists>rn.\n          r =\n          Oc \\<up> Suc (code p) @\n          Bk # Oc \\<up> Suc (bl_bin (<args>)) @ Bk \\<up> rn)}\n  t_utm\n  {\\<lambda>(l, r).\n      (\\<exists>m. l = Bk \\<up> m) \\<and>\n      (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode", "show \"tm_wf0 t_wcode\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 t_wcode", "by auto"], ["proof (state)\nthis:\n  tm_wf0 t_wcode\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode |+| t_utm\n  {\\<lambda>(l, r).\n      (\\<exists>m. l = Bk \\<up> m) \\<and>\n      (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "then"], ["proof (chain)\npicking this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode |+| t_utm\n  {\\<lambda>(l, r).\n      (\\<exists>m. l = Bk \\<up> m) \\<and>\n      (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}", "obtain n where\n    \"is_final (?steps0 (t_wcode |+| t_utm) n)\" \n    \"(\\<lambda>(l, r). (\\<exists>m. l = Bk \\<up> m) \\<and>\n           (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)) holds_for ?steps0 (t_wcode |+| t_utm) n\""], ["proof (prove)\nusing this:\n  {\\<lambda>(l, r). l = [] \\<and> r = <code p # args>} t_wcode |+| t_utm\n  {\\<lambda>(l, r).\n      (\\<exists>m. l = Bk \\<up> m) \\<and>\n      (\\<exists>n. r = Oc \\<up> rs @ Bk \\<up> n)}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>is_final\n                  (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm)\n                    n);\n         (\\<lambda>(l, r).\n             (\\<exists>m. l = Bk \\<up> m) \\<and>\n             (\\<exists>n.\n                 r =\n                 Oc \\<up> rs @\n                 Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n   (t_wcode |+| t_utm) n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: Hoare_halt_def a)"], ["proof (state)\nthis:\n  is_final (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm) n)\n  (\\<lambda>(l, r).\n      (\\<exists>m. l = Bk \\<up> m) \\<and>\n      (\\<exists>n.\n          r =\n          Oc \\<up> rs @\n          Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n                                  (t_wcode |+| t_utm) n\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  is_final (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm) n)\n  (\\<lambda>(l, r).\n      (\\<exists>m. l = Bk \\<up> m) \\<and>\n      (\\<exists>n.\n          r =\n          Oc \\<up> rs @\n          Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n                                  (t_wcode |+| t_utm) n\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "apply(case_tac \"rec_ci rec_F\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>is_final\n                 (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm)\n                   n);\n        (\\<lambda>(l, r).\n            (\\<exists>m. l = Bk \\<up> m) \\<and>\n            (\\<exists>n.\n                r =\n                Oc \\<up> rs @\n                Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n  (t_wcode |+| t_utm) n;\n        rec_ci rec_F = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n                         {\\<lambda>tp.\n                             \\<exists>m n.\n                                tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}", "apply(auto simp add: UTM_def Hoare_halt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>is_final\n                 (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm)\n                   n);\n        (\\<lambda>(l, r).\n            (\\<exists>m. l = Bk \\<up> m) \\<and>\n            (\\<exists>n.\n                r =\n                Oc \\<up> rs @\n                Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n  (t_wcode |+| t_utm) n;\n        rec_ci rec_F = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <code p # args>)\n                               (t_wcode |+| tm_of\n       (a [+] dummy_abc (Suc (Suc 0))) @\n      shift (mopup (Suc (Suc 0)))\n       (length (tm_of (a [+] dummy_abc (Suc (Suc 0)))) div 2))\n                               n) \\<and>\n                            (\\<lambda>tp.\n                                \\<exists>m n.\n                                   tp =\n                                   (Bk \\<up> m,\n                                    Oc \\<up> rs @\n                                    Bk \\<up> n)) holds_for steps0\n                      (Suc 0, [], <code p # args>)\n                      (t_wcode |+| tm_of (a [+] dummy_abc (Suc (Suc 0))) @\n                                   shift (mopup (Suc (Suc 0)))\n                                    (length\n(tm_of (a [+] dummy_abc (Suc (Suc 0)))) div\n                                     2))\n                      n", "apply(case_tac \"(?steps0 (t_wcode |+| t_utm) n)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>is_final\n                 (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm)\n                   n);\n        (\\<lambda>(l, r).\n            (\\<exists>m. l = Bk \\<up> m) \\<and>\n            (\\<exists>n.\n                r =\n                Oc \\<up> rs @\n                Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n  (t_wcode |+| t_utm) n;\n        rec_ci rec_F = (a, b, c);\n        steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm) n =\n        (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            is_final\n                             (steps0 (Suc 0, [], <code p # args>)\n                               (t_wcode |+| tm_of\n       (a [+] dummy_abc (Suc (Suc 0))) @\n      shift (mopup (Suc (Suc 0)))\n       (length (tm_of (a [+] dummy_abc (Suc (Suc 0)))) div 2))\n                               n) \\<and>\n                            (\\<lambda>tp.\n                                \\<exists>m n.\n                                   tp =\n                                   (Bk \\<up> m,\n                                    Oc \\<up> rs @\n                                    Bk \\<up> n)) holds_for steps0\n                      (Suc 0, [], <code p # args>)\n                      (t_wcode |+| tm_of (a [+] dummy_abc (Suc (Suc 0))) @\n                                   shift (mopup (Suc (Suc 0)))\n                                    (length\n(tm_of (a [+] dummy_abc (Suc (Suc 0)))) div\n                                     2))\n                      n", "apply(rule_tac x=\"n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba ca.\n       \\<lbrakk>is_final\n                 (steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm)\n                   n);\n        (\\<lambda>(l, r).\n            (\\<exists>m. l = Bk \\<up> m) \\<and>\n            (\\<exists>n.\n                r =\n                Oc \\<up> rs @\n                Bk \\<up> n)) holds_for steps0 (Suc 0, [], <code p # args>)\n  (t_wcode |+| t_utm) n;\n        rec_ci rec_F = (a, b, c);\n        steps0 (Suc 0, [], <code p # args>) (t_wcode |+| t_utm) n =\n        (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> is_final\n                          (steps0 (Suc 0, [], <code p # args>)\n                            (t_wcode |+| tm_of\n    (a [+] dummy_abc (Suc (Suc 0))) @\n   shift (mopup (Suc (Suc 0)))\n    (length (tm_of (a [+] dummy_abc (Suc (Suc 0)))) div 2))\n                            n) \\<and>\n                         (\\<lambda>tp.\n                             \\<exists>m n.\n                                tp =\n                                (Bk \\<up> m,\n                                 Oc \\<up> rs @\n                                 Bk \\<up> n)) holds_for steps0\n                   (Suc 0, [], <code p # args>)\n                   (t_wcode |+| tm_of (a [+] dummy_abc (Suc (Suc 0))) @\n                                shift (mopup (Suc (Suc 0)))\n                                 (length\n                                   (tm_of\n                                     (a [+] dummy_abc (Suc (Suc 0)))) div\n                                  2))\n                   n", "apply(auto simp add:a t_utm_def F_aprog_def F_tprog_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n  {\\<lambda>tp. \\<exists>m n. tp = (Bk \\<up> m, Oc \\<up> rs @ Bk \\<up> n)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UTM_halt_lemma2:\n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and args: \"(args::nat list) \\<noteq> []\"\n    and exec: \"{(\\<lambda>tp. tp = ([], <args>))} p {(\\<lambda>tp. tp = (Bk\\<up>m, <(n::nat)> @ Bk\\<up>k))}\" \n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM {(\\<lambda>tp. (\\<exists> m k. tp = (Bk\\<up>m, <n> @ Bk\\<up>k)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m k. tp = (Bk \\<up> m, <n> @ Bk \\<up> k)}", "using UTM_halt_lemma[OF assms(1) _ assms(2), where i=\"0\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?rs;\n   {\\<lambda>tp. tp = (Bk \\<up> 0, <args>)} p\n   {\\<lambda>tp. tp = (Bk \\<up> ?m, Oc \\<up> ?rs @ Bk \\<up> ?k)}\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n                    {\\<lambda>tp.\n                        \\<exists>m n.\n                           tp = (Bk \\<up> m, Oc \\<up> ?rs @ Bk \\<up> n)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m k. tp = (Bk \\<up> m, <n> @ Bk \\<up> k)}", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?rs;\n   {\\<lambda>tp. tp = (Bk \\<up> 0, <args>)} p\n   {\\<lambda>tp. tp = (Bk \\<up> ?m, Oc \\<up> ?rs @ Bk \\<up> ?k)}\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n                    {\\<lambda>tp.\n                        \\<exists>m n.\n                           tp = (Bk \\<up> m, Oc \\<up> ?rs @ Bk \\<up> n)}\n  {\\<lambda>tp. tp = ([], <args>)} p\n  {\\<lambda>tp. tp = (Bk \\<up> m, <n> @ Bk \\<up> k)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM\n    {\\<lambda>tp. \\<exists>m k. tp = (Bk \\<up> m, <n> @ Bk \\<up> k)}", "by(simp add: tape_of_nat_def)"], ["", "lemma UTM_unhalt_lemma: \n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and unhalt: \"{(\\<lambda>tp. tp = (Bk\\<up>i, <args>))} p \\<up>\"\n    and args: \"args \\<noteq> []\"\n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "have \"(\\<not> TSTD (steps0 (Suc 0, Bk\\<up>(i), <args>) p stp))\" for stp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p stp)", "(* in unhalt, we substitute inner 'forall' n\\<rightarrow>stp *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p stp)", "using unhalt[unfolded Hoare_unhalt_def,rule_format,OF refl,of stp]"], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, Bk \\<up> i, <args>) p stp)\n\ngoal (1 subgoal):\n 1. \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p stp)", "by(cases \"steps0 (Suc 0, Bk \\<up> i, <args>) p stp\",auto simp: Hoare_unhalt_def TSTD_def)"], ["proof (state)\nthis:\n  \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p ?stp)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "then"], ["proof (chain)\npicking this:\n  \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p ?stp)", "have \"\\<forall> stp. \\<not> is_final (steps0 (Suc 0, [], <code p # args>)  UTM stp)\""], ["proof (prove)\nusing this:\n  \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p ?stp)\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code p # args>) UTM stp)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> TSTD (steps0 (Suc 0, Bk \\<up> i, <args>) p ?stp)\n  tm_wf0 p\n  {\\<lambda>tp. tp = (Bk \\<up> i, <args>)} p \\<up>\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (Suc 0, [], <code p # args>) UTM stp)", "by(intro UTM_uhalt_lemma', auto)"], ["proof (state)\nthis:\n  \\<forall>stp.\n     \\<not> is_final (steps0 (Suc 0, [], <code p # args>) UTM stp)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<forall>stp.\n     \\<not> is_final (steps0 (Suc 0, [], <code p # args>) UTM stp)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "by(simp add: Hoare_unhalt_def)"], ["proof (state)\nthis:\n  {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UTM_unhalt_lemma2: \n  assumes tm_wf: \"tm_wf (p, 0)\"\n    and unhalt: \"{(\\<lambda>tp. tp = ([], <args>))} p \\<up>\"\n    and args: \"args \\<noteq> []\"\n  shows \"{(\\<lambda>tp. tp = ([], <code p # args>))} UTM \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "using UTM_unhalt_lemma[OF assms(1), where i=\"0\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{\\<lambda>tp. tp = (Bk \\<up> 0, <?args>)} p \\<up>;\n   ?args \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda>tp. tp = ([], <code p # ?args>)} UTM \\<up>\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "using assms(2-3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>{\\<lambda>tp. tp = (Bk \\<up> 0, <?args>)} p \\<up>;\n   ?args \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> {\\<lambda>tp. tp = ([], <code p # ?args>)} UTM \\<up>\n  {\\<lambda>tp. tp = ([], <args>)} p \\<up>\n  args \\<noteq> []\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], <code p # args>)} UTM \\<up>", "by(simp add: tape_of_nat_def)"], ["", "end"]]}