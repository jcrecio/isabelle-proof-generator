{"file_name": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine/Abacus.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine", "problem_names": ["lemma length_findnth: \n  \"length (findnth n) = 4 * n\"", "lemma ci_length : \"length (ci ns n ai) div 2 = length_of ai\"", "lemma start_of_nonzero[simp]: \"start_of ly as > 0\" \"(start_of ly as = 0) = False\"", "lemma abc_steps_l_0: \"abc_steps_l ac ap 0 = ac\"", "lemma abc_step_red: \n  \"abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow> \n  abc_steps_l (as, am) ap (Suc stp) = abc_step_l (bs, bm) (abc_fetch bs ap) \"", "lemma tm_shift_fetch: \n  \"\\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0 \\<rbrakk>\n  \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)\"", "lemma tm_shift_eq_step:\n  assumes exec: \"step (s, l, r) (A, 0) = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"step (s + off, l, r) (shift A off, off) = (s' + off, l', r')\"", "lemma tm_shift_eq_steps: \n  assumes exec: \"steps (s, l, r) (A, 0) stp = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"steps (s + off, l, r) (shift A off, off) stp = (s' + off, l', r')\"", "lemma startof_ge1[simp]: \"Suc 0 \\<le> start_of ly as\"", "lemma start_of_Suc1: \"\\<lbrakk>ly = layout_of ap; \n       abc_fetch as ap = Some (Inc n)\\<rbrakk>\n       \\<Longrightarrow> start_of ly (Suc as) = start_of ly as + 2 * n + 9\"", "lemma start_of_Suc2:\n  \"\\<lbrakk>ly = layout_of ap;\n  abc_fetch as ap = Some (Dec n e)\\<rbrakk> \\<Longrightarrow> \n        start_of ly (Suc as) = \n            start_of ly as + 2 * n + 16\"", "lemma start_of_Suc3:\n  \"\\<lbrakk>ly = layout_of ap;\n  abc_fetch as ap = Some (Goto n)\\<rbrakk> \\<Longrightarrow> \n  start_of ly (Suc as) = start_of ly as + 1\"", "lemma length_ci_inc: \n  \"length (ci ly ss (Inc n)) = 4*n + 18\"", "lemma length_ci_dec: \n  \"length (ci ly ss (Dec n e)) = 4*n + 32\"", "lemma length_ci_goto: \n  \"length (ci ly ss (Goto n )) = 2\"", "lemma take_Suc_last[elim]: \"Suc as \\<le> length xs \\<Longrightarrow> \n            take (Suc as) xs = take as xs @ [xs ! as]\"", "lemma concat_suc: \"Suc as \\<le> length xs \\<Longrightarrow> \n       concat (take (Suc as) xs) = concat (take as xs) @ xs! as\"", "lemma concat_drop_suc_iff: \n  \"Suc n < length tps \\<Longrightarrow> concat (drop (Suc n) tps) = \n           tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\"", "lemma  tm_append:\n  \"\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk> \\<Longrightarrow> \n  \\<exists> tp1 tp2. concat tps = tp1 @ tp @ tp2 \\<and> tp1 = \n  concat (take n tps) \\<and> tp2 = concat (drop (Suc n) tps)\"", "lemma length_tms_of[simp]: \"length (tms_of aprog) = length aprog\"", "lemma ci_nth: \n  \"\\<lbrakk>ly = layout_of aprog; \n  abc_fetch as aprog = Some ins\\<rbrakk>\n  \\<Longrightarrow> ci ly (start_of ly as) ins = tms_of aprog ! as\"", "lemma t_split:\"\\<lbrakk>\n        ly = layout_of aprog;\n        abc_fetch as aprog = Some ins\\<rbrakk>\n      \\<Longrightarrow> \\<exists> tp1 tp2. concat (tms_of aprog) = \n            tp1 @ (ci ly (start_of ly as) ins) @ tp2\n            \\<and> tp1 = concat (take as (tms_of aprog)) \\<and> \n              tp2 = concat (drop (Suc as) (tms_of aprog))\"", "lemma div_apart: \"\\<lbrakk>x mod (2::nat) = 0; y mod 2 = 0\\<rbrakk> \n          \\<Longrightarrow> (x + y) div 2 = x div 2 + y div 2\"", "lemma length_layout_of[simp]: \"length (layout_of aprog) = length aprog\"", "lemma length_tms_of_elem_even[intro]:  \"n < length ap \\<Longrightarrow> length (tms_of ap ! n) mod 2 = 0\"", "lemma compile_mod2: \"length (concat (take n (tms_of ap))) mod 2 = 0\"", "lemma tpa_states:\n  \"\\<lbrakk>tp = concat (take as (tms_of ap));\n  as \\<le> length ap\\<rbrakk> \\<Longrightarrow> \n  start_of (layout_of ap) as = Suc (length tp div 2)\"", "lemma append_append_fetch: \n  \"\\<lbrakk>length tp1 mod 2 = 0; length tp mod 2 = 0;\n      length tp1 div 2 < a \\<and> a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow>fetch (tp1 @ tp @ tp2) a b = fetch tp (a - length tp1 div 2) b \"", "lemma step_eq_fetch':\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and fetch: \"abc_fetch as ap = Some ins\"\n    and range1: \"s \\<ge> start_of ly as\"\n    and range2: \"s < start_of ly (Suc as)\"\n  shows \"fetch tp s b = fetch (ci ly (start_of ly as) ins)\n       (Suc s - start_of ly as) b \"", "lemma step_eq_fetch: \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and abc_fetch: \"abc_fetch as ap = Some ins\" \n    and fetch: \"fetch (ci ly (start_of ly as) ins)\n       (Suc s - start_of ly as) b = (ac, ns)\"\n    and notfinal: \"ns \\<noteq> 0\"\n  shows \"fetch tp s b = (ac, ns)\"", "lemma step_eq_in:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and fetch: \"abc_fetch as ap = Some ins\"    \n    and exec: \"step (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) \n  = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"step (s, l, r) (tp, 0) = (s', l', r')\"", "lemma steps_eq_in:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some ins\"    \n    and exec: \"steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp \n  = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"steps (s, l, r) (tp, 0) stp = (s', l', r')\"", "lemma tm_append_fetch_first: \n  \"\\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0\\<rbrakk> \\<Longrightarrow> \n    fetch (A @ B) s b = (ac, ns)\"", "lemma tm_append_first_step_eq: \n  assumes \"step (s, l, r) (A, off) = (s', l', r')\"\n    and \"s' \\<noteq> 0\"\n  shows \"step (s, l, r) (A @ B, off) = (s', l', r')\"", "lemma tm_append_first_steps_eq: \n  assumes \"steps (s, l, r) (A, off) stp = (s', l', r')\"\n    and \"s' \\<noteq> 0\"\n  shows \"steps (s, l, r) (A @ B, off) stp = (s', l', r')\"", "lemma tm_append_second_fetch_eq:\n  assumes\n    even: \"length A mod 2 = 0\"\n    and off: \"off = length A div 2\"\n    and fetch: \"fetch B s b = (ac, ns)\"\n    and notfinal: \"ns \\<noteq> 0\"\n  shows \"fetch (A @ shift B off) (s + off) b = (ac, ns + off)\"", "lemma tm_append_second_step_eq: \n  assumes \n    exec: \"step0 (s, l, r) B = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"step0 (s + off, l, r) (A @ shift B off) = (s' + off, l', r')\"", "lemma tm_append_second_steps_eq: \n  assumes \n    exec: \"steps (s, l, r) (B, 0) stp = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"steps (s + off, l, r) (A @ shift B off, 0) stp = (s' + off, l', r')\"", "lemma tm_append_second_fetch0_eq:\n  assumes\n    even: \"length A mod 2 = 0\"\n    and off: \"off = length A div 2\"\n    and fetch: \"fetch B s b = (ac, 0)\"\n    and notfinal: \"s \\<noteq> 0\"\n  shows \"fetch (A @ shift B off) (s + off) b = (ac, 0)\"", "lemma tm_append_second_halt_eq:\n  assumes \n    exec: \"steps (Suc 0, l, r) (B, 0) stp = (0, l', r')\"\n    and wf_B: \"tm_wf (B, 0)\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"steps (Suc off, l, r) (A @ shift B off, 0) stp = (0, l', r')\"", "lemma tm_append_steps: \n  assumes \n    aexec: \"steps (s, l, r) (A, 0) stpa = (Suc (length A div 2), la, ra)\"\n    and bexec: \"steps (Suc 0, la, ra) (B, 0) stpb =  (sb, lb, rb)\"\n    and notfinal: \"sb \\<noteq> 0\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"steps (s, l, r) (A @ shift B off, 0) (stpa + stpb) = (sb + off, lb, rb)\"", "lemma halt_lemma2': \n  \"\\<lbrakk>wf LE;  \\<forall> n. ((\\<not> P (f n) \\<and> Q (f n)) \\<longrightarrow> \n    (Q (f (Suc n)) \\<and> (f (Suc n), (f n)) \\<in> LE)); Q (f 0)\\<rbrakk> \n      \\<Longrightarrow> \\<exists> n. P (f n)\"", "lemma halt_lemma2'': \n  \"\\<lbrakk>P (f n); \\<not> P (f (0::nat))\\<rbrakk> \\<Longrightarrow> \n         \\<exists> n. (P (f n) \\<and> (\\<forall> i < n. \\<not> P (f i)))\"", "lemma halt_lemma2''':\n  \"\\<lbrakk>\\<forall>n. \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow> Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n                 Q (f 0);  \\<forall>i<na. \\<not> P (f i)\\<rbrakk> \\<Longrightarrow> Q (f na)\"", "lemma halt_lemma2: \n  \"\\<lbrakk>wf LE;  \n    Q (f 0); \\<not> P (f 0);\n    \\<forall> n. ((\\<not> P (f n) \\<and> Q (f n)) \\<longrightarrow> (Q (f (Suc n)) \\<and> (f (Suc n), (f n)) \\<in> LE))\\<rbrakk> \n  \\<Longrightarrow> \\<exists> n. P (f n) \\<and> Q (f n)\"", "lemma wf_findnth_LE: \"wf findnth_LE\"", "lemma x_is_2n_arith[simp]: \n  \"\\<lbrakk>x < Suc (Suc (2 * n)); Suc x mod 2 = Suc 0; \\<not> x < 2 * n\\<rbrakk>\n \\<Longrightarrow> x = 2*n\"", "lemma between_sucs:\"x < Suc n \\<Longrightarrow> \\<not> x < n \\<Longrightarrow> x = n\"", "lemma fetch_findnth[simp]: \n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Oc = (R, Suc a)\"\n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Oc = (R, a)\"\n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Bk = (R, Suc a)\"\n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Bk = (W1, a)\"", "lemma replicate_once[intro]: \"\\<exists>rn. [Bk] = Bk \\<up> rn\"", "lemma at_begin_norm_Bk[intro]:  \"at_begin_norm (as, am) (q, aaa, []) ires\n             \\<Longrightarrow> at_begin_norm (as, am) (q, aaa, [Bk]) ires\"", "lemma at_begin_fst_bwtn_Bk[intro]: \"at_begin_fst_bwtn (as, am) (q, aaa, []) ires \n            \\<Longrightarrow> at_begin_fst_bwtn (as, am) (q, aaa, [Bk]) ires\"", "lemma at_begin_fst_awtn_Bk[intro]: \"at_begin_fst_awtn (as, am) (q, aaa, []) ires\n           \\<Longrightarrow> at_begin_fst_awtn (as, am) (q, aaa, [Bk]) ires\"", "lemma inv_locate_a_Bk[intro]: \"inv_locate_a (as, am) (q, aaa, []) ires\n            \\<Longrightarrow> inv_locate_a (as, am) (q, aaa, [Bk]) ires\"", "lemma locate_a_2_locate_a[simp]: \"inv_locate_a (as, am) (q, aaa, Bk # xs) ires\n       \\<Longrightarrow> inv_locate_a (as, am) (q, aaa, Oc # xs) ires\"", "lemma inv_locate_a[simp]: \"inv_locate_a (as, am) (q, aaa, []) ires \\<Longrightarrow> \n               inv_locate_a (as, am) (q, aaa, [Oc]) ires\"", "lemma inv_locate_b[simp]: \"inv_locate_b (as, am) (q, aaa, Oc # xs) ires\n         \\<Longrightarrow> inv_locate_b (as, am) (q, Oc # aaa, xs) ires\"", "lemma tape_nat[simp]:  \"<[x::nat]> = Oc\\<up>(Suc x)\"", "lemma inv_locate[simp]: \"\\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires; \\<exists>n. xs = Bk\\<up>n\\<rbrakk>\n            \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires\"", "lemma repeat_Bk_no_Oc[simp]: \"(Oc # r = Bk \\<up> rn) = False\"", "lemma repeat_Bk[simp]: \"(\\<exists>rna. Bk \\<up> rn = Bk # Bk \\<up> rna) \\<or> rn = 0\"", "lemma inv_locate_b_Oc_via_a[simp]: \n  assumes \"inv_locate_a (as, lm) (q, l, Oc # r) ires\"\n  shows \"inv_locate_b (as, lm) (q, Oc # l, r) ires\"", "lemma length_equal: \"xs = ys \\<Longrightarrow> length xs = length ys\"", "lemma inv_locate_a_Bk_via_b[simp]: \"\\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires; \n                \\<not> (\\<exists>n. xs = Bk\\<up>n)\\<rbrakk> \n       \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires\"", "lemma locate_b_2_a[intro]: \n  \"inv_locate_b (as, am) (q, aaa, Bk # xs) ires\n    \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires\"", "lemma inv_locate_b_Bk[simp]:  \"inv_locate_b (as, am) (q, l, []) ires \n           \\<Longrightarrow>  inv_locate_b (as, am) (q, l, [Bk]) ires\"", "lemma div_rounding_down[simp]: \"(2*q - Suc 0) div 2 = (q - 1)\" \"(Suc (2*q)) div 2 = q\"", "lemma even_plus_one_odd[simp]: \"x mod 2 = 0 \\<Longrightarrow> Suc x mod 2 = Suc 0\"", "lemma odd_plus_one_even[simp]: \"x mod 2 = Suc 0 \\<Longrightarrow> Suc x mod 2 = 0\"", "lemma locate_b_2_locate_a[simp]: \n  \"\\<lbrakk>q > 0;  inv_locate_b (as, am) (q - Suc 0, aaa, Bk # xs) ires\\<rbrakk>\n   \\<Longrightarrow>  inv_locate_a (as, am) (q, Bk # aaa, xs) ires\"", "lemma findnth_inv_layout_of_via_crsp[simp]:\n  \"crsp (layout_of ap) (as, lm) (s, l, r) ires\n  \\<Longrightarrow> findnth_inv (layout_of ap) n (as, lm) (Suc 0, l, r) ires\"", "lemma findnth_correct_pre: \n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and not0: \"n > 0\"\n    and f: \"f = (\\<lambda> stp. (steps (Suc 0, l, r) (findnth n, 0) stp, n))\"\n    and P: \"P = (\\<lambda> ((s, l, r), n). s = Suc (2 * n))\"\n    and Q: \"Q = (\\<lambda> ((s, l, r), n). findnth_inv ly n (as, lm) (s, l, r) ires)\"\n  shows \"\\<exists> stp. P (f stp) \\<and> Q (f stp)\"", "lemma inv_locate_a_via_crsp[simp]:\n  \"crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow> inv_locate_a (as, lm) (0, l, r) ires\"", "lemma findnth_correct: \n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n  shows \"\\<exists> stp l' r'. steps (Suc 0, l, r) (findnth n, 0) stp = (Suc (2 * n), l', r')\n              \\<and> inv_locate_a (as, lm) (n, l', r') ires\"", "lemma wf_inc_le[intro]: \"wf inc_LE\"", "lemma inv_locate_b_2_after_write[simp]:\n  assumes \"inv_locate_b (as, am) (n, aaa, Bk # xs) ires\"\n  shows \"inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n))) (s, aaa, Oc # xs) ires\"", "lemma inv_after_move_Oc_via_write[simp]: \"inv_after_write (as, lm) (x, l, Oc # r) ires\n                \\<Longrightarrow> inv_after_move (as, lm) (y, Oc # l, r) ires\"", "lemma inv_after_write_Suc[simp]: \"inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)\n                )) (x, aaa, Bk # xs) ires = False\"\n  \"inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n))) \n                        (x, aaa, []) ires = False\"", "lemma inv_after_clear_Bk_via_Oc[simp]: \"inv_after_move (as, lm) (s, l, Oc # r) ires\n                \\<Longrightarrow> inv_after_clear (as, lm) (s', l, Bk # r) ires\"", "lemma inv_after_move_2_inv_on_left_moving[simp]:  \n  assumes \"inv_after_move (as, lm) (s, l, Bk # r) ires\"\n  shows \"(l = [] \\<longrightarrow> \n         inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n      (l \\<noteq> [] \\<longrightarrow> \n         inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\"", "lemma inv_after_move_2_inv_on_left_moving_B[simp]: \n  \"inv_after_move (as, lm) (s, l, []) ires\n      \\<Longrightarrow> (l = [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', [], [Bk]) ires) \\<and>\n          (l \\<noteq> [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', tl l, [hd l]) ires)\"", "lemma inv_after_clear_2_inv_on_right_moving[simp]: \n  \"inv_after_clear (as, lm) (x, l, Bk # r) ires\n      \\<Longrightarrow> inv_on_right_moving (as, lm) (y, Bk # l, r) ires\"", "lemma inv_on_right_moving_Oc[simp]: \"inv_on_right_moving (as, lm) (x, l, Oc # r) ires\n      \\<Longrightarrow> inv_on_right_moving (as, lm) (y, Oc # l, r) ires\"", "lemma inv_on_right_moving_2_inv_on_right_moving[simp]: \n  \"inv_on_right_moving (as, lm) (x, l, Bk # r) ires\n     \\<Longrightarrow> inv_after_write (as, lm) (y, l, Oc # r) ires\"", "lemma inv_on_right_moving_singleton_Bk[simp]: \"inv_on_right_moving (as, lm) (x, l, []) ires\\<Longrightarrow> \n             inv_on_right_moving (as, lm) (y, l, [Bk]) ires\"", "lemma no_inv_on_left_moving_in_middle_B_Oc[simp]: \"inv_on_left_moving_in_middle_B (as, lm) \n               (s, l, Oc # r) ires = False\"", "lemma no_inv_on_left_moving_norm_Bk[simp]: \"inv_on_left_moving_norm (as, lm) (s, l, Bk # r) ires \n             = False\"", "lemma inv_on_left_moving_in_middle_B_Bk[simp]: \n  \"\\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires;\n    hd l = Bk; l \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n     inv_on_left_moving_in_middle_B (as, lm) (s, tl l, Bk # Oc # r) ires\"", "lemma inv_on_left_moving_norm_Oc_Oc[simp]: \"\\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires; \n                hd l = Oc; l \\<noteq> []\\<rbrakk>\n            \\<Longrightarrow> inv_on_left_moving_norm (as, lm) \n                                        (s, tl l, Oc # Oc # r) ires\"", "lemma inv_on_left_moving_in_middle_B_Bk_Oc[simp]: \"inv_on_left_moving_norm (as, lm) (s, [], Oc # r) ires\n     \\<Longrightarrow> inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # Oc # r) ires\"", "lemma inv_on_left_moving_Oc_cases[simp]:\"inv_on_left_moving (as, lm) (s, l, Oc # r) ires\n    \\<Longrightarrow> (l = [] \\<longrightarrow> inv_on_left_moving (as, lm) (s, [], Bk # Oc # r) ires)\n \\<and>  (l \\<noteq> [] \\<longrightarrow> inv_on_left_moving (as, lm) (s, tl l, hd l # Oc # r) ires)\"", "lemma from_on_left_moving_to_check_left_moving[simp]: \"inv_on_left_moving_in_middle_B (as, lm) \n                                      (s, Bk # list, Bk # r) ires\n          \\<Longrightarrow> inv_check_left_moving_on_leftmost (as, lm) \n                                      (s', list, Bk # Bk # r) ires\"", "lemma inv_check_left_moving_in_middle_no_Bk[simp]:\n  \"inv_check_left_moving_in_middle (as, lm) (s, l, Bk # r) ires= False\"", "lemma inv_check_left_moving_on_leftmost_Bk_Bk[simp]: \n  \"inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # r) ires\\<Longrightarrow> \n  inv_check_left_moving_on_leftmost (as, lm) (s', [], Bk # Bk # r) ires\"", "lemma inv_check_left_moving_on_leftmost_no_Oc[simp]: \"inv_check_left_moving_on_leftmost (as, lm) \n                                       (s, list, Oc # r) ires= False\"", "lemma inv_check_left_moving_in_middle_Oc_Bk[simp]: \"inv_on_left_moving_in_middle_B (as, lm) \n                                         (s, Oc # list, Bk # r) ires\n \\<Longrightarrow> inv_check_left_moving_in_middle (as, lm) (s', list, Oc # Bk # r) ires\"", "lemma inv_on_left_moving_2_check_left_moving[simp]:\n  \"inv_on_left_moving (as, lm) (s, l, Bk # r) ires\n \\<Longrightarrow> (l = [] \\<longrightarrow> inv_check_left_moving (as, lm) (s', [], Bk # Bk # r) ires)\n \\<and> (l \\<noteq> [] \\<longrightarrow> \n      inv_check_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\"", "lemma inv_on_left_moving_norm_no_empty[simp]: \"inv_on_left_moving_norm (as, lm) (s, l, []) ires = False\"", "lemma inv_on_left_moving_no_empty[simp]: \"inv_on_left_moving (as, lm) (s, l, []) ires = False\"", "lemma \n  inv_check_left_moving_in_middle_2_on_left_moving_in_middle_B[simp]:\n  assumes \"inv_check_left_moving_in_middle (as, lm) (s, Bk # list, Oc # r) ires\"\n  shows \"inv_on_left_moving_in_middle_B (as, lm) (s', list, Bk # Oc # r) ires\"", "lemma inv_check_left_moving_in_middle_Bk_Oc[simp]: \n  \"inv_check_left_moving_in_middle (as, lm) (s, [], Oc # r) ires\\<Longrightarrow>\n     inv_check_left_moving_in_middle (as, lm) (s', [Bk], Oc # r) ires\"", "lemma inv_on_left_moving_norm_Oc_Oc_via_middle[simp]: \"inv_check_left_moving_in_middle (as, lm) \n                       (s, Oc # list, Oc # r) ires\n   \\<Longrightarrow> inv_on_left_moving_norm (as, lm) (s', list, Oc # Oc # r) ires\"", "lemma inv_check_left_moving_Oc_cases[simp]: \"inv_check_left_moving (as, lm) (s, l, Oc # r) ires\n\\<Longrightarrow> (l = [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', [], Bk # Oc # r) ires) \\<and>\n   (l \\<noteq> [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', tl l, hd l # Oc # r) ires)\"", "lemma inv_after_left_moving_Bk_via_check[simp]: \"inv_check_left_moving (as, lm) (s, l, Bk # r) ires\n                \\<Longrightarrow> inv_after_left_moving (as, lm) (s', Bk # l, r) ires\"", "lemma inv_after_left_moving_Bk_empty_via_check[simp]:\"inv_check_left_moving (as, lm) (s, l, []) ires\n      \\<Longrightarrow> inv_after_left_moving (as, lm) (s', Bk # l, []) ires\"", "lemma inv_stop_Bk_move[simp]: \"inv_after_left_moving (as, lm) (s, l, Bk # r) ires\n       \\<Longrightarrow> inv_stop (as, lm) (s', Bk # l, r) ires\"", "lemma inv_stop_Bk_empty[simp]: \"inv_after_left_moving (as, lm) (s, l, []) ires\n             \\<Longrightarrow> inv_stop (as, lm) (s', Bk # l, []) ires\"", "lemma inv_stop_indep_fst[simp]: \"inv_stop (as, lm) (x, l, r) ires \\<Longrightarrow> \n               inv_stop (as, lm) (y, l, r) ires\"", "lemma inv_after_clear_no_Oc[simp]: \"inv_after_clear (as, lm) (s, aaa, Oc # xs) ires= False\"", "lemma inv_after_left_moving_no_Oc[simp]: \n  \"inv_after_left_moving (as, lm) (s, aaa, Oc # xs) ires = False\"", "lemma inv_after_clear_Suc_nonempty[simp]:\n  \"inv_after_clear (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (s, b, []) ires = False\"", "lemma inv_on_left_moving_Suc_nonempty[simp]: \"inv_on_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) \n           (s, b, Oc # list) ires \\<Longrightarrow> b \\<noteq> []\"", "lemma inv_check_left_moving_Suc_nonempty[simp]:\n  \"inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (s, b, Oc # list) ires \\<Longrightarrow> b \\<noteq> []\"", "lemma tinc_correct_pre:\n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_a (as, lm) (n, l, r) ires\"\n    and lm': \"lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\"\n    and f: \"f = steps (Suc 0, l, r) (tinc_b, 0)\"\n    and P: \"P = (\\<lambda> (s, l, r). s = 10)\"\n    and Q: \"Q = (\\<lambda> (s, l, r). inc_inv n (as, lm) (s, l, r) ires)\" \n  shows \"\\<exists> stp. P (f stp) \\<and> Q (f stp)\"", "lemma tinc_correct: \n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_a (as, lm) (n, l, r) ires\"\n    and lm': \"lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\"\n  shows \"\\<exists> stp l' r'. steps (Suc 0, l, r) (tinc_b, 0) stp = (10, l', r')\n              \\<and> inv_stop (as, lm') (10, l', r') ires\"", "lemma is_even_4[simp]: \"(4::nat) * n mod 2 = 0\"", "lemma crsp_step_inc_pre:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and aexec: \"abc_step_l (as, lm) (Some (Inc n)) = (asa, lma)\"\n  shows \"\\<exists> stp k. steps (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n), 0) stp \n        = (2*n + 10, Bk # Bk # ires, <lma> @ Bk\\<up>k) \\<and> stp > 0\"", "lemma crsp_step_inc:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some (Inc n)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n  (steps (s, l, r) (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp) ires\"", "lemma x_plus_helpers:\n  \"x + 4 = Suc (x + 3)\"\n  \"x + 5 = Suc (x + 4)\"\n  \"x + 6 = Suc (x + 5)\"\n  \"x + 7 = Suc (x + 6)\"\n  \"x + 8 = Suc (x + 7)\"\n  \"x + 9 = Suc (x + 8)\"\n  \"x + 10 = Suc (x + 9)\"\n  \"x + 11 = Suc (x + 10)\"\n  \"x + 12 = Suc (x + 11)\"\n  \"x + 13 = Suc (x + 12)\"\n  \"14 + x = Suc (x + 13)\"\n  \"15 + x = Suc (x + 14)\"\n  \"16 + x = Suc (x + 15)\"", "lemma fetch_Dec[simp]: \n  \"fetch (ci ly (start_of ly as) (Dec n e)) (Suc (2 * n)) Bk = (W1,  start_of ly as + 2 *n)\"\n  \"fetch (ci ly (start_of ly as) (Dec n e)) (Suc (2 * n)) Oc = (R,  Suc (start_of ly as) + 2 *n)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (2 * n))) Oc\n     = (R, start_of ly as + 2*n + 2)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (2 * n))) Bk\n     = (L, start_of ly as + 2*n + 13)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (Suc (2 * n)))) Oc\n     = (R, start_of ly as + 2*n + 2)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (Suc (2 * n)))) Bk\n     = (L, start_of ly as + 2*n + 3)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 4) Oc = (W0, start_of ly as + 2*n + 3)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 4) Bk = (R, start_of ly as + 2*n + 4)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 5) Bk = (R, start_of ly as + 2*n + 5)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 6) Bk = (L, start_of ly as + 2*n + 6)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 6) Oc = (L, start_of ly as + 2*n + 7)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 7) Bk = (L, start_of ly as + 2*n + 10)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 8) Bk = (W1, start_of ly as + 2*n + 7)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 8) Oc = (R, start_of ly as + 2*n + 8)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 9) Bk = (L, start_of ly as + 2*n + 9)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 9) Oc = (R, start_of ly as + 2*n + 8)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 10) Bk = (R, start_of ly as + 2*n + 4)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 10) Oc = (W0, start_of ly as + 2*n + 9)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 11) Oc = (L, start_of ly as + 2*n + 10)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 11) Bk = (L, start_of ly as + 2*n + 11)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 12) Oc = (L, start_of ly as + 2*n + 10)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 12) Bk = (R, start_of ly as + 2*n + 12)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 13) Bk = (R, start_of ly as + 2*n + 16)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (14 + 2 * n) Oc = (L, start_of ly as + 2*n + 13)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (14 + 2 * n) Bk = (L, start_of ly as + 2*n + 14)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (15 + 2 * n) Oc = (L, start_of ly as + 2*n + 13)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (15 + 2 * n) Bk = (R, start_of ly as + 2*n + 15)\"\n  \"fetch (ci (ly) (start_of (ly) as) (Dec n e)) (16 + 2 * n) Bk = (R, start_of (ly) e)\"", "lemma steps_start_of_invb_inv_locate_a1[simp]: \n  \"\\<lbrakk>r = [] \\<or> hd r = Bk; inv_locate_a (as, lm) (n, l, r) ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n  steps (start_of ly as + 2 * n, l, r) (ci ly (start_of ly as) (Dec n e), \n  start_of ly as - Suc 0) stp = (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\"", "lemma steps_start_of_invb_inv_locate_a2[simp]: \n  \"\\<lbrakk>inv_locate_a (as, lm) (n, l, r) ires; r \\<noteq> [] \\<and> hd r \\<noteq> Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n  steps (start_of ly as + 2 * n, l, r) (ci ly (start_of ly as) (Dec n e), \n  start_of ly as - Suc 0) stp = (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\"", "lemma wf_dec_le: \"wf abc_dec_1_LE\"", "lemma startof_Suc2:\n  \"abc_fetch as ap = Some (Dec n e) \\<Longrightarrow> \n        start_of (layout_of ap) (Suc as) = \n            start_of (layout_of ap) as + 2 * n + 16\"", "lemma start_of_less_2: \n  \"start_of ly e \\<le> start_of ly (Suc e)\"", "lemma start_of_less_1: \"start_of ly e \\<le> start_of ly (e + d)\"", "lemma start_of_less: \n  assumes \"e < as\"\n  shows \"start_of ly e \\<le> start_of ly as\"", "lemma start_of_ge: \n  assumes fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and layout: \"ly = layout_of ap\"\n    and great: \"e > as\"\n  shows \"start_of ly e \\<ge> start_of ly as + 2*n + 16\"", "lemma start_of_ineq1[simp]: \n  \"\\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog\\<rbrakk>\n   \\<Longrightarrow> (start_of ly e \\<noteq> Suc (start_of ly as + 2 * n) \\<and>\n        start_of ly e \\<noteq> Suc (Suc (start_of ly as + 2 * n)) \\<and>  \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 3 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 4 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 5 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 6 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 7 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 8 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 9 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 10 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 11 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 12 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 13 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 14 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 15)\"", "lemma start_of_ineq2[simp]: \"\\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog\\<rbrakk>\n      \\<Longrightarrow> (Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e \\<and>\n          Suc (Suc (start_of ly as + 2 * n)) \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 3 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 4 \\<noteq> start_of ly e \\<and>\n          start_of ly as + 2 * n + 5 \\<noteq>start_of ly e \\<and> \n          start_of ly as + 2 * n + 6 \\<noteq> start_of ly e \\<and>\n          start_of ly as + 2 * n + 7 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 8 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 9 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 10 \\<noteq> start_of ly e \\<and>\n          start_of ly as + 2 * n + 11 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 12 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 13 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 14 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 15 \\<noteq> start_of ly e)\"", "lemma inv_locate_b_nonempty[simp]: \"inv_locate_b (as, lm) (n, [], []) ires = False\"", "lemma inv_locate_b_no_Bk[simp]: \"inv_locate_b (as, lm) (n, [], Bk # list) ires = False\"", "lemma dec_first_on_right_moving_Oc[simp]: \n  \"\\<lbrakk>dec_first_on_right_moving n (as, am) (s, aaa, Oc # xs) ires\\<rbrakk>\n   \\<Longrightarrow> dec_first_on_right_moving n (as, am) (s', Oc # aaa, xs) ires\"", "lemma dec_first_on_right_moving_Bk_nonempty[simp]: \n  \"dec_first_on_right_moving n (as, am) (s, l, Bk # xs) ires \\<Longrightarrow> l \\<noteq> []\"", "lemma replicateE: \n  \"\\<lbrakk>\\<not> length lm1 < length am; \n    am @ replicate (length lm1 - length am) 0 @ [0::nat] = \n                                                lm1 @ m # lm2;\n    0 < m\\<rbrakk>\n   \\<Longrightarrow> RR\"", "lemma dec_after_clear_Bk_strip_hd[simp]: \n  \"\\<lbrakk>dec_first_on_right_moving n (as, \n                   abc_lm_s am n (abc_lm_v am n)) (s, l, Bk # xs) ires\\<rbrakk>\n\\<Longrightarrow> dec_after_clear (as, abc_lm_s am n \n                 (abc_lm_v am n - Suc 0)) (s', tl l, hd l # Bk # xs) ires\"", "lemma dec_first_on_right_moving_dec_after_clear_cases[simp]: \n  \"\\<lbrakk>dec_first_on_right_moving n (as, \n                   abc_lm_s am n (abc_lm_v am n)) (s, l, []) ires\\<rbrakk>\n\\<Longrightarrow> (l = [] \\<longrightarrow> dec_after_clear (as, \n             abc_lm_s am n (abc_lm_v am n - Suc 0)) (s', [], [Bk]) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow> dec_after_clear (as, abc_lm_s am n \n                      (abc_lm_v am n - Suc 0)) (s', tl l, [hd l]) ires)\"", "lemma dec_after_clear_Bk_via_Oc[simp]: \"\\<lbrakk>dec_after_clear (as, am) (s, l, Oc # r) ires\\<rbrakk>\n                \\<Longrightarrow> dec_after_clear (as, am) (s', l, Bk # r) ires\"", "lemma dec_right_move_Bk_via_clear_Bk[simp]: \"\\<lbrakk>dec_after_clear (as, am) (s, l, Bk # r) ires\\<rbrakk>\n                \\<Longrightarrow> dec_right_move (as, am) (s', Bk # l, r) ires\"", "lemma dec_right_move_Bk_Bk_via_clear[simp]: \"\\<lbrakk>dec_after_clear (as, am) (s, l, []) ires\\<rbrakk>\n             \\<Longrightarrow> dec_right_move (as, am) (s', Bk # l, [Bk]) ires\"", "lemma dec_right_move_no_Oc[simp]:\"dec_right_move (as, am) (s, l, Oc # r) ires = False\"", "lemma dec_right_move_2_check_right_move[simp]:\n  \"\\<lbrakk>dec_right_move (as, am) (s, l, Bk # r) ires\\<rbrakk>\n      \\<Longrightarrow> dec_check_right_move (as, am) (s', Bk # l, r) ires\"", "lemma lm_iff_empty[simp]: \"(<lm::nat list> = []) = (lm = [])\"", "lemma dec_right_move_asif_Bk_singleton[simp]: \n  \"dec_right_move (as, am) (s, l, []) ires= \n  dec_right_move (as, am) (s, l, [Bk]) ires\"", "lemma dec_check_right_move_nonempty[simp]: \"dec_check_right_move (as, am) (s, l, r) ires\\<Longrightarrow> l \\<noteq> []\"", "lemma dec_check_right_move_Oc_tail[simp]: \"\\<lbrakk>dec_check_right_move (as, am) (s, l, Oc # r) ires\\<rbrakk>\n             \\<Longrightarrow> dec_after_write (as, am) (s', tl l, hd l # Oc # r) ires\"", "lemma dec_left_move_Bk_tail[simp]: \"\\<lbrakk>dec_check_right_move (as, am) (s, l, Bk # r) ires\\<rbrakk>\n                \\<Longrightarrow> dec_left_move (as, am) (s', tl l, hd l # Bk # r) ires\"", "lemma dec_left_move_tail[simp]: \"\\<lbrakk>dec_check_right_move (as, am) (s, l, []) ires\\<rbrakk>\n             \\<Longrightarrow> dec_left_move (as, am) (s', tl l, [hd l]) ires\"", "lemma dec_left_move_no_Oc[simp]: \"dec_left_move (as, am) (s, aaa, Oc # xs) ires = False\"", "lemma dec_left_move_nonempty[simp]: \"dec_left_move (as, am) (s, l, r) ires\n             \\<Longrightarrow> l \\<noteq> []\"", "lemma inv_on_left_moving_in_middle_B_Oc_Bk_Bks[simp]: \"inv_on_left_moving_in_middle_B (as, [m])\n  (s', Oc # Oc\\<up>m @ Bk # Bk # ires, Bk # Bk\\<up>rn) ires\"", "lemma inv_on_left_moving_in_middle_B_Oc_Bk_Bks_rev[simp]: \"lm1 \\<noteq> [] \\<Longrightarrow> \n  inv_on_left_moving_in_middle_B (as, lm1 @ [m]) (s', \n  Oc # Oc\\<up>m @ Bk # <rev lm1> @ Bk # Bk # ires, Bk # Bk\\<up>rn) ires\"", "lemma inv_on_left_moving_Bk_tail[simp]: \"dec_left_move (as, am) (s, l, Bk # r) ires\n       \\<Longrightarrow> inv_on_left_moving (as, am) (s', tl l, hd l # Bk # r) ires\"", "lemma inv_on_left_moving_tail[simp]: \"dec_left_move (as, am) (s, l, []) ires\n             \\<Longrightarrow> inv_on_left_moving (as, am) (s', tl l, [hd l]) ires\"", "lemma dec_on_right_moving_Oc_mv[simp]: \"dec_after_write (as, am) (s, l, Oc # r) ires\n       \\<Longrightarrow> dec_on_right_moving (as, am) (s', Oc # l, r) ires\"", "lemma dec_after_write_Oc_via_Bk[simp]: \"dec_after_write (as, am) (s, l, Bk # r) ires\n       \\<Longrightarrow> dec_after_write (as, am) (s', l, Oc # r) ires\"", "lemma dec_after_write_Oc_empty[simp]: \"dec_after_write (as, am) (s, aaa, []) ires\n             \\<Longrightarrow> dec_after_write (as, am) (s', aaa, [Oc]) ires\"", "lemma dec_on_right_moving_Oc_move[simp]: \"dec_on_right_moving (as, am) (s, l, Oc # r) ires\n       \\<Longrightarrow> dec_on_right_moving (as, am) (s', Oc # l, r) ires\"", "lemma dec_on_right_moving_nonempty[simp]: \"dec_on_right_moving (as, am) (s, l, r) ires\\<Longrightarrow>  l \\<noteq> []\"", "lemma dec_after_clear_Bk_tail[simp]: \"dec_on_right_moving (as, am) (s, l, Bk # r) ires\n      \\<Longrightarrow>  dec_after_clear (as, am) (s', tl l, hd l # Bk # r) ires\"", "lemma dec_after_clear_tail[simp]: \"dec_on_right_moving (as, am) (s, l, []) ires\n             \\<Longrightarrow> dec_after_clear (as, am) (s', tl l, [hd l]) ires\"", "lemma dec_false_1[simp]:\n  \"\\<lbrakk>abc_lm_v am n = 0; inv_locate_b (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n  \\<Longrightarrow> False\"", "lemma inv_on_left_moving_Bk_tl[simp]: \n  \"\\<lbrakk>inv_locate_b (as, am) (n, aaa, Bk # xs) ires; \n   abc_lm_v am n = 0\\<rbrakk>\n   \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0) \n                         (s, tl aaa, hd aaa # Bk # xs) ires\"", "lemma inv_on_left_moving_tl[simp]:\n  \"\\<lbrakk>abc_lm_v am n = 0; inv_locate_b (as, am) (n, aaa, []) ires\\<rbrakk>\n   \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa]) ires\"", "lemma dec_first_on_right_moving_Oc_via_inv_locate_n_b[simp]:\n  \"\\<lbrakk>inv_locate_n_b (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n \\<Longrightarrow> dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))  \n                                      (s, Oc # aaa, xs) ires\"", "lemma inv_on_left_moving_nonempty[simp]: \"inv_on_left_moving (as, am) (s, [], r) ires \n  = False\"", "lemma inv_check_left_moving_startof_nonempty[simp]: \n  \"inv_check_left_moving (as, abc_lm_s am n 0)\n  (start_of (layout_of aprog) as + 2 * n + 14, [], Oc # xs) ires\n = False\"", "lemma start_of_lessE[elim]: \"\\<lbrakk>abc_fetch as ap = Some (Dec n e);\n                start_of (layout_of ap) as < start_of (layout_of ap) e; \n                start_of (layout_of ap) e \\<le> Suc (start_of (layout_of ap) as + 2 * n)\\<rbrakk>\n       \\<Longrightarrow> RR\"", "lemma crsp_step_dec_b_e_pre':\n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_b (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and dec_0: \"abc_lm_v lm n = 0\"\n    and f: \"f = (\\<lambda> stp. (steps (Suc (start_of ly as) + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), \n            start_of ly as - Suc 0) stp, start_of ly as, n))\"\n    and P: \"P = (\\<lambda> ((s, l, r), ss, x). s = start_of ly e)\"\n    and Q: \"Q = (\\<lambda> ((s, l, r), ss, x). dec_inv_1 ly x e (as, lm) (s, l, r) ires)\"\n  shows \"\\<exists> stp. P (f stp) \\<and> Q (f stp)\"", "lemma crsp_step_dec_b_e_pre:\n  assumes \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_b (as, lm) (n, la, ra) ires\"\n    and dec_0: \"abc_lm_v lm n  = 0\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp lb rb.\n       steps (Suc (start_of ly as) + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), \n       start_of ly as - Suc 0) stp = (start_of ly e, lb, rb) \\<and>\n       dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\"", "lemma crsp_abc_step_via_stop[simp]:\n  \"\\<lbrakk>abc_lm_v lm n = 0;\n  inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, lb, rb) ires\\<rbrakk>\n  \\<Longrightarrow> crsp ly (abc_step_l (as, lm) (Some (Dec n e))) (start_of ly e, lb, rb) ires\"", "lemma crsp_step_dec_b_e:\n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_a (as, lm) (n, l, r) ires\"\n    and dec_0: \"abc_lm_v lm n = 0\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n  (steps (start_of ly as + 2 * n, l, r) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\"", "lemma wf_dec2_le: \"wf abc_dec_2_LE\"", "lemma fix_add: \"fetch ap ((x::nat) + 2*n) b = fetch ap (2*n + x) b\"", "lemma inv_locate_n_b_Bk_elim[elim]: \n  \"\\<lbrakk>0 < abc_lm_v am n; inv_locate_n_b (as, am) (n, aaa, Bk # xs) ires\\<rbrakk> \n \\<Longrightarrow> RR\"", "lemma inv_locate_n_b_nonemptyE[elim]:\n  \"\\<lbrakk>0 < abc_lm_v am n; inv_locate_n_b (as, am) \n                                (n, aaa, []) ires\\<rbrakk> \\<Longrightarrow> RR\"", "lemma no_Ocs_dec_after_write[simp]: \"dec_after_write (as, am) (s, aa, r) ires\n           \\<Longrightarrow> takeWhile (\\<lambda>a. a = Oc) aa = []\"", "lemma fewer_Ocs_dec_on_right_moving[simp]: \n  \"\\<lbrakk>dec_on_right_moving (as, lm) (s, aa, []) ires; \n       length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \n           \\<noteq> length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) < \n                       length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0\"", "lemma more_Ocs_dec_after_clear[simp]: \n  \"dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0)) \n             (start_of (layout_of aprog) as + 2 * n + 9, aa, Bk # xs) ires\n \\<Longrightarrow> length xs - Suc 0 < length xs + \n                             length (takeWhile (\\<lambda>a. a = Oc) aa)\"", "lemma more_Ocs_dec_after_clear2[simp]: \n  \"\\<lbrakk>dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n       (start_of (layout_of aprog) as + 2 * n + 9, aa, []) ires\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < length (takeWhile (\\<lambda>a. a = Oc) aa)\"", "lemma inv_check_left_moving_nonemptyE[elim]: \n  \"inv_check_left_moving (as, lm) (s, [], Oc # xs) ires\n \\<Longrightarrow> RR\"", "lemma inv_locate_n_b_Oc_via_at_begin_norm[simp]:\n  \"\\<lbrakk>0 < abc_lm_v am n; \n  at_begin_norm (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n  \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires\"", "lemma inv_locate_n_b_Oc_via_at_begin_fst_awtn[simp]: \n  \"\\<lbrakk>0 < abc_lm_v am n; \n   at_begin_fst_awtn (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires\"", "lemma inv_locate_n_b_Oc_via_inv_locate_n_a[simp]: \n  \"\\<lbrakk>0 < abc_lm_v am n; inv_locate_a (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc#aaa, xs) ires\"", "lemma more_Oc_dec_on_right_moving[simp]: \n  \"\\<lbrakk>dec_on_right_moving (as, am) (s, aa, Bk # xs) ires; \n   Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa)))\n   \\<noteq> length (takeWhile (\\<lambda>a. a = Oc) aa)\\<rbrakk>\n  \\<Longrightarrow> Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa))) \n    < length (takeWhile (\\<lambda>a. a = Oc) aa)\"", "lemma crsp_step_dec_b_suc_pre:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and inv_start: \"inv_locate_a (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and dec_suc: \"0 < abc_lm_v lm n\"\n    and f: \"f = (\\<lambda> stp. (steps (start_of ly as + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), \n            start_of ly as - Suc 0) stp, start_of ly as, n))\"\n    and P: \"P = (\\<lambda> ((s, l, r), ss, x). s = start_of ly as + 2*n + 16)\"\n    and Q: \"Q = (\\<lambda> ((s, l, r), ss, x). dec_inv_2 ly x e (as, lm) (s, l, r) ires)\"\n  shows \"\\<exists> stp. P (f stp) \\<and> Q(f stp)\"", "lemma crsp_abc_step_l_start_of[simp]: \n  \"\\<lbrakk>inv_stop (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) \n  (start_of (layout_of ap) as + 2 * n + 16, a, b) ires;\n   abc_lm_v lm n > 0;\n   abc_fetch as ap = Some (Dec n e)\\<rbrakk>\n  \\<Longrightarrow> crsp (layout_of ap) (abc_step_l (as, lm) (Some (Dec n e))) \n  (start_of (layout_of ap) as + 2 * n + 16, a, b) ires\"", "lemma crsp_step_dec_b_suc:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and inv_start: \"inv_locate_a (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and dec_suc: \"0 < abc_lm_v lm n\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n              (steps (start_of ly as + 2 * n, la, ra) (ci (layout_of ap) \n                  (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\"", "lemma crsp_step_dec_b:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and inv_start: \"inv_locate_a (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n  (steps (start_of ly as + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\"", "lemma crsp_step_dec: \n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n  (steps (s, l, r) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\"", "lemma crsp_step_goto:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n  shows \"\\<exists>stp>0. crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n  (steps (s, l, r) (ci ly (start_of ly as) (Goto n), \n            start_of ly as - Suc 0) stp) ires\"", "lemma crsp_step_in:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some ins\"\n  shows \"\\<exists> stp>0. crsp ly (abc_step_l (as, lm) (Some ins))\n                      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp) ires\"", "lemma crsp_step:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some ins\"\n  shows \"\\<exists> stp>0. crsp ly (abc_step_l (as, lm) (Some ins))\n                      (steps (s, l, r) (tp, 0) stp) ires\"", "lemma crsp_steps:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n  shows \"\\<exists> stp. crsp ly (abc_steps_l (as, lm) ap n)\n                      (steps (s, l, r) (tp, 0) stp) ires\"", "lemma tp_correct': \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (Suc 0, l, r) ires\"\n    and abc_halt: \"abc_steps_l (0, lm) ap stp = (length ap, am)\"\n  shows \"\\<exists> stp k. steps (Suc 0, l, r) (tp, 0) stp = (start_of ly (length ap), Bk # Bk # ires, <am> @ Bk\\<up>k)\"", "lemma layout_id_cons: \"layout_of (ap @ [p]) = layout_of ap @ [length_of p]\"", "lemma map_start_of_layout[simp]:  \n  \"map (start_of (layout_of xs @ [length_of x])) [0..<length xs] =  (map (start_of (layout_of xs)) [0..<length xs])\"", "lemma tpairs_id_cons: \n  \"tpairs_of (xs @ [x]) = tpairs_of xs @ [(start_of (layout_of (xs @ [x])) (length xs), x)]\"", "lemma map_length_ci:\n  \"(map (length \\<circ> (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y)) (tpairs_of xs)) = \n  (map (length \\<circ> (\\<lambda>(x, y). ci (layout_of xs) x y)) (tpairs_of xs)) \"", "lemma length_tp'[simp]: \n  \"\\<lbrakk>ly = layout_of ap; tp = tm_of ap\\<rbrakk> \\<Longrightarrow>\n       length tp = 2 * sum_list (take (length ap) (layout_of ap))\"", "lemma length_tp:\n  \"\\<lbrakk>ly = layout_of ap; tp = tm_of ap\\<rbrakk> \\<Longrightarrow> \n  start_of ly (length ap) = Suc (length tp div 2)\"", "lemma compile_correct_halt: \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (Suc 0, l, r) ires\"\n    and abc_halt: \"abc_steps_l (0, lm) ap stp = (length ap, am)\"\n    and rs_loc: \"n < length am\"\n    and rs: \"abc_lm_v am n = rs\"\n    and off: \"off = length tp div 2\"\n  shows \"\\<exists> stp i j. steps (Suc 0, l, r) (tp @ shift (mopup n) off, 0) stp = (0, Bk\\<up>i @ Bk # Bk # ires, Oc\\<up>Suc rs @ Bk\\<up>j)\"", "lemma abc_step_red2:\n  \"abc_steps_l (s, lm) p (Suc n) = (let (as', am') = abc_steps_l (s, lm) p n in\n                                    abc_step_l (as', am') (abc_fetch as' p))\"", "lemma crsp_steps2:\n  assumes \n    layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (Suc 0, l, r) ires\"\n    and nothalt: \"as < length ap\"\n    and aexec: \"abc_steps_l (0, lm) ap stp = (as, am)\"\n  shows \"\\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps (Suc 0, l, r) (tp, 0) stpa) ires\"", "lemma compile_correct_unhalt: \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (1, l, r) ires\"\n    and off: \"off = length tp div 2\"\n    and abc_unhalt: \"\\<forall> stp. (\\<lambda> (as, am). as < length ap) (abc_steps_l (0, lm) ap stp)\"\n  shows \"\\<forall> stp.\\<not> is_final (steps (1, l, r) (tp @ shift (mopup n) off, 0) stp)\""], "translations": [["", "lemma length_findnth: \n  \"length (findnth n) = 4 * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (findnth n) = 4 * n", "by (induct n, auto)"], ["", "lemma ci_length : \"length (ci ns n ai) div 2 = length_of ai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ci ns n ai) div 2 = length_of ai", "apply(auto simp: ci.simps tinc_b_def tdec_b_def length_findnth\n      split: abc_inst.splits simp del: adjust.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Representation of Abacus memory by TM tapes\\<close>"], ["", "text \\<open>\n  \\<open>crsp acf tcf\\<close> meams the abacus configuration \\<open>acf\\<close>\n  is corretly represented by the TM configuration \\<open>tcf\\<close>.\n\\<close>"], ["", "fun crsp :: \"layout \\<Rightarrow> abc_conf \\<Rightarrow> config \\<Rightarrow> cell list \\<Rightarrow> bool\"\n  where \n    \"crsp ly (as, lm) (s, l, r) inres = \n           (s = start_of ly as \\<and> (\\<exists> x. r = <lm> @ Bk\\<up>x) \\<and> \n            l = Bk # Bk # inres)\""], ["", "declare crsp.simps[simp del]"], ["", "text \\<open>\n  The type of invarints expressing correspondence between \n  Abacus configuration and TM configuration.\n\\<close>"], ["", "type_synonym inc_inv_t = \"abc_conf \\<Rightarrow> config \\<Rightarrow> cell list \\<Rightarrow> bool\""], ["", "declare tms_of.simps[simp del] tm_of.simps[simp del]\n  layout_of.simps[simp del] abc_fetch.simps [simp del]  \n  tpairs_of.simps[simp del] start_of.simps[simp del]\n  ci.simps [simp del] length_of.simps[simp del] \n  layout_of.simps[simp del]"], ["", "text \\<open>\n  The lemmas in this section lead to the correctness of \n  the compilation of \\<open>Inc n\\<close> instruction.\n\\<close>"], ["", "declare abc_step_l.simps[simp del] abc_steps_l.simps[simp del]"], ["", "lemma start_of_nonzero[simp]: \"start_of ly as > 0\" \"(start_of ly as = 0) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < start_of ly as &&& (start_of ly as = 0) = False", "apply(auto simp: start_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma abc_steps_l_0: \"abc_steps_l ac ap 0 = ac\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_steps_l ac ap 0 = ac", "by(cases ac, simp add: abc_steps_l.simps)"], ["", "lemma abc_step_red: \n  \"abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow> \n  abc_steps_l (as, am) ap (Suc stp) = abc_step_l (bs, bm) (abc_fetch bs ap) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n    abc_steps_l (as, am) ap (Suc stp) =\n    abc_step_l (bs, bm) (abc_fetch bs ap)", "proof(induct stp arbitrary: as am bs bm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as am bs bm.\n       abc_steps_l (as, am) ap 0 = (bs, bm) \\<Longrightarrow>\n       abc_steps_l (as, am) ap (Suc 0) =\n       abc_step_l (bs, bm) (abc_fetch bs ap)\n 2. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "case 0"], ["proof (state)\nthis:\n  abc_steps_l (as, am) ap 0 = (bs, bm)\n\ngoal (2 subgoals):\n 1. \\<And>as am bs bm.\n       abc_steps_l (as, am) ap 0 = (bs, bm) \\<Longrightarrow>\n       abc_steps_l (as, am) ap (Suc 0) =\n       abc_step_l (bs, bm) (abc_fetch bs ap)\n 2. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "thus \"?case\""], ["proof (prove)\nusing this:\n  abc_steps_l (as, am) ap 0 = (bs, bm)\n\ngoal (1 subgoal):\n 1. abc_steps_l (as, am) ap (Suc 0) = abc_step_l (bs, bm) (abc_fetch bs ap)", "by(simp add: abc_steps_l.simps abc_steps_l_0)"], ["proof (state)\nthis:\n  abc_steps_l (as, am) ap (Suc 0) = abc_step_l (bs, bm) (abc_fetch bs ap)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "case (Suc stp as am bs bm)"], ["proof (state)\nthis:\n  abc_steps_l (?as, ?am) ap stp = (?bs, ?bm) \\<Longrightarrow>\n  abc_steps_l (?as, ?am) ap (Suc stp) =\n  abc_step_l (?bs, ?bm) (abc_fetch ?bs ap)\n  abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "have ind: \"\\<And>as am bs bm. abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow> \n    abc_steps_l (as, am) ap (Suc stp) = abc_step_l (bs, bm) (abc_fetch bs ap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as am bs bm.\n       abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n       abc_steps_l (as, am) ap (Suc stp) =\n       abc_step_l (bs, bm) (abc_fetch bs ap)", "by fact"], ["proof (state)\nthis:\n  abc_steps_l (?as, ?am) ap stp = (?bs, ?bm) \\<Longrightarrow>\n  abc_steps_l (?as, ?am) ap (Suc stp) =\n  abc_step_l (?bs, ?bm) (abc_fetch ?bs ap)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "have h:\" abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_steps_l (as, am) ap (Suc stp) = (bs, bm)", "by fact"], ["proof (state)\nthis:\n  abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "obtain as' am' where g: \"abc_step_l (as, am) (abc_fetch as ap) = (as', am')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' am'.\n        abc_step_l (as, am) (abc_fetch as ap) = (as', am') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"abc_step_l (as, am) (abc_fetch as ap)\", auto)"], ["proof (state)\nthis:\n  abc_step_l (as, am) (abc_fetch as ap) = (as', am')\n\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "then"], ["proof (chain)\npicking this:\n  abc_step_l (as, am) (abc_fetch as ap) = (as', am')", "have \"abc_steps_l (as', am') ap (Suc stp) = abc_step_l (bs, bm) (abc_fetch bs ap)\""], ["proof (prove)\nusing this:\n  abc_step_l (as, am) (abc_fetch as ap) = (as', am')\n\ngoal (1 subgoal):\n 1. abc_steps_l (as', am') ap (Suc stp) =\n    abc_step_l (bs, bm) (abc_fetch bs ap)", "using h"], ["proof (prove)\nusing this:\n  abc_step_l (as, am) (abc_fetch as ap) = (as', am')\n  abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\n\ngoal (1 subgoal):\n 1. abc_steps_l (as', am') ap (Suc stp) =\n    abc_step_l (bs, bm) (abc_fetch bs ap)", "by(intro ind, simp add: abc_steps_l.simps)"], ["proof (state)\nthis:\n  abc_steps_l (as', am') ap (Suc stp) =\n  abc_step_l (bs, bm) (abc_fetch bs ap)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am bs bm.\n       \\<lbrakk>\\<And>as am bs bm.\n                   abc_steps_l (as, am) ap stp = (bs, bm) \\<Longrightarrow>\n                   abc_steps_l (as, am) ap (Suc stp) =\n                   abc_step_l (bs, bm) (abc_fetch bs ap);\n        abc_steps_l (as, am) ap (Suc stp) = (bs, bm)\\<rbrakk>\n       \\<Longrightarrow> abc_steps_l (as, am) ap (Suc (Suc stp)) =\n                         abc_step_l (bs, bm) (abc_fetch bs ap)", "thus \"?case\""], ["proof (prove)\nusing this:\n  abc_steps_l (as', am') ap (Suc stp) =\n  abc_step_l (bs, bm) (abc_fetch bs ap)\n\ngoal (1 subgoal):\n 1. abc_steps_l (as, am) ap (Suc (Suc stp)) =\n    abc_step_l (bs, bm) (abc_fetch bs ap)", "using g"], ["proof (prove)\nusing this:\n  abc_steps_l (as', am') ap (Suc stp) =\n  abc_step_l (bs, bm) (abc_fetch bs ap)\n  abc_step_l (as, am) (abc_fetch as ap) = (as', am')\n\ngoal (1 subgoal):\n 1. abc_steps_l (as, am) ap (Suc (Suc stp)) =\n    abc_step_l (bs, bm) (abc_fetch bs ap)", "by(simp add: abc_steps_l.simps)"], ["proof (state)\nthis:\n  abc_steps_l (as, am) ap (Suc (Suc stp)) =\n  abc_step_l (bs, bm) (abc_fetch bs ap)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_shift_fetch: \n  \"\\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0 \\<rbrakk>\n  \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)", "apply(cases b;cases s)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0; b = Bk; s = 0\\<rbrakk>\n    \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)\n 2. \\<And>nat.\n       \\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0; b = Bk;\n        s = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)\n 3. \\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0; b = Oc; s = 0\\<rbrakk>\n    \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)\n 4. \\<And>nat.\n       \\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0; b = Oc;\n        s = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fetch (shift A off) s b = (ac, ns + off)", "apply(auto simp: fetch.simps shift.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tm_shift_eq_step:\n  assumes exec: \"step (s, l, r) (A, 0) = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"step (s + off, l, r) (shift A off, off) = (s' + off, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (s + off, l, r) (shift A off, off) = (s' + off, l', r')", "using assms"], ["proof (prove)\nusing this:\n  step0 (s, l, r) A = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. step (s + off, l, r) (shift A off, off) = (s' + off, l', r')", "apply(simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case fetch A s (read r) of\n              (a, s') \\<Rightarrow> (s', update a (l, r))) =\n             (s', l', r');\n     0 < s'\\<rbrakk>\n    \\<Longrightarrow> (r = [] \\<longrightarrow>\n                       (case fetch (shift A off) s Bk of\n                        (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                       (s' + off, l', r')) \\<and>\n                      (r \\<noteq> [] \\<longrightarrow>\n                       (case fetch (shift A off) s (hd r) of\n                        (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                       (s' + off, l', r'))", "apply(cases \"fetch A s (read r)\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>update a (l, []) = (l', r'); 0 < s'; fetch A s Bk = (a, s');\n        r = []\\<rbrakk>\n       \\<Longrightarrow> (case fetch (shift A off) s Bk of\n                          (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                         (s' + off, l', r')\n 2. \\<And>a.\n       \\<lbrakk>update a (l, r) = (l', r'); 0 < s';\n        fetch A s (hd r) = (a, s'); r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (case fetch (shift A off) s (hd r) of\n                          (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                         (s' + off, l', r')", "apply(drule_tac [!] off = off in tm_shift_fetch, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare step.simps[simp del] steps.simps[simp del] shift.simps[simp del]"], ["", "lemma tm_shift_eq_steps: \n  assumes exec: \"steps (s, l, r) (A, 0) stp = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"steps (s + off, l, r) (shift A off, off) stp = (s' + off, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (s + off, l, r) (shift A off, off) stp = (s' + off, l', r')", "using exec notfinal"], ["proof (prove)\nusing this:\n  steps0 (s, l, r) A stp = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps (s + off, l, r) (shift A off, off) stp = (s' + off, l', r')", "proof(induct stp arbitrary: s' l' r', simp add: steps.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "fix stp s' l' r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "assume ind: \"\\<And>s' l' r'. \\<lbrakk>steps (s, l, r) (A, 0) stp = (s', l', r'); s' \\<noteq> 0\\<rbrakk> \n     \\<Longrightarrow> steps (s + off, l, r) (shift A off, off) stp = (s' + off, l', r')\"\n    and h: \" steps (s, l, r) (A, 0) (Suc stp) = (s', l', r')\" \"s' \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (s, l, r) A stp = (?s', ?l', ?r'); ?s' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> steps (s + off, l, r) (shift A off, off) stp =\n                    (?s' + off, ?l', ?r')\n  steps0 (s, l, r) A (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "obtain s1 l1 r1 where g: \"steps (s, l, r) (A, 0) stp = (s1, l1, r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 l1 r1.\n        steps0 (s, l, r) A stp = (s1, l1, r1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"steps (s, l, r) (A, 0) stp\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>s1 l1 r1.\n                   steps0 (s, l, r) A stp = (s1, l1, r1) \\<Longrightarrow>\n                   thesis;\n        steps0 (s, l, r) A stp = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "moreover"], ["proof (state)\nthis:\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "then"], ["proof (chain)\npicking this:\n  steps0 (s, l, r) A stp = (s1, l1, r1)", "have \"s1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> 0", "using h"], ["proof (prove)\nusing this:\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n  steps0 (s, l, r) A (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> 0", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (s, l, r) A stp = (s1, l1, r1);\n     step0 (s1, l1, r1) A = (s', l', r'); 0 < s'\\<rbrakk>\n    \\<Longrightarrow> 0 < s1", "apply(cases \"0 < s1\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "ultimately"], ["proof (chain)\npicking this:\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n  s1 \\<noteq> 0", "have \"steps (s + off, l, r) (shift A off, off) stp =\n                   (s1 + off, l1, r1)\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n  s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps (s + off, l, r) (shift A off, off) stp = (s1 + off, l1, r1)", "apply(intro ind, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps (s + off, l, r) (shift A off, off) stp = (s1 + off, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) A stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s + off, l, r)\n(shift A off, off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) A (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s + off, l, r) (shift A off, off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "thus \"steps (s + off, l, r) (shift A off, off) (Suc stp) = (s' + off, l', r')\""], ["proof (prove)\nusing this:\n  steps (s + off, l, r) (shift A off, off) stp = (s1 + off, l1, r1)\n\ngoal (1 subgoal):\n 1. steps (s + off, l, r) (shift A off, off) (Suc stp) = (s' + off, l', r')", "using h g assms"], ["proof (prove)\nusing this:\n  steps (s + off, l, r) (shift A off, off) stp = (s1 + off, l1, r1)\n  steps0 (s, l, r) A (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n  steps0 (s, l, r) A stp = (s1, l1, r1)\n  steps0 (s, l, r) A stp = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps (s + off, l, r) (shift A off, off) (Suc stp) = (s' + off, l', r')", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (s + off, l, r) (shift A off, off) stp =\n             (s1 + off, l1, r1);\n     step0 (s1, l1, r1) A = (s', l', r'); 0 < s';\n     steps0 (s, l, r) A stp = (s1, l1, r1);\n     steps0 (s, l, r) A stp = (s', l', r'); 0 < s'\\<rbrakk>\n    \\<Longrightarrow> step (s1 + off, l1, r1) (shift A off, off) =\n                      (s' + off, l', r')", "apply(intro tm_shift_eq_step, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps (s + off, l, r) (shift A off, off) (Suc stp) = (s' + off, l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma startof_ge1[simp]: \"Suc 0 \\<le> start_of ly as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> start_of ly as", "apply(simp add: start_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_Suc1: \"\\<lbrakk>ly = layout_of ap; \n       abc_fetch as ap = Some (Inc n)\\<rbrakk>\n       \\<Longrightarrow> start_of ly (Suc as) = start_of ly as + 2 * n + 9\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Inc n)\\<rbrakk>\n    \\<Longrightarrow> start_of ly (Suc as) = start_of ly as + 2 * n + 9", "apply(auto simp: start_of.simps layout_of.simps  \n      length_of.simps abc_fetch.simps \n      take_Suc_conv_app_nth split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_Suc2:\n  \"\\<lbrakk>ly = layout_of ap;\n  abc_fetch as ap = Some (Dec n e)\\<rbrakk> \\<Longrightarrow> \n        start_of ly (Suc as) = \n            start_of ly as + 2 * n + 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Dec n e)\\<rbrakk>\n    \\<Longrightarrow> start_of ly (Suc as) = start_of ly as + 2 * n + 16", "apply(auto simp: start_of.simps layout_of.simps  \n      length_of.simps abc_fetch.simps \n      take_Suc_conv_app_nth split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_Suc3:\n  \"\\<lbrakk>ly = layout_of ap;\n  abc_fetch as ap = Some (Goto n)\\<rbrakk> \\<Longrightarrow> \n  start_of ly (Suc as) = start_of ly as + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Goto n)\\<rbrakk>\n    \\<Longrightarrow> start_of ly (Suc as) = start_of ly as + 1", "apply(auto simp: start_of.simps layout_of.simps  \n      length_of.simps abc_fetch.simps \n      take_Suc_conv_app_nth split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_ci_inc: \n  \"length (ci ly ss (Inc n)) = 4*n + 18\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ci ly ss (Inc n)) = 4 * n + 18", "apply(auto simp: ci.simps length_findnth tinc_b_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_ci_dec: \n  \"length (ci ly ss (Dec n e)) = 4*n + 32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ci ly ss (Dec n e)) = 4 * n + 32", "apply(auto simp: ci.simps length_findnth tdec_b_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_ci_goto: \n  \"length (ci ly ss (Goto n )) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ci ly ss (Goto n)) = 2", "apply(auto simp: ci.simps length_findnth tdec_b_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma take_Suc_last[elim]: \"Suc as \\<le> length xs \\<Longrightarrow> \n            take (Suc as) xs = take as xs @ [xs ! as]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc as \\<le> length xs \\<Longrightarrow>\n    take (Suc as) xs = take as xs @ [xs ! as]", "proof(induct xs arbitrary: as)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as.\n       Suc as \\<le> length [] \\<Longrightarrow>\n       take (Suc as) [] = take as [] @ [[] ! as]\n 2. \\<And>a xs as.\n       \\<lbrakk>\\<And>as.\n                   Suc as \\<le> length xs \\<Longrightarrow>\n                   take (Suc as) xs = take as xs @ [xs ! as];\n        Suc as \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> take (Suc as) (a # xs) =\n                         take as (a # xs) @ [(a # xs) ! as]", "case (Cons a xs)"], ["proof (state)\nthis:\n  Suc ?as \\<le> length xs \\<Longrightarrow>\n  take (Suc ?as) xs = take ?as xs @ [xs ! ?as]\n  Suc as \\<le> length (a # xs)\n\ngoal (2 subgoals):\n 1. \\<And>as.\n       Suc as \\<le> length [] \\<Longrightarrow>\n       take (Suc as) [] = take as [] @ [[] ! as]\n 2. \\<And>a xs as.\n       \\<lbrakk>\\<And>as.\n                   Suc as \\<le> length xs \\<Longrightarrow>\n                   take (Suc as) xs = take as xs @ [xs ! as];\n        Suc as \\<le> length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> take (Suc as) (a # xs) =\n                         take as (a # xs) @ [(a # xs) ! as]", "then"], ["proof (chain)\npicking this:\n  Suc ?as \\<le> length xs \\<Longrightarrow>\n  take (Suc ?as) xs = take ?as xs @ [xs ! ?as]\n  Suc as \\<le> length (a # xs)", "show ?case"], ["proof (prove)\nusing this:\n  Suc ?as \\<le> length xs \\<Longrightarrow>\n  take (Suc ?as) xs = take ?as xs @ [xs ! ?as]\n  Suc as \\<le> length (a # xs)\n\ngoal (1 subgoal):\n 1. take (Suc as) (a # xs) = take as (a # xs) @ [(a # xs) ! as]", "by ( simp, cases as;simp)"], ["proof (state)\nthis:\n  take (Suc as) (a # xs) = take as (a # xs) @ [(a # xs) ! as]\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       Suc as \\<le> length [] \\<Longrightarrow>\n       take (Suc as) [] = take as [] @ [[] ! as]", "qed simp"], ["", "lemma concat_suc: \"Suc as \\<le> length xs \\<Longrightarrow> \n       concat (take (Suc as) xs) = concat (take as xs) @ xs! as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc as \\<le> length xs \\<Longrightarrow>\n    concat (take (Suc as) xs) = concat (take as xs) @ xs ! as", "apply(subgoal_tac \"take (Suc as) xs = take as xs @ [xs ! as]\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc as \\<le> length xs \\<Longrightarrow>\n    take (Suc as) xs = take as xs @ [xs ! as]", "by auto"], ["", "lemma concat_drop_suc_iff: \n  \"Suc n < length tps \\<Longrightarrow> concat (drop (Suc n) tps) = \n           tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < length tps \\<Longrightarrow>\n    concat (drop (Suc n) tps) =\n    tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "proof(induct tps arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       Suc n < length [] \\<Longrightarrow>\n       concat (drop (Suc n) []) =\n       [] ! Suc n @ concat (drop (Suc (Suc n)) [])\n 2. \\<And>a tps n.\n       \\<lbrakk>\\<And>n.\n                   Suc n < length tps \\<Longrightarrow>\n                   concat (drop (Suc n) tps) =\n                   tps ! Suc n @ concat (drop (Suc (Suc n)) tps);\n        Suc n < length (a # tps)\\<rbrakk>\n       \\<Longrightarrow> concat (drop (Suc n) (a # tps)) =\n                         (a # tps) ! Suc n @\n                         concat (drop (Suc (Suc n)) (a # tps))", "case (Cons a tps)"], ["proof (state)\nthis:\n  Suc ?n < length tps \\<Longrightarrow>\n  concat (drop (Suc ?n) tps) =\n  tps ! Suc ?n @ concat (drop (Suc (Suc ?n)) tps)\n  Suc n < length (a # tps)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       Suc n < length [] \\<Longrightarrow>\n       concat (drop (Suc n) []) =\n       [] ! Suc n @ concat (drop (Suc (Suc n)) [])\n 2. \\<And>a tps n.\n       \\<lbrakk>\\<And>n.\n                   Suc n < length tps \\<Longrightarrow>\n                   concat (drop (Suc n) tps) =\n                   tps ! Suc n @ concat (drop (Suc (Suc n)) tps);\n        Suc n < length (a # tps)\\<rbrakk>\n       \\<Longrightarrow> concat (drop (Suc n) (a # tps)) =\n                         (a # tps) ! Suc n @\n                         concat (drop (Suc (Suc n)) (a # tps))", "then"], ["proof (chain)\npicking this:\n  Suc ?n < length tps \\<Longrightarrow>\n  concat (drop (Suc ?n) tps) =\n  tps ! Suc ?n @ concat (drop (Suc (Suc ?n)) tps)\n  Suc n < length (a # tps)", "show ?case"], ["proof (prove)\nusing this:\n  Suc ?n < length tps \\<Longrightarrow>\n  concat (drop (Suc ?n) tps) =\n  tps ! Suc ?n @ concat (drop (Suc (Suc ?n)) tps)\n  Suc n < length (a # tps)\n\ngoal (1 subgoal):\n 1. concat (drop (Suc n) (a # tps)) =\n    (a # tps) ! Suc n @ concat (drop (Suc (Suc n)) (a # tps))", "apply(cases tps, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>n.\n                   n < length list \\<Longrightarrow>\n                   concat (drop n list) =\n                   list ! n @ concat (drop (Suc n) list);\n        n < Suc (length list); tps = a # list\\<rbrakk>\n       \\<Longrightarrow> concat (drop n (a # list)) =\n                         (a # list) ! n @ concat (drop n list)", "apply(cases n, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  concat (drop (Suc n) (a # tps)) =\n  (a # tps) ! Suc n @ concat (drop (Suc (Suc n)) (a # tps))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       Suc n < length [] \\<Longrightarrow>\n       concat (drop (Suc n) []) =\n       [] ! Suc n @ concat (drop (Suc (Suc n)) [])", "qed simp"], ["", "declare append_assoc[simp del]"], ["", "lemma  tm_append:\n  \"\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk> \\<Longrightarrow> \n  \\<exists> tp1 tp2. concat tps = tp1 @ tp @ tp2 \\<and> tp1 = \n  concat (take n tps) \\<and> tp2 = concat (drop (Suc n) tps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tp1 tp2.\n                         concat tps = tp1 @ tp @ tp2 \\<and>\n                         tp1 = concat (take n tps) \\<and>\n                         tp2 = concat (drop (Suc n) tps)", "apply(rule_tac x = \"concat (take n tps)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tp2.\n                         concat tps = concat (take n tps) @ tp @ tp2 \\<and>\n                         concat (take n tps) = concat (take n tps) \\<and>\n                         tp2 = concat (drop (Suc n) tps)", "apply(rule_tac x = \"concat (drop (Suc n) tps)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take n tps) @\n                      tp @ concat (drop (Suc n) tps) \\<and>\n                      concat (take n tps) = concat (take n tps) \\<and>\n                      concat (drop (Suc n) tps) = concat (drop (Suc n) tps)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take n tps) @\n                      tps ! n @ concat (drop (Suc n) tps)", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length tps; tp = tps ! 0\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take 0 tps) @\n                      tps ! 0 @ concat (drop (Suc 0) tps)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n                \\<Longrightarrow> concat tps =\n                                  concat (take n tps) @\n                                  tps ! n @ concat (drop (Suc n) tps);\n        Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n       \\<Longrightarrow> concat tps =\n                         concat (take (Suc n) tps) @\n                         tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "case 0"], ["proof (state)\nthis:\n  0 < length tps\n  tp = tps ! 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length tps; tp = tps ! 0\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take 0 tps) @\n                      tps ! 0 @ concat (drop (Suc 0) tps)\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n                \\<Longrightarrow> concat tps =\n                                  concat (take n tps) @\n                                  tps ! n @ concat (drop (Suc n) tps);\n        Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n       \\<Longrightarrow> concat tps =\n                         concat (take (Suc n) tps) @\n                         tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "then"], ["proof (chain)\npicking this:\n  0 < length tps\n  tp = tps ! 0", "show ?case"], ["proof (prove)\nusing this:\n  0 < length tps\n  tp = tps ! 0\n\ngoal (1 subgoal):\n 1. concat tps = concat (take 0 tps) @ tps ! 0 @ concat (drop (Suc 0) tps)", "by(cases tps; simp)"], ["proof (state)\nthis:\n  concat tps = concat (take 0 tps) @ tps ! 0 @ concat (drop (Suc 0) tps)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n                \\<Longrightarrow> concat tps =\n                                  concat (take n tps) @\n                                  tps ! n @ concat (drop (Suc n) tps);\n        Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n       \\<Longrightarrow> concat tps =\n                         concat (take (Suc n) tps) @\n                         tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n                \\<Longrightarrow> concat tps =\n                                  concat (take n tps) @\n                                  tps ! n @ concat (drop (Suc n) tps);\n        Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n       \\<Longrightarrow> concat tps =\n                         concat (take (Suc n) tps) @\n                         tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n  \\<Longrightarrow> concat tps =\n                    concat (take n tps) @\n                    tps ! n @ concat (drop (Suc n) tps)\n  Suc n < length tps\n  tp = tps ! Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n                \\<Longrightarrow> concat tps =\n                                  concat (take n tps) @\n                                  tps ! n @ concat (drop (Suc n) tps);\n        Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n       \\<Longrightarrow> concat tps =\n                         concat (take (Suc n) tps) @\n                         tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n  \\<Longrightarrow> concat tps =\n                    concat (take n tps) @\n                    tps ! n @ concat (drop (Suc n) tps)\n  Suc n < length tps\n  tp = tps ! Suc n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n  \\<Longrightarrow> concat tps =\n                    concat (take n tps) @\n                    tps ! n @ concat (drop (Suc n) tps)\n  Suc n < length tps\n  tp = tps ! Suc n\n\ngoal (1 subgoal):\n 1. concat tps =\n    concat (take (Suc n) tps) @\n    tps ! Suc n @ concat (drop (Suc (Suc n)) tps)", "apply(subgoal_tac \"concat (take n tps) @ (tps ! n) = \n               concat (take (Suc n) tps)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take n tps) @\n                               tps ! n @ concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n;\n     concat (take n tps) @ tps ! n = concat (take (Suc n) tps)\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take (Suc n) tps) @\n                      tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\n 2. \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take n tps) @\n                               tps ! n @ concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n    \\<Longrightarrow> concat (take n tps) @ tps ! n =\n                      concat (take (Suc n) tps)", "apply(simp only: append_assoc[THEN sym], simp only: append_assoc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n < length tps; tps ! Suc n = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take (Suc n) tps) @\n                               concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n;\n     concat (take n tps) @ tps ! n = concat (take (Suc n) tps)\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take (Suc n) tps) @\n                      tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\n 2. \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take n tps) @\n                               tps ! n @ concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n    \\<Longrightarrow> concat (take n tps) @ tps ! n =\n                      concat (take (Suc n) tps)", "apply(subgoal_tac \" concat (drop (Suc n) tps) = tps ! Suc n @ \n                  concat (drop (Suc (Suc n)) tps)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n < length tps; tps ! Suc n = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take (Suc n) tps) @\n                               concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n;\n     concat (take n tps) @ tps ! n = concat (take (Suc n) tps);\n     concat (drop (Suc n) tps) =\n     tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\\<rbrakk>\n    \\<Longrightarrow> concat tps =\n                      concat (take (Suc n) tps) @\n                      tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\n 2. \\<lbrakk>\\<lbrakk>n < length tps; tps ! Suc n = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take (Suc n) tps) @\n                               concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n;\n     concat (take n tps) @ tps ! n = concat (take (Suc n) tps)\\<rbrakk>\n    \\<Longrightarrow> concat (drop (Suc n) tps) =\n                      tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\n 3. \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take n tps) @\n                               tps ! n @ concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n    \\<Longrightarrow> concat (take n tps) @ tps ! n =\n                      concat (take (Suc n) tps)", "apply (metis append_take_drop_id concat_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>n < length tps; tps ! Suc n = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take (Suc n) tps) @\n                               concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n;\n     concat (take n tps) @ tps ! n = concat (take (Suc n) tps)\\<rbrakk>\n    \\<Longrightarrow> concat (drop (Suc n) tps) =\n                      tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\n 2. \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take n tps) @\n                               tps ! n @ concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n    \\<Longrightarrow> concat (take n tps) @ tps ! n =\n                      concat (take (Suc n) tps)", "apply(rule concat_drop_suc_iff,force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>n < length tps; tp = tps ! n\\<rbrakk>\n             \\<Longrightarrow> concat tps =\n                               concat (take n tps) @\n                               tps ! n @ concat (drop (Suc n) tps);\n     Suc n < length tps; tp = tps ! Suc n\\<rbrakk>\n    \\<Longrightarrow> concat (take n tps) @ tps ! n =\n                      concat (take (Suc n) tps)", "by (simp add: concat_suc)"], ["proof (state)\nthis:\n  concat tps =\n  concat (take (Suc n) tps) @ tps ! Suc n @ concat (drop (Suc (Suc n)) tps)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare append_assoc[simp]"], ["", "lemma length_tms_of[simp]: \"length (tms_of aprog) = length aprog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tms_of aprog) = length aprog", "apply(auto simp: tms_of.simps tpairs_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ci_nth: \n  \"\\<lbrakk>ly = layout_of aprog; \n  abc_fetch as aprog = Some ins\\<rbrakk>\n  \\<Longrightarrow> ci ly (start_of ly as) ins = tms_of aprog ! as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins\\<rbrakk>\n    \\<Longrightarrow> ci ly (start_of ly as) ins = tms_of aprog ! as", "apply(simp add: tms_of.simps tpairs_of.simps \n      abc_fetch.simps del: map_append split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_split:\"\\<lbrakk>\n        ly = layout_of aprog;\n        abc_fetch as aprog = Some ins\\<rbrakk>\n      \\<Longrightarrow> \\<exists> tp1 tp2. concat (tms_of aprog) = \n            tp1 @ (ci ly (start_of ly as) ins) @ tp2\n            \\<and> tp1 = concat (take as (tms_of aprog)) \\<and> \n              tp2 = concat (drop (Suc as) (tms_of aprog))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tp1 tp2.\n                         concat (tms_of aprog) =\n                         tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n                         tp1 = concat (take as (tms_of aprog)) \\<and>\n                         tp2 = concat (drop (Suc as) (tms_of aprog))", "apply(insert tm_append[of \"as\" \"tms_of aprog\" \n        \"ci ly (start_of ly as) ins\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog))\\<rbrakk>\n    \\<Longrightarrow> concat (tms_of aprog) =\n                      concat (take as (tms_of aprog)) @\n                      ci (layout_of aprog) (start_of (layout_of aprog) as)\n                       ins @\n                      concat (drop (Suc as) (tms_of aprog))", "apply(subgoal_tac \"ci ly (start_of ly as) ins = (tms_of aprog) ! as\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog));\n     ci ly (start_of ly as) ins = tms_of aprog ! as\\<rbrakk>\n    \\<Longrightarrow> concat (tms_of aprog) =\n                      concat (take as (tms_of aprog)) @\n                      ci (layout_of aprog) (start_of (layout_of aprog) as)\n                       ins @\n                      concat (drop (Suc as) (tms_of aprog))\n 2. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog))\\<rbrakk>\n    \\<Longrightarrow> ci ly (start_of ly as) ins = tms_of aprog ! as", "apply(subgoal_tac \"length (tms_of aprog) = length aprog\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog));\n     ci ly (start_of ly as) ins = tms_of aprog ! as;\n     length (tms_of aprog) = length aprog\\<rbrakk>\n    \\<Longrightarrow> concat (tms_of aprog) =\n                      concat (take as (tms_of aprog)) @\n                      ci (layout_of aprog) (start_of (layout_of aprog) as)\n                       ins @\n                      concat (drop (Suc as) (tms_of aprog))\n 2. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog));\n     ci ly (start_of ly as) ins = tms_of aprog ! as\\<rbrakk>\n    \\<Longrightarrow> length (tms_of aprog) = length aprog\n 3. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog))\\<rbrakk>\n    \\<Longrightarrow> ci ly (start_of ly as) ins = tms_of aprog ! as", "apply(simp add: abc_fetch.simps split: if_splits, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of aprog; abc_fetch as aprog = Some ins;\n     \\<lbrakk>as < length aprog;\n      ci (layout_of aprog) (start_of (layout_of aprog) as) ins =\n      tms_of aprog ! as\\<rbrakk>\n     \\<Longrightarrow> concat (tms_of aprog) =\n                       concat (take as (tms_of aprog)) @\n                       tms_of aprog ! as @\n                       concat (drop (Suc as) (tms_of aprog))\\<rbrakk>\n    \\<Longrightarrow> ci ly (start_of ly as) ins = tms_of aprog ! as", "apply(intro ci_nth, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma div_apart: \"\\<lbrakk>x mod (2::nat) = 0; y mod 2 = 0\\<rbrakk> \n          \\<Longrightarrow> (x + y) div 2 = x div 2 + y div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_even x; is_even y\\<rbrakk>\n    \\<Longrightarrow> (x + y) div 2 = x div 2 + y div 2", "by(auto)"], ["", "lemma length_layout_of[simp]: \"length (layout_of aprog) = length aprog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (layout_of aprog) = length aprog", "by(auto simp: layout_of.simps)"], ["", "lemma length_tms_of_elem_even[intro]:  \"n < length ap \\<Longrightarrow> length (tms_of ap ! n) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length ap \\<Longrightarrow> is_even (length (tms_of ap ! n))", "apply(cases \"ap ! n\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>n < length ap; ap ! n = Inc x1\\<rbrakk>\n       \\<Longrightarrow> is_even (length (tms_of ap ! n))\n 2. \\<And>x21 x22.\n       \\<lbrakk>n < length ap; ap ! n = Dec x21 x22\\<rbrakk>\n       \\<Longrightarrow> is_even (length (tms_of ap ! n))\n 3. \\<And>x3.\n       \\<lbrakk>n < length ap; ap ! n = Goto x3\\<rbrakk>\n       \\<Longrightarrow> is_even (length (tms_of ap ! n))", "by (auto simp: tms_of.simps tpairs_of.simps ci.simps length_findnth tinc_b_def tdec_b_def)"], ["", "lemma compile_mod2: \"length (concat (take n (tms_of ap))) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (concat (take n (tms_of ap))))", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_even (length (concat (take 0 (tms_of ap))))\n 2. \\<And>n.\n       is_even (length (concat (take n (tms_of ap)))) \\<Longrightarrow>\n       is_even (length (concat (take (Suc n) (tms_of ap))))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. is_even (length (concat (take 0 (tms_of ap))))\n 2. \\<And>n.\n       is_even (length (concat (take n (tms_of ap)))) \\<Longrightarrow>\n       is_even (length (concat (take (Suc n) (tms_of ap))))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (concat (take 0 (tms_of ap))))", "by (auto simp add: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  is_even (length (concat (take 0 (tms_of ap))))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_even (length (concat (take n (tms_of ap)))) \\<Longrightarrow>\n       is_even (length (concat (take (Suc n) (tms_of ap))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_even (length (concat (take n (tms_of ap)))) \\<Longrightarrow>\n       is_even (length (concat (take (Suc n) (tms_of ap))))", "case (Suc n)"], ["proof (state)\nthis:\n  is_even (length (concat (take n (tms_of ap))))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_even (length (concat (take n (tms_of ap)))) \\<Longrightarrow>\n       is_even (length (concat (take (Suc n) (tms_of ap))))", "hence \"n < length (tms_of ap) \\<Longrightarrow> is_even (length (concat (take (Suc n) (tms_of ap))))\""], ["proof (prove)\nusing this:\n  is_even (length (concat (take n (tms_of ap))))\n\ngoal (1 subgoal):\n 1. n < length (tms_of ap) \\<Longrightarrow>\n    is_even (length (concat (take (Suc n) (tms_of ap))))", "unfolding take_Suc_conv_app_nth"], ["proof (prove)\nusing this:\n  is_even (length (concat (take n (tms_of ap))))\n\ngoal (1 subgoal):\n 1. n < length (tms_of ap) \\<Longrightarrow>\n    is_even (length (concat (take n (tms_of ap) @ [tms_of ap ! n])))", "by fastforce"], ["proof (state)\nthis:\n  n < length (tms_of ap) \\<Longrightarrow>\n  is_even (length (concat (take (Suc n) (tms_of ap))))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       is_even (length (concat (take n (tms_of ap)))) \\<Longrightarrow>\n       is_even (length (concat (take (Suc n) (tms_of ap))))", "with Suc"], ["proof (chain)\npicking this:\n  is_even (length (concat (take n (tms_of ap))))\n  n < length (tms_of ap) \\<Longrightarrow>\n  is_even (length (concat (take (Suc n) (tms_of ap))))", "show ?case"], ["proof (prove)\nusing this:\n  is_even (length (concat (take n (tms_of ap))))\n  n < length (tms_of ap) \\<Longrightarrow>\n  is_even (length (concat (take (Suc n) (tms_of ap))))\n\ngoal (1 subgoal):\n 1. is_even (length (concat (take (Suc n) (tms_of ap))))", "by(cases \"n < length (tms_of ap)\", auto)"], ["proof (state)\nthis:\n  is_even (length (concat (take (Suc n) (tms_of ap))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tpa_states:\n  \"\\<lbrakk>tp = concat (take as (tms_of ap));\n  as \\<le> length ap\\<rbrakk> \\<Longrightarrow> \n  start_of (layout_of ap) as = Suc (length tp div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tp = concat (take as (tms_of ap)); as \\<le> length ap\\<rbrakk>\n    \\<Longrightarrow> start_of (layout_of ap) as = Suc (length tp div 2)", "proof(induct as arbitrary: tp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tp.\n       \\<lbrakk>tp = concat (take 0 (tms_of ap)); 0 \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) 0 = Suc (length tp div 2)\n 2. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "case 0"], ["proof (state)\nthis:\n  tp = concat (take 0 (tms_of ap))\n  0 \\<le> length ap\n\ngoal (2 subgoals):\n 1. \\<And>tp.\n       \\<lbrakk>tp = concat (take 0 (tms_of ap)); 0 \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) 0 = Suc (length tp div 2)\n 2. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "thus \"?case\""], ["proof (prove)\nusing this:\n  tp = concat (take 0 (tms_of ap))\n  0 \\<le> length ap\n\ngoal (1 subgoal):\n 1. start_of (layout_of ap) 0 = Suc (length tp div 2)", "by(simp add: start_of.simps)"], ["proof (state)\nthis:\n  start_of (layout_of ap) 0 = Suc (length tp div 2)\n\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "case (Suc as tp)"], ["proof (state)\nthis:\n  \\<lbrakk>?tp = concat (take as (tms_of ap)); as \\<le> length ap\\<rbrakk>\n  \\<Longrightarrow> start_of (layout_of ap) as = Suc (length ?tp div 2)\n  tp = concat (take (Suc as) (tms_of ap))\n  Suc as \\<le> length ap\n\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "have ind: \"\\<And>tp. \\<lbrakk>tp = concat (take as (tms_of ap)); as \\<le> length ap\\<rbrakk> \\<Longrightarrow>\n    start_of (layout_of ap) as = Suc (length tp div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tp.\n       \\<lbrakk>tp = concat (take as (tms_of ap));\n        as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) as = Suc (length tp div 2)", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>?tp = concat (take as (tms_of ap)); as \\<le> length ap\\<rbrakk>\n  \\<Longrightarrow> start_of (layout_of ap) as = Suc (length ?tp div 2)\n\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "have tp: \"tp = concat (take (Suc as) (tms_of ap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tp = concat (take (Suc as) (tms_of ap))", "by fact"], ["proof (state)\nthis:\n  tp = concat (take (Suc as) (tms_of ap))\n\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "have le: \"Suc as \\<le> length ap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc as \\<le> length ap", "by fact"], ["proof (state)\nthis:\n  Suc as \\<le> length ap\n\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "have a: \"start_of (layout_of ap) as = Suc (length (concat (take as (tms_of ap))) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of (layout_of ap) as =\n    Suc (length (concat (take as (tms_of ap))) div 2)", "using le"], ["proof (prove)\nusing this:\n  Suc as \\<le> length ap\n\ngoal (1 subgoal):\n 1. start_of (layout_of ap) as =\n    Suc (length (concat (take as (tms_of ap))) div 2)", "by(intro ind, simp_all)"], ["proof (state)\nthis:\n  start_of (layout_of ap) as =\n  Suc (length (concat (take as (tms_of ap))) div 2)\n\ngoal (1 subgoal):\n 1. \\<And>as tp.\n       \\<lbrakk>\\<And>tp.\n                   \\<lbrakk>tp = concat (take as (tms_of ap));\n                    as \\<le> length ap\\<rbrakk>\n                   \\<Longrightarrow> start_of (layout_of ap) as =\n                                     Suc (length tp div 2);\n        tp = concat (take (Suc as) (tms_of ap));\n        Suc as \\<le> length ap\\<rbrakk>\n       \\<Longrightarrow> start_of (layout_of ap) (Suc as) =\n                         Suc (length tp div 2)", "from a tp le"], ["proof (chain)\npicking this:\n  start_of (layout_of ap) as =\n  Suc (length (concat (take as (tms_of ap))) div 2)\n  tp = concat (take (Suc as) (tms_of ap))\n  Suc as \\<le> length ap", "show \"?case\""], ["proof (prove)\nusing this:\n  start_of (layout_of ap) as =\n  Suc (length (concat (take as (tms_of ap))) div 2)\n  tp = concat (take (Suc as) (tms_of ap))\n  Suc as \\<le> length ap\n\ngoal (1 subgoal):\n 1. start_of (layout_of ap) (Suc as) = Suc (length tp div 2)", "apply(simp add: start_of.simps take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap\\<rbrakk>\n    \\<Longrightarrow> length (concat (take as (tms_of ap))) div 2 +\n                      layout_of ap ! as =\n                      (length (concat (take as (tms_of ap))) +\n                       length (tms_of ap ! as)) div\n                      2", "apply(subgoal_tac \"length (concat (take as (tms_of ap))) mod 2= 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap;\n     is_even (length (concat (take as (tms_of ap))))\\<rbrakk>\n    \\<Longrightarrow> length (concat (take as (tms_of ap))) div 2 +\n                      layout_of ap ! as =\n                      (length (concat (take as (tms_of ap))) +\n                       length (tms_of ap ! as)) div\n                      2\n 2. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap\\<rbrakk>\n    \\<Longrightarrow> is_even (length (concat (take as (tms_of ap))))", "apply(subgoal_tac \" length (tms_of ap ! as) mod 2 = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap;\n     is_even (length (concat (take as (tms_of ap))));\n     is_even (length (tms_of ap ! as))\\<rbrakk>\n    \\<Longrightarrow> length (concat (take as (tms_of ap))) div 2 +\n                      layout_of ap ! as =\n                      (length (concat (take as (tms_of ap))) +\n                       length (tms_of ap ! as)) div\n                      2\n 2. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap;\n     is_even (length (concat (take as (tms_of ap))))\\<rbrakk>\n    \\<Longrightarrow> is_even (length (tms_of ap ! as))\n 3. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap\\<rbrakk>\n    \\<Longrightarrow> is_even (length (concat (take as (tms_of ap))))", "apply(simp add: Abacus.div_apart)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap;\n     is_even (length (concat (take as (tms_of ap))));\n     is_even (length (tms_of ap ! as))\\<rbrakk>\n    \\<Longrightarrow> layout_of ap ! as = length (tms_of ap ! as) div 2\n 2. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap;\n     is_even (length (concat (take as (tms_of ap))))\\<rbrakk>\n    \\<Longrightarrow> is_even (length (tms_of ap ! as))\n 3. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap\\<rbrakk>\n    \\<Longrightarrow> is_even (length (concat (take as (tms_of ap))))", "apply(simp add: layout_of.simps ci_length  tms_of.simps tpairs_of.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap;\n     is_even (length (concat (take as (tms_of ap))))\\<rbrakk>\n    \\<Longrightarrow> is_even (length (tms_of ap ! as))\n 2. \\<lbrakk>sum_list (take as (layout_of ap)) =\n             length (concat (take as (tms_of ap))) div 2;\n     tp = concat (take as (tms_of ap)) @ tms_of ap ! as;\n     Suc as \\<le> length ap\\<rbrakk>\n    \\<Longrightarrow> is_even (length (concat (take as (tms_of ap))))", "apply(auto  intro: compile_mod2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  start_of (layout_of ap) (Suc as) = Suc (length tp div 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare fetch.simps[simp]"], ["", "lemma append_append_fetch: \n  \"\\<lbrakk>length tp1 mod 2 = 0; length tp mod 2 = 0;\n      length tp1 div 2 < a \\<and> a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow>fetch (tp1 @ tp @ tp2) a b = fetch tp (a - length tp1 div 2) b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_even (length tp1); is_even (length tp);\n     length tp1 div 2 < a \\<and>\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> fetch (tp1 @ tp @ tp2) a b =\n                      fetch tp (a - length tp1 div 2) b", "apply(subgoal_tac \"\\<exists> x. a = length tp1 div 2 + x\", erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_even (length tp1); is_even (length tp);\n        length tp1 div 2 < a \\<and>\n        a \\<le> length tp1 div 2 + length tp div 2;\n        a = length tp1 div 2 + x\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2) a b =\n                         fetch tp (a - length tp1 div 2) b\n 2. \\<lbrakk>is_even (length tp1); is_even (length tp);\n     length tp1 div 2 < a \\<and>\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_even (length tp1); is_even (length tp);\n        length tp1 div 2 < a \\<and>\n        a \\<le> length tp1 div 2 + length tp div 2;\n        a = length tp1 div 2 + x\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2) a b =\n                         fetch tp (a - length tp1 div 2) b\n 2. \\<lbrakk>is_even (length tp1); is_even (length tp);\n     length tp1 div 2 < a \\<and>\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(case_tac x, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x nat.\n       \\<lbrakk>is_even (length tp1); is_even (length tp);\n        length tp1 div 2 < a \\<and>\n        a \\<le> length tp1 div 2 + length tp div 2;\n        a = length tp1 div 2 + x; x = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2) a b =\n                         fetch tp (a - length tp1 div 2) b\n 2. \\<lbrakk>is_even (length tp1); is_even (length tp);\n     length tp1 div 2 < a \\<and>\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(subgoal_tac \"length tp1 div 2 + Suc nat = \n             Suc (length tp1 div 2 + nat)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x nat.\n       \\<lbrakk>is_even (length tp1); is_even (length tp);\n        length tp1 div 2 < a \\<and>\n        a \\<le> length tp1 div 2 + length tp div 2;\n        a = length tp1 div 2 + x; x = Suc nat;\n        length tp1 div 2 + Suc nat = Suc (length tp1 div 2 + nat)\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2) a b =\n                         fetch tp (a - length tp1 div 2) b\n 2. \\<And>x nat.\n       \\<lbrakk>is_even (length tp1); is_even (length tp);\n        length tp1 div 2 < a \\<and>\n        a \\<le> length tp1 div 2 + length tp div 2;\n        a = length tp1 div 2 + x; x = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length tp1 div 2 + Suc nat =\n                         Suc (length tp1 div 2 + nat)\n 3. \\<lbrakk>is_even (length tp1); is_even (length tp);\n     length tp1 div 2 < a \\<and>\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(simp only: fetch.simps nth_of.simps, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp)\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2)\n                          (Suc (length tp1 div 2 + nat)) b =\n                         fetch tp (Suc nat) b\n 2. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(cases b, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Bk\\<rbrakk>\n       \\<Longrightarrow> \\<not> length tp + length tp2\n                                \\<le> 2 * nat \\<longrightarrow>\n                         (length tp \\<le> 2 * nat \\<longrightarrow>\n                          (tp @ tp2) ! (2 * nat) = (Nop, 0)) \\<and>\n                         (\\<not> length tp \\<le> 2 * nat \\<longrightarrow>\n                          (tp @ tp2) ! (2 * nat) = tp ! (2 * nat))\n 2. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Oc\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2)\n                          (Suc (length tp1 div 2 + nat)) b =\n                         fetch tp (Suc nat) b\n 3. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(subgoal_tac \"2 * (length tp1 div 2) = length tp1\", simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Bk\\<rbrakk>\n       \\<Longrightarrow> \\<not> length tp + length tp2\n                                \\<le> 2 * nat \\<longrightarrow>\n                         (length tp \\<le> 2 * nat \\<longrightarrow>\n                          (tp @ tp2) ! (2 * nat) = (Nop, 0)) \\<and>\n                         (\\<not> length tp \\<le> 2 * nat \\<longrightarrow>\n                          (tp @ tp2) ! (2 * nat) = tp ! (2 * nat))\n 2. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Bk\\<rbrakk>\n       \\<Longrightarrow> 2 * (length tp1 div 2) = length tp1\n 3. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Oc\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2)\n                          (Suc (length tp1 div 2 + nat)) b =\n                         fetch tp (Suc nat) b\n 4. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(subgoal_tac \"2 * nat < length tp\", simp add: nth_append, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Bk\\<rbrakk>\n       \\<Longrightarrow> 2 * (length tp1 div 2) = length tp1\n 2. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Oc\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2)\n                          (Suc (length tp1 div 2 + nat)) b =\n                         fetch tp (Suc nat) b\n 3. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(subgoal_tac \"2 * (length tp1 div 2) = length tp1\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Bk\\<rbrakk>\n       \\<Longrightarrow> 2 * (length tp1 div 2) = length tp1\n 2. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Oc\\<rbrakk>\n       \\<Longrightarrow> fetch (tp1 @ tp @ tp2)\n                          (Suc (length tp1 div 2 + nat)) b =\n                         fetch tp (Suc nat) b\n 3. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(subgoal_tac \"2 * nat < length tp\", simp add: nth_append, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Suc nat \\<le> length tp div 2;\n        a = Suc (length tp1 div 2 + nat); even (length tp1);\n        even (length tp); b = Oc;\n        \\<not> length tp \\<le> Suc (2 * nat)\\<rbrakk>\n       \\<Longrightarrow> (tp1 @ tp @ tp2) ! Suc (length tp1 + 2 * nat) =\n                         tp ! Suc (2 * nat)\n 2. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(auto simp: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>even (length tp1); even (length tp); length tp1 div 2 < a;\n     a \\<le> length tp1 div 2 + length tp div 2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. a = length tp1 div 2 + x", "apply(rule_tac x = \"a - length tp1 div 2\" in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma step_eq_fetch':\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and fetch: \"abc_fetch as ap = Some ins\"\n    and range1: \"s \\<ge> start_of ly as\"\n    and range2: \"s < start_of ly (Suc as)\"\n  shows \"fetch tp s b = fetch (ci ly (start_of ly as) ins)\n       (Suc s - start_of ly as) b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "have \"\\<exists>tp1 tp2. concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n    tp1 = concat (take as (tms_of ap)) \\<and> tp2 = concat (drop (Suc as) (tms_of ap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tp1 tp2.\n       concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n       tp1 = concat (take as (tms_of ap)) \\<and>\n       tp2 = concat (drop (Suc as) (tms_of ap))", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  abc_fetch as ap = Some ins\n  start_of ly as \\<le> s\n  s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. \\<exists>tp1 tp2.\n       concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n       tp1 = concat (take as (tms_of ap)) \\<and>\n       tp2 = concat (drop (Suc as) (tms_of ap))", "by(intro t_split, simp_all)"], ["proof (state)\nthis:\n  \\<exists>tp1 tp2.\n     concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n     tp1 = concat (take as (tms_of ap)) \\<and>\n     tp2 = concat (drop (Suc as) (tms_of ap))\n\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "then"], ["proof (chain)\npicking this:\n  \\<exists>tp1 tp2.\n     concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n     tp1 = concat (take as (tms_of ap)) \\<and>\n     tp2 = concat (drop (Suc as) (tms_of ap))", "obtain tp1 tp2 where a: \"concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n    tp1 = concat (take as (tms_of ap)) \\<and> tp2 = concat (drop (Suc as) (tms_of ap))\""], ["proof (prove)\nusing this:\n  \\<exists>tp1 tp2.\n     concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n     tp1 = concat (take as (tms_of ap)) \\<and>\n     tp2 = concat (drop (Suc as) (tms_of ap))\n\ngoal (1 subgoal):\n 1. (\\<And>tp1 tp2.\n        concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n        tp1 = concat (take as (tms_of ap)) \\<and>\n        tp2 = concat (drop (Suc as) (tms_of ap)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n  tp1 = concat (take as (tms_of ap)) \\<and>\n  tp2 = concat (drop (Suc as) (tms_of ap))\n\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "then"], ["proof (chain)\npicking this:\n  concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n  tp1 = concat (take as (tms_of ap)) \\<and>\n  tp2 = concat (drop (Suc as) (tms_of ap))", "have b: \"start_of (layout_of ap) as = Suc (length tp1 div 2)\""], ["proof (prove)\nusing this:\n  concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n  tp1 = concat (take as (tms_of ap)) \\<and>\n  tp2 = concat (drop (Suc as) (tms_of ap))\n\ngoal (1 subgoal):\n 1. start_of (layout_of ap) as = Suc (length tp1 div 2)", "using fetch"], ["proof (prove)\nusing this:\n  concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n  tp1 = concat (take as (tms_of ap)) \\<and>\n  tp2 = concat (drop (Suc as) (tms_of ap))\n  abc_fetch as ap = Some ins\n\ngoal (1 subgoal):\n 1. start_of (layout_of ap) as = Suc (length tp1 div 2)", "by(intro tpa_states, simp, simp add: abc_fetch.simps split: if_splits)"], ["proof (state)\nthis:\n  start_of (layout_of ap) as = Suc (length tp1 div 2)\n\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "have \"fetch (tp1 @ (ci ly (start_of ly as) ins) @ tp2)  s b = \n        fetch (ci ly (start_of ly as) ins) (s - length tp1 div 2) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (tp1 @ ci ly (start_of ly as) ins @ tp2) s b =\n    fetch (ci ly (start_of ly as) ins) (s - length tp1 div 2) b", "proof(intro append_append_fetch)"], ["proof (state)\ngoal (3 subgoals):\n 1. is_even (length tp1)\n 2. is_even (length (ci ly (start_of ly as) ins))\n 3. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "show \"length tp1 mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length tp1)", "using a"], ["proof (prove)\nusing this:\n  concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n  tp1 = concat (take as (tms_of ap)) \\<and>\n  tp2 = concat (drop (Suc as) (tms_of ap))\n\ngoal (1 subgoal):\n 1. is_even (length tp1)", "by(auto, rule_tac compile_mod2)"], ["proof (state)\nthis:\n  is_even (length tp1)\n\ngoal (2 subgoals):\n 1. is_even (length (ci ly (start_of ly as) ins))\n 2. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. is_even (length (ci ly (start_of ly as) ins))\n 2. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "show \"length (ci ly (start_of ly as) ins) mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (length (ci ly (start_of ly as) ins))", "by(cases ins, auto simp: ci.simps length_findnth tinc_b_def tdec_b_def)"], ["proof (state)\nthis:\n  is_even (length (ci ly (start_of ly as) ins))\n\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "show \"length tp1 div 2 < s \\<and> s \\<le> \n      length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "have \"length (ci ly (start_of ly as) ins) div 2 = length_of ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ci ly (start_of ly as) ins) div 2 = length_of ins", "using ci_length"], ["proof (prove)\nusing this:\n  length (ci ?ns ?n ?ai) div 2 = length_of ?ai\n\ngoal (1 subgoal):\n 1. length (ci ly (start_of ly as) ins) div 2 = length_of ins", "by simp"], ["proof (state)\nthis:\n  length (ci ly (start_of ly as) ins) div 2 = length_of ins\n\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "moreover"], ["proof (state)\nthis:\n  length (ci ly (start_of ly as) ins) div 2 = length_of ins\n\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "have \"start_of ly (Suc as) = start_of ly as + length_of ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly (Suc as) = start_of ly as + length_of ins", "using fetch layout"], ["proof (prove)\nusing this:\n  abc_fetch as ap = Some ins\n  ly = layout_of ap\n\ngoal (1 subgoal):\n 1. start_of ly (Suc as) = start_of ly as + length_of ins", "apply(simp add: start_of.simps abc_fetch.simps List.take_Suc_conv_app_nth \n            split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; as < length ap; ap ! as = ins\\<rbrakk>\n    \\<Longrightarrow> layout_of ap ! as = length_of ins", "apply(simp add: layout_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  start_of ly (Suc as) = start_of ly as + length_of ins\n\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "ultimately"], ["proof (chain)\npicking this:\n  length (ci ly (start_of ly as) ins) div 2 = length_of ins\n  start_of ly (Suc as) = start_of ly as + length_of ins", "show \"?thesis\""], ["proof (prove)\nusing this:\n  length (ci ly (start_of ly as) ins) div 2 = length_of ins\n  start_of ly (Suc as) = start_of ly as + length_of ins\n\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "using b layout range1 range2"], ["proof (prove)\nusing this:\n  length (ci ly (start_of ly as) ins) div 2 = length_of ins\n  start_of ly (Suc as) = start_of ly as + length_of ins\n  start_of (layout_of ap) as = Suc (length tp1 div 2)\n  ly = layout_of ap\n  start_of ly as \\<le> s\n  s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. length tp1 div 2 < s \\<and>\n    s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length tp1 div 2 < s \\<and>\n  s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length tp1 div 2 < s \\<and>\n  s \\<le> length tp1 div 2 + length (ci ly (start_of ly as) ins) div 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fetch (tp1 @ ci ly (start_of ly as) ins @ tp2) s b =\n  fetch (ci ly (start_of ly as) ins) (s - length tp1 div 2) b\n\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  fetch (tp1 @ ci ly (start_of ly as) ins @ tp2) s b =\n  fetch (ci ly (start_of ly as) ins) (s - length tp1 div 2) b\n\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "using b layout a compile"], ["proof (prove)\nusing this:\n  fetch (tp1 @ ci ly (start_of ly as) ins @ tp2) s b =\n  fetch (ci ly (start_of ly as) ins) (s - length tp1 div 2) b\n  start_of (layout_of ap) as = Suc (length tp1 div 2)\n  ly = layout_of ap\n  concat (tms_of ap) = tp1 @ ci ly (start_of ly as) ins @ tp2 \\<and>\n  tp1 = concat (take as (tms_of ap)) \\<and>\n  tp2 = concat (drop (Suc as) (tms_of ap))\n  tp = tm_of ap\n\ngoal (1 subgoal):\n 1. fetch tp s b =\n    fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b", "apply(simp add: tm_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fetch tp s b =\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_eq_fetch: \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and abc_fetch: \"abc_fetch as ap = Some ins\" \n    and fetch: \"fetch (ci ly (start_of ly as) ins)\n       (Suc s - start_of ly as) b = (ac, ns)\"\n    and notfinal: \"ns \\<noteq> 0\"\n  shows \"fetch tp s b = (ac, ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "have \"s \\<ge> start_of ly as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly as \\<le> s", "proof(cases \"s \\<ge> start_of ly as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s\n 2. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "case True"], ["proof (state)\nthis:\n  start_of ly as \\<le> s\n\ngoal (2 subgoals):\n 1. start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s\n 2. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. start_of ly as \\<le> s", "by simp"], ["proof (state)\nthis:\n  start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "case False"], ["proof (state)\nthis:\n  \\<not> start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "have \"\\<not> start_of ly as \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s", "by fact"], ["proof (state)\nthis:\n  \\<not> start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "then"], ["proof (chain)\npicking this:\n  \\<not> start_of ly as \\<le> s", "have \"Suc s - start_of ly as = 0\""], ["proof (prove)\nusing this:\n  \\<not> start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. Suc s - start_of ly as = 0", "by arith"], ["proof (state)\nthis:\n  Suc s - start_of ly as = 0\n\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "then"], ["proof (chain)\npicking this:\n  Suc s - start_of ly as = 0", "have \"fetch (ci ly (start_of ly as) ins)\n       (Suc s - start_of ly as) b = (Nop, 0)\""], ["proof (prove)\nusing this:\n  Suc s - start_of ly as = 0\n\ngoal (1 subgoal):\n 1. fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)", "by(simp add: fetch.simps)"], ["proof (state)\nthis:\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)\n\ngoal (1 subgoal):\n 1. \\<not> start_of ly as \\<le> s \\<Longrightarrow> start_of ly as \\<le> s", "with notfinal fetch"], ["proof (chain)\npicking this:\n  ns \\<noteq> 0\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (ac, ns)\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  ns \\<noteq> 0\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (ac, ns)\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)\n\ngoal (1 subgoal):\n 1. start_of ly as \\<le> s", "by(simp)"], ["proof (state)\nthis:\n  start_of ly as \\<le> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "moreover"], ["proof (state)\nthis:\n  start_of ly as \\<le> s\n\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "have \"s < start_of ly (Suc as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s < start_of ly (Suc as)", "proof(cases \"s < start_of ly (Suc as)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s < start_of ly (Suc as) \\<Longrightarrow> s < start_of ly (Suc as)\n 2. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "case True"], ["proof (state)\nthis:\n  s < start_of ly (Suc as)\n\ngoal (2 subgoals):\n 1. s < start_of ly (Suc as) \\<Longrightarrow> s < start_of ly (Suc as)\n 2. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. s < start_of ly (Suc as)", "by simp"], ["proof (state)\nthis:\n  s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "case False"], ["proof (state)\nthis:\n  \\<not> s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "have h: \"\\<not> s < start_of ly (Suc as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as)", "by fact"], ["proof (state)\nthis:\n  \\<not> s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "then"], ["proof (chain)\npicking this:\n  \\<not> s < start_of ly (Suc as)", "have \"s > start_of ly as\""], ["proof (prove)\nusing this:\n  \\<not> s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. start_of ly as < s", "using abc_fetch layout"], ["proof (prove)\nusing this:\n  \\<not> s < start_of ly (Suc as)\n  abc_fetch as ap = Some ins\n  ly = layout_of ap\n\ngoal (1 subgoal):\n 1. start_of ly as < s", "apply(simp add: start_of.simps abc_fetch.simps split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap;\n     \\<not> s < Suc (sum_list (take (Suc as) (layout_of ap)));\n     as < length ap; ap ! as = ins\\<rbrakk>\n    \\<Longrightarrow> Suc (sum_list (take as (layout_of ap))) < s", "apply(simp add: List.take_Suc_conv_app_nth, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap;\n     \\<not> s < Suc (sum_list (take as (layout_of ap)) + layout_of ap ! as);\n     as < length ap; ins = ap ! as\\<rbrakk>\n    \\<Longrightarrow> Suc (sum_list (take as (layout_of ap))) < s", "apply(subgoal_tac \"layout_of ap ! as > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ly = layout_of ap;\n     \\<not> s < Suc (sum_list (take as (layout_of ap)) + layout_of ap ! as);\n     as < length ap; ins = ap ! as; 0 < layout_of ap ! as\\<rbrakk>\n    \\<Longrightarrow> Suc (sum_list (take as (layout_of ap))) < s\n 2. \\<lbrakk>ly = layout_of ap;\n     \\<not> s < Suc (sum_list (take as (layout_of ap)) + layout_of ap ! as);\n     as < length ap; ins = ap ! as\\<rbrakk>\n    \\<Longrightarrow> 0 < layout_of ap ! as", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap;\n     \\<not> s < Suc (sum_list (take as (layout_of ap)) + layout_of ap ! as);\n     as < length ap; ins = ap ! as\\<rbrakk>\n    \\<Longrightarrow> 0 < layout_of ap ! as", "apply(simp add: layout_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = map length_of ap;\n     \\<not> s < Suc (sum_list (take as (map length_of ap)) +\n                     length_of (ap ! as));\n     as < length ap; ins = ap ! as\\<rbrakk>\n    \\<Longrightarrow> 0 < length_of (ap ! as)", "apply(cases \"ap!as\", auto simp: length_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  start_of ly as < s\n\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "from this and h"], ["proof (chain)\npicking this:\n  start_of ly as < s\n  \\<not> s < start_of ly (Suc as)", "have \"fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)\""], ["proof (prove)\nusing this:\n  start_of ly as < s\n  \\<not> s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)", "using abc_fetch layout"], ["proof (prove)\nusing this:\n  start_of ly as < s\n  \\<not> s < start_of ly (Suc as)\n  abc_fetch as ap = Some ins\n  ly = layout_of ap\n\ngoal (1 subgoal):\n 1. fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)", "apply(cases b;cases ins)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; b = Bk;\n        start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; ins = Inc x1\\<rbrakk>\n       \\<Longrightarrow> fetch (ci ly (start_of ly as) ins)\n                          (Suc s - start_of ly as) b =\n                         (Nop, 0)\n 2. \\<And>x21 x22.\n       \\<lbrakk>start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; b = Bk;\n        start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap;\n        ins = Dec x21 x22\\<rbrakk>\n       \\<Longrightarrow> fetch (ci ly (start_of ly as) ins)\n                          (Suc s - start_of ly as) b =\n                         (Nop, 0)\n 3. \\<And>x3.\n       \\<lbrakk>start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; b = Bk;\n        start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap;\n        ins = Goto x3\\<rbrakk>\n       \\<Longrightarrow> fetch (ci ly (start_of ly as) ins)\n                          (Suc s - start_of ly as) b =\n                         (Nop, 0)\n 4. \\<And>x1.\n       \\<lbrakk>start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; b = Oc;\n        start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; ins = Inc x1\\<rbrakk>\n       \\<Longrightarrow> fetch (ci ly (start_of ly as) ins)\n                          (Suc s - start_of ly as) b =\n                         (Nop, 0)\n 5. \\<And>x21 x22.\n       \\<lbrakk>start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; b = Oc;\n        start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap;\n        ins = Dec x21 x22\\<rbrakk>\n       \\<Longrightarrow> fetch (ci ly (start_of ly as) ins)\n                          (Suc s - start_of ly as) b =\n                         (Nop, 0)\n 6. \\<And>x3.\n       \\<lbrakk>start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap; b = Oc;\n        start_of ly as < s; \\<not> s < start_of ly (Suc as);\n        abc_fetch as ap = Some ins; ly = layout_of ap;\n        ins = Goto x3\\<rbrakk>\n       \\<Longrightarrow> fetch (ci ly (start_of ly as) ins)\n                          (Suc s - start_of ly as) b =\n                         (Nop, 0)", "apply(simp_all add:Suc_diff_le start_of_Suc2 start_of_Suc1 start_of_Suc3)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>\\<not> s < start_of (layout_of ap) as + 2 * x1 + 9; b = Bk;\n        abc_fetch as ap = Some (Inc x1); ly = layout_of ap;\n        ins = Inc x1\\<rbrakk>\n       \\<Longrightarrow> \\<not> length\n                                 (ci (layout_of ap)\n                                   (start_of (layout_of ap) as) (Inc x1))\n                                \\<le> 2 *\n(s - start_of (layout_of ap) as) \\<longrightarrow>\n                         ci (layout_of ap) (start_of (layout_of ap) as)\n                          (Inc x1) !\n                         (2 * (s - start_of (layout_of ap) as)) =\n                         (Nop, 0)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> s < start_of (layout_of ap) as + 2 * x21 + 16;\n        b = Bk; abc_fetch as ap = Some (Dec x21 x22); ly = layout_of ap;\n        ins = Dec x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> length\n                                 (ci (layout_of ap)\n                                   (start_of (layout_of ap) as)\n                                   (Dec x21 x22))\n                                \\<le> 2 *\n(s - start_of (layout_of ap) as) \\<longrightarrow>\n                         ci (layout_of ap) (start_of (layout_of ap) as)\n                          (Dec x21 x22) !\n                         (2 * (s - start_of (layout_of ap) as)) =\n                         (Nop, 0)\n 3. \\<And>x3.\n       \\<lbrakk>start_of (layout_of ap) as < s; b = Bk;\n        abc_fetch as ap = Some (Goto x3); ly = layout_of ap;\n        ins = Goto x3\\<rbrakk>\n       \\<Longrightarrow> \\<not> length\n                                 (ci (layout_of ap)\n                                   (start_of (layout_of ap) as) (Goto x3))\n                                \\<le> 2 *\n(s - start_of (layout_of ap) as) \\<longrightarrow>\n                         ci (layout_of ap) (start_of (layout_of ap) as)\n                          (Goto x3) !\n                         (2 * (s - start_of (layout_of ap) as)) =\n                         (Nop, 0)\n 4. \\<And>x1.\n       \\<lbrakk>\\<not> s < start_of (layout_of ap) as + 2 * x1 + 9; b = Oc;\n        abc_fetch as ap = Some (Inc x1); ly = layout_of ap;\n        ins = Inc x1\\<rbrakk>\n       \\<Longrightarrow> \\<not> length\n                                 (ci (layout_of ap)\n                                   (start_of (layout_of ap) as) (Inc x1))\n                                \\<le> Suc\n (2 * (s - start_of (layout_of ap) as)) \\<longrightarrow>\n                         ci (layout_of ap) (start_of (layout_of ap) as)\n                          (Inc x1) !\n                         Suc (2 * (s - start_of (layout_of ap) as)) =\n                         (Nop, 0)\n 5. \\<And>x21 x22.\n       \\<lbrakk>\\<not> s < start_of (layout_of ap) as + 2 * x21 + 16;\n        b = Oc; abc_fetch as ap = Some (Dec x21 x22); ly = layout_of ap;\n        ins = Dec x21 x22\\<rbrakk>\n       \\<Longrightarrow> \\<not> length\n                                 (ci (layout_of ap)\n                                   (start_of (layout_of ap) as)\n                                   (Dec x21 x22))\n                                \\<le> Suc\n (2 * (s - start_of (layout_of ap) as)) \\<longrightarrow>\n                         ci (layout_of ap) (start_of (layout_of ap) as)\n                          (Dec x21 x22) !\n                         Suc (2 * (s - start_of (layout_of ap) as)) =\n                         (Nop, 0)\n 6. \\<And>x3.\n       \\<lbrakk>start_of (layout_of ap) as < s; b = Oc;\n        abc_fetch as ap = Some (Goto x3); ly = layout_of ap;\n        ins = Goto x3\\<rbrakk>\n       \\<Longrightarrow> \\<not> length\n                                 (ci (layout_of ap)\n                                   (start_of (layout_of ap) as) (Goto x3))\n                                \\<le> Suc\n (2 * (s - start_of (layout_of ap) as)) \\<longrightarrow>\n                         ci (layout_of ap) (start_of (layout_of ap) as)\n                          (Goto x3) !\n                         Suc (2 * (s - start_of (layout_of ap) as)) =\n                         (Nop, 0)", "by (simp_all only: length_ci_inc length_ci_dec length_ci_goto, auto)"], ["proof (state)\nthis:\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)\n\ngoal (1 subgoal):\n 1. \\<not> s < start_of ly (Suc as) \\<Longrightarrow>\n    s < start_of ly (Suc as)", "from fetch and notfinal this"], ["proof (chain)\npicking this:\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (ac, ns)\n  ns \\<noteq> 0\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (ac, ns)\n  ns \\<noteq> 0\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (Nop, 0)\n\ngoal (1 subgoal):\n 1. s < start_of ly (Suc as)", "by simp"], ["proof (state)\nthis:\n  s < start_of ly (Suc as)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "ultimately"], ["proof (chain)\npicking this:\n  start_of ly as \\<le> s\n  s < start_of ly (Suc as)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  start_of ly as \\<le> s\n  s < start_of ly (Suc as)\n\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "using assms"], ["proof (prove)\nusing this:\n  start_of ly as \\<le> s\n  s < start_of ly (Suc as)\n  ly = layout_of ap\n  tp = tm_of ap\n  abc_fetch as ap = Some ins\n  fetch (ci ly (start_of ly as) ins) (Suc s - start_of ly as) b = (ac, ns)\n  ns \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fetch tp s b = (ac, ns)", "by(drule_tac b= b and ins = ins in step_eq_fetch', auto)"], ["proof (state)\nthis:\n  fetch tp s b = (ac, ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_eq_in:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and fetch: \"abc_fetch as ap = Some ins\"    \n    and exec: \"step (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) \n  = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"step (s, l, r) (tp, 0) = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step0 (s, l, r) tp = (s', l', r')", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  abc_fetch as ap = Some ins\n  step (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) =\n  (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. step0 (s, l, r) tp = (s', l', r')", "apply(simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; tp = tm_of ap; abc_fetch as ap = Some ins;\n     (case fetch (ci (layout_of ap) (start_of (layout_of ap) as) ins)\n            (Suc s - start_of (layout_of ap) as) (read r) of\n      (a, s') \\<Rightarrow> (s', update a (l, r))) =\n     (s', l', r');\n     0 < s'\\<rbrakk>\n    \\<Longrightarrow> (r = [] \\<longrightarrow>\n                       (case fetch (tm_of ap) s Bk of\n                        (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                       (s', l', r')) \\<and>\n                      (r \\<noteq> [] \\<longrightarrow>\n                       (case fetch (tm_of ap) s (hd r) of\n                        (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                       (s', l', r'))", "apply(cases \"fetch (ci (layout_of ap) (start_of (layout_of ap) as) ins)\n    (Suc s - start_of (layout_of ap) as) (read r)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some ins; update a (l, r) = (l', r'); 0 < s';\n        fetch (ci (layout_of ap) (start_of (layout_of ap) as) ins)\n         (Suc s - start_of (layout_of ap) as) (read r) =\n        (a, s')\\<rbrakk>\n       \\<Longrightarrow> (r = [] \\<longrightarrow>\n                          (case fetch (tm_of ap) s Bk of\n                           (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                          (s', l', r')) \\<and>\n                         (r \\<noteq> [] \\<longrightarrow>\n                          (case fetch (tm_of ap) s (hd r) of\n                           (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                          (s', l', r'))", "using layout"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some ins; update a (l, r) = (l', r'); 0 < s';\n        fetch (ci (layout_of ap) (start_of (layout_of ap) as) ins)\n         (Suc s - start_of (layout_of ap) as) (read r) =\n        (a, s')\\<rbrakk>\n       \\<Longrightarrow> (r = [] \\<longrightarrow>\n                          (case fetch (tm_of ap) s Bk of\n                           (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                          (s', l', r')) \\<and>\n                         (r \\<noteq> [] \\<longrightarrow>\n                          (case fetch (tm_of ap) s (hd r) of\n                           (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                          (s', l', r'))", "apply(drule_tac s = s and b = \"read r\" and ac = a in step_eq_fetch, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma steps_eq_in:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some ins\"    \n    and exec: \"steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp \n  = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n  shows \"steps (s, l, r) (tp, 0) stp = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp stp = (s', l', r')", "using exec notfinal"], ["proof (prove)\nusing this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp stp = (s', l', r')", "proof(induct stp arbitrary: s' l' r', simp add: steps.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "fix stp s' l' r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "assume ind: \n    \"\\<And>s' l' r'. \\<lbrakk>steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n              \\<Longrightarrow> steps (s, l, r) (tp, 0) stp = (s', l', r')\"\n    and h: \"steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) (Suc stp) = (s', l', r')\" \"s' \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<lbrakk>steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n            stp =\n           (?s', ?l', ?r');\n   ?s' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> steps0 (s, l, r) tp stp = (?s', ?l', ?r')\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n   (Suc stp) =\n  (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "obtain s1 l1 r1 where g: \"steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp = \n                        (s1, l1, r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s1 l1 r1.\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         stp =\n        (s1, l1, r1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>s1 l1 r1.\n                   steps (s, l, r)\n                    (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n                   (s1, l1, r1) \\<Longrightarrow>\n                   thesis;\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         stp =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "moreover"], ["proof (state)\nthis:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "hence \"s1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> 0", "using h"], ["proof (prove)\nusing this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n   (Suc stp) =\n  (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> 0", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - Suc 0) stp =\n             (s1, l1, r1);\n     step (s1, l1, r1)\n      (ci ly (start_of ly as) ins, start_of ly as - Suc 0) =\n     (s', l', r');\n     0 < s'\\<rbrakk>\n    \\<Longrightarrow> 0 < s1", "apply(cases \"0 < s1\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "ultimately"], ["proof (chain)\npicking this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n  s1 \\<noteq> 0", "have \"steps (s, l, r) (tp, 0) stp = (s1, l1, r1)\""], ["proof (prove)\nusing this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n  s1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp stp = (s1, l1, r1)", "apply(rule_tac ind, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (s, l, r) tp stp = (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r)\n                             (ci ly (start_of ly as) ins,\n                              start_of ly as - 1)\n                             stp =\n                            (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s, l, r) tp stp = (s', l', r');\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         (Suc stp) =\n        (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "thus \"steps (s, l, r) (tp, 0) (Suc stp) = (s', l', r')\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) tp stp = (s1, l1, r1)\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "using h g assms"], ["proof (prove)\nusing this:\n  steps0 (s, l, r) tp stp = (s1, l1, r1)\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n   (Suc stp) =\n  (s', l', r')\n  s' \\<noteq> 0\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s1, l1, r1)\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some ins\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp (Suc stp) = (s', l', r')", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (s, l, r) (tm_of ap) stp = (s1, l1, r1);\n     step (s1, l1, r1)\n      (ci (layout_of ap) (start_of (layout_of ap) as) ins,\n       start_of (layout_of ap) as - Suc 0) =\n     (s', l', r');\n     0 < s';\n     steps (s, l, r)\n      (ci (layout_of ap) (start_of (layout_of ap) as) ins,\n       start_of (layout_of ap) as - Suc 0)\n      stp =\n     (s1, l1, r1);\n     ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     steps (s, l, r)\n      (ci (layout_of ap) (start_of (layout_of ap) as) ins,\n       start_of (layout_of ap) as - Suc 0)\n      stp =\n     (s', l', r');\n     0 < s'\\<rbrakk>\n    \\<Longrightarrow> step0 (s1, l1, r1) (tm_of ap) = (s', l', r')", "apply(rule_tac step_eq_in, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (s, l, r) tp (Suc stp) = (s', l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_append_fetch_first: \n  \"\\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0\\<rbrakk> \\<Longrightarrow> \n    fetch (A @ B) s b = (ac, ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fetch A s b = (ac, ns); ns \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fetch (A @ B) s b = (ac, ns)", "by(cases b;cases s;force simp: fetch.simps nth_append split: if_splits)"], ["", "lemma tm_append_first_step_eq: \n  assumes \"step (s, l, r) (A, off) = (s', l', r')\"\n    and \"s' \\<noteq> 0\"\n  shows \"step (s, l, r) (A @ B, off) = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step (s, l, r) (A @ B, off) = (s', l', r')", "using assms"], ["proof (prove)\nusing this:\n  step (s, l, r) (A, off) = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. step (s, l, r) (A @ B, off) = (s', l', r')", "apply(simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case fetch A (s - off) (read r) of\n              (a, s') \\<Rightarrow> (s', update a (l, r))) =\n             (s', l', r');\n     0 < s'\\<rbrakk>\n    \\<Longrightarrow> (r = [] \\<longrightarrow>\n                       (case fetch (A @ B) (s - off) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                       (s', l', r')) \\<and>\n                      (r \\<noteq> [] \\<longrightarrow>\n                       (case fetch (A @ B) (s - off) (hd r) of\n                        (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                       (s', l', r'))", "apply(cases \"fetch A (s - off) (read r)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(case fetch A (s - off) (read r) of\n                 (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                (s', l', r');\n        0 < s'; fetch A (s - off) (read r) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (r = [] \\<longrightarrow>\n                          (case fetch (A @ B) (s - off) Bk of\n                           (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                          (s', l', r')) \\<and>\n                         (r \\<noteq> [] \\<longrightarrow>\n                          (case fetch (A @ B) (s - off) (hd r) of\n                           (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                          (s', l', r'))", "apply(frule_tac  B = B and b = \"read r\" in tm_append_fetch_first, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tm_append_first_steps_eq: \n  assumes \"steps (s, l, r) (A, off) stp = (s', l', r')\"\n    and \"s' \\<noteq> 0\"\n  shows \"steps (s, l, r) (A @ B, off) stp = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps (s, l, r) (A @ B, off) stp = (s', l', r')", "using assms"], ["proof (prove)\nusing this:\n  steps (s, l, r) (A, off) stp = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps (s, l, r) (A @ B, off) stp = (s', l', r')", "proof(induct stp arbitrary: s' l' r', simp add: steps.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r) (A, off) stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp =\n                                     (s', l', r');\n        steps (s, l, r) (A, off) (Suc stp) = (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s, l, r) (A @ B, off) (Suc stp) =\n                         (s', l', r')", "fix stp s' l' r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r) (A, off) stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp =\n                                     (s', l', r');\n        steps (s, l, r) (A, off) (Suc stp) = (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s, l, r) (A @ B, off) (Suc stp) =\n                         (s', l', r')", "assume ind: \"\\<And>s' l' r'. \\<lbrakk>steps (s, l, r) (A, off) stp = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp = (s', l', r')\"\n    and h: \"steps (s, l, r) (A, off) (Suc stp) = (s', l', r')\" \"s' \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<lbrakk>steps (s, l, r) (A, off) stp = (?s', ?l', ?r');\n   ?s' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp = (?s', ?l', ?r')\n  steps (s, l, r) (A, off) (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r) (A, off) stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp =\n                                     (s', l', r');\n        steps (s, l, r) (A, off) (Suc stp) = (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s, l, r) (A @ B, off) (Suc stp) =\n                         (s', l', r')", "obtain sa la ra where a: \"steps (s, l, r) (A, off) stp = (sa, la, ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa la ra.\n        steps (s, l, r) (A, off) stp = (sa, la, ra) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"steps (s, l, r) (A, off) stp\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>sa la ra.\n                   steps (s, l, r) (A, off) stp =\n                   (sa, la, ra) \\<Longrightarrow>\n                   thesis;\n        steps (s, l, r) (A, off) stp = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  steps (s, l, r) (A, off) stp = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r) (A, off) stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp =\n                                     (s', l', r');\n        steps (s, l, r) (A, off) (Suc stp) = (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s, l, r) (A @ B, off) (Suc stp) =\n                         (s', l', r')", "hence \"steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> sa \\<noteq> 0\""], ["proof (prove)\nusing this:\n  steps (s, l, r) (A, off) stp = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> sa \\<noteq> 0", "using h ind[of sa la ra]"], ["proof (prove)\nusing this:\n  steps (s, l, r) (A, off) stp = (sa, la, ra)\n  steps (s, l, r) (A, off) (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n  \\<lbrakk>steps (s, l, r) (A, off) stp = (sa, la, ra);\n   sa \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> sa \\<noteq> 0", "apply(cases sa, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> sa \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps (s, l, r) (A, off) stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps (s, l, r) (A @ B, off) stp =\n                                     (s', l', r');\n        steps (s, l, r) (A, off) (Suc stp) = (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps (s, l, r) (A @ B, off) (Suc stp) =\n                         (s', l', r')", "thus \"steps (s, l, r) (A @ B, off) (Suc stp) = (s', l', r')\""], ["proof (prove)\nusing this:\n  steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> sa \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps (s, l, r) (A @ B, off) (Suc stp) = (s', l', r')", "using h a"], ["proof (prove)\nusing this:\n  steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> sa \\<noteq> 0\n  steps (s, l, r) (A, off) (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n  steps (s, l, r) (A, off) stp = (sa, la, ra)\n\ngoal (1 subgoal):\n 1. steps (s, l, r) (A @ B, off) (Suc stp) = (s', l', r')", "apply(simp add: step_red)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (s, l, r) (A @ B, off) stp = (sa, la, ra) \\<and> 0 < sa;\n     step (sa, la, ra) (A, off) = (s', l', r'); 0 < s';\n     steps (s, l, r) (A, off) stp = (sa, la, ra)\\<rbrakk>\n    \\<Longrightarrow> step (sa, la, ra) (A @ B, off) = (s', l', r')", "apply(intro tm_append_first_step_eq, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps (s, l, r) (A @ B, off) (Suc stp) = (s', l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_append_second_fetch_eq:\n  assumes\n    even: \"length A mod 2 = 0\"\n    and off: \"off = length A div 2\"\n    and fetch: \"fetch B s b = (ac, ns)\"\n    and notfinal: \"ns \\<noteq> 0\"\n  shows \"fetch (A @ shift B off) (s + off) b = (ac, ns + off)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (A @ shift B off) (s + off) b = (ac, ns + off)", "using assms"], ["proof (prove)\nusing this:\n  is_even (length A)\n  off = length A div 2\n  fetch B s b = (ac, ns)\n  ns \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fetch (A @ shift B off) (s + off) b = (ac, ns + off)", "by(cases b;cases s,auto simp: nth_append shift.simps split: if_splits)"], ["", "lemma tm_append_second_step_eq: \n  assumes \n    exec: \"step0 (s, l, r) B = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"step0 (s + off, l, r) (A @ shift B off) = (s' + off, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step0 (s + off, l, r) (A @ shift B off) = (s' + off, l', r')", "using assms"], ["proof (prove)\nusing this:\n  step0 (s, l, r) B = (s', l', r')\n  s' \\<noteq> 0\n  off = length A div 2\n  is_even (length A)\n\ngoal (1 subgoal):\n 1. step0 (s + off, l, r) (A @ shift B off) = (s' + off, l', r')", "apply(simp add: step.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case fetch B s (read r) of\n              (a, s') \\<Rightarrow> (s', update a (l, r))) =\n             (s', l', r');\n     0 < s'; off = length A div 2; is_even (length A)\\<rbrakk>\n    \\<Longrightarrow> (r = [] \\<longrightarrow>\n                       (case fetch (A @ shift B (length A div 2))\n                              (s + length A div 2) Bk of\n                        (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                       (s' + length A div 2, l', r')) \\<and>\n                      (r \\<noteq> [] \\<longrightarrow>\n                       (case fetch (A @ shift B (length A div 2))\n                              (s + length A div 2) (hd r) of\n                        (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                       (s' + length A div 2, l', r'))", "apply(cases \"fetch B s (read r)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(case fetch B s (read r) of\n                 (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                (s', l', r');\n        0 < s'; off = length A div 2; is_even (length A);\n        fetch B s (read r) = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (r = [] \\<longrightarrow>\n                          (case fetch (A @ shift B (length A div 2))\n                                 (s + length A div 2) Bk of\n                           (a, s') \\<Rightarrow> (s', update a (l, []))) =\n                          (s' + length A div 2, l', r')) \\<and>\n                         (r \\<noteq> [] \\<longrightarrow>\n                          (case fetch (A @ shift B (length A div 2))\n                                 (s + length A div 2) (hd r) of\n                           (a, s') \\<Rightarrow> (s', update a (l, r))) =\n                          (s' + length A div 2, l', r'))", "apply(frule_tac tm_append_second_fetch_eq, simp_all, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tm_append_second_steps_eq: \n  assumes \n    exec: \"steps (s, l, r) (B, 0) stp = (s', l', r')\"\n    and notfinal: \"s' \\<noteq> 0\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"steps (s + off, l, r) (A @ shift B off, 0) stp = (s' + off, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (s + off, l, r) (A @ shift B off) stp = (s' + off, l', r')", "using exec notfinal"], ["proof (prove)\nusing this:\n  steps0 (s, l, r) B stp = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps0 (s + off, l, r) (A @ shift B off) stp = (s' + off, l', r')", "proof(induct stp arbitrary: s' l' r')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s' l' r'.\n       \\<lbrakk>steps0 (s, l, r) B 0 = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off) 0 =\n                         (s' + off, l', r')\n 2. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "case 0"], ["proof (state)\nthis:\n  steps0 (s, l, r) B 0 = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>s' l' r'.\n       \\<lbrakk>steps0 (s, l, r) B 0 = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off) 0 =\n                         (s' + off, l', r')\n 2. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "thus \"steps0 (s + off, l, r) (A @ shift B off) 0 = (s' + off, l', r')\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) B 0 = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps0 (s + off, l, r) (A @ shift B off) 0 = (s' + off, l', r')", "by(simp add: steps.simps)"], ["proof (state)\nthis:\n  steps0 (s + off, l, r) (A @ shift B off) 0 = (s' + off, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "case (Suc stp s' l' r')"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (s, l, r) B stp = (?s', ?l', ?r'); ?s' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off) stp =\n                    (?s' + off, ?l', ?r')\n  steps0 (s, l, r) B (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "have ind: \"\\<And>s' l' r'. \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r'); s' \\<noteq> 0\\<rbrakk> \\<Longrightarrow> \n    steps0 (s + off, l, r) (A @ shift B off) stp = (s' + off, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' l' r'.\n       \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n        s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off) stp =\n                         (s' + off, l', r')", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>steps0 (s, l, r) B stp = (?s', ?l', ?r'); ?s' \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off) stp =\n                    (?s' + off, ?l', ?r')\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "have h: \"steps0 (s, l, r) B (Suc stp) = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (s, l, r) B (Suc stp) = (s', l', r')", "by fact"], ["proof (state)\nthis:\n  steps0 (s, l, r) B (Suc stp) = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "have k: \"s' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<noteq> 0", "by fact"], ["proof (state)\nthis:\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "obtain s'' l'' r'' where a: \"steps0 (s, l, r) B stp = (s'', l'', r'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'' l'' r''.\n        steps0 (s, l, r) B stp = (s'', l'', r'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod_cases3)"], ["proof (state)\nthis:\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "then"], ["proof (chain)\npicking this:\n  steps0 (s, l, r) B stp = (s'', l'', r'')", "have b: \"s'' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n\ngoal (1 subgoal):\n 1. s'' \\<noteq> 0", "using h k"], ["proof (prove)\nusing this:\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n  steps0 (s, l, r) B (Suc stp) = (s', l', r')\n  s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s'' \\<noteq> 0", "by(intro notI, auto)"], ["proof (state)\nthis:\n  s'' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "from a b"], ["proof (chain)\npicking this:\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n  s'' \\<noteq> 0", "have c: \"steps0 (s + off, l, r) (A @ shift B off) stp = (s'' + off, l'', r'')\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n  s'' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. steps0 (s + off, l, r) (A @ shift B off) stp = (s'' + off, l'', r'')", "by(erule_tac ind, simp)"], ["proof (state)\nthis:\n  steps0 (s + off, l, r) (A @ shift B off) stp = (s'' + off, l'', r'')\n\ngoal (1 subgoal):\n 1. \\<And>stp s' l' r'.\n       \\<lbrakk>\\<And>s' l' r'.\n                   \\<lbrakk>steps0 (s, l, r) B stp = (s', l', r');\n                    s' \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> steps0 (s + off, l, r)\n(A @ shift B off) stp =\n                                     (s' + off, l', r');\n        steps0 (s, l, r) B (Suc stp) = (s', l', r'); s' \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> steps0 (s + off, l, r) (A @ shift B off)\n                          (Suc stp) =\n                         (s' + off, l', r')", "from c b h a k assms"], ["proof (chain)\npicking this:\n  steps0 (s + off, l, r) (A @ shift B off) stp = (s'' + off, l'', r'')\n  s'' \\<noteq> 0\n  steps0 (s, l, r) B (Suc stp) = (s', l', r')\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n  s' \\<noteq> 0\n  steps0 (s, l, r) B stp = (s', l', r')\n  s' \\<noteq> 0\n  off = length A div 2\n  is_even (length A)", "show \"?case\""], ["proof (prove)\nusing this:\n  steps0 (s + off, l, r) (A @ shift B off) stp = (s'' + off, l'', r'')\n  s'' \\<noteq> 0\n  steps0 (s, l, r) B (Suc stp) = (s', l', r')\n  steps0 (s, l, r) B stp = (s'', l'', r'')\n  s' \\<noteq> 0\n  steps0 (s, l, r) B stp = (s', l', r')\n  s' \\<noteq> 0\n  off = length A div 2\n  is_even (length A)\n\ngoal (1 subgoal):\n 1. steps0 (s + off, l, r) (A @ shift B off) (Suc stp) = (s' + off, l', r')", "by(auto intro:tm_append_second_step_eq)"], ["proof (state)\nthis:\n  steps0 (s + off, l, r) (A @ shift B off) (Suc stp) = (s' + off, l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_append_second_fetch0_eq:\n  assumes\n    even: \"length A mod 2 = 0\"\n    and off: \"off = length A div 2\"\n    and fetch: \"fetch B s b = (ac, 0)\"\n    and notfinal: \"s \\<noteq> 0\"\n  shows \"fetch (A @ shift B off) (s + off) b = (ac, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch (A @ shift B off) (s + off) b = (ac, 0)", "using assms"], ["proof (prove)\nusing this:\n  is_even (length A)\n  off = length A div 2\n  fetch B s b = (ac, 0)\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fetch (A @ shift B off) (s + off) b = (ac, 0)", "apply(cases b;cases s)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>is_even (length A); off = length A div 2;\n     fetch B s b = (ac, 0); s \\<noteq> 0; b = Bk; is_even (length A);\n     off = length A div 2; fetch B s b = (ac, 0); s \\<noteq> 0;\n     s = 0\\<rbrakk>\n    \\<Longrightarrow> fetch (A @ shift B off) (s + off) b = (ac, 0)\n 2. \\<And>nat.\n       \\<lbrakk>is_even (length A); off = length A div 2;\n        fetch B s b = (ac, 0); s \\<noteq> 0; b = Bk; is_even (length A);\n        off = length A div 2; fetch B s b = (ac, 0); s \\<noteq> 0;\n        s = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fetch (A @ shift B off) (s + off) b = (ac, 0)\n 3. \\<lbrakk>is_even (length A); off = length A div 2;\n     fetch B s b = (ac, 0); s \\<noteq> 0; b = Oc; is_even (length A);\n     off = length A div 2; fetch B s b = (ac, 0); s \\<noteq> 0;\n     s = 0\\<rbrakk>\n    \\<Longrightarrow> fetch (A @ shift B off) (s + off) b = (ac, 0)\n 4. \\<And>nat.\n       \\<lbrakk>is_even (length A); off = length A div 2;\n        fetch B s b = (ac, 0); s \\<noteq> 0; b = Oc; is_even (length A);\n        off = length A div 2; fetch B s b = (ac, 0); s \\<noteq> 0;\n        s = Suc nat\\<rbrakk>\n       \\<Longrightarrow> fetch (A @ shift B off) (s + off) b = (ac, 0)", "apply(auto simp: fetch.simps nth_append shift.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tm_append_second_halt_eq:\n  assumes \n    exec: \"steps (Suc 0, l, r) (B, 0) stp = (0, l', r')\"\n    and wf_B: \"tm_wf (B, 0)\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"steps (Suc off, l, r) (A @ shift B off, 0) stp = (0, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "have \"\\<exists>n. \\<not> is_final (steps0 (1, l, r) B n) \\<and> steps0 (1, l, r) B (Suc n) = (0, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n       steps0 (1, l, r) B (Suc n) = (0, l', r')", "using exec"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) B stp = (0, l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n       steps0 (1, l, r) B (Suc n) = (0, l', r')", "by(rule_tac before_final, simp)"], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n     steps0 (1, l, r) B (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "then"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n     steps0 (1, l, r) B (Suc n) = (0, l', r')", "obtain n where a: \n    \"\\<not> is_final (steps0 (1, l, r) B n) \\<and> steps0 (1, l, r) B (Suc n) = (0, l', r')\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n     steps0 (1, l, r) B (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n        steps0 (1, l, r) B (Suc n) = (0, l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "obtain s'' l'' r'' where b: \"steps0 (1, l, r) B n = (s'', l'', r'') \\<and> s'' >0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'' l'' r''.\n        steps0 (1, l, r) B n = (s'', l'', r'') \\<and>\n        0 < s'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. (\\<And>s'' l'' r''.\n        steps0 (1, l, r) B n = (s'', l'', r'') \\<and>\n        0 < s'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"steps0 (1, l, r) B n\", auto)"], ["proof (state)\nthis:\n  steps0 (1, l, r) B n = (s'', l'', r'') \\<and> 0 < s''\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "have c: \"steps (Suc 0 + off, l, r) (A @ shift B off, 0) n = (s'' + off, l'', r'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (Suc 0 + off, l, r) (A @ shift B off) n = (s'' + off, l'', r'')", "using a b assms"], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n  steps0 (1, l, r) B n = (s'', l'', r'') \\<and> 0 < s''\n  steps0 (Suc 0, l, r) B stp = (0, l', r')\n  tm_wf0 B\n  off = length A div 2\n  is_even (length A)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0 + off, l, r) (A @ shift B off) n = (s'' + off, l'', r'')", "by(rule_tac tm_append_second_steps_eq, simp_all)"], ["proof (state)\nthis:\n  steps0 (Suc 0 + off, l, r) (A @ shift B off) n = (s'' + off, l'', r'')\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "obtain ac where d: \"fetch B s'' (read r'') = (ac, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ac.\n        fetch B s'' (read r'') = (ac, 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using  b a"], ["proof (prove)\nusing this:\n  steps0 (1, l, r) B n = (s'', l'', r'') \\<and> 0 < s''\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. (\\<And>ac.\n        fetch B s'' (read r'') = (ac, 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"fetch B s'' (read r'')\", auto simp: step_red step.simps)"], ["proof (state)\nthis:\n  fetch B s'' (read r'') = (ac, 0)\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "then"], ["proof (chain)\npicking this:\n  fetch B s'' (read r'') = (ac, 0)", "have \"fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)\""], ["proof (prove)\nusing this:\n  fetch B s'' (read r'') = (ac, 0)\n\ngoal (1 subgoal):\n 1. fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)", "using assms b"], ["proof (prove)\nusing this:\n  fetch B s'' (read r'') = (ac, 0)\n  steps0 (Suc 0, l, r) B stp = (0, l', r')\n  tm_wf0 B\n  off = length A div 2\n  is_even (length A)\n  steps0 (1, l, r) B n = (s'', l'', r'') \\<and> 0 < s''\n\ngoal (1 subgoal):\n 1. fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)", "by(rule_tac tm_append_second_fetch0_eq, simp_all)"], ["proof (state)\nthis:\n  fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "then"], ["proof (chain)\npicking this:\n  fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)", "have e: \"steps (Suc 0 + off, l, r) (A @ shift B off, 0) (Suc n) = (0, l', r')\""], ["proof (prove)\nusing this:\n  fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0 + off, l, r) (A @ shift B off) (Suc n) = (0, l', r')", "using a b assms c d"], ["proof (prove)\nusing this:\n  fetch (A @ shift B off) (s'' + off) (read r'') = (ac, 0)\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n  steps0 (1, l, r) B n = (s'', l'', r'') \\<and> 0 < s''\n  steps0 (Suc 0, l, r) B stp = (0, l', r')\n  tm_wf0 B\n  off = length A div 2\n  is_even (length A)\n  steps0 (Suc 0 + off, l, r) (A @ shift B off) n = (s'' + off, l'', r'')\n  fetch B s'' (read r'') = (ac, 0)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0 + off, l, r) (A @ shift B off) (Suc n) = (0, l', r')", "by(simp add: step_red step.simps)"], ["proof (state)\nthis:\n  steps0 (Suc 0 + off, l, r) (A @ shift B off) (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "from a"], ["proof (chain)\npicking this:\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')", "have \"n < stp\""], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. n < stp", "using exec"], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n  steps0 (Suc 0, l, r) B stp = (0, l', r')\n\ngoal (1 subgoal):\n 1. n < stp", "proof(cases \"n < stp\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp\n 2. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "case  True"], ["proof (state)\nthis:\n  n < stp\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp\n 2. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  n < stp\n\ngoal (1 subgoal):\n 1. n < stp", "by simp"], ["proof (state)\nthis:\n  n < stp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "case False"], ["proof (state)\nthis:\n  \\<not> n < stp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "have \"\\<not> n < stp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < stp", "by fact"], ["proof (state)\nthis:\n  \\<not> n < stp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "then"], ["proof (chain)\npicking this:\n  \\<not> n < stp", "obtain d where  \"n = stp + d\""], ["proof (prove)\nusing this:\n  \\<not> n < stp\n\ngoal (1 subgoal):\n 1. (\\<And>d. n = stp + d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis add.comm_neutral less_imp_add_positive nat_neq_iff)"], ["proof (state)\nthis:\n  n = stp + d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) B n) \\<and>\n             steps0 (1, l, r) B (Suc n) = (0, l', r');\n     steps0 (Suc 0, l, r) B stp = (0, l', r'); \\<not> n < stp\\<rbrakk>\n    \\<Longrightarrow> n < stp", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  n = stp + d\n\ngoal (1 subgoal):\n 1. n < stp", "using a e exec"], ["proof (prove)\nusing this:\n  n = stp + d\n  \\<not> is_final (steps0 (1, l, r) B n) \\<and>\n  steps0 (1, l, r) B (Suc n) = (0, l', r')\n  steps0 (Suc 0 + off, l, r) (A @ shift B off) (Suc n) = (0, l', r')\n  steps0 (Suc 0, l, r) B stp = (0, l', r')\n\ngoal (1 subgoal):\n 1. n < stp", "by(simp)"], ["proof (state)\nthis:\n  n < stp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < stp\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "then"], ["proof (chain)\npicking this:\n  n < stp", "obtain d where \"stp = Suc n + d\""], ["proof (prove)\nusing this:\n  n < stp\n\ngoal (1 subgoal):\n 1. (\\<And>d. stp = Suc n + d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(metis add_Suc less_iff_Suc_add)"], ["proof (state)\nthis:\n  stp = Suc n + d\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  stp = Suc n + d\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "using e"], ["proof (prove)\nusing this:\n  stp = Suc n + d\n  steps0 (Suc 0 + off, l, r) (A @ shift B off) (Suc n) = (0, l', r')\n\ngoal (1 subgoal):\n 1. steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')", "by(simp only: steps_add, simp)"], ["proof (state)\nthis:\n  steps0 (Suc off, l, r) (A @ shift B off) stp = (0, l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tm_append_steps: \n  assumes \n    aexec: \"steps (s, l, r) (A, 0) stpa = (Suc (length A div 2), la, ra)\"\n    and bexec: \"steps (Suc 0, la, ra) (B, 0) stpb =  (sb, lb, rb)\"\n    and notfinal: \"sb \\<noteq> 0\"\n    and off: \"off = length A div 2\"\n    and even: \"length A mod 2 = 0\"\n  shows \"steps (s, l, r) (A @ shift B off, 0) (stpa + stpb) = (sb + off, lb, rb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)", "have \"steps (s, l, r) (A@shift B off, 0) stpa = (Suc (length A div 2), la, ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) stpa = (Suc (length A div 2), la, ra)", "apply(intro tm_append_first_steps_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. steps0 (s, l, r) A stpa = (Suc (length A div 2), la, ra)\n 2. Suc (length A div 2) \\<noteq> 0", "apply(auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (s, l, r) (A @ shift B off) stpa = (Suc (length A div 2), la, ra)\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)", "moreover"], ["proof (state)\nthis:\n  steps0 (s, l, r) (A @ shift B off) stpa = (Suc (length A div 2), la, ra)\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)", "have \"steps (1 + off, la, ra) (A @ shift B off, 0) stpb = (sb + off, lb, rb)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (1 + off, la, ra) (A @ shift B off) stpb = (sb + off, lb, rb)", "apply(intro tm_append_second_steps_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. steps0 (1, la, ra) B stpb = (sb, lb, rb)\n 2. sb \\<noteq> 0\n 3. off = length A div 2\n 4. is_even (length A)", "apply(auto simp: assms bexec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (1 + off, la, ra) (A @ shift B off) stpb = (sb + off, lb, rb)\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)", "ultimately"], ["proof (chain)\npicking this:\n  steps0 (s, l, r) (A @ shift B off) stpa = (Suc (length A div 2), la, ra)\n  steps0 (1 + off, la, ra) (A @ shift B off) stpb = (sb + off, lb, rb)", "show \"steps (s, l, r) (A @ shift B off, 0) (stpa + stpb) = (sb + off, lb, rb)\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) (A @ shift B off) stpa = (Suc (length A div 2), la, ra)\n  steps0 (1 + off, la, ra) (A @ shift B off) stpb = (sb + off, lb, rb)\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)", "apply(simp add: steps_add off)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (s, l, r) (A @ shift B off) (stpa + stpb) = (sb + off, lb, rb)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Crsp of Inc\\<close>"], ["", "fun at_begin_fst_bwtn :: \"inc_inv_t\"\n  where\n    \"at_begin_fst_bwtn (as, lm) (s, l, r) ires = \n      (\\<exists> lm1 tn rn. lm1 = (lm @ 0\\<up>tn) \\<and> length lm1 = s \\<and> \n          (if lm1 = [] then l = Bk # Bk # ires\n           else l = [Bk]@<rev lm1>@Bk#Bk#ires) \\<and> r = Bk\\<up>rn)\""], ["", "fun at_begin_fst_awtn :: \"inc_inv_t\"\n  where\n    \"at_begin_fst_awtn (as, lm) (s, l, r) ires = \n      (\\<exists> lm1 tn rn. lm1 = (lm @ 0\\<up>tn) \\<and> length lm1 = s \\<and>\n         (if lm1 = []  then l = Bk # Bk # ires\n          else l = [Bk]@<rev lm1>@Bk#Bk#ires) \\<and> r = [Oc]@Bk\\<up>rn)\""], ["", "fun at_begin_norm :: \"inc_inv_t\"\n  where\n    \"at_begin_norm (as, lm) (s, l, r) ires= \n      (\\<exists> lm1 lm2 rn. lm = lm1 @ lm2 \\<and> length lm1 = s \\<and> \n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = Bk # <rev lm1> @ Bk # Bk # ires ) \\<and> r = <lm2>@Bk\\<up>rn)\""], ["", "fun in_middle :: \"inc_inv_t\"\n  where\n    \"in_middle (as, lm) (s, l, r) ires = \n      (\\<exists> lm1 lm2 tn m ml mr rn. lm @ 0\\<up>tn = lm1 @ [m] @ lm2\n       \\<and> length lm1 = s \\<and> m + 1 = ml + mr \\<and>  \n         ml \\<noteq> 0 \\<and> tn = s + 1 - length lm \\<and> \n       (if lm1 = [] then l = Oc\\<up>ml @ Bk # Bk # ires \n        else l = Oc\\<up>ml@[Bk]@<rev lm1>@\n                 Bk # Bk # ires) \\<and> (r = Oc\\<up>mr @ [Bk] @ <lm2>@ Bk\\<up>rn \\<or> \n      (lm2 = [] \\<and> r = Oc\\<up>mr))\n      )\""], ["", "fun inv_locate_a :: \"inc_inv_t\"\n  where \"inv_locate_a (as, lm) (s, l, r) ires = \n     (at_begin_norm (as, lm) (s, l, r) ires \\<or>\n      at_begin_fst_bwtn (as, lm) (s, l, r) ires \\<or>\n      at_begin_fst_awtn (as, lm) (s, l, r) ires\n      )\""], ["", "fun inv_locate_b :: \"inc_inv_t\"\n  where \"inv_locate_b (as, lm) (s, l, r) ires = \n        (in_middle (as, lm) (s, l, r)) ires \""], ["", "fun inv_after_write :: \"inc_inv_t\"\n  where \"inv_after_write (as, lm) (s, l, r) ires = \n           (\\<exists> rn m lm1 lm2. lm = lm1 @ m # lm2 \\<and>\n             (if lm1 = [] then l = Oc\\<up>m @ Bk # Bk # ires\n              else Oc # l = Oc\\<up>Suc m@ Bk # <rev lm1> @ \n                      Bk # Bk # ires) \\<and> r = [Oc] @ <lm2> @ Bk\\<up>rn)\""], ["", "fun inv_after_move :: \"inc_inv_t\"\n  where \"inv_after_move (as, lm) (s, l, r) ires = \n      (\\<exists> rn m lm1 lm2. lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then l = Oc\\<up>Suc m @ Bk # Bk # ires\n         else l = Oc\\<up>Suc m@ Bk # <rev lm1> @ Bk # Bk # ires) \\<and> \n        r = <lm2> @ Bk\\<up>rn)\""], ["", "fun inv_after_clear :: \"inc_inv_t\"\n  where \"inv_after_clear (as, lm) (s, l, r) ires =\n       (\\<exists> rn m lm1 lm2 r'. lm = lm1 @ m # lm2 \\<and> \n        (if lm1 = [] then l = Oc\\<up>Suc m @ Bk # Bk # ires\n         else l = Oc\\<up>Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and> \n          r = Bk # r' \\<and> Oc # r' = <lm2> @ Bk\\<up>rn)\""], ["", "fun inv_on_right_moving :: \"inc_inv_t\"\n  where \"inv_on_right_moving (as, lm) (s, l, r) ires = \n       (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and> \n            ml + mr = m \\<and> \n          (if lm1 = [] then l = Oc\\<up>ml @ Bk # Bk # ires\n          else l = Oc\\<up>ml  @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> \n         ((r = Oc\\<up>mr @ [Bk] @ <lm2> @ Bk\\<up>rn) \\<or> \n          (r = Oc\\<up>mr \\<and> lm2 = [])))\""], ["", "fun inv_on_left_moving_norm :: \"inc_inv_t\"\n  where \"inv_on_left_moving_norm (as, lm) (s, l, r) ires =\n      (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and>  \n             ml + mr = Suc m \\<and> mr > 0 \\<and> (if lm1 = [] then l = Oc\\<up>ml @ Bk # Bk # ires\n                                         else l =  Oc\\<up>ml @ Bk # <rev lm1> @ Bk # Bk # ires)\n        \\<and> (r = Oc\\<up>mr @ Bk # <lm2> @ Bk\\<up>rn \\<or> \n           (lm2 = [] \\<and> r = Oc\\<up>mr)))\""], ["", "fun inv_on_left_moving_in_middle_B:: \"inc_inv_t\"\n  where \"inv_on_left_moving_in_middle_B (as, lm) (s, l, r) ires =\n                (\\<exists> lm1 lm2 rn. lm = lm1 @ lm2 \\<and>  \n                     (if lm1 = [] then l = Bk # ires\n                      else l = <rev lm1> @ Bk # Bk # ires) \\<and> \n                      r = Bk # <lm2> @ Bk\\<up>rn)\""], ["", "fun inv_on_left_moving :: \"inc_inv_t\"\n  where \"inv_on_left_moving (as, lm) (s, l, r) ires = \n       (inv_on_left_moving_norm  (as, lm) (s, l, r) ires \\<or>\n        inv_on_left_moving_in_middle_B (as, lm) (s, l, r) ires)\""], ["", "fun inv_check_left_moving_on_leftmost :: \"inc_inv_t\"\n  where \"inv_check_left_moving_on_leftmost (as, lm) (s, l, r) ires = \n                (\\<exists> rn. l = ires \\<and> r = [Bk, Bk] @ <lm> @  Bk\\<up>rn)\""], ["", "fun inv_check_left_moving_in_middle :: \"inc_inv_t\"\n  where \"inv_check_left_moving_in_middle (as, lm) (s, l, r) ires = \n              (\\<exists> lm1 lm2 r' rn. lm = lm1 @ lm2 \\<and>\n                 (Oc # l = <rev lm1> @ Bk # Bk # ires) \\<and> r = Oc # Bk # r' \\<and> \n                           r' = <lm2> @  Bk\\<up>rn)\""], ["", "fun inv_check_left_moving :: \"inc_inv_t\"\n  where \"inv_check_left_moving (as, lm) (s, l, r) ires = \n             (inv_check_left_moving_on_leftmost (as, lm) (s, l, r) ires \\<or>\n             inv_check_left_moving_in_middle (as, lm) (s, l, r) ires)\""], ["", "fun inv_after_left_moving :: \"inc_inv_t\"\n  where \"inv_after_left_moving (as, lm) (s, l, r) ires= \n              (\\<exists> rn. l = Bk # ires \\<and> r = Bk # <lm> @  Bk\\<up>rn)\""], ["", "fun inv_stop :: \"inc_inv_t\"\n  where \"inv_stop (as, lm) (s, l, r) ires= \n              (\\<exists> rn. l = Bk # Bk # ires \\<and> r = <lm> @  Bk\\<up>rn)\""], ["", "lemma halt_lemma2': \n  \"\\<lbrakk>wf LE;  \\<forall> n. ((\\<not> P (f n) \\<and> Q (f n)) \\<longrightarrow> \n    (Q (f (Suc n)) \\<and> (f (Suc n), (f n)) \\<in> LE)); Q (f 0)\\<rbrakk> \n      \\<Longrightarrow> \\<exists> n. P (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf LE;\n     \\<forall>n.\n        \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. P (f n)", "apply(intro exCI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf LE;\n     \\<forall>n.\n        Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>n. \\<not> P (f n)\\<rbrakk>\n    \\<Longrightarrow> False", "apply(subgoal_tac \"\\<forall> n. Q (f n)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf LE;\n     \\<forall>n.\n        Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>n. \\<not> P (f n); \\<forall>n. Q (f n)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>wf LE;\n     \\<forall>n.\n        Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>n. \\<not> P (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. Q (f n)", "apply(drule_tac f = f in wf_inv_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>n.\n                Q (f n) \\<longrightarrow>\n                Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>n. \\<not> P (f n); \\<forall>n. Q (f n);\n     wf (inv_image LE f)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>wf LE;\n     \\<forall>n.\n        Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>n. \\<not> P (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. Q (f n)", "apply(erule wf_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>n.\n                   Q (f n) \\<longrightarrow>\n                   Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        Q (f 0); \\<forall>n. \\<not> P (f n); \\<forall>n. Q (f n);\n        \\<forall>y.\n           (y, x) \\<in> inv_image LE f \\<longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>wf LE;\n     \\<forall>n.\n        Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>n. \\<not> P (f n)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n. Q (f n)", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>wf LE;\n        \\<forall>n.\n           Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        Q (f 0); \\<forall>n. \\<not> P (f n)\\<rbrakk>\n       \\<Longrightarrow> Q (f n)", "apply(rename_tac n,induct_tac n; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma halt_lemma2'': \n  \"\\<lbrakk>P (f n); \\<not> P (f (0::nat))\\<rbrakk> \\<Longrightarrow> \n         \\<exists> n. (P (f n) \\<and> (\\<forall> i < n. \\<not> P (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P (f n); \\<not> P (f 0)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n.\n                         P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))", "apply(induct n rule: nat_less_induct, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma halt_lemma2''':\n  \"\\<lbrakk>\\<forall>n. \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow> Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n                 Q (f 0);  \\<forall>i<na. \\<not> P (f i)\\<rbrakk> \\<Longrightarrow> Q (f na)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n.\n                \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n                Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n     Q (f 0); \\<forall>i<na. \\<not> P (f i)\\<rbrakk>\n    \\<Longrightarrow> Q (f na)", "apply(induct na, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma halt_lemma2: \n  \"\\<lbrakk>wf LE;  \n    Q (f 0); \\<not> P (f 0);\n    \\<forall> n. ((\\<not> P (f n) \\<and> Q (f n)) \\<longrightarrow> (Q (f (Suc n)) \\<and> (f (Suc n), (f n)) \\<in> LE))\\<rbrakk> \n  \\<Longrightarrow> \\<exists> n. P (f n) \\<and> Q (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n     \\<forall>n.\n        \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. P (f n) \\<and> Q (f n)", "apply(insert halt_lemma2' [of LE P f Q], simp, erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. P (f n) \\<and> Q (f n)", "apply(subgoal_tac \"\\<exists> n. (P (f n) \\<and> (\\<forall> i < n. \\<not> P (f i)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n);\n        \\<exists>n. P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. P (f n) \\<and> Q (f n)\n 2. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n); P (f na) \\<and> (\\<forall>i<na. \\<not> P (f i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. P (f n) \\<and> Q (f n)\n 2. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))", "apply(rename_tac n na)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n); P (f na) \\<and> (\\<forall>i<na. \\<not> P (f i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. P (f n) \\<and> Q (f n)\n 2. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))", "apply(rule_tac x = na in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n na.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n); P (f na); \\<forall>i<na. \\<not> P (f i)\\<rbrakk>\n       \\<Longrightarrow> Q (f na)\n 2. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))", "apply(rule halt_lemma2''', simp, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>wf LE; Q (f 0); \\<not> P (f 0);\n        \\<forall>n.\n           \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n           Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> LE;\n        P (f n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            P (f n) \\<and> (\\<forall>i<n. \\<not> P (f i))", "apply(erule_tac halt_lemma2'', simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun findnth_inv :: \"layout \\<Rightarrow> nat \\<Rightarrow> inc_inv_t\"\n  where\n    \"findnth_inv ly n (as, lm) (s, l, r) ires =\n              (if s = 0 then False\n               else if s \\<le> Suc (2*n) then \n                  if s mod 2 = 1 then inv_locate_a (as, lm) ((s - 1) div 2, l, r) ires\n                  else inv_locate_b (as, lm) ((s - 1) div 2, l, r) ires\n               else False)\""], ["", "fun findnth_state :: \"config \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"findnth_state (s, l, r) n = (Suc (2*n) - s)\""], ["", "fun findnth_step :: \"config \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"findnth_step (s, l, r) n = \n           (if s mod 2 = 1 then\n                   (if (r \\<noteq> [] \\<and> hd r = Oc) then 0\n                    else 1)\n            else length r)\""], ["", "fun findnth_measure :: \"config \\<times> nat \\<Rightarrow> nat \\<times> nat\"\n  where\n    \"findnth_measure (c, n) = \n     (findnth_state c n, findnth_step c n)\""], ["", "definition lex_pair :: \"((nat \\<times> nat) \\<times> nat \\<times> nat) set\"\n  where\n    \"lex_pair \\<equiv> less_than <*lex*> less_than\""], ["", "definition findnth_LE :: \"((config \\<times> nat) \\<times> (config \\<times> nat)) set\"\n  where\n    \"findnth_LE \\<equiv> (inv_image lex_pair findnth_measure)\""], ["", "lemma wf_findnth_LE: \"wf findnth_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf findnth_LE", "by(auto simp: findnth_LE_def lex_pair_def)"], ["", "declare findnth_inv.simps[simp del]"], ["", "lemma x_is_2n_arith[simp]: \n  \"\\<lbrakk>x < Suc (Suc (2 * n)); Suc x mod 2 = Suc 0; \\<not> x < 2 * n\\<rbrakk>\n \\<Longrightarrow> x = 2*n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < Suc (Suc (2 * n)); Suc x mod 2 = Suc 0;\n     \\<not> x < 2 * n\\<rbrakk>\n    \\<Longrightarrow> x = 2 * n", "by arith"], ["", "lemma between_sucs:\"x < Suc n \\<Longrightarrow> \\<not> x < n \\<Longrightarrow> x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < Suc n; \\<not> x < n\\<rbrakk> \\<Longrightarrow> x = n", "by auto"], ["", "lemma fetch_findnth[simp]: \n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Oc = (R, Suc a)\"\n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Oc = (R, a)\"\n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 \\<noteq> Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Bk = (R, Suc a)\"\n  \"\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 = Suc 0\\<rbrakk> \\<Longrightarrow> fetch (findnth n) a Bk = (W1, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 = Suc 0\\<rbrakk>\n      \\<Longrightarrow> fetch (findnth n) a Oc = (R, Suc a)) &&&\n     (\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 \\<noteq> Suc 0\\<rbrakk>\n      \\<Longrightarrow> fetch (findnth n) a Oc = (R, a))) &&&\n    (\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 \\<noteq> Suc 0\\<rbrakk>\n     \\<Longrightarrow> fetch (findnth n) a Bk = (R, Suc a)) &&&\n    (\\<lbrakk>0 < a; a < Suc (2 * n); a mod 2 = Suc 0\\<rbrakk>\n     \\<Longrightarrow> fetch (findnth n) a Bk = (W1, a))", "by(cases a;induct n;force simp: length_findnth nth_append dest!:between_sucs)+"], ["", "declare at_begin_norm.simps[simp del] at_begin_fst_bwtn.simps[simp del] \n  at_begin_fst_awtn.simps[simp del] in_middle.simps[simp del] \n  abc_lm_s.simps[simp del] abc_lm_v.simps[simp del]  \n  ci.simps[simp del] inv_after_move.simps[simp del] \n  inv_on_left_moving_norm.simps[simp del] \n  inv_on_left_moving_in_middle_B.simps[simp del]\n  inv_after_clear.simps[simp del] \n  inv_after_write.simps[simp del] inv_on_left_moving.simps[simp del]\n  inv_on_right_moving.simps[simp del] \n  inv_check_left_moving.simps[simp del] \n  inv_check_left_moving_in_middle.simps[simp del]\n  inv_check_left_moving_on_leftmost.simps[simp del] \n  inv_after_left_moving.simps[simp del]\n  inv_stop.simps[simp del] inv_locate_a.simps[simp del] \n  inv_locate_b.simps[simp del]"], ["", "lemma replicate_once[intro]: \"\\<exists>rn. [Bk] = Bk \\<up> rn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn. [Bk] = Bk \\<up> rn", "by (metis replicate.simps)"], ["", "lemma at_begin_norm_Bk[intro]:  \"at_begin_norm (as, am) (q, aaa, []) ires\n             \\<Longrightarrow> at_begin_norm (as, am) (q, aaa, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_begin_norm (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_norm (as, am) (q, aaa, [Bk]) ires", "apply(simp add: at_begin_norm.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       <lm2> = [] \\<Longrightarrow>\n    \\<exists>lm1.\n       (lm1 = [] \\<longrightarrow>\n        q = 0 \\<and>\n        aaa = Bk # Bk # ires \\<and>\n        (\\<exists>rn. [Bk] = <am> @ Bk \\<up> rn)) \\<and>\n       (lm1 \\<noteq> [] \\<longrightarrow>\n        (\\<exists>lm2.\n            am = lm1 @ lm2 \\<and>\n            length lm1 = q \\<and>\n            aaa = Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n            (\\<exists>rn. [Bk] = <lm2> @ Bk \\<up> rn)))", "by fastforce"], ["", "lemma at_begin_fst_bwtn_Bk[intro]: \"at_begin_fst_bwtn (as, am) (q, aaa, []) ires \n            \\<Longrightarrow> at_begin_fst_bwtn (as, am) (q, aaa, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_begin_fst_bwtn (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_fst_bwtn (as, am) (q, aaa, [Bk]) ires", "apply(simp only: at_begin_fst_bwtn.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       [Bk] = Bk \\<up> rn", "using replicate_once"], ["proof (prove)\nusing this:\n  \\<exists>rn. [Bk] = Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       [Bk] = Bk \\<up> rn", "by blast"], ["", "lemma at_begin_fst_awtn_Bk[intro]: \"at_begin_fst_awtn (as, am) (q, aaa, []) ires\n           \\<Longrightarrow> at_begin_fst_awtn (as, am) (q, aaa, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at_begin_fst_awtn (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_fst_awtn (as, am) (q, aaa, [Bk]) ires", "apply(auto simp: at_begin_fst_awtn.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_a_Bk[intro]: \"inv_locate_a (as, am) (q, aaa, []) ires\n            \\<Longrightarrow> inv_locate_a (as, am) (q, aaa, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_a (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    inv_locate_a (as, am) (q, aaa, [Bk]) ires", "apply(simp only: inv_locate_a.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. at_begin_norm (as, am) (q, aaa, []) ires \\<or>\n    at_begin_fst_bwtn (as, am) (q, aaa, []) ires \\<or>\n    at_begin_fst_awtn (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_norm (as, am) (q, aaa, [Bk]) ires \\<or>\n    at_begin_fst_bwtn (as, am) (q, aaa, [Bk]) ires \\<or>\n    at_begin_fst_awtn (as, am) (q, aaa, [Bk]) ires", "apply(erule disj_forward)"], ["proof (prove)\ngoal (2 subgoals):\n 1. at_begin_norm (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_norm (as, am) (q, aaa, [Bk]) ires\n 2. at_begin_fst_bwtn (as, am) (q, aaa, []) ires \\<or>\n    at_begin_fst_awtn (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_fst_bwtn (as, am) (q, aaa, [Bk]) ires \\<or>\n    at_begin_fst_awtn (as, am) (q, aaa, [Bk]) ires", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. at_begin_fst_bwtn (as, am) (q, aaa, []) ires \\<or>\n    at_begin_fst_awtn (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_fst_bwtn (as, am) (q, aaa, [Bk]) ires \\<or>\n    at_begin_fst_awtn (as, am) (q, aaa, [Bk]) ires\n 2. at_begin_norm (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    at_begin_norm (as, am) (q, aaa, [Bk]) ires", "apply(erule disj_forward, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma locate_a_2_locate_a[simp]: \"inv_locate_a (as, am) (q, aaa, Bk # xs) ires\n       \\<Longrightarrow> inv_locate_a (as, am) (q, aaa, Oc # xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_a (as, am) (q, aaa, Bk # xs) ires \\<Longrightarrow>\n    inv_locate_a (as, am) (q, aaa, Oc # xs) ires", "apply(simp only: inv_locate_a.simps at_begin_norm.simps \n      at_begin_fst_bwtn.simps at_begin_fst_awtn.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    (\\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn)", "apply(erule_tac disjE, erule exE, erule exE, erule exE, \n      rule disjI2, rule disjI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 2. (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    (\\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # xs = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    (\\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn)\n 2. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "apply(erule_tac disjE, erule exE, erule exE, \n      erule exE, rule disjI2, rule disjI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 2. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = [Oc] @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn)\n 3. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = [Oc] @ Bk \\<up> rn \\<Longrightarrow>\n    (\\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn)\n 2. \\<And>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 3. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 2. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 2. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "fix lm1 tn rn"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 2. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "assume k: \"lm1 = am @ 0\\<up>tn \\<and> length lm1 = q \\<and> (if lm1 = [] then aaa = Bk # Bk # \n    ires else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> Bk # xs = Bk\\<up>rn\""], ["proof (state)\nthis:\n  lm1 = am @ 0 \\<up> tn \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = Bk \\<up> rn\n\ngoal (2 subgoals):\n 1. \\<And>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn\n 2. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "thus \"\\<exists>lm1 tn rn. lm1 = am @ 0 \\<up> tn \\<and> length lm1 = q \\<and> \n    (if lm1 = [] then aaa = Bk # Bk # ires else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> Oc # xs = [Oc] @ Bk \\<up> rn\"\n    (is \"\\<exists>lm1 tn rn. ?P lm1 tn rn\")"], ["proof (prove)\nusing this:\n  lm1 = am @ 0 \\<up> tn \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # xs = [Oc] @ Bk \\<up> rn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lm1 = am @ 0 \\<up> tn \\<and>\n    length lm1 = q \\<and>\n    (if lm1 = [] then aaa = Bk # Bk # ires\n     else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n    Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # xs = [Oc] @ Bk \\<up> rn", "from k"], ["proof (chain)\npicking this:\n  lm1 = am @ 0 \\<up> tn \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = Bk \\<up> rn", "have \"?P lm1 tn (rn - 1)\""], ["proof (prove)\nusing this:\n  lm1 = am @ 0 \\<up> tn \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. lm1 = am @ 0 \\<up> tn \\<and>\n    length lm1 = q \\<and>\n    (if lm1 = [] then aaa = Bk # Bk # ires\n     else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n    Oc # xs = [Oc] @ Bk \\<up> (rn - 1)", "by (auto simp: Cons_replicate_eq)"], ["proof (state)\nthis:\n  lm1 = am @ 0 \\<up> tn \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Oc # xs = [Oc] @ Bk \\<up> (rn - 1)\n\ngoal (1 subgoal):\n 1. lm1 = am @ 0 \\<up> tn \\<and>\n    length lm1 = q \\<and>\n    (if lm1 = [] then aaa = Bk # Bk # ires\n     else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n    Bk # xs = Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # xs = [Oc] @ Bk \\<up> rn", "thus ?thesis"], ["proof (prove)\nusing this:\n  lm1 = am @ 0 \\<up> tn \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Oc # xs = [Oc] @ Bk \\<up> (rn - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # xs = [Oc] @ Bk \\<up> rn", "by blast"], ["proof (state)\nthis:\n  \\<exists>lm1 tn rn.\n     lm1 = am @ 0 \\<up> tn \\<and>\n     length lm1 = q \\<and>\n     (if lm1 = [] then aaa = Bk # Bk # ires\n      else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n     Oc # xs = [Oc] @ Bk \\<up> rn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>lm1 tn rn.\n     lm1 = am @ 0 \\<up> tn \\<and>\n     length lm1 = q \\<and>\n     (if lm1 = [] then aaa = Bk # Bk # ires\n      else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n     Oc # xs = [Oc] @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "fix lm1 lm2 rn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "assume h1: \"am = lm1 @ lm2 \\<and> length lm1 = q \\<and> (if lm1 = [] \n    then aaa = Bk # Bk # ires else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n    Bk # xs = <lm2> @ Bk\\<up>rn\""], ["proof (state)\nthis:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "from h1"], ["proof (chain)\npicking this:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn", "have h2: \"lm2 = []\""], ["proof (prove)\nusing this:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. lm2 = []", "apply(auto split: if_splits;cases lm2;simp add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lm2 = []\n\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       am = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # xs = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 tn rn.\n          lm1 = am @ 0 \\<up> tn \\<and>\n          length lm1 = q \\<and>\n          (if lm1 = [] then aaa = Bk # Bk # ires\n           else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          Oc # xs = [Oc] @ Bk \\<up> rn", "from h1 and h2"], ["proof (chain)\npicking this:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn\n  lm2 = []", "show \"\\<exists>lm1 tn rn. lm1 = am @ 0\\<up>tn \\<and> length lm1 = q \\<and> \n    (if lm1 = [] then aaa = Bk # Bk # ires else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n    Oc # xs = [Oc] @ Bk\\<up>rn\" \n    (is \"\\<exists>lm1 tn rn. ?P lm1 tn rn\")"], ["proof (prove)\nusing this:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn\n  lm2 = []\n\ngoal (1 subgoal):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # xs = [Oc] @ Bk \\<up> rn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>am = lm1 @ lm2 \\<and>\n             length lm1 = q \\<and>\n             (if lm1 = [] then aaa = Bk # Bk # ires\n              else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n             Bk # xs = <lm2> @ Bk \\<up> rn;\n     lm2 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 tn rn.\n                         lm1 = am @ 0 \\<up> tn \\<and>\n                         length lm1 = q \\<and>\n                         (if lm1 = [] then aaa = Bk # Bk # ires\n                          else aaa =\n                               [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                         Oc # xs = [Oc] @ Bk \\<up> rn", "from h1 and h2"], ["proof (chain)\npicking this:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn\n  lm2 = []", "have \"?P lm1 0 (rn - 1)\""], ["proof (prove)\nusing this:\n  am = lm1 @ lm2 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n  Bk # xs = <lm2> @ Bk \\<up> rn\n  lm2 = []\n\ngoal (1 subgoal):\n 1. lm1 = am @ 0 \\<up> 0 \\<and>\n    length lm1 = q \\<and>\n    (if lm1 = [] then aaa = Bk # Bk # ires\n     else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n    Oc # xs = [Oc] @ Bk \\<up> (rn - 1)", "apply(auto simp:tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lm2 = []; am = lm1; q = length lm1;\n     if lm1 = [] then aaa = Bk # Bk # ires\n     else aaa = Bk # <rev lm1> @ Bk # Bk # ires;\n     Bk # xs = Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> xs = Bk \\<up> (rn - Suc 0)", "by(cases rn, simp, simp)"], ["proof (state)\nthis:\n  lm1 = am @ 0 \\<up> 0 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Oc # xs = [Oc] @ Bk \\<up> (rn - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>am = lm1 @ lm2 \\<and>\n             length lm1 = q \\<and>\n             (if lm1 = [] then aaa = Bk # Bk # ires\n              else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n             Bk # xs = <lm2> @ Bk \\<up> rn;\n     lm2 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 tn rn.\n                         lm1 = am @ 0 \\<up> tn \\<and>\n                         length lm1 = q \\<and>\n                         (if lm1 = [] then aaa = Bk # Bk # ires\n                          else aaa =\n                               [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                         Oc # xs = [Oc] @ Bk \\<up> rn", "thus ?thesis"], ["proof (prove)\nusing this:\n  lm1 = am @ 0 \\<up> 0 \\<and>\n  length lm1 = q \\<and>\n  (if lm1 = [] then aaa = Bk # Bk # ires\n   else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n  Oc # xs = [Oc] @ Bk \\<up> (rn - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>lm1 tn rn.\n       lm1 = am @ 0 \\<up> tn \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # xs = [Oc] @ Bk \\<up> rn", "by blast"], ["proof (state)\nthis:\n  \\<exists>lm1 tn rn.\n     lm1 = am @ 0 \\<up> tn \\<and>\n     length lm1 = q \\<and>\n     (if lm1 = [] then aaa = Bk # Bk # ires\n      else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n     Oc # xs = [Oc] @ Bk \\<up> rn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>lm1 tn rn.\n     lm1 = am @ 0 \\<up> tn \\<and>\n     length lm1 = q \\<and>\n     (if lm1 = [] then aaa = Bk # Bk # ires\n      else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n     Oc # xs = [Oc] @ Bk \\<up> rn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_locate_a[simp]: \"inv_locate_a (as, am) (q, aaa, []) ires \\<Longrightarrow> \n               inv_locate_a (as, am) (q, aaa, [Oc]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_a (as, am) (q, aaa, []) ires \\<Longrightarrow>\n    inv_locate_a (as, am) (q, aaa, [Oc]) ires", "apply(insert locate_a_2_locate_a [of as am q aaa \"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_a (as, am) (q, aaa, []) ires;\n     \\<And>ires.\n        inv_locate_a (as, am) (q, aaa, [Bk]) ires \\<Longrightarrow>\n        inv_locate_a (as, am) (q, aaa, [Oc]) ires\\<rbrakk>\n    \\<Longrightarrow> inv_locate_a (as, am) (q, aaa, [Oc]) ires", "apply(subgoal_tac \"inv_locate_a (as, am) (q, aaa, [Bk]) ires\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*inv: from locate_b to locate_b*)"], ["", "lemma inv_locate_b[simp]: \"inv_locate_b (as, am) (q, aaa, Oc # xs) ires\n         \\<Longrightarrow> inv_locate_b (as, am) (q, Oc # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, am) (q, aaa, Oc # xs) ires \\<Longrightarrow>\n    inv_locate_b (as, am) (q, Oc # aaa, xs) ires", "apply(simp only: inv_locate_b.simps in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 tn m ml mr rn.\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> Oc # xs = Oc \\<up> mr) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # aaa =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> Oc # xs = Oc \\<up> mr) \\<Longrightarrow>\n       \\<exists>lm1 lm2 tn m ml mr rn.\n          am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n          length lm1 = q \\<and>\n          m + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          tn = q + 1 - length am \\<and>\n          (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # aaa =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rename_tac lm1 lm2 tn m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> Oc # xs = Oc \\<up> mr) \\<Longrightarrow>\n       \\<exists>lm1 lm2 tn m ml mr rn.\n          am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n          length lm1 = q \\<and>\n          m + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          tn = q + 1 - length am \\<and>\n          (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # aaa =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI, \n      rule_tac x = tn in exI, rule_tac x = m in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> Oc # xs = Oc \\<up> mr) \\<Longrightarrow>\n       \\<exists>ml mr rn.\n          am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n          length lm1 = q \\<and>\n          m + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          tn = q + 1 - length am \\<and>\n          (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # aaa =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rule_tac x = \"Suc ml\" in exI, rule_tac x = \"mr - 1\" in exI,\n      rule_tac x = rn in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> Oc # xs = Oc \\<up> mr) \\<Longrightarrow>\n       am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = Suc ml + (mr - 1) \\<and>\n       Suc ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length am \\<and>\n       (if lm1 = [] then Oc # aaa = Oc \\<up> Suc ml @ Bk # Bk # ires\n        else Oc # aaa =\n             Oc \\<up> Suc ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (xs = Oc \\<up> (mr - 1) @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> xs = Oc \\<up> (mr - 1))", "apply(case_tac mr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       \\<lbrakk>am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                length lm1 = q \\<and>\n                m + 1 = ml + mr \\<and>\n                ml \\<noteq> 0 \\<and>\n                tn = q + 1 - length am \\<and>\n                (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aaa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 lm2 = [] \\<and> Oc # xs = Oc \\<up> mr);\n        mr = 0\\<rbrakk>\n       \\<Longrightarrow> am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                         length lm1 = q \\<and>\n                         m + 1 = Suc ml + (mr - 1) \\<and>\n                         Suc ml \\<noteq> 0 \\<and>\n                         tn = q + 1 - length am \\<and>\n                         (if lm1 = []\n                          then Oc # aaa = Oc \\<up> Suc ml @ Bk # Bk # ires\n                          else Oc # aaa =\n                               Oc \\<up> Suc ml @\n                               [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (xs =\n                          Oc \\<up> (mr - 1) @\n                          [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and> xs = Oc \\<up> (mr - 1))\n 2. \\<And>lm1 lm2 tn m ml mr rn nat.\n       \\<lbrakk>am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                length lm1 = q \\<and>\n                m + 1 = ml + mr \\<and>\n                ml \\<noteq> 0 \\<and>\n                tn = q + 1 - length am \\<and>\n                (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aaa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 lm2 = [] \\<and> Oc # xs = Oc \\<up> mr);\n        mr = Suc nat\\<rbrakk>\n       \\<Longrightarrow> am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                         length lm1 = q \\<and>\n                         m + 1 = Suc ml + (mr - 1) \\<and>\n                         Suc ml \\<noteq> 0 \\<and>\n                         tn = q + 1 - length am \\<and>\n                         (if lm1 = []\n                          then Oc # aaa = Oc \\<up> Suc ml @ Bk # Bk # ires\n                          else Oc # aaa =\n                               Oc \\<up> Suc ml @\n                               [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (xs =\n                          Oc \\<up> (mr - 1) @\n                          [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and> xs = Oc \\<up> (mr - 1))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tape_nat[simp]:  \"<[x::nat]> = Oc\\<up>(Suc x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <[x]> = Oc \\<up> Suc x", "apply(simp add: tape_of_nat_def tape_of_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate[simp]: \"\\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires; \\<exists>n. xs = Bk\\<up>n\\<rbrakk>\n            \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires;\n     \\<exists>n. xs = Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires", "apply(simp add: inv_locate_b.simps inv_locate_a.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_middle (as, am) (q, aaa, Bk # xs) ires;\n     \\<exists>n. xs = Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> at_begin_norm (as, am) (Suc q, Bk # aaa, xs)\n                       ires \\<or>\n                      at_begin_fst_bwtn (as, am) (Suc q, Bk # aaa, xs)\n                       ires \\<or>\n                      at_begin_fst_awtn (as, am) (Suc q, Bk # aaa, xs) ires", "apply(rule_tac disjI2, rule_tac disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_middle (as, am) (q, aaa, Bk # xs) ires;\n     \\<exists>n. xs = Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> at_begin_fst_bwtn (as, am) (Suc q, Bk # aaa, xs) ires", "apply(simp only: in_middle.simps at_begin_fst_bwtn.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>lm1 lm2 tn m ml mr rn.\n                am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                length lm1 = q \\<and>\n                m + 1 = ml + mr \\<and>\n                ml \\<noteq> 0 \\<and>\n                tn = q + 1 - length am \\<and>\n                (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aaa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 lm2 = [] \\<and> Bk # xs = Oc \\<up> mr);\n     \\<exists>n. xs = Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 tn rn.\n                         lm1 = am @ 0 \\<up> tn \\<and>\n                         length lm1 = Suc q \\<and>\n                         (if lm1 = [] then Bk # aaa = Bk # Bk # ires\n                          else Bk # aaa =\n                               [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                         xs = Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 n lm2 tn m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n;\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = q \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = q + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # xs = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 tn rn.\n                            lm1 = am @ 0 \\<up> tn \\<and>\n                            length lm1 = Suc q \\<and>\n                            (if lm1 = [] then Bk # aaa = Bk # Bk # ires\n                             else Bk # aaa =\n                                  [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                            xs = Bk \\<up> rn", "apply(rename_tac lm1 n lm2 tn m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 n lm2 tn m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n;\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = q \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = q + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # xs = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 tn rn.\n                            lm1 = am @ 0 \\<up> tn \\<and>\n                            length lm1 = Suc q \\<and>\n                            (if lm1 = [] then Bk # aaa = Bk # Bk # ires\n                             else Bk # aaa =\n                                  [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                            xs = Bk \\<up> rn", "apply(rule_tac x = \"lm1 @ [m]\" in exI, rule_tac x = tn in exI, simp split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 = [];\n        am @ 0 \\<up> (Suc q - length am) = m # lm2 \\<and>\n        q = 0 \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and> mr = 0\n 2. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and>\n                         Oc \\<up> ml @ Bk # <rev lm1> = <m # rev lm1>", "apply(case_tac mr, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 n lm2 m mr rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; lm1 = [];\n        am @ 0 \\<up> (Suc q - length am) = m # lm2 \\<and>\n        q = 0 \\<and>\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires \\<and>\n        Bk \\<up> n = <lm2> @ Bk \\<up> rn;\n        mr = 0\\<rbrakk>\n       \\<Longrightarrow> [] = lm2\n 2. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and>\n                         Oc \\<up> ml @ Bk # <rev lm1> = <m # rev lm1>", "apply(cases \"length am\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 n lm2 m mr rn nat.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; lm1 = [];\n        am @ 0 \\<up> (q - nat) = m # lm2 \\<and>\n        q = 0 \\<and>\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires \\<and>\n        Bk \\<up> n = <lm2> @ Bk \\<up> rn;\n        mr = 0; length am = Suc nat\\<rbrakk>\n       \\<Longrightarrow> [] = lm2\n 2. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and>\n                         Oc \\<up> ml @ Bk # <rev lm1> = <m # rev lm1>", "apply(case_tac lm2, simp_all add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 n lm2 m mr rn nat a list.\n       \\<lbrakk>lm1 = []; mr = 0; Suc 0 = nat; lm2 = [a]; list = [];\n        am = [m, a]; q = 0; aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 n lm2 m mr rn nat a list.\n       \\<lbrakk>lm1 = []; mr = 0; Suc (length list) = nat; lm2 = a # list;\n        list \\<noteq> []; am = m # a # list; q = 0;\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and> mr = 0", "apply(cases am, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 n lm2 m mr rn nat a list aa.\n       \\<lbrakk>lm1 = []; mr = 0; Suc 0 = nat; lm2 = [a]; list = []; aa = m;\n        q = 0; aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk \\<up> rn; am = [m, a]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 n lm2 m mr rn nat a list.\n       \\<lbrakk>lm1 = []; mr = 0; Suc (length list) = nat; lm2 = a # list;\n        list \\<noteq> []; am = m # a # list; q = 0;\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and> mr = 0", "apply(case_tac n, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 n lm2 m mr rn nat a list.\n       \\<lbrakk>lm1 = []; mr = 0; Suc (length list) = nat; lm2 = a # list;\n        list \\<noteq> []; am = m # a # list; q = 0;\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and> mr = 0", "apply(case_tac n, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 n lm2 m ml mr rn.\n       \\<lbrakk>xs = Bk \\<up> n; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        (mr = 0 \\<and> Bk \\<up> n = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # Bk \\<up> n = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> [] = lm2 \\<and> mr = 0", "apply(case_tac mr, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 n lm2 m mr rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc q - length am) = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n        Bk \\<up> n = <lm2> @ Bk \\<up> rn;\n        mr = 0\\<rbrakk>\n       \\<Longrightarrow> [] = lm2", "apply(case_tac lm2, simp_all add: tape_of_nl_cons split: if_splits, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 n m rn a.\n       \\<lbrakk>lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m, a];\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk \\<up> rn; q = length lm1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 n m rn a list.\n       \\<lbrakk>lm1 \\<noteq> []; list \\<noteq> [];\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # a # list;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Bk \\<up> n = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        xs = Oc # Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn;\n        q = length lm1\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac [!] n, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma repeat_Bk_no_Oc[simp]: \"(Oc # r = Bk \\<up> rn) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Oc # r = Bk \\<up> rn) = False", "apply(cases rn, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma repeat_Bk[simp]: \"(\\<exists>rna. Bk \\<up> rn = Bk # Bk \\<up> rna) \\<or> rn = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>rna. Bk \\<up> rn = Bk # Bk \\<up> rna) \\<or> rn = 0", "apply(cases rn, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_b_Oc_via_a[simp]: \n  assumes \"inv_locate_a (as, lm) (q, l, Oc # r) ires\"\n  shows \"inv_locate_b (as, lm) (q, Oc # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, lm) (q, Oc # l, r) ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_locate_b (as, lm) (q, Oc # l, r) ires", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, lm) (q, Oc # l, r) ires", "using assms"], ["proof (prove)\nusing this:\n  inv_locate_a (as, lm) (q, l, Oc # r) ires\n\ngoal (1 subgoal):\n 1. inv_locate_b (as, lm) (q, Oc # l, r) ires", "unfolding inv_locate_a.simps inv_locate_b.simps\n      at_begin_norm.simps at_begin_fst_bwtn.simps at_begin_fst_awtn.simps"], ["proof (prove)\nusing this:\n  (\\<exists>lm1 lm2 rn.\n      lm = lm1 @ lm2 \\<and>\n      length lm1 = q \\<and>\n      (if lm1 = [] then l = Bk # Bk # ires\n       else l = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n      Oc # r = <lm2> @ Bk \\<up> rn) \\<or>\n  (\\<exists>lm1 tn rn.\n      lm1 = lm @ 0 \\<up> tn \\<and>\n      length lm1 = q \\<and>\n      (if lm1 = [] then l = Bk # Bk # ires\n       else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n      Oc # r = Bk \\<up> rn) \\<or>\n  (\\<exists>lm1 tn rn.\n      lm1 = lm @ 0 \\<up> tn \\<and>\n      length lm1 = q \\<and>\n      (if lm1 = [] then l = Bk # Bk # ires\n       else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n      Oc # r = [Oc] @ Bk \\<up> rn)\n\ngoal (1 subgoal):\n 1. in_middle (as, lm) (q, Oc # l, r) ires", "apply(simp only:in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>lm1 lm2 rn.\n        lm = lm1 @ lm2 \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = <lm2> @ Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(erule disjE, erule exE, erule exE, erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       lm = lm1 @ lm2 \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then l = Bk # Bk # ires\n        else l = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       Oc # r = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 lm2 tn m ml mr rn.\n          lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n          length lm1 = q \\<and>\n          m + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          tn = q + 1 - length lm \\<and>\n          (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           lm2 = [] \\<and> r = Oc \\<up> mr)\n 2. (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(rename_tac Lm1 Lm2 Rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 Rn.\n       lm = Lm1 @ Lm2 \\<and>\n       length Lm1 = q \\<and>\n       (if Lm1 = [] then l = Bk # Bk # ires\n        else l = Bk # <rev Lm1> @ Bk # Bk # ires) \\<and>\n       Oc # r = <Lm2> @ Bk \\<up> Rn \\<Longrightarrow>\n       \\<exists>lm1 lm2 tn m ml mr rn.\n          lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n          length lm1 = q \\<and>\n          m + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          tn = q + 1 - length lm \\<and>\n          (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           lm2 = [] \\<and> r = Oc \\<up> mr)\n 2. (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(rule_tac x = Lm1 in exI, rule_tac x = \"tl Lm2\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 Rn.\n       lm = Lm1 @ Lm2 \\<and>\n       length Lm1 = q \\<and>\n       (if Lm1 = [] then l = Bk # Bk # ires\n        else l = Bk # <rev Lm1> @ Bk # Bk # ires) \\<and>\n       Oc # r = <Lm2> @ Bk \\<up> Rn \\<Longrightarrow>\n       \\<exists>tn m ml mr rn.\n          lm @ 0 \\<up> tn = Lm1 @ [m] @ tl Lm2 \\<and>\n          length Lm1 = q \\<and>\n          m + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          tn = q + 1 - length lm \\<and>\n          (if Lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> mr @ [Bk] @ <tl Lm2> @ Bk \\<up> rn \\<or>\n           tl Lm2 = [] \\<and> r = Oc \\<up> mr)\n 2. (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(rule_tac x = 0 in exI, rule_tac x = \"hd Lm2\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 Rn.\n       lm = Lm1 @ Lm2 \\<and>\n       length Lm1 = q \\<and>\n       (if Lm1 = [] then l = Bk # Bk # ires\n        else l = Bk # <rev Lm1> @ Bk # Bk # ires) \\<and>\n       Oc # r = <Lm2> @ Bk \\<up> Rn \\<Longrightarrow>\n       \\<exists>ml mr rn.\n          lm @ 0 \\<up> 0 = Lm1 @ [hd Lm2] @ tl Lm2 \\<and>\n          length Lm1 = q \\<and>\n          hd Lm2 + 1 = ml + mr \\<and>\n          ml \\<noteq> 0 \\<and>\n          0 = q + 1 - length lm \\<and>\n          (if Lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> mr @ [Bk] @ <tl Lm2> @ Bk \\<up> rn \\<or>\n           tl Lm2 = [] \\<and> r = Oc \\<up> mr)\n 2. (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(rule_tac x = 1 in exI, rule_tac x = \"hd Lm2\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 Rn.\n       lm = Lm1 @ Lm2 \\<and>\n       length Lm1 = q \\<and>\n       (if Lm1 = [] then l = Bk # Bk # ires\n        else l = Bk # <rev Lm1> @ Bk # Bk # ires) \\<and>\n       Oc # r = <Lm2> @ Bk \\<up> Rn \\<Longrightarrow>\n       \\<exists>rn.\n          lm @ 0 \\<up> 0 = Lm1 @ [hd Lm2] @ tl Lm2 \\<and>\n          length Lm1 = q \\<and>\n          hd Lm2 + 1 = 1 + hd Lm2 \\<and>\n          1 \\<noteq> 0 \\<and>\n          0 = q + 1 - length lm \\<and>\n          (if Lm1 = [] then Oc # l = Oc \\<up> 1 @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> 1 @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> hd Lm2 @ [Bk] @ <tl Lm2> @ Bk \\<up> rn \\<or>\n           tl Lm2 = [] \\<and> r = Oc \\<up> hd Lm2)\n 2. (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(case_tac Lm2, force simp: tape_of_nl_cons )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 Rn a list.\n       \\<lbrakk>lm = Lm1 @ Lm2 \\<and>\n                length Lm1 = q \\<and>\n                (if Lm1 = [] then l = Bk # Bk # ires\n                 else l = Bk # <rev Lm1> @ Bk # Bk # ires) \\<and>\n                Oc # r = <Lm2> @ Bk \\<up> Rn;\n        Lm2 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn.\n                            lm @ 0 \\<up> 0 = Lm1 @ [hd Lm2] @ tl Lm2 \\<and>\n                            length Lm1 = q \\<and>\n                            hd Lm2 + 1 = 1 + hd Lm2 \\<and>\n                            1 \\<noteq> 0 \\<and>\n                            0 = q + 1 - length lm \\<and>\n                            (if Lm1 = []\n                             then Oc # l = Oc \\<up> 1 @ Bk # Bk # ires\n                             else Oc # l =\n                                  Oc \\<up> 1 @\n                                  [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n                            (r =\n                             Oc \\<up> hd Lm2 @\n                             [Bk] @ <tl Lm2> @ Bk \\<up> rn \\<or>\n                             tl Lm2 = [] \\<and> r = Oc \\<up> hd Lm2)\n 2. (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = Bk \\<up> rn) \\<or>\n    (\\<exists>lm1 tn rn.\n        lm1 = lm @ 0 \\<up> tn \\<and>\n        length lm1 = q \\<and>\n        (if lm1 = [] then l = Bk # Bk # ires\n         else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # r = [Oc] @ Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m ml mr rn.\n       lm @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n       length lm1 = q \\<and>\n       m + 1 = ml + mr \\<and>\n       ml \\<noteq> 0 \\<and>\n       tn = q + 1 - length lm \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        lm2 = [] \\<and> r = Oc \\<up> mr)", "apply(case_tac \"tl Lm2\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 Rn a list aa lista.\n       \\<lbrakk>lm = Lm1 @ a # aa # lista \\<and>\n                length Lm1 = q \\<and>\n                (if Lm1 = [] then l = Bk # Bk # ires\n                 else l = Bk # <rev Lm1> @ Bk # Bk # ires) \\<and>\n                Oc # r = <a # aa # lista> @ Bk \\<up> Rn;\n        Lm2 = a # aa # lista; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn.\n                            r = Oc \\<up> a @ Bk # <aa # lista> @ Bk \\<up> rn\n 2. \\<exists>lm1.\n       (\\<exists>tn. lm1 = lm @ 0 \\<up> tn) \\<and>\n       length lm1 = q \\<and>\n       (if lm1 = [] then l = Bk # Bk # ires\n        else l = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (\\<exists>rn. r = Bk \\<up> rn) \\<Longrightarrow>\n    \\<exists>lm1 lm2 tn m.\n       lm @ 0 \\<up> tn = lm1 @ m # lm2 \\<and>\n       length lm1 = q \\<and>\n       (\\<exists>ml.\n           (lm1 = [] \\<longrightarrow>\n            (\\<exists>mr.\n                Suc m = ml + mr \\<and>\n                0 < ml \\<and>\n                tn = Suc q - length lm \\<and>\n                Oc # l = Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                ((\\<exists>rn.\n                     r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\n                 lm2 = [] \\<and> r = Oc \\<up> mr))) \\<and>\n           (lm1 \\<noteq> [] \\<longrightarrow>\n            (\\<exists>mr.\n                Suc m = ml + mr \\<and>\n                0 < ml \\<and>\n                tn = Suc q - length lm \\<and>\n                Oc # l =\n                Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                ((\\<exists>rn.\n                     r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\n                 lm2 = [] \\<and> r = Oc \\<up> mr))))", "apply(case_tac Rn, auto simp: tape_of_nl_cons )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tn rn.\n       \\<lbrakk>q = length lm + tn;\n        if lm = [] \\<and> tn = 0 then l = Bk # Bk # ires\n        else l = [Bk] @ <rev (lm @ 0 \\<up> tn)> @ Bk # Bk # ires;\n        r = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tna m.\n                            lm @ 0 \\<up> tna = lm1 @ m # lm2 \\<and>\n                            length lm1 = length lm + tn \\<and>\n                            (\\<exists>ml.\n                                (lm1 = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     Suc m = ml + mr \\<and>\n                                     0 < ml \\<and>\n                                     tna = Suc tn \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\nlm2 = [] \\<and> rn = mr \\<and> rn = 0))) \\<and>\n                                (lm1 \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     Suc m = ml + mr \\<and>\n                                     0 < ml \\<and>\n                                     tna = Suc tn \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\nlm2 = [] \\<and> rn = mr \\<and> rn = 0))))", "apply(rename_tac tn rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tn rn.\n       \\<lbrakk>q = length lm + tn;\n        if lm = [] \\<and> tn = 0 then l = Bk # Bk # ires\n        else l = [Bk] @ <rev (lm @ 0 \\<up> tn)> @ Bk # Bk # ires;\n        r = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tna m.\n                            lm @ 0 \\<up> tna = lm1 @ m # lm2 \\<and>\n                            length lm1 = length lm + tn \\<and>\n                            (\\<exists>ml.\n                                (lm1 = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     Suc m = ml + mr \\<and>\n                                     0 < ml \\<and>\n                                     tna = Suc tn \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\nlm2 = [] \\<and> rn = mr \\<and> rn = 0))) \\<and>\n                                (lm1 \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     Suc m = ml + mr \\<and>\n                                     0 < ml \\<and>\n                                     tna = Suc tn \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\nlm2 = [] \\<and> rn = mr \\<and> rn = 0))))", "apply(rule_tac x = \"lm @ replicate tn 0\" in exI, \n        rule_tac x = \"[]\" in exI, \n        rule_tac x = \"Suc tn\" in exI, \n        rule_tac x = 0 in exI, auto simp add: replicate_append_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tn rn.\n       \\<lbrakk>q = length lm + tn;\n        if lm = [] \\<and> tn = 0 then l = Bk # Bk # ires\n        else l = [Bk] @ <rev (lm @ 0 \\<up> tn)> @ Bk # Bk # ires;\n        r = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            (lm = [] \\<and> tn = 0 \\<longrightarrow>\n                             (\\<exists>mr.\n                                 Suc 0 = ml + mr \\<and>\n                                 0 < ml \\<and>\n                                 [Oc] = Oc \\<up> ml \\<and>\n                                 ((\\<exists>rna.\nBk \\<up> rn = Oc \\<up> mr @ Bk # Bk \\<up> rna) \\<or>\n                                  rn = mr \\<and> rn = 0))) \\<and>\n                            ((lm = [] \\<longrightarrow>\n                              0 < tn) \\<longrightarrow>\n                             (\\<exists>mr.\n                                 Suc 0 = ml + mr \\<and>\n                                 0 < ml \\<and>\n                                 [Oc] = Oc \\<up> ml \\<and>\n                                 ((\\<exists>rna.\nBk \\<up> rn = Oc \\<up> mr @ Bk # Bk \\<up> rna) \\<or>\n                                  rn = mr \\<and> rn = 0)))", "apply(rule_tac x = \"Suc 0\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv_locate_b (as, lm) (q, Oc # l, r) ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_equal: \"xs = ys \\<Longrightarrow> length xs = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys \\<Longrightarrow> length xs = length ys", "by auto"], ["", "lemma inv_locate_a_Bk_via_b[simp]: \"\\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires; \n                \\<not> (\\<exists>n. xs = Bk\\<up>n)\\<rbrakk> \n       \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires;\n     \\<nexists>n. xs = Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_b (as, am) (q, aaa, Bk # xs) ires;\n     \\<nexists>n. xs = Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires", "apply(simp add: inv_locate_b.simps inv_locate_a.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_middle (as, am) (q, aaa, Bk # xs) ires;\n     \\<forall>n. xs \\<noteq> Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> at_begin_norm (as, am) (Suc q, Bk # aaa, xs)\n                       ires \\<or>\n                      at_begin_fst_bwtn (as, am) (Suc q, Bk # aaa, xs)\n                       ires \\<or>\n                      at_begin_fst_awtn (as, am) (Suc q, Bk # aaa, xs) ires", "apply(rule_tac disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>in_middle (as, am) (q, aaa, Bk # xs) ires;\n     \\<forall>n. xs \\<noteq> Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> at_begin_norm (as, am) (Suc q, Bk # aaa, xs) ires", "apply(simp only: in_middle.simps at_begin_norm.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>lm1 lm2 tn m ml mr rn.\n                am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                length lm1 = q \\<and>\n                m + 1 = ml + mr \\<and>\n                ml \\<noteq> 0 \\<and>\n                tn = q + 1 - length am \\<and>\n                (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aaa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 lm2 = [] \\<and> Bk # xs = Oc \\<up> mr);\n     \\<forall>n. xs \\<noteq> Bk \\<up> n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                         am = lm1 @ lm2 \\<and>\n                         length lm1 = Suc q \\<and>\n                         (if lm1 = [] then Bk # aaa = Bk # Bk # ires\n                          else Bk # aaa =\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         xs = <lm2> @ Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       \\<lbrakk>\\<forall>n. xs \\<noteq> Bk \\<up> n;\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = q \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = q + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # xs = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                            am = lm1 @ lm2 \\<and>\n                            length lm1 = Suc q \\<and>\n                            (if lm1 = [] then Bk # aaa = Bk # Bk # ires\n                             else Bk # aaa =\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            xs = <lm2> @ Bk \\<up> rn", "apply(rename_tac lm1 lm2 tn m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       \\<lbrakk>\\<forall>n. xs \\<noteq> Bk \\<up> n;\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = q \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = q + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # xs = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                            am = lm1 @ lm2 \\<and>\n                            length lm1 = Suc q \\<and>\n                            (if lm1 = [] then Bk # aaa = Bk # Bk # ires\n                             else Bk # aaa =\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            xs = <lm2> @ Bk \\<up> rn", "apply(rule_tac x = \"lm1 @ [m]\" in exI, rule_tac x = lm2 in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       \\<lbrakk>\\<forall>n. xs \\<noteq> Bk \\<up> n;\n        am @ 0 \\<up> tn = lm1 @ m # lm2 \\<and>\n        length lm1 = q \\<and>\n        Suc m = ml + mr \\<and>\n        0 < ml \\<and>\n        tn = Suc q - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (mr = 0 \\<and> xs = <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # xs = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> am = lm1 @ m # lm2 \\<and>\n                         aaa = <m # rev lm1> @ Bk # Bk # ires \\<and>\n                         (\\<exists>rn. xs = <lm2> @ Bk \\<up> rn)", "apply(subgoal_tac \"tn = 0\", simp , auto split: if_splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n;\n        lm1 \\<noteq> []; am = lm1 @ m # lm2; q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Oc # Oc \\<up> m @ Bk # <rev lm1> = <m # rev lm1>\n 2. \\<And>lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n;\n        am @ 0 \\<up> (Suc 0 - length am) = m # lm2; q = 0;\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length am\n 3. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n;\n        lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc (length lm1) \\<le> length am", "apply(simp add: tape_of_nl_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n;\n        am @ 0 \\<up> (Suc 0 - length am) = m # lm2; q = 0;\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length am\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n;\n        lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc (length lm1) \\<le> length am", "apply(drule_tac length_equal, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n; q = 0;\n        aaa = Oc # Oc \\<up> m @ Bk # Bk # ires; xs = <lm2> @ Bk \\<up> rn;\n        length am + (Suc 0 - length am) = Suc (length lm2)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 \\<le> length am\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>\\<forall>n. <lm2> @ Bk \\<up> rn \\<noteq> Bk \\<up> n;\n        lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc (length lm1) \\<le> length am", "apply(cases \"length am\", simp_all, erule_tac x = rn in allE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>lm1 \\<noteq> [];\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn; <lm2> \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Suc (length lm1) \\<le> length am", "apply(drule_tac length_equal, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>lm1 \\<noteq> []; q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn; <lm2> \\<noteq> [];\n        length am + (Suc (length lm1) - length am) =\n        Suc (length lm1 + length lm2)\\<rbrakk>\n       \\<Longrightarrow> Suc (length lm1) \\<le> length am", "apply(case_tac \"(Suc (length lm1) - length am)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn nat.\n       \\<lbrakk>lm1 \\<noteq> []; q = length lm1;\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        xs = <lm2> @ Bk \\<up> rn; <lm2> \\<noteq> [];\n        length am + nat = length lm1 + length lm2;\n        Suc (length lm1) - length am = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (length lm1) \\<le> length am", "apply(case_tac lm2, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma locate_b_2_a[intro]: \n  \"inv_locate_b (as, am) (q, aaa, Bk # xs) ires\n    \\<Longrightarrow> inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, am) (q, aaa, Bk # xs) ires \\<Longrightarrow>\n    inv_locate_a (as, am) (Suc q, Bk # aaa, xs) ires", "apply(cases \"\\<exists> n. xs = Bk\\<up>n\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_b_Bk[simp]:  \"inv_locate_b (as, am) (q, l, []) ires \n           \\<Longrightarrow>  inv_locate_b (as, am) (q, l, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, am) (q, l, []) ires \\<Longrightarrow>\n    inv_locate_b (as, am) (q, l, [Bk]) ires", "by(force simp add: inv_locate_b.simps in_middle.simps)"], ["", "(*inv: from locate_b to after_write*)"], ["", "lemma div_rounding_down[simp]: \"(2*q - Suc 0) div 2 = (q - 1)\" \"(Suc (2*q)) div 2 = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * q - Suc 0) div 2 = q - 1 &&& Suc (2 * q) div 2 = q", "by arith+"], ["", "lemma even_plus_one_odd[simp]: \"x mod 2 = 0 \\<Longrightarrow> Suc x mod 2 = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even x \\<Longrightarrow> Suc x mod 2 = Suc 0", "by arith"], ["", "lemma odd_plus_one_even[simp]: \"x mod 2 = Suc 0 \\<Longrightarrow> Suc x mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod 2 = Suc 0 \\<Longrightarrow> is_even (Suc x)", "by arith"], ["", "lemma locate_b_2_locate_a[simp]: \n  \"\\<lbrakk>q > 0;  inv_locate_b (as, am) (q - Suc 0, aaa, Bk # xs) ires\\<rbrakk>\n   \\<Longrightarrow>  inv_locate_a (as, am) (q, Bk # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < q;\n     inv_locate_b (as, am) (q - Suc 0, aaa, Bk # xs) ires\\<rbrakk>\n    \\<Longrightarrow> inv_locate_a (as, am) (q, Bk # aaa, xs) ires", "apply(insert locate_b_2_a [of as am \"q - 1\" aaa xs ires], simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*inv: from locate_b to after_write*)"], ["", "lemma findnth_inv_layout_of_via_crsp[simp]:\n  \"crsp (layout_of ap) (as, lm) (s, l, r) ires\n  \\<Longrightarrow> findnth_inv (layout_of ap) n (as, lm) (Suc 0, l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crsp (layout_of ap) (as, lm) (s, l, r) ires \\<Longrightarrow>\n    findnth_inv (layout_of ap) n (as, lm) (Suc 0, l, r) ires", "by(auto simp: crsp.simps findnth_inv.simps inv_locate_a.simps\n      at_begin_norm.simps at_begin_fst_awtn.simps at_begin_fst_bwtn.simps)"], ["", "lemma findnth_correct_pre: \n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and not0: \"n > 0\"\n    and f: \"f = (\\<lambda> stp. (steps (Suc 0, l, r) (findnth n, 0) stp, n))\"\n    and P: \"P = (\\<lambda> ((s, l, r), n). s = Suc (2 * n))\"\n    and Q: \"Q = (\\<lambda> ((s, l, r), n). findnth_inv ly n (as, lm) (s, l, r) ires)\"\n  shows \"\\<exists> stp. P (f stp) \\<and> Q (f stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. P (f stp) \\<and> Q (f stp)", "proof(rule_tac LE = findnth_LE in halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf findnth_LE\n 2. Q (f 0)\n 3. \\<not> P (f 0)\n 4. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "show \"wf findnth_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf findnth_LE", "by(intro wf_findnth_LE)"], ["proof (state)\nthis:\n  wf findnth_LE\n\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "show \"Q (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (f 0)", "using crsp layout"], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires\n  ly = layout_of ap\n\ngoal (1 subgoal):\n 1. Q (f 0)", "apply(simp add: f P Q steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (f 0)\n\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "show \"\\<not> P (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "using not0"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "apply(simp add: f P steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> P (f 0)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "have \"\\<not> P (f na) \\<and> Q (f na) \\<Longrightarrow> Q (f (Suc na)) \\<and> (f (Suc na), f na) \n        \\<in> findnth_LE\" for na"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f na) \\<and> Q (f na) \\<Longrightarrow>\n    Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> findnth_LE", "proof(simp add: f, \n      cases \"steps (Suc 0, l, r) (findnth n, 0) na\", simp add: P)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        steps0 (Suc 0, l, r) (findnth n) na = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) (findnth n), n) \\<and>\n                         ((step0 (a, b, c) (findnth n), n), (a, b, c), n)\n                         \\<in> findnth_LE", "fix na a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        steps0 (Suc 0, l, r) (findnth n) na__ = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) (findnth n), n) \\<and>\n                         ((step0 (a, b, c) (findnth n), n), (a, b, c), n)\n                         \\<in> findnth_LE", "assume \"a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n)\""], ["proof (state)\nthis:\n  a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        steps0 (Suc 0, l, r) (findnth n) na__ = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) (findnth n), n) \\<and>\n                         ((step0 (a, b, c) (findnth n), n), (a, b, c), n)\n                         \\<in> findnth_LE", "thus  \"Q (step (a, b, c) (findnth n, 0), n) \\<and> \n        ((step (a, b, c) (findnth n, 0), n), (a, b, c), n) \\<in> findnth_LE\""], ["proof (prove)\nusing this:\n  a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n)\n\ngoal (1 subgoal):\n 1. Q (step0 (a, b, c) (findnth n), n) \\<and>\n    ((step0 (a, b, c) (findnth n), n), (a, b, c), n) \\<in> findnth_LE", "apply(cases c, case_tac [2] \"hd c\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n); c = []\\<rbrakk>\n    \\<Longrightarrow> Q (step0 (a, b, c) (findnth n), n) \\<and>\n                      ((step0 (a, b, c) (findnth n), n), (a, b, c), n)\n                      \\<in> findnth_LE\n 2. \\<And>aa list.\n       \\<lbrakk>a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        c = aa # list; a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) (findnth n), n) \\<and>\n                         ((step0 (a, b, c) (findnth n), n), (a, b, c), n)\n                         \\<in> findnth_LE\n 3. \\<And>aa list.\n       \\<lbrakk>a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        c = aa # list; a \\<noteq> Suc (2 * n) \\<and> Q ((a, b, c), n);\n        hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) (findnth n), n) \\<and>\n                         ((step0 (a, b, c) (findnth n), n), (a, b, c), n)\n                         \\<in> findnth_LE", "apply(simp_all add: step.simps findnth_LE_def Q findnth_inv.simps mod_2  lex_pair_def split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>c = []; 0 < a; a \\<le> Suc (2 * n); is_even a;\n     a \\<noteq> Suc (2 * n) \\<and>\n     inv_locate_b (as, lm) ((a - Suc 0) div 2, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inv_locate_a (as, lm) (a div 2, Bk # b, [])\n                       ires \\<and>\n                      2 * n - a < Suc (2 * n) - a\n 2. \\<And>aa list.\n       \\<lbrakk>c = Bk # list; aa = Bk; 0 < a; a \\<noteq> Suc (2 * n);\n        a \\<le> Suc (2 * n);\n        inv_locate_a (as, lm) ((a - Suc 0) div 2, b, Bk # list) ires;\n        a mod 2 = Suc 0\\<rbrakk>\n       \\<Longrightarrow> list = [] \\<longrightarrow>\n                         inv_locate_a (as, lm) ((a - Suc 0) div 2, b, [Oc])\n                          ires\n 3. \\<And>aa list.\n       \\<lbrakk>c = Bk # list; aa = Bk; 0 < a; a \\<noteq> Suc (2 * n);\n        a \\<le> Suc (2 * n);\n        inv_locate_b (as, lm) ((a - Suc 0) div 2, b, Bk # list) ires;\n        is_even a\\<rbrakk>\n       \\<Longrightarrow> (list \\<noteq> [] \\<and>\n                          hd list = Oc \\<longrightarrow>\n                          inv_locate_a (as, lm) (a div 2, Bk # b, list)\n                           ires \\<and>\n                          (2 * n - a < Suc (2 * n) - a \\<or>\n                           2 * n - a = Suc (2 * n) - a)) \\<and>\n                         (list = [] \\<longrightarrow>\n                          inv_locate_a (as, lm) (a div 2, Bk # b, [])\n                           ires \\<and>\n                          2 * n - a < Suc (2 * n) - a) \\<and>\n                         (hd list \\<noteq> Oc \\<longrightarrow>\n                          inv_locate_a (as, lm) (a div 2, Bk # b, list)\n                           ires \\<and>\n                          (2 * n - a < Suc (2 * n) - a \\<or>\n                           2 * n - a = Suc (2 * n) - a \\<and>\n                           list \\<noteq> []))\n 4. \\<And>aa list.\n       \\<lbrakk>c = Oc # list; aa = Oc; 0 < a; a \\<noteq> Suc (2 * n);\n        a \\<le> Suc (2 * n);\n        inv_locate_a (as, lm) ((a - Suc 0) div 2, b, Oc # list) ires;\n        a mod 2 = Suc 0\\<rbrakk>\n       \\<Longrightarrow> inv_locate_b (as, lm) (a div 2, Oc # b, list)\n                          ires \\<and>\n                         2 * n - a < Suc (2 * n) - a", "apply(auto simp: mod_ex1 mod_ex2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (step0 (a, b, c) (findnth n), n) \\<and>\n  ((step0 (a, b, c) (findnth n), n), (a, b, c), n) \\<in> findnth_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> P (f ?na) \\<and> Q (f ?na) \\<Longrightarrow>\n  Q (f (Suc ?na)) \\<and> (f (Suc ?na), f ?na) \\<in> findnth_LE\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "thus \"\\<forall>n. \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n        Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE\""], ["proof (prove)\nusing this:\n  \\<not> P (f ?na) \\<and> Q (f ?na) \\<Longrightarrow>\n  Q (f (Suc ?na)) \\<and> (f (Suc ?na), f ?na) \\<in> findnth_LE\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE", "by blast"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n     Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> findnth_LE\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_locate_a_via_crsp[simp]:\n  \"crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow> inv_locate_a (as, lm) (0, l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n    inv_locate_a (as, lm) (0, l, r) ires", "apply(auto simp: crsp.simps inv_locate_a.simps at_begin_norm.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma findnth_correct: \n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n  shows \"\\<exists> stp l' r'. steps (Suc 0, l, r) (findnth n, 0) stp = (Suc (2 * n), l', r')\n              \\<and> inv_locate_a (as, lm) (n, l', r') ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n       inv_locate_a (as, lm) (n, l', r') ires", "using crsp"], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n       inv_locate_a (as, lm) (n, l', r') ires", "apply(cases \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp l' r'.\n                         steps0 (Suc 0, l, r) (findnth n) stp =\n                         (Suc (2 * n), l', r') \\<and>\n                         inv_locate_a (as, lm) (n, l', r') ires\n 2. \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp l' r'.\n                         steps0 (Suc 0, l, r) (findnth n) stp =\n                         (Suc (2 * n), l', r') \\<and>\n                         inv_locate_a (as, lm) (n, l', r') ires", "apply(rule_tac x = 0 in exI, auto simp: steps.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; 0 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp l' r'.\n                         steps0 (Suc 0, l, r) (findnth n) stp =\n                         (Suc (2 * n), l', r') \\<and>\n                         inv_locate_a (as, lm) (n, l', r') ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; 0 < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp l' r'.\n                         steps0 (Suc 0, l, r) (findnth n) stp =\n                         (Suc (2 * n), l', r') \\<and>\n                         inv_locate_a (as, lm) (n, l', r') ires", "apply(drule_tac findnth_correct_pre, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires; 0 < n;\n        ly = layout_of ap;\n        steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), a, b);\n        findnth_inv (layout_of ap) n (as, lm) (Suc (2 * n), a, b)\n         ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp l' r'.\n                            steps0 (Suc 0, l, r) (findnth n) stp =\n                            (Suc (2 * n), l', r') \\<and>\n                            inv_locate_a (as, lm) (n, l', r') ires", "using findnth_inv.simps"], ["proof (prove)\nusing this:\n  findnth_inv ?ly ?n (?as, ?lm) (?s, ?l, ?r) ?ires =\n  (if ?s = 0 then False\n   else if ?s \\<le> Suc (2 * ?n)\n        then if ?s mod 2 = 1\n             then inv_locate_a (?as, ?lm) ((?s - 1) div 2, ?l, ?r) ?ires\n             else inv_locate_b (?as, ?lm) ((?s - 1) div 2, ?l, ?r) ?ires\n        else False)\n\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires; 0 < n;\n        ly = layout_of ap;\n        steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), a, b);\n        findnth_inv (layout_of ap) n (as, lm) (Suc (2 * n), a, b)\n         ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp l' r'.\n                            steps0 (Suc 0, l, r) (findnth n) stp =\n                            (Suc (2 * n), l', r') \\<and>\n                            inv_locate_a (as, lm) (n, l', r') ires", "by auto"], ["", "fun inc_inv :: \"nat \\<Rightarrow> inc_inv_t\"\n  where\n    \"inc_inv n (as, lm) (s, l, r) ires =\n              (let lm' = abc_lm_s lm n (Suc (abc_lm_v lm n)) in\n                if s = 0 then False\n                else if s = 1 then \n                   inv_locate_a (as, lm) (n, l, r) ires\n                else if s = 2 then \n                   inv_locate_b (as, lm) (n, l, r) ires\n                else if s = 3 then \n                   inv_after_write (as, lm') (s, l, r) ires\n                else if s = Suc 3 then \n                   inv_after_move (as, lm') (s, l, r) ires\n                else if s = Suc 4 then \n                   inv_after_clear (as, lm') (s, l, r) ires\n                else if s = Suc (Suc 4) then \n                   inv_on_right_moving (as, lm') (s, l, r) ires\n                else if s = Suc (Suc 5) then \n                   inv_on_left_moving (as, lm') (s, l, r) ires\n                else if s = Suc (Suc (Suc 5)) then \n                   inv_check_left_moving (as, lm') (s, l, r) ires\n                else if s = Suc (Suc (Suc (Suc 5))) then \n                   inv_after_left_moving (as, lm') (s, l, r) ires\n                else if s = Suc (Suc (Suc (Suc (Suc 5)))) then \n                   inv_stop (as, lm') (s, l, r) ires\n                else False)\""], ["", "fun abc_inc_stage1 :: \"config \\<Rightarrow> nat\"\n  where\n    \"abc_inc_stage1 (s, l, r) = \n            (if s = 0 then 0\n             else if s \\<le> 2 then 5\n             else if s \\<le> 6 then 4\n             else if s \\<le> 8 then 3\n             else if s = 9 then 2\n             else 1)\""], ["", "fun abc_inc_stage2 :: \"config \\<Rightarrow> nat\"\n  where\n    \"abc_inc_stage2 (s, l, r) =\n                (if s = 1 then 2\n                 else if s = 2 then 1\n                 else if s = 3 then length r\n                 else if s = 4 then length r\n                 else if s = 5 then length r\n                 else if s = 6 then \n                                  if r \\<noteq> [] then length r\n                                  else 1\n                 else if s = 7 then length l\n                 else if s = 8 then length l\n                 else 0)\""], ["", "fun abc_inc_stage3 :: \"config \\<Rightarrow>  nat\"\n  where\n    \"abc_inc_stage3 (s, l, r) = (\n              if s = 4 then 4\n              else if s = 5 then 3\n              else if s = 6 then \n                   if r \\<noteq> [] \\<and> hd r = Oc then 2\n                   else 1\n              else if s = 3 then 0\n              else if s = 2 then length r\n              else if s = 1 then \n                      if (r \\<noteq> [] \\<and> hd r = Oc) then 0\n                      else 1\n              else 10 - s)\""], ["", "definition inc_measure :: \"config \\<Rightarrow> nat \\<times> nat \\<times> nat\"\n  where\n    \"inc_measure c = \n    (abc_inc_stage1 c, abc_inc_stage2 c, abc_inc_stage3 c)\""], ["", "definition lex_triple :: \n  \"((nat \\<times> (nat \\<times> nat)) \\<times> (nat \\<times> (nat \\<times> nat))) set\"\n  where \"lex_triple \\<equiv> less_than <*lex*> lex_pair\""], ["", "definition inc_LE :: \"(config \\<times> config) set\"\n  where\n    \"inc_LE \\<equiv> (inv_image lex_triple inc_measure)\""], ["", "declare inc_inv.simps[simp del]"], ["", "lemma wf_inc_le[intro]: \"wf inc_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf inc_LE", "by(auto simp: inc_LE_def lex_triple_def lex_pair_def)"], ["", "lemma inv_locate_b_2_after_write[simp]:\n  assumes \"inv_locate_b (as, am) (n, aaa, Bk # xs) ires\"\n  shows \"inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n))) (s, aaa, Oc # xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)))\n     (s, aaa, Oc # xs) ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)))\n     (s, aaa, Oc # xs) ires", "from assms"], ["proof (chain)\npicking this:\n  inv_locate_b (as, am) (n, aaa, Bk # xs) ires", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_locate_b (as, am) (n, aaa, Bk # xs) ires\n\ngoal (1 subgoal):\n 1. inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)))\n     (s, aaa, Oc # xs) ires", "apply(auto simp: in_middle.simps inv_after_write.simps \n        abc_lm_v.simps abc_lm_s.simps inv_locate_b.simps simp del:split_head_repeat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ m # lm2; n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn m lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 lm1 @ (ml + mr) # lm2 = m # lm2a \\<and>\n                                 aaa = Oc \\<up> m @ Bk # Bk # ires \\<and>\n                                 xs = <lm2a> @ Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 lm1 @ (ml + mr) # lm2 =\n                                 lm1a @ m # lm2a \\<and>\n                                 aaa =\n                                 Oc \\<up> m @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 xs = <lm2a> @ Bk \\<up> rn))\n 2. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn m lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 m # lm2 \\<and>\n                                 aaa = Oc \\<up> m @ Bk # Bk # ires \\<and>\n                                 xs = <lm2> @ Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 lm1a @ m # lm2 \\<and>\n                                 aaa =\n                                 Oc \\<up> m @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 xs = <lm2> @ Bk \\<up> rn))", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ m # lm2; n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn m lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 lm1 @ (ml + mr) # lm2 = m # lm2a \\<and>\n                                 aaa = Oc \\<up> m @ Bk # Bk # ires \\<and>\n                                 xs = <lm2a> @ Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 lm1 @ (ml + mr) # lm2 =\n                                 lm1a @ m # lm2a \\<and>\n                                 aaa =\n                                 Oc \\<up> m @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 xs = <lm2a> @ Bk \\<up> rn))\n 2. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rn m lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 m # lm2 \\<and>\n                                 aaa = Oc \\<up> m @ Bk # Bk # ires \\<and>\n                                 xs = <lm2> @ Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 lm1a @ m # lm2 \\<and>\n                                 aaa =\n                                 Oc \\<up> m @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 xs = <lm2> @ Bk \\<up> rn))", "apply(case_tac [!] mr, auto split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; \\<not> length lm1 < length am;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; lm1 \\<noteq> [];\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ma lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 ma # lm2a \\<and>\n                                 Oc # Oc \\<up> m @ Bk # <rev lm1> =\n                                 Oc \\<up> ma \\<and>\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 lm1a @ ma # lm2a \\<and>\n                                 Oc # Oc \\<up> m @ Bk # <rev lm1> =\n                                 Oc \\<up> ma @ Bk # <rev lm1a> \\<and>\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna))", "apply(rename_tac lm1 lm2 m rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; \\<not> length lm1 < length am;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; lm1 \\<noteq> [];\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna ma lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 ma # lm2a \\<and>\n                                 Oc # Oc \\<up> m @ Bk # <rev lm1> =\n                                 Oc \\<up> ma \\<and>\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 am @\n                                 0 \\<up> (length lm1 - length am) @\n                                 [Suc 0] =\n                                 lm1a @ ma # lm2a \\<and>\n                                 Oc # Oc \\<up> m @ Bk # <rev lm1> =\n                                 Oc \\<up> ma @ Bk # <rev lm1a> \\<and>\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna))", "apply(rule_tac x = rn in exI, rule_tac x = \"Suc m\" in exI,\n        rule_tac x = \"lm1\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; \\<not> length lm1 < length am;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; lm1 \\<noteq> [];\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm2a.\n                            am @\n                            0 \\<up> (length lm1 - length am) @ [Suc 0] =\n                            lm1 @ Suc m # lm2a \\<and>\n                            <lm2> = <lm2a>", "apply(rule_tac x = \"lm2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; \\<not> length lm1 < length am;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; lm1 \\<noteq> [];\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> am @ 0 \\<up> (length lm1 - length am) @ [Suc 0] =\n                         lm1 @ Suc m # lm2 \\<and>\n                         <lm2> = <lm2>", "apply(simp only: Suc_diff_le exp_ind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>xs = <lm2> @ Bk \\<up> rn; \\<not> length lm1 < length am;\n        am @ 0 \\<up> (length lm1 - length am) @ [0] = lm1 @ m # lm2;\n        n = length lm1; lm1 \\<noteq> [];\n        aaa = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> am @ 0 \\<up> (length lm1 - length am) @ [Suc 0] =\n                         lm1 @ Suc m # lm2 \\<and>\n                         <lm2> = <lm2>", "by(subgoal_tac \"lm2 = []\"; force dest:length_equal)"], ["proof (state)\nthis:\n  inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)))\n   (s, aaa, Oc # xs) ires\n\ngoal:\nNo subgoals!", "qed"], ["", "(*inv: from after_write to after_move*)"], ["", "lemma inv_after_move_Oc_via_write[simp]: \"inv_after_write (as, lm) (x, l, Oc # r) ires\n                \\<Longrightarrow> inv_after_move (as, lm) (y, Oc # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_write (as, lm) (x, l, Oc # r) ires \\<Longrightarrow>\n    inv_after_move (as, lm) (y, Oc # l, r) ires", "apply(auto simp:inv_after_move.simps inv_after_write.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_after_write_Suc[simp]: \"inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)\n                )) (x, aaa, Bk # xs) ires = False\"\n  \"inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n))) \n                        (x, aaa, []) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n)))\n     (x, aaa, Bk # xs) ires =\n    False &&&\n    inv_after_write (as, abc_lm_s am n (Suc (abc_lm_v am n))) (x, aaa, [])\n     ires =\n    False", "apply(auto simp: inv_after_write.simps )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*inv: from after_move to after_clear*)"], ["", "lemma inv_after_clear_Bk_via_Oc[simp]: \"inv_after_move (as, lm) (s, l, Oc # r) ires\n                \\<Longrightarrow> inv_after_clear (as, lm) (s', l, Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_move (as, lm) (s, l, Oc # r) ires \\<Longrightarrow>\n    inv_after_clear (as, lm) (s', l, Bk # r) ires", "apply(auto simp: inv_after_move.simps inv_after_clear.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_after_move_2_inv_on_left_moving[simp]:  \n  assumes \"inv_after_move (as, lm) (s, l, Bk # r) ires\"\n  shows \"(l = [] \\<longrightarrow> \n         inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n      (l \\<noteq> [] \\<longrightarrow> \n         inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       (l = [] \\<longrightarrow>\n        inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n       (l \\<noteq> [] \\<longrightarrow>\n        inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "case (Cons a list)"], ["proof (state)\nthis:\n  l = a # list\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\n 2. \\<And>a list.\n       l = a # list \\<Longrightarrow>\n       (l = [] \\<longrightarrow>\n        inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n       (l \\<noteq> [] \\<longrightarrow>\n        inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "from assms Cons"], ["proof (chain)\npicking this:\n  inv_after_move (as, lm) (s, l, Bk # r) ires\n  l = a # list", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_after_move (as, lm) (s, l, Bk # r) ires\n  l = a # list\n\ngoal (1 subgoal):\n 1. (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "apply(simp only: inv_after_move.simps inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>rn m lm1 lm2.\n                lm = lm1 @ m # lm2 \\<and>\n                (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n                 else a # list =\n                      Oc \\<up> Suc m @\n                      Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                Bk # r = <lm2> @ Bk \\<up> rn;\n     l = a # list\\<rbrakk>\n    \\<Longrightarrow> (a # list = [] \\<longrightarrow>\n                       inv_on_left_moving_norm (as, lm)\n                        (s', [], Bk # Bk # r) ires \\<or>\n                       inv_on_left_moving_in_middle_B (as, lm)\n                        (s', [], Bk # Bk # r) ires) \\<and>\n                      (a # list \\<noteq> [] \\<longrightarrow>\n                       inv_on_left_moving_norm (as, lm)\n                        (s', tl (a # list), hd (a # list) # Bk # r)\n                        ires \\<or>\n                       inv_on_left_moving_in_middle_B (as, lm)\n                        (s', tl (a # list), hd (a # list) # Bk # r) ires)", "apply(rule conjI, force, rule impI, rule disjI1, simp only: inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>rn m lm1 lm2.\n                lm = lm1 @ m # lm2 \\<and>\n                (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n                 else a # list =\n                      Oc \\<up> Suc m @\n                      Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                Bk # r = <lm2> @ Bk \\<up> rn;\n     l = a # list; a # list \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                         lm = lm1 @ [m] @ lm2 \\<and>\n                         ml + mr = Suc m \\<and>\n                         0 < mr \\<and>\n                         (if lm1 = []\n                          then tl (a # list) = Oc \\<up> ml @ Bk # Bk # ires\n                          else tl (a # list) =\n                               Oc \\<up> ml @\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (hd (a # list) # Bk # r =\n                          Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and>\n                          hd (a # list) # Bk # r = Oc \\<up> mr)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = a # list; a # list \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n         else a # list =\n              Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl (a # list) =\n                                  Oc \\<up> ml @ Bk # Bk # ires\n                             else tl (a # list) =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (hd (a # list) # Bk # r =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and>\n                             hd (a # list) # Bk # r = Oc \\<up> mr)", "apply(rename_tac rn m lm1 lm2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = a # list; a # list \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n         else a # list =\n              Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl (a # list) =\n                                  Oc \\<up> ml @ Bk # Bk # ires\n                             else tl (a # list) =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (hd (a # list) # Bk # r =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and>\n                             hd (a # list) # Bk # r = Oc \\<up> mr)", "apply(subgoal_tac \"lm2 = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = a # list; a # list \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n         else a # list =\n              Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # r = <lm2> @ Bk \\<up> rn;\n        lm2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl (a # list) =\n                                  Oc \\<up> ml @ Bk # Bk # ires\n                             else tl (a # list) =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (hd (a # list) # Bk # r =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and>\n                             hd (a # list) # Bk # r = Oc \\<up> mr)\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = a # list; a # list \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n         else a # list =\n              Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI,  \n        rule_tac x = m in exI, rule_tac x = m in exI, \n        rule_tac x = 1 in exI,  \n        rule_tac x = \"rn - 1\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = a # list; a # list \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n         else a # list =\n              Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # r = <lm2> @ Bk \\<up> rn;\n        lm2 = []\\<rbrakk>\n       \\<Longrightarrow> lm = lm1 @ [m] @ lm2 \\<and>\n                         m + 1 = Suc m \\<and>\n                         0 < 1 \\<and>\n                         (if lm1 = []\n                          then tl (a # list) = Oc \\<up> m @ Bk # Bk # ires\n                          else tl (a # list) =\n                               Oc \\<up> m @\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (hd (a # list) # Bk # r =\n                          Oc \\<up> 1 @ Bk # <lm2> @ Bk \\<up> (rn - 1) \\<or>\n                          lm2 = [] \\<and>\n                          hd (a # list) # Bk # r = Oc \\<up> 1)\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = a # list; a # list \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then a # list = Oc \\<up> Suc m @ Bk # Bk # ires\n         else a # list =\n              Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []", "apply (auto split:if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>rn m.\n       \\<lbrakk>l = Oc # Oc \\<up> m @ Bk # Bk # ires; lm = [m]; a = Oc;\n        list = Oc \\<up> m @ Bk # Bk # ires; Bk # r = Bk \\<up> rn;\n        0 < rn\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> rn = Bk # Bk \\<up> (rn - Suc 0)\n 2. \\<And>rn m lm1.\n       \\<lbrakk>l = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        lm1 \\<noteq> []; lm = lm1 @ [m]; a = Oc;\n        list = Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Bk # r = Bk \\<up> rn; 0 < rn\\<rbrakk>\n       \\<Longrightarrow> Bk \\<up> rn = Bk # Bk \\<up> (rn - Suc 0)\n 3. \\<And>rn m lm2.\n       \\<lbrakk>l = Oc # Oc \\<up> m @ Bk # Bk # ires; lm = m # lm2; a = Oc;\n        list = Oc \\<up> m @ Bk # Bk # ires;\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 4. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        lm1 \\<noteq> []; lm = lm1 @ m # lm2; a = Oc;\n        list = Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []", "apply(case_tac [1-2] rn, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm2.\n       \\<lbrakk>l = Oc # Oc \\<up> m @ Bk # Bk # ires; lm = m # lm2; a = Oc;\n        list = Oc \\<up> m @ Bk # Bk # ires;\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>l = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        lm1 \\<noteq> []; lm = lm1 @ m # lm2; a = Oc;\n        list = Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []", "by(case_tac [!] lm2, simp_all add: tape_of_nl_cons split: if_splits)"], ["proof (state)\nthis:\n  (l = [] \\<longrightarrow>\n   inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n  (l \\<noteq> [] \\<longrightarrow>\n   inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\n\ngoal (1 subgoal):\n 1. l = [] \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = [] \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "case Nil"], ["proof (state)\nthis:\n  l = []\n\ngoal (1 subgoal):\n 1. l = [] \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "using assms"], ["proof (prove)\nusing this:\n  l = []\n  inv_after_move (as, lm) (s, l, Bk # r) ires\n\ngoal (1 subgoal):\n 1. (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "unfolding inv_after_move.simps inv_on_left_moving.simps"], ["proof (prove)\nusing this:\n  l = []\n  \\<exists>rn m lm1 lm2.\n     lm = lm1 @ m # lm2 \\<and>\n     (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n      else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n     Bk # r = <lm2> @ Bk \\<up> rn\n\ngoal (1 subgoal):\n 1. (l = [] \\<longrightarrow>\n     inv_on_left_moving_norm (as, lm) (s', [], Bk # Bk # r) ires \\<or>\n     inv_on_left_moving_in_middle_B (as, lm) (s', [], Bk # Bk # r)\n      ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving_norm (as, lm) (s', tl l, hd l # Bk # r) ires \\<or>\n     inv_on_left_moving_in_middle_B (as, lm) (s', tl l, hd l # Bk # r) ires)", "by (auto split:if_splits)"], ["proof (state)\nthis:\n  (l = [] \\<longrightarrow>\n   inv_on_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n  (l \\<noteq> [] \\<longrightarrow>\n   inv_on_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_after_move_2_inv_on_left_moving_B[simp]: \n  \"inv_after_move (as, lm) (s, l, []) ires\n      \\<Longrightarrow> (l = [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', [], [Bk]) ires) \\<and>\n          (l \\<noteq> [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', tl l, [hd l]) ires)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_move (as, lm) (s, l, []) ires \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], [Bk]) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, [hd l]) ires)", "apply(simp only: inv_after_move.simps inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving_norm (as, lm) (s', [], [Bk]) ires \\<or>\n     inv_on_left_moving_in_middle_B (as, lm) (s', [], [Bk]) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving_norm (as, lm) (s', tl l, [hd l]) ires \\<or>\n     inv_on_left_moving_in_middle_B (as, lm) (s', tl l, [hd l]) ires)", "apply(subgoal_tac \"l \\<noteq> []\", rule conjI, simp, rule impI, rule disjI1,\n      simp only: inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>rn m lm1 lm2.\n                lm = lm1 @ m # lm2 \\<and>\n                (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n                 else l =\n                      Oc \\<up> Suc m @\n                      Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                [] = <lm2> @ Bk \\<up> rn;\n     \\<not> False; l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                         lm = lm1 @ [m] @ lm2 \\<and>\n                         ml + mr = Suc m \\<and>\n                         0 < mr \\<and>\n                         (if lm1 = []\n                          then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                          else tl l =\n                               Oc \\<up> ml @\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         ([hd l] =\n                          Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and> [hd l] = Oc \\<up> mr)\n 2. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    l \\<noteq> []", "apply(erule exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>\\<not> False; l \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n         else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        [] = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            ([hd l] =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> [hd l] = Oc \\<up> mr)\n 2. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    l \\<noteq> []", "apply(rename_tac rn m lm1 lm2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>\\<not> False; l \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n         else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        [] = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            ([hd l] =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> [hd l] = Oc \\<up> mr)\n 2. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    l \\<noteq> []", "apply(subgoal_tac \"lm2 = []\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>\\<not> False; l \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n         else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        [] = <lm2> @ Bk \\<up> rn;\n        lm2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            ([hd l] =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> [hd l] = Oc \\<up> mr)\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>\\<not> False; l \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n         else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        [] = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 3. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    l \\<noteq> []", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI,  \n      rule_tac x = m in exI, rule_tac x = m in exI, \n      rule_tac x = 1 in exI, rule_tac x = \"rn - 1\" in exI, force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>\\<not> False; l \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n         else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        [] = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 2. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    l \\<noteq> []", "apply(metis append_Cons list.distinct(1) list.exhaust replicate_Suc tape_of_nl_cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rn m lm1 lm2.\n       lm = lm1 @ m # lm2 \\<and>\n       (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n       [] = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    l \\<noteq> []", "apply(metis append_Cons list.distinct(1) replicate_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_after_clear_2_inv_on_right_moving[simp]: \n  \"inv_after_clear (as, lm) (x, l, Bk # r) ires\n      \\<Longrightarrow> inv_on_right_moving (as, lm) (y, Bk # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_clear (as, lm) (x, l, Bk # r) ires \\<Longrightarrow>\n    inv_on_right_moving (as, lm) (y, Bk # l, r) ires", "apply(auto simp: inv_after_clear.simps inv_on_right_moving.simps simp del:split_head_repeat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     Bk # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     Bk # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))))", "apply(rename_tac rn m lm1 lm2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     Bk # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     Bk # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))))", "apply(subgoal_tac \"lm2 \\<noteq> []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn; lm2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     Bk # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     Bk # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))))\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 \\<noteq> []", "apply(rule_tac x = \"lm1 @ [m]\" in exI, rule_tac x = \"tl lm2\" in exI, \n      rule_tac x = \"hd lm2\" in exI, simp del:split_head_repeat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn; lm2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr.\n                            ml + mr = hd lm2 \\<and>\n                            Bk # l =\n                            Oc \\<up> ml @\n                            Bk # <m # rev lm1> @ Bk # Bk # ires \\<and>\n                            ((\\<exists>rn.\n                                 r =\n                                 Oc \\<up> mr @\n                                 Bk # <tl lm2> @ Bk \\<up> rn) \\<or>\n                             r = Oc \\<up> mr \\<and> tl lm2 = [])\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 \\<noteq> []", "apply(rule_tac x = 0 in exI, rule_tac x = \"hd lm2\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn; lm2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> 0 + hd lm2 = hd lm2 \\<and>\n                         Bk # l =\n                         Oc \\<up> 0 @\n                         Bk # <m # rev lm1> @ Bk # Bk # ires \\<and>\n                         ((\\<exists>rn.\n                              r =\n                              Oc \\<up> hd lm2 @\n                              Bk # <tl lm2> @ Bk \\<up> rn) \\<or>\n                          r = Oc \\<up> hd lm2 \\<and> tl lm2 = [])\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 \\<noteq> []", "apply(simp, rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn; lm2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> l = <m # rev lm1> @ Bk # Bk # ires\n 2. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn; lm2 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>rn.\n                             r =\n                             Oc \\<up> hd lm2 @\n                             Bk # <tl lm2> @ Bk \\<up> rn) \\<or>\n                         r = Oc \\<up> hd lm2 \\<and> tl lm2 = []\n 3. \\<And>rn m lm1 lm2.\n       \\<lbrakk>lm = lm1 @ m # lm2;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm2 \\<noteq> []", "apply(case_tac [!] \"lm2::nat list\", auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>rn m lm1 a list.\n       \\<lbrakk>lm = lm1 @ m # a # list;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <a # list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> l = <m # rev lm1> @ Bk # Bk # ires\n 2. \\<And>rn m lm1 a list.\n       \\<lbrakk>lm = lm1 @ m # a # list;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <a # list> @ Bk \\<up> rn;\n        \\<forall>rn.\n           r \\<noteq> Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> r = Oc \\<up> a\n 3. \\<And>rn m lm1 a list.\n       \\<lbrakk>lm = lm1 @ m # a # list;\n        if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Oc \\<up> Suc m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <a # list> @ Bk \\<up> rn;\n        \\<forall>rn.\n           r \\<noteq> Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> list = []", "apply(case_tac rn, auto split: if_splits simp: tape_of_nl_cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rn m a.\n       \\<lbrakk>\\<forall>rna. Bk \\<up> rn \\<noteq> Bk # Bk \\<up> rna;\n        lm = [m, a]; l = Oc # Oc \\<up> m @ Bk # Bk # ires;\n        r = Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> rn = 0\n 2. \\<And>rn m lm1 a.\n       \\<lbrakk>\\<forall>rna. Bk \\<up> rn \\<noteq> Bk # Bk \\<up> rna;\n        lm = lm1 @ [m, a]; lm1 \\<noteq> [];\n        l = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        r = Oc \\<up> a @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> rn = 0", "apply(case_tac [!] rn, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*inv: from on_right_moving to on_right_moving*)"], ["", "lemma inv_on_right_moving_Oc[simp]: \"inv_on_right_moving (as, lm) (x, l, Oc # r) ires\n      \\<Longrightarrow> inv_on_right_moving (as, lm) (y, Oc # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_right_moving (as, lm) (x, l, Oc # r) ires \\<Longrightarrow>\n    inv_on_right_moving (as, lm) (y, Oc # l, r) ires", "apply(auto simp: inv_on_right_moving.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 ml mr rn.\n       \\<lbrakk>lm = lm1 @ (ml + mr) # lm2;\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a m.\n                            lm1 @ (ml + mr) # lm2 = lm1a @ m # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))))\n 2. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            lm1 @ [ml + mr] = lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rename_tac lm1 lm2 ml mr rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 ml mr rn.\n       \\<lbrakk>lm = lm1 @ (ml + mr) # lm2;\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a m.\n                            lm1 @ (ml + mr) # lm2 = lm1a @ m # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2a = []))))\n 2. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            lm1 @ [ml + mr] = lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI, \n      rule_tac x = \"ml + mr\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 ml mr rn.\n       \\<lbrakk>lm = lm1 @ (ml + mr) # lm2;\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla mra.\n                            mla + mra = ml + mr \\<and>\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            ((\\<exists>rn.\n                                 r =\n                                 Oc \\<up> mra @\n                                 Bk # <lm2> @ Bk \\<up> rn) \\<or>\n                             r = Oc \\<up> mra \\<and> lm2 = [])\n 2. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            lm1 @ [ml + mr] = lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = \"Suc ml\" in exI, \n      rule_tac x = \"mr - 1\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 ml mr rn.\n       \\<lbrakk>lm = lm1 @ (ml + mr) # lm2;\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc (mr - Suc 0) = mr \\<and>\n                         ((\\<exists>rn.\n                              r =\n                              Oc \\<up> (mr - Suc 0) @\n                              Bk # <lm2> @ Bk \\<up> rn) \\<or>\n                          r = Oc \\<up> (mr - Suc 0) \\<and> lm2 = [])\n 2. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            lm1 @ [ml + mr] = lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))))", "apply (metis One_nat_def Suc_pred cell.distinct(1) empty_replicate list.inject\n      list.sel(3) neq0_conv self_append_conv2 tl_append2 tl_replicate)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            lm1 @ [ml + mr] = lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = m \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nr = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = lm1 in exI, rule_tac x = \"[]\" in exI, \n      rule_tac x = \"ml + mr\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mla mra.\n                            mla + mra = ml + mr \\<and>\n                            Oc # Oc \\<up> ml = Oc \\<up> mla \\<and>\n                            ((\\<exists>rn.\n                                 r = Oc \\<up> mra @ Bk # Bk \\<up> rn) \\<or>\n                             r = Oc \\<up> mra)", "apply(rule_tac x = \"Suc ml\" in exI, \n      rule_tac x = \"mr - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 ml mr.\n       \\<lbrakk>lm = lm1 @ [ml + mr];\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> Suc ml + (mr - 1) = ml + mr \\<and>\n                         Oc # Oc \\<up> ml = Oc \\<up> Suc ml \\<and>\n                         ((\\<exists>rn.\n                              r =\n                              Oc \\<up> (mr - 1) @ Bk # Bk \\<up> rn) \\<or>\n                          r = Oc \\<up> (mr - 1))", "apply (auto simp add: Cons_replicate_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_right_moving_2_inv_on_right_moving[simp]: \n  \"inv_on_right_moving (as, lm) (x, l, Bk # r) ires\n     \\<Longrightarrow> inv_after_write (as, lm) (y, l, Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_right_moving (as, lm) (x, l, Bk # r) ires \\<Longrightarrow>\n    inv_after_write (as, lm) (y, l, Oc # r) ires", "apply(auto simp: inv_on_right_moving.simps inv_after_write.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 ml rn.\n       \\<lbrakk>lm = lm1 @ ml # lm2;\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna m lm1a.\n                            (lm1a = [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 lm1 @ ml # lm2 = m # lm2a \\<and>\n                                 l = Oc \\<up> m @ Bk # Bk # ires \\<and>\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (\\<exists>lm2a.\n                                 lm1 @ ml # lm2 = lm1a @ m # lm2a \\<and>\n                                 l =\n                                 Oc \\<up> m @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna))", "by (metis append.left_neutral append_Cons )"], ["", "lemma inv_on_right_moving_singleton_Bk[simp]: \"inv_on_right_moving (as, lm) (x, l, []) ires\\<Longrightarrow> \n             inv_on_right_moving (as, lm) (y, l, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_right_moving (as, lm) (x, l, []) ires \\<Longrightarrow>\n    inv_on_right_moving (as, lm) (y, l, [Bk]) ires", "apply(auto simp: inv_on_right_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m.\n       \\<lbrakk>if lm1 = [] then l = Oc \\<up> m @ Bk # Bk # ires\n                else l = Oc \\<up> m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        lm = lm1 @ [m]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     l = Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     (mr = 0 \\<and> <lm2> = [] \\<or>\n[Bk] = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = ma \\<and>\n                                     l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     (mr = 0 \\<and> <lm2> = [] \\<or>\n[Bk] = Oc \\<up> mr \\<and> lm2 = []))))", "by fastforce"], ["", "(*inv: from on_left_moving to on_left_moving*)"], ["", "lemma no_inv_on_left_moving_in_middle_B_Oc[simp]: \"inv_on_left_moving_in_middle_B (as, lm) \n               (s, l, Oc # r) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, lm) (s, l, Oc # r) ires = False", "by(auto simp: inv_on_left_moving_in_middle_B.simps )"], ["", "lemma no_inv_on_left_moving_norm_Bk[simp]: \"inv_on_left_moving_norm (as, lm) (s, l, Bk # r) ires \n             = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_norm (as, lm) (s, l, Bk # r) ires = False", "by(auto simp: inv_on_left_moving_norm.simps)"], ["", "lemma inv_on_left_moving_in_middle_B_Bk[simp]: \n  \"\\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires;\n    hd l = Bk; l \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n     inv_on_left_moving_in_middle_B (as, lm) (s, tl l, Bk # Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires;\n     hd l = Bk; l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_in_middle_B (as, lm)\n                       (s, tl l, Bk # Oc # r) ires", "apply(cases l, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>inv_on_left_moving_norm (as, lm) (s, Bk # list, Oc # r)\n                 ires;\n        a = Bk; l = Bk # list\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_in_middle_B (as, lm)\n                          (s, list, Bk # Oc # r) ires", "apply(simp only: inv_on_left_moving_norm.simps \n      inv_on_left_moving_in_middle_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<exists>lm1 lm2 m ml mr rn.\n                   lm = lm1 @ [m] @ lm2 \\<and>\n                   ml + mr = Suc m \\<and>\n                   0 < mr \\<and>\n                   (if lm1 = []\n                    then Bk # list = Oc \\<up> ml @ Bk # Bk # ires\n                    else Bk # list =\n                         Oc \\<up> ml @\n                         Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                   (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                    lm2 = [] \\<and> Oc # r = Oc \\<up> mr);\n        a = Bk; l = Bk # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                            lm = lm1 @ lm2 \\<and>\n                            (if lm1 = [] then list = Bk # ires\n                             else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n                            Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list lm1 lm2 m ml mr rn.\n       \\<lbrakk>a = Bk; l = Bk # list;\n        lm = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        0 < mr \\<and>\n        (if lm1 = [] then Bk # list = Oc \\<up> ml @ Bk # Bk # ires\n         else Bk # list =\n              Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Oc # r = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                            lm = lm1 @ lm2 \\<and>\n                            (if lm1 = [] then list = Bk # ires\n                             else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n                            Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "unfolding tape_of_nl_cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list lm1 lm2 m ml mr rn.\n       \\<lbrakk>a = Bk; l = Bk # list;\n        lm = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        0 < mr \\<and>\n        (if lm1 = [] then Bk # list = Oc \\<up> ml @ Bk # Bk # ires\n         else Bk # list =\n              Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Oc # r = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                            lm = lm1 @ lm2 \\<and>\n                            (if lm1 = [] then list = Bk # ires\n                             else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n                            Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "apply(rename_tac a list lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list lm1 lm2 m ml mr rn.\n       \\<lbrakk>a = Bk; l = Bk # list;\n        lm = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        0 < mr \\<and>\n        (if lm1 = [] then Bk # list = Oc \\<up> ml @ Bk # Bk # ires\n         else Bk # list =\n              Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Oc # r = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 rn.\n                            lm = lm1 @ lm2 \\<and>\n                            (if lm1 = [] then list = Bk # ires\n                             else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n                            Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "apply(rule_tac x = lm1 in exI, rule_tac x = \"m # lm2\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm2 m rn.\n       \\<lbrakk>l = Bk # Bk # ires; lm = m # lm2;\n        r = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn =\n                            <m # lm2> @ Bk \\<up> rna\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>l = Bk # <rev lm1> @ Bk # Bk # ires; lm = lm1 @ m # lm2;\n        r = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn; lm1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn =\n                            <m # lm2> @ Bk \\<up> rna", "apply(auto simp: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_norm_Oc_Oc[simp]: \"\\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires; \n                hd l = Oc; l \\<noteq> []\\<rbrakk>\n            \\<Longrightarrow> inv_on_left_moving_norm (as, lm) \n                                        (s, tl l, Oc # Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires;\n     hd l = Oc; l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_norm (as, lm)\n                       (s, tl l, Oc # Oc # r) ires", "apply(simp only: inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>lm1 lm2 m ml mr rn.\n                lm = lm1 @ [m] @ lm2 \\<and>\n                ml + mr = Suc m \\<and>\n                0 < mr \\<and>\n                (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n                 else l =\n                      Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                 lm2 = [] \\<and> Oc # r = Oc \\<up> mr);\n     hd l = Oc; l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                         lm = lm1 @ [m] @ lm2 \\<and>\n                         ml + mr = Suc m \\<and>\n                         0 < mr \\<and>\n                         (if lm1 = []\n                          then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                          else tl l =\n                               Oc \\<up> ml @\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (Oc # Oc # r =\n                          Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and> Oc # Oc # r = Oc \\<up> mr)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>hd l = Oc; l \\<noteq> [];\n        lm = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        0 < mr \\<and>\n        (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n         else l = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Oc # r = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (Oc # Oc # r =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> Oc # Oc # r = Oc \\<up> mr)", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>hd l = Oc; l \\<noteq> [];\n        lm = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        0 < mr \\<and>\n        (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n         else l = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Oc # r = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            lm = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (Oc # Oc # r =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> Oc # Oc # r = Oc \\<up> mr)", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI, \n      rule_tac x = m in exI, rule_tac x = \"ml - 1\" in exI,\n      rule_tac x = \"Suc mr\" in exI, rule_tac x = rn in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>hd l = Oc; l \\<noteq> [];\n        lm = lm1 @ m # lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        0 < mr \\<and>\n        (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n         else l = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Oc # r = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> (lm1 = [] \\<longrightarrow>\n                          ml - Suc 0 + mr = m \\<and>\n                          tl (Oc \\<up> ml @ Bk # Bk # ires) =\n                          Oc \\<up> (ml - Suc 0) @ Bk # Bk # ires) \\<and>\n                         (lm1 \\<noteq> [] \\<longrightarrow>\n                          ml - Suc 0 + mr = m \\<and>\n                          tl (Oc \\<up> ml @\n                              Bk # <rev lm1> @ Bk # Bk # ires) =\n                          Oc \\<up> (ml - Suc 0) @\n                          Bk # <rev lm1> @ Bk # Bk # ires)", "apply(case_tac ml, auto simp: split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_in_middle_B_Bk_Oc[simp]: \"inv_on_left_moving_norm (as, lm) (s, [], Oc # r) ires\n     \\<Longrightarrow> inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_norm (as, lm) (s, [], Oc # r) ires \\<Longrightarrow>\n    inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # Oc # r) ires", "by(auto simp: inv_on_left_moving_norm.simps \n      inv_on_left_moving_in_middle_B.simps split: if_splits)"], ["", "lemma inv_on_left_moving_Oc_cases[simp]:\"inv_on_left_moving (as, lm) (s, l, Oc # r) ires\n    \\<Longrightarrow> (l = [] \\<longrightarrow> inv_on_left_moving (as, lm) (s, [], Bk # Oc # r) ires)\n \\<and>  (l \\<noteq> [] \\<longrightarrow> inv_on_left_moving (as, lm) (s, tl l, hd l # Oc # r) ires)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving (as, lm) (s, l, Oc # r) ires \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s, [], Bk # Oc # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s, tl l, hd l # Oc # r) ires)", "apply(simp add: inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # Oc # r)\n      ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving_norm (as, lm) (s, tl l, hd l # Oc # r) ires \\<or>\n     inv_on_left_moving_in_middle_B (as, lm) (s, tl l, hd l # Oc # r) ires)", "apply(cases \"l \\<noteq> []\", rule conjI, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires;\n     l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_norm (as, lm)\n                       (s, tl l, hd l # Oc # r) ires \\<or>\n                      inv_on_left_moving_in_middle_B (as, lm)\n                       (s, tl l, hd l # Oc # r) ires\n 2. \\<lbrakk>inv_on_left_moving_norm (as, lm) (s, l, Oc # r) ires;\n     \\<not> l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (l = [] \\<longrightarrow>\n                       inv_on_left_moving_in_middle_B (as, lm)\n                        (s, [], Bk # Oc # r) ires) \\<and>\n                      (l \\<noteq> [] \\<longrightarrow>\n                       inv_on_left_moving_norm (as, lm)\n                        (s, tl l, hd l # Oc # r) ires \\<or>\n                       inv_on_left_moving_in_middle_B (as, lm)\n                        (s, tl l, hd l # Oc # r) ires)", "apply(cases \"hd l\", simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma from_on_left_moving_to_check_left_moving[simp]: \"inv_on_left_moving_in_middle_B (as, lm) \n                                      (s, Bk # list, Bk # r) ires\n          \\<Longrightarrow> inv_check_left_moving_on_leftmost (as, lm) \n                                      (s', list, Bk # Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, lm) (s, Bk # list, Bk # r)\n     ires \\<Longrightarrow>\n    inv_check_left_moving_on_leftmost (as, lm) (s', list, Bk # Bk # r) ires", "apply(simp only: inv_on_left_moving_in_middle_B.simps inv_check_left_moving_on_leftmost.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 rn.\n       lm = lm1 @ lm2 \\<and>\n       (if lm1 = [] then Bk # list = Bk # ires\n        else Bk # list = <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # r = Bk # <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>rn.\n       list = ires \\<and> Bk # Bk # r = [Bk, Bk] @ <lm> @ Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       lm = lm1 @ lm2 \\<and>\n       (if lm1 = [] then Bk # list = Bk # ires\n        else Bk # list = <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # r = Bk # <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>rn.\n          list = ires \\<and> Bk # Bk # r = [Bk, Bk] @ <lm> @ Bk \\<up> rn", "apply(rename_tac lm1 lm2 rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       lm = lm1 @ lm2 \\<and>\n       (if lm1 = [] then Bk # list = Bk # ires\n        else Bk # list = <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # r = Bk # <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>rn.\n          list = ires \\<and> Bk # Bk # r = [Bk, Bk] @ <lm> @ Bk \\<up> rn", "apply(case_tac \"rev lm1\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = rev lista @ a # lm2 \\<and>\n                Bk # list = <a # lista> @ Bk # Bk # ires \\<and>\n                r = <lm2> @ Bk \\<up> rn;\n        lm1 = rev lista @ [a]\\<rbrakk>\n       \\<Longrightarrow> list = ires \\<and>\n                         (\\<exists>rna.\n                             <lm2> @ Bk \\<up> rn =\n                             <rev lista @ a # lm2> @ Bk \\<up> rna)", "apply(case_tac \"tl (rev lm1)\", simp_all add: tape_of_nat_def tape_of_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_in_middle_no_Bk[simp]:\n  \"inv_check_left_moving_in_middle (as, lm) (s, l, Bk # r) ires= False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving_in_middle (as, lm) (s, l, Bk # r) ires = False", "by(auto simp: inv_check_left_moving_in_middle.simps )"], ["", "lemma inv_check_left_moving_on_leftmost_Bk_Bk[simp]: \n  \"inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # r) ires\\<Longrightarrow> \n  inv_check_left_moving_on_leftmost (as, lm) (s', [], Bk # Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, lm) (s, [], Bk # r)\n     ires \\<Longrightarrow>\n    inv_check_left_moving_on_leftmost (as, lm) (s', [], Bk # Bk # r) ires", "apply(auto simp: inv_on_left_moving_in_middle_B.simps \n      inv_check_left_moving_on_leftmost.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_on_leftmost_no_Oc[simp]: \"inv_check_left_moving_on_leftmost (as, lm) \n                                       (s, list, Oc # r) ires= False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving_on_leftmost (as, lm) (s, list, Oc # r) ires =\n    False", "by(auto simp: inv_check_left_moving_on_leftmost.simps split: if_splits)"], ["", "lemma inv_check_left_moving_in_middle_Oc_Bk[simp]: \"inv_on_left_moving_in_middle_B (as, lm) \n                                         (s, Oc # list, Bk # r) ires\n \\<Longrightarrow> inv_check_left_moving_in_middle (as, lm) (s', list, Oc # Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, lm) (s, Oc # list, Bk # r)\n     ires \\<Longrightarrow>\n    inv_check_left_moving_in_middle (as, lm) (s', list, Oc # Bk # r) ires", "apply(auto simp: inv_on_left_moving_in_middle_B.simps \n      inv_check_left_moving_in_middle.simps  split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_2_check_left_moving[simp]:\n  \"inv_on_left_moving (as, lm) (s, l, Bk # r) ires\n \\<Longrightarrow> (l = [] \\<longrightarrow> inv_check_left_moving (as, lm) (s', [], Bk # Bk # r) ires)\n \\<and> (l \\<noteq> [] \\<longrightarrow> \n      inv_check_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving (as, lm) (s, l, Bk # r) ires \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_check_left_moving (as, lm) (s', [], Bk # Bk # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_check_left_moving (as, lm) (s', tl l, hd l # Bk # r) ires)", "by (cases l;cases \"hd l\", auto simp: inv_on_left_moving.simps inv_check_left_moving.simps)"], ["", "lemma inv_on_left_moving_norm_no_empty[simp]: \"inv_on_left_moving_norm (as, lm) (s, l, []) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_norm (as, lm) (s, l, []) ires = False", "apply(auto simp: inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_no_empty[simp]: \"inv_on_left_moving (as, lm) (s, l, []) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving (as, lm) (s, l, []) ires = False", "apply(simp add: inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> inv_on_left_moving_in_middle_B (as, lm) (s, l, []) ires", "apply(simp add: inv_on_left_moving_in_middle_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n  inv_check_left_moving_in_middle_2_on_left_moving_in_middle_B[simp]:\n  assumes \"inv_check_left_moving_in_middle (as, lm) (s, Bk # list, Oc # r) ires\"\n  shows \"inv_on_left_moving_in_middle_B (as, lm) (s', list, Bk # Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, lm) (s', list, Bk # Oc # r) ires", "using assms"], ["proof (prove)\nusing this:\n  inv_check_left_moving_in_middle (as, lm) (s, Bk # list, Oc # r) ires\n\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, lm) (s', list, Bk # Oc # r) ires", "apply(simp only: inv_check_left_moving_in_middle.simps \n      inv_on_left_moving_in_middle_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 r' rn.\n       lm = lm1 @ lm2 \\<and>\n       Oc # Bk # list = <rev lm1> @ Bk # Bk # ires \\<and>\n       Oc # r = Oc # Bk # r' \\<and>\n       r' = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    \\<exists>lm1 lm2 rn.\n       lm = lm1 @ lm2 \\<and>\n       (if lm1 = [] then list = Bk # ires\n        else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n       Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 r' rn.\n       lm = lm1 @ lm2 \\<and>\n       Oc # Bk # list = <rev lm1> @ Bk # Bk # ires \\<and>\n       Oc # r = Oc # Bk # r' \\<and>\n       r' = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 lm2 rn.\n          lm = lm1 @ lm2 \\<and>\n          (if lm1 = [] then list = Bk # ires\n           else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n          Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "apply(rename_tac lm1 lm2 r' rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 r' rn.\n       lm = lm1 @ lm2 \\<and>\n       Oc # Bk # list = <rev lm1> @ Bk # Bk # ires \\<and>\n       Oc # r = Oc # Bk # r' \\<and>\n       r' = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       \\<exists>lm1 lm2 rn.\n          lm = lm1 @ lm2 \\<and>\n          (if lm1 = [] then list = Bk # ires\n           else list = <rev lm1> @ Bk # Bk # ires) \\<and>\n          Bk # Oc # r = Bk # <lm2> @ Bk \\<up> rn", "apply(rule_tac x = \"rev (tl (rev lm1))\" in exI, \n      rule_tac x = \"[hd (rev lm1)] @ lm2\" in exI, auto)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> lm1 = [hd (rev lm1)]\n 2. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> list = Bk # ires\n 3. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Bk # <lm2> @ Bk \\<up> rn =\n                            <hd (rev lm1) # lm2> @ Bk \\<up> rna\n 4. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> lm1 = rev (tl (rev lm1)) @ [hd (rev lm1)]\n 5. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> list = <tl (rev lm1)> @ Bk # Bk # ires\n 6. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Bk # <lm2> @ Bk \\<up> rn =\n                            <hd (rev lm1) # lm2> @ Bk \\<up> rna", "apply(case_tac [!] \"rev lm1\",case_tac [!] \"tl (rev lm1)\")"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []; rev lm1 = [];\n        tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> lm1 = [hd (rev lm1)]\n 2. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []; rev lm1 = [];\n        tl (rev lm1) = a # lista\\<rbrakk>\n       \\<Longrightarrow> lm1 = [hd (rev lm1)]\n 3. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = [];\n        rev lm1 = a # lista; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> lm1 = [hd (rev lm1)]\n 4. \\<And>lm1 lm2 rn a lista aa listaa.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = [];\n        rev lm1 = a # lista; tl (rev lm1) = aa # listaa\\<rbrakk>\n       \\<Longrightarrow> lm1 = [hd (rev lm1)]\n 5. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []; rev lm1 = [];\n        tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> list = Bk # ires\n 6. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []; rev lm1 = [];\n        tl (rev lm1) = a # lista\\<rbrakk>\n       \\<Longrightarrow> list = Bk # ires\n 7. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = [];\n        rev lm1 = a # lista; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> list = Bk # ires\n 8. \\<And>lm1 lm2 rn a lista aa listaa.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = [];\n        rev lm1 = a # lista; tl (rev lm1) = aa # listaa\\<rbrakk>\n       \\<Longrightarrow> list = Bk # ires\n 9. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []; rev lm1 = [];\n        tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Bk # <lm2> @ Bk \\<up> rn =\n                            <hd (rev lm1) # lm2> @ Bk \\<up> rna\n 10. \\<And>lm1 lm2 rn a lista.\n        \\<lbrakk>lm = lm1 @ lm2;\n         Oc # Bk # list = <rev lm1> @ Bk # Bk # ires;\n         r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []; rev lm1 = [];\n         tl (rev lm1) = a # lista\\<rbrakk>\n        \\<Longrightarrow> \\<exists>rna.\n                             Oc # Bk # <lm2> @ Bk \\<up> rn =\n                             <hd (rev lm1) # lm2> @ Bk \\<up> rna\nA total of 24 subgoals...", "apply(simp_all add: tape_of_nat_def tape_of_list_def tape_of_nat_list.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn lista.\n       \\<lbrakk>lm = 0 # lm2; list = Bk # ires;\n        r = Bk # tape_of_nat_list lm2 @ Bk \\<up> rn; lista = [];\n        lm1 = [0]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Bk # tape_of_nat_list lm2 @ Bk \\<up> rn =\n                            tape_of_nat_list (0 # lm2) @ Bk \\<up> rna\n 2. \\<And>lm1 lm2 rn lista aa listaa.\n       \\<lbrakk>lm = rev listaa @ aa # 0 # lm2;\n        list = tape_of_nat_list (aa # listaa) @ Bk # Bk # ires;\n        r = Bk # tape_of_nat_list lm2 @ Bk \\<up> rn;\n        lm1 = rev listaa @ [aa, 0]; lista = aa # listaa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Bk # tape_of_nat_list lm2 @ Bk \\<up> rn =\n                            tape_of_nat_list (0 # lm2) @ Bk \\<up> rna", "apply(case_tac [1] lm2, auto simp:tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm2 rn aa lista.\n       \\<lbrakk>lm = rev lista @ aa # 0 # lm2;\n        list = tape_of_nat_list (aa # lista) @ Bk # Bk # ires;\n        r = Bk # tape_of_nat_list lm2 @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna.\n                            Oc # Bk # tape_of_nat_list lm2 @ Bk \\<up> rn =\n                            tape_of_nat_list (0 # lm2) @ Bk \\<up> rna", "apply(case_tac lm2, auto simp:tape_of_nat_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_in_middle_Bk_Oc[simp]: \n  \"inv_check_left_moving_in_middle (as, lm) (s, [], Oc # r) ires\\<Longrightarrow>\n     inv_check_left_moving_in_middle (as, lm) (s', [Bk], Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving_in_middle (as, lm) (s, [], Oc # r)\n     ires \\<Longrightarrow>\n    inv_check_left_moving_in_middle (as, lm) (s', [Bk], Oc # r) ires", "apply(auto simp: inv_check_left_moving_in_middle.simps )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_norm_Oc_Oc_via_middle[simp]: \"inv_check_left_moving_in_middle (as, lm) \n                       (s, Oc # list, Oc # r) ires\n   \\<Longrightarrow> inv_on_left_moving_norm (as, lm) (s', list, Oc # Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving_in_middle (as, lm) (s, Oc # list, Oc # r)\n     ires \\<Longrightarrow>\n    inv_on_left_moving_norm (as, lm) (s', list, Oc # Oc # r) ires", "apply(auto simp: inv_check_left_moving_in_middle.simps \n      inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a m.\n                            lm1 @ lm2 = lm1a @ m # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     0 < mr \\<and>\n                                     list =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n    Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\nlm2a = [] \\<and> Oc # Oc # Bk # <lm2> @ Bk \\<up> rn = Oc \\<up> mr))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     0 < mr \\<and>\n                                     list =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n    Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\nlm2a = [] \\<and> Oc # Oc # Bk # <lm2> @ Bk \\<up> rn = Oc \\<up> mr))))", "apply(rename_tac lm1 lm2 rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a m.\n                            lm1 @ lm2 = lm1a @ m # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     0 < mr \\<and>\n                                     list =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n    Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\nlm2a = [] \\<and> Oc # Oc # Bk # <lm2> @ Bk \\<up> rn = Oc \\<up> mr))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     0 < mr \\<and>\n                                     list =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n    Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\nlm2a = [] \\<and> Oc # Oc # Bk # <lm2> @ Bk \\<up> rn = Oc \\<up> mr))))", "apply(rule_tac x = \"rev (tl (rev lm1))\" in exI, \n      rule_tac x = lm2 in exI, rule_tac x = \"hd (rev lm1)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm1 @ lm2 =\n                         rev (tl (rev lm1)) @ hd (rev lm1) # lm2 \\<and>\n                         (\\<exists>ml.\n                             (rev (tl (rev lm1)) = [] \\<longrightarrow>\n                              (\\<exists>mr.\n                                  ml + mr = Suc (hd (rev lm1)) \\<and>\n                                  0 < mr \\<and>\n                                  list = Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                  ((\\<exists>rna.\n Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                                   lm2 = [] \\<and>\n                                   Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                   Oc \\<up> mr))) \\<and>\n                             (rev (tl (rev lm1)) \\<noteq>\n                              [] \\<longrightarrow>\n                              (\\<exists>mr.\n                                  ml + mr = Suc (hd (rev lm1)) \\<and>\n                                  0 < mr \\<and>\n                                  list =\n                                  Oc \\<up> ml @\n                                  Bk #\n                                  <rev (rev (tl (rev lm1)))> @\n                                  Bk # Bk # ires \\<and>\n                                  ((\\<exists>rna.\n Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                                   lm2 = [] \\<and>\n                                   Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                   Oc \\<up> mr))))", "apply(rule_tac conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> lm1 @ lm2 = rev (tl (rev lm1)) @ hd (rev lm1) # lm2\n 2. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            (rev (tl (rev lm1)) = [] \\<longrightarrow>\n                             (\\<exists>mr.\n                                 ml + mr = Suc (hd (rev lm1)) \\<and>\n                                 0 < mr \\<and>\n                                 list = Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                 ((\\<exists>rna.\nOc # Oc # Bk # <lm2> @ Bk \\<up> rn =\nOc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                                  lm2 = [] \\<and>\n                                  Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                  Oc \\<up> mr))) \\<and>\n                            (rev (tl (rev lm1)) \\<noteq>\n                             [] \\<longrightarrow>\n                             (\\<exists>mr.\n                                 ml + mr = Suc (hd (rev lm1)) \\<and>\n                                 0 < mr \\<and>\n                                 list =\n                                 Oc \\<up> ml @\n                                 Bk #\n                                 <rev (rev (tl (rev lm1)))> @\n                                 Bk # Bk # ires \\<and>\n                                 ((\\<exists>rna.\nOc # Oc # Bk # <lm2> @ Bk \\<up> rn =\nOc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                                  lm2 = [] \\<and>\n                                  Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                  Oc \\<up> mr)))", "apply(case_tac \"rev lm1\", simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml.\n                            (rev (tl (rev lm1)) = [] \\<longrightarrow>\n                             (\\<exists>mr.\n                                 ml + mr = Suc (hd (rev lm1)) \\<and>\n                                 0 < mr \\<and>\n                                 list = Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                 ((\\<exists>rna.\nOc # Oc # Bk # <lm2> @ Bk \\<up> rn =\nOc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                                  lm2 = [] \\<and>\n                                  Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                  Oc \\<up> mr))) \\<and>\n                            (rev (tl (rev lm1)) \\<noteq>\n                             [] \\<longrightarrow>\n                             (\\<exists>mr.\n                                 ml + mr = Suc (hd (rev lm1)) \\<and>\n                                 0 < mr \\<and>\n                                 list =\n                                 Oc \\<up> ml @\n                                 Bk #\n                                 <rev (rev (tl (rev lm1)))> @\n                                 Bk # Bk # ires \\<and>\n                                 ((\\<exists>rna.\nOc # Oc # Bk # <lm2> @ Bk \\<up> rn =\nOc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                                  lm2 = [] \\<and>\n                                  Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                  Oc \\<up> mr)))", "apply(rule_tac x = \"hd (rev lm1) - 1\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr.\n                            hd (rev lm1) - Suc 0 + mr =\n                            Suc (hd (rev lm1)) \\<and>\n                            0 < mr \\<and>\n                            list =\n                            Oc \\<up> (hd (rev lm1) - Suc 0) @\n                            Bk # Bk # ires \\<and>\n                            ((\\<exists>rna.\n                                 Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                 Oc \\<up> mr @\n                                 Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                             lm2 = [] \\<and>\n                             Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                             Oc \\<up> mr)\n 2. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>mr.\n                            hd (rev lm1) - Suc 0 + mr =\n                            Suc (hd (rev lm1)) \\<and>\n                            0 < mr \\<and>\n                            list =\n                            Oc \\<up> (hd (rev lm1) - Suc 0) @\n                            Bk # <tl (rev lm1)> @ Bk # Bk # ires \\<and>\n                            ((\\<exists>rna.\n                                 Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                                 Oc \\<up> mr @\n                                 Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                             lm2 = [] \\<and>\n                             Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                             Oc \\<up> mr)", "apply(rule_tac [!] x = \"Suc (Suc 0)\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) = []\\<rbrakk>\n       \\<Longrightarrow> Suc (hd (rev lm1) - Suc 0) = hd (rev lm1) \\<and>\n                         list =\n                         Oc \\<up> (hd (rev lm1) - Suc 0) @ Bk # Bk # ires\n 2. \\<And>lm1 lm2 rn.\n       \\<lbrakk>lm = lm1 @ lm2; Oc # Oc # list = <rev lm1> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; tl (rev lm1) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd (rev lm1) - Suc 0 + Suc (Suc 0) =\n                         Suc (hd (rev lm1)) \\<and>\n                         0 < Suc (Suc 0) \\<and>\n                         list =\n                         Oc \\<up> (hd (rev lm1) - Suc 0) @\n                         Bk # <tl (rev lm1)> @ Bk # Bk # ires \\<and>\n                         ((\\<exists>rna.\n                              Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                              Oc \\<up> Suc (Suc 0) @\n                              Bk # <lm2> @ Bk \\<up> rna) \\<or>\n                          lm2 = [] \\<and>\n                          Oc # Oc # Bk # <lm2> @ Bk \\<up> rn =\n                          Oc \\<up> Suc (Suc 0))", "apply(case_tac [!] \"rev lm1\", simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = a # lm2; Oc # list = Oc \\<up> a @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; lista = []; lm1 = [a]\\<rbrakk>\n       \\<Longrightarrow> Suc (a - Suc 0) = a \\<and>\n                         list = Oc \\<up> (a - Suc 0) @ Bk # Bk # ires\n 2. \\<And>lm1 lm2 rn a lista.\n       \\<lbrakk>lm = rev lista @ a # lm2;\n        Oc # Oc # list = <a # lista> @ Bk # Bk # ires;\n        r = Bk # <lm2> @ Bk \\<up> rn; lista \\<noteq> [];\n        lm1 = rev lista @ [a]\\<rbrakk>\n       \\<Longrightarrow> Suc (a - Suc 0) = a \\<and>\n                         list =\n                         Oc \\<up> (a - Suc 0) @\n                         Bk # <lista> @ Bk # Bk # ires", "apply(case_tac [!] \"last lm1\", simp_all add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_Oc_cases[simp]: \"inv_check_left_moving (as, lm) (s, l, Oc # r) ires\n\\<Longrightarrow> (l = [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', [], Bk # Oc # r) ires) \\<and>\n   (l \\<noteq> [] \\<longrightarrow> inv_on_left_moving (as, lm) (s', tl l, hd l # Oc # r) ires)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving (as, lm) (s, l, Oc # r) ires \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', [], Bk # Oc # r) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     inv_on_left_moving (as, lm) (s', tl l, hd l # Oc # r) ires)", "apply(cases l;cases \"hd l\", auto simp: inv_check_left_moving.simps inv_on_left_moving.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*inv: check_left_moving to after_left_moving*)"], ["", "lemma inv_after_left_moving_Bk_via_check[simp]: \"inv_check_left_moving (as, lm) (s, l, Bk # r) ires\n                \\<Longrightarrow> inv_after_left_moving (as, lm) (s', Bk # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving (as, lm) (s, l, Bk # r) ires \\<Longrightarrow>\n    inv_after_left_moving (as, lm) (s', Bk # l, r) ires", "apply(auto simp: inv_check_left_moving.simps \n      inv_check_left_moving_on_leftmost.simps inv_after_left_moving.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_after_left_moving_Bk_empty_via_check[simp]:\"inv_check_left_moving (as, lm) (s, l, []) ires\n      \\<Longrightarrow> inv_after_left_moving (as, lm) (s', Bk # l, []) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving (as, lm) (s, l, []) ires \\<Longrightarrow>\n    inv_after_left_moving (as, lm) (s', Bk # l, []) ires", "by(simp add: inv_check_left_moving.simps  \n      inv_check_left_moving_in_middle.simps \n      inv_check_left_moving_on_leftmost.simps)"], ["", "(*inv: after_left_moving to inv_stop*)"], ["", "lemma inv_stop_Bk_move[simp]: \"inv_after_left_moving (as, lm) (s, l, Bk # r) ires\n       \\<Longrightarrow> inv_stop (as, lm) (s', Bk # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_left_moving (as, lm) (s, l, Bk # r) ires \\<Longrightarrow>\n    inv_stop (as, lm) (s', Bk # l, r) ires", "apply(auto simp: inv_after_left_moving.simps inv_stop.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_stop_Bk_empty[simp]: \"inv_after_left_moving (as, lm) (s, l, []) ires\n             \\<Longrightarrow> inv_stop (as, lm) (s', Bk # l, []) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_left_moving (as, lm) (s, l, []) ires \\<Longrightarrow>\n    inv_stop (as, lm) (s', Bk # l, []) ires", "by(auto simp: inv_after_left_moving.simps)"], ["", "(*inv: stop to stop*)"], ["", "lemma inv_stop_indep_fst[simp]: \"inv_stop (as, lm) (x, l, r) ires \\<Longrightarrow> \n               inv_stop (as, lm) (y, l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_stop (as, lm) (x, l, r) ires \\<Longrightarrow>\n    inv_stop (as, lm) (y, l, r) ires", "apply(simp add: inv_stop.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_after_clear_no_Oc[simp]: \"inv_after_clear (as, lm) (s, aaa, Oc # xs) ires= False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_clear (as, lm) (s, aaa, Oc # xs) ires = False", "apply(auto simp: inv_after_clear.simps )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_after_left_moving_no_Oc[simp]: \n  \"inv_after_left_moving (as, lm) (s, aaa, Oc # xs) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_left_moving (as, lm) (s, aaa, Oc # xs) ires = False", "by(auto simp: inv_after_left_moving.simps  )"], ["", "lemma inv_after_clear_Suc_nonempty[simp]:\n  \"inv_after_clear (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (s, b, []) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_after_clear (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (s, b, [])\n     ires =\n    False", "apply(auto simp: inv_after_clear.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_Suc_nonempty[simp]: \"inv_on_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) \n           (s, b, Oc # list) ires \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n     (s, b, Oc # list) ires \\<Longrightarrow>\n    b \\<noteq> []", "apply(auto simp: inv_on_left_moving.simps inv_on_left_moving_norm.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_Suc_nonempty[simp]:\n  \"inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (s, b, Oc # list) ires \\<Longrightarrow> b \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n     (s, b, Oc # list) ires \\<Longrightarrow>\n    b \\<noteq> []", "apply(auto simp: inv_check_left_moving.simps inv_check_left_moving_in_middle.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tinc_correct_pre:\n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_a (as, lm) (n, l, r) ires\"\n    and lm': \"lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\"\n    and f: \"f = steps (Suc 0, l, r) (tinc_b, 0)\"\n    and P: \"P = (\\<lambda> (s, l, r). s = 10)\"\n    and Q: \"Q = (\\<lambda> (s, l, r). inc_inv n (as, lm) (s, l, r) ires)\" \n  shows \"\\<exists> stp. P (f stp) \\<and> Q (f stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. P (f stp) \\<and> Q (f stp)", "proof(rule_tac LE = inc_LE in halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf inc_LE\n 2. Q (f 0)\n 3. \\<not> P (f 0)\n 4. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "show \"wf inc_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf inc_LE", "by(auto)"], ["proof (state)\nthis:\n  wf inc_LE\n\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "show \"Q (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (f 0)", "using inv_start"], ["proof (prove)\nusing this:\n  inv_locate_a (as, lm) (n, l, r) ires\n\ngoal (1 subgoal):\n 1. Q (f 0)", "by(simp add: f P Q steps.simps inc_inv.simps)"], ["proof (state)\nthis:\n  Q (f 0)\n\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "show \"\\<not> P (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "by(simp add: f P steps.simps)"], ["proof (state)\nthis:\n  \\<not> P (f 0)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "have \"\\<not> P (f n) \\<and> Q (f n) \\<Longrightarrow> Q (f (Suc n)) \\<and> (f (Suc n), f n) \n        \\<in> inc_LE\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f n) \\<and> Q (f n) \\<Longrightarrow>\n    Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "proof(simp add: f, \n      cases \"steps (Suc 0, l, r) (tinc_b, 0) n\", simp add: P)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<noteq> 10 \\<and> Q (a, b, c);\n        steps0 (Suc 0, l, r) tinc_b n = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) tinc_b) \\<and>\n                         (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "fix n a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<noteq> 10 \\<and> Q (a, b, c);\n        steps0 (Suc 0, l, r) tinc_b na__ = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) tinc_b) \\<and>\n                         (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "assume 10: \"a \\<noteq> 10 \\<and> Q (a, b, c)\""], ["proof (state)\nthis:\n  a \\<noteq> 10 \\<and> Q (a, b, c)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<noteq> 10 \\<and> Q (a, b, c);\n        steps0 (Suc 0, l, r) tinc_b na__ = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step0 (a, b, c) tinc_b) \\<and>\n                         (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "thus  \"Q (step (a, b, c) (tinc_b, 0)) \\<and> (step (a, b, c) (tinc_b, 0), a, b, c) \\<in> inc_LE\""], ["proof (prove)\nusing this:\n  a \\<noteq> 10 \\<and> Q (a, b, c)\n\ngoal (1 subgoal):\n 1. Q (step0 (a, b, c) tinc_b) \\<and>\n    (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "apply(simp add:Q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 10 \\<and> inc_inv n (as, lm) (a, b, c) ires \\<Longrightarrow>\n    inc_inv n (as, lm) (step0 (a, b, c) tinc_b) ires \\<and>\n    (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "apply(simp add: inc_inv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 10 \\<and>\n    (let lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\n     in if a = 0 then False\n        else if a = 1 then inv_locate_a (as, lm) (n, b, c) ires\n             else if a = 2 then inv_locate_b (as, lm) (n, b, c) ires\n                  else if a = 3\n                       then inv_after_write (as, lm') (a, b, c) ires\n                       else if a = Suc 3\n                            then inv_after_move (as, lm') (a, b, c) ires\n                            else if a = Suc 4\n                                 then inv_after_clear (as, lm') (a, b, c)\n ires\n                                 else if a = Suc (Suc 4)\nthen inv_on_right_moving (as, lm') (a, b, c) ires\nelse if a = Suc (Suc 5) then inv_on_left_moving (as, lm') (a, b, c) ires\n     else if a = Suc (Suc (Suc 5))\n          then inv_check_left_moving (as, lm') (a, b, c) ires\n          else if a = Suc (Suc (Suc (Suc 5)))\n               then inv_after_left_moving (as, lm') (a, b, c) ires\n               else if a = Suc (Suc (Suc (Suc (Suc 5))))\n                    then inv_stop (as, lm') (a, b, c) ires\n                    else False) \\<Longrightarrow>\n    inc_inv n (as, lm) (step0 (a, b, c) tinc_b) ires \\<and>\n    (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "apply(cases c; cases \"hd c\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>a \\<noteq> 10 \\<and>\n             (let lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\n              in if a = 0 then False\n                 else if a = 1 then inv_locate_a (as, lm) (n, b, c) ires\n                      else if a = 2\n                           then inv_locate_b (as, lm) (n, b, c) ires\n                           else if a = 3\n                                then inv_after_write (as, lm') (a, b, c)\nires\n                                else if a = Suc 3\n                                     then inv_after_move (as, lm') (a, b, c)\n     ires\n                                     else if a = Suc 4\n    then inv_after_clear (as, lm') (a, b, c) ires\n    else if a = Suc (Suc 4)\n         then inv_on_right_moving (as, lm') (a, b, c) ires\n         else if a = Suc (Suc 5)\n              then inv_on_left_moving (as, lm') (a, b, c) ires\n              else if a = Suc (Suc (Suc 5))\n                   then inv_check_left_moving (as, lm') (a, b, c) ires\n                   else if a = Suc (Suc (Suc (Suc 5)))\n                        then inv_after_left_moving (as, lm') (a, b, c) ires\n                        else if a = Suc (Suc (Suc (Suc (Suc 5))))\n                             then inv_stop (as, lm') (a, b, c) ires\n                             else False);\n     c = []; hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm) (step0 (a, b, c) tinc_b)\n                       ires \\<and>\n                      (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE\n 2. \\<lbrakk>a \\<noteq> 10 \\<and>\n             (let lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\n              in if a = 0 then False\n                 else if a = 1 then inv_locate_a (as, lm) (n, b, c) ires\n                      else if a = 2\n                           then inv_locate_b (as, lm) (n, b, c) ires\n                           else if a = 3\n                                then inv_after_write (as, lm') (a, b, c)\nires\n                                else if a = Suc 3\n                                     then inv_after_move (as, lm') (a, b, c)\n     ires\n                                     else if a = Suc 4\n    then inv_after_clear (as, lm') (a, b, c) ires\n    else if a = Suc (Suc 4)\n         then inv_on_right_moving (as, lm') (a, b, c) ires\n         else if a = Suc (Suc 5)\n              then inv_on_left_moving (as, lm') (a, b, c) ires\n              else if a = Suc (Suc (Suc 5))\n                   then inv_check_left_moving (as, lm') (a, b, c) ires\n                   else if a = Suc (Suc (Suc (Suc 5)))\n                        then inv_after_left_moving (as, lm') (a, b, c) ires\n                        else if a = Suc (Suc (Suc (Suc (Suc 5))))\n                             then inv_stop (as, lm') (a, b, c) ires\n                             else False);\n     c = []; hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm) (step0 (a, b, c) tinc_b)\n                       ires \\<and>\n                      (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE\n 3. \\<And>aa list.\n       \\<lbrakk>a \\<noteq> 10 \\<and>\n                (let lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\n                 in if a = 0 then False\n                    else if a = 1 then inv_locate_a (as, lm) (n, b, c) ires\n                         else if a = 2\n                              then inv_locate_b (as, lm) (n, b, c) ires\n                              else if a = 3\n                                   then inv_after_write (as, lm') (a, b, c)\n   ires\n                                   else if a = Suc 3\n  then inv_after_move (as, lm') (a, b, c) ires\n  else if a = Suc 4 then inv_after_clear (as, lm') (a, b, c) ires\n       else if a = Suc (Suc 4)\n            then inv_on_right_moving (as, lm') (a, b, c) ires\n            else if a = Suc (Suc 5)\n                 then inv_on_left_moving (as, lm') (a, b, c) ires\n                 else if a = Suc (Suc (Suc 5))\n                      then inv_check_left_moving (as, lm') (a, b, c) ires\n                      else if a = Suc (Suc (Suc (Suc 5)))\n                           then inv_after_left_moving (as, lm') (a, b, c)\n                                 ires\n                           else if a = Suc (Suc (Suc (Suc (Suc 5))))\n                                then inv_stop (as, lm') (a, b, c) ires\n                                else False);\n        c = aa # list; hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> inc_inv n (as, lm) (step0 (a, b, c) tinc_b)\n                          ires \\<and>\n                         (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE\n 4. \\<And>aa list.\n       \\<lbrakk>a \\<noteq> 10 \\<and>\n                (let lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\n                 in if a = 0 then False\n                    else if a = 1 then inv_locate_a (as, lm) (n, b, c) ires\n                         else if a = 2\n                              then inv_locate_b (as, lm) (n, b, c) ires\n                              else if a = 3\n                                   then inv_after_write (as, lm') (a, b, c)\n   ires\n                                   else if a = Suc 3\n  then inv_after_move (as, lm') (a, b, c) ires\n  else if a = Suc 4 then inv_after_clear (as, lm') (a, b, c) ires\n       else if a = Suc (Suc 4)\n            then inv_on_right_moving (as, lm') (a, b, c) ires\n            else if a = Suc (Suc 5)\n                 then inv_on_left_moving (as, lm') (a, b, c) ires\n                 else if a = Suc (Suc (Suc 5))\n                      then inv_check_left_moving (as, lm') (a, b, c) ires\n                      else if a = Suc (Suc (Suc (Suc 5)))\n                           then inv_after_left_moving (as, lm') (a, b, c)\n                                 ires\n                           else if a = Suc (Suc (Suc (Suc (Suc 5))))\n                                then inv_stop (as, lm') (a, b, c) ires\n                                else False);\n        c = aa # list; hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> inc_inv n (as, lm) (step0 (a, b, c) tinc_b)\n                          ires \\<and>\n                         (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE", "apply(auto simp: Let_def step.simps tinc_b_def split: if_splits)"], ["proof (prove)\ngoal (54 subgoals):\n 1. \\<lbrakk>c = []; hd [] = Bk; a = Suc 0;\n     inv_locate_a (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm) (Suc 0, b, [Oc]) ires\n 2. \\<lbrakk>c = []; hd [] = Bk; a = Suc 0;\n     inv_locate_a (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> ((Suc 0, b, [Oc]), Suc 0, b, []) \\<in> inc_LE\n 3. \\<lbrakk>c = []; hd [] = Bk; a = 2;\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              2 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 4. \\<lbrakk>c = []; hd [] = Bk; a = 2;\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> (case fetch\n                             [(W1, Suc 0), (R, 2), (W1, 3), (R, 2), (W1, 3),\n                              (R, 4), (L, 7), (W0, 5), (R, 6), (W0, 5),\n                              (W1, 3), (R, 6), (L, 8), (L, 7), (R, 9),\n                              (L, 7), (R, 10), (W0, 9)]\n                             2 Bk of\n                       (a, s') \\<Rightarrow> (s', update a (b, [])),\n                       2, b, [])\n                      \\<in> inc_LE\n 5. \\<lbrakk>c = []; hd [] = Bk; a = 4;\n     inv_after_move (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (4, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              4 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 6. \\<lbrakk>c = []; hd [] = Bk; a = 4;\n     inv_after_move (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (4, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> (case fetch\n                             [(W1, Suc 0), (R, 2), (W1, 3), (R, 2), (W1, 3),\n                              (R, 4), (L, 7), (W0, 5), (R, 6), (W0, 5),\n                              (W1, 3), (R, 6), (L, 8), (L, 7), (R, 9),\n                              (L, 7), (R, 10), (W0, 9)]\n                             4 Bk of\n                       (a, s') \\<Rightarrow> (s', update a (b, [])),\n                       4, b, [])\n                      \\<in> inc_LE\n 7. \\<lbrakk>c = []; hd [] = Bk; a = 6;\n     inv_on_right_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n      (6, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              6 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 8. \\<lbrakk>c = []; hd [] = Bk; a = 6;\n     inv_on_right_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n      (6, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> (case fetch\n                             [(W1, Suc 0), (R, 2), (W1, 3), (R, 2), (W1, 3),\n                              (R, 4), (L, 7), (W0, 5), (R, 6), (W0, 5),\n                              (W1, 3), (R, 6), (L, 8), (L, 7), (R, 9),\n                              (L, 7), (R, 10), (W0, 9)]\n                             6 Bk of\n                       (a, s') \\<Rightarrow> (s', update a (b, [])),\n                       6, b, [])\n                      \\<in> inc_LE\n 9. \\<lbrakk>c = []; hd [] = Bk; a = 8;\n     inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n      (8, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              8 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 10. \\<lbrakk>c = []; hd [] = Bk; a = 8;\n      inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n       (8, b, []) ires\\<rbrakk>\n     \\<Longrightarrow> (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              8 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        8, b, [])\n                       \\<in> inc_LE\nA total of 54 subgoals...", "(* ~ 12 sec *)"], ["proof (prove)\ngoal (54 subgoals):\n 1. \\<lbrakk>c = []; hd [] = Bk; a = Suc 0;\n     inv_locate_a (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm) (Suc 0, b, [Oc]) ires\n 2. \\<lbrakk>c = []; hd [] = Bk; a = Suc 0;\n     inv_locate_a (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> ((Suc 0, b, [Oc]), Suc 0, b, []) \\<in> inc_LE\n 3. \\<lbrakk>c = []; hd [] = Bk; a = 2;\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              2 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 4. \\<lbrakk>c = []; hd [] = Bk; a = 2;\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> (case fetch\n                             [(W1, Suc 0), (R, 2), (W1, 3), (R, 2), (W1, 3),\n                              (R, 4), (L, 7), (W0, 5), (R, 6), (W0, 5),\n                              (W1, 3), (R, 6), (L, 8), (L, 7), (R, 9),\n                              (L, 7), (R, 10), (W0, 9)]\n                             2 Bk of\n                       (a, s') \\<Rightarrow> (s', update a (b, [])),\n                       2, b, [])\n                      \\<in> inc_LE\n 5. \\<lbrakk>c = []; hd [] = Bk; a = 4;\n     inv_after_move (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (4, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              4 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 6. \\<lbrakk>c = []; hd [] = Bk; a = 4;\n     inv_after_move (as, abc_lm_s lm n (Suc (abc_lm_v lm n))) (4, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> (case fetch\n                             [(W1, Suc 0), (R, 2), (W1, 3), (R, 2), (W1, 3),\n                              (R, 4), (L, 7), (W0, 5), (R, 6), (W0, 5),\n                              (W1, 3), (R, 6), (L, 8), (L, 7), (R, 9),\n                              (L, 7), (R, 10), (W0, 9)]\n                             4 Bk of\n                       (a, s') \\<Rightarrow> (s', update a (b, [])),\n                       4, b, [])\n                      \\<in> inc_LE\n 7. \\<lbrakk>c = []; hd [] = Bk; a = 6;\n     inv_on_right_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n      (6, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              6 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 8. \\<lbrakk>c = []; hd [] = Bk; a = 6;\n     inv_on_right_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n      (6, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> (case fetch\n                             [(W1, Suc 0), (R, 2), (W1, 3), (R, 2), (W1, 3),\n                              (R, 4), (L, 7), (W0, 5), (R, 6), (W0, 5),\n                              (W1, 3), (R, 6), (L, 8), (L, 7), (R, 9),\n                              (L, 7), (R, 10), (W0, 9)]\n                             6 Bk of\n                       (a, s') \\<Rightarrow> (s', update a (b, [])),\n                       6, b, [])\n                      \\<in> inc_LE\n 9. \\<lbrakk>c = []; hd [] = Bk; a = 8;\n     inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n      (8, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> inc_inv n (as, lm)\n                       (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              8 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])))\n                       ires\n 10. \\<lbrakk>c = []; hd [] = Bk; a = 8;\n      inv_check_left_moving (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n       (8, b, []) ires\\<rbrakk>\n     \\<Longrightarrow> (case fetch\n                              [(W1, Suc 0), (R, 2), (W1, 3), (R, 2),\n                               (W1, 3), (R, 4), (L, 7), (W0, 5), (R, 6),\n                               (W0, 5), (W1, 3), (R, 6), (L, 8), (L, 7),\n                               (R, 9), (L, 7), (R, 10), (W0, 9)]\n                              8 Bk of\n                        (a, s') \\<Rightarrow> (s', update a (b, [])),\n                        8, b, [])\n                       \\<in> inc_LE\nA total of 54 subgoals...", "apply(simp_all add: inc_inv.simps inc_LE_def lex_triple_def lex_pair_def\n          inc_measure_def numeral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (step0 (a, b, c) tinc_b) \\<and>\n  (step0 (a, b, c) tinc_b, a, b, c) \\<in> inc_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> P (f ?n) \\<and> Q (f ?n) \\<Longrightarrow>\n  Q (f (Suc ?n)) \\<and> (f (Suc ?n), f ?n) \\<in> inc_LE\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "thus \"\\<forall>n. \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow> Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE\""], ["proof (prove)\nusing this:\n  \\<not> P (f ?n) \\<and> Q (f ?n) \\<Longrightarrow>\n  Q (f (Suc ?n)) \\<and> (f (Suc ?n), f ?n) \\<in> inc_LE\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE", "by blast"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n     Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> inc_LE\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tinc_correct: \n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_a (as, lm) (n, l, r) ires\"\n    and lm': \"lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\"\n  shows \"\\<exists> stp l' r'. steps (Suc 0, l, r) (tinc_b, 0) stp = (10, l', r')\n              \\<and> inv_stop (as, lm') (10, l', r') ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) tinc_b stp = (10, l', r') \\<and>\n       inv_stop (as, lm') (10, l', r') ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  inv_locate_a (as, lm) (n, l, r) ires\n  lm' = abc_lm_s lm n (Suc (abc_lm_v lm n))\n\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) tinc_b stp = (10, l', r') \\<and>\n       inv_stop (as, lm') (10, l', r') ires", "apply(drule_tac tinc_correct_pre, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>ly = layout_of ap; inv_locate_a (as, lm) (n, l, r) ires;\n        lm' = abc_lm_s lm n (Suc (abc_lm_v lm n));\n        steps0 (Suc 0, l, r) tinc_b stp = (10, a, b);\n        inc_inv n (as, lm) (10, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp l' r'.\n                            steps0 (Suc 0, l, r) tinc_b stp =\n                            (10, l', r') \\<and>\n                            inv_stop\n                             (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n                             (10, l', r') ires", "apply(rule_tac x = stp in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>ly = layout_of ap; inv_locate_a (as, lm) (n, l, r) ires;\n        lm' = abc_lm_s lm n (Suc (abc_lm_v lm n));\n        steps0 (Suc 0, l, r) tinc_b stp = (10, a, b);\n        inc_inv n (as, lm) (10, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> inv_stop (as, abc_lm_s lm n (Suc (abc_lm_v lm n)))\n                          (10, a, b) ires", "apply(simp add: inc_inv.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_even_4[simp]: \"(4::nat) * n mod 2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_even (4 * n)", "apply(arith)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_inc_pre:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and aexec: \"abc_step_l (as, lm) (Some (Inc n)) = (asa, lma)\"\n  shows \"\\<exists> stp k. steps (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n), 0) stp \n        = (2*n + 10, Bk # Bk # ires, <lma> @ Bk\\<up>k) \\<and> stp > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "have \"\\<exists> stp l' r'. steps (Suc 0, l, r) (findnth n, 0) stp = (Suc (2 * n), l', r')\n    \\<and> inv_locate_a (as, lm) (n, l', r') ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n       inv_locate_a (as, lm) (n, l', r') ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_step_l (as, lm) (Some (Inc n)) = (asa, lma)\n\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n       inv_locate_a (as, lm) (n, l', r') ires", "apply(rule_tac findnth_correct, simp_all add: crsp layout)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp l' r'.\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp l' r'.\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires", "obtain stp l' r' where a:\n    \"steps (Suc 0, l, r) (findnth n, 0) stp = (Suc (2 * n), l', r')\n    \\<and> inv_locate_a (as, lm) (n, l', r') ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp l' r'.\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. (\\<And>stp l' r'.\n        steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n        inv_locate_a (as, lm) (n, l', r') ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "moreover"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "have\n    \"\\<exists> stp la ra. steps (Suc 0, l', r') (tinc_b, 0) stp = (10, la, ra)\n                        \\<and> inv_stop (as, lma) (10, la, ra) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps0 (Suc 0, l', r') tinc_b stp = (10, la, ra) \\<and>\n       inv_stop (as, lma) (10, la, ra) ires", "using assms a"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_step_l (as, lm) (Some (Inc n)) = (asa, lma)\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps0 (Suc 0, l', r') tinc_b stp = (10, la, ra) \\<and>\n       inv_stop (as, lma) (10, la, ra) ires", "proof(rule_tac lm' = lma and n = n and lm = lm and ly = ly and ap = ap in tinc_correct,\n      simp, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_step_l (as, lm) (Some (Inc n)) = (asa, lma);\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires\\<rbrakk>\n    \\<Longrightarrow> lma = abc_lm_s lm n (Suc (abc_lm_v lm n))", "show \"lma = abc_lm_s lm n (Suc (abc_lm_v lm n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lma = abc_lm_s lm n (Suc (abc_lm_v lm n))", "using aexec"], ["proof (prove)\nusing this:\n  abc_step_l (as, lm) (Some (Inc n)) = (asa, lma)\n\ngoal (1 subgoal):\n 1. lma = abc_lm_s lm n (Suc (abc_lm_v lm n))", "apply(simp add: abc_step_l.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lma = abc_lm_s lm n (Suc (abc_lm_v lm n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp la ra.\n     steps0 (Suc 0, l', r') tinc_b stp = (10, la, ra) \\<and>\n     inv_stop (as, lma) (10, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp la ra.\n     steps0 (Suc 0, l', r') tinc_b stp = (10, la, ra) \\<and>\n     inv_stop (as, lma) (10, la, ra) ires", "obtain stpa la ra where b:\n    \"steps (Suc 0, l', r') (tinc_b, 0) stpa = (10, la, ra)\n    \\<and> inv_stop (as, lma) (10, la, ra) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp la ra.\n     steps0 (Suc 0, l', r') tinc_b stp = (10, la, ra) \\<and>\n     inv_stop (as, lma) (10, la, ra) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpa la ra.\n        steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n        inv_stop (as, lma) (10, la, ra) ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n  inv_stop (as, lma) (10, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "from a b"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n  steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n  inv_stop (as, lma) (10, la, ra) ires", "show \"\\<exists>stp k. steps (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n), 0) stp\n    = (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and> stp > 0\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n  steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n  inv_stop (as, lma) (10, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n       0 < stp", "apply(rule_tac x = \"stp + stpa\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, l, r) (findnth n) stp =\n             (Suc (2 * n), l', r') \\<and>\n             inv_locate_a (as, lm) (n, l', r') ires;\n     steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n     inv_stop (as, lma) (10, la, ra) ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         steps0 (Suc 0, l, r)\n                          (findnth n @ shift tinc_b (2 * n)) (stp + stpa) =\n                         (2 * n + 10, Bk # Bk # ires,\n                          <lma> @ Bk \\<up> k) \\<and>\n                         0 < stp + stpa", "using tm_append_steps[of \"Suc 0\" l r \"findnth n\" stp l' r' tinc_b stpa 10 la ra \"length (findnth n) div 2\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>steps0 (Suc 0, l, r) (findnth n) stp =\n           (Suc (length (findnth n) div 2), l', r');\n   steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra); 10 \\<noteq> 0;\n   length (findnth n) div 2 = length (findnth n) div 2;\n   is_even (length (findnth n))\\<rbrakk>\n  \\<Longrightarrow> steps0 (Suc 0, l, r)\n                     (findnth n @ shift tinc_b (length (findnth n) div 2))\n                     (stp + stpa) =\n                    (10 + length (findnth n) div 2, la, ra)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, l, r) (findnth n) stp =\n             (Suc (2 * n), l', r') \\<and>\n             inv_locate_a (as, lm) (n, l', r') ires;\n     steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n     inv_stop (as, lma) (10, la, ra) ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k.\n                         steps0 (Suc 0, l, r)\n                          (findnth n @ shift tinc_b (2 * n)) (stp + stpa) =\n                         (2 * n + 10, Bk # Bk # ires,\n                          <lma> @ Bk \\<up> k) \\<and>\n                         0 < stp + stpa", "apply(simp add: length_findnth inv_stop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, l, r) (findnth n) stp =\n             (Suc (2 * n), l', r') \\<and>\n             inv_locate_a (as, lm) (n, l', r') ires;\n     steps0 (Suc 0, l', r') tinc_b stpa = (10, la, ra) \\<and>\n     la = Bk # Bk # ires \\<and> (\\<exists>rn. ra = <lma> @ Bk \\<up> rn);\n     steps0 (steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp)\n      (findnth n @ shift tinc_b (2 * n)) stpa =\n     (10 + 2 * n, Bk # Bk # ires, ra)\\<rbrakk>\n    \\<Longrightarrow> 0 < stp \\<or> 0 < stpa", "apply(cases stpa, simp_all add: steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n     (2 * n + 10, Bk # Bk # ires, <lma> @ Bk \\<up> k) \\<and>\n     0 < stp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crsp_step_inc:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some (Inc n)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n  (steps (s, l, r) (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n        (steps (s, l, r)\n          (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n        ires", "proof(cases \"(abc_step_l (as, lm) (Some (Inc n)))\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       abc_step_l (as, lm) (Some (Inc n)) = (a, b) \\<Longrightarrow>\n       \\<exists>stp>0.\n          crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n           (steps (s, l, r)\n             (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n           ires", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       abc_step_l (as, lm) (Some (Inc n)) = (a, b) \\<Longrightarrow>\n       \\<exists>stp>0.\n          crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n           (steps (s, l, r)\n             (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n           ires", "assume aexec: \"abc_step_l (as, lm) (Some (Inc n)) = (a, b)\""], ["proof (state)\nthis:\n  abc_step_l (as, lm) (Some (Inc n)) = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       abc_step_l (as, lm) (Some (Inc n)) = (a, b) \\<Longrightarrow>\n       \\<exists>stp>0.\n          crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n           (steps (s, l, r)\n             (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n           ires", "then"], ["proof (chain)\npicking this:\n  abc_step_l (as, lm) (Some (Inc n)) = (a, b)", "have \"\\<exists> stp k. steps (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n), 0) stp \n        = (2*n + 10, Bk # Bk # ires, <b> @ Bk\\<up>k) \\<and> stp > 0\""], ["proof (prove)\nusing this:\n  abc_step_l (as, lm) (Some (Inc n)) = (a, b)\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n       0 < stp", "using assms"], ["proof (prove)\nusing this:\n  abc_step_l (as, lm) (Some (Inc n)) = (a, b)\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some (Inc n)\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n       (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n       0 < stp", "apply(rule_tac crsp_step_inc_pre, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n     (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n     0 < stp\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       abc_step_l (as, lm) (Some (Inc n)) = (a, b) \\<Longrightarrow>\n       \\<exists>stp>0.\n          crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n           (steps (s, l, r)\n             (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n           ires", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n     (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n     0 < stp\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n        (steps (s, l, r)\n          (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n        ires", "using assms aexec"], ["proof (prove)\nusing this:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n     (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n     0 < stp\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some (Inc n)\n  abc_step_l (as, lm) (Some (Inc n)) = (a, b)\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n        (steps (s, l, r)\n          (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n        ires", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b);\n        \\<exists>k.\n           steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n           (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n           0 < stp\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n                             (steps (s, l, r)\n                               (ci ly (start_of ly as) (Inc n),\n                                start_of ly as - Suc 0)\n                               stp)\n                             ires", "apply(erule_tac exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp k.\n       \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b);\n        steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n        (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k) \\<and>\n        0 < stp\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n                             (steps (s, l, r)\n                               (ci ly (start_of ly as) (Inc n),\n                                start_of ly as - Suc 0)\n                               stp)\n                             ires", "apply(erule_tac conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp k.\n       \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b);\n        steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n        (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k);\n        0 < stp\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n                             (steps (s, l, r)\n                               (ci ly (start_of ly as) (Inc n),\n                                start_of ly as - Suc 0)\n                               stp)\n                             ires", "apply(rename_tac stp k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp k.\n       \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b);\n        steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n        (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k);\n        0 < stp\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n                             (steps (s, l, r)\n                               (ci ly (start_of ly as) (Inc n),\n                                start_of ly as - Suc 0)\n                               stp)\n                             ires", "apply(rule_tac x = stp in exI, simp add: ci.simps tm_shift_eq_steps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp k.\n       \\<lbrakk>ly = layout_of ap;\n        crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b);\n        steps0 (Suc 0, l, r) (findnth n @ shift tinc_b (2 * n)) stp =\n        (2 * n + 10, Bk # Bk # ires, <b> @ Bk \\<up> k);\n        0 < stp\\<rbrakk>\n       \\<Longrightarrow> crsp (layout_of ap) (a, b)\n                          (steps (s, l, r)\n                            (shift (findnth n @ shift tinc_b (2 * n))\n                              (start_of (layout_of ap) as - Suc 0),\n                             start_of (layout_of ap) as - Suc 0)\n                            stp)\n                          ires", "apply(drule_tac off = \"(start_of (layout_of ap) as - Suc 0)\" in tm_shift_eq_steps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>stp k.\n       \\<lbrakk>ly = layout_of ap;\n        crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b); 0 < stp\\<rbrakk>\n       \\<Longrightarrow> 2 * n + 10 \\<noteq> 0\n 2. \\<And>stp k.\n       \\<lbrakk>ly = layout_of ap;\n        crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        abc_fetch as ap = Some (Inc n);\n        abc_step_l (as, lm) (Some (Inc n)) = (a, b); 0 < stp;\n        steps (Suc 0 + (start_of (layout_of ap) as - Suc 0), l, r)\n         (shift (findnth n @ shift tinc_b (2 * n))\n           (start_of (layout_of ap) as - Suc 0),\n          start_of (layout_of ap) as - Suc 0)\n         stp =\n        (2 * n + 10 + (start_of (layout_of ap) as - Suc 0), Bk # Bk # ires,\n         <b> @ Bk \\<up> k)\\<rbrakk>\n       \\<Longrightarrow> crsp (layout_of ap) (a, b)\n                          (steps (s, l, r)\n                            (shift (findnth n @ shift tinc_b (2 * n))\n                              (start_of (layout_of ap) as - Suc 0),\n                             start_of (layout_of ap) as - Suc 0)\n                            stp)\n                          ires", "apply(auto simp: crsp.simps abc_step_l.simps fetch start_of_Suc1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some (Inc n)))\n      (steps (s, l, r)\n        (ci ly (start_of ly as) (Inc n), start_of ly as - Suc 0) stp)\n      ires\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Crsp of Dec n e\\<close>"], ["", "type_synonym dec_inv_t = \"(nat * nat list) \\<Rightarrow> config \\<Rightarrow> cell list \\<Rightarrow>  bool\""], ["", "fun dec_first_on_right_moving :: \"nat \\<Rightarrow> dec_inv_t\"\n  where\n    \"dec_first_on_right_moving n (as, lm) (s, l, r) ires = \n               (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and> \n         ml + mr = Suc m \\<and> length lm1 = n \\<and> ml > 0 \\<and> m > 0 \\<and>\n             (if lm1 = [] then l = Oc\\<up>ml @ Bk # Bk # ires\n                          else  l = Oc\\<up>ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> \n    ((r = Oc\\<up>mr @ [Bk] @ <lm2> @ Bk\\<up>rn) \\<or> (r = Oc\\<up>mr \\<and> lm2 = [])))\""], ["", "fun dec_on_right_moving :: \"dec_inv_t\"\n  where\n    \"dec_on_right_moving (as, lm) (s, l, r) ires =  \n   (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and> \n                             ml + mr = Suc (Suc m) \\<and>\n   (if lm1 = [] then l = Oc\\<up>ml@ Bk # Bk # ires\n                else  l = Oc\\<up>ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> \n   ((r = Oc\\<up>mr @ [Bk] @ <lm2> @ Bk\\<up>rn) \\<or> (r = Oc\\<up>mr \\<and> lm2 = [])))\""], ["", "fun dec_after_clear :: \"dec_inv_t\"\n  where\n    \"dec_after_clear (as, lm) (s, l, r) ires = \n              (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and> \n                ml + mr = Suc m \\<and> ml = Suc m \\<and> r \\<noteq> [] \\<and> r \\<noteq> [] \\<and>\n               (if lm1 = [] then l = Oc\\<up>ml@ Bk # Bk # ires\n                            else l = Oc\\<up>ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> \n               (tl r = Bk # <lm2> @ Bk\\<up>rn \\<or> tl r = [] \\<and> lm2 = []))\""], ["", "fun dec_after_write :: \"dec_inv_t\"\n  where\n    \"dec_after_write (as, lm) (s, l, r) ires = \n         (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and> \n       ml + mr = Suc m \\<and> ml = Suc m \\<and> lm2 \\<noteq> [] \\<and>\n       (if lm1 = [] then l = Bk # Oc\\<up>ml @ Bk # Bk # ires\n                    else l = Bk # Oc\\<up>ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> \n       tl r = <lm2> @ Bk\\<up>rn)\""], ["", "fun dec_right_move :: \"dec_inv_t\"\n  where\n    \"dec_right_move (as, lm) (s, l, r) ires = \n        (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \n            \\<and> ml = Suc m \\<and> mr = (0::nat) \\<and> \n              (if lm1 = [] then l = Bk # Oc\\<up>ml @ Bk # Bk # ires\n                          else l = Bk # Oc\\<up>ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \n           \\<and> (r = Bk # <lm2> @ Bk\\<up>rn \\<or> r = [] \\<and> lm2 = []))\""], ["", "fun dec_check_right_move :: \"dec_inv_t\"\n  where\n    \"dec_check_right_move (as, lm) (s, l, r) ires = \n        (\\<exists> lm1 lm2 m ml mr rn. lm = lm1 @ [m] @ lm2 \\<and> \n           ml = Suc m \\<and> mr = (0::nat) \\<and> \n           (if lm1 = [] then l = Bk # Bk # Oc\\<up>ml @ Bk # Bk # ires\n                       else l = Bk # Bk # Oc\\<up>ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and> \n           r = <lm2> @ Bk\\<up>rn)\""], ["", "fun dec_left_move :: \"dec_inv_t\"\n  where\n    \"dec_left_move (as, lm) (s, l, r) ires = \n    (\\<exists> lm1 m rn. (lm::nat list) = lm1 @ [m::nat] \\<and>   \n    rn > 0 \\<and> \n   (if lm1 = [] then l = Bk # Oc\\<up>Suc m @ Bk # Bk # ires\n    else l = Bk # Oc\\<up>Suc m @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and> r = Bk\\<up>rn)\""], ["", "declare\n  dec_on_right_moving.simps[simp del] dec_after_clear.simps[simp del] \n  dec_after_write.simps[simp del] dec_left_move.simps[simp del] \n  dec_check_right_move.simps[simp del] dec_right_move.simps[simp del] \n  dec_first_on_right_moving.simps[simp del]"], ["", "fun inv_locate_n_b :: \"inc_inv_t\"\n  where\n    \"inv_locate_n_b (as, lm) (s, l, r) ires= \n    (\\<exists> lm1 lm2 tn m ml mr rn. lm @ 0\\<up>tn = lm1 @ [m] @ lm2 \\<and> \n     length lm1 = s \\<and> m + 1 = ml + mr \\<and> \n     ml = 1 \\<and> tn = s + 1 - length lm \\<and>\n     (if lm1 = [] then l = Oc\\<up>ml @ Bk # Bk # ires\n      else l = Oc\\<up>ml @ Bk # <rev lm1> @ Bk # Bk # ires) \\<and> \n     (r = Oc\\<up>mr @ [Bk] @ <lm2>@ Bk\\<up>rn \\<or> (lm2 = [] \\<and> r = Oc\\<up>mr))\n  )\""], ["", "fun dec_inv_1 :: \"layout \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> dec_inv_t\"\n  where\n    \"dec_inv_1 ly n e (as, am) (s, l, r) ires = \n           (let ss = start_of ly as in\n            let am' = abc_lm_s am n (abc_lm_v am n - Suc 0) in\n            let am'' = abc_lm_s am n (abc_lm_v am n) in\n              if s = start_of ly e then inv_stop (as, am'') (s, l, r) ires\n              else if s = ss then False\n              else if s = ss + 2 * n + 1 then \n                  inv_locate_b (as, am) (n, l, r) ires\n              else if s = ss + 2 * n + 13 then \n                  inv_on_left_moving (as, am'') (s, l, r) ires\n              else if s = ss + 2 * n + 14 then \n                  inv_check_left_moving (as, am'') (s, l, r) ires\n              else if s = ss + 2 * n + 15 then \n                  inv_after_left_moving (as, am'') (s, l, r) ires\n              else False)\""], ["", "declare fetch.simps[simp del]"], ["", "lemma x_plus_helpers:\n  \"x + 4 = Suc (x + 3)\"\n  \"x + 5 = Suc (x + 4)\"\n  \"x + 6 = Suc (x + 5)\"\n  \"x + 7 = Suc (x + 6)\"\n  \"x + 8 = Suc (x + 7)\"\n  \"x + 9 = Suc (x + 8)\"\n  \"x + 10 = Suc (x + 9)\"\n  \"x + 11 = Suc (x + 10)\"\n  \"x + 12 = Suc (x + 11)\"\n  \"x + 13 = Suc (x + 12)\"\n  \"14 + x = Suc (x + 13)\"\n  \"15 + x = Suc (x + 14)\"\n  \"16 + x = Suc (x + 15)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x + 4 = Suc (x + 3) &&&\n      x + 5 = Suc (x + 4) &&& x + 6 = Suc (x + 5)) &&&\n     x + 7 = Suc (x + 6) &&&\n     x + 8 = Suc (x + 7) &&& x + 9 = Suc (x + 8)) &&&\n    (x + 10 = Suc (x + 9) &&&\n     x + 11 = Suc (x + 10) &&& x + 12 = Suc (x + 11)) &&&\n    (x + 13 = Suc (x + 12) &&& 14 + x = Suc (x + 13)) &&&\n    15 + x = Suc (x + 14) &&& 16 + x = Suc (x + 15)", "by auto"], ["", "lemma fetch_Dec[simp]: \n  \"fetch (ci ly (start_of ly as) (Dec n e)) (Suc (2 * n)) Bk = (W1,  start_of ly as + 2 *n)\"\n  \"fetch (ci ly (start_of ly as) (Dec n e)) (Suc (2 * n)) Oc = (R,  Suc (start_of ly as) + 2 *n)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (2 * n))) Oc\n     = (R, start_of ly as + 2*n + 2)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (2 * n))) Bk\n     = (L, start_of ly as + 2*n + 13)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (Suc (2 * n)))) Oc\n     = (R, start_of ly as + 2*n + 2)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (Suc (Suc (Suc (2 * n)))) Bk\n     = (L, start_of ly as + 2*n + 3)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 4) Oc = (W0, start_of ly as + 2*n + 3)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 4) Bk = (R, start_of ly as + 2*n + 4)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 5) Bk = (R, start_of ly as + 2*n + 5)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 6) Bk = (L, start_of ly as + 2*n + 6)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 6) Oc = (L, start_of ly as + 2*n + 7)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 7) Bk = (L, start_of ly as + 2*n + 10)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 8) Bk = (W1, start_of ly as + 2*n + 7)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 8) Oc = (R, start_of ly as + 2*n + 8)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 9) Bk = (L, start_of ly as + 2*n + 9)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 9) Oc = (R, start_of ly as + 2*n + 8)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 10) Bk = (R, start_of ly as + 2*n + 4)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 10) Oc = (W0, start_of ly as + 2*n + 9)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 11) Oc = (L, start_of ly as + 2*n + 10)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 11) Bk = (L, start_of ly as + 2*n + 11)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 12) Oc = (L, start_of ly as + 2*n + 10)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 12) Bk = (R, start_of ly as + 2*n + 12)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (2 * n + 13) Bk = (R, start_of ly as + 2*n + 16)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (14 + 2 * n) Oc = (L, start_of ly as + 2*n + 13)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (14 + 2 * n) Bk = (L, start_of ly as + 2*n + 14)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (15 + 2 * n) Oc = (L, start_of ly as + 2*n + 13)\"\n  \"fetch (ci (ly) (start_of ly as) (Dec n e)) (15 + 2 * n) Bk = (R, start_of ly as + 2*n + 15)\"\n  \"fetch (ci (ly) (start_of (ly) as) (Dec n e)) (16 + 2 * n) Bk = (R, start_of (ly) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((fetch (ci ly (start_of ly as) (Dec n e)) (Suc (2 * n)) Bk =\n       (W1, start_of ly as + 2 * n) &&&\n       fetch (ci ly (start_of ly as) (Dec n e)) (Suc (2 * n)) Oc =\n       (R, Suc (start_of ly as) + 2 * n) &&&\n       fetch (ci ly (start_of ly as) (Dec n e)) (Suc (Suc (2 * n))) Oc =\n       (R, start_of ly as + 2 * n + 2)) &&&\n      (fetch (ci ly (start_of ly as) (Dec n e)) (Suc (Suc (2 * n))) Bk =\n       (L, start_of ly as + 2 * n + 13) &&&\n       fetch (ci ly (start_of ly as) (Dec n e)) (Suc (Suc (Suc (2 * n))))\n        Oc =\n       (R, start_of ly as + 2 * n + 2)) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (Suc (Suc (Suc (2 * n))))\n       Bk =\n      (L, start_of ly as + 2 * n + 3) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 4) Oc =\n      (W0, start_of ly as + 2 * n + 3)) &&&\n     (fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 4) Bk =\n      (R, start_of ly as + 2 * n + 4) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 5) Bk =\n      (R, start_of ly as + 2 * n + 5) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 6) Bk =\n      (L, start_of ly as + 2 * n + 6)) &&&\n     (fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 6) Oc =\n      (L, start_of ly as + 2 * n + 7) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 7) Bk =\n      (L, start_of ly as + 2 * n + 10)) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 8) Bk =\n     (W1, start_of ly as + 2 * n + 7) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 8) Oc =\n     (R, start_of ly as + 2 * n + 8)) &&&\n    ((fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 9) Bk =\n      (L, start_of ly as + 2 * n + 9) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 9) Oc =\n      (R, start_of ly as + 2 * n + 8) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 10) Bk =\n      (R, start_of ly as + 2 * n + 4)) &&&\n     (fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 10) Oc =\n      (W0, start_of ly as + 2 * n + 9) &&&\n      fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 11) Oc =\n      (L, start_of ly as + 2 * n + 10)) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 11) Bk =\n     (L, start_of ly as + 2 * n + 11) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 12) Oc =\n     (L, start_of ly as + 2 * n + 10)) &&&\n    (fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 12) Bk =\n     (R, start_of ly as + 2 * n + 12) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (2 * n + 13) Bk =\n     (R, start_of ly as + 2 * n + 16) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (14 + 2 * n) Oc =\n     (L, start_of ly as + 2 * n + 13)) &&&\n    (fetch (ci ly (start_of ly as) (Dec n e)) (14 + 2 * n) Bk =\n     (L, start_of ly as + 2 * n + 14) &&&\n     fetch (ci ly (start_of ly as) (Dec n e)) (15 + 2 * n) Oc =\n     (L, start_of ly as + 2 * n + 13)) &&&\n    fetch (ci ly (start_of ly as) (Dec n e)) (15 + 2 * n) Bk =\n    (R, start_of ly as + 2 * n + 15) &&&\n    fetch (ci ly (start_of ly as) (Dec n e)) (16 + 2 * n) Bk =\n    (R, start_of ly e)", "unfolding x_plus_helpers fetch.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((case nth_of (ci ly (start_of ly as) (Dec n e)) (2 * (2 * n)) of\n        None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n       (W1, start_of ly as + 2 * n) &&&\n       (case nth_of (ci ly (start_of ly as) (Dec n e)) (2 * (2 * n) + 1) of\n        None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n       (R, Suc (start_of ly as) + 2 * n) &&&\n       (case nth_of (ci ly (start_of ly as) (Dec n e))\n              (2 * Suc (2 * n) + 1) of\n        None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n       (R, start_of ly as + 2 * n + 2)) &&&\n      ((case nth_of (ci ly (start_of ly as) (Dec n e)) (2 * Suc (2 * n)) of\n        None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n       (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n    (Suc (Suc (Suc (start_of ly as + 2 * n + 3))))))))))) &&&\n       (case nth_of (ci ly (start_of ly as) (Dec n e))\n              (2 * Suc (Suc (2 * n)) + 1) of\n        None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n       (R, start_of ly as + 2 * n + 2)) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (2 * n))) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, start_of ly as + 2 * n + 3) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * (2 * n + 3) + 1) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (W0, start_of ly as + 2 * n + 3)) &&&\n     ((case nth_of (ci ly (start_of ly as) (Dec n e)) (2 * (2 * n + 3)) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (R, Suc (start_of ly as + 2 * n + 3)) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (2 * n + 3)) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (R, Suc (Suc (start_of ly as + 2 * n + 3))) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (2 * n + 3))) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, Suc (Suc (Suc (start_of ly as + 2 * n + 3))))) &&&\n     ((case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (2 * n + 3)) + 1) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, Suc (Suc (Suc (Suc (start_of ly as + 2 * n + 3))))) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (Suc (2 * n + 3)))) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n   (start_of ly as + 2 * n + 3))))))))) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 * Suc (Suc (Suc (Suc (2 * n + 3))))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (W1, Suc (Suc (Suc (Suc (start_of ly as + 2 * n + 3))))) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 * Suc (Suc (Suc (Suc (2 * n + 3)))) + 1) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc (Suc (start_of ly as + 2 * n + 3))))))) &&&\n    (((case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (Suc (Suc (Suc (2 * n + 3)))))) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, Suc (Suc (Suc (Suc (Suc (Suc (start_of ly as + 2 * n +\n  3))))))) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (Suc (Suc (Suc (2 * n + 3))))) + 1) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (R, Suc (Suc (Suc (Suc (Suc (start_of ly as + 2 * n + 3)))))) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (Suc (Suc (Suc (Suc (2 * n + 3))))))) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (R, Suc (start_of ly as + 2 * n + 3))) &&&\n     ((case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (Suc (Suc (Suc (Suc (2 * n + 3)))))) + 1) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (W0,\n       Suc (Suc (Suc (Suc (Suc (Suc (start_of ly as + 2 * n + 3))))))) &&&\n      (case nth_of (ci ly (start_of ly as) (Dec n e))\n             (2 * Suc (Suc (Suc (Suc (Suc (Suc (Suc (2 * n + 3))))))) +\n              1) of\n       None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n      (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n   (start_of ly as + 2 * n + 3))))))))) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 * Suc (Suc (Suc (Suc (Suc (Suc (Suc (2 * n + 3)))))))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n  (Suc (start_of ly as + 2 * n + 3))))))))) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 * Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc (2 * n + 3)))))))) +\n             1) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n  (start_of ly as + 2 * n + 3))))))))) &&&\n    ((case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 *\n             Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc (2 * n + 3))))))))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n  (Suc (Suc (start_of ly as + 2 * n + 3)))))))))) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 *\n             Suc (Suc (Suc (Suc (Suc (Suc\n (Suc (Suc (Suc (2 * n + 3)))))))))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (R, start_of ly as + 2 * n + 16) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 *\n             Suc (Suc (Suc (Suc (Suc (Suc\n (Suc (Suc (Suc (Suc (2 * n + 3)))))))))) +\n             1) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n  (Suc (Suc (Suc (start_of ly as + 2 * n + 3)))))))))))) &&&\n    ((case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 *\n             Suc (Suc (Suc (Suc (Suc (Suc\n (Suc (Suc (Suc (Suc (2 * n + 3))))))))))) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (L, start_of ly as + 2 * n + 14) &&&\n     (case nth_of (ci ly (start_of ly as) (Dec n e))\n            (2 * (2 * n + 14) + 1) of\n      None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n     (L, Suc (Suc (Suc (Suc (Suc (Suc (Suc\n  (Suc (Suc (Suc (start_of ly as + 2 * n + 3)))))))))))) &&&\n    (case nth_of (ci ly (start_of ly as) (Dec n e)) (2 * (2 * n + 14)) of\n     None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n    (R, start_of ly as + 2 * n + 15) &&&\n    (case nth_of (ci ly (start_of ly as) (Dec n e)) (2 * (2 * n + 15)) of\n     None \\<Rightarrow> (Nop, 0) | Some i \\<Rightarrow> i) =\n    (R, start_of ly e)", "by(auto simp: ci.simps shift.simps nth_append tdec_b_def length_findnth adjust.simps)"], ["", "lemma steps_start_of_invb_inv_locate_a1[simp]: \n  \"\\<lbrakk>r = [] \\<or> hd r = Bk; inv_locate_a (as, lm) (n, l, r) ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n  steps (start_of ly as + 2 * n, l, r) (ci ly (start_of ly as) (Dec n e), \n  start_of ly as - Suc 0) stp = (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = [] \\<or> hd r = Bk;\n     inv_locate_a (as, lm) (n, l, r) ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n                         steps (start_of ly as + 2 * n, l, r)\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0)\n                          stp =\n                         (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n                         inv_locate_b (as, lm) (n, la, ra) ires", "apply(rule_tac x = \"Suc (Suc 0)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = [] \\<or> hd r = Bk;\n     inv_locate_a (as, lm) (n, l, r) ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la ra.\n                         steps (start_of ly as + 2 * n, l, r)\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0)\n                          (Suc (Suc 0)) =\n                         (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n                         inv_locate_b (as, lm) (n, la, ra) ires", "apply(auto simp: steps.simps step.simps length_ci_dec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_a (as, lm) (n, l, r) ires; hd r = Bk;\n     r \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_locate_b (as, lm) (n, Oc # l, tl r) ires", "apply(cases r, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma steps_start_of_invb_inv_locate_a2[simp]: \n  \"\\<lbrakk>inv_locate_a (as, lm) (n, l, r) ires; r \\<noteq> [] \\<and> hd r \\<noteq> Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n  steps (start_of ly as + 2 * n, l, r) (ci ly (start_of ly as) (Dec n e), \n  start_of ly as - Suc 0) stp = (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_a (as, lm) (n, l, r) ires;\n     r \\<noteq> [] \\<and> hd r \\<noteq> Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n                         steps (start_of ly as + 2 * n, l, r)\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0)\n                          stp =\n                         (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n                         inv_locate_b (as, lm) (n, la, ra) ires", "apply(rule_tac x = \"(Suc 0)\" in exI, cases \"hd r\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_a (as, lm) (n, l, r) ires; r \\<noteq> [];\n     hd r = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>la ra.\n                         step\n                          (steps (start_of ly as + 2 * n, l, r)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0)\n                            0)\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0) =\n                         (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n                         inv_locate_b (as, lm) (n, la, ra) ires", "apply(auto simp: steps.simps step.simps length_ci_dec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_a (as, lm) (n, l, r) ires; r \\<noteq> [];\n     hd r = Oc\\<rbrakk>\n    \\<Longrightarrow> inv_locate_b (as, lm) (n, Oc # l, tl r) ires", "apply(cases r, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun abc_dec_1_stage1:: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_1_stage1 (s, l, r) ss n = \n       (if s > ss \\<and> s \\<le> ss + 2*n + 1 then 4\n        else if s = ss + 2 * n + 13 \\<or> s = ss + 2*n + 14 then 3\n        else if s = ss + 2*n + 15 then 2\n        else 0)\""], ["", "fun abc_dec_1_stage2:: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_1_stage2 (s, l, r) ss n = \n       (if s \\<le> ss + 2 * n + 1 then (ss + 2 * n + 16 - s)\n        else if s = ss + 2*n + 13 then length l\n        else if s = ss + 2*n + 14 then length l\n        else 0)\""], ["", "fun abc_dec_1_stage3 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_1_stage3 (s, l, r) ss n  = \n        (if s \\<le> ss + 2*n + 1 then \n             if (s - ss) mod 2 = 0 then \n                         if r \\<noteq> [] \\<and> hd r = Oc then 0 else 1  \n                         else length r\n         else if s = ss + 2 * n + 13 then \n             if r \\<noteq> [] \\<and> hd r = Oc then 2 \n             else 1\n         else if s = ss + 2 * n + 14 then \n             if r \\<noteq> [] \\<and> hd r = Oc then 3 else 0 \n         else 0)\""], ["", "fun abc_dec_1_measure :: \"(config \\<times> nat \\<times> nat) \\<Rightarrow> (nat \\<times> nat \\<times> nat)\"\n  where\n    \"abc_dec_1_measure (c, ss, n) = (abc_dec_1_stage1 c ss n, \n                   abc_dec_1_stage2 c ss n, abc_dec_1_stage3 c ss n)\""], ["", "definition abc_dec_1_LE ::\n  \"((config \\<times> nat \\<times>\n  nat) \\<times> (config \\<times> nat \\<times> nat)) set\"\n  where \"abc_dec_1_LE \\<equiv> (inv_image lex_triple abc_dec_1_measure)\""], ["", "lemma wf_dec_le: \"wf abc_dec_1_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf abc_dec_1_LE", "by(auto intro:wf_inv_image simp:abc_dec_1_LE_def lex_triple_def lex_pair_def)"], ["", "lemma startof_Suc2:\n  \"abc_fetch as ap = Some (Dec n e) \\<Longrightarrow> \n        start_of (layout_of ap) (Suc as) = \n            start_of (layout_of ap) as + 2 * n + 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_fetch as ap = Some (Dec n e) \\<Longrightarrow>\n    start_of (layout_of ap) (Suc as) =\n    start_of (layout_of ap) as + 2 * n + 16", "apply(auto simp: start_of.simps layout_of.simps  \n      length_of.simps abc_fetch.simps \n      take_Suc_conv_app_nth split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_less_2: \n  \"start_of ly e \\<le> start_of ly (Suc e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly (Suc e)", "apply(cases \"e < length ly\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. e < length ly \\<Longrightarrow> start_of ly e \\<le> start_of ly (Suc e)\n 2. \\<not> e < length ly \\<Longrightarrow>\n    start_of ly e \\<le> start_of ly (Suc e)", "apply(auto simp: start_of.simps take_Suc take_Suc_conv_app_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_less_1: \"start_of ly e \\<le> start_of ly (e + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly (e + d)", "proof(induct d)"], ["proof (state)\ngoal (2 subgoals):\n 1. start_of ly e \\<le> start_of ly (e + 0)\n 2. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. start_of ly e \\<le> start_of ly (e + 0)\n 2. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "thus \"?case\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly (e + 0)", "by simp"], ["proof (state)\nthis:\n  start_of ly e \\<le> start_of ly (e + 0)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "case (Suc d)"], ["proof (state)\nthis:\n  start_of ly e \\<le> start_of ly (e + d)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "have \"start_of ly e \\<le> start_of ly (e + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly (e + d)", "by fact"], ["proof (state)\nthis:\n  start_of ly e \\<le> start_of ly (e + d)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "moreover"], ["proof (state)\nthis:\n  start_of ly e \\<le> start_of ly (e + d)\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "have \"start_of ly (e + d) \\<le> start_of ly (Suc (e + d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly (e + d) \\<le> start_of ly (Suc (e + d))", "by(rule_tac start_of_less_2)"], ["proof (state)\nthis:\n  start_of ly (e + d) \\<le> start_of ly (Suc (e + d))\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       start_of ly e \\<le> start_of ly (e + d) \\<Longrightarrow>\n       start_of ly e \\<le> start_of ly (e + Suc d)", "ultimately"], ["proof (chain)\npicking this:\n  start_of ly e \\<le> start_of ly (e + d)\n  start_of ly (e + d) \\<le> start_of ly (Suc (e + d))", "show\"?case\""], ["proof (prove)\nusing this:\n  start_of ly e \\<le> start_of ly (e + d)\n  start_of ly (e + d) \\<le> start_of ly (Suc (e + d))\n\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly (e + Suc d)", "by(simp)"], ["proof (state)\nthis:\n  start_of ly e \\<le> start_of ly (e + Suc d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_of_less: \n  assumes \"e < as\"\n  shows \"start_of ly e \\<le> start_of ly as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly as", "obtain d where \" as = e + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d. as = e + d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  e < as\n\ngoal (1 subgoal):\n 1. (\\<And>d. as = e + d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis less_imp_add_positive)"], ["proof (state)\nthis:\n  as = e + d\n\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly as", "thus \"?thesis\""], ["proof (prove)\nusing this:\n  as = e + d\n\ngoal (1 subgoal):\n 1. start_of ly e \\<le> start_of ly as", "by(simp add: start_of_less_1)"], ["proof (state)\nthis:\n  start_of ly e \\<le> start_of ly as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma start_of_ge: \n  assumes fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and layout: \"ly = layout_of ap\"\n    and great: \"e > as\"\n  shows \"start_of ly e \\<ge> start_of ly as + 2*n + 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly as + 2 * n + 16 \\<le> start_of ly e", "proof(cases \"e = Suc as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e\n 2. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "case True"], ["proof (state)\nthis:\n  e = Suc as\n\ngoal (2 subgoals):\n 1. e = Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e\n 2. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "have \"e = Suc as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = Suc as", "by fact"], ["proof (state)\nthis:\n  e = Suc as\n\ngoal (2 subgoals):\n 1. e = Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e\n 2. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "moreover"], ["proof (state)\nthis:\n  e = Suc as\n\ngoal (2 subgoals):\n 1. e = Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e\n 2. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "hence \"start_of ly (Suc as) = start_of ly as + 2*n + 16\""], ["proof (prove)\nusing this:\n  e = Suc as\n\ngoal (1 subgoal):\n 1. start_of ly (Suc as) = start_of ly as + 2 * n + 16", "using layout fetch"], ["proof (prove)\nusing this:\n  e = Suc as\n  ly = layout_of ap\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. start_of ly (Suc as) = start_of ly as + 2 * n + 16", "by(simp add: startof_Suc2)"], ["proof (state)\nthis:\n  start_of ly (Suc as) = start_of ly as + 2 * n + 16\n\ngoal (2 subgoals):\n 1. e = Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e\n 2. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "ultimately"], ["proof (chain)\npicking this:\n  e = Suc as\n  start_of ly (Suc as) = start_of ly as + 2 * n + 16", "show \"?thesis\""], ["proof (prove)\nusing this:\n  e = Suc as\n  start_of ly (Suc as) = start_of ly as + 2 * n + 16\n\ngoal (1 subgoal):\n 1. start_of ly as + 2 * n + 16 \\<le> start_of ly e", "by (simp)"], ["proof (state)\nthis:\n  start_of ly as + 2 * n + 16 \\<le> start_of ly e\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "case False"], ["proof (state)\nthis:\n  e \\<noteq> Suc as\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "have \"e \\<noteq> Suc as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as", "by fact"], ["proof (state)\nthis:\n  e \\<noteq> Suc as\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "then"], ["proof (chain)\npicking this:\n  e \\<noteq> Suc as", "have \"e > Suc as\""], ["proof (prove)\nusing this:\n  e \\<noteq> Suc as\n\ngoal (1 subgoal):\n 1. Suc as < e", "using great"], ["proof (prove)\nusing this:\n  e \\<noteq> Suc as\n  as < e\n\ngoal (1 subgoal):\n 1. Suc as < e", "by arith"], ["proof (state)\nthis:\n  Suc as < e\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "then"], ["proof (chain)\npicking this:\n  Suc as < e", "have \"start_of ly (Suc as) \\<le> start_of ly e\""], ["proof (prove)\nusing this:\n  Suc as < e\n\ngoal (1 subgoal):\n 1. start_of ly (Suc as) \\<le> start_of ly e", "by(simp add: start_of_less)"], ["proof (state)\nthis:\n  start_of ly (Suc as) \\<le> start_of ly e\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "moreover"], ["proof (state)\nthis:\n  start_of ly (Suc as) \\<le> start_of ly e\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "have \"start_of ly (Suc as) = start_of ly as + 2*n + 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. start_of ly (Suc as) = start_of ly as + 2 * n + 16", "using layout fetch"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. start_of ly (Suc as) = start_of ly as + 2 * n + 16", "by(simp add: startof_Suc2)"], ["proof (state)\nthis:\n  start_of ly (Suc as) = start_of ly as + 2 * n + 16\n\ngoal (1 subgoal):\n 1. e \\<noteq> Suc as \\<Longrightarrow>\n    start_of ly as + 2 * n + 16 \\<le> start_of ly e", "ultimately"], ["proof (chain)\npicking this:\n  start_of ly (Suc as) \\<le> start_of ly e\n  start_of ly (Suc as) = start_of ly as + 2 * n + 16", "show \"?thesis\""], ["proof (prove)\nusing this:\n  start_of ly (Suc as) \\<le> start_of ly e\n  start_of ly (Suc as) = start_of ly as + 2 * n + 16\n\ngoal (1 subgoal):\n 1. start_of ly as + 2 * n + 16 \\<le> start_of ly e", "by arith"], ["proof (state)\nthis:\n  start_of ly as + 2 * n + 16 \\<le> start_of ly e\n\ngoal:\nNo subgoals!", "qed"], ["", "declare dec_inv_1.simps[simp del]"], ["", "lemma start_of_ineq1[simp]: \n  \"\\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog\\<rbrakk>\n   \\<Longrightarrow> (start_of ly e \\<noteq> Suc (start_of ly as + 2 * n) \\<and>\n        start_of ly e \\<noteq> Suc (Suc (start_of ly as + 2 * n)) \\<and>  \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 3 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 4 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 5 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 6 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 7 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 8 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 9 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 10 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 11 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 12 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 13 \\<and>\n        start_of ly e \\<noteq> start_of ly as + 2 * n + 14 \\<and> \n        start_of ly e \\<noteq> start_of ly as + 2 * n + 15)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as aprog = Some (Dec n e);\n     ly = layout_of aprog\\<rbrakk>\n    \\<Longrightarrow> start_of ly e \\<noteq>\n                      Suc (start_of ly as + 2 * n) \\<and>\n                      start_of ly e \\<noteq>\n                      Suc (Suc (start_of ly as + 2 * n)) \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 3 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 4 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 5 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 6 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 7 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 8 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 9 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 10 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 11 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 12 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 13 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 14 \\<and>\n                      start_of ly e \\<noteq> start_of ly as + 2 * n + 15", "using start_of_ge[of as aprog n e ly] start_of_less[of e as ly]"], ["proof (prove)\nusing this:\n  \\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog;\n   as < e\\<rbrakk>\n  \\<Longrightarrow> start_of ly as + 2 * n + 16 \\<le> start_of ly e\n  e < as \\<Longrightarrow> start_of ly e \\<le> start_of ly as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as aprog = Some (Dec n e);\n     ly = layout_of aprog\\<rbrakk>\n    \\<Longrightarrow> start_of ly e \\<noteq>\n                      Suc (start_of ly as + 2 * n) \\<and>\n                      start_of ly e \\<noteq>\n                      Suc (Suc (start_of ly as + 2 * n)) \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 3 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 4 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 5 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 6 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 7 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 8 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 9 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 10 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 11 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 12 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 13 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 14 \\<and>\n                      start_of ly e \\<noteq> start_of ly as + 2 * n + 15", "apply(cases \"e < as\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog;\n     \\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog;\n      as < e\\<rbrakk>\n     \\<Longrightarrow> start_of ly as + 2 * n + 16 \\<le> start_of ly e;\n     e < as \\<Longrightarrow> start_of ly e \\<le> start_of ly as;\n     \\<not> e < as\\<rbrakk>\n    \\<Longrightarrow> start_of ly e \\<noteq>\n                      Suc (start_of ly as + 2 * n) \\<and>\n                      start_of ly e \\<noteq>\n                      Suc (Suc (start_of ly as + 2 * n)) \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 3 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 4 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 5 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 6 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 7 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 8 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 9 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 10 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 11 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 12 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 13 \\<and>\n                      start_of ly e \\<noteq>\n                      start_of ly as + 2 * n + 14 \\<and>\n                      start_of ly e \\<noteq> start_of ly as + 2 * n + 15", "apply(cases \"e = as\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_ineq2[simp]: \"\\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog\\<rbrakk>\n      \\<Longrightarrow> (Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e \\<and>\n          Suc (Suc (start_of ly as + 2 * n)) \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 3 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 4 \\<noteq> start_of ly e \\<and>\n          start_of ly as + 2 * n + 5 \\<noteq>start_of ly e \\<and> \n          start_of ly as + 2 * n + 6 \\<noteq> start_of ly e \\<and>\n          start_of ly as + 2 * n + 7 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 8 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 9 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 10 \\<noteq> start_of ly e \\<and>\n          start_of ly as + 2 * n + 11 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 12 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 13 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 14 \\<noteq> start_of ly e \\<and> \n          start_of ly as + 2 * n + 15 \\<noteq> start_of ly e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as aprog = Some (Dec n e);\n     ly = layout_of aprog\\<rbrakk>\n    \\<Longrightarrow> Suc (start_of ly as + 2 * n) \\<noteq>\n                      start_of ly e \\<and>\n                      Suc (Suc (start_of ly as + 2 * n)) \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 3 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 4 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 5 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 6 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 7 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 8 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 9 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 10 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 11 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 12 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 13 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 14 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 15 \\<noteq> start_of ly e", "using start_of_ge[of as aprog n e ly] start_of_less[of e as ly]"], ["proof (prove)\nusing this:\n  \\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog;\n   as < e\\<rbrakk>\n  \\<Longrightarrow> start_of ly as + 2 * n + 16 \\<le> start_of ly e\n  e < as \\<Longrightarrow> start_of ly e \\<le> start_of ly as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as aprog = Some (Dec n e);\n     ly = layout_of aprog\\<rbrakk>\n    \\<Longrightarrow> Suc (start_of ly as + 2 * n) \\<noteq>\n                      start_of ly e \\<and>\n                      Suc (Suc (start_of ly as + 2 * n)) \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 3 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 4 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 5 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 6 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 7 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 8 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 9 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 10 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 11 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 12 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 13 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 14 \\<noteq>\n                      start_of ly e \\<and>\n                      start_of ly as + 2 * n + 15 \\<noteq> start_of ly e", "apply(cases \"e < as\", simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as aprog = Some (Dec n e); ly = layout_of aprog;\n     as < e \\<Longrightarrow>\n     start_of (layout_of aprog) as + 2 * n + 16\n     \\<le> start_of (layout_of aprog) e;\n     \\<not> e < as\\<rbrakk>\n    \\<Longrightarrow> Suc (start_of (layout_of aprog) as + 2 * n) \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      Suc (Suc (start_of (layout_of aprog) as +\n                                2 * n)) \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 3 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 4 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 5 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 6 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 7 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 8 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 9 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 10 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 11 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 12 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 13 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 14 \\<noteq>\n                      start_of (layout_of aprog) e \\<and>\n                      start_of (layout_of aprog) as + 2 * n + 15 \\<noteq>\n                      start_of (layout_of aprog) e", "apply(cases \"e = as\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_b_nonempty[simp]: \"inv_locate_b (as, lm) (n, [], []) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, lm) (n, [], []) ires = False", "apply(auto simp: inv_locate_b.simps in_middle.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_b_no_Bk[simp]: \"inv_locate_b (as, lm) (n, [], Bk # list) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_b (as, lm) (n, [], Bk # list) ires = False", "apply(auto simp: inv_locate_b.simps in_middle.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_first_on_right_moving_Oc[simp]: \n  \"\\<lbrakk>dec_first_on_right_moving n (as, am) (s, aaa, Oc # xs) ires\\<rbrakk>\n   \\<Longrightarrow> dec_first_on_right_moving n (as, am) (s', Oc # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_first_on_right_moving n (as, am) (s, aaa, Oc # xs)\n     ires \\<Longrightarrow>\n    dec_first_on_right_moving n (as, am) (s', Oc # aaa, xs) ires", "apply(simp only: dec_first_on_right_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n    \\<exists>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # aaa =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        xs = Oc \\<up> mr \\<and> lm2 = [])", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>lm1 lm2 m ml mr rn.\n          am = lm1 @ [m] @ lm2 \\<and>\n          ml + mr = Suc m \\<and>\n          length lm1 = n \\<and>\n          0 < ml \\<and>\n          0 < m \\<and>\n          (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # aaa =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           xs = Oc \\<up> mr \\<and> lm2 = [])", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>lm1 lm2 m ml mr rn.\n          am = lm1 @ [m] @ lm2 \\<and>\n          ml + mr = Suc m \\<and>\n          length lm1 = n \\<and>\n          0 < ml \\<and>\n          0 < m \\<and>\n          (if lm1 = [] then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # aaa =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           xs = Oc \\<up> mr \\<and> lm2 = [])", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI, \n      rule_tac x = m in exI, rule_tac x = \"Suc ml\" in exI, \n      rule_tac x = \"mr - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>rn.\n          am = lm1 @ [m] @ lm2 \\<and>\n          Suc ml + (mr - 1) = Suc m \\<and>\n          length lm1 = n \\<and>\n          0 < Suc ml \\<and>\n          0 < m \\<and>\n          (if lm1 = [] then Oc # aaa = Oc \\<up> Suc ml @ Bk # Bk # ires\n           else Oc # aaa =\n                Oc \\<up> Suc ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (xs = Oc \\<up> (mr - 1) @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           xs = Oc \\<up> (mr - 1) \\<and> lm2 = [])", "apply(case_tac [!] mr, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_first_on_right_moving_Bk_nonempty[simp]: \n  \"dec_first_on_right_moving n (as, am) (s, l, Bk # xs) ires \\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_first_on_right_moving n (as, am) (s, l, Bk # xs)\n     ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(auto simp: dec_first_on_right_moving.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma replicateE: \n  \"\\<lbrakk>\\<not> length lm1 < length am; \n    am @ replicate (length lm1 - length am) 0 @ [0::nat] = \n                                                lm1 @ m # lm2;\n    0 < m\\<rbrakk>\n   \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length lm1 < length am;\n     am @ 0 \\<up> (length lm1 - length am) @ [0] = lm1 @ m # lm2;\n     0 < m\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(subgoal_tac \"lm2 = []\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length lm1 < length am;\n     am @ 0 \\<up> (length lm1 - length am) @ [0] = lm1 @ m # lm2;\n     0 < m\\<rbrakk>\n    \\<Longrightarrow> lm2 = []", "apply(drule_tac length_equal, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_after_clear_Bk_strip_hd[simp]: \n  \"\\<lbrakk>dec_first_on_right_moving n (as, \n                   abc_lm_s am n (abc_lm_v am n)) (s, l, Bk # xs) ires\\<rbrakk>\n\\<Longrightarrow> dec_after_clear (as, abc_lm_s am n \n                 (abc_lm_v am n - Suc 0)) (s', tl l, hd l # Bk # xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, l, Bk # xs) ires \\<Longrightarrow>\n    dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n     (s', tl l, hd l # Bk # xs) ires", "apply(simp only: dec_first_on_right_moving.simps \n      dec_after_clear.simps abc_lm_s.simps abc_lm_v.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 m ml mr rn.\n       (if n < length am then am[n := if n < length am then am ! n else 0]\n        else am @\n             0 \\<up> (n - length am) @\n             [if n < length am then am ! n else 0]) =\n       lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Bk # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n    \\<exists>lm1 lm2 m ml mr rn.\n       (if n < length am\n        then am[n := (if n < length am then am ! n else 0) - Suc 0]\n        else am @\n             0 \\<up> (n - length am) @\n             [(if n < length am then am ! n else 0) - Suc 0]) =\n       lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       ml = Suc m \\<and>\n       hd l # Bk # xs \\<noteq> [] \\<and>\n       hd l # Bk # xs \\<noteq> [] \\<and>\n       (if lm1 = [] then tl l = Oc \\<up> ml @ Bk # Bk # ires\n        else tl l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (tl (hd l # Bk # xs) = Bk # <lm2> @ Bk \\<up> rn \\<or>\n        tl (hd l # Bk # xs) = [] \\<and> lm2 = [])", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       (if n < length am then am[n := if n < length am then am ! n else 0]\n        else am @\n             0 \\<up> (n - length am) @\n             [if n < length am then am ! n else 0]) =\n       lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Bk # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>lm1 lm2 m ml mr rn.\n          (if n < length am\n           then am[n := (if n < length am then am ! n else 0) - Suc 0]\n           else am @\n                0 \\<up> (n - length am) @\n                [(if n < length am then am ! n else 0) - Suc 0]) =\n          lm1 @ [m] @ lm2 \\<and>\n          ml + mr = Suc m \\<and>\n          ml = Suc m \\<and>\n          hd l # Bk # xs \\<noteq> [] \\<and>\n          hd l # Bk # xs \\<noteq> [] \\<and>\n          (if lm1 = [] then tl l = Oc \\<up> ml @ Bk # Bk # ires\n           else tl l =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (tl (hd l # Bk # xs) = Bk # <lm2> @ Bk \\<up> rn \\<or>\n           tl (hd l # Bk # xs) = [] \\<and> lm2 = [])", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       (if n < length am then am[n := if n < length am then am ! n else 0]\n        else am @\n             0 \\<up> (n - length am) @\n             [if n < length am then am ! n else 0]) =\n       lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       length lm1 = n \\<and>\n       0 < ml \\<and>\n       0 < m \\<and>\n       (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Bk # xs = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>lm1 lm2 m ml mr rn.\n          (if n < length am\n           then am[n := (if n < length am then am ! n else 0) - Suc 0]\n           else am @\n                0 \\<up> (n - length am) @\n                [(if n < length am then am ! n else 0) - Suc 0]) =\n          lm1 @ [m] @ lm2 \\<and>\n          ml + mr = Suc m \\<and>\n          ml = Suc m \\<and>\n          hd l # Bk # xs \\<noteq> [] \\<and>\n          hd l # Bk # xs \\<noteq> [] \\<and>\n          (if lm1 = [] then tl l = Oc \\<up> ml @ Bk # Bk # ires\n           else tl l =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (tl (hd l # Bk # xs) = Bk # <lm2> @ Bk \\<up> rn \\<or>\n           tl (hd l # Bk # xs) = [] \\<and> lm2 = [])", "apply(cases \"n < length am\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>(if n < length am\n                 then am[n := if n < length am then am ! n else 0]\n                 else am @\n                      0 \\<up> (n - length am) @\n                      [if n < length am then am ! n else 0]) =\n                lm1 @ [m] @ lm2 \\<and>\n                ml + mr = Suc m \\<and>\n                length lm1 = n \\<and>\n                0 < ml \\<and>\n                0 < m \\<and>\n                (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n                 else l =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 Bk # xs = Oc \\<up> mr \\<and> lm2 = []);\n        n < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            (if n < length am\n                             then am[n :=\n (if n < length am then am ! n else 0) - Suc 0]\n                             else am @\n                                  0 \\<up> (n - length am) @\n                                  [(if n < length am then am ! n else 0) -\n                                   Suc 0]) =\n                            lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            ml = Suc m \\<and>\n                            hd l # Bk # xs \\<noteq> [] \\<and>\n                            hd l # Bk # xs \\<noteq> [] \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (tl (hd l # Bk # xs) =\n                             Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             tl (hd l # Bk # xs) = [] \\<and> lm2 = [])\n 2. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>(if n < length am\n                 then am[n := if n < length am then am ! n else 0]\n                 else am @\n                      0 \\<up> (n - length am) @\n                      [if n < length am then am ! n else 0]) =\n                lm1 @ [m] @ lm2 \\<and>\n                ml + mr = Suc m \\<and>\n                length lm1 = n \\<and>\n                0 < ml \\<and>\n                0 < m \\<and>\n                (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n                 else l =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 Bk # xs = Oc \\<up> mr \\<and> lm2 = []);\n        \\<not> n < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            (if n < length am\n                             then am[n :=\n (if n < length am then am ! n else 0) - Suc 0]\n                             else am @\n                                  0 \\<up> (n - length am) @\n                                  [(if n < length am then am ! n else 0) -\n                                   Suc 0]) =\n                            lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            ml = Suc m \\<and>\n                            hd l # Bk # xs \\<noteq> [] \\<and>\n                            hd l # Bk # xs \\<noteq> [] \\<and>\n                            (if lm1 = []\n                             then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl l =\n                                  Oc \\<up> ml @\n                                  [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (tl (hd l # Bk # xs) =\n                             Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             tl (hd l # Bk # xs) = [] \\<and> lm2 = [])", "by(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI, \n      rule_tac x = \"m - 1\" in exI, auto elim:replicateE)"], ["", "lemma dec_first_on_right_moving_dec_after_clear_cases[simp]: \n  \"\\<lbrakk>dec_first_on_right_moving n (as, \n                   abc_lm_s am n (abc_lm_v am n)) (s, l, []) ires\\<rbrakk>\n\\<Longrightarrow> (l = [] \\<longrightarrow> dec_after_clear (as, \n             abc_lm_s am n (abc_lm_v am n - Suc 0)) (s', [], [Bk]) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow> dec_after_clear (as, abc_lm_s am n \n                      (abc_lm_v am n - Suc 0)) (s', tl l, [hd l]) ires)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, l, []) ires \\<Longrightarrow>\n    (l = [] \\<longrightarrow>\n     dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n      (s', [], [Bk]) ires) \\<and>\n    (l \\<noteq> [] \\<longrightarrow>\n     dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n      (s', tl l, [hd l]) ires)", "apply(subgoal_tac \"l \\<noteq> []\", \n      simp only: dec_first_on_right_moving.simps \n      dec_after_clear.simps abc_lm_s.simps abc_lm_v.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>lm1 lm2 m ml mr rn.\n                (if n < length am\n                 then am[n := if n < length am then am ! n else 0]\n                 else am @\n                      0 \\<up> (n - length am) @\n                      [if n < length am then am ! n else 0]) =\n                lm1 @ [m] @ lm2 \\<and>\n                ml + mr = Suc m \\<and>\n                length lm1 = n \\<and>\n                0 < ml \\<and>\n                0 < m \\<and>\n                (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n                 else l =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 [] = Oc \\<up> mr \\<and> lm2 = []);\n     l \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (False \\<longrightarrow>\n                       (\\<exists>lm1 lm2 m ml mr rn.\n                           (if n < length am\n                            then am[n :=\n(if n < length am then am ! n else 0) - Suc 0]\n                            else am @\n                                 0 \\<up> (n - length am) @\n                                 [(if n < length am then am ! n else 0) -\n                                  Suc 0]) =\n                           lm1 @ [m] @ lm2 \\<and>\n                           ml + mr = Suc m \\<and>\n                           ml = Suc m \\<and>\n                           [Bk] \\<noteq> [] \\<and>\n                           [Bk] \\<noteq> [] \\<and>\n                           (if lm1 = []\n                            then [] = Oc \\<up> ml @ Bk # Bk # ires\n                            else [] =\n                                 Oc \\<up> ml @\n                                 [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                           (tl [Bk] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                            tl [Bk] = [] \\<and> lm2 = []))) \\<and>\n                      (\\<not> False \\<longrightarrow>\n                       (\\<exists>lm1 lm2 m ml mr rn.\n                           (if n < length am\n                            then am[n :=\n(if n < length am then am ! n else 0) - Suc 0]\n                            else am @\n                                 0 \\<up> (n - length am) @\n                                 [(if n < length am then am ! n else 0) -\n                                  Suc 0]) =\n                           lm1 @ [m] @ lm2 \\<and>\n                           ml + mr = Suc m \\<and>\n                           ml = Suc m \\<and>\n                           [hd l] \\<noteq> [] \\<and>\n                           [hd l] \\<noteq> [] \\<and>\n                           (if lm1 = []\n                            then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                            else tl l =\n                                 Oc \\<up> ml @\n                                 [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                           (tl [hd l] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                            tl [hd l] = [] \\<and> lm2 = [])))\n 2. dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, l, []) ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>l \\<noteq> [];\n        (if n < length am then am[n := if n < length am then am ! n else 0]\n         else am @\n              0 \\<up> (n - length am) @\n              [if n < length am then am ! n else 0]) =\n        lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        length lm1 = n \\<and>\n        0 < ml \\<and>\n        0 < m \\<and>\n        (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n         else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         [] = Oc \\<up> mr \\<and> lm2 = [])\\<rbrakk>\n       \\<Longrightarrow> (False \\<longrightarrow>\n                          (\\<exists>lm1 lm2 m ml mr rn.\n                              (if n < length am\n                               then am[n :=\n   (if n < length am then am ! n else 0) - Suc 0]\n                               else am @\n                                    0 \\<up> (n - length am) @\n                                    [(if n < length am then am ! n else 0) -\n                                     Suc 0]) =\n                              lm1 @ [m] @ lm2 \\<and>\n                              ml + mr = Suc m \\<and>\n                              ml = Suc m \\<and>\n                              [Bk] \\<noteq> [] \\<and>\n                              [Bk] \\<noteq> [] \\<and>\n                              (if lm1 = []\n                               then [] = Oc \\<up> ml @ Bk # Bk # ires\n                               else [] =\n                                    Oc \\<up> ml @\n                                    [Bk] @\n                                    <rev lm1> @ Bk # Bk # ires) \\<and>\n                              (tl [Bk] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                               tl [Bk] = [] \\<and> lm2 = []))) \\<and>\n                         (\\<not> False \\<longrightarrow>\n                          (\\<exists>lm1 lm2 m ml mr rn.\n                              (if n < length am\n                               then am[n :=\n   (if n < length am then am ! n else 0) - Suc 0]\n                               else am @\n                                    0 \\<up> (n - length am) @\n                                    [(if n < length am then am ! n else 0) -\n                                     Suc 0]) =\n                              lm1 @ [m] @ lm2 \\<and>\n                              ml + mr = Suc m \\<and>\n                              ml = Suc m \\<and>\n                              [hd l] \\<noteq> [] \\<and>\n                              [hd l] \\<noteq> [] \\<and>\n                              (if lm1 = []\n                               then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                               else tl l =\n                                    Oc \\<up> ml @\n                                    [Bk] @\n                                    <rev lm1> @ Bk # Bk # ires) \\<and>\n                              (tl [hd l] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                               tl [hd l] = [] \\<and> lm2 = [])))\n 2. dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, l, []) ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>l \\<noteq> [];\n        (if n < length am then am[n := if n < length am then am ! n else 0]\n         else am @\n              0 \\<up> (n - length am) @\n              [if n < length am then am ! n else 0]) =\n        lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        length lm1 = n \\<and>\n        0 < ml \\<and>\n        0 < m \\<and>\n        (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n         else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         [] = Oc \\<up> mr \\<and> lm2 = [])\\<rbrakk>\n       \\<Longrightarrow> (False \\<longrightarrow>\n                          (\\<exists>lm1 lm2 m ml mr rn.\n                              (if n < length am\n                               then am[n :=\n   (if n < length am then am ! n else 0) - Suc 0]\n                               else am @\n                                    0 \\<up> (n - length am) @\n                                    [(if n < length am then am ! n else 0) -\n                                     Suc 0]) =\n                              lm1 @ [m] @ lm2 \\<and>\n                              ml + mr = Suc m \\<and>\n                              ml = Suc m \\<and>\n                              [Bk] \\<noteq> [] \\<and>\n                              [Bk] \\<noteq> [] \\<and>\n                              (if lm1 = []\n                               then [] = Oc \\<up> ml @ Bk # Bk # ires\n                               else [] =\n                                    Oc \\<up> ml @\n                                    [Bk] @\n                                    <rev lm1> @ Bk # Bk # ires) \\<and>\n                              (tl [Bk] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                               tl [Bk] = [] \\<and> lm2 = []))) \\<and>\n                         (\\<not> False \\<longrightarrow>\n                          (\\<exists>lm1 lm2 m ml mr rn.\n                              (if n < length am\n                               then am[n :=\n   (if n < length am then am ! n else 0) - Suc 0]\n                               else am @\n                                    0 \\<up> (n - length am) @\n                                    [(if n < length am then am ! n else 0) -\n                                     Suc 0]) =\n                              lm1 @ [m] @ lm2 \\<and>\n                              ml + mr = Suc m \\<and>\n                              ml = Suc m \\<and>\n                              [hd l] \\<noteq> [] \\<and>\n                              [hd l] \\<noteq> [] \\<and>\n                              (if lm1 = []\n                               then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                               else tl l =\n                                    Oc \\<up> ml @\n                                    [Bk] @\n                                    <rev lm1> @ Bk # Bk # ires) \\<and>\n                              (tl [hd l] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                               tl [hd l] = [] \\<and> lm2 = [])))\n 2. dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, l, []) ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(cases \"n < length am\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 m.\n       \\<lbrakk>l \\<noteq> [];\n        am = lm1 @ [m] \\<and>\n        length lm1 = n \\<and>\n        0 < m \\<and>\n        (if lm1 = [] then l = Oc \\<up> Suc m @ Bk # Bk # ires\n         else l =\n              Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             (lm1 @ [m])[n := (lm1 @ [m]) ! n - Suc 0] =\n                             [ma] \\<and>\n                             tl l =\n                             Oc # Oc \\<up> ma @ Bk # Bk # ires) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             (lm1 @ [m])[n := (lm1 @ [m]) ! n - Suc 0] =\n                             lm1a @ [ma] \\<and>\n                             tl l =\n                             Oc #\n                             Oc \\<up> ma @ Bk # <rev lm1a> @ Bk # Bk # ires)\n 2. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>l \\<noteq> [];\n        (if n < length am then am[n := if n < length am then am ! n else 0]\n         else am @\n              0 \\<up> (n - length am) @\n              [if n < length am then am ! n else 0]) =\n        lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc m \\<and>\n        length lm1 = n \\<and>\n        0 < ml \\<and>\n        0 < m \\<and>\n        (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n         else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         [] = Oc \\<up> mr \\<and> lm2 = []);\n        \\<not> n < length am\\<rbrakk>\n       \\<Longrightarrow> (False \\<longrightarrow>\n                          (\\<exists>lm1 lm2 m ml mr rn.\n                              (if n < length am\n                               then am[n :=\n   (if n < length am then am ! n else 0) - Suc 0]\n                               else am @\n                                    0 \\<up> (n - length am) @\n                                    [(if n < length am then am ! n else 0) -\n                                     Suc 0]) =\n                              lm1 @ [m] @ lm2 \\<and>\n                              ml + mr = Suc m \\<and>\n                              ml = Suc m \\<and>\n                              [Bk] \\<noteq> [] \\<and>\n                              [Bk] \\<noteq> [] \\<and>\n                              (if lm1 = []\n                               then [] = Oc \\<up> ml @ Bk # Bk # ires\n                               else [] =\n                                    Oc \\<up> ml @\n                                    [Bk] @\n                                    <rev lm1> @ Bk # Bk # ires) \\<and>\n                              (tl [Bk] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                               tl [Bk] = [] \\<and> lm2 = []))) \\<and>\n                         (\\<not> False \\<longrightarrow>\n                          (\\<exists>lm1 lm2 m ml mr rn.\n                              (if n < length am\n                               then am[n :=\n   (if n < length am then am ! n else 0) - Suc 0]\n                               else am @\n                                    0 \\<up> (n - length am) @\n                                    [(if n < length am then am ! n else 0) -\n                                     Suc 0]) =\n                              lm1 @ [m] @ lm2 \\<and>\n                              ml + mr = Suc m \\<and>\n                              ml = Suc m \\<and>\n                              [hd l] \\<noteq> [] \\<and>\n                              [hd l] \\<noteq> [] \\<and>\n                              (if lm1 = []\n                               then tl l = Oc \\<up> ml @ Bk # Bk # ires\n                               else tl l =\n                                    Oc \\<up> ml @\n                                    [Bk] @\n                                    <rev lm1> @ Bk # Bk # ires) \\<and>\n                              (tl [hd l] = Bk # <lm2> @ Bk \\<up> rn \\<or>\n                               tl [hd l] = [] \\<and> lm2 = [])))\n 3. dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, l, []) ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(rule_tac x = lm1 in exI, rule_tac x = \"m - 1\" in exI, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>am = [m]; n = 0; 0 < m;\n        l = Oc # Oc \\<up> m @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> m = Oc # Oc \\<up> (m - Suc 0)\n 2. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1; 0 < m;\n        l = Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        lm1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> Oc \\<up> m = Oc # Oc \\<up> (m - Suc 0)\n 3. \\<lbrakk>dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n              (s, [], []) ires;\n     l = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply(case_tac [1-2] m, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n              (s, [], []) ires;\n     l = []\\<rbrakk>\n    \\<Longrightarrow> False", "apply(auto simp: dec_first_on_right_moving.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_after_clear_Bk_via_Oc[simp]: \"\\<lbrakk>dec_after_clear (as, am) (s, l, Oc # r) ires\\<rbrakk>\n                \\<Longrightarrow> dec_after_clear (as, am) (s', l, Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_clear (as, am) (s, l, Oc # r) ires \\<Longrightarrow>\n    dec_after_clear (as, am) (s', l, Bk # r) ires", "apply(auto simp: dec_after_clear.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_right_move_Bk_via_clear_Bk[simp]: \"\\<lbrakk>dec_after_clear (as, am) (s, l, Bk # r) ires\\<rbrakk>\n                \\<Longrightarrow> dec_right_move (as, am) (s', Bk # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_clear (as, am) (s, l, Bk # r) ires \\<Longrightarrow>\n    dec_right_move (as, am) (s', Bk # l, r) ires", "apply(auto simp: dec_after_clear.simps dec_right_move.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_right_move_Bk_Bk_via_clear[simp]: \"\\<lbrakk>dec_after_clear (as, am) (s, l, []) ires\\<rbrakk>\n             \\<Longrightarrow> dec_right_move (as, am) (s', Bk # l, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_clear (as, am) (s, l, []) ires \\<Longrightarrow>\n    dec_right_move (as, am) (s', Bk # l, [Bk]) ires", "apply(auto simp: dec_after_clear.simps dec_right_move.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_right_move_no_Oc[simp]:\"dec_right_move (as, am) (s, l, Oc # r) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_right_move (as, am) (s, l, Oc # r) ires = False", "apply(auto simp: dec_right_move.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_right_move_2_check_right_move[simp]:\n  \"\\<lbrakk>dec_right_move (as, am) (s, l, Bk # r) ires\\<rbrakk>\n      \\<Longrightarrow> dec_check_right_move (as, am) (s', Bk # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_right_move (as, am) (s, l, Bk # r) ires \\<Longrightarrow>\n    dec_check_right_move (as, am) (s', Bk # l, r) ires", "apply(auto simp: dec_right_move.simps dec_check_right_move.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lm_iff_empty[simp]: \"(<lm::nat list> = []) = (lm = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<lm> = []) = (lm = [])", "apply(cases lm, simp_all add: tape_of_nl_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_right_move_asif_Bk_singleton[simp]: \n  \"dec_right_move (as, am) (s, l, []) ires= \n  dec_right_move (as, am) (s, l, [Bk]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_right_move (as, am) (s, l, []) ires =\n    dec_right_move (as, am) (s, l, [Bk]) ires", "apply(simp add: dec_right_move.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_check_right_move_nonempty[simp]: \"dec_check_right_move (as, am) (s, l, r) ires\\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_check_right_move (as, am) (s, l, r) ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(auto simp: dec_check_right_move.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_check_right_move_Oc_tail[simp]: \"\\<lbrakk>dec_check_right_move (as, am) (s, l, Oc # r) ires\\<rbrakk>\n             \\<Longrightarrow> dec_after_write (as, am) (s', tl l, hd l # Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_check_right_move (as, am) (s, l, Oc # r) ires \\<Longrightarrow>\n    dec_after_write (as, am) (s', tl l, hd l # Oc # r) ires", "apply(auto simp: dec_check_right_move.simps dec_after_write.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2;\n        if lm1 = [] then l = Bk # Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l =\n             Bk # Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 @ m # lm2 = ma # lm2a \\<and>\n                             lm2a \\<noteq> [] \\<and>\n                             tl l =\n                             Bk # Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                             (\\<exists>rna.\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                             lm2a \\<noteq> [] \\<and>\n                             tl l =\n                             Bk #\n                             Oc #\n                             Oc \\<up> ma @\n                             Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                             (\\<exists>rna.\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna))", "apply(rename_tac lm1 lm2 m rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2;\n        if lm1 = [] then l = Bk # Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l =\n             Bk # Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 @ m # lm2 = ma # lm2a \\<and>\n                             lm2a \\<noteq> [] \\<and>\n                             tl l =\n                             Bk # Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                             (\\<exists>rna.\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                             lm2a \\<noteq> [] \\<and>\n                             tl l =\n                             Bk #\n                             Oc #\n                             Oc \\<up> ma @\n                             Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                             (\\<exists>rna.\n                                 <lm2> @ Bk \\<up> rn =\n                                 <lm2a> @ Bk \\<up> rna))", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI, rule_tac x = m in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_left_move_Bk_tail[simp]: \"\\<lbrakk>dec_check_right_move (as, am) (s, l, Bk # r) ires\\<rbrakk>\n                \\<Longrightarrow> dec_left_move (as, am) (s', tl l, hd l # Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_check_right_move (as, am) (s, l, Bk # r) ires \\<Longrightarrow>\n    dec_left_move (as, am) (s', tl l, hd l # Bk # r) ires", "apply(auto simp: dec_check_right_move.simps dec_left_move.simps inv_after_move.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2;\n        if lm1 = [] then l = Bk # Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l =\n             Bk # Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 @ m # lm2 = [ma] \\<and>\n                             (\\<exists>rna>0.\n                                 tl l =\n                                 Bk #\n                                 Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                                 hd l # <lm2> @ Bk \\<up> rn =\n                                 Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 @ m # lm2 = lm1a @ [ma] \\<and>\n                             (\\<exists>rna>0.\n                                 tl l =\n                                 Bk #\n                                 Oc #\n                                 Oc \\<up> ma @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 hd l # <lm2> @ Bk \\<up> rn = Bk \\<up> rna))", "apply(rename_tac lm1 lm2 m rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2;\n        if lm1 = [] then l = Bk # Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l =\n             Bk # Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 @ m # lm2 = [ma] \\<and>\n                             (\\<exists>rna>0.\n                                 tl l =\n                                 Bk #\n                                 Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                                 hd l # <lm2> @ Bk \\<up> rn =\n                                 Bk \\<up> rna)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 @ m # lm2 = lm1a @ [ma] \\<and>\n                             (\\<exists>rna>0.\n                                 tl l =\n                                 Bk #\n                                 Oc #\n                                 Oc \\<up> ma @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 hd l # <lm2> @ Bk \\<up> rn = Bk \\<up> rna))", "apply(rule_tac x = lm1 in exI, rule_tac x = m in exI, auto split: if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>lm2 m rn.\n       \\<lbrakk>Bk # r = <lm2> @ Bk \\<up> rn; am = m # lm2;\n        l = Bk # Bk # Oc # Oc \\<up> m @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 2. \\<And>lm2 m rn.\n       \\<lbrakk>Bk # r = <lm2> @ Bk \\<up> rn; am = m # lm2;\n        l = Bk # Bk # Oc # Oc \\<up> m @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna>0.\n                            Bk # <lm2> @ Bk \\<up> rn = Bk \\<up> rna\n 3. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>Bk # r = <lm2> @ Bk \\<up> rn; am = lm1 @ m # lm2;\n        lm1 \\<noteq> [];\n        l =\n        Bk # Bk # Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 4. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>Bk # r = <lm2> @ Bk \\<up> rn; am = lm1 @ m # lm2;\n        lm1 \\<noteq> [];\n        l =\n        Bk # Bk # Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna>0.\n                            Bk # <lm2> @ Bk \\<up> rn = Bk \\<up> rna", "apply(case_tac [!] lm2, simp_all add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm2 m rn.\n       \\<lbrakk>Bk # r = Bk \\<up> rn; am = [m];\n        l = Bk # Bk # Oc # Oc \\<up> m @ Bk # Bk # ires; lm2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna>0. Bk # Bk \\<up> rn = Bk \\<up> rna\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>Bk # r = Bk \\<up> rn; am = lm1 @ [m]; lm1 \\<noteq> [];\n        l = Bk # Bk # Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires;\n        lm2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rna>0. Bk # Bk \\<up> rn = Bk \\<up> rna", "apply(rule_tac [!] x = \"(Suc rn)\" in exI, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_left_move_tail[simp]: \"\\<lbrakk>dec_check_right_move (as, am) (s, l, []) ires\\<rbrakk>\n             \\<Longrightarrow> dec_left_move (as, am) (s', tl l, [hd l]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_check_right_move (as, am) (s, l, []) ires \\<Longrightarrow>\n    dec_left_move (as, am) (s', tl l, [hd l]) ires", "apply(auto simp: dec_check_right_move.simps dec_left_move.simps inv_after_move.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m.\n       \\<lbrakk>if lm1 = []\n                then l = Bk # Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n                else l =\n                     Bk #\n                     Bk #\n                     Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        am = lm1 @ [m]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 = [] \\<and>\n                             m = ma \\<and>\n                             (\\<exists>rn>0.\n                                 tl l =\n                                 Bk #\n                                 Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                                 [hd l] = Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 = lm1a \\<and>\n                             m = ma \\<and>\n                             (\\<exists>rn>0.\n                                 tl l =\n                                 Bk #\n                                 Oc #\n                                 Oc \\<up> ma @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 [hd l] = Bk \\<up> rn))", "apply(rename_tac lm1 m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m.\n       \\<lbrakk>if lm1 = []\n                then l = Bk # Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n                else l =\n                     Bk #\n                     Bk #\n                     Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        am = lm1 @ [m]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 = [] \\<and>\n                             m = ma \\<and>\n                             (\\<exists>rn>0.\n                                 tl l =\n                                 Bk #\n                                 Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                                 [hd l] = Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 = lm1a \\<and>\n                             m = ma \\<and>\n                             (\\<exists>rn>0.\n                                 tl l =\n                                 Bk #\n                                 Oc #\n                                 Oc \\<up> ma @\n                                 Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                 [hd l] = Bk \\<up> rn))", "apply(rule_tac x = lm1 in exI, rule_tac x = m in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_left_move_no_Oc[simp]: \"dec_left_move (as, am) (s, aaa, Oc # xs) ires = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_left_move (as, am) (s, aaa, Oc # xs) ires = False", "apply(auto simp: dec_left_move.simps inv_after_move.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_left_move_nonempty[simp]: \"dec_left_move (as, am) (s, l, r) ires\n             \\<Longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_left_move (as, am) (s, l, r) ires \\<Longrightarrow> l \\<noteq> []", "apply(auto simp: dec_left_move.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_in_middle_B_Oc_Bk_Bks[simp]: \"inv_on_left_moving_in_middle_B (as, [m])\n  (s', Oc # Oc\\<up>m @ Bk # Bk # ires, Bk # Bk\\<up>rn) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving_in_middle_B (as, [m])\n     (s', Oc # Oc \\<up> m @ Bk # Bk # ires, Bk # Bk \\<up> rn) ires", "apply(simp add: inv_on_left_moving_in_middle_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1.\n       lm1 \\<noteq> [] \\<and>\n       (lm1 \\<noteq> [] \\<longrightarrow>\n        (\\<exists>lm2.\n            [m] = lm1 @ lm2 \\<and>\n            Oc # Oc \\<up> m = <rev lm1> \\<and>\n            (\\<exists>rna. Bk \\<up> rn = <lm2> @ Bk \\<up> rna)))", "apply(rule_tac x = \"[m]\" in exI, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_in_middle_B_Oc_Bk_Bks_rev[simp]: \"lm1 \\<noteq> [] \\<Longrightarrow> \n  inv_on_left_moving_in_middle_B (as, lm1 @ [m]) (s', \n  Oc # Oc\\<up>m @ Bk # <rev lm1> @ Bk # Bk # ires, Bk # Bk\\<up>rn) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lm1 \\<noteq> [] \\<Longrightarrow>\n    inv_on_left_moving_in_middle_B (as, lm1 @ [m])\n     (s', Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires,\n      Bk # Bk \\<up> rn)\n     ires", "apply(simp only: inv_on_left_moving_in_middle_B.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lm1 \\<noteq> [] \\<Longrightarrow>\n    \\<exists>lm1a lm2 rna.\n       lm1 @ [m] = lm1a @ lm2 \\<and>\n       (if lm1a = []\n        then Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires = Bk # ires\n        else Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires =\n             <rev lm1a> @ Bk # Bk # ires) \\<and>\n       Bk # Bk \\<up> rn = Bk # <lm2> @ Bk \\<up> rna", "apply(rule_tac x = \"lm1 @ [m ]\" in exI, rule_tac x = \"[]\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lm1 \\<noteq> [] \\<Longrightarrow>\n    Oc # Oc \\<up> m @ Bk # <rev lm1> = <m # rev lm1>", "apply(simp add: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_Bk_tail[simp]: \"dec_left_move (as, am) (s, l, Bk # r) ires\n       \\<Longrightarrow> inv_on_left_moving (as, am) (s', tl l, hd l # Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_left_move (as, am) (s, l, Bk # r) ires \\<Longrightarrow>\n    inv_on_left_moving (as, am) (s', tl l, hd l # Bk # r) ires", "apply(auto simp: dec_left_move.simps inv_on_left_moving.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_tail[simp]: \"dec_left_move (as, am) (s, l, []) ires\n             \\<Longrightarrow> inv_on_left_moving (as, am) (s', tl l, [hd l]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_left_move (as, am) (s, l, []) ires \\<Longrightarrow>\n    inv_on_left_moving (as, am) (s', tl l, [hd l]) ires", "apply(auto simp: dec_left_move.simps inv_on_left_moving.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_on_right_moving_Oc_mv[simp]: \"dec_after_write (as, am) (s, l, Oc # r) ires\n       \\<Longrightarrow> dec_on_right_moving (as, am) (s', Oc # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_write (as, am) (s, l, Oc # r) ires \\<Longrightarrow>\n    dec_on_right_moving (as, am) (s', Oc # l, r) ires", "apply(auto simp: dec_after_write.simps dec_on_right_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2; lm2 \\<noteq> [];\n        if lm1 = [] then l = Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc (Suc ma) \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    <lm2> @ Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\n<lm2> @ Bk \\<up> rn = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc (Suc ma) \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    <lm2> @ Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\n<lm2> @ Bk \\<up> rn = Oc \\<up> mr \\<and> lm2a = []))))", "apply(rename_tac lm1 lm2 m rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2; lm2 \\<noteq> [];\n        if lm1 = [] then l = Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc (Suc ma) \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    <lm2> @ Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\n<lm2> @ Bk \\<up> rn = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc (Suc ma) \\<and>\n                                     Oc # l =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rna.\n    <lm2> @ Bk \\<up> rn = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rna) \\<or>\n<lm2> @ Bk \\<up> rn = Oc \\<up> mr \\<and> lm2a = []))))", "apply(rule_tac x = \"lm1 @ [m]\" in exI, rule_tac x = \"tl lm2\" in exI, \n      rule_tac x = \"hd lm2\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2; lm2 \\<noteq> [];\n        if lm1 = [] then l = Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr.\n                            ml + mr = Suc (Suc (hd lm2)) \\<and>\n                            Oc # l =\n                            Oc \\<up> ml @\n                            Bk # <m # rev lm1> @ Bk # Bk # ires \\<and>\n                            ((\\<exists>rna.\n                                 <lm2> @ Bk \\<up> rn =\n                                 Oc \\<up> mr @\n                                 Bk # <tl lm2> @ Bk \\<up> rna) \\<or>\n                             <lm2> @ Bk \\<up> rn = Oc \\<up> mr \\<and>\n                             tl lm2 = [])", "apply(rule_tac x = \"Suc 0\" in exI,rule_tac x =  \"Suc (hd lm2)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2; lm2 \\<noteq> [];\n        if lm1 = [] then l = Bk # Oc \\<up> Suc m @ Bk # Bk # ires\n        else l = Bk # Oc \\<up> Suc m @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc 0 + Suc (hd lm2) = Suc (Suc (hd lm2)) \\<and>\n                         Oc # l =\n                         Oc \\<up> Suc 0 @\n                         Bk # <m # rev lm1> @ Bk # Bk # ires \\<and>\n                         ((\\<exists>rna.\n                              <lm2> @ Bk \\<up> rn =\n                              Oc \\<up> Suc (hd lm2) @\n                              Bk # <tl lm2> @ Bk \\<up> rna) \\<or>\n                          <lm2> @ Bk \\<up> rn = Oc \\<up> Suc (hd lm2) \\<and>\n                          tl lm2 = [])", "apply(case_tac lm2, auto split: if_splits simp: tape_of_nl_cons)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_after_write_Oc_via_Bk[simp]: \"dec_after_write (as, am) (s, l, Bk # r) ires\n       \\<Longrightarrow> dec_after_write (as, am) (s', l, Oc # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_write (as, am) (s, l, Bk # r) ires \\<Longrightarrow>\n    dec_after_write (as, am) (s', l, Oc # r) ires", "apply(auto simp: dec_after_write.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_after_write_Oc_empty[simp]: \"dec_after_write (as, am) (s, aaa, []) ires\n             \\<Longrightarrow> dec_after_write (as, am) (s', aaa, [Oc]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_write (as, am) (s, aaa, []) ires \\<Longrightarrow>\n    dec_after_write (as, am) (s', aaa, [Oc]) ires", "apply(auto simp: dec_after_write.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_on_right_moving_Oc_move[simp]: \"dec_on_right_moving (as, am) (s, l, Oc # r) ires\n       \\<Longrightarrow> dec_on_right_moving (as, am) (s', Oc # l, r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_on_right_moving (as, am) (s, l, Oc # r) ires \\<Longrightarrow>\n    dec_on_right_moving (as, am) (s', Oc # l, r) ires", "apply(simp only: dec_on_right_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc (Suc m) \\<and>\n       (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # r = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n    \\<exists>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc (Suc m) \\<and>\n       (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n        else Oc # l =\n             Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        r = Oc \\<up> mr \\<and> lm2 = [])", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc (Suc m) \\<and>\n       (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # r = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>lm1 lm2 m ml mr rn.\n          am = lm1 @ [m] @ lm2 \\<and>\n          ml + mr = Suc (Suc m) \\<and>\n          (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           r = Oc \\<up> mr \\<and> lm2 = [])", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc (Suc m) \\<and>\n       (if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (Oc # r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # r = Oc \\<up> mr \\<and> lm2 = []) \\<Longrightarrow>\n       \\<exists>lm1 lm2 m ml mr rn.\n          am = lm1 @ [m] @ lm2 \\<and>\n          ml + mr = Suc (Suc m) \\<and>\n          (if lm1 = [] then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n           else Oc # l =\n                Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n          (r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n           r = Oc \\<up> mr \\<and> lm2 = [])", "apply(erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ [m] @ lm2; ml + mr = Suc (Suc m);\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        Oc # r = Oc \\<up> mr \\<and> lm2 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            am = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc (Suc m) \\<and>\n                            (if lm1 = []\n                             then Oc # l = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # l =\n                                  Oc \\<up> ml @\n                                  [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (r =\n                             Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                             r = Oc \\<up> mr \\<and> lm2 = [])", "apply(rule_tac x = lm1 in exI, rule_tac x = lm2 in exI,\n      rule_tac x = \"m\" in exI, rule_tac x = \"Suc ml\" in exI, \n      rule_tac x = \"mr - 1\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ m # lm2; ml + mr = Suc (Suc m);\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n        Oc # r = Oc \\<up> mr \\<and> lm2 = []\\<rbrakk>\n       \\<Longrightarrow> ml + (mr - Suc 0) = Suc m \\<and>\n                         ((\\<exists>rn.\n                              r =\n                              Oc \\<up> (mr - Suc 0) @\n                              Bk # <lm2> @ Bk \\<up> rn) \\<or>\n                          r = Oc \\<up> (mr - Suc 0) \\<and> lm2 = [])", "apply(case_tac mr, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_on_right_moving_nonempty[simp]: \"dec_on_right_moving (as, am) (s, l, r) ires\\<Longrightarrow>  l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_on_right_moving (as, am) (s, l, r) ires \\<Longrightarrow>\n    l \\<noteq> []", "apply(auto simp: dec_on_right_moving.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_after_clear_Bk_tail[simp]: \"dec_on_right_moving (as, am) (s, l, Bk # r) ires\n      \\<Longrightarrow>  dec_after_clear (as, am) (s', tl l, hd l # Bk # r) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_on_right_moving (as, am) (s, l, Bk # r) ires \\<Longrightarrow>\n    dec_after_clear (as, am) (s', tl l, hd l # Bk # r) ires", "apply(auto simp: dec_on_right_moving.simps dec_after_clear.simps simp del:split_head_repeat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ m # lm2; ml + mr = Suc (Suc m);\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 @ m # lm2 = ma # lm2a \\<and>\n                             tl l = Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                             (\\<exists>rn. r = <lm2a> @ Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                             tl l =\n                             Oc #\n                             Oc \\<up> ma @\n                             Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                             (\\<exists>rn. r = <lm2a> @ Bk \\<up> rn))", "apply(rename_tac lm1 lm2 m ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ m # lm2; ml + mr = Suc (Suc m);\n        if lm1 = [] then l = Oc \\<up> ml @ Bk # Bk # ires\n        else l = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Bk # r = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 @ m # lm2 = ma # lm2a \\<and>\n                             tl l = Oc # Oc \\<up> ma @ Bk # Bk # ires \\<and>\n                             (\\<exists>rn. r = <lm2a> @ Bk \\<up> rn)) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                             tl l =\n                             Oc #\n                             Oc \\<up> ma @\n                             Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                             (\\<exists>rn. r = <lm2a> @ Bk \\<up> rn))", "apply(case_tac mr, auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_after_clear_tail[simp]: \"dec_on_right_moving (as, am) (s, l, []) ires\n             \\<Longrightarrow> dec_after_clear (as, am) (s', tl l, [hd l]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_on_right_moving (as, am) (s, l, []) ires \\<Longrightarrow>\n    dec_after_clear (as, am) (s', tl l, [hd l]) ires", "apply(auto simp: dec_on_right_moving.simps dec_after_clear.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m.\n       \\<lbrakk>if lm1 = [] then l = Oc \\<up> Suc (Suc m) @ Bk # Bk # ires\n                else l =\n                     Oc \\<up> Suc (Suc m) @\n                     [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        am = lm1 @ [m]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a ma.\n                            (lm1a = [] \\<longrightarrow>\n                             lm1 = [] \\<and>\n                             m = ma \\<and>\n                             tl l =\n                             Oc # Oc \\<up> ma @ Bk # Bk # ires) \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 = lm1a \\<and>\n                             m = ma \\<and>\n                             tl l =\n                             Oc #\n                             Oc \\<up> ma @ Bk # <rev lm1a> @ Bk # Bk # ires)", "apply(simp_all split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; lm1 \\<noteq> [];\n        l = Oc # Oc # Oc \\<up> m @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a.\n                            lm1a \\<noteq> [] \\<and>\n                            (lm1a \\<noteq> [] \\<longrightarrow>\n                             lm1 = lm1a \\<and> <rev lm1> = <rev lm1a>)", "apply(rule_tac x = lm1 in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dec_false_1[simp]:\n  \"\\<lbrakk>abc_lm_v am n = 0; inv_locate_b (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n  \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_lm_v am n = 0;\n     inv_locate_b (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n    \\<Longrightarrow> False", "apply(auto simp: inv_locate_b.simps in_middle.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac lm1 lm2 m ml Mr rn)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"length lm1 \\<ge> length am\", auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn;\n        length am \\<le> length lm1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v (lm1 @ m # lm2) (length lm1) = 0;\n        am = lm1 @ m # lm2; n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"lm2 = []\", simp, subgoal_tac \"m = 0\", simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [0];\n        n = length lm1; Suc 0 = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # Bk \\<up> rn;\n        length am \\<le> length lm1; lm2 = []; m = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # Bk \\<up> rn;\n        length am \\<le> length lm1; lm2 = []\\<rbrakk>\n       \\<Longrightarrow> m = 0\n 3. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn;\n        length am \\<le> length lm1\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 4. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v (lm1 @ m # lm2) (length lm1) = 0;\n        am = lm1 @ m # lm2; n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac Mr, auto simp: )"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>lm1 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # Bk \\<up> rn;\n        length am \\<le> length lm1\\<rbrakk>\n       \\<Longrightarrow> m = 0\n 2. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn;\n        length am \\<le> length lm1\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 3. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v (lm1 @ m # lm2) (length lm1) = 0;\n        am = lm1 @ m # lm2; n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"Suc (length lm1) - length am = \n                   Suc (length lm1 - length am)\", \n      simp add: exp_ind del: replicate.simps, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn;\n        length am \\<le> length lm1\\<rbrakk>\n       \\<Longrightarrow> lm2 = []\n 2. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v (lm1 @ m # lm2) (length lm1) = 0;\n        am = lm1 @ m # lm2; n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac xs = \"am @ replicate (Suc (length lm1) - length am) 0\"\n      and ys = \"lm1 @ m # lm2\" in length_equal, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>abc_lm_v (lm1 @ m # lm2) (length lm1) = 0;\n        am = lm1 @ m # lm2; n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>lm1 m ml mr.\n       \\<lbrakk>abc_lm_v am (length lm1) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac Mr, auto simp: abc_lm_v.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m ml mr.\n       \\<lbrakk>(if length lm1 < length am then am ! length lm1 else 0) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac lm1 m ml Mr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m ml Mr.\n       \\<lbrakk>(if length lm1 < length am then am ! length lm1 else 0) = 0;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + Mr; 0 < ml;\n        if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> Mr\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"Mr = 0\", simp_all split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m ml Mr.\n       \\<lbrakk>Oc # xs = Oc \\<up> Mr; 0 < Mr;\n        \\<not> length lm1 < length am;\n        am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1; Suc m = ml + Mr; 0 < ml; lm1 \\<noteq> [];\n        aaa = Oc \\<up> ml @ Bk # <rev lm1> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"Suc (length lm1) - length am = \n                       Suc (length lm1 - length am)\", \n      simp add: exp_ind del: replicate.simps, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_Bk_tl[simp]: \n  \"\\<lbrakk>inv_locate_b (as, am) (n, aaa, Bk # xs) ires; \n   abc_lm_v am n = 0\\<rbrakk>\n   \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0) \n                         (s, tl aaa, hd aaa # Bk # xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_b (as, am) (n, aaa, Bk # xs) ires;\n     abc_lm_v am n = 0\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0)\n                       (s, tl aaa, hd aaa # Bk # xs) ires", "apply(simp add: inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_locate_b (as, am) (n, aaa, Bk # xs) ires;\n     abc_lm_v am n = 0\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                       (s, tl aaa, hd aaa # Bk # xs) ires \\<or>\n                      inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                       (s, tl aaa, hd aaa # Bk # xs) ires", "apply(simp only: inv_locate_b.simps in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>lm1 lm2 tn m ml mr rn.\n                am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                length lm1 = n \\<and>\n                m + 1 = ml + mr \\<and>\n                ml \\<noteq> 0 \\<and>\n                tn = n + 1 - length am \\<and>\n                (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aaa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 lm2 = [] \\<and> Bk # xs = Oc \\<up> mr);\n     abc_lm_v am n = 0\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                       (s, tl aaa, hd aaa # Bk # xs) ires \\<or>\n                      inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                       (s, tl aaa, hd aaa # Bk # xs) ires", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = n \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> Bk # xs = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, hd aaa # Bk # xs) ires \\<or>\n                         inv_on_left_moving_in_middle_B\n                          (as, abc_lm_s am n 0)\n                          (s, tl aaa, hd aaa # Bk # xs) ires", "apply(rename_tac Lm1 Lm2 tn M ml Mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lm1 Lm2 tn M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ [M] @ Lm2 \\<and>\n        length Lm1 = n \\<and>\n        M + 1 = ml + Mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> Mr @ [Bk] @ <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr)\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, hd aaa # Bk # xs) ires \\<or>\n                         inv_on_left_moving_in_middle_B\n                          (as, abc_lm_s am n 0)\n                          (s, tl aaa, hd aaa # Bk # xs) ires", "apply(subgoal_tac \"\\<not> inv_on_left_moving_in_middle_B \n         (as, abc_lm_s am n 0) (s, tl aaa, hd aaa # Bk # xs) ires\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> (Suc n - length am) = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Mr = 0 \\<and> xs = <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr);\n        \\<not> inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                (s, tl aaa, hd aaa # Bk # xs) ires\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, hd aaa # Bk # xs) ires\n 2. \\<And>Lm1 Lm2 tn M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ [M] @ Lm2 \\<and>\n        length Lm1 = n \\<and>\n        M + 1 = ml + Mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> Mr @ [Bk] @ <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr)\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0)\n                                 (s, tl aaa, hd aaa # Bk # xs) ires", "apply(simp only: inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> (Suc n - length am) = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Mr = 0 \\<and> xs = <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr);\n        \\<not> inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                (s, tl aaa, hd aaa # Bk # xs) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            abc_lm_s am n 0 = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (hd aaa # Bk # xs =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> hd aaa # Bk # xs = Oc \\<up> mr)\n 2. \\<And>Lm1 Lm2 tn M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ [M] @ Lm2 \\<and>\n        length Lm1 = n \\<and>\n        M + 1 = ml + Mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> Mr @ [Bk] @ <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr)\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0)\n                                 (s, tl aaa, hd aaa # Bk # xs) ires", "apply(erule_tac conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        \\<not> inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                (s, tl aaa, hd aaa # Bk # xs) ires;\n        am @ 0 \\<up> (Suc n - length am) = Lm1 @ M # Lm2; length Lm1 = n;\n        Suc M = ml + Mr; 0 < ml;\n        if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        Mr = 0 \\<and> xs = <Lm2> @ Bk \\<up> rn \\<or>\n        Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            abc_lm_s am n 0 = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (hd aaa # Bk # xs =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> hd aaa # Bk # xs = Oc \\<up> mr)\n 2. \\<And>Lm1 Lm2 tn M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ [M] @ Lm2 \\<and>\n        length Lm1 = n \\<and>\n        M + 1 = ml + Mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> Mr @ [Bk] @ <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr)\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0)\n                                 (s, tl aaa, hd aaa # Bk # xs) ires", "apply(rule_tac x = Lm1 in exI, rule_tac x = Lm2 in exI, \n      rule_tac x =  M in exI, rule_tac x = M in exI, \n      rule_tac x = \"Suc 0\" in exI, simp add: abc_lm_s.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        \\<not> inv_on_left_moving_in_middle_B\n                (as,\n                 if n < length am then am[n := 0]\n                 else am @ 0 \\<up> (n - length am) @ [0])\n                (s, tl aaa, hd aaa # Bk # xs) ires;\n        am @ 0 \\<up> (Suc n - length am) = Lm1 @ M # Lm2; length Lm1 = n;\n        Suc M = ml + Mr; 0 < ml;\n        if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        Mr = 0 \\<and> xs = <Lm2> @ Bk \\<up> rn \\<or>\n        Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr\\<rbrakk>\n       \\<Longrightarrow> (n < length am \\<longrightarrow>\n                          (Lm1 = [] \\<longrightarrow>\n                           am[n := 0] = M # Lm2 \\<and>\n                           ml - Suc 0 = M \\<and>\n                           (\\<exists>rn. xs = <Lm2> @ Bk \\<up> rn)) \\<and>\n                          (Lm1 \\<noteq> [] \\<longrightarrow>\n                           am[n := 0] = Lm1 @ M # Lm2 \\<and>\n                           ml - Suc 0 = M \\<and>\n                           (\\<exists>rn. xs = <Lm2> @ Bk \\<up> rn))) \\<and>\n                         (\\<not> n < length am \\<longrightarrow>\n                          (Lm1 = [] \\<longrightarrow>\n                           am @ 0 \\<up> (n - length am) @ [0] =\n                           M # Lm2 \\<and>\n                           ml - Suc 0 = M \\<and>\n                           (\\<exists>rn. xs = <Lm2> @ Bk \\<up> rn)) \\<and>\n                          (Lm1 \\<noteq> [] \\<longrightarrow>\n                           am @ 0 \\<up> (n - length am) @ [0] =\n                           Lm1 @ M # Lm2 \\<and>\n                           ml - Suc 0 = M \\<and>\n                           (\\<exists>rn. xs = <Lm2> @ Bk \\<up> rn)))\n 2. \\<And>Lm1 Lm2 tn M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ [M] @ Lm2 \\<and>\n        length Lm1 = n \\<and>\n        M + 1 = ml + Mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> Mr @ [Bk] @ <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> Bk # xs = Oc \\<up> Mr)\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0)\n                                 (s, tl aaa, hd aaa # Bk # xs) ires", "apply(case_tac Mr, auto simp: abc_lm_v.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 M rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ M # Lm2;\n        aaa = Oc # Oc \\<up> M @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        xs = <Lm2> @ Bk \\<up> rn; n = length Lm1;\n        \\<not> length Lm1 < length am; Lm1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> am @ 0 \\<up> (length Lm1 - length am) @ [0] =\n                         Lm1 @ M # Lm2\n 2. \\<And>Lm1 Lm2 M rn.\n       \\<lbrakk>(if length Lm1 < length am then am ! length Lm1 else 0) = 0;\n        am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ M # Lm2;\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc M @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc M @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        inv_on_left_moving_in_middle_B (as, abc_lm_s am (length Lm1) 0)\n         (s, tl aaa, hd aaa # Bk # <Lm2> @ Bk \\<up> rn) ires;\n        xs = <Lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp only: exp_ind[THEN sym] replicate_Suc Nat.Suc_diff_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lm1 Lm2 M rn.\n       \\<lbrakk>(if length Lm1 < length am then am ! length Lm1 else 0) = 0;\n        am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ M # Lm2;\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc M @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc M @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        inv_on_left_moving_in_middle_B (as, abc_lm_s am (length Lm1) 0)\n         (s, tl aaa, hd aaa # Bk # <Lm2> @ Bk \\<up> rn) ires;\n        xs = <Lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp: inv_on_left_moving_in_middle_B.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_tl[simp]:\n  \"\\<lbrakk>abc_lm_v am n = 0; inv_locate_b (as, am) (n, aaa, []) ires\\<rbrakk>\n   \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa]) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_lm_v am n = 0;\n     inv_locate_b (as, am) (n, aaa, []) ires\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0)\n                       (s, tl aaa, [hd aaa]) ires", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_lm_v am n = 0;\n     inv_locate_b (as, am) (n, aaa, []) ires\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving (as, abc_lm_s am n 0)\n                       (s, tl aaa, [hd aaa]) ires", "apply(simp add: inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_lm_v am n = 0;\n     inv_locate_b (as, am) (n, aaa, []) ires\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                       (s, tl aaa, [hd aaa]) ires \\<or>\n                      inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                       (s, tl aaa, [hd aaa]) ires", "apply(simp only: inv_locate_b.simps in_middle.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_lm_v am n = 0;\n     \\<exists>lm1 lm2 tn m ml mr rn.\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = n \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> [] = Oc \\<up> mr)\\<rbrakk>\n    \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                       (s, tl aaa, [hd aaa]) ires \\<or>\n                      inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                       (s, tl aaa, [hd aaa]) ires", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 tn m ml mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n        length lm1 = n \\<and>\n        m + 1 = ml + mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         lm2 = [] \\<and> [] = Oc \\<up> mr)\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, [hd aaa]) ires \\<or>\n                         inv_on_left_moving_in_middle_B\n                          (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa]) ires", "apply(rename_tac Lm1 Lm2 tn M ml Mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lm1 Lm2 tn M ml Mr rn.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ [M] @ Lm2 \\<and>\n        length Lm1 = n \\<and>\n        M + 1 = ml + Mr \\<and>\n        ml \\<noteq> 0 \\<and>\n        tn = n + 1 - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> Mr @ [Bk] @ <Lm2> @ Bk \\<up> rn \\<or>\n         Lm2 = [] \\<and> [] = Oc \\<up> Mr)\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, [hd aaa]) ires \\<or>\n                         inv_on_left_moving_in_middle_B\n                          (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa]) ires", "apply(simp add: inv_on_left_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, [hd aaa]) ires \\<or>\n                         inv_on_left_moving_in_middle_B\n                          (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa]) ires", "apply(subgoal_tac \"\\<not> inv_on_left_moving_in_middle_B \n         (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa]) ires\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0;\n        \\<not> inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                (s, tl aaa, [hd aaa]) ires\\<rbrakk>\n       \\<Longrightarrow> inv_on_left_moving_norm (as, abc_lm_s am n 0)\n                          (s, tl aaa, [hd aaa]) ires\n 2. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa])\n                                 ires", "apply(simp only: inv_on_left_moving_norm.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0;\n        \\<not> inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                (s, tl aaa, [hd aaa]) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            abc_lm_s am n 0 = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            ([hd aaa] =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> [hd aaa] = Oc \\<up> mr)\n 2. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa])\n                                 ires", "apply(erule_tac conjE)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        \\<not> inv_on_left_moving_in_middle_B (as, abc_lm_s am n 0)\n                (s, tl aaa, [hd aaa]) ires;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2; length Lm1 = n; Suc M = ml + Mr;\n        0 < ml; tn = Suc n - length am;\n        if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        Lm2 = []; Mr = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m ml mr rn.\n                            abc_lm_s am n 0 = lm1 @ [m] @ lm2 \\<and>\n                            ml + mr = Suc m \\<and>\n                            0 < mr \\<and>\n                            (if lm1 = []\n                             then tl aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else tl aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            ([hd aaa] =\n                             Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> [hd aaa] = Oc \\<up> mr)\n 2. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa])\n                                 ires", "apply(rule_tac x = Lm1 in exI, rule_tac x = Lm2 in exI, \n      rule_tac x =  M in exI, rule_tac x = M in exI, \n      rule_tac x = \"Suc 0\" in exI, simp add: abc_lm_s.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        \\<not> inv_on_left_moving_in_middle_B\n                (as,\n                 if n < length am then am[n := 0]\n                 else am @ 0 \\<up> (n - length am) @ [0])\n                (s, tl aaa, [hd aaa]) ires;\n        am @ 0 \\<up> (Suc n - length am) = Lm1 @ [M]; length Lm1 = n;\n        Suc M = ml; tn = Suc n - length am;\n        if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n        else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        Lm2 = []; Mr = 0\\<rbrakk>\n       \\<Longrightarrow> (n < length am \\<longrightarrow>\n                          (Lm1 = [] \\<longrightarrow>\n                           am[n := 0] = [M] \\<and> ml - Suc 0 = M) \\<and>\n                          (Lm1 \\<noteq> [] \\<longrightarrow>\n                           am[n := 0] = Lm1 @ [M] \\<and>\n                           ml - Suc 0 = M)) \\<and>\n                         (\\<not> n < length am \\<longrightarrow>\n                          (Lm1 = [] \\<longrightarrow>\n                           am = [] \\<and>\n                           n = length am \\<and>\n                           M = 0 \\<and> ml - Suc 0 = M) \\<and>\n                          (Lm1 \\<noteq> [] \\<longrightarrow>\n                           am @ 0 \\<up> (n - length am) = Lm1 \\<and>\n                           M = 0 \\<and> ml - Suc 0 = M))\n 2. \\<And>Lm1 Lm2 tn M ml Mr.\n       \\<lbrakk>abc_lm_v am n = 0;\n        am @ 0 \\<up> tn = Lm1 @ M # Lm2 \\<and>\n        length Lm1 = n \\<and>\n        Suc M = ml + Mr \\<and>\n        0 < ml \\<and>\n        tn = Suc n - length am \\<and>\n        (if Lm1 = [] then aaa = Oc \\<up> ml @ Bk # Bk # ires\n         else aaa = Oc \\<up> ml @ [Bk] @ <rev Lm1> @ Bk # Bk # ires) \\<and>\n        Lm2 = [] \\<and> Mr = 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> inv_on_left_moving_in_middle_B\n                                 (as, abc_lm_s am n 0) (s, tl aaa, [hd aaa])\n                                 ires", "apply(case_tac Mr, simp_all, auto simp: abc_lm_v.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Lm1 M.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [M];\n        aaa = Oc # Oc \\<up> M @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        n = length Lm1; \\<not> length Lm1 < length am;\n        Lm1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> am @ 0 \\<up> (length Lm1 - length am) = Lm1\n 2. \\<And>Lm1 M.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [M];\n        aaa = Oc # Oc \\<up> M @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        n = length Lm1; \\<not> length Lm1 < length am;\n        Lm1 \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> M = 0\n 3. \\<And>Lm1 M.\n       \\<lbrakk>(if length Lm1 < length am then am ! length Lm1 else 0) = 0;\n        am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [M];\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc M @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc M @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        inv_on_left_moving_in_middle_B (as, abc_lm_s am (length Lm1) 0)\n         (s, tl aaa, [hd aaa]) ires\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp_all only: exp_ind Nat.Suc_diff_le del: replicate_Suc, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lm1 M.\n       \\<lbrakk>(if length Lm1 < length am then am ! length Lm1 else 0) = 0;\n        am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [M];\n        n = length Lm1;\n        if Lm1 = [] then aaa = (Oc \\<up> M @ [Oc]) @ Bk # Bk # ires\n        else aaa = (Oc \\<up> M @ [Oc]) @ [Bk] @ <rev Lm1> @ Bk # Bk # ires;\n        inv_on_left_moving_in_middle_B (as, abc_lm_s am (length Lm1) 0)\n         (s, tl aaa, [hd aaa]) ires\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp: inv_on_left_moving_in_middle_B.simps split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 M.\n       \\<lbrakk>hd (Oc \\<up> M @ Oc # Bk # <rev Lm1> @ Bk # Bk # ires) = Bk;\n        am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [M];\n        n = length Lm1; Lm1 \\<noteq> [];\n        aaa = Oc \\<up> M @ Oc # Bk # <rev Lm1> @ Bk # Bk # ires;\n        \\<not> length Lm1 < length am; abc_lm_s am (length Lm1) 0 = [];\n        tl (Oc \\<up> M @ Oc # Bk # <rev Lm1> @ Bk # Bk # ires) =\n        Bk # ires\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Lm1 M.\n       \\<lbrakk>hd (Oc \\<up> M @ Oc # Bk # <rev Lm1> @ Bk # Bk # ires) = Bk;\n        am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [M];\n        n = length Lm1; Lm1 \\<noteq> [];\n        aaa = Oc \\<up> M @ Oc # Bk # <rev Lm1> @ Bk # Bk # ires;\n        \\<not> length Lm1 < length am;\n        abc_lm_s am (length Lm1) 0 \\<noteq> [];\n        tl (Oc \\<up> M @ Oc # Bk # <rev Lm1> @ Bk # Bk # ires) =\n        <rev (abc_lm_s am (length Lm1) 0)> @ Bk # Bk # ires\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac [!] M, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare dec_inv_1.simps[simp del]"], ["", "declare inv_locate_n_b.simps [simp del]"], ["", "lemma dec_first_on_right_moving_Oc_via_inv_locate_n_b[simp]:\n  \"\\<lbrakk>inv_locate_n_b (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n \\<Longrightarrow> dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))  \n                                      (s, Oc # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_locate_n_b (as, am) (n, aaa, Oc # xs) ires \\<Longrightarrow>\n    dec_first_on_right_moving n (as, abc_lm_s am n (abc_lm_v am n))\n     (s, Oc # aaa, xs) ires", "apply(auto simp: inv_locate_n_b.simps dec_first_on_right_moving.simps \n      abc_lm_s.simps abc_lm_v.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am = lm1 @ m # lm2; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2a ma.\n                            lm1 @ m # lm2 = lm1a @ ma # lm2a \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2a = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2a> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2a = []))))\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 4. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rename_tac Lm1 Lm2 m rn)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Lm1 Lm2 m rn.\n       \\<lbrakk>am = Lm1 @ m # Lm2; n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <Lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 ma.\n                            Lm1 @ m # Lm2 = lm1 @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1 = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     Lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1 \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1 = length Lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 4. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = Lm1 in exI, rule_tac x = Lm2 in exI, \n      rule_tac x = m in exI, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Lm1 Lm2 m rn.\n       \\<lbrakk>am = Lm1 @ m # Lm2; n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <Lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr.\n                            ml + mr = Suc m \\<and>\n                            0 < ml \\<and>\n                            0 < m \\<and>\n                            [Oc, Oc] = Oc \\<up> ml \\<and>\n                            ((\\<exists>rn.\n                                 xs =\n                                 Oc \\<up> mr @\n                                 Bk # <Lm2> @ Bk \\<up> rn) \\<or>\n                             xs = Oc \\<up> mr \\<and> Lm2 = [])\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 4. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = \"Suc (Suc 0)\" in exI, \n      rule_tac x = \"m - 1\" in exI, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Lm1 Lm2 m rn.\n       \\<lbrakk>am = Lm1 @ m # Lm2; n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <Lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> Suc (m - Suc 0) = m \\<and>\n                         0 < m \\<and>\n                         ((\\<exists>rn.\n                              xs =\n                              Oc \\<up> (m - Suc 0) @\n                              Bk # <Lm2> @ Bk \\<up> rn) \\<or>\n                          xs = Oc \\<up> (m - Suc 0) \\<and> Lm2 = [])\n 2. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 4. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply (metis One_nat_def Suc_pred cell.distinct(1) empty_replicate list.inject list.sel(3)\n      neq0_conv self_append_conv2 tl_append2 tl_replicate)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>lm1 lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ m # lm2;\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <lm2> @ Bk \\<up> rn;\n        \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 2. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rename_tac Lm1 Lm2 m rn)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Lm1 Lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ m # Lm2;\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <Lm2> @ Bk \\<up> rn;\n        \\<not> length Lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m.\n                            am @ 0 \\<up> (length Lm1 - length am) @ [0] =\n                            lm1 @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1 = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     Lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1 \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1 = length Lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 2. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = Lm1 in exI, rule_tac x = Lm2 in exI, \n      rule_tac x = m in exI, \n      simp add: Suc_diff_le exp_ind del: replicate.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Lm1 Lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (length Lm1 - length am) @ [0] = Lm1 @ m # Lm2;\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <Lm2> @ Bk \\<up> rn;\n        \\<not> length Lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr.\n                            ml + mr = Suc m \\<and>\n                            0 < ml \\<and>\n                            0 < m \\<and>\n                            Oc # Oc \\<up> 0 @ [Oc] = Oc \\<up> ml \\<and>\n                            ((\\<exists>rn.\n                                 xs =\n                                 Oc \\<up> mr @\n                                 Bk # <Lm2> @ Bk \\<up> rn) \\<or>\n                             xs = Oc \\<up> mr \\<and> Lm2 = [])\n 2. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = \"Suc (Suc 0)\" in exI, \n      rule_tac x = \"m - 1\" in exI, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Lm1 Lm2 m rn.\n       \\<lbrakk>am @ 0 \\<up> (length Lm1 - length am) @ [0] = Lm1 @ m # Lm2;\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m @ Bk # <Lm2> @ Bk \\<up> rn;\n        \\<not> length Lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> Suc (m - Suc 0) = m \\<and>\n                         0 < m \\<and>\n                         ((\\<exists>rn.\n                              xs =\n                              Oc \\<up> (m - Suc 0) @\n                              Bk # <Lm2> @ Bk \\<up> rn) \\<or>\n                          xs = Oc \\<up> (m - Suc 0) \\<and> Lm2 = [])\n 2. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 3. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply (metis cell.distinct(1) empty_replicate gr_zeroI list.inject replicateE self_append_conv2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 m.\n       \\<lbrakk>am = lm1 @ [m]; n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 ma.\n                            lm1 @ [m] = lm1a @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 2. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rename_tac Lm1 m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 m.\n       \\<lbrakk>am = Lm1 @ [m]; n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 ma.\n                            Lm1 @ [m] = lm1 @ ma # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1 = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     Lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1 \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc ma \\<and>\n                                     length lm1 = length Lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < ma \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))\n 2. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = Lm1 in exI, rule_tac x = \"[]\" in exI, \n      rule_tac x = m in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 m.\n       \\<lbrakk>am = Lm1 @ [m]; n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr.\n                            ml + mr = Suc m \\<and>\n                            0 < ml \\<and>\n                            0 < m \\<and>\n                            [Oc, Oc] = Oc \\<up> ml \\<and>\n                            ((\\<exists>rn.\n                                 xs = Oc \\<up> mr @ Bk # Bk \\<up> rn) \\<or>\n                             xs = Oc \\<up> mr)\n 2. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = \"Suc (Suc 0)\" in exI, \n      rule_tac x = \"m - 1\" in exI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lm1 m.\n       \\<lbrakk>am = Lm1 @ [m]; n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m\\<rbrakk>\n       \\<Longrightarrow> Suc (m - Suc 0) = m \\<and>\n                         0 < m \\<and>\n                         ((\\<exists>rn.\n                              xs =\n                              Oc \\<up> (m - Suc 0) @ Bk # Bk \\<up> rn) \\<or>\n                          xs = Oc \\<up> (m - Suc 0))\n 2. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(case_tac m, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length lm1) - length am) = lm1 @ [m];\n        n = length lm1;\n        if lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1a lm2 m.\n                            am @ 0 \\<up> (length lm1 - length am) @ [0] =\n                            lm1a @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1a = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1a \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1a = length lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1a> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rename_tac Lm1 m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lm1 m.\n       \\<lbrakk>am @ 0 \\<up> (Suc (length Lm1) - length am) = Lm1 @ [m];\n        n = length Lm1;\n        if Lm1 = [] then aaa = Oc \\<up> Suc 0 @ Bk # Bk # ires\n        else aaa = Oc \\<up> Suc 0 @ Bk # <rev Lm1> @ Bk # Bk # ires;\n        Oc # xs = Oc \\<up> m; \\<not> length Lm1 < length am\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 m.\n                            am @ 0 \\<up> (length Lm1 - length am) @ [0] =\n                            lm1 @ m # lm2 \\<and>\n                            (\\<exists>ml.\n                                (lm1 = [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     Lm1 = [] \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))) \\<and>\n                                (lm1 \\<noteq> [] \\<longrightarrow>\n                                 (\\<exists>mr.\n                                     ml + mr = Suc m \\<and>\n                                     length lm1 = length Lm1 \\<and>\n                                     0 < ml \\<and>\n                                     0 < m \\<and>\n                                     Oc # aaa =\n                                     Oc \\<up> ml @\n                                     Bk # <rev lm1> @ Bk # Bk # ires \\<and>\n                                     ((\\<exists>rn.\n    xs = Oc \\<up> mr @ Bk # <lm2> @ Bk \\<up> rn) \\<or>\nxs = Oc \\<up> mr \\<and> lm2 = []))))", "apply(rule_tac x = Lm1 in exI, rule_tac x = \"[]\" in exI, rule_tac x = m in exI, \n      simp add: Suc_diff_le exp_ind del: replicate.simps, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_on_left_moving_nonempty[simp]: \"inv_on_left_moving (as, am) (s, [], r) ires \n  = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_on_left_moving (as, am) (s, [], r) ires = False", "apply(simp add: inv_on_left_moving.simps inv_on_left_moving_norm.simps\n      inv_on_left_moving_in_middle_B.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_startof_nonempty[simp]: \n  \"inv_check_left_moving (as, abc_lm_s am n 0)\n  (start_of (layout_of aprog) as + 2 * n + 14, [], Oc # xs) ires\n = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving (as, abc_lm_s am n 0)\n     (start_of (layout_of aprog) as + 2 * n + 14, [], Oc # xs) ires =\n    False", "apply(simp add: inv_check_left_moving.simps inv_check_left_moving_in_middle.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma start_of_lessE[elim]: \"\\<lbrakk>abc_fetch as ap = Some (Dec n e);\n                start_of (layout_of ap) as < start_of (layout_of ap) e; \n                start_of (layout_of ap) e \\<le> Suc (start_of (layout_of ap) as + 2 * n)\\<rbrakk>\n       \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n     start_of (layout_of ap) as < start_of (layout_of ap) e;\n     start_of (layout_of ap) e\n     \\<le> Suc (start_of (layout_of ap) as + 2 * n)\\<rbrakk>\n    \\<Longrightarrow> RR", "using start_of_less[of e as \"layout_of ap\"] start_of_ge[of as ap n e \"layout_of ap\"]"], ["proof (prove)\nusing this:\n  e < as \\<Longrightarrow>\n  start_of (layout_of ap) e \\<le> start_of (layout_of ap) as\n  \\<lbrakk>abc_fetch as ap = Some (Dec n e); layout_of ap = layout_of ap;\n   as < e\\<rbrakk>\n  \\<Longrightarrow> start_of (layout_of ap) as + 2 * n + 16\n                    \\<le> start_of (layout_of ap) e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n     start_of (layout_of ap) as < start_of (layout_of ap) e;\n     start_of (layout_of ap) e\n     \\<le> Suc (start_of (layout_of ap) as + 2 * n)\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(cases \"as < e\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n     start_of (layout_of ap) as < start_of (layout_of ap) e;\n     start_of (layout_of ap) e\n     \\<le> Suc (start_of (layout_of ap) as + 2 * n);\n     e < as \\<Longrightarrow>\n     start_of (layout_of ap) e \\<le> start_of (layout_of ap) as;\n     \\<lbrakk>abc_fetch as ap = Some (Dec n e); layout_of ap = layout_of ap;\n      as < e\\<rbrakk>\n     \\<Longrightarrow> start_of (layout_of ap) as + 2 * n + 16\n                       \\<le> start_of (layout_of ap) e;\n     \\<not> as < e\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(cases \"as = e\", simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_dec_b_e_pre':\n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_b (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and dec_0: \"abc_lm_v lm n = 0\"\n    and f: \"f = (\\<lambda> stp. (steps (Suc (start_of ly as) + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), \n            start_of ly as - Suc 0) stp, start_of ly as, n))\"\n    and P: \"P = (\\<lambda> ((s, l, r), ss, x). s = start_of ly e)\"\n    and Q: \"Q = (\\<lambda> ((s, l, r), ss, x). dec_inv_1 ly x e (as, lm) (s, l, r) ires)\"\n  shows \"\\<exists> stp. P (f stp) \\<and> Q (f stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. P (f stp) \\<and> Q (f stp)", "proof(rule_tac LE = abc_dec_1_LE in halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf abc_dec_1_LE\n 2. Q (f 0)\n 3. \\<not> P (f 0)\n 4. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "show \"wf abc_dec_1_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf abc_dec_1_LE", "by(intro wf_dec_le)"], ["proof (state)\nthis:\n  wf abc_dec_1_LE\n\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "show \"Q (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (f 0)", "using layout fetch"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. Q (f 0)", "apply(simp add: f steps.simps Q dec_inv_1.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Dec n e)\\<rbrakk>\n    \\<Longrightarrow> inv_locate_b (as, lm) (n, la, ra) ires", "apply(subgoal_tac \"e > as \\<or> e = as \\<or> e < as\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Dec n e);\n     as < e \\<or> e = as \\<or> e < as\\<rbrakk>\n    \\<Longrightarrow> inv_locate_b (as, lm) (n, la, ra) ires\n 2. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Dec n e)\\<rbrakk>\n    \\<Longrightarrow> as < e \\<or> e = as \\<or> e < as", "apply(auto simp: inv_start)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (f 0)\n\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "show \"\\<not> P (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "using layout fetch"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "apply(simp add: f steps.simps P)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> P (f 0)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "show \"\\<forall>n. \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow> Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "using fetch"], ["proof (prove)\nusing this:\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE", "proof(rule_tac allI, rule_tac impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n        abc_fetch as ap = Some (Dec n e);\n        \\<not> P (f na) \\<and> Q (f na)\\<rbrakk>\n       \\<Longrightarrow> Q (f (Suc na)) \\<and>\n                         (f (Suc na), f na) \\<in> abc_dec_1_LE", "fix na"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n        abc_fetch as ap = Some (Dec n e);\n        \\<not> P (f na) \\<and> Q (f na)\\<rbrakk>\n       \\<Longrightarrow> Q (f (Suc na)) \\<and>\n                         (f (Suc na), f na) \\<in> abc_dec_1_LE", "assume \"\\<not> P (f na) \\<and> Q (f na)\""], ["proof (state)\nthis:\n  \\<not> P (f na) \\<and> Q (f na)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n        abc_fetch as ap = Some (Dec n e);\n        \\<not> P (f na) \\<and> Q (f na)\\<rbrakk>\n       \\<Longrightarrow> Q (f (Suc na)) \\<and>\n                         (f (Suc na), f na) \\<in> abc_dec_1_LE", "thus \"Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> abc_dec_1_LE\""], ["proof (prove)\nusing this:\n  \\<not> P (f na) \\<and> Q (f na)\n\ngoal (1 subgoal):\n 1. Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> abc_dec_1_LE", "apply(simp add: f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (steps (Suc (start_of ly as + 2 * n), la, ra)\n               (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0)\n               na,\n              start_of ly as, n) \\<and>\n    Q (steps (Suc (start_of ly as + 2 * n), la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na,\n       start_of ly as, n) \\<Longrightarrow>\n    Q (step\n        (steps (Suc (start_of ly as + 2 * n), la, ra)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n       start_of ly as, n) \\<and>\n    ((step\n       (steps (Suc (start_of ly as + 2 * n), la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n      start_of ly as, n),\n     steps (Suc (start_of ly as + 2 * n), la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na,\n     start_of ly as, n)\n    \\<in> abc_dec_1_LE", "apply(cases \"steps (Suc (start_of ly as + 2 * n), la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (Suc (start_of ly as + 2 * n), la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_1_LE", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (Suc (start_of ly as + 2 * n), la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_1_LE", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (Suc (start_of ly as + 2 * n), la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_1_LE", "assume \"\\<not> P ((a, b, c), start_of ly as, n) \\<and> Q ((a, b, c), start_of ly as, n)\""], ["proof (state)\nthis:\n  \\<not> P ((a, b, c), start_of ly as, n) \\<and>\n  Q ((a, b, c), start_of ly as, n)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (Suc (start_of ly as + 2 * n), la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_1_LE", "thus \"Q (step (a, b, c) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0), start_of ly as, n) \\<and>\n               ((step (a, b, c) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0), start_of ly as, n), \n                   (a, b, c), start_of ly as, n) \\<in> abc_dec_1_LE\""], ["proof (prove)\nusing this:\n  \\<not> P ((a, b, c), start_of ly as, n) \\<and>\n  Q ((a, b, c), start_of ly as, n)\n\ngoal (1 subgoal):\n 1. Q (step (a, b, c)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n       start_of ly as, n) \\<and>\n    ((step (a, b, c)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n      start_of ly as, n),\n     (a, b, c), start_of ly as, n)\n    \\<in> abc_dec_1_LE", "apply(simp add: Q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P ((a, b, c), start_of ly as, n) \\<and>\n    dec_inv_1 ly n e (as, lm) (a, b, c) ires \\<Longrightarrow>\n    dec_inv_1 ly n e (as, lm)\n     (step (a, b, c)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0))\n     ires \\<and>\n    ((step (a, b, c)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n      start_of ly as, n),\n     (a, b, c), start_of ly as, n)\n    \\<in> abc_dec_1_LE", "apply(cases c;cases \"hd c\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n             dec_inv_1 ly n e (as, lm) (a, b, c) ires;\n     c = []; hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, c), start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 2. \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n             dec_inv_1 ly n e (as, lm) (a, b, c) ires;\n     c = []; hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, c), start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 3. \\<And>aa list.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                dec_inv_1 ly n e (as, lm) (a, b, c) ires;\n        c = aa # list; hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                          (step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_1_LE\n 4. \\<And>aa list.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                dec_inv_1 ly n e (as, lm) (a, b, c) ires;\n        c = aa # list; hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                          (step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_1_LE", "apply(simp_all add: dec_inv_1.simps Let_def split: if_splits)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<lbrakk>c = []; hd [] = Bk; a = start_of ly e;\n     \\<not> P ((start_of ly e, b, []), start_of ly as, n) \\<and>\n     inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly e, b, []), start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 2. \\<lbrakk>c = []; hd [] = Bk;\n     Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e;\n     a = Suc (start_of ly as + 2 * n);\n     \\<not> P ((Suc (start_of ly as + 2 * n), b, []), start_of ly as,\n               n) \\<and>\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (start_of ly as + 2 * n), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 3. \\<lbrakk>c = []; hd [] = Bk;\n     start_of ly as + 2 * n + 14 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 14;\n     \\<not> P ((start_of ly as + 2 * n + 14, b, []), start_of ly as,\n               n) \\<and>\n     inv_check_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 14, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 14, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 4. \\<lbrakk>c = []; hd [] = Bk;\n     start_of ly as + 2 * n + 15 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 15;\n     \\<not> P ((start_of ly as + 2 * n + 15, b, []), start_of ly as,\n               n) \\<and>\n     inv_after_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 15, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 15, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 5. \\<lbrakk>c = []; hd [] = Oc; a = start_of ly e;\n     \\<not> P ((start_of ly e, b, []), start_of ly as, n) \\<and>\n     inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly e, b, []), start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 6. \\<lbrakk>c = []; hd [] = Oc;\n     Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e;\n     a = Suc (start_of ly as + 2 * n);\n     \\<not> P ((Suc (start_of ly as + 2 * n), b, []), start_of ly as,\n               n) \\<and>\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (start_of ly as + 2 * n), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 7. \\<lbrakk>c = []; hd [] = Oc;\n     start_of ly as + 2 * n + 14 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 14;\n     \\<not> P ((start_of ly as + 2 * n + 14, b, []), start_of ly as,\n               n) \\<and>\n     inv_check_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 14, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 14, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 8. \\<lbrakk>c = []; hd [] = Oc;\n     start_of ly as + 2 * n + 15 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 15;\n     \\<not> P ((start_of ly as + 2 * n + 15, b, []), start_of ly as,\n               n) \\<and>\n     inv_after_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 15, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 15, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 9. \\<And>aa list.\n       \\<lbrakk>c = Bk # list; aa = Bk; a = start_of ly e;\n        \\<not> P ((start_of ly e, b, Bk # list), start_of ly as, n) \\<and>\n        inv_stop (as, abc_lm_s lm n (abc_lm_v lm n))\n         (start_of ly e, b, Bk # list) ires\\<rbrakk>\n       \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                          (step (start_of ly e, b, Bk # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (start_of ly e, b, Bk # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (start_of ly e, b, Bk # list), start_of ly as, n)\n                         \\<in> abc_dec_1_LE\n 10. \\<And>aa list.\n        \\<lbrakk>c = Bk # list; aa = Bk;\n         Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e;\n         a = Suc (start_of ly as + 2 * n);\n         \\<not> P ((Suc (start_of ly as + 2 * n), b, Bk # list),\n                   start_of ly as, n) \\<and>\n         inv_locate_b (as, lm) (n, b, Bk # list) ires\\<rbrakk>\n        \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                           (step\n                             (Suc (start_of ly as + 2 * n), b, Bk # list)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0))\n                           ires \\<and>\n                          ((step\n                             (Suc (start_of ly as + 2 * n), b, Bk # list)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n),\n                           (Suc (start_of ly as + 2 * n), b, Bk # list),\n                           start_of ly as, n)\n                          \\<in> abc_dec_1_LE\nA total of 17 subgoals...", "using fetch layout dec_0"], ["proof (prove)\nusing this:\n  abc_fetch as ap = Some (Dec n e)\n  ly = layout_of ap\n  abc_lm_v lm n = 0\n\ngoal (17 subgoals):\n 1. \\<lbrakk>c = []; hd [] = Bk; a = start_of ly e;\n     \\<not> P ((start_of ly e, b, []), start_of ly as, n) \\<and>\n     inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly e, b, []), start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 2. \\<lbrakk>c = []; hd [] = Bk;\n     Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e;\n     a = Suc (start_of ly as + 2 * n);\n     \\<not> P ((Suc (start_of ly as + 2 * n), b, []), start_of ly as,\n               n) \\<and>\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (start_of ly as + 2 * n), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 3. \\<lbrakk>c = []; hd [] = Bk;\n     start_of ly as + 2 * n + 14 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 14;\n     \\<not> P ((start_of ly as + 2 * n + 14, b, []), start_of ly as,\n               n) \\<and>\n     inv_check_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 14, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 14, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 4. \\<lbrakk>c = []; hd [] = Bk;\n     start_of ly as + 2 * n + 15 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 15;\n     \\<not> P ((start_of ly as + 2 * n + 15, b, []), start_of ly as,\n               n) \\<and>\n     inv_after_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 15, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 15, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 5. \\<lbrakk>c = []; hd [] = Oc; a = start_of ly e;\n     \\<not> P ((start_of ly e, b, []), start_of ly as, n) \\<and>\n     inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, b, [])\n      ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly e, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly e, b, []), start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 6. \\<lbrakk>c = []; hd [] = Oc;\n     Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e;\n     a = Suc (start_of ly as + 2 * n);\n     \\<not> P ((Suc (start_of ly as + 2 * n), b, []), start_of ly as,\n               n) \\<and>\n     inv_locate_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (start_of ly as + 2 * n), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_1_LE\n 7. \\<lbrakk>c = []; hd [] = Oc;\n     start_of ly as + 2 * n + 14 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 14;\n     \\<not> P ((start_of ly as + 2 * n + 14, b, []), start_of ly as,\n               n) \\<and>\n     inv_check_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 14, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 14, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 14, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 8. \\<lbrakk>c = []; hd [] = Oc;\n     start_of ly as + 2 * n + 15 \\<noteq> start_of ly e;\n     a = start_of ly as + 2 * n + 15;\n     \\<not> P ((start_of ly as + 2 * n + 15, b, []), start_of ly as,\n               n) \\<and>\n     inv_after_left_moving (as, abc_lm_s lm n (abc_lm_v lm n))\n      (start_of ly as + 2 * n + 15, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 15, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 15, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_1_LE\n 9. \\<And>aa list.\n       \\<lbrakk>c = Bk # list; aa = Bk; a = start_of ly e;\n        \\<not> P ((start_of ly e, b, Bk # list), start_of ly as, n) \\<and>\n        inv_stop (as, abc_lm_s lm n (abc_lm_v lm n))\n         (start_of ly e, b, Bk # list) ires\\<rbrakk>\n       \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                          (step (start_of ly e, b, Bk # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (start_of ly e, b, Bk # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (start_of ly e, b, Bk # list), start_of ly as, n)\n                         \\<in> abc_dec_1_LE\n 10. \\<And>aa list.\n        \\<lbrakk>c = Bk # list; aa = Bk;\n         Suc (start_of ly as + 2 * n) \\<noteq> start_of ly e;\n         a = Suc (start_of ly as + 2 * n);\n         \\<not> P ((Suc (start_of ly as + 2 * n), b, Bk # list),\n                   start_of ly as, n) \\<and>\n         inv_locate_b (as, lm) (n, b, Bk # list) ires\\<rbrakk>\n        \\<Longrightarrow> dec_inv_1 ly n e (as, lm)\n                           (step\n                             (Suc (start_of ly as + 2 * n), b, Bk # list)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0))\n                           ires \\<and>\n                          ((step\n                             (Suc (start_of ly as + 2 * n), b, Bk # list)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n),\n                           (Suc (start_of ly as + 2 * n), b, Bk # list),\n                           start_of ly as, n)\n                          \\<in> abc_dec_1_LE\nA total of 17 subgoals...", "apply(auto simp: step.simps P dec_inv_1.simps Let_def abc_dec_1_LE_def\n            lex_triple_def lex_pair_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>c = Oc # list; a = Suc (start_of (layout_of ap) as + 2 * n);\n        inv_locate_b (as, lm) (n, b, Oc # list) ires;\n        abc_fetch as ap = Some (Dec n e); ly = layout_of ap;\n        abc_lm_v lm n = 0\\<rbrakk>\n       \\<Longrightarrow> False", "using dec_0"], ["proof (prove)\nusing this:\n  abc_lm_v lm n = 0\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       \\<lbrakk>c = Oc # list; a = Suc (start_of (layout_of ap) as + 2 * n);\n        inv_locate_b (as, lm) (n, b, Oc # list) ires;\n        abc_fetch as ap = Some (Dec n e); ly = layout_of ap;\n        abc_lm_v lm n = 0\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac dec_false_1, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (step (a, b, c)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n     start_of ly as, n) \\<and>\n  ((step (a, b, c)\n     (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n    start_of ly as, n),\n   (a, b, c), start_of ly as, n)\n  \\<in> abc_dec_1_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> abc_dec_1_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n     Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_1_LE\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crsp_step_dec_b_e_pre:\n  assumes \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_b (as, lm) (n, la, ra) ires\"\n    and dec_0: \"abc_lm_v lm n  = 0\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp lb rb.\n       steps (Suc (start_of ly as) + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), \n       start_of ly as - Suc 0) stp = (start_of ly e, lb, rb) \\<and>\n       dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp lb rb.\n       steps (Suc (start_of ly as) + 2 * n, la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n       (start_of ly e, lb, rb) \\<and>\n       dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  inv_locate_b (as, lm) (n, la, ra) ires\n  abc_lm_v lm n = 0\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<exists>stp lb rb.\n       steps (Suc (start_of ly as) + 2 * n, la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n       (start_of ly e, lb, rb) \\<and>\n       dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires", "apply(drule_tac crsp_step_dec_b_e_pre', auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>ly = layout_of ap; inv_locate_b (as, lm) (n, la, ra) ires;\n        abc_lm_v lm n = 0; abc_fetch as ap = Some (Dec n e);\n        steps (Suc (start_of (layout_of ap) as + 2 * n), la, ra)\n         (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n          start_of (layout_of ap) as - Suc 0)\n         stp =\n        (start_of (layout_of ap) e, a, b);\n        dec_inv_1 (layout_of ap) n e (as, lm)\n         (start_of (layout_of ap) e, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp lb rb.\n                            steps\n                             (Suc (start_of (layout_of ap) as + 2 * n), la,\n                              ra)\n                             (ci (layout_of ap) (start_of (layout_of ap) as)\n                               (Dec n e),\n                              start_of (layout_of ap) as - Suc 0)\n                             stp =\n                            (start_of (layout_of ap) e, lb, rb) \\<and>\n                            dec_inv_1 (layout_of ap) n e (as, lm)\n                             (start_of (layout_of ap) e, lb, rb) ires", "apply(rename_tac stp a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>ly = layout_of ap; inv_locate_b (as, lm) (n, la, ra) ires;\n        abc_lm_v lm n = 0; abc_fetch as ap = Some (Dec n e);\n        steps (Suc (start_of (layout_of ap) as + 2 * n), la, ra)\n         (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n          start_of (layout_of ap) as - Suc 0)\n         stp =\n        (start_of (layout_of ap) e, a, b);\n        dec_inv_1 (layout_of ap) n e (as, lm)\n         (start_of (layout_of ap) e, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp lb rb.\n                            steps\n                             (Suc (start_of (layout_of ap) as + 2 * n), la,\n                              ra)\n                             (ci (layout_of ap) (start_of (layout_of ap) as)\n                               (Dec n e),\n                              start_of (layout_of ap) as - Suc 0)\n                             stp =\n                            (start_of (layout_of ap) e, lb, rb) \\<and>\n                            dec_inv_1 (layout_of ap) n e (as, lm)\n                             (start_of (layout_of ap) e, lb, rb) ires", "apply(rule_tac x = stp in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_abc_step_via_stop[simp]:\n  \"\\<lbrakk>abc_lm_v lm n = 0;\n  inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, lb, rb) ires\\<rbrakk>\n  \\<Longrightarrow> crsp ly (abc_step_l (as, lm) (Some (Dec n e))) (start_of ly e, lb, rb) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abc_lm_v lm n = 0;\n     inv_stop (as, abc_lm_s lm n (abc_lm_v lm n)) (start_of ly e, lb, rb)\n      ires\\<rbrakk>\n    \\<Longrightarrow> crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n                       (start_of ly e, lb, rb) ires", "apply(auto simp: crsp.simps abc_step_l.simps inv_stop.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_dec_b_e:\n  assumes layout: \"ly = layout_of ap\"\n    and inv_start: \"inv_locate_a (as, lm) (n, l, r) ires\"\n    and dec_0: \"abc_lm_v lm n = 0\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n  (steps (start_of ly as + 2 * n, l, r) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "let ?P = \"ci ly (start_of ly as) (Dec n e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "let ?off = \"start_of ly as - Suc 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "have \"\\<exists> stp la ra. steps (start_of ly as + 2 * n, l, r) (?P, ?off) stp = (Suc (start_of ly as) + 2*n, la, ra)\n             \\<and>  inv_locate_b (as, lm) (n, la, ra) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (start_of ly as + 2 * n, l, r)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n       (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n       inv_locate_b (as, lm) (n, la, ra) ires", "using inv_start"], ["proof (prove)\nusing this:\n  inv_locate_a (as, lm) (n, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (start_of ly as + 2 * n, l, r)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n       (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n       inv_locate_b (as, lm) (n, la, ra) ires", "apply(cases \"r = [] \\<or> hd r = Bk\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp la ra.\n     steps (start_of ly as + 2 * n, l, r)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n     (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n     inv_locate_b (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp la ra.\n     steps (start_of ly as + 2 * n, l, r)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n     (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n     inv_locate_b (as, lm) (n, la, ra) ires", "obtain stpa la ra where a:\n    \"steps (start_of ly as + 2 * n, l, r) (?P, ?off) stpa = (Suc (start_of ly as) + 2*n, la, ra)\n             \\<and>  inv_locate_b (as, lm) (n, la, ra) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp la ra.\n     steps (start_of ly as + 2 * n, l, r)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n     (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n     inv_locate_b (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpa la ra.\n        steps (start_of ly as + 2 * n, l, r)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpa =\n        (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n        inv_locate_b (as, lm) (n, la, ra) ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps (start_of ly as + 2 * n, l, r)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpa =\n  (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "have \"\\<exists> stp lb rb. steps (Suc (start_of ly as) + 2 * n, la, ra) (?P, ?off) stp = (start_of ly e, lb, rb)\n             \\<and>  dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp lb rb.\n       steps (Suc (start_of ly as) + 2 * n, la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n       (start_of ly e, lb, rb) \\<and>\n       dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires", "using assms a"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  inv_locate_a (as, lm) (n, l, r) ires\n  abc_lm_v lm n = 0\n  abc_fetch as ap = Some (Dec n e)\n  steps (start_of ly as + 2 * n, l, r)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpa =\n  (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp lb rb.\n       steps (Suc (start_of ly as) + 2 * n, la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n       (start_of ly e, lb, rb) \\<and>\n       dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires", "apply(rule_tac crsp_step_dec_b_e_pre, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp lb rb.\n     steps (Suc (start_of ly as) + 2 * n, la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n     (start_of ly e, lb, rb) \\<and>\n     dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp lb rb.\n     steps (Suc (start_of ly as) + 2 * n, la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n     (start_of ly e, lb, rb) \\<and>\n     dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires", "obtain stpb lb rb where b:\n    \"steps (Suc (start_of ly as) + 2 * n, la, ra) (?P, ?off) stpb = (start_of ly e, lb, rb)\n             \\<and>  dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp lb rb.\n     steps (Suc (start_of ly as) + 2 * n, la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp =\n     (start_of ly e, lb, rb) \\<and>\n     dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpb lb rb.\n        steps (Suc (start_of ly as) + 2 * n, la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n        (start_of ly e, lb, rb) \\<and>\n        dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb)\n         ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps (Suc (start_of ly as) + 2 * n, la, ra)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n  (start_of ly e, lb, rb) \\<and>\n  dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "from a b"], ["proof (chain)\npicking this:\n  steps (start_of ly as + 2 * n, l, r)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpa =\n  (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\n  steps (Suc (start_of ly as) + 2 * n, la, ra)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n  (start_of ly e, lb, rb) \\<and>\n  dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires", "show \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e))) \n    (steps (start_of ly as + 2 * n, l, r) (?P, ?off) stp) ires\""], ["proof (prove)\nusing this:\n  steps (start_of ly as + 2 * n, l, r)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpa =\n  (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n  inv_locate_b (as, lm) (n, la, ra) ires\n  steps (Suc (start_of ly as) + 2 * n, la, ra)\n   (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n  (start_of ly e, lb, rb) \\<and>\n  dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "apply(rule_tac x = \"stpa + stpb\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (start_of ly as + 2 * n, l, r)\n              (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0)\n              stpa =\n             (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n             inv_locate_b (as, lm) (n, la, ra) ires;\n     steps (Suc (start_of ly as) + 2 * n, la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n     (start_of ly e, lb, rb) \\<and>\n     dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\\<rbrakk>\n    \\<Longrightarrow> 0 < stpa + stpb \\<and>\n                      crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n                       (steps (start_of ly as + 2 * n, l, r)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0)\n                         (stpa + stpb))\n                       ires", "using dec_0"], ["proof (prove)\nusing this:\n  abc_lm_v lm n = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (start_of ly as + 2 * n, l, r)\n              (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0)\n              stpa =\n             (Suc (start_of ly as) + 2 * n, la, ra) \\<and>\n             inv_locate_b (as, lm) (n, la, ra) ires;\n     steps (Suc (start_of ly as) + 2 * n, la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n     (start_of ly e, lb, rb) \\<and>\n     dec_inv_1 ly n e (as, lm) (start_of ly e, lb, rb) ires\\<rbrakk>\n    \\<Longrightarrow> 0 < stpa + stpb \\<and>\n                      crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n                       (steps (start_of ly as + 2 * n, l, r)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0)\n                         (stpa + stpb))\n                       ires", "apply(simp add: dec_inv_1.simps )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (start_of ly as + 2 * n, l, r)\n              (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0)\n              stpa =\n             (Suc (start_of ly as + 2 * n), la, ra) \\<and>\n             inv_locate_b (as, lm) (n, la, ra) ires;\n     steps (Suc (start_of ly as + 2 * n), la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stpb =\n     (start_of ly e, lb, rb) \\<and>\n     inv_stop (as, abc_lm_s lm n 0) (start_of ly e, lb, rb) ires;\n     abc_lm_v lm n = 0\\<rbrakk>\n    \\<Longrightarrow> 0 < stpa \\<or> 0 < stpb", "apply(cases stpa, simp_all add: steps.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n      (steps (start_of ly as + 2 * n, l, r)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n      ires\n\ngoal:\nNo subgoals!", "qed"], ["", "fun dec_inv_2 :: \"layout \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> dec_inv_t\"\n  where\n    \"dec_inv_2 ly n e (as, am) (s, l, r) ires =\n           (let ss = start_of ly as in\n            let am' = abc_lm_s am n (abc_lm_v am n - Suc 0) in\n            let am'' = abc_lm_s am n (abc_lm_v am n) in\n              if s = 0 then False\n              else if s = ss + 2 * n then \n                      inv_locate_a (as, am) (n, l, r) ires\n              else if s = ss + 2 * n + 1 then \n                      inv_locate_n_b (as, am) (n, l, r) ires\n              else if s = ss + 2 * n + 2 then \n                      dec_first_on_right_moving n (as, am'') (s, l, r) ires\n              else if s = ss + 2 * n + 3 then \n                      dec_after_clear (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 4 then \n                      dec_right_move (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 5 then \n                      dec_check_right_move (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 6 then \n                      dec_left_move (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 7 then \n                      dec_after_write (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 8 then \n                      dec_on_right_moving (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 9 then \n                      dec_after_clear (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 10 then \n                      inv_on_left_moving (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 11 then \n                      inv_check_left_moving (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 12 then \n                      inv_after_left_moving (as, am') (s, l, r) ires\n              else if s = ss + 2 * n + 16 then \n                      inv_stop (as, am') (s, l, r) ires\n              else False)\""], ["", "declare dec_inv_2.simps[simp del]"], ["", "fun abc_dec_2_stage1 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_2_stage1 (s, l, r) ss n = \n              (if s \\<le> ss + 2*n + 1 then 7\n               else if s = ss + 2*n + 2 then 6 \n               else if s = ss + 2*n + 3 then 5\n               else if s \\<ge> ss + 2*n + 4 \\<and> s \\<le> ss + 2*n + 9 then 4\n               else if s = ss + 2*n + 6 then 3\n               else if s = ss + 2*n + 10 \\<or> s = ss + 2*n + 11 then 2\n               else if s = ss + 2*n + 12 then 1\n               else 0)\""], ["", "fun abc_dec_2_stage2 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_2_stage2 (s, l, r) ss n = \n       (if s \\<le> ss + 2 * n + 1 then (ss + 2 * n + 16 - s)\n        else if s = ss + 2*n + 10 then length l\n        else if s = ss + 2*n + 11 then length l\n        else if s = ss + 2*n + 4 then length r - 1\n        else if s = ss + 2*n + 5 then length r \n        else if s = ss + 2*n + 7 then length r - 1\n        else if s = ss + 2*n + 8 then  \n              length r + length (takeWhile (\\<lambda> a. a = Oc) l) - 1\n        else if s = ss + 2*n + 9 then \n              length r + length (takeWhile (\\<lambda> a. a = Oc) l) - 1\n        else 0)\""], ["", "fun abc_dec_2_stage3 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_2_stage3 (s, l, r) ss n  =\n        (if s \\<le> ss + 2*n + 1 then \n            if (s - ss) mod 2 = 0 then if r \\<noteq> [] \\<and> \n                                          hd r = Oc then 0 else 1  \n            else length r\n         else if s = ss + 2 * n + 10 then \n             if  r \\<noteq> [] \\<and> hd r = Oc then 2\n             else 1\n         else if s = ss + 2 * n + 11 then \n             if r \\<noteq> [] \\<and> hd r = Oc then 3 \n             else 0 \n         else (ss + 2 * n + 16 - s))\""], ["", "fun abc_dec_2_stage4 :: \"config \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"abc_dec_2_stage4 (s, l, r) ss n = \n          (if s = ss + 2*n + 2 then length r\n           else if s = ss + 2*n + 8 then length r\n           else if s = ss + 2*n + 3 then \n               if r \\<noteq> [] \\<and> hd r = Oc then 1\n               else 0\n           else if s = ss + 2*n + 7 then \n               if r \\<noteq> [] \\<and> hd r = Oc then 0 \n               else 1\n           else if s = ss + 2*n + 9 then \n               if r \\<noteq> [] \\<and> hd r = Oc then 1\n               else 0 \n           else 0)\""], ["", "fun abc_dec_2_measure :: \"(config \\<times> nat \\<times> nat) \\<Rightarrow> (nat \\<times> nat \\<times> nat \\<times> nat)\"\n  where\n    \"abc_dec_2_measure (c, ss, n) = \n  (abc_dec_2_stage1 c ss n, \n  abc_dec_2_stage2 c ss n, abc_dec_2_stage3 c ss n,  abc_dec_2_stage4 c ss n)\""], ["", "definition lex_square:: \n  \"((nat \\<times> nat \\<times> nat \\<times> nat) \\<times> (nat \\<times> nat \\<times> nat \\<times> nat)) set\"\n  where \"lex_square \\<equiv> less_than <*lex*> lex_triple\""], ["", "definition abc_dec_2_LE ::\n  \"((config \\<times> nat \\<times>\n  nat) \\<times> (config \\<times> nat \\<times> nat)) set\"\n  where \"abc_dec_2_LE \\<equiv> (inv_image lex_square abc_dec_2_measure)\""], ["", "lemma wf_dec2_le: \"wf abc_dec_2_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf abc_dec_2_LE", "by(auto simp:abc_dec_2_LE_def lex_square_def lex_triple_def lex_pair_def)"], ["", "lemma fix_add: \"fetch ap ((x::nat) + 2*n) b = fetch ap (2*n + x) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fetch ap (x + 2 * n) b = fetch ap (2 * n + x) b", "using Suc_1 add.commute"], ["proof (prove)\nusing this:\n  Suc 1 = 2\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. fetch ap (x + 2 * n) b = fetch ap (2 * n + x) b", "by metis"], ["", "lemma inv_locate_n_b_Bk_elim[elim]: \n  \"\\<lbrakk>0 < abc_lm_v am n; inv_locate_n_b (as, am) (n, aaa, Bk # xs) ires\\<rbrakk> \n \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     inv_locate_n_b (as, am) (n, aaa, Bk # xs) ires\\<rbrakk>\n    \\<Longrightarrow> RR", "by(auto simp:gr0_conv_Suc inv_locate_n_b.simps abc_lm_v.simps split: if_splits)"], ["", "lemma inv_locate_n_b_nonemptyE[elim]:\n  \"\\<lbrakk>0 < abc_lm_v am n; inv_locate_n_b (as, am) \n                                (n, aaa, []) ires\\<rbrakk> \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     inv_locate_n_b (as, am) (n, aaa, []) ires\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(auto simp: inv_locate_n_b.simps abc_lm_v.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_Ocs_dec_after_write[simp]: \"dec_after_write (as, am) (s, aa, r) ires\n           \\<Longrightarrow> takeWhile (\\<lambda>a. a = Oc) aa = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_write (as, am) (s, aa, r) ires \\<Longrightarrow>\n    takeWhile (\\<lambda>a. a = Oc) aa = []", "apply(simp only : dec_after_write.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       ml = Suc m \\<and>\n       lm2 \\<noteq> [] \\<and>\n       (if lm1 = [] then aa = Bk # Oc \\<up> ml @ Bk # Bk # ires\n        else aa =\n             Bk # Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       tl r = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n    takeWhile (\\<lambda>a. a = Oc) aa = []", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       am = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       ml = Suc m \\<and>\n       lm2 \\<noteq> [] \\<and>\n       (if lm1 = [] then aa = Bk # Oc \\<up> ml @ Bk # Bk # ires\n        else aa =\n             Bk # Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       tl r = <lm2> @ Bk \\<up> rn \\<Longrightarrow>\n       takeWhile (\\<lambda>a. a = Oc) aa = []", "apply(erule_tac conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>am = lm1 @ [m] @ lm2; ml + mr = Suc m; ml = Suc m;\n        lm2 \\<noteq> [];\n        if lm1 = [] then aa = Bk # Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Bk # Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        tl r = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> takeWhile (\\<lambda>a. a = Oc) aa = []", "apply(cases aa, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn a list.\n       \\<lbrakk>am = lm1 @ [m] @ lm2; ml + mr = Suc m; ml = Suc m;\n        lm2 \\<noteq> [];\n        if lm1 = [] then aa = Bk # Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Bk # Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        tl r = <lm2> @ Bk \\<up> rn; aa = a # list\\<rbrakk>\n       \\<Longrightarrow> takeWhile (\\<lambda>a. a = Oc) aa = []", "apply(cases \"hd aa\", simp only: takeWhile.simps , simp_all split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fewer_Ocs_dec_on_right_moving[simp]: \n  \"\\<lbrakk>dec_on_right_moving (as, lm) (s, aa, []) ires; \n       length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \n           \\<noteq> length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) < \n                       length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dec_on_right_moving (as, lm) (s, aa, []) ires;\n     length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \\<noteq>\n     length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa))\n                      < length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0", "apply(simp only: dec_on_right_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>lm1 lm2 m ml mr rn.\n                lm = lm1 @ [m] @ lm2 \\<and>\n                ml + mr = Suc (Suc m) \\<and>\n                (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 [] = Oc \\<up> mr \\<and> lm2 = []);\n     length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \\<noteq>\n     length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa))\n                      < length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \\<noteq>\n                length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0;\n        lm = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc (Suc m) \\<and>\n        (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n         else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        ([] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         [] = Oc \\<up> mr \\<and> lm2 = [])\\<rbrakk>\n       \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa))\n                         < length (takeWhile (\\<lambda>a. a = Oc) aa) -\n                           Suc 0", "apply(erule_tac conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \\<noteq>\n                length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0;\n        lm = lm1 @ [m] @ lm2; ml + mr = Suc (Suc m);\n        if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        [] = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        [] = Oc \\<up> mr \\<and> lm2 = []\\<rbrakk>\n       \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa))\n                         < length (takeWhile (\\<lambda>a. a = Oc) aa) -\n                           Suc 0", "apply(rename_tac lm1 lm2 m ml Mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml Mr rn.\n       \\<lbrakk>length (takeWhile (\\<lambda>a. a = Oc) (tl aa)) \\<noteq>\n                length (takeWhile (\\<lambda>a. a = Oc) aa) - Suc 0;\n        lm = lm1 @ [m] @ lm2; ml + Mr = Suc (Suc m);\n        if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        [] = Oc \\<up> Mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n        [] = Oc \\<up> Mr \\<and> lm2 = []\\<rbrakk>\n       \\<Longrightarrow> length (takeWhile (\\<lambda>a. a = Oc) (tl aa))\n                         < length (takeWhile (\\<lambda>a. a = Oc) aa) -\n                           Suc 0", "apply(case_tac Mr, auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma more_Ocs_dec_after_clear[simp]: \n  \"dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0)) \n             (start_of (layout_of aprog) as + 2 * n + 9, aa, Bk # xs) ires\n \\<Longrightarrow> length xs - Suc 0 < length xs + \n                             length (takeWhile (\\<lambda>a. a = Oc) aa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n     (start_of (layout_of aprog) as + 2 * n + 9, aa, Bk # xs)\n     ires \\<Longrightarrow>\n    length xs - Suc 0\n    < length xs + length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(simp only: dec_after_clear.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lm1 lm2 m ml mr rn.\n       abc_lm_s am n (abc_lm_v am n - Suc 0) = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       ml = Suc m \\<and>\n       Bk # xs \\<noteq> [] \\<and>\n       Bk # xs \\<noteq> [] \\<and>\n       (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (tl (Bk # xs) = Bk # <lm2> @ Bk \\<up> rn \\<or>\n        tl (Bk # xs) = [] \\<and> lm2 = []) \\<Longrightarrow>\n    length xs - Suc 0\n    < length xs + length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       abc_lm_s am n (abc_lm_v am n - Suc 0) = lm1 @ [m] @ lm2 \\<and>\n       ml + mr = Suc m \\<and>\n       ml = Suc m \\<and>\n       Bk # xs \\<noteq> [] \\<and>\n       Bk # xs \\<noteq> [] \\<and>\n       (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n       (tl (Bk # xs) = Bk # <lm2> @ Bk \\<up> rn \\<or>\n        tl (Bk # xs) = [] \\<and> lm2 = []) \\<Longrightarrow>\n       length xs - Suc 0\n       < length xs + length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>abc_lm_s am n (abc_lm_v am n - Suc 0) = lm1 @ [m] @ lm2;\n        ml + mr = Suc m; ml = Suc m; Bk # xs \\<noteq> [];\n        Bk # xs \\<noteq> [];\n        if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n        else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        tl (Bk # xs) = Bk # <lm2> @ Bk \\<up> rn \\<or>\n        tl (Bk # xs) = [] \\<and> lm2 = []\\<rbrakk>\n       \\<Longrightarrow> length xs - Suc 0\n                         < length xs +\n                           length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(simp split: if_splits )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma more_Ocs_dec_after_clear2[simp]: \n  \"\\<lbrakk>dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n       (start_of (layout_of aprog) as + 2 * n + 9, aa, []) ires\\<rbrakk>\n    \\<Longrightarrow> Suc 0 < length (takeWhile (\\<lambda>a. a = Oc) aa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dec_after_clear (as, abc_lm_s am n (abc_lm_v am n - Suc 0))\n     (start_of (layout_of aprog) as + 2 * n + 9, aa, [])\n     ires \\<Longrightarrow>\n    Suc 0 < length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(simp add: dec_after_clear.simps split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_check_left_moving_nonemptyE[elim]: \n  \"inv_check_left_moving (as, lm) (s, [], Oc # xs) ires\n \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_check_left_moving (as, lm) (s, [], Oc # xs) ires \\<Longrightarrow>\n    RR", "apply(simp add: inv_check_left_moving.simps inv_check_left_moving_in_middle.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_n_b_Oc_via_at_begin_norm[simp]:\n  \"\\<lbrakk>0 < abc_lm_v am n; \n  at_begin_norm (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n  \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     at_begin_norm (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n    \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires", "apply(simp only: at_begin_norm.simps inv_locate_n_b.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     \\<exists>lm1 lm2 rn.\n        am = lm1 @ lm2 \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                         am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                         length lm1 = n \\<and>\n                         m + 1 = ml + mr \\<and>\n                         ml = 1 \\<and>\n                         tn = n + 1 - length am \\<and>\n                         (if lm1 = []\n                          then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                          else Oc # aaa =\n                               Oc \\<up> ml @\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (xs =\n                          Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>0 < abc_lm_v am n;\n        am = lm1 @ lm2 \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                            am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                            length lm1 = n \\<and>\n                            m + 1 = ml + mr \\<and>\n                            ml = 1 \\<and>\n                            tn = n + 1 - length am \\<and>\n                            (if lm1 = []\n                             then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (xs =\n                             Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rename_tac lm1 lm2 rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>0 < abc_lm_v am n;\n        am = lm1 @ lm2 \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                            am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                            length lm1 = n \\<and>\n                            m + 1 = ml + mr \\<and>\n                            ml = 1 \\<and>\n                            tn = n + 1 - length am \\<and>\n                            (if lm1 = []\n                             then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (xs =\n                             Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rule_tac x = lm1 in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn.\n       \\<lbrakk>0 < abc_lm_v (lm1 @ lm2) n;\n        am = lm1 @ lm2 \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm2a m.\n                            lm2 @ 0 \\<up> (Suc 0 - length lm2) =\n                            m # lm2a \\<and>\n                            ((\\<exists>rn.\n                                 xs =\n                                 Oc \\<up> m @\n                                 Bk # <lm2a> @ Bk \\<up> rn) \\<or>\n                             lm2a = [] \\<and> xs = Oc \\<up> m)", "apply(case_tac \"length lm2\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn nat.\n       \\<lbrakk>0 < abc_lm_v (lm1 @ lm2) n;\n        am = lm1 @ lm2 \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <lm2> @ Bk \\<up> rn;\n        length lm2 = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm2a m.\n                            lm2 @ 0 \\<up> (Suc 0 - length lm2) =\n                            m # lm2a \\<and>\n                            ((\\<exists>rn.\n                                 xs =\n                                 Oc \\<up> m @\n                                 Bk # <lm2a> @ Bk \\<up> rn) \\<or>\n                             lm2a = [] \\<and> xs = Oc \\<up> m)", "apply(case_tac \"lm2\", simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 rn nat a list.\n       \\<lbrakk>0 < abc_lm_v (lm1 @ a # list) n;\n        am = lm1 @ a # list \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = <a # list> @ Bk \\<up> rn;\n        length list = nat; lm2 = a # list\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>rn.\n                             xs =\n                             Oc \\<up> a @ Bk # <list> @ Bk \\<up> rn) \\<or>\n                         list = [] \\<and> xs = Oc \\<up> a", "apply(case_tac \"lm2\", auto simp: tape_of_nl_cons split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_n_b_Oc_via_at_begin_fst_awtn[simp]: \n  \"\\<lbrakk>0 < abc_lm_v am n; \n   at_begin_fst_awtn (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     at_begin_fst_awtn (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n    \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires", "apply(simp only: at_begin_fst_awtn.simps inv_locate_n_b.simps )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     \\<exists>lm1 tn rn.\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                         am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                         length lm1 = n \\<and>\n                         m + 1 = ml + mr \\<and>\n                         ml = 1 \\<and>\n                         tn = n + 1 - length am \\<and>\n                         (if lm1 = []\n                          then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                          else Oc # aaa =\n                               Oc \\<up> ml @\n                               Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                         (xs =\n                          Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                          lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n;\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                            am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                            length lm1 = n \\<and>\n                            m + 1 = ml + mr \\<and>\n                            ml = 1 \\<and>\n                            tn = n + 1 - length am \\<and>\n                            (if lm1 = []\n                             then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (xs =\n                             Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rename_tac lm1 tn rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n;\n        lm1 = am @ 0 \\<up> tn \\<and>\n        length lm1 = n \\<and>\n        (if lm1 = [] then aaa = Bk # Bk # ires\n         else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        Oc # xs = [Oc] @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                            am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                            length lm1 = n \\<and>\n                            m + 1 = ml + mr \\<and>\n                            ml = 1 \\<and>\n                            tn = n + 1 - length am \\<and>\n                            (if lm1 = []\n                             then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (xs =\n                             Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n; lm1 = am @ 0 \\<up> tn; length lm1 = n;\n        if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = [Oc] @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lm1 lm2 tn m ml mr rn.\n                            am @ 0 \\<up> tn = lm1 @ [m] @ lm2 \\<and>\n                            length lm1 = n \\<and>\n                            m + 1 = ml + mr \\<and>\n                            ml = 1 \\<and>\n                            tn = n + 1 - length am \\<and>\n                            (if lm1 = []\n                             then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (xs =\n                             Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                             lm2 = [] \\<and> xs = Oc \\<up> mr)", "apply(rule_tac x = lm1 in exI, rule_tac x = \"[]\" in exI, \n      rule_tac x = \"Suc tn\" in exI, rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n; lm1 = am @ 0 \\<up> tn; length lm1 = n;\n        if lm1 = [] then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        Oc # xs = [Oc] @ Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ml mr rn.\n                            am @ 0 \\<up> Suc tn = lm1 @ [0] @ [] \\<and>\n                            length lm1 = n \\<and>\n                            0 + 1 = ml + mr \\<and>\n                            ml = 1 \\<and>\n                            Suc tn = n + 1 - length am \\<and>\n                            (if lm1 = []\n                             then Oc # aaa = Oc \\<up> ml @ Bk # Bk # ires\n                             else Oc # aaa =\n                                  Oc \\<up> ml @\n                                  Bk # <rev lm1> @ Bk # Bk # ires) \\<and>\n                            (xs =\n                             Oc \\<up> mr @ [Bk] @ <[]> @ Bk \\<up> rn \\<or>\n                             [] = [] \\<and> xs = Oc \\<up> mr)", "apply(simp add: exp_ind del: replicate.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n; lm1 = am @ 0 \\<up> tn;\n        length am + tn = n;\n        if am = [] \\<and> tn = 0 then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        xs = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> (am = [] \\<and> tn = 0 \\<longrightarrow>\n                          n = 0 \\<and>\n                          ((\\<exists>rna.\n                               Bk \\<up> rn =\n                               Oc \\<up> 0 @ Bk # Bk \\<up> rna) \\<or>\n                           rn = 0)) \\<and>\n                         ((am = [] \\<longrightarrow>\n                           0 < tn) \\<longrightarrow>\n                          Suc tn = Suc n - length am \\<and>\n                          ((\\<exists>rna.\n                               Bk \\<up> rn =\n                               Oc \\<up> 0 @ Bk # Bk \\<up> rna) \\<or>\n                           rn = 0))", "apply(rule conjI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n; lm1 = am @ 0 \\<up> tn;\n        length am + tn = n;\n        if am = [] \\<and> tn = 0 then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        xs = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> am = [] \\<and> tn = 0 \\<longrightarrow>\n                         n = 0 \\<and>\n                         ((\\<exists>rna.\n                              Bk \\<up> rn =\n                              Oc \\<up> 0 @ Bk # Bk \\<up> rna) \\<or>\n                          rn = 0)\n 2. \\<And>lm1 tn rn.\n       \\<lbrakk>0 < abc_lm_v am n; lm1 = am @ 0 \\<up> tn;\n        length am + tn = n;\n        if am = [] \\<and> tn = 0 then aaa = Bk # Bk # ires\n        else aaa = [Bk] @ <rev lm1> @ Bk # Bk # ires;\n        xs = Bk \\<up> rn\\<rbrakk>\n       \\<Longrightarrow> (am = [] \\<longrightarrow>\n                          0 < tn) \\<longrightarrow>\n                         Suc tn = Suc n - length am \\<and>\n                         ((\\<exists>rna.\n                              Bk \\<up> rn =\n                              Oc \\<up> 0 @ Bk # Bk \\<up> rna) \\<or>\n                          rn = 0)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_locate_n_b_Oc_via_inv_locate_n_a[simp]: \n  \"\\<lbrakk>0 < abc_lm_v am n; inv_locate_a (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc#aaa, xs) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < abc_lm_v am n;\n     inv_locate_a (as, am) (n, aaa, Oc # xs) ires\\<rbrakk>\n    \\<Longrightarrow> inv_locate_n_b (as, am) (n, Oc # aaa, xs) ires", "apply(auto simp: inv_locate_a.simps at_begin_fst_bwtn.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma more_Oc_dec_on_right_moving[simp]: \n  \"\\<lbrakk>dec_on_right_moving (as, am) (s, aa, Bk # xs) ires; \n   Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa)))\n   \\<noteq> length (takeWhile (\\<lambda>a. a = Oc) aa)\\<rbrakk>\n  \\<Longrightarrow> Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa))) \n    < length (takeWhile (\\<lambda>a. a = Oc) aa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dec_on_right_moving (as, am) (s, aa, Bk # xs) ires;\n     Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa))) \\<noteq>\n     length (takeWhile (\\<lambda>a. a = Oc) aa)\\<rbrakk>\n    \\<Longrightarrow> Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa)))\n                      < length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(simp only: dec_on_right_moving.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>lm1 lm2 m ml mr rn.\n                am = lm1 @ [m] @ lm2 \\<and>\n                ml + mr = Suc (Suc m) \\<and>\n                (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n                 else aa =\n                      Oc \\<up> ml @\n                      [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n                (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n                 Bk # xs = Oc \\<up> mr \\<and> lm2 = []);\n     Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa))) \\<noteq>\n     length (takeWhile (\\<lambda>a. a = Oc) aa)\\<rbrakk>\n    \\<Longrightarrow> Suc (length (takeWhile (\\<lambda>a. a = Oc) (tl aa)))\n                      < length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(erule exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>Suc (length\n                      (takeWhile (\\<lambda>a. a = Oc) (tl aa))) \\<noteq>\n                length (takeWhile (\\<lambda>a. a = Oc) aa);\n        am = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc (Suc m) \\<and>\n        (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n         else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         Bk # xs = Oc \\<up> mr \\<and> lm2 = [])\\<rbrakk>\n       \\<Longrightarrow> Suc (length\n                               (takeWhile (\\<lambda>a. a = Oc) (tl aa)))\n                         < length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(rename_tac ml mr rn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lm1 lm2 m ml mr rn.\n       \\<lbrakk>Suc (length\n                      (takeWhile (\\<lambda>a. a = Oc) (tl aa))) \\<noteq>\n                length (takeWhile (\\<lambda>a. a = Oc) aa);\n        am = lm1 @ [m] @ lm2 \\<and>\n        ml + mr = Suc (Suc m) \\<and>\n        (if lm1 = [] then aa = Oc \\<up> ml @ Bk # Bk # ires\n         else aa = Oc \\<up> ml @ [Bk] @ <rev lm1> @ Bk # Bk # ires) \\<and>\n        (Bk # xs = Oc \\<up> mr @ [Bk] @ <lm2> @ Bk \\<up> rn \\<or>\n         Bk # xs = Oc \\<up> mr \\<and> lm2 = [])\\<rbrakk>\n       \\<Longrightarrow> Suc (length\n                               (takeWhile (\\<lambda>a. a = Oc) (tl aa)))\n                         < length (takeWhile (\\<lambda>a. a = Oc) aa)", "apply(case_tac ml, auto split: if_splits )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_dec_b_suc_pre:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and inv_start: \"inv_locate_a (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and dec_suc: \"0 < abc_lm_v lm n\"\n    and f: \"f = (\\<lambda> stp. (steps (start_of ly as + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), \n            start_of ly as - Suc 0) stp, start_of ly as, n))\"\n    and P: \"P = (\\<lambda> ((s, l, r), ss, x). s = start_of ly as + 2*n + 16)\"\n    and Q: \"Q = (\\<lambda> ((s, l, r), ss, x). dec_inv_2 ly x e (as, lm) (s, l, r) ires)\"\n  shows \"\\<exists> stp. P (f stp) \\<and> Q(f stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. P (f stp) \\<and> Q (f stp)", "proof(rule_tac LE = abc_dec_2_LE in halt_lemma2)"], ["proof (state)\ngoal (4 subgoals):\n 1. wf abc_dec_2_LE\n 2. Q (f 0)\n 3. \\<not> P (f 0)\n 4. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "show \"wf abc_dec_2_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf abc_dec_2_LE", "by(intro wf_dec2_le)"], ["proof (state)\nthis:\n  wf abc_dec_2_LE\n\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Q (f 0)\n 2. \\<not> P (f 0)\n 3. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "show \"Q (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (f 0)", "using layout fetch inv_start"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  abc_fetch as ap = Some (Dec n e)\n  inv_locate_a (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. Q (f 0)", "apply(simp add: f steps.simps Q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Dec n e);\n     inv_locate_a (as, lm) (n, la, ra) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 (layout_of ap) n e (as, lm)\n                       (start_of (layout_of ap) as + 2 * n, la, ra) ires", "apply(simp only: dec_inv_2.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; abc_fetch as ap = Some (Dec n e);\n     inv_locate_a (as, lm) (n, la, ra) ires\\<rbrakk>\n    \\<Longrightarrow> let ss = start_of (layout_of ap) as;\n                          am' = abc_lm_s lm n (abc_lm_v lm n - Suc 0);\n                          am'' = abc_lm_s lm n (abc_lm_v lm n)\n                      in if start_of (layout_of ap) as + 2 * n = 0\n                         then False\n                         else if start_of (layout_of ap) as + 2 * n =\n                                 ss + 2 * n\n                              then True\n                              else if start_of (layout_of ap) as + 2 * n =\nss + 2 * n + 1\n                                   then inv_locate_n_b (as, lm) (n, la, ra)\n   ires\n                                   else if start_of (layout_of ap) as +\n     2 * n =\n     ss + 2 * n + 2\n  then dec_first_on_right_moving n (as, am'')\n        (start_of (layout_of ap) as + 2 * n, la, ra) ires\n  else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 3\n       then dec_after_clear (as, am')\n             (start_of (layout_of ap) as + 2 * n, la, ra) ires\n       else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 4\n            then dec_right_move (as, am')\n                  (start_of (layout_of ap) as + 2 * n, la, ra) ires\n            else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 5\n                 then dec_check_right_move (as, am')\n                       (start_of (layout_of ap) as + 2 * n, la, ra) ires\n                 else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 6\n                      then dec_left_move (as, am')\n                            (start_of (layout_of ap) as + 2 * n, la, ra)\n                            ires\n                      else if start_of (layout_of ap) as + 2 * n =\n                              ss + 2 * n + 7\n                           then dec_after_write (as, am')\n                                 (start_of (layout_of ap) as + 2 * n, la,\n                                  ra)\n                                 ires\n                           else if start_of (layout_of ap) as + 2 * n =\n                                   ss + 2 * n + 8\n                                then dec_on_right_moving (as, am')\n(start_of (layout_of ap) as + 2 * n, la, ra) ires\n                                else if start_of (layout_of ap) as + 2 * n =\n  ss + 2 * n + 9\n                                     then dec_after_clear (as, am')\n     (start_of (layout_of ap) as + 2 * n, la, ra) ires\n                                     else if start_of (layout_of ap) as +\n       2 * n =\n       ss + 2 * n + 10\n    then inv_on_left_moving (as, am')\n          (start_of (layout_of ap) as + 2 * n, la, ra) ires\n    else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 11\n         then inv_check_left_moving (as, am')\n               (start_of (layout_of ap) as + 2 * n, la, ra) ires\n         else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 12\n              then inv_after_left_moving (as, am')\n                    (start_of (layout_of ap) as + 2 * n, la, ra) ires\n              else if start_of (layout_of ap) as + 2 * n = ss + 2 * n + 16\n                   then inv_stop (as, am')\n                         (start_of (layout_of ap) as + 2 * n, la, ra) ires\n                   else False", "apply(auto simp: Let_def start_of_ge start_of_less inv_start dec_inv_2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (f 0)\n\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> P (f 0)\n 2. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "show \"\\<not> P (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "using layout fetch"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<not> P (f 0)", "apply(simp add: f steps.simps P)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<not> P (f 0)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "show \"\\<forall>n. \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow> Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "using fetch"], ["proof (prove)\nusing this:\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n       Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE", "proof(rule_tac allI, rule_tac impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n        abc_fetch as ap = Some (Dec n e);\n        \\<not> P (f na) \\<and> Q (f na)\\<rbrakk>\n       \\<Longrightarrow> Q (f (Suc na)) \\<and>\n                         (f (Suc na), f na) \\<in> abc_dec_2_LE", "fix na"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n        abc_fetch as ap = Some (Dec n e);\n        \\<not> P (f na) \\<and> Q (f na)\\<rbrakk>\n       \\<Longrightarrow> Q (f (Suc na)) \\<and>\n                         (f (Suc na), f na) \\<in> abc_dec_2_LE", "assume \"\\<not> P (f na) \\<and> Q (f na)\""], ["proof (state)\nthis:\n  \\<not> P (f na) \\<and> Q (f na)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>abc_fetch as ap = Some (Dec n e);\n        abc_fetch as ap = Some (Dec n e);\n        \\<not> P (f na) \\<and> Q (f na)\\<rbrakk>\n       \\<Longrightarrow> Q (f (Suc na)) \\<and>\n                         (f (Suc na), f na) \\<in> abc_dec_2_LE", "thus \"Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> abc_dec_2_LE\""], ["proof (prove)\nusing this:\n  \\<not> P (f na) \\<and> Q (f na)\n\ngoal (1 subgoal):\n 1. Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> abc_dec_2_LE", "apply(simp add: f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P (steps (start_of ly as + 2 * n, la, ra)\n               (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0)\n               na,\n              start_of ly as, n) \\<and>\n    Q (steps (start_of ly as + 2 * n, la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na,\n       start_of ly as, n) \\<Longrightarrow>\n    Q (step\n        (steps (start_of ly as + 2 * n, la, ra)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n       start_of ly as, n) \\<and>\n    ((step\n       (steps (start_of ly as + 2 * n, la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n      start_of ly as, n),\n     steps (start_of ly as + 2 * n, la, ra)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na,\n     start_of ly as, n)\n    \\<in> abc_dec_2_LE", "apply(cases \"steps ((start_of ly as + 2 * n), la, ra)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (start_of ly as + 2 * n, la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_2_LE", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (start_of ly as + 2 * n, la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_2_LE", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (start_of ly as + 2 * n, la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_2_LE", "assume \"\\<not> P ((a, b, c), start_of ly as, n) \\<and> Q ((a, b, c), start_of ly as, n)\""], ["proof (state)\nthis:\n  \\<not> P ((a, b, c), start_of ly as, n) \\<and>\n  Q ((a, b, c), start_of ly as, n)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n) \\<and>\n                Q ((a, b, c), start_of ly as, n);\n        steps (start_of ly as + 2 * n, la, ra)\n         (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) na =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> Q (step (a, b, c)\n                             (ci ly (start_of ly as) (Dec n e),\n                              start_of ly as - Suc 0),\n                            start_of ly as, n) \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_2_LE", "thus \"Q (step (a, b, c) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0), start_of ly as, n) \\<and>\n               ((step (a, b, c) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0), start_of ly as, n), \n                   (a, b, c), start_of ly as, n) \\<in> abc_dec_2_LE\""], ["proof (prove)\nusing this:\n  \\<not> P ((a, b, c), start_of ly as, n) \\<and>\n  Q ((a, b, c), start_of ly as, n)\n\ngoal (1 subgoal):\n 1. Q (step (a, b, c)\n        (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n       start_of ly as, n) \\<and>\n    ((step (a, b, c)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n      start_of ly as, n),\n     (a, b, c), start_of ly as, n)\n    \\<in> abc_dec_2_LE", "apply(simp add: Q)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P ((a, b, c), start_of ly as, n) \\<and>\n    dec_inv_2 ly n e (as, lm) (a, b, c) ires \\<Longrightarrow>\n    dec_inv_2 ly n e (as, lm)\n     (step (a, b, c)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0))\n     ires \\<and>\n    ((step (a, b, c)\n       (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n      start_of ly as, n),\n     (a, b, c), start_of ly as, n)\n    \\<in> abc_dec_2_LE", "apply(erule_tac conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n);\n     dec_inv_2 ly n e (as, lm) (a, b, c) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, c), start_of ly as, n)\n                      \\<in> abc_dec_2_LE", "apply(cases c; cases \"hd c\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n);\n     dec_inv_2 ly n e (as, lm) (a, b, c) ires; c = []; hd c = Bk\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, c), start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 2. \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n);\n     dec_inv_2 ly n e (as, lm) (a, b, c) ires; c = []; hd c = Oc\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, c)\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, c), start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 3. \\<And>aa list.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n);\n        dec_inv_2 ly n e (as, lm) (a, b, c) ires; c = aa # list;\n        hd c = Bk\\<rbrakk>\n       \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                          (step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_2_LE\n 4. \\<And>aa list.\n       \\<lbrakk>\\<not> P ((a, b, c), start_of ly as, n);\n        dec_inv_2 ly n e (as, lm) (a, b, c) ires; c = aa # list;\n        hd c = Oc\\<rbrakk>\n       \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                          (step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (a, b, c)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, c), start_of ly as, n)\n                         \\<in> abc_dec_2_LE", "apply(simp_all add: dec_inv_2.simps Let_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> P ((a, b, []), start_of ly as, n);\n     if a = 0 then False\n     else if a = start_of ly as + 2 * n\n          then inv_locate_a (as, lm) (n, b, []) ires\n          else if a = start_of ly as + 2 * n + 1\n               then inv_locate_n_b (as, lm) (n, b, []) ires\n               else if a = start_of ly as + 2 * n + 2\n                    then dec_first_on_right_moving n\n                          (as, abc_lm_s lm n (abc_lm_v lm n)) (a, b, [])\n                          ires\n                    else if a = start_of ly as + 2 * n + 3\n                         then dec_after_clear\n                               (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                               (a, b, []) ires\n                         else if a = start_of ly as + 2 * n + 4\n                              then dec_right_move\n                                    (as,\n                                     abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                    (a, b, []) ires\n                              else if a = start_of ly as + 2 * n + 5\n                                   then dec_check_right_move\n   (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, []) ires\n                                   else if a = start_of ly as + 2 * n + 6\n  then dec_left_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, [])\n        ires\n  else if a = start_of ly as + 2 * n + 7\n       then dec_after_write (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n             (a, b, []) ires\n       else if a = start_of ly as + 2 * n + 8\n            then dec_on_right_moving\n                  (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, [])\n                  ires\n            else if a = start_of ly as + 2 * n + 9\n                 then dec_after_clear\n                       (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                       (a, b, []) ires\n                 else if a = start_of ly as + 2 * n + 10\n                      then inv_on_left_moving\n                            (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                            (a, b, []) ires\n                      else if a = start_of ly as + 2 * n + 11\n                           then inv_check_left_moving\n                                 (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                 (a, b, []) ires\n                           else if a = start_of ly as + 2 * n + 12\n                                then inv_after_left_moving\n(as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, []) ires\n                                else if a = start_of ly as + 2 * n + 16\n                                     then inv_stop\n     (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, []) ires\n                                     else False;\n     c = []; hd [] = Bk\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (a, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, []), start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 2. \\<lbrakk>\\<not> P ((a, b, []), start_of ly as, n);\n     if a = 0 then False\n     else if a = start_of ly as + 2 * n\n          then inv_locate_a (as, lm) (n, b, []) ires\n          else if a = start_of ly as + 2 * n + 1\n               then inv_locate_n_b (as, lm) (n, b, []) ires\n               else if a = start_of ly as + 2 * n + 2\n                    then dec_first_on_right_moving n\n                          (as, abc_lm_s lm n (abc_lm_v lm n)) (a, b, [])\n                          ires\n                    else if a = start_of ly as + 2 * n + 3\n                         then dec_after_clear\n                               (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                               (a, b, []) ires\n                         else if a = start_of ly as + 2 * n + 4\n                              then dec_right_move\n                                    (as,\n                                     abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                    (a, b, []) ires\n                              else if a = start_of ly as + 2 * n + 5\n                                   then dec_check_right_move\n   (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, []) ires\n                                   else if a = start_of ly as + 2 * n + 6\n  then dec_left_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, [])\n        ires\n  else if a = start_of ly as + 2 * n + 7\n       then dec_after_write (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n             (a, b, []) ires\n       else if a = start_of ly as + 2 * n + 8\n            then dec_on_right_moving\n                  (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, [])\n                  ires\n            else if a = start_of ly as + 2 * n + 9\n                 then dec_after_clear\n                       (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                       (a, b, []) ires\n                 else if a = start_of ly as + 2 * n + 10\n                      then inv_on_left_moving\n                            (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                            (a, b, []) ires\n                      else if a = start_of ly as + 2 * n + 11\n                           then inv_check_left_moving\n                                 (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                 (a, b, []) ires\n                           else if a = start_of ly as + 2 * n + 12\n                                then inv_after_left_moving\n(as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, []) ires\n                                else if a = start_of ly as + 2 * n + 16\n                                     then inv_stop\n     (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, []) ires\n                                     else False;\n     c = []; hd [] = Oc\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (a, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (a, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (a, b, []), start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 3. \\<And>aa list.\n       \\<lbrakk>\\<not> P ((a, b, Bk # list), start_of ly as, n);\n        if a = 0 then False\n        else if a = start_of ly as + 2 * n\n             then inv_locate_a (as, lm) (n, b, aa # list) ires\n             else if a = start_of ly as + 2 * n + 1\n                  then inv_locate_n_b (as, lm) (n, b, aa # list) ires\n                  else if a = start_of ly as + 2 * n + 2\n                       then dec_first_on_right_moving n\n                             (as, abc_lm_s lm n (abc_lm_v lm n))\n                             (a, b, aa # list) ires\n                       else if a = start_of ly as + 2 * n + 3\n                            then dec_after_clear\n                                  (as,\n                                   abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                  (a, b, aa # list) ires\n                            else if a = start_of ly as + 2 * n + 4\n                                 then dec_right_move\n (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, aa # list) ires\n                                 else if a = start_of ly as + 2 * n + 5\nthen dec_check_right_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (a, b, aa # list) ires\nelse if a = start_of ly as + 2 * n + 6\n     then dec_left_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n           (a, b, aa # list) ires\n     else if a = start_of ly as + 2 * n + 7\n          then dec_after_write (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                (a, b, aa # list) ires\n          else if a = start_of ly as + 2 * n + 8\n               then dec_on_right_moving\n                     (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                     (a, b, aa # list) ires\n               else if a = start_of ly as + 2 * n + 9\n                    then dec_after_clear\n                          (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                          (a, b, aa # list) ires\n                    else if a = start_of ly as + 2 * n + 10\n                         then inv_on_left_moving\n                               (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                               (a, b, aa # list) ires\n                         else if a = start_of ly as + 2 * n + 11\n                              then inv_check_left_moving\n                                    (as,\n                                     abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                    (a, b, aa # list) ires\n                              else if a = start_of ly as + 2 * n + 12\n                                   then inv_after_left_moving\n   (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, aa # list) ires\n                                   else if a = start_of ly as + 2 * n + 16\n  then inv_stop (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n        (a, b, aa # list) ires\n  else False;\n        c = Bk # list; aa = Bk\\<rbrakk>\n       \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                          (step (a, b, Bk # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (a, b, Bk # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, Bk # list), start_of ly as, n)\n                         \\<in> abc_dec_2_LE\n 4. \\<And>aa list.\n       \\<lbrakk>\\<not> P ((a, b, Oc # list), start_of ly as, n);\n        if a = 0 then False\n        else if a = start_of ly as + 2 * n\n             then inv_locate_a (as, lm) (n, b, aa # list) ires\n             else if a = start_of ly as + 2 * n + 1\n                  then inv_locate_n_b (as, lm) (n, b, aa # list) ires\n                  else if a = start_of ly as + 2 * n + 2\n                       then dec_first_on_right_moving n\n                             (as, abc_lm_s lm n (abc_lm_v lm n))\n                             (a, b, aa # list) ires\n                       else if a = start_of ly as + 2 * n + 3\n                            then dec_after_clear\n                                  (as,\n                                   abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                  (a, b, aa # list) ires\n                            else if a = start_of ly as + 2 * n + 4\n                                 then dec_right_move\n (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, aa # list) ires\n                                 else if a = start_of ly as + 2 * n + 5\nthen dec_check_right_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (a, b, aa # list) ires\nelse if a = start_of ly as + 2 * n + 6\n     then dec_left_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n           (a, b, aa # list) ires\n     else if a = start_of ly as + 2 * n + 7\n          then dec_after_write (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                (a, b, aa # list) ires\n          else if a = start_of ly as + 2 * n + 8\n               then dec_on_right_moving\n                     (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                     (a, b, aa # list) ires\n               else if a = start_of ly as + 2 * n + 9\n                    then dec_after_clear\n                          (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                          (a, b, aa # list) ires\n                    else if a = start_of ly as + 2 * n + 10\n                         then inv_on_left_moving\n                               (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                               (a, b, aa # list) ires\n                         else if a = start_of ly as + 2 * n + 11\n                              then inv_check_left_moving\n                                    (as,\n                                     abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n                                    (a, b, aa # list) ires\n                              else if a = start_of ly as + 2 * n + 12\n                                   then inv_after_left_moving\n   (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) (a, b, aa # list) ires\n                                   else if a = start_of ly as + 2 * n + 16\n  then inv_stop (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n        (a, b, aa # list) ires\n  else False;\n        c = Oc # list; aa = Oc\\<rbrakk>\n       \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                          (step (a, b, Oc # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0))\n                          ires \\<and>\n                         ((step (a, b, Oc # list)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0),\n                           start_of ly as, n),\n                          (a, b, Oc # list), start_of ly as, n)\n                         \\<in> abc_dec_2_LE", "apply(simp_all split: if_splits)"], ["proof (prove)\ngoal (51 subgoals):\n 1. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n;\n     inv_locate_a (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n, b, []), start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 2. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((Suc (start_of ly as + 2 * n), b, []), start_of ly as, n);\n     a = Suc (start_of ly as + 2 * n);\n     inv_locate_n_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (start_of ly as + 2 * n), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 3. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((Suc (Suc (start_of ly as + 2 * n)), b, []), start_of ly as,\n               n);\n     a = Suc (Suc (start_of ly as + 2 * n));\n     dec_first_on_right_moving n (as, abc_lm_s lm n (abc_lm_v lm n))\n      (Suc (Suc (start_of ly as + 2 * n)), b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (Suc (Suc (start_of ly as + 2 * n)), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (Suc (start_of ly as + 2 * n)), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (Suc (start_of ly as + 2 * n)), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 4. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 3, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 3;\n     dec_after_clear (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 3, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 3, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 3, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 3, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 5. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 4, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 4;\n     dec_right_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 4, b, [Bk]) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 4, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 4, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 4, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 6. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 5, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 5;\n     dec_check_right_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 5, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 5, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 5, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 5, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 7. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 6, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 6;\n     dec_left_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 6, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 6, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 6, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 6, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 8. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 7, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 7;\n     dec_after_write (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 7, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 7, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 7, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 7, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 9. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 8, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 8;\n     dec_on_right_moving (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 8, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 8, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 8, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 8, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 10. \\<lbrakk>c = []; hd [] = Bk;\n      \\<not> P ((start_of ly as + 2 * n + 9, b, []), start_of ly as, n);\n      a = start_of ly as + 2 * n + 9;\n      dec_after_clear (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n       (start_of ly as + 2 * n + 9, b, []) ires\\<rbrakk>\n     \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                        (step (start_of ly as + 2 * n + 9, b, [])\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0))\n                        ires \\<and>\n                       ((step (start_of ly as + 2 * n + 9, b, [])\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0),\n                         start_of ly as, n),\n                        (start_of ly as + 2 * n + 9, b, []), start_of ly as,\n                        n)\n                       \\<in> abc_dec_2_LE\nA total of 51 subgoals...", "using fetch layout dec_suc"], ["proof (prove)\nusing this:\n  abc_fetch as ap = Some (Dec n e)\n  ly = layout_of ap\n  0 < abc_lm_v lm n\n\ngoal (51 subgoals):\n 1. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n;\n     inv_locate_a (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n, b, []), start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 2. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((Suc (start_of ly as + 2 * n), b, []), start_of ly as, n);\n     a = Suc (start_of ly as + 2 * n);\n     inv_locate_n_b (as, lm) (n, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (start_of ly as + 2 * n), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (start_of ly as + 2 * n), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 3. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((Suc (Suc (start_of ly as + 2 * n)), b, []), start_of ly as,\n               n);\n     a = Suc (Suc (start_of ly as + 2 * n));\n     dec_first_on_right_moving n (as, abc_lm_s lm n (abc_lm_v lm n))\n      (Suc (Suc (start_of ly as + 2 * n)), b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (Suc (Suc (start_of ly as + 2 * n)), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (Suc (Suc (start_of ly as + 2 * n)), b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (Suc (Suc (start_of ly as + 2 * n)), b, []),\n                       start_of ly as, n)\n                      \\<in> abc_dec_2_LE\n 4. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 3, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 3;\n     dec_after_clear (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 3, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 3, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 3, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 3, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 5. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 4, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 4;\n     dec_right_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 4, b, [Bk]) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 4, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 4, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 4, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 6. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 5, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 5;\n     dec_check_right_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 5, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 5, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 5, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 5, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 7. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 6, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 6;\n     dec_left_move (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 6, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 6, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 6, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 6, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 8. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 7, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 7;\n     dec_after_write (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 7, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 7, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 7, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 7, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 9. \\<lbrakk>c = []; hd [] = Bk;\n     \\<not> P ((start_of ly as + 2 * n + 8, b, []), start_of ly as, n);\n     a = start_of ly as + 2 * n + 8;\n     dec_on_right_moving (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n      (start_of ly as + 2 * n + 8, b, []) ires\\<rbrakk>\n    \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                       (step (start_of ly as + 2 * n + 8, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0))\n                       ires \\<and>\n                      ((step (start_of ly as + 2 * n + 8, b, [])\n                         (ci ly (start_of ly as) (Dec n e),\n                          start_of ly as - Suc 0),\n                        start_of ly as, n),\n                       (start_of ly as + 2 * n + 8, b, []), start_of ly as,\n                       n)\n                      \\<in> abc_dec_2_LE\n 10. \\<lbrakk>c = []; hd [] = Bk;\n      \\<not> P ((start_of ly as + 2 * n + 9, b, []), start_of ly as, n);\n      a = start_of ly as + 2 * n + 9;\n      dec_after_clear (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n       (start_of ly as + 2 * n + 9, b, []) ires\\<rbrakk>\n     \\<Longrightarrow> dec_inv_2 ly n e (as, lm)\n                        (step (start_of ly as + 2 * n + 9, b, [])\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0))\n                        ires \\<and>\n                       ((step (start_of ly as + 2 * n + 9, b, [])\n                          (ci ly (start_of ly as) (Dec n e),\n                           start_of ly as - Suc 0),\n                         start_of ly as, n),\n                        (start_of ly as + 2 * n + 9, b, []), start_of ly as,\n                        n)\n                       \\<in> abc_dec_2_LE\nA total of 51 subgoals...", "apply(auto simp: step.simps P dec_inv_2.simps Let_def abc_dec_2_LE_def lex_triple_def lex_pair_def lex_square_def\n            fix_add numeral_3_eq_3)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q (step (a, b, c)\n      (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n     start_of ly as, n) \\<and>\n  ((step (a, b, c)\n     (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0),\n    start_of ly as, n),\n   (a, b, c), start_of ly as, n)\n  \\<in> abc_dec_2_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q (f (Suc na)) \\<and> (f (Suc na), f na) \\<in> abc_dec_2_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> P (f n) \\<and> Q (f n) \\<longrightarrow>\n     Q (f (Suc n)) \\<and> (f (Suc n), f n) \\<in> abc_dec_2_LE\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crsp_abc_step_l_start_of[simp]: \n  \"\\<lbrakk>inv_stop (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0)) \n  (start_of (layout_of ap) as + 2 * n + 16, a, b) ires;\n   abc_lm_v lm n > 0;\n   abc_fetch as ap = Some (Dec n e)\\<rbrakk>\n  \\<Longrightarrow> crsp (layout_of ap) (abc_step_l (as, lm) (Some (Dec n e))) \n  (start_of (layout_of ap) as + 2 * n + 16, a, b) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_stop (as, abc_lm_s lm n (abc_lm_v lm n - Suc 0))\n              (start_of (layout_of ap) as + 2 * n + 16, a, b) ires;\n     0 < abc_lm_v lm n; abc_fetch as ap = Some (Dec n e)\\<rbrakk>\n    \\<Longrightarrow> crsp (layout_of ap)\n                       (abc_step_l (as, lm) (Some (Dec n e)))\n                       (start_of (layout_of ap) as + 2 * n + 16, a, b) ires", "by(auto simp: inv_stop.simps crsp.simps  abc_step_l.simps startof_Suc2)"], ["", "lemma crsp_step_dec_b_suc:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and inv_start: \"inv_locate_a (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n    and dec_suc: \"0 < abc_lm_v lm n\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n              (steps (start_of ly as + 2 * n, la, ra) (ci (layout_of ap) \n                  (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, la, ra)\n          (ci (layout_of ap) (start_of ly as) (Dec n e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  inv_locate_a (as, lm) (n, la, ra) ires\n  abc_fetch as ap = Some (Dec n e)\n  0 < abc_lm_v lm n\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, la, ra)\n          (ci (layout_of ap) (start_of ly as) (Dec n e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "apply(drule_tac crsp_step_dec_b_suc_pre, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        ly = layout_of ap; inv_locate_a (as, lm) (n, la, ra) ires;\n        abc_fetch as ap = Some (Dec n e); 0 < abc_lm_v lm n;\n        steps (start_of (layout_of ap) as + 2 * n, la, ra)\n         (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n          start_of (layout_of ap) as - Suc 0)\n         stp =\n        (start_of (layout_of ap) as + 2 * n + 16, a, b);\n        dec_inv_2 (layout_of ap) n e (as, lm)\n         (start_of (layout_of ap) as + 2 * n + 16, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Dec n e)))\n                             (steps\n                               (start_of (layout_of ap) as + 2 * n, la, ra)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Dec n e),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires", "apply(rename_tac stp a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        ly = layout_of ap; inv_locate_a (as, lm) (n, la, ra) ires;\n        abc_fetch as ap = Some (Dec n e); 0 < abc_lm_v lm n;\n        steps (start_of (layout_of ap) as + 2 * n, la, ra)\n         (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n          start_of (layout_of ap) as - Suc 0)\n         stp =\n        (start_of (layout_of ap) as + 2 * n + 16, a, b);\n        dec_inv_2 (layout_of ap) n e (as, lm)\n         (start_of (layout_of ap) as + 2 * n + 16, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Dec n e)))\n                             (steps\n                               (start_of (layout_of ap) as + 2 * n, la, ra)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Dec n e),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires", "apply(rule_tac x = stp in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp a b.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        ly = layout_of ap; inv_locate_a (as, lm) (n, la, ra) ires;\n        abc_fetch as ap = Some (Dec n e); 0 < abc_lm_v lm n;\n        steps (start_of (layout_of ap) as + 2 * n, la, ra)\n         (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n          start_of (layout_of ap) as - Suc 0)\n         stp =\n        (start_of (layout_of ap) as + 2 * n + 16, a, b);\n        dec_inv_2 (layout_of ap) n e (as, lm)\n         (start_of (layout_of ap) as + 2 * n + 16, a, b) ires\\<rbrakk>\n       \\<Longrightarrow> 0 < stp \\<and>\n                         crsp (layout_of ap)\n                          (abc_step_l (as, lm) (Some (Dec n e)))\n                          (steps\n                            (start_of (layout_of ap) as + 2 * n, la, ra)\n                            (ci (layout_of ap) (start_of (layout_of ap) as)\n                              (Dec n e),\n                             start_of (layout_of ap) as - Suc 0)\n                            stp)\n                          ires", "apply(case_tac stp, simp_all add: steps.simps dec_inv_2.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_dec_b:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and inv_start: \"inv_locate_a (as, lm) (n, la, ra) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n  (steps (start_of ly as + 2 * n, la, ra) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, la, ra)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  inv_locate_a (as, lm) (n, la, ra) ires\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, la, ra)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "apply(cases \"abc_lm_v lm n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n     inv_locate_a (as, lm) (n, la, ra) ires;\n     abc_fetch as ap = Some (Dec n e); abc_lm_v lm n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp>0.\n                         crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n                          (steps (start_of ly as + 2 * n, la, ra)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0)\n                            stp)\n                          ires\n 2. \\<lbrakk>ly = layout_of ap; crsp ly (as, lm) (s, l, r) ires;\n     inv_locate_a (as, lm) (n, la, ra) ires;\n     abc_fetch as ap = Some (Dec n e); abc_lm_v lm n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp>0.\n                         crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n                          (steps (start_of ly as + 2 * n, la, ra)\n                            (ci ly (start_of ly as) (Dec n e),\n                             start_of ly as - Suc 0)\n                            stp)\n                          ires", "apply(rule_tac crsp_step_dec_b_e, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; crsp (layout_of ap) (as, lm) (s, l, r) ires;\n     inv_locate_a (as, lm) (n, la, ra) ires;\n     abc_fetch as ap = Some (Dec n e); 0 < abc_lm_v lm n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp>0.\n                         crsp (layout_of ap)\n                          (abc_step_l (as, lm) (Some (Dec n e)))\n                          (steps\n                            (start_of (layout_of ap) as + 2 * n, la, ra)\n                            (ci (layout_of ap) (start_of (layout_of ap) as)\n                              (Dec n e),\n                             start_of (layout_of ap) as - Suc 0)\n                            stp)\n                          ires", "apply(rule_tac crsp_step_dec_b_suc, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_dec: \n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some (Dec n e)\"\n  shows \"\\<exists>stp > 0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n  (steps (s, l, r) (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (ci ly (start_of ly as) (Dec n e), start_of ly as - Suc 0) stp)\n        ires", "proof(simp add: ci.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "let ?off = \"start_of ly as - Suc 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "let ?A = \"findnth n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "let ?B = \"adjust (shift (shift tdec_b (2 * n)) ?off) (start_of ly e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "have \"\\<exists> stp la ra. steps (s, l, r) (shift ?A ?off @ ?B, ?off) stp = (start_of ly as + 2*n, la, ra)\n                    \\<and> inv_locate_a (as, lm) (n, la, ra) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "have \"\\<exists>stp l' r'. steps (Suc 0, l, r) (?A, 0) stp = (Suc (2 * n), l', r') \\<and> \n                     inv_locate_a (as, lm) (n, l', r') ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n       inv_locate_a (as, lm) (n, l', r') ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some (Dec n e)\n\ngoal (1 subgoal):\n 1. \\<exists>stp l' r'.\n       steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n       inv_locate_a (as, lm) (n, l', r') ires", "apply(rule_tac findnth_correct, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp l' r'.\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp l' r'.\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires", "obtain stp l' r' where a: \n      \"steps (Suc 0, l, r) (?A, 0) stp = (Suc (2 * n), l', r') \\<and> \n      inv_locate_a (as, lm) (n, l', r') ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp l' r'.\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n     inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. (\\<And>stp l' r'.\n        steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n        inv_locate_a (as, lm) (n, l', r') ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "then"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires", "have \"steps (Suc 0 + ?off, l, r) (shift ?A ?off, ?off) stp = (Suc (2 * n) + ?off, l', r')\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. steps (Suc 0 + (start_of ly as - Suc 0), l, r)\n     (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n     stp =\n    (Suc (2 * n) + (start_of ly as - Suc 0), l', r')", "apply(rule_tac tm_shift_eq_steps, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps (Suc 0 + (start_of ly as - Suc 0), l, r)\n   (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n   stp =\n  (Suc (2 * n) + (start_of ly as - Suc 0), l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "moreover"], ["proof (state)\nthis:\n  steps (Suc 0 + (start_of ly as - Suc 0), l, r)\n   (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n   stp =\n  (Suc (2 * n) + (start_of ly as - Suc 0), l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "have \"s = start_of ly as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = start_of ly as", "using crsp"], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. s = start_of ly as", "apply(auto simp: crsp.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s = start_of ly as\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "ultimately"], ["proof (chain)\npicking this:\n  steps (Suc 0 + (start_of ly as - Suc 0), l, r)\n   (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n   stp =\n  (Suc (2 * n) + (start_of ly as - Suc 0), l', r')\n  s = start_of ly as", "show \"\\<exists> stp la ra. steps (s, l, r) (shift ?A ?off @ ?B, ?off) stp = (start_of ly as + 2*n, la, ra)\n                    \\<and> inv_locate_a (as, lm) (n, la, ra) ires\""], ["proof (prove)\nusing this:\n  steps (Suc 0 + (start_of ly as - Suc 0), l, r)\n   (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n   stp =\n  (Suc (2 * n) + (start_of ly as - Suc 0), l', r')\n  s = start_of ly as\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "using a"], ["proof (prove)\nusing this:\n  steps (Suc 0 + (start_of ly as - Suc 0), l, r)\n   (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n   stp =\n  (Suc (2 * n) + (start_of ly as - Suc 0), l', r')\n  s = start_of ly as\n  steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r') \\<and>\n  inv_locate_a (as, lm) (n, l', r') ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp la ra.\n       steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp =\n       (start_of ly as + 2 * n, la, ra) \\<and>\n       inv_locate_a (as, lm) (n, la, ra) ires", "apply(drule_tac B = ?B in tm_append_first_steps_eq, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (start_of ly as, l, r)\n              (shift (findnth n) (start_of ly as - Suc 0) @\n               adjust\n                (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n                (start_of ly e),\n               start_of ly as - Suc 0)\n              stp =\n             (2 * n + start_of ly as, l', r');\n     steps (start_of ly as, l, r)\n      (shift (findnth n) (start_of ly as - Suc 0), start_of ly as - Suc 0)\n      stp =\n     (2 * n + start_of ly as, l', r');\n     s = start_of ly as;\n     steps0 (Suc 0, l, r) (findnth n) stp = (Suc (2 * n), l', r');\n     inv_locate_a (as, lm) (n, l', r') ires\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp la ra.\n                         steps (start_of ly as, l, r)\n                          (shift (findnth n) (start_of ly as - Suc 0) @\n                           adjust\n                            (shift (shift tdec_b (2 * n))\n                              (start_of ly as - Suc 0))\n                            (start_of ly e),\n                           start_of ly as - Suc 0)\n                          stp =\n                         (start_of ly as + 2 * n, la, ra) \\<and>\n                         inv_locate_a (as, lm) (n, la, ra) ires", "apply(rule_tac x = stp in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp la ra.\n     steps (s, l, r)\n      (shift (findnth n) (start_of ly as - Suc 0) @\n       adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n        (start_of ly e),\n       start_of ly as - Suc 0)\n      stp =\n     (start_of ly as + 2 * n, la, ra) \\<and>\n     inv_locate_a (as, lm) (n, la, ra) ires\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>stp la ra.\n     steps (s, l, r)\n      (shift (findnth n) (start_of ly as - Suc 0) @\n       adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n        (start_of ly e),\n       start_of ly as - Suc 0)\n      stp =\n     (start_of ly as + 2 * n, la, ra) \\<and>\n     inv_locate_a (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp la ra.\n     steps (s, l, r)\n      (shift (findnth n) (start_of ly as - Suc 0) @\n       adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n        (start_of ly e),\n       start_of ly as - Suc 0)\n      stp =\n     (start_of ly as + 2 * n, la, ra) \\<and>\n     inv_locate_a (as, lm) (n, la, ra) ires", "obtain stpa la ra where a: \n    \"steps (s, l, r) (shift ?A ?off @ ?B, ?off) stpa = (start_of ly as + 2*n, la, ra)\n                    \\<and> inv_locate_a (as, lm) (n, la, ra) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp la ra.\n     steps (s, l, r)\n      (shift (findnth n) (start_of ly as - Suc 0) @\n       adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n        (start_of ly e),\n       start_of ly as - Suc 0)\n      stp =\n     (start_of ly as + 2 * n, la, ra) \\<and>\n     inv_locate_a (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpa la ra.\n        steps (s, l, r)\n         (shift (findnth n) (start_of ly as - Suc 0) @\n          adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n           (start_of ly e),\n          start_of ly as - Suc 0)\n         stpa =\n        (start_of ly as + 2 * n, la, ra) \\<and>\n        inv_locate_a (as, lm) (n, la, ra) ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps (s, l, r)\n   (shift (findnth n) (start_of ly as - Suc 0) @\n    adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n     (start_of ly e),\n    start_of ly as - Suc 0)\n   stpa =\n  (start_of ly as + 2 * n, la, ra) \\<and>\n  inv_locate_a (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "have \"\\<exists>stp. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n           (steps (start_of ly as + 2*n, la, ra) (shift ?A ?off @ ?B, ?off) stp) ires \\<and> stp > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, la, ra)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires \\<and>\n       0 < stp", "using assms a"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some (Dec n e)\n  steps (s, l, r)\n   (shift (findnth n) (start_of ly as - Suc 0) @\n    adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n     (start_of ly e),\n    start_of ly as - Suc 0)\n   stpa =\n  (start_of ly as + 2 * n, la, ra) \\<and>\n  inv_locate_a (as, lm) (n, la, ra) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (start_of ly as + 2 * n, la, ra)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires \\<and>\n       0 < stp", "apply(drule_tac crsp_step_dec_b, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        steps (s, l, r)\n         (shift (findnth n) (start_of (layout_of ap) as - Suc 0) @\n          adjust\n           (shift (shift tdec_b (2 * n))\n             (start_of (layout_of ap) as - Suc 0))\n           (start_of (layout_of ap) e),\n          start_of (layout_of ap) as - Suc 0)\n         stpa =\n        (start_of (layout_of ap) as + 2 * n, la, ra);\n        ly = layout_of ap; abc_fetch as ap = Some (Dec n e);\n        inv_locate_a (as, lm) (n, la, ra) ires; 0 < stp;\n        crsp (layout_of ap) (abc_step_l (as, lm) (Some (Dec n e)))\n         (steps (start_of (layout_of ap) as + 2 * n, la, ra)\n           (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n            start_of (layout_of ap) as - Suc 0)\n           stp)\n         ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Dec n e)))\n                             (steps\n                               (start_of (layout_of ap) as + 2 * n, la, ra)\n                               (shift (findnth n)\n                                 (start_of (layout_of ap) as - Suc 0) @\n                                adjust\n                                 (shift (shift tdec_b (2 * n))\n                                   (start_of (layout_of ap) as - Suc 0))\n                                 (start_of (layout_of ap) e),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires \\<and>\n                            0 < stp", "apply(rename_tac stp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        steps (s, l, r)\n         (shift (findnth n) (start_of (layout_of ap) as - Suc 0) @\n          adjust\n           (shift (shift tdec_b (2 * n))\n             (start_of (layout_of ap) as - Suc 0))\n           (start_of (layout_of ap) e),\n          start_of (layout_of ap) as - Suc 0)\n         stpa =\n        (start_of (layout_of ap) as + 2 * n, la, ra);\n        ly = layout_of ap; abc_fetch as ap = Some (Dec n e);\n        inv_locate_a (as, lm) (n, la, ra) ires; 0 < stp;\n        crsp (layout_of ap) (abc_step_l (as, lm) (Some (Dec n e)))\n         (steps (start_of (layout_of ap) as + 2 * n, la, ra)\n           (ci (layout_of ap) (start_of (layout_of ap) as) (Dec n e),\n            start_of (layout_of ap) as - Suc 0)\n           stp)\n         ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Dec n e)))\n                             (steps\n                               (start_of (layout_of ap) as + 2 * n, la, ra)\n                               (shift (findnth n)\n                                 (start_of (layout_of ap) as - Suc 0) @\n                                adjust\n                                 (shift (shift tdec_b (2 * n))\n                                   (start_of (layout_of ap) as - Suc 0))\n                                 (start_of (layout_of ap) e),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires \\<and>\n                            0 < stp", "apply(rule_tac x = stp in exI, simp add: ci.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n      (steps (start_of ly as + 2 * n, la, ra)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp)\n      ires \\<and>\n     0 < stp\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp.\n     crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n      (steps (start_of ly as + 2 * n, la, ra)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp)\n      ires \\<and>\n     0 < stp", "obtain stpb where b: \n    \"crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n    (steps (start_of ly as + 2*n, la, ra) (shift ?A ?off @ ?B, ?off) stpb) ires \\<and> stpb > 0\""], ["proof (prove)\nusing this:\n  \\<exists>stp.\n     crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n      (steps (start_of ly as + 2 * n, la, ra)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp)\n      ires \\<and>\n     0 < stp\n\ngoal (1 subgoal):\n 1. (\\<And>stpb.\n        crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n         (steps (start_of ly as + 2 * n, la, ra)\n           (shift (findnth n) (start_of ly as - Suc 0) @\n            adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n             (start_of ly e),\n            start_of ly as - Suc 0)\n           stpb)\n         ires \\<and>\n        0 < stpb \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n   (steps (start_of ly as + 2 * n, la, ra)\n     (shift (findnth n) (start_of ly as - Suc 0) @\n      adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n       (start_of ly e),\n      start_of ly as - Suc 0)\n     stpb)\n   ires \\<and>\n  0 < stpb\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "from a b"], ["proof (chain)\npicking this:\n  steps (s, l, r)\n   (shift (findnth n) (start_of ly as - Suc 0) @\n    adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n     (start_of ly e),\n    start_of ly as - Suc 0)\n   stpa =\n  (start_of ly as + 2 * n, la, ra) \\<and>\n  inv_locate_a (as, lm) (n, la, ra) ires\n  crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n   (steps (start_of ly as + 2 * n, la, ra)\n     (shift (findnth n) (start_of ly as - Suc 0) @\n      adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n       (start_of ly e),\n      start_of ly as - Suc 0)\n     stpb)\n   ires \\<and>\n  0 < stpb", "show \"\\<exists> stp>0. crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n    (steps (s, l, r) (shift ?A ?off @ ?B, ?off) stp) ires\""], ["proof (prove)\nusing this:\n  steps (s, l, r)\n   (shift (findnth n) (start_of ly as - Suc 0) @\n    adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n     (start_of ly e),\n    start_of ly as - Suc 0)\n   stpa =\n  (start_of ly as + 2 * n, la, ra) \\<and>\n  inv_locate_a (as, lm) (n, la, ra) ires\n  crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n   (steps (start_of ly as + 2 * n, la, ra)\n     (shift (findnth n) (start_of ly as - Suc 0) @\n      adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n       (start_of ly e),\n      start_of ly as - Suc 0)\n     stpb)\n   ires \\<and>\n  0 < stpb\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n        (steps (s, l, r)\n          (shift (findnth n) (start_of ly as - Suc 0) @\n           adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n            (start_of ly e),\n           start_of ly as - Suc 0)\n          stp)\n        ires", "apply(rule_tac x = \"stpa + stpb\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (s, l, r)\n              (shift (findnth n) (start_of ly as - Suc 0) @\n               adjust\n                (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n                (start_of ly e),\n               start_of ly as - Suc 0)\n              stpa =\n             (start_of ly as + 2 * n, la, ra) \\<and>\n             inv_locate_a (as, lm) (n, la, ra) ires;\n     crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n      (steps (start_of ly as + 2 * n, la, ra)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stpb)\n      ires \\<and>\n     0 < stpb\\<rbrakk>\n    \\<Longrightarrow> 0 < stpa + stpb \\<and>\n                      crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n                       (steps (s, l, r)\n                         (shift (findnth n) (start_of ly as - Suc 0) @\n                          adjust\n                           (shift (shift tdec_b (2 * n))\n                             (start_of ly as - Suc 0))\n                           (start_of ly e),\n                          start_of ly as - Suc 0)\n                         (stpa + stpb))\n                       ires", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some (Dec n e)))\n      (steps (s, l, r)\n        (shift (findnth n) (start_of ly as - Suc 0) @\n         adjust (shift (shift tdec_b (2 * n)) (start_of ly as - Suc 0))\n          (start_of ly e),\n         start_of ly as - Suc 0)\n        stp)\n      ires\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Crsp of Goto\\<close>"], ["", "lemma crsp_step_goto:\n  assumes layout: \"ly = layout_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n  shows \"\\<exists>stp>0. crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n  (steps (s, l, r) (ci ly (start_of ly as) (Goto n), \n            start_of ly as - Suc 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n        (steps (s, l, r)\n          (ci ly (start_of ly as) (Goto n), start_of ly as - Suc 0) stp)\n        ires", "using crsp"], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n        (steps (s, l, r)\n          (ci ly (start_of ly as) (Goto n), start_of ly as - Suc 0) stp)\n        ires", "apply(rule_tac x = \"Suc 0\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n    0 < Suc 0 \\<and>\n    crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n     (steps (s, l, r)\n       (ci ly (start_of ly as) (Goto n), start_of ly as - Suc 0) (Suc 0))\n     ires", "apply(cases r;cases \"hd r\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; r = []; hd r = Bk\\<rbrakk>\n    \\<Longrightarrow> 0 < Suc 0 \\<and>\n                      crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n                       (steps (s, l, r)\n                         (ci ly (start_of ly as) (Goto n),\n                          start_of ly as - Suc 0)\n                         (Suc 0))\n                       ires\n 2. \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; r = []; hd r = Oc\\<rbrakk>\n    \\<Longrightarrow> 0 < Suc 0 \\<and>\n                      crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n                       (steps (s, l, r)\n                         (ci ly (start_of ly as) (Goto n),\n                          start_of ly as - Suc 0)\n                         (Suc 0))\n                       ires\n 3. \\<And>a list.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; r = a # list;\n        hd r = Bk\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc 0 \\<and>\n                         crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n                          (steps (s, l, r)\n                            (ci ly (start_of ly as) (Goto n),\n                             start_of ly as - Suc 0)\n                            (Suc 0))\n                          ires\n 4. \\<And>a list.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires; r = a # list;\n        hd r = Oc\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc 0 \\<and>\n                         crsp ly (abc_step_l (as, lm) (Some (Goto n)))\n                          (steps (s, l, r)\n                            (ci ly (start_of ly as) (Goto n),\n                             start_of ly as - Suc 0)\n                            (Suc 0))\n                          ires", "apply(simp_all add: ci.simps steps.simps step.simps crsp.simps fetch.simps abc_step_l.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step_in:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some ins\"\n  shows \"\\<exists> stp>0. crsp ly (abc_step_l (as, lm) (Some ins))\n                      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins))\n        (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n          stp)\n        ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some ins\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins))\n        (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n          stp)\n        ires", "apply(cases ins, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires; ins = Inc x1;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some (Inc x1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Inc x1)))\n                             (steps (s, l, r)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Inc x1),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires\n 2. \\<And>x21 x22.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        ins = Dec x21 x22; ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some (Dec x21 x22)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Dec x21 x22)))\n                             (steps (s, l, r)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Dec x21 x22),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires\n 3. \\<And>x3.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires; ins = Goto x3;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some (Goto x3)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Goto x3)))\n                             (steps (s, l, r)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Goto x3),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires", "apply(rule crsp_step_inc, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires;\n        ins = Dec x21 x22; ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some (Dec x21 x22)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Dec x21 x22)))\n                             (steps (s, l, r)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Dec x21 x22),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires\n 2. \\<And>x3.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires; ins = Goto x3;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some (Goto x3)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Goto x3)))\n                             (steps (s, l, r)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Goto x3),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires", "apply(rule crsp_step_dec, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>crsp (layout_of ap) (as, lm) (s, l, r) ires; ins = Goto x3;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_fetch as ap = Some (Goto x3)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp>0.\n                            crsp (layout_of ap)\n                             (abc_step_l (as, lm) (Some (Goto x3)))\n                             (steps (s, l, r)\n                               (ci (layout_of ap)\n                                 (start_of (layout_of ap) as) (Goto x3),\n                                start_of (layout_of ap) as - Suc 0)\n                               stp)\n                             ires", "apply(rule_tac crsp_step_goto, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_step:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n    and fetch: \"abc_fetch as ap = Some ins\"\n  shows \"\\<exists> stp>0. crsp ly (abc_step_l (as, lm) (Some ins))\n                      (steps (s, l, r) (tp, 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "have \"\\<exists> stp>0. crsp ly (abc_step_l (as, lm) (Some ins))\n                      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins))\n        (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n          stp)\n        ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some ins\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins))\n        (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n          stp)\n        ires", "apply(rule_tac crsp_step_in, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires", "obtain stp where d: \"stp > 0 \\<and> crsp ly (abc_step_l (as, lm) (Some ins))\n                      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        0 < stp \\<and>\n        crsp ly (abc_step_l (as, lm) (Some ins))\n         (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n           stp)\n         ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  0 < stp \\<and>\n  crsp ly (abc_step_l (as, lm) (Some ins))\n   (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n   ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "obtain s' l' r' where e:\n    \"(steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp) = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' l' r'.\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         stp =\n        (s', l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"(steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>s' l' r'.\n                   steps (s, l, r)\n                    (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n                   (s', l', r') \\<Longrightarrow>\n                   thesis;\n        steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1)\n         stp =\n        (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "then"], ["proof (chain)\npicking this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')", "have \"steps (s, l, r) (tp, 0) stp = (s', l', r')\""], ["proof (prove)\nusing this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp stp = (s', l', r')", "using assms d"], ["proof (prove)\nusing this:\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (as, lm) (s, l, r) ires\n  abc_fetch as ap = Some ins\n  0 < stp \\<and>\n  crsp ly (abc_step_l (as, lm) (Some ins))\n   (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n   ires\n\ngoal (1 subgoal):\n 1. steps0 (s, l, r) tp stp = (s', l', r')", "apply(rule_tac steps_eq_in)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\\<rbrakk>\n    \\<Longrightarrow> ?ly6 = layout_of ?ap6\n 2. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\\<rbrakk>\n    \\<Longrightarrow> tp = tm_of ?ap6\n 3. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\\<rbrakk>\n    \\<Longrightarrow> crsp ?ly6 (?as6, ?lm6) (s, l, r) ?ires6\n 4. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\\<rbrakk>\n    \\<Longrightarrow> abc_fetch ?as6 ?ap6 = Some ?ins6\n 5. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\\<rbrakk>\n    \\<Longrightarrow> steps (s, l, r)\n                       (ci ?ly6 (start_of ?ly6 ?as6) ?ins6,\n                        start_of ?ly6 ?as6 - 1)\n                       stp =\n                      (s', l', r')\n 6. \\<lbrakk>steps (s, l, r)\n              (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap; crsp ly (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp ly (abc_step_l (as, lm) (Some ins))\n      (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n      ires\\<rbrakk>\n    \\<Longrightarrow> s' \\<noteq> 0", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps (s, l, r)\n              (ci (layout_of ap) (start_of (layout_of ap) as) ins,\n               start_of (layout_of ap) as - Suc 0)\n              stp =\n             (s', l', r');\n     ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (as, lm) (s, l, r) ires;\n     abc_fetch as ap = Some ins;\n     0 < stp \\<and>\n     crsp (layout_of ap) (abc_step_l (as, lm) (Some ins)) (s', l', r')\n      ires\\<rbrakk>\n    \\<Longrightarrow> 0 < s'", "apply(cases \"(abc_step_l (as, lm) (Some ins))\", simp add: crsp.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (s, l, r) tp stp = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "thus \" \\<exists>stp>0. crsp ly (abc_step_l (as, lm) (Some ins)) (steps (s, l, r) (tp, 0) stp) ires\""], ["proof (prove)\nusing this:\n  steps0 (s, l, r) tp stp = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "using d e"], ["proof (prove)\nusing this:\n  steps0 (s, l, r) tp stp = (s', l', r')\n  0 < stp \\<and>\n  crsp ly (abc_step_l (as, lm) (Some ins))\n   (steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp)\n   ires\n  steps (s, l, r) (ci ly (start_of ly as) ins, start_of ly as - 1) stp =\n  (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp)\n        ires", "apply(rule_tac x = stp in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as, lm) (Some ins)) (steps0 (s, l, r) tp stp) ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crsp_steps:\n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (as, lm) (s, l, r) ires\"\n  shows \"\\<exists> stp. crsp ly (abc_steps_l (as, lm) ap n)\n                      (steps (s, l, r) (tp, 0) stp) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires", "using crsp"], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n    \\<exists>stp.\n       crsp ly (abc_steps_l (as, lm) ap 0) (steps0 (s, l, r) tp stp) ires\n 2. \\<And>n.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n                \\<exists>stp.\n                   crsp ly (abc_steps_l (as, lm) ap n)\n                    (steps0 (s, l, r) tp stp) ires;\n        crsp ly (as, lm) (s, l, r) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "case 0"], ["proof (state)\nthis:\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (2 subgoals):\n 1. crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n    \\<exists>stp.\n       crsp ly (abc_steps_l (as, lm) ap 0) (steps0 (s, l, r) tp stp) ires\n 2. \\<And>n.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n                \\<exists>stp.\n                   crsp ly (abc_steps_l (as, lm) ap n)\n                    (steps0 (s, l, r) tp stp) ires;\n        crsp ly (as, lm) (s, l, r) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "then"], ["proof (chain)\npicking this:\n  crsp ly (as, lm) (s, l, r) ires", "show ?case"], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       crsp ly (abc_steps_l (as, lm) ap 0) (steps0 (s, l, r) tp stp) ires", "apply(rule_tac x = 0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n    crsp ly (abc_steps_l (as, lm) ap 0) (steps0 (s, l, r) tp 0) ires", "by(simp add: steps.simps abc_steps_l.simps)"], ["proof (state)\nthis:\n  \\<exists>stp.\n     crsp ly (abc_steps_l (as, lm) ap 0) (steps0 (s, l, r) tp stp) ires\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n                \\<exists>stp.\n                   crsp ly (abc_steps_l (as, lm) ap n)\n                    (steps0 (s, l, r) tp stp) ires;\n        crsp ly (as, lm) (s, l, r) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n                \\<exists>stp.\n                   crsp ly (abc_steps_l (as, lm) ap n)\n                    (steps0 (s, l, r) tp stp) ires;\n        crsp ly (as, lm) (s, l, r) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "case (Suc n)"], ["proof (state)\nthis:\n  crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n  \\<exists>stp.\n     crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n                \\<exists>stp.\n                   crsp ly (abc_steps_l (as, lm) ap n)\n                    (steps0 (s, l, r) tp stp) ires;\n        crsp ly (as, lm) (s, l, r) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "then"], ["proof (chain)\npicking this:\n  crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n  \\<exists>stp.\n     crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires\n  crsp ly (as, lm) (s, l, r) ires", "obtain stp where \"crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires\""], ["proof (prove)\nusing this:\n  crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n  \\<exists>stp.\n     crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp)\n         ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>crsp ly (as, lm) (s, l, r) ires \\<Longrightarrow>\n                \\<exists>stp.\n                   crsp ly (abc_steps_l (as, lm) ap n)\n                    (steps0 (s, l, r) tp stp) ires;\n        crsp ly (as, lm) (s, l, r) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "thus ?case"], ["proof (prove)\nusing this:\n  crsp ly (abc_steps_l (as, lm) ap n) (steps0 (s, l, r) tp stp) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       crsp ly (abc_steps_l (as, lm) ap (Suc n)) (steps0 (s, l, r) tp stp)\n        ires", "apply(cases \"(abc_steps_l (as, lm) ap n)\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>crsp ly (a, b) (steps0 (s, l, r) tp stp) ires;\n        abc_steps_l (as, lm) ap n = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_steps_l (as, lm) ap (Suc n))\n                             (steps0 (s, l, r) tp stp) ires", "apply(frule_tac abc_step_red, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>crsp ly (a, b) (steps0 (s, l, r) tp stp) ires;\n        abc_steps_l (as, lm) ap n = (a, b);\n        abc_steps_l (as, lm) ap (Suc n) =\n        abc_step_l (a, b) (abc_fetch a ap)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_step_l (a, b) (abc_fetch a ap))\n                             (steps0 (s, l, r) tp stp) ires", "apply(cases \"abc_fetch (fst (abc_steps_l (as, lm) ap n)) ap\", simp add: abc_step_l.simps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa.\n       \\<lbrakk>crsp ly (a, b) (steps0 (s, l, r) tp stp) ires;\n        abc_steps_l (as, lm) ap n = (a, b);\n        abc_steps_l (as, lm) ap (Suc n) = abc_step_l (a, b) (Some aa);\n        abc_fetch a ap = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_step_l (a, b) (Some aa))\n                             (steps0 (s, l, r) tp stp) ires", "apply(cases \"steps (s, l, r) (tp, 0) stp\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba c.\n       \\<lbrakk>crsp ly (a, b) (ab, ba, c) ires;\n        abc_steps_l (as, lm) ap n = (a, b);\n        abc_steps_l (as, lm) ap (Suc n) = abc_step_l (a, b) (Some aa);\n        abc_fetch a ap = Some aa;\n        steps0 (s, l, r) tp stp = (ab, ba, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_step_l (a, b) (Some aa))\n                             (steps0 (s, l, r) tp stp) ires", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (as, lm) (s, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba c.\n       \\<lbrakk>crsp ly (a, b) (ab, ba, c) ires;\n        abc_steps_l (as, lm) ap n = (a, b);\n        abc_steps_l (as, lm) ap (Suc n) = abc_step_l (a, b) (Some aa);\n        abc_fetch a ap = Some aa;\n        steps0 (s, l, r) tp stp = (ab, ba, c)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp ly (abc_step_l (a, b) (Some aa))\n                             (steps0 (s, l, r) tp stp) ires", "apply(drule_tac s = \"fst (steps0 (s, l, r) (tm_of ap) stp)\"\n        and l = \"fst (snd (steps0 (s, l, r) (tm_of ap) stp))\"\n        and r = \"snd (snd (steps0 (s, l, r) (tm_of ap) stp))\" in crsp_step, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ab ba c stpa.\n       \\<lbrakk>crsp (layout_of ap) (a, b) (ab, ba, c) ires;\n        abc_steps_l (as, lm) ap n = (a, b);\n        abc_steps_l (as, lm) ap (Suc n) = abc_step_l (a, b) (Some aa);\n        abc_fetch a ap = Some aa;\n        steps0 (s, l, r) (tm_of ap) stp = (ab, ba, c);\n        crsp (layout_of ap) (as, lm) (s, l, r) ires; ly = layout_of ap;\n        tp = tm_of ap; 0 < stpa;\n        crsp (layout_of ap) (abc_step_l (a, b) (Some aa))\n         (steps0 (ab, ba, c) (tm_of ap) stpa) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp.\n                            crsp (layout_of ap)\n                             (abc_step_l (a, b) (Some aa))\n                             (steps0 (s, l, r) (tm_of ap) stp) ires", "by (metis steps_add)"], ["proof (state)\nthis:\n  \\<exists>stp.\n     crsp ly (abc_steps_l (as, lm) ap (Suc n)) (steps0 (s, l, r) tp stp)\n      ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tp_correct': \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (Suc 0, l, r) ires\"\n    and abc_halt: \"abc_steps_l (0, lm) ap stp = (length ap, am)\"\n  shows \"\\<exists> stp k. steps (Suc 0, l, r) (tp, 0) stp = (start_of ly (length ap), Bk # Bk # ires, <am> @ Bk\\<up>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) tp stp =\n       (start_of ly (length ap), Bk # Bk # ires, <am> @ Bk \\<up> k)", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (Suc 0, l, r) ires\n  abc_steps_l (0, lm) ap stp = (length ap, am)\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) tp stp =\n       (start_of ly (length ap), Bk # Bk # ires, <am> @ Bk \\<up> k)", "apply(drule_tac n = stp in crsp_steps, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpa.\n       \\<lbrakk>crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_steps_l (0, lm) ap stp = (length ap, am);\n        crsp (layout_of ap) (length ap, am)\n         (steps0 (Suc 0, l, r) (tm_of ap) stpa) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp k.\n                            steps0 (Suc 0, l, r) (tm_of ap) stp =\n                            (start_of (layout_of ap) (length ap),\n                             Bk # Bk # ires, <am> @ Bk \\<up> k)", "apply(rename_tac stpA)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpA.\n       \\<lbrakk>crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_steps_l (0, lm) ap stp = (length ap, am);\n        crsp (layout_of ap) (length ap, am)\n         (steps0 (Suc 0, l, r) (tm_of ap) stpA) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stp k.\n                            steps0 (Suc 0, l, r) (tm_of ap) stp =\n                            (start_of (layout_of ap) (length ap),\n                             Bk # Bk # ires, <am> @ Bk \\<up> k)", "apply(rule_tac x = stpA in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stpA.\n       \\<lbrakk>crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n        ly = layout_of ap; tp = tm_of ap;\n        abc_steps_l (0, lm) ap stp = (length ap, am);\n        crsp (layout_of ap) (length ap, am)\n         (steps0 (Suc 0, l, r) (tm_of ap) stpA) ires\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            steps0 (Suc 0, l, r) (tm_of ap) stpA =\n                            (start_of (layout_of ap) (length ap),\n                             Bk # Bk # ires, <am> @ Bk \\<up> k)", "apply(case_tac \"steps (Suc 0, l, r) (tm_of ap, 0) stpA\", simp add: crsp.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>The tp @ [(Nop, 0), (Nop, 0)] is nomoral turing machines, so we can use Hoare\\_plus when composing with Mop machine\\<close>"], ["", "lemma layout_id_cons: \"layout_of (ap @ [p]) = layout_of ap @ [length_of p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. layout_of (ap @ [p]) = layout_of ap @ [length_of p]", "apply(simp add: layout_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_start_of_layout[simp]:  \n  \"map (start_of (layout_of xs @ [length_of x])) [0..<length xs] =  (map (start_of (layout_of xs)) [0..<length xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (start_of (layout_of xs @ [length_of x])) [0..<length xs] =\n    map (start_of (layout_of xs)) [0..<length xs]", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa < length xs \\<Longrightarrow>\n       start_of (layout_of xs @ [length_of x]) xa =\n       start_of (layout_of xs) xa", "apply(simp add: layout_of.simps start_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tpairs_id_cons: \n  \"tpairs_of (xs @ [x]) = tpairs_of xs @ [(start_of (layout_of (xs @ [x])) (length xs), x)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tpairs_of (xs @ [x]) =\n    tpairs_of xs @ [(start_of (layout_of (xs @ [x])) (length xs), x)]", "apply(auto simp: tpairs_of.simps layout_id_cons )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_length_ci:\n  \"(map (length \\<circ> (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y)) (tpairs_of xs)) = \n  (map (length \\<circ> (\\<lambda>(x, y). ci (layout_of xs) x y)) (tpairs_of xs)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (length \\<circ>\n         (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y))\n     (tpairs_of xs) =\n    map (length \\<circ> (\\<lambda>(x, y). ci (layout_of xs) x y))\n     (tpairs_of xs)", "apply(auto simp: ci.simps adjust.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (tpairs_of xs) \\<Longrightarrow>\n       length (ci (layout_of xs @ [length_of x]) a b) =\n       length (ci (layout_of xs) a b)", "apply(rename_tac A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       (A, B) \\<in> set (tpairs_of xs) \\<Longrightarrow>\n       length (ci (layout_of xs @ [length_of x]) A B) =\n       length (ci (layout_of xs) A B)", "apply(case_tac B, auto simp: ci.simps adjust.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_tp'[simp]: \n  \"\\<lbrakk>ly = layout_of ap; tp = tm_of ap\\<rbrakk> \\<Longrightarrow>\n       length tp = 2 * sum_list (take (length ap) (layout_of ap))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; tp = tm_of ap\\<rbrakk>\n    \\<Longrightarrow> length tp =\n                      2 * sum_list (take (length ap) (layout_of ap))", "proof(induct ap arbitrary: ly tp rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ly tp.\n       \\<lbrakk>ly = layout_of []; tp = tm_of []\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 * sum_list (take (length []) (layout_of []))\n 2. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "case Nil"], ["proof (state)\nthis:\n  ly = layout_of []\n  tp = tm_of []\n\ngoal (2 subgoals):\n 1. \\<And>ly tp.\n       \\<lbrakk>ly = layout_of []; tp = tm_of []\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 * sum_list (take (length []) (layout_of []))\n 2. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "thus \"?case\""], ["proof (prove)\nusing this:\n  ly = layout_of []\n  tp = tm_of []\n\ngoal (1 subgoal):\n 1. length tp = 2 * sum_list (take (length []) (layout_of []))", "by(simp add: tms_of.simps tm_of.simps tpairs_of.simps)"], ["proof (state)\nthis:\n  length tp = 2 * sum_list (take (length []) (layout_of []))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "fix x xs ly tp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "assume ind: \"\\<And>ly tp. \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk> \\<Longrightarrow> \n    length tp = 2 * sum_list (take (length xs) (layout_of xs))\"\n    and layout: \"ly = layout_of (xs @ [x])\"\n    and tp: \"tp = tm_of (xs @ [x])\""], ["proof (state)\nthis:\n  \\<lbrakk>?ly = layout_of xs; ?tp = tm_of xs\\<rbrakk>\n  \\<Longrightarrow> length ?tp =\n                    2 * sum_list (take (length xs) (layout_of xs))\n  ly = layout_of (xs @ [x])\n  tp = tm_of (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "obtain ly' where a: \"ly' = layout_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ly'.\n        ly' = layout_of xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ly' = layout_of xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "obtain tp' where b: \"tp' = tm_of xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tp'. tp' = tm_of xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  tp' = tm_of xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "have c: \"length tp' = 2 * sum_list (take (length xs) (layout_of xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length tp' = 2 * sum_list (take (length xs) (layout_of xs))", "using a b"], ["proof (prove)\nusing this:\n  ly' = layout_of xs\n  tp' = tm_of xs\n\ngoal (1 subgoal):\n 1. length tp' = 2 * sum_list (take (length xs) (layout_of xs))", "by(erule_tac ind, simp)"], ["proof (state)\nthis:\n  length tp' = 2 * sum_list (take (length xs) (layout_of xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs ly tp.\n       \\<lbrakk>\\<And>ly tp.\n                   \\<lbrakk>ly = layout_of xs; tp = tm_of xs\\<rbrakk>\n                   \\<Longrightarrow> length tp =\n                                     2 *\n                                     sum_list\n(take (length xs) (layout_of xs));\n        ly = layout_of (xs @ [x]); tp = tm_of (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> length tp =\n                         2 *\n                         sum_list\n                          (take (length (xs @ [x])) (layout_of (xs @ [x])))", "thus \"length tp = 2 * \n    sum_list (take (length (xs @ [x])) (layout_of (xs @ [x])))\""], ["proof (prove)\nusing this:\n  length tp' = 2 * sum_list (take (length xs) (layout_of xs))\n\ngoal (1 subgoal):\n 1. length tp =\n    2 * sum_list (take (length (xs @ [x])) (layout_of (xs @ [x])))", "using tp b"], ["proof (prove)\nusing this:\n  length tp' = 2 * sum_list (take (length xs) (layout_of xs))\n  tp = tm_of (xs @ [x])\n  tp' = tm_of xs\n\ngoal (1 subgoal):\n 1. length tp =\n    2 * sum_list (take (length (xs @ [x])) (layout_of (xs @ [x])))", "apply(auto simp: layout_id_cons tm_of.simps tms_of.simps length_concat tpairs_id_cons map_length_ci)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sum_list\n              (map (length \\<circ> (\\<lambda>(x, y). ci (layout_of xs) x y))\n                (tpairs_of xs)) =\n             2 * sum_list (layout_of xs);\n     tp =\n     concat\n      (map (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y)\n        (tpairs_of xs)) @\n     ci (layout_of xs @ [length_of x])\n      (start_of (layout_of xs @ [length_of x]) (length xs)) x;\n     tp' =\n     concat\n      (map (\\<lambda>(x, y). ci (layout_of xs) x y) (tpairs_of xs))\\<rbrakk>\n    \\<Longrightarrow> length\n                       (ci (layout_of xs @ [length_of x])\n                         (start_of (layout_of xs @ [length_of x])\n                           (length xs))\n                         x) =\n                      2 * length_of x", "apply(cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>sum_list\n                 (map (length \\<circ>\n                       (\\<lambda>(x, y). ci (layout_of xs) x y))\n                   (tpairs_of xs)) =\n                2 * sum_list (layout_of xs);\n        tp =\n        concat\n         (map (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y)\n           (tpairs_of xs)) @\n        ci (layout_of xs @ [length_of x])\n         (start_of (layout_of xs @ [length_of x]) (length xs)) x;\n        tp' =\n        concat\n         (map (\\<lambda>(x, y). ci (layout_of xs) x y) (tpairs_of xs));\n        x = Inc x1\\<rbrakk>\n       \\<Longrightarrow> length\n                          (ci (layout_of xs @ [length_of x])\n                            (start_of (layout_of xs @ [length_of x])\n                              (length xs))\n                            x) =\n                         2 * length_of x\n 2. \\<And>x21 x22.\n       \\<lbrakk>sum_list\n                 (map (length \\<circ>\n                       (\\<lambda>(x, y). ci (layout_of xs) x y))\n                   (tpairs_of xs)) =\n                2 * sum_list (layout_of xs);\n        tp =\n        concat\n         (map (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y)\n           (tpairs_of xs)) @\n        ci (layout_of xs @ [length_of x])\n         (start_of (layout_of xs @ [length_of x]) (length xs)) x;\n        tp' =\n        concat\n         (map (\\<lambda>(x, y). ci (layout_of xs) x y) (tpairs_of xs));\n        x = Dec x21 x22\\<rbrakk>\n       \\<Longrightarrow> length\n                          (ci (layout_of xs @ [length_of x])\n                            (start_of (layout_of xs @ [length_of x])\n                              (length xs))\n                            x) =\n                         2 * length_of x\n 3. \\<And>x3.\n       \\<lbrakk>sum_list\n                 (map (length \\<circ>\n                       (\\<lambda>(x, y). ci (layout_of xs) x y))\n                   (tpairs_of xs)) =\n                2 * sum_list (layout_of xs);\n        tp =\n        concat\n         (map (\\<lambda>(xa, y). ci (layout_of xs @ [length_of x]) xa y)\n           (tpairs_of xs)) @\n        ci (layout_of xs @ [length_of x])\n         (start_of (layout_of xs @ [length_of x]) (length xs)) x;\n        tp' =\n        concat\n         (map (\\<lambda>(x, y). ci (layout_of xs) x y) (tpairs_of xs));\n        x = Goto x3\\<rbrakk>\n       \\<Longrightarrow> length\n                          (ci (layout_of xs @ [length_of x])\n                            (start_of (layout_of xs @ [length_of x])\n                              (length xs))\n                            x) =\n                         2 * length_of x", "apply(auto simp: ci.simps tinc_b_def tdec_b_def length_findnth adjust.simps length_of.simps\n        split: abc_inst.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length tp = 2 * sum_list (take (length (xs @ [x])) (layout_of (xs @ [x])))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_tp:\n  \"\\<lbrakk>ly = layout_of ap; tp = tm_of ap\\<rbrakk> \\<Longrightarrow> \n  start_of ly (length ap) = Suc (length tp div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; tp = tm_of ap\\<rbrakk>\n    \\<Longrightarrow> start_of ly (length ap) = Suc (length tp div 2)", "apply(frule_tac length_tp', simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     length (tm_of ap) = 2 * sum_list (layout_of ap)\\<rbrakk>\n    \\<Longrightarrow> start_of (layout_of ap) (length ap) =\n                      Suc (sum_list (layout_of ap))", "apply(simp add: start_of.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compile_correct_halt: \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (Suc 0, l, r) ires\"\n    and abc_halt: \"abc_steps_l (0, lm) ap stp = (length ap, am)\"\n    and rs_loc: \"n < length am\"\n    and rs: \"abc_lm_v am n = rs\"\n    and off: \"off = length tp div 2\"\n  shows \"\\<exists> stp i j. steps (Suc 0, l, r) (tp @ shift (mopup n) off, 0) stp = (0, Bk\\<up>i @ Bk # Bk # ires, Oc\\<up>Suc rs @ Bk\\<up>j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "have \"\\<exists> stp k. steps (Suc 0, l, r) (tp, 0) stp = (Suc off, Bk # Bk # ires, <am> @ Bk\\<up>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) tp stp =\n       (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)", "using assms tp_correct'[of ly ap tp lm l r ires stp am]"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (Suc 0, l, r) ires\n  abc_steps_l (0, lm) ap stp = (length ap, am)\n  n < length am\n  abc_lm_v am n = rs\n  off = length tp div 2\n  \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n   crsp ly (0, lm) (Suc 0, l, r) ires;\n   abc_steps_l (0, lm) ap stp = (length ap, am)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp k.\n                       steps0 (Suc 0, l, r) tp stp =\n                       (start_of ly (length ap), Bk # Bk # ires,\n                        <am> @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>stp k.\n       steps0 (Suc 0, l, r) tp stp =\n       (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)", "by(simp add: length_tp)"], ["proof (state)\nthis:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) tp stp =\n     (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) tp stp =\n     (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)", "obtain stp k where \"steps (Suc 0, l, r) (tp, 0) stp = (Suc off, Bk # Bk # ires, <am> @ Bk\\<up>k)\""], ["proof (prove)\nusing this:\n  \\<exists>stp k.\n     steps0 (Suc 0, l, r) tp stp =\n     (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. (\\<And>stp k.\n        steps0 (Suc 0, l, r) tp stp =\n        (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) tp stp = (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "then"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, l, r) tp stp = (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)", "have a: \"steps (Suc 0, l, r) (tp@shift (mopup n) off , 0) stp = (Suc off, Bk # Bk # ires, <am> @ Bk\\<up>k)\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) tp stp = (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n    (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)", "using assms"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) tp stp = (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (Suc 0, l, r) ires\n  abc_steps_l (0, lm) ap stp = (length ap, am)\n  n < length am\n  abc_lm_v am n = rs\n  off = length tp div 2\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n    (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)", "by(auto intro: tm_append_first_steps_eq)"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n  (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "have \"\\<exists> stp i j. (steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stp)\n    = (0, Bk\\<up>i @ Bk # Bk # ires, Oc # Oc\\<up> rs @ Bk\\<up>j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (Suc 0, l, r) ires\n  abc_steps_l (0, lm) ap stp = (length ap, am)\n  n < length am\n  abc_lm_v am n = rs\n  off = length tp div 2\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n        (mopup_a n @ shift mopup_b (2 * n)) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "by(rule_tac mopup_correct, auto simp: abc_lm_v.simps)"], ["proof (state)\nthis:\n  \\<exists>stp i j.\n     steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n      (mopup_a n @ shift mopup_b (2 * n)) stp =\n     (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp i j.\n     steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n      (mopup_a n @ shift mopup_b (2 * n)) stp =\n     (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "obtain stpb i j where \n    \"steps (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k) (mopup_a n @ shift mopup_b (2 * n), 0) stpb\n    = (0, Bk\\<up>i @ Bk # Bk # ires, Oc # Oc\\<up> rs @ Bk\\<up>j)\""], ["proof (prove)\nusing this:\n  \\<exists>stp i j.\n     steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n      (mopup_a n @ shift mopup_b (2 * n)) stp =\n     (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal (1 subgoal):\n 1. (\\<And>stpb i j.\n        steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n         (mopup_a n @ shift mopup_b (2 * n)) stpb =\n        (0, Bk \\<up> i @ Bk # Bk # ires,\n         Oc # Oc \\<up> rs @ Bk \\<up> j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (mopup_a n @ shift mopup_b (2 * n)) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "then"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (mopup_a n @ shift mopup_b (2 * n)) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "have b: \"steps (Suc 0 + off, Bk # Bk # ires, <am> @ Bk \\<up> k) (tp @ shift (mopup n) off, 0) stpb\n    = (0, Bk\\<up>i @ Bk # Bk # ires, Oc # Oc\\<up> rs @ Bk\\<up>j)\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (mopup_a n @ shift mopup_b (2 * n)) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0 + off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (tp @ shift (mopup n) off) stpb =\n    (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "using assms wf_mopup"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (mopup_a n @ shift mopup_b (2 * n)) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (Suc 0, l, r) ires\n  abc_steps_l (0, lm) ap stp = (length ap, am)\n  n < length am\n  abc_lm_v am n = rs\n  off = length tp div 2\n  tm_wf0 (mopup ?n)\n\ngoal (1 subgoal):\n 1. steps0 (Suc 0 + off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n     (tp @ shift (mopup n) off) stpb =\n    (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "apply(drule_tac tm_append_second_halt_eq, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (Suc 0 + off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (tp @ shift (mopup n) off) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "from a b"], ["proof (chain)\npicking this:\n  steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n  (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n  steps0 (Suc 0 + off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (tp @ shift (mopup n) off) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n  (Suc off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n  steps0 (Suc 0 + off, Bk # Bk # ires, <am> @ Bk \\<up> k)\n   (tp @ shift (mopup n) off) stpb =\n  (0, Bk \\<up> i @ Bk # Bk # ires, Oc # Oc \\<up> rs @ Bk \\<up> j)\n\ngoal (1 subgoal):\n 1. \\<exists>stp i j.\n       steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n       (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)", "by(rule_tac x = \"stp + stpb\" in exI, simp add: steps_add)"], ["proof (state)\nthis:\n  \\<exists>stp i j.\n     steps0 (Suc 0, l, r) (tp @ shift (mopup n) off) stp =\n     (0, Bk \\<up> i @ Bk # Bk # ires, Oc \\<up> Suc rs @ Bk \\<up> j)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare mopup.simps[simp del]"], ["", "lemma abc_step_red2:\n  \"abc_steps_l (s, lm) p (Suc n) = (let (as', am') = abc_steps_l (s, lm) p n in\n                                    abc_step_l (as', am') (abc_fetch as' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_steps_l (s, lm) p (Suc n) =\n    (let (as', am') = abc_steps_l (s, lm) p n\n     in abc_step_l (as', am') (abc_fetch as' p))", "apply(cases \"abc_steps_l (s, lm) p n\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       abc_steps_l (s, lm) p n = (a, b) \\<Longrightarrow>\n       abc_steps_l (s, lm) p (Suc n) = abc_step_l (a, b) (abc_fetch a p)", "apply(drule_tac abc_step_red, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma crsp_steps2:\n  assumes \n    layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (Suc 0, l, r) ires\"\n    and nothalt: \"as < length ap\"\n    and aexec: \"abc_steps_l (0, lm) ap stp = (as, am)\"\n  shows \"\\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps (Suc 0, l, r) (tp, 0) stpa) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stpa\\<ge>stp.\n       crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires", "using nothalt aexec"], ["proof (prove)\nusing this:\n  as < length ap\n  abc_steps_l (0, lm) ap stp = (as, am)\n\ngoal (1 subgoal):\n 1. \\<exists>stpa\\<ge>stp.\n       crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires", "proof(induct stp arbitrary: as am)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as am.\n       \\<lbrakk>as < length ap; abc_steps_l (0, lm) ap 0 = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>0.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires\n 2. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "case 0"], ["proof (state)\nthis:\n  as < length ap\n  abc_steps_l (0, lm) ap 0 = (as, am)\n\ngoal (2 subgoals):\n 1. \\<And>as am.\n       \\<lbrakk>as < length ap; abc_steps_l (0, lm) ap 0 = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>0.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires\n 2. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "thus \"?case\""], ["proof (prove)\nusing this:\n  as < length ap\n  abc_steps_l (0, lm) ap 0 = (as, am)\n\ngoal (1 subgoal):\n 1. \\<exists>stpa\\<ge>0.\n       crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires", "using crsp"], ["proof (prove)\nusing this:\n  as < length ap\n  abc_steps_l (0, lm) ap 0 = (as, am)\n  crsp ly (0, lm) (Suc 0, l, r) ires\n\ngoal (1 subgoal):\n 1. \\<exists>stpa\\<ge>0.\n       crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires", "by(rule_tac x = 0 in exI, auto simp: abc_steps_l.simps steps.simps crsp)"], ["proof (state)\nthis:\n  \\<exists>stpa\\<ge>0. crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "case (Suc stp as am)"], ["proof (state)\nthis:\n  \\<lbrakk>?as < length ap; abc_steps_l (0, lm) ap stp = (?as, ?am)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stpaa\\<ge>stp.\n                       crsp ly (?as, ?am) (steps0 (Suc 0, l, r) tp stpaa)\n                        ires\n  as < length ap\n  abc_steps_l (0, lm) ap (Suc stp) = (as, am)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "have ind: \n    \"\\<And> as am.  \\<lbrakk>as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk> \n    \\<Longrightarrow> \\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps (Suc 0, l, r) (tp, 0) stpa) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as am.\n       \\<lbrakk>as < length ap;\n        abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpaa\\<ge>stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpaa)\n                             ires", "by fact"], ["proof (state)\nthis:\n  \\<lbrakk>?as < length ap; abc_steps_l (0, lm) ap stp = (?as, ?am)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stpaa\\<ge>stp.\n                       crsp ly (?as, ?am) (steps0 (Suc 0, l, r) tp stpaa)\n                        ires\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "have a: \"as < length ap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as < length ap", "by fact"], ["proof (state)\nthis:\n  as < length ap\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "have b: \"abc_steps_l (0, lm) ap (Suc stp) = (as, am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abc_steps_l (0, lm) ap (Suc stp) = (as, am)", "by fact"], ["proof (state)\nthis:\n  abc_steps_l (0, lm) ap (Suc stp) = (as, am)\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "obtain as' am' where c: \"abc_steps_l (0, lm) ap stp = (as', am')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' am'.\n        abc_steps_l (0, lm) ap stp = (as', am') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"abc_steps_l (0, lm) ap stp\", auto)"], ["proof (state)\nthis:\n  abc_steps_l (0, lm) ap stp = (as', am')\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "then"], ["proof (chain)\npicking this:\n  abc_steps_l (0, lm) ap stp = (as', am')", "have d: \"as' < length ap\""], ["proof (prove)\nusing this:\n  abc_steps_l (0, lm) ap stp = (as', am')\n\ngoal (1 subgoal):\n 1. as' < length ap", "using a b"], ["proof (prove)\nusing this:\n  abc_steps_l (0, lm) ap stp = (as', am')\n  as < length ap\n  abc_steps_l (0, lm) ap (Suc stp) = (as, am)\n\ngoal (1 subgoal):\n 1. as' < length ap", "by(simp add: abc_step_red2, cases \"as' < length ap\", simp,\n        simp add: abc_fetch.simps abc_steps_l.simps abc_step_l.simps)"], ["proof (state)\nthis:\n  as' < length ap\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "have \"\\<exists>stpa\\<ge>stp. crsp ly (as', am') (steps (Suc 0, l, r) (tp, 0) stpa) ires\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stpaa\\<ge>stp.\n       crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpaa) ires", "using d c ind"], ["proof (prove)\nusing this:\n  as' < length ap\n  abc_steps_l (0, lm) ap stp = (as', am')\n  \\<lbrakk>?as < length ap; abc_steps_l (0, lm) ap stp = (?as, ?am)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stpaa\\<ge>stp.\n                       crsp ly (?as, ?am) (steps0 (Suc 0, l, r) tp stpaa)\n                        ires\n\ngoal (1 subgoal):\n 1. \\<exists>stpaa\\<ge>stp.\n       crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpaa) ires", "by simp"], ["proof (state)\nthis:\n  \\<exists>stpaa\\<ge>stp.\n     crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpaa) ires\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "from this"], ["proof (chain)\npicking this:\n  \\<exists>stpaa\\<ge>stp.\n     crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpaa) ires", "obtain stpa where e: \n    \"stpa \\<ge> stp \\<and>  crsp ly (as', am') (steps (Suc 0, l, r) (tp, 0) stpa) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stpaa\\<ge>stp.\n     crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpaa) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpaa.\n        stp \\<le> stpaa \\<and>\n        crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpaa)\n         ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  stp \\<le> stpa \\<and>\n  crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpa) ires\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "obtain s' l' r' where f: \"steps (Suc 0, l, r) (tp, 0) stpa = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' l' r'.\n        steps0 (Suc 0, l, r) tp stpa = (s', l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"steps (Suc 0, l, r) (tp, 0) stpa\", auto)"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) tp stpa = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "obtain ins where g: \"abc_fetch as' ap = Some ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ins.\n        abc_fetch as' ap = Some ins \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using d"], ["proof (prove)\nusing this:\n  as' < length ap\n\ngoal (1 subgoal):\n 1. (\\<And>ins.\n        abc_fetch as' ap = Some ins \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"abc_fetch as' ap\",auto simp: abc_fetch.simps)"], ["proof (state)\nthis:\n  abc_fetch as' ap = Some ins\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "then"], ["proof (chain)\npicking this:\n  abc_fetch as' ap = Some ins", "have \"\\<exists>stp> (0::nat). crsp ly (abc_step_l (as', am') (Some ins)) \n    (steps (s', l', r') (tp, 0) stp) ires \""], ["proof (prove)\nusing this:\n  abc_fetch as' ap = Some ins\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as', am') (Some ins))\n        (steps0 (s', l', r') tp stp) ires", "using layout compile e f"], ["proof (prove)\nusing this:\n  abc_fetch as' ap = Some ins\n  ly = layout_of ap\n  tp = tm_of ap\n  stp \\<le> stpa \\<and>\n  crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpa) ires\n  steps0 (Suc 0, l, r) tp stpa = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>stp>0.\n       crsp ly (abc_step_l (as', am') (Some ins))\n        (steps0 (s', l', r') tp stp) ires", "by(rule_tac crsp_step, simp_all)"], ["proof (state)\nthis:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stp)\n      ires\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stp)\n      ires", "obtain stpb where \"stpb > 0 \\<and> crsp ly (abc_step_l (as', am') (Some ins)) \n    (steps (s', l', r') (tp, 0) stpb) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stp>0.\n     crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stp)\n      ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpb.\n        0 < stpb \\<and>\n        crsp ly (abc_step_l (as', am') (Some ins))\n         (steps0 (s', l', r') tp stpb) ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  0 < stpb \\<and>\n  crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stpb)\n   ires\n\ngoal (1 subgoal):\n 1. \\<And>stp as am.\n       \\<lbrakk>\\<And>as am.\n                   \\<lbrakk>as < length ap;\n                    abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n  crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa) ires;\n        as < length ap; abc_steps_l (0, lm) ap (Suc stp) = (as, am)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>stpa\\<ge>Suc stp.\n                            crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpa)\n                             ires", "from this"], ["proof (chain)\npicking this:\n  0 < stpb \\<and>\n  crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stpb)\n   ires", "show \"?case\""], ["proof (prove)\nusing this:\n  0 < stpb \\<and>\n  crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stpb)\n   ires\n\ngoal (1 subgoal):\n 1. \\<exists>stpaa\\<ge>Suc stp.\n       crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpaa) ires", "using b e g f c"], ["proof (prove)\nusing this:\n  0 < stpb \\<and>\n  crsp ly (abc_step_l (as', am') (Some ins)) (steps0 (s', l', r') tp stpb)\n   ires\n  abc_steps_l (0, lm) ap (Suc stp) = (as, am)\n  stp \\<le> stpa \\<and>\n  crsp ly (as', am') (steps0 (Suc 0, l, r) tp stpa) ires\n  abc_fetch as' ap = Some ins\n  steps0 (Suc 0, l, r) tp stpa = (s', l', r')\n  abc_steps_l (0, lm) ap stp = (as', am')\n\ngoal (1 subgoal):\n 1. \\<exists>stpaa\\<ge>Suc stp.\n       crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpaa) ires", "by(rule_tac x = \"stpa + stpb\" in exI, simp add: steps_add abc_step_red2)"], ["proof (state)\nthis:\n  \\<exists>stpaa\\<ge>Suc stp.\n     crsp ly (as, am) (steps0 (Suc 0, l, r) tp stpaa) ires\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compile_correct_unhalt: \n  assumes layout: \"ly = layout_of ap\"\n    and compile: \"tp = tm_of ap\"\n    and crsp: \"crsp ly (0, lm) (1, l, r) ires\"\n    and off: \"off = length tp div 2\"\n    and abc_unhalt: \"\\<forall> stp. (\\<lambda> (as, am). as < length ap) (abc_steps_l (0, lm) ap stp)\"\n  shows \"\\<forall> stp.\\<not> is_final (steps (1, l, r) (tp @ shift (mopup n) off, 0) stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)", "using assms"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (1, l, r) ires\n  off = length tp div 2\n  \\<forall>stp.\n     case abc_steps_l (0, lm) ap stp of\n     (as, am) \\<Rightarrow> as < length ap\n\ngoal (1 subgoal):\n 1. \\<forall>stp.\n       \\<not> is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)", "proof(rule_tac allI, rule_tac notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "fix stp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "assume h: \"is_final (steps (1, l, r) (tp @ shift (mopup n) off, 0) stp)\""], ["proof (state)\nthis:\n  is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "obtain as am where a: \"abc_steps_l (0, lm) ap stp = (as, am)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as am.\n        abc_steps_l (0, lm) ap stp = (as, am) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"abc_steps_l (0, lm) ap stp\", auto)"], ["proof (state)\nthis:\n  abc_steps_l (0, lm) ap stp = (as, am)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  abc_steps_l (0, lm) ap stp = (as, am)", "have b: \"as < length ap\""], ["proof (prove)\nusing this:\n  abc_steps_l (0, lm) ap stp = (as, am)\n\ngoal (1 subgoal):\n 1. as < length ap", "using abc_unhalt"], ["proof (prove)\nusing this:\n  abc_steps_l (0, lm) ap stp = (as, am)\n  \\<forall>stp.\n     case abc_steps_l (0, lm) ap stp of\n     (as, am) \\<Rightarrow> as < length ap\n\ngoal (1 subgoal):\n 1. as < length ap", "by(erule_tac x = stp in allE, simp)"], ["proof (state)\nthis:\n  as < length ap\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<exists> stpa\\<ge>stp. crsp ly (as, am) (steps (1, l, r) (tp, 0) stpa) ires \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires", "using assms b a"], ["proof (prove)\nusing this:\n  ly = layout_of ap\n  tp = tm_of ap\n  crsp ly (0, lm) (1, l, r) ires\n  off = length tp div 2\n  \\<forall>stp.\n     case abc_steps_l (0, lm) ap stp of\n     (as, am) \\<Rightarrow> as < length ap\n  as < length ap\n  abc_steps_l (0, lm) ap stp = (as, am)\n\ngoal (1 subgoal):\n 1. \\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires", "apply(simp add: numeral)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n     off =\n     (sum_list (layout_of ap) + sum_list (layout_of ap)) div Suc (Suc 0);\n     \\<forall>stp.\n        case abc_steps_l (0, lm) ap stp of\n        (as, am) \\<Rightarrow> as < length ap;\n     as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stpa\\<ge>stp.\n                         crsp (layout_of ap) (as, am)\n                          (steps0 (Suc 0, l, r) (tm_of ap) stpa) ires", "apply(rule_tac crsp_steps2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n     off =\n     (sum_list (layout_of ap) + sum_list (layout_of ap)) div Suc (Suc 0);\n     \\<forall>stp.\n        case abc_steps_l (0, lm) ap stp of\n        (as, am) \\<Rightarrow> as < length ap;\n     as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n    \\<Longrightarrow> layout_of ap = layout_of ?ap7\n 2. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n     off =\n     (sum_list (layout_of ap) + sum_list (layout_of ap)) div Suc (Suc 0);\n     \\<forall>stp.\n        case abc_steps_l (0, lm) ap stp of\n        (as, am) \\<Rightarrow> as < length ap;\n     as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n    \\<Longrightarrow> tm_of ap = tm_of ?ap7\n 3. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n     off =\n     (sum_list (layout_of ap) + sum_list (layout_of ap)) div Suc (Suc 0);\n     \\<forall>stp.\n        case abc_steps_l (0, lm) ap stp of\n        (as, am) \\<Rightarrow> as < length ap;\n     as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n    \\<Longrightarrow> crsp (layout_of ap) (0, ?lm7) (Suc 0, l, r) ires\n 4. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n     off =\n     (sum_list (layout_of ap) + sum_list (layout_of ap)) div Suc (Suc 0);\n     \\<forall>stp.\n        case abc_steps_l (0, lm) ap stp of\n        (as, am) \\<Rightarrow> as < length ap;\n     as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n    \\<Longrightarrow> as < length ?ap7\n 5. \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n     crsp (layout_of ap) (0, lm) (Suc 0, l, r) ires;\n     off =\n     (sum_list (layout_of ap) + sum_list (layout_of ap)) div Suc (Suc 0);\n     \\<forall>stp.\n        case abc_steps_l (0, lm) ap stp of\n        (as, am) \\<Rightarrow> as < length ap;\n     as < length ap; abc_steps_l (0, lm) ap stp = (as, am)\\<rbrakk>\n    \\<Longrightarrow> abc_steps_l (0, ?lm7) ?ap7 stp = (as, am)", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires", "obtain stpa where \n    \"stpa\\<ge>stp \\<and> crsp ly (as, am) (steps (1, l, r) (tp, 0) stpa) ires\""], ["proof (prove)\nusing this:\n  \\<exists>stpa\\<ge>stp. crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires\n\ngoal (1 subgoal):\n 1. (\\<And>stpa.\n        stp \\<le> stpa \\<and>\n        crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  stp \\<le> stpa \\<and> crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  stp \\<le> stpa \\<and> crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires", "obtain s' l' r' where b: \"(steps (1, l, r) (tp, 0) stpa) = (s', l', r') \\<and> \n       stpa\\<ge>stp \\<and> crsp ly (as, am) (s', l', r') ires\""], ["proof (prove)\nusing this:\n  stp \\<le> stpa \\<and> crsp ly (as, am) (steps0 (1, l, r) tp stpa) ires\n\ngoal (1 subgoal):\n 1. (\\<And>s' l' r'.\n        steps0 (1, l, r) tp stpa = (s', l', r') \\<and>\n        stp \\<le> stpa \\<and>\n        crsp ly (as, am) (s', l', r') ires \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"steps (1, l, r) (tp, 0) stpa\", auto)"], ["proof (state)\nthis:\n  steps0 (1, l, r) tp stpa = (s', l', r') \\<and>\n  stp \\<le> stpa \\<and> crsp ly (as, am) (s', l', r') ires\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "hence c:\n    \"(steps (1, l, r) (tp @ shift (mopup n) off, 0) stpa) = (s', l', r')\""], ["proof (prove)\nusing this:\n  steps0 (1, l, r) tp stpa = (s', l', r') \\<and>\n  stp \\<le> stpa \\<and> crsp ly (as, am) (s', l', r') ires\n\ngoal (1 subgoal):\n 1. steps0 (1, l, r) (tp @ shift (mopup n) off) stpa = (s', l', r')", "by(rule_tac tm_append_first_steps_eq, simp_all add: crsp.simps)"], ["proof (state)\nthis:\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stpa = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "from b"], ["proof (chain)\npicking this:\n  steps0 (1, l, r) tp stpa = (s', l', r') \\<and>\n  stp \\<le> stpa \\<and> crsp ly (as, am) (s', l', r') ires", "have d: \"s' > 0 \\<and> stpa \\<ge> stp\""], ["proof (prove)\nusing this:\n  steps0 (1, l, r) tp stpa = (s', l', r') \\<and>\n  stp \\<le> stpa \\<and> crsp ly (as, am) (s', l', r') ires\n\ngoal (1 subgoal):\n 1. 0 < s' \\<and> stp \\<le> stpa", "by(simp add: crsp.simps)"], ["proof (state)\nthis:\n  0 < s' \\<and> stp \\<le> stpa\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < s' \\<and> stp \\<le> stpa", "obtain diff where e: \"stpa = stp + diff\""], ["proof (prove)\nusing this:\n  0 < s' \\<and> stp \\<le> stpa\n\ngoal (1 subgoal):\n 1. (\\<And>diff.\n        stpa = stp + diff \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis le_iff_add)"], ["proof (state)\nthis:\n  stpa = stp + diff\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "obtain s'' l'' r'' where f:\n    \"steps (1, l, r) (tp @ shift (mopup n) off, 0) stp = (s'', l'', r'') \\<and> is_final (s'', l'', r'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'' l'' r''.\n        steps0 (1, l, r) (tp @ shift (mopup n) off) stp =\n        (s'', l'', r'') \\<and>\n        is_final (s'', l'', r'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using h"], ["proof (prove)\nusing this:\n  is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\n\ngoal (1 subgoal):\n 1. (\\<And>s'' l'' r''.\n        steps0 (1, l, r) (tp @ shift (mopup n) off) stp =\n        (s'', l'', r'') \\<and>\n        is_final (s'', l'', r'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"steps (1, l, r) (tp @ shift (mopup n) off, 0) stp\", auto)"], ["proof (state)\nthis:\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stp = (s'', l'', r'') \\<and>\n  is_final (s'', l'', r'')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stp = (s'', l'', r'') \\<and>\n  is_final (s'', l'', r'')", "have \"is_final (steps (s'', l'', r'') (tp @ shift (mopup n) off, 0) diff)\""], ["proof (prove)\nusing this:\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stp = (s'', l'', r'') \\<and>\n  is_final (s'', l'', r'')\n\ngoal (1 subgoal):\n 1. is_final (steps0 (s'', l'', r'') (tp @ shift (mopup n) off) diff)", "by(auto intro: after_is_final)"], ["proof (state)\nthis:\n  is_final (steps0 (s'', l'', r'') (tp @ shift (mopup n) off) diff)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_final (steps0 (s'', l'', r'') (tp @ shift (mopup n) off) diff)", "have \"is_final (steps (1, l, r) (tp @ shift (mopup n) off, 0) stpa)\""], ["proof (prove)\nusing this:\n  is_final (steps0 (s'', l'', r'') (tp @ shift (mopup n) off) diff)\n\ngoal (1 subgoal):\n 1. is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stpa)", "using e f"], ["proof (prove)\nusing this:\n  is_final (steps0 (s'', l'', r'') (tp @ shift (mopup n) off) diff)\n  stpa = stp + diff\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stp = (s'', l'', r'') \\<and>\n  is_final (s'', l'', r'')\n\ngoal (1 subgoal):\n 1. is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stpa)", "by simp"], ["proof (state)\nthis:\n  is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stpa)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>ly = layout_of ap; tp = tm_of ap;\n        crsp ly (0, lm) (1, l, r) ires; off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        ly = layout_of ap; tp = tm_of ap; crsp ly (0, lm) (1, l, r) ires;\n        off = length tp div 2;\n        \\<forall>stp.\n           case abc_steps_l (0, lm) ap stp of\n           (as, am) \\<Rightarrow> as < length ap;\n        is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stp)\\<rbrakk>\n       \\<Longrightarrow> False", "from this and c d"], ["proof (chain)\npicking this:\n  is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stpa)\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stpa = (s', l', r')\n  0 < s' \\<and> stp \\<le> stpa", "show \"False\""], ["proof (prove)\nusing this:\n  is_final (steps0 (1, l, r) (tp @ shift (mopup n) off) stpa)\n  steps0 (1, l, r) (tp @ shift (mopup n) off) stpa = (s', l', r')\n  0 < s' \\<and> stp \\<le> stpa\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}