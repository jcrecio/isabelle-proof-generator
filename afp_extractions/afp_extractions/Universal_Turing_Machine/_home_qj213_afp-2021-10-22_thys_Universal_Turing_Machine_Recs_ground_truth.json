{"file_name": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine/Recs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine", "problem_names": ["lemma if_zero_one [simp]:\n  \"(if P then 1 else 0) = (0::nat) \\<longleftrightarrow> \\<not> P\"\n  \"(0::nat) < (if P then 1 else 0) = P\"\n  \"(if P then 0 else 1) = (if \\<not>P then 1 else (0::nat))\"", "lemma nth:\n  \"(x # xs) ! 0 = x\"\n  \"(x # y # xs) ! 1 = y\"\n  \"(x # y # z # xs) ! 2 = z\"\n  \"(x # y # z # u # xs) ! 3 = u\"", "lemma setprod_atMost_Suc[simp]:\n  \"(\\<Prod>i \\<le> Suc n. f i) = (\\<Prod>i \\<le> n. f i) * f(Suc n)\"", "lemma setprod_lessThan_Suc[simp]:\n  \"(\\<Prod>i < Suc n. f i) = (\\<Prod>i < n. f i) * f n\"", "lemma setsum_add_nat_ivl2: \"n \\<le> p  \\<Longrightarrow>\n  sum f {..<n} + sum f {n..p} = sum f {..p::nat}\"", "lemma setsum_eq_zero [simp]:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  shows \"(\\<Sum>i < n. f i) = 0 \\<longleftrightarrow> (\\<forall>i < n. f i = 0)\"\n    \"(\\<Sum>i \\<le> n. f i) = 0 \\<longleftrightarrow> (\\<forall>i \\<le> n. f i = 0)\"", "lemma setprod_eq_zero [simp]:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  shows \"(\\<Prod>i < n. f i) = 0 \\<longleftrightarrow> (\\<exists>i < n. f i = 0)\"\n    \"(\\<Prod>i \\<le> n. f i) = 0 \\<longleftrightarrow> (\\<exists>i \\<le> n. f i = 0)\"", "lemma setsum_one_less:\n  fixes n::nat\n  assumes \"\\<forall>i < n. f i \\<le> 1\"\n  shows \"(\\<Sum>i < n. f i) \\<le> n\"", "lemma setsum_one_le:\n  fixes n::nat\n  assumes \"\\<forall>i \\<le> n. f i \\<le> 1\"\n  shows \"(\\<Sum>i \\<le> n. f i) \\<le> Suc n\"", "lemma setsum_eq_one_le:\n  fixes n::nat\n  assumes \"\\<forall>i \\<le> n. f i = 1\"\n  shows \"(\\<Sum>i \\<le> n. f i) = Suc n\"", "lemma setsum_least_eq:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes h0: \"p \\<le> n\"\n  assumes h1: \"\\<forall>i \\<in> {..<p}. f i = 1\"\n  assumes h2: \"\\<forall>i \\<in> {p..n}. f i = 0\"\n  shows \"(\\<Sum>i \\<le> n. f i) = p\"", "lemma nat_mult_le_one:\n  fixes m n::nat\n  assumes \"m \\<le> 1\" \"n \\<le> 1\"\n  shows \"m * n \\<le> 1\"", "lemma setprod_one_le:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes \"\\<forall>i \\<le> n. f i \\<le> 1\"\n  shows \"(\\<Prod>i \\<le> n. f i) \\<le> 1\"", "lemma setprod_greater_zero:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes \"\\<forall>i \\<le> n. f i \\<ge> 0\"\n  shows \"(\\<Prod>i \\<le> n. f i) \\<ge> 0\"", "lemma setprod_eq_one:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes \"\\<forall>i \\<le> n. f i = Suc 0\"\n  shows \"(\\<Prod>i \\<le> n. f i) = Suc 0\"", "lemma setsum_cut_off_less:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes h1: \"m \\<le> n\"\n    and     h2: \"\\<forall>i \\<in> {m..<n}. f i = 0\"\n  shows \"(\\<Sum>i < n. f i) = (\\<Sum>i < m. f i)\"", "lemma setsum_cut_off_le:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes h1: \"m \\<le> n\"\n    and     h2: \"\\<forall>i \\<in> {m..n}. f i = 0\"\n  shows \"(\\<Sum>i \\<le> n. f i) = (\\<Sum>i < m. f i)\"", "lemma setprod_one [simp]:\n  fixes n::nat\n  shows \"(\\<Prod>i < n. Suc 0) = Suc 0\"\n    \"(\\<Prod>i \\<le> n. Suc 0) = Suc 0\"", "lemma constn_lemma [simp]:\n  \"rec_eval (constn n) xs = n\"", "lemma swap_lemma [simp]:\n  \"rec_eval (rec_swap f) [x, y] = rec_eval f [y, x]\"", "lemma add_lemma [simp]:\n  \"rec_eval rec_add [x, y] =  x + y\"", "lemma mult_lemma [simp]:\n  \"rec_eval rec_mult [x, y] = x * y\"", "lemma power_lemma [simp]:\n  \"rec_eval rec_power [x, y] = x ^ y\"", "lemma fact_aux_lemma [simp]:\n  \"rec_eval rec_fact_aux [x, y] = fact x\"", "lemma fact_lemma [simp]:\n  \"rec_eval rec_fact [x] = fact x\"", "lemma pred_lemma [simp]:\n  \"rec_eval rec_predecessor [x] =  x - 1\"", "lemma minus_lemma [simp]:\n  \"rec_eval rec_minus [x, y] = x - y\"", "lemma sign_lemma [simp]:\n  \"rec_eval rec_sign [x] = (if x = 0 then 0 else 1)\"", "lemma not_lemma [simp]:\n  \"rec_eval rec_not [x] = (if x = 0 then 1 else 0)\"", "lemma eq_lemma [simp]:\n  \"rec_eval rec_eq [x, y] = (if x = y then 1 else 0)\"", "lemma noteq_lemma [simp]:\n  \"rec_eval rec_noteq [x, y] = (if x \\<noteq> y then 1 else 0)\"", "lemma conj_lemma [simp]:\n  \"rec_eval rec_conj [x, y] = (if x = 0 \\<or> y = 0 then 0 else 1)\"", "lemma disj_lemma [simp]:\n  \"rec_eval rec_disj [x, y] = (if x = 0 \\<and> y = 0 then 0 else 1)\"", "lemma imp_lemma [simp]:\n  \"rec_eval rec_imp [x, y] = (if 0 < x \\<and> y = 0 then 0 else 1)\"", "lemma ifz_lemma [simp]:\n  \"rec_eval rec_ifz [z, x, y] = (if z = 0 then x else y)\"", "lemma if_lemma [simp]:\n  \"rec_eval rec_if [z, x, y] = (if 0 < z then x else y)\"", "lemma less_lemma [simp]:\n  \"rec_eval rec_less [x, y] = (if x < y then 1 else 0)\"", "lemma le_lemma [simp]:\n  \"rec_eval rec_le [x, y] = (if (x \\<le> y) then 1 else 0)\"", "lemma sigma1_lemma [simp]:\n  shows \"rec_eval (rec_sigma1 f) [x, y] = (\\<Sum> z \\<le> x. rec_eval f [z, y])\"", "lemma sigma2_lemma [simp]:\n  shows \"rec_eval (rec_sigma2 f) [x, y1, y2] = (\\<Sum> z \\<le> x. rec_eval f  [z, y1, y2])\"", "lemma accum1_lemma [simp]:\n  shows \"rec_eval (rec_accum1 f) [x, y] = (\\<Prod> z \\<le> x. rec_eval f  [z, y])\"", "lemma accum2_lemma [simp]:\n  shows \"rec_eval (rec_accum2 f) [x, y1, y2] = (\\<Prod> z \\<le> x. rec_eval f  [z, y1, y2])\"", "lemma accum3_lemma [simp]:\n  shows \"rec_eval (rec_accum3 f) [x, y1, y2, y3] = (\\<Prod> z \\<le> x. (rec_eval f)  [z, y1, y2, y3])\"", "lemma ex1_lemma [simp]:\n  \"rec_eval (rec_ex1 f) [x, y] = (if (\\<exists>z \\<le> x. 0 < rec_eval f [z, y]) then 1 else 0)\"", "lemma ex2_lemma [simp]:\n  \"rec_eval (rec_ex2 f) [x, y1, y2] = (if (\\<exists>z \\<le> x. 0 < rec_eval f [z, y1, y2]) then 1 else 0)\"", "lemma all1_lemma [simp]:\n  \"rec_eval (rec_all1 f) [x, y] = (if (\\<forall>z \\<le> x. 0 < rec_eval f [z, y]) then 1 else 0)\"", "lemma all2_lemma [simp]:\n  \"rec_eval (rec_all2 f) [x, y1, y2] = (if (\\<forall>z \\<le> x. 0 < rec_eval f [z, y1, y2]) then 1 else 0)\"", "lemma all3_lemma [simp]:\n  \"rec_eval (rec_all3 f) [x, y1, y2, y3] = (if (\\<forall>z \\<le> x. 0 < rec_eval f [z, y1, y2, y3]) then 1 else 0)\"", "lemma all1_less_lemma [simp]:\n  \"rec_eval (rec_all1_less f) [x, y] = (if (\\<forall>z < x. 0 < rec_eval f [z, y]) then 1 else 0)\"", "lemma all2_less_lemma [simp]:\n  \"rec_eval (rec_all2_less f) [x, y1, y2] = (if (\\<forall>z < x. 0 < rec_eval f [z, y1, y2]) then 1 else 0)\"", "lemma Quo0:\n  shows \"Quo 0 y = 0\"", "lemma Quo1:\n  \"x * (Quo x y) \\<le> y\"", "lemma Quo2:\n  \"b * (Quo b a) + a mod b = a\"", "lemma Quo3:\n  \"n * (Quo n m) = m - m mod n\"", "lemma Quo4:\n  assumes h: \"0 < x\"\n  shows \"y < x + x * Quo x y\"", "lemma Quo_div:\n  shows \"Quo x y = y div x\"", "lemma Quo_rec_quo:\n  shows \"rec_eval rec_quo [y, x] = Quo x y\"", "lemma quo_lemma [simp]:\n  shows \"rec_eval rec_quo [y, x] = y div x\"", "lemma Iter_comm:\n  \"(Iter f n) (f x) = f ((Iter f n) x)\"", "lemma iter_lemma [simp]:\n  \"rec_eval (rec_iter f) [n, x] =  Iter (\\<lambda>x. rec_eval f [x]) n x\"", "lemma BMax_rec_eq1:\n  \"BMax_rec R x = (GREATEST z. (R z \\<and> z \\<le> x) \\<or> z = 0)\"", "lemma BMax_rec_eq2:\n  \"BMax_rec R x = Max ({z. z \\<le> x \\<and> R z} \\<union> {0})\"", "lemma BMax_rec_eq3:\n  \"BMax_rec R x = Max (Set.filter (\\<lambda>z. R z) {..x} \\<union> {0})\"", "lemma max1_lemma [simp]:\n  \"rec_eval (rec_max1 f) [x, y] = BMax_rec (\\<lambda>u. rec_eval f [u, y] = 0) x\"", "lemma max2_lemma [simp]:\n  \"rec_eval (rec_max2 f) [x, y1, y2] = BMax_rec (\\<lambda>u. rec_eval f [u, y1, y2] = 0) x\"", "lemma fst_prod_decode:\n  \"pdec1 z = z - triangle (Max_triangle z)\"", "lemma snd_prod_decode:\n  \"pdec2 z = Max_triangle z - pdec1 z\"", "lemma le_triangle:\n  \"m \\<le> triangle (n + m)\"", "lemma Max_triangle_triangle_le:\n  \"triangle (Max_triangle z) \\<le> z\"", "lemma Max_triangle_le:\n  \"Max_triangle z \\<le> z\"", "lemma w_aux:\n  \"Max_triangle (triangle k + m) = Max_triangle_aux k m\"", "lemma y_aux: \"y \\<le> Max_triangle_aux y k\"", "lemma Max_triangle_greatest:\n  \"Max_triangle z = (GREATEST k. (triangle k \\<le> z \\<and> k \\<le> z) \\<or> k = 0)\"", "lemma triangle_lemma [simp]:\n  \"rec_eval rec_triangle [x] = triangle x\"", "lemma max_triangle_lemma [simp]:\n  \"rec_eval rec_max_triangle [x] = Max_triangle x\"", "lemma pdec1_lemma [simp]:\n  \"rec_eval rec_pdec1 [z] = pdec1 z\"", "lemma pdec2_lemma [simp]:\n  \"rec_eval rec_pdec2 [z] = pdec2 z\"", "lemma penc_lemma [simp]:\n  \"rec_eval rec_penc [m, n] = penc m n\"", "lemma pdec_zero_simps [simp]:\n  \"pdec1 0 = 0\"\n  \"pdec2 0 = 0\"", "lemma ldec_zero:\n  \"ldec 0 n = 0\"", "lemma list_encode_inverse:\n  \"ldec (lenc xs) n = (if n < length xs then xs ! n else 0)\"", "lemma lenc_length_le:\n  \"length xs \\<le> lenc xs\"", "lemma inside_False [simp]:\n  \"inside 0 n = False\"", "lemma inside_length [simp]:\n  \"inside (lenc xs) s = (s < length xs)\"", "lemma enclen_length [simp]:\n  \"enclen (lenc xs) = length xs\"", "lemma enclen_penc [simp]:\n  \"enclen (penc (Suc x) (lenc xs)) = Suc (enclen (lenc xs))\"", "lemma enclen_zero [simp]:\n  \"enclen 0 = 0\"", "lemma ldec_iter:\n  \"ldec z n = pdec1 (Iter pdec2 n z) - 1\"", "lemma inside_iter:\n  \"inside z n = (0 < Iter pdec2 n z)\"", "lemma lenc_lemma [simp]:\n  \"rec_eval (rec_lenc fs) xs = lenc (map (\\<lambda>f. rec_eval f xs) fs)\"", "lemma ldec_lemma [simp]:\n  \"rec_eval rec_ldec [z, n] = ldec z n\"", "lemma inside_lemma [simp]:\n  \"rec_eval rec_inside [z, n] = (if inside z n then 1 else 0)\"", "lemma enclen_lemma [simp]:\n  \"rec_eval rec_enclen [z] = enclen z\""], "translations": [["", "lemma if_zero_one [simp]:\n  \"(if P then 1 else 0) = (0::nat) \\<longleftrightarrow> \\<not> P\"\n  \"(0::nat) < (if P then 1 else 0) = P\"\n  \"(if P then 0 else 1) = (if \\<not>P then 1 else (0::nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if P then 1 else 0) = 0) = (\\<not> P) &&&\n    (0 < (if P then 1 else 0)) = P &&&\n    (if P then 0 else 1) = (if \\<not> P then 1 else 0)", "by (simp_all)"], ["", "lemma nth:\n  \"(x # xs) ! 0 = x\"\n  \"(x # y # xs) ! 1 = y\"\n  \"(x # y # z # xs) ! 2 = z\"\n  \"(x # y # z # u # xs) ! 3 = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x # xs) ! 0 = x &&& (x # y # xs) ! 1 = y) &&&\n    (x # y # z # xs) ! 2 = z &&& (x # y # z # u # xs) ! 3 = u", "by (simp_all)"], ["", "section \\<open>Some auxiliary lemmas about \\<open>\\<Sum>\\<close> and \\<open>\\<Prod>\\<close>\\<close>"], ["", "lemma setprod_atMost_Suc[simp]:\n  \"(\\<Prod>i \\<le> Suc n. f i) = (\\<Prod>i \\<le> n. f i) * f(Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f {..Suc n} = prod f {..n} * f (Suc n)", "by(simp add:atMost_Suc mult_ac)"], ["", "lemma setprod_lessThan_Suc[simp]:\n  \"(\\<Prod>i < Suc n. f i) = (\\<Prod>i < n. f i) * f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f {..<Suc n} = prod f {..<n} * f n", "by (simp add:lessThan_Suc mult_ac)"], ["", "lemma setsum_add_nat_ivl2: \"n \\<le> p  \\<Longrightarrow>\n  sum f {..<n} + sum f {n..p} = sum f {..p::nat}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> p \\<Longrightarrow> sum f {..<n} + sum f {n..p} = sum f {..p}", "apply(subst sum.union_disjoint[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. n \\<le> p \\<Longrightarrow> finite {..<n}\n 2. n \\<le> p \\<Longrightarrow> finite {n..p}\n 3. n \\<le> p \\<Longrightarrow> {..<n} \\<inter> {n..p} = {}\n 4. n \\<le> p \\<Longrightarrow> sum f ({..<n} \\<union> {n..p}) = sum f {..p}", "apply(auto simp add: ivl_disj_un_one)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma setsum_eq_zero [simp]:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  shows \"(\\<Sum>i < n. f i) = 0 \\<longleftrightarrow> (\\<forall>i < n. f i = 0)\"\n    \"(\\<Sum>i \\<le> n. f i) = 0 \\<longleftrightarrow> (\\<forall>i \\<le> n. f i = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum f {..<n} = 0) = (\\<forall>i<n. f i = 0) &&&\n    (sum f {..n} = 0) = (\\<forall>i\\<le>n. f i = 0)", "by (auto)"], ["", "lemma setprod_eq_zero [simp]:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  shows \"(\\<Prod>i < n. f i) = 0 \\<longleftrightarrow> (\\<exists>i < n. f i = 0)\"\n    \"(\\<Prod>i \\<le> n. f i) = 0 \\<longleftrightarrow> (\\<exists>i \\<le> n. f i = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod f {..<n} = 0) = (\\<exists>i<n. f i = 0) &&&\n    (prod f {..n} = 0) = (\\<exists>i\\<le>n. f i = 0)", "by (auto)"], ["", "lemma setsum_one_less:\n  fixes n::nat\n  assumes \"\\<forall>i < n. f i \\<le> 1\"\n  shows \"(\\<Sum>i < n. f i) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<n} \\<le> n", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n. f i \\<le> 1\n\ngoal (1 subgoal):\n 1. sum f {..<n} \\<le> n", "by (induct n) (auto)"], ["", "lemma setsum_one_le:\n  fixes n::nat\n  assumes \"\\<forall>i \\<le> n. f i \\<le> 1\"\n  shows \"(\\<Sum>i \\<le> n. f i) \\<le> Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..n} \\<le> Suc n", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. f i \\<le> 1\n\ngoal (1 subgoal):\n 1. sum f {..n} \\<le> Suc n", "by (induct n) (auto)"], ["", "lemma setsum_eq_one_le:\n  fixes n::nat\n  assumes \"\\<forall>i \\<le> n. f i = 1\"\n  shows \"(\\<Sum>i \\<le> n. f i) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..n} = Suc n", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. f i = 1\n\ngoal (1 subgoal):\n 1. sum f {..n} = Suc n", "by (induct n) (auto)"], ["", "lemma setsum_least_eq:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes h0: \"p \\<le> n\"\n  assumes h1: \"\\<forall>i \\<in> {..<p}. f i = 1\"\n  assumes h2: \"\\<forall>i \\<in> {p..n}. f i = 0\"\n  shows \"(\\<Sum>i \\<le> n. f i) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..n} = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f {..n} = p", "have eq_p: \"(\\<Sum>i \\<in> {..<p}. f i) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<p} = p", "using h1"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{..<p}. f i = 1\n\ngoal (1 subgoal):\n 1. sum f {..<p} = p", "by (induct p) (simp_all)"], ["proof (state)\nthis:\n  sum f {..<p} = p\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "have eq_zero: \"(\\<Sum>i \\<in> {p..n}. f i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {p..n} = 0", "using h2"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{p..n}. f i = 0\n\ngoal (1 subgoal):\n 1. sum f {p..n} = 0", "by auto"], ["proof (state)\nthis:\n  sum f {p..n} = 0\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "have \"(\\<Sum>i \\<le> n. f i) = (\\<Sum>i \\<in> {..<p}. f i) + (\\<Sum>i \\<in> {p..n}. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<p} + sum f {p..n}", "using h0"], ["proof (prove)\nusing this:\n  p \\<le> n\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<p} + sum f {p..n}", "by (simp add: setsum_add_nat_ivl2)"], ["proof (state)\nthis:\n  sum f {..n} = sum f {..<p} + sum f {p..n}\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "also"], ["proof (state)\nthis:\n  sum f {..n} = sum f {..<p} + sum f {p..n}\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "have \"... = (\\<Sum>i \\<in> {..<p}. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<p} + sum f {p..n} = sum f {..<p}", "using eq_zero"], ["proof (prove)\nusing this:\n  sum f {p..n} = 0\n\ngoal (1 subgoal):\n 1. sum f {..<p} + sum f {p..n} = sum f {..<p}", "by simp"], ["proof (state)\nthis:\n  sum f {..<p} + sum f {p..n} = sum f {..<p}\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "finally"], ["proof (chain)\npicking this:\n  sum f {..n} = sum f {..<p}", "show \"(\\<Sum>i \\<le> n. f i) = p\""], ["proof (prove)\nusing this:\n  sum f {..n} = sum f {..<p}\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "using eq_p"], ["proof (prove)\nusing this:\n  sum f {..n} = sum f {..<p}\n  sum f {..<p} = p\n\ngoal (1 subgoal):\n 1. sum f {..n} = p", "by simp"], ["proof (state)\nthis:\n  sum f {..n} = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_mult_le_one:\n  fixes m n::nat\n  assumes \"m \\<le> 1\" \"n \\<le> 1\"\n  shows \"m * n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * n \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> 1\n  n \\<le> 1\n\ngoal (1 subgoal):\n 1. m * n \\<le> 1", "by (induct n) (auto)"], ["", "lemma setprod_one_le:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes \"\\<forall>i \\<le> n. f i \\<le> 1\"\n  shows \"(\\<Prod>i \\<le> n. f i) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f {..n} \\<le> 1", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. f i \\<le> 1\n\ngoal (1 subgoal):\n 1. prod f {..n} \\<le> 1", "by (induct n) (auto intro: nat_mult_le_one)"], ["", "lemma setprod_greater_zero:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes \"\\<forall>i \\<le> n. f i \\<ge> 0\"\n  shows \"(\\<Prod>i \\<le> n. f i) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> prod f {..n}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. 0 \\<le> f i\n\ngoal (1 subgoal):\n 1. 0 \\<le> prod f {..n}", "by (induct n) (auto)"], ["", "lemma setprod_eq_one:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes \"\\<forall>i \\<le> n. f i = Suc 0\"\n  shows \"(\\<Prod>i \\<le> n. f i) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f {..n} = Suc 0", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. f i = Suc 0\n\ngoal (1 subgoal):\n 1. prod f {..n} = Suc 0", "by (induct n) (auto)"], ["", "lemma setsum_cut_off_less:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes h1: \"m \\<le> n\"\n    and     h2: \"\\<forall>i \\<in> {m..<n}. f i = 0\"\n  shows \"(\\<Sum>i < n. f i) = (\\<Sum>i < m. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "have eq_zero: \"(\\<Sum>i \\<in> {m..<n}. f i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {m..<n} = 0", "using h2"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{m..<n}. f i = 0\n\ngoal (1 subgoal):\n 1. sum f {m..<n} = 0", "by auto"], ["proof (state)\nthis:\n  sum f {m..<n} = 0\n\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "have \"(\\<Sum>i < n. f i) = (\\<Sum>i \\<in> {..<m}. f i) + (\\<Sum>i \\<in> {m..<n}. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m} + sum f {m..<n}", "using h1"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m} + sum f {m..<n}", "by (metis atLeast0LessThan le0 sum.atLeastLessThan_concat)"], ["proof (state)\nthis:\n  sum f {..<n} = sum f {..<m} + sum f {m..<n}\n\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "also"], ["proof (state)\nthis:\n  sum f {..<n} = sum f {..<m} + sum f {m..<n}\n\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "have \"... = (\\<Sum>i \\<in> {..<m}. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<m} + sum f {m..<n} = sum f {..<m}", "using eq_zero"], ["proof (prove)\nusing this:\n  sum f {m..<n} = 0\n\ngoal (1 subgoal):\n 1. sum f {..<m} + sum f {m..<n} = sum f {..<m}", "by simp"], ["proof (state)\nthis:\n  sum f {..<m} + sum f {m..<n} = sum f {..<m}\n\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "finally"], ["proof (chain)\npicking this:\n  sum f {..<n} = sum f {..<m}", "show \"(\\<Sum>i < n. f i) = (\\<Sum>i < m. f i)\""], ["proof (prove)\nusing this:\n  sum f {..<n} = sum f {..<m}\n\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f {..<m}", "by simp"], ["proof (state)\nthis:\n  sum f {..<n} = sum f {..<m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setsum_cut_off_le:\n  fixes f::\"nat \\<Rightarrow> nat\"\n  assumes h1: \"m \\<le> n\"\n    and     h2: \"\\<forall>i \\<in> {m..n}. f i = 0\"\n  shows \"(\\<Sum>i \\<le> n. f i) = (\\<Sum>i < m. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "have eq_zero: \"(\\<Sum>i \\<in> {m..n}. f i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {m..n} = 0", "using h2"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{m..n}. f i = 0\n\ngoal (1 subgoal):\n 1. sum f {m..n} = 0", "by auto"], ["proof (state)\nthis:\n  sum f {m..n} = 0\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "have \"(\\<Sum>i \\<le> n. f i) = (\\<Sum>i \\<in> {..<m}. f i) + (\\<Sum>i \\<in> {m..n}. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m} + sum f {m..n}", "using h1"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m} + sum f {m..n}", "by (simp add: setsum_add_nat_ivl2)"], ["proof (state)\nthis:\n  sum f {..n} = sum f {..<m} + sum f {m..n}\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "also"], ["proof (state)\nthis:\n  sum f {..n} = sum f {..<m} + sum f {m..n}\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "have \"... = (\\<Sum>i \\<in> {..<m}. f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<m} + sum f {m..n} = sum f {..<m}", "using eq_zero"], ["proof (prove)\nusing this:\n  sum f {m..n} = 0\n\ngoal (1 subgoal):\n 1. sum f {..<m} + sum f {m..n} = sum f {..<m}", "by simp"], ["proof (state)\nthis:\n  sum f {..<m} + sum f {m..n} = sum f {..<m}\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "finally"], ["proof (chain)\npicking this:\n  sum f {..n} = sum f {..<m}", "show \"(\\<Sum>i \\<le> n. f i) = (\\<Sum>i < m. f i)\""], ["proof (prove)\nusing this:\n  sum f {..n} = sum f {..<m}\n\ngoal (1 subgoal):\n 1. sum f {..n} = sum f {..<m}", "by simp"], ["proof (state)\nthis:\n  sum f {..n} = sum f {..<m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setprod_one [simp]:\n  fixes n::nat\n  shows \"(\\<Prod>i < n. Suc 0) = Suc 0\"\n    \"(\\<Prod>i \\<le> n. Suc 0) = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. Suc 0) = Suc 0 &&& (\\<Prod>i\\<le>n. Suc 0) = Suc 0", "by (induct n) (simp_all)"], ["", "section \\<open>Recursive Functions\\<close>"], ["", "datatype recf =  Z\n  |  S\n  |  Id nat nat\n  |  Cn nat recf \"recf list\"\n  |  Pr nat recf recf\n  |  Mn nat recf"], ["", "fun arity :: \"recf \\<Rightarrow> nat\"\n  where\n    \"arity Z = 1\"\n  | \"arity S = 1\"\n  | \"arity (Id m n) = m\"\n  | \"arity (Cn n f gs) = n\"\n  | \"arity (Pr n f g) = Suc n\"\n  | \"arity (Mn n f) = n\""], ["", "text \\<open>Abbreviations for calculating the arity of the constructors\\<close>"], ["", "abbreviation\n  \"CN f gs \\<equiv> Cn (arity (hd gs)) f gs\""], ["", "abbreviation\n  \"PR f g \\<equiv> Pr (arity f) f g\""], ["", "abbreviation\n  \"MN f \\<equiv> Mn (arity f - 1) f\""], ["", "text \\<open>the evaluation function and termination relation\\<close>"], ["", "fun rec_eval :: \"recf \\<Rightarrow> nat list \\<Rightarrow> nat\"\n  where\n    \"rec_eval Z xs = 0\"\n  | \"rec_eval S xs = Suc (xs ! 0)\"\n  | \"rec_eval (Id m n) xs = xs ! n\"\n  | \"rec_eval (Cn n f gs) xs = rec_eval f (map (\\<lambda>x. rec_eval x xs) gs)\"\n  | \"rec_eval (Pr n f g) (0 # xs) = rec_eval f xs\"\n  | \"rec_eval (Pr n f g) (Suc x # xs) =\n     rec_eval g (x # (rec_eval (Pr n f g) (x # xs)) # xs)\"\n  | \"rec_eval (Mn n f) xs = (LEAST x. rec_eval f (x # xs) = 0)\""], ["", "inductive\n  terminates :: \"recf \\<Rightarrow> nat list \\<Rightarrow> bool\"\n  where\n    termi_z: \"terminates Z [n]\"\n  | termi_s: \"terminates S [n]\"\n  | termi_id: \"\\<lbrakk>n < m; length xs = m\\<rbrakk> \\<Longrightarrow> terminates (Id m n) xs\"\n  | termi_cn: \"\\<lbrakk>terminates f (map (\\<lambda>g. rec_eval g xs) gs);\n              \\<forall>g \\<in> set gs. terminates g xs; length xs = n\\<rbrakk> \\<Longrightarrow> terminates (Cn n f gs) xs\"\n  | termi_pr: \"\\<lbrakk>\\<forall> y < x. terminates g (y # (rec_eval (Pr n f g) (y # xs) # xs));\n              terminates f xs;\n              length xs = n\\<rbrakk>\n              \\<Longrightarrow> terminates (Pr n f g) (x # xs)\"\n  | termi_mn: \"\\<lbrakk>length xs = n; terminates f (r # xs);\n              rec_eval f (r # xs) = 0;\n              \\<forall> i < r. terminates f (i # xs) \\<and> rec_eval f (i # xs) > 0\\<rbrakk> \\<Longrightarrow> terminates (Mn n f) xs\""], ["", "section \\<open>Arithmetic Functions\\<close>"], ["", "text \\<open>\n  \\<open>constn n\\<close> is the recursive function which computes\n  natural number \\<open>n\\<close>.\n\\<close>"], ["", "fun constn :: \"nat \\<Rightarrow> recf\"\n  where\n    \"constn 0 = Z\"  |\n    \"constn (Suc n) = CN S [constn n]\""], ["", "definition\n  \"rec_swap f = CN f [Id 2 1, Id 2 0]\""], ["", "definition\n  \"rec_add = PR (Id 1 0) (CN S [Id 3 1])\""], ["", "definition\n  \"rec_mult = PR Z (CN rec_add [Id 3 1, Id 3 2])\""], ["", "definition\n  \"rec_power = rec_swap (PR (constn 1) (CN rec_mult [Id 3 1, Id 3 2]))\""], ["", "definition\n  \"rec_fact_aux = PR (constn 1) (CN rec_mult [CN S [Id 3 0], Id 3 1])\""], ["", "definition\n  \"rec_fact = CN rec_fact_aux [Id 1 0, Id 1 0]\""], ["", "definition\n  \"rec_predecessor = CN (PR Z (Id 3 0)) [Id 1 0, Id 1 0]\""], ["", "definition\n  \"rec_minus = rec_swap (PR (Id 1 0) (CN rec_predecessor [Id 3 1]))\""], ["", "lemma constn_lemma [simp]:\n  \"rec_eval (constn n) xs = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (constn n) xs = n", "by (induct n) (simp_all)"], ["", "lemma swap_lemma [simp]:\n  \"rec_eval (rec_swap f) [x, y] = rec_eval f [y, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_swap f) [x, y] = rec_eval f [y, x]", "by (simp add: rec_swap_def)"], ["", "lemma add_lemma [simp]:\n  \"rec_eval rec_add [x, y] =  x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_add [x, y] = x + y", "by (induct x) (simp_all add: rec_add_def)"], ["", "lemma mult_lemma [simp]:\n  \"rec_eval rec_mult [x, y] = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_mult [x, y] = x * y", "by (induct x) (simp_all add: rec_mult_def)"], ["", "lemma power_lemma [simp]:\n  \"rec_eval rec_power [x, y] = x ^ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_power [x, y] = x ^ y", "by (induct y) (simp_all add: rec_power_def)"], ["", "lemma fact_aux_lemma [simp]:\n  \"rec_eval rec_fact_aux [x, y] = fact x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_fact_aux [x, y] = fact x", "by (induct x) (simp_all add: rec_fact_aux_def)"], ["", "lemma fact_lemma [simp]:\n  \"rec_eval rec_fact [x] = fact x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_fact [x] = fact x", "by (simp add: rec_fact_def)"], ["", "lemma pred_lemma [simp]:\n  \"rec_eval rec_predecessor [x] =  x - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_predecessor [x] = x - 1", "by (induct x) (simp_all add: rec_predecessor_def)"], ["", "lemma minus_lemma [simp]:\n  \"rec_eval rec_minus [x, y] = x - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_minus [x, y] = x - y", "by (induct y) (simp_all add: rec_minus_def)"], ["", "section \\<open>Logical functions\\<close>"], ["", "text \\<open>\n  The \\<open>sign\\<close> function returns 1 when the input argument\n  is greater than \\<open>0\\<close>.\\<close>"], ["", "definition\n  \"rec_sign = CN rec_minus [constn 1, CN rec_minus [constn 1, Id 1 0]]\""], ["", "definition\n  \"rec_not = CN rec_minus [constn 1, Id 1 0]\""], ["", "text \\<open>\n  \\<open>rec_eq\\<close> compares two arguments: returns \\<open>1\\<close>\n  if they are equal; \\<open>0\\<close> otherwise.\\<close>"], ["", "definition\n  \"rec_eq = CN rec_minus [CN (constn 1) [Id 2 0], CN rec_add [rec_minus, rec_swap rec_minus]]\""], ["", "definition\n  \"rec_noteq = CN rec_not [rec_eq]\""], ["", "definition\n  \"rec_conj = CN rec_sign [rec_mult]\""], ["", "definition\n  \"rec_disj = CN rec_sign [rec_add]\""], ["", "definition\n  \"rec_imp = CN rec_disj [CN rec_not [Id 2 0], Id 2 1]\""], ["", "text \\<open>@{term \"rec_ifz [z, x, y]\"} returns x if z is zero,\n  y otherwise;  @{term \"rec_if [z, x, y]\"} returns x if z is *not*\n  zero, y otherwise\\<close>"], ["", "definition\n  \"rec_ifz = PR (Id 2 0) (Id 4 3)\""], ["", "definition\n  \"rec_if = CN rec_ifz [CN rec_not [Id 3 0], Id 3 1, Id 3 2]\""], ["", "lemma sign_lemma [simp]:\n  \"rec_eval rec_sign [x] = (if x = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_sign [x] = (if x = 0 then 0 else 1)", "by (simp add: rec_sign_def)"], ["", "lemma not_lemma [simp]:\n  \"rec_eval rec_not [x] = (if x = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_not [x] = (if x = 0 then 1 else 0)", "by (simp add: rec_not_def)"], ["", "lemma eq_lemma [simp]:\n  \"rec_eval rec_eq [x, y] = (if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_eq [x, y] = (if x = y then 1 else 0)", "by (simp add: rec_eq_def)"], ["", "lemma noteq_lemma [simp]:\n  \"rec_eval rec_noteq [x, y] = (if x \\<noteq> y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_noteq [x, y] = (if x \\<noteq> y then 1 else 0)", "by (simp add: rec_noteq_def)"], ["", "lemma conj_lemma [simp]:\n  \"rec_eval rec_conj [x, y] = (if x = 0 \\<or> y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_conj [x, y] = (if x = 0 \\<or> y = 0 then 0 else 1)", "by (simp add: rec_conj_def)"], ["", "lemma disj_lemma [simp]:\n  \"rec_eval rec_disj [x, y] = (if x = 0 \\<and> y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_disj [x, y] = (if x = 0 \\<and> y = 0 then 0 else 1)", "by (simp add: rec_disj_def)"], ["", "lemma imp_lemma [simp]:\n  \"rec_eval rec_imp [x, y] = (if 0 < x \\<and> y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_imp [x, y] = (if 0 < x \\<and> y = 0 then 0 else 1)", "by (simp add: rec_imp_def)"], ["", "lemma ifz_lemma [simp]:\n  \"rec_eval rec_ifz [z, x, y] = (if z = 0 then x else y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_ifz [z, x, y] = (if z = 0 then x else y)", "by (cases z) (simp_all add: rec_ifz_def)"], ["", "lemma if_lemma [simp]:\n  \"rec_eval rec_if [z, x, y] = (if 0 < z then x else y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_if [z, x, y] = (if 0 < z then x else y)", "by (simp add: rec_if_def)"], ["", "section \\<open>Less and Le Relations\\<close>"], ["", "text \\<open>\n  \\<open>rec_less\\<close> compares two arguments and returns \\<open>1\\<close> if\n  the first is less than the second; otherwise returns \\<open>0\\<close>.\\<close>"], ["", "definition\n  \"rec_less = CN rec_sign [rec_swap rec_minus]\""], ["", "definition\n  \"rec_le = CN rec_disj [rec_less, rec_eq]\""], ["", "lemma less_lemma [simp]:\n  \"rec_eval rec_less [x, y] = (if x < y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_less [x, y] = (if x < y then 1 else 0)", "by (simp add: rec_less_def)"], ["", "lemma le_lemma [simp]:\n  \"rec_eval rec_le [x, y] = (if (x \\<le> y) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_le [x, y] = (if x \\<le> y then 1 else 0)", "by(simp add: rec_le_def)"], ["", "section \\<open>Summation and Product Functions\\<close>"], ["", "definition\n  \"rec_sigma1 f = PR (CN f [CN Z [Id 1 0], Id 1 0])\n                     (CN rec_add [Id 3 1, CN f [CN S [Id 3 0], Id 3 2]])\""], ["", "definition\n  \"rec_sigma2 f = PR (CN f [CN Z [Id 2 0], Id 2 0, Id 2 1])\n                     (CN rec_add [Id 4 1, CN f [CN S [Id 4 0], Id 4 2, Id 4 3]])\""], ["", "definition\n  \"rec_accum1 f = PR (CN f [CN Z [Id 1 0], Id 1 0])\n                     (CN rec_mult [Id 3 1, CN f [CN S [Id 3 0], Id 3 2]])\""], ["", "definition\n  \"rec_accum2 f = PR (CN f [CN Z [Id 2 0], Id 2 0, Id 2 1])\n                     (CN rec_mult [Id 4 1, CN f [CN S [Id 4 0], Id 4 2, Id 4 3]])\""], ["", "definition\n  \"rec_accum3 f = PR (CN f [CN Z [Id 3 0], Id 3 0, Id 3 1, Id 3 2])\n                     (CN rec_mult [Id 5 1, CN f [CN S [Id 5 0], Id 5 2, Id 5 3, Id 5 4]])\""], ["", "lemma sigma1_lemma [simp]:\n  shows \"rec_eval (rec_sigma1 f) [x, y] = (\\<Sum> z \\<le> x. rec_eval f [z, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_sigma1 f) [x, y] = (\\<Sum>z\\<le>x. rec_eval f [z, y])", "by (induct x) (simp_all add: rec_sigma1_def)"], ["", "lemma sigma2_lemma [simp]:\n  shows \"rec_eval (rec_sigma2 f) [x, y1, y2] = (\\<Sum> z \\<le> x. rec_eval f  [z, y1, y2])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_sigma2 f) [x, y1, y2] =\n    (\\<Sum>z\\<le>x. rec_eval f [z, y1, y2])", "by (induct x) (simp_all add: rec_sigma2_def)"], ["", "lemma accum1_lemma [simp]:\n  shows \"rec_eval (rec_accum1 f) [x, y] = (\\<Prod> z \\<le> x. rec_eval f  [z, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_accum1 f) [x, y] = (\\<Prod>z\\<le>x. rec_eval f [z, y])", "by (induct x) (simp_all add: rec_accum1_def)"], ["", "lemma accum2_lemma [simp]:\n  shows \"rec_eval (rec_accum2 f) [x, y1, y2] = (\\<Prod> z \\<le> x. rec_eval f  [z, y1, y2])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_accum2 f) [x, y1, y2] =\n    (\\<Prod>z\\<le>x. rec_eval f [z, y1, y2])", "by (induct x) (simp_all add: rec_accum2_def)"], ["", "lemma accum3_lemma [simp]:\n  shows \"rec_eval (rec_accum3 f) [x, y1, y2, y3] = (\\<Prod> z \\<le> x. (rec_eval f)  [z, y1, y2, y3])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_accum3 f) [x, y1, y2, y3] =\n    (\\<Prod>z\\<le>x. rec_eval f [z, y1, y2, y3])", "by (induct x) (simp_all add: rec_accum3_def)"], ["", "section \\<open>Bounded Quantifiers\\<close>"], ["", "definition\n  \"rec_all1 f = CN rec_sign [rec_accum1 f]\""], ["", "definition\n  \"rec_all2 f = CN rec_sign [rec_accum2 f]\""], ["", "definition\n  \"rec_all3 f = CN rec_sign [rec_accum3 f]\""], ["", "definition\n  \"rec_all1_less f = (let cond1 = CN rec_eq [Id 3 0, Id 3 1] in\n                      let cond2 = CN f [Id 3 0, Id 3 2]\n                      in CN (rec_all2 (CN rec_disj [cond1, cond2])) [Id 2 0, Id 2 0, Id 2 1])\""], ["", "definition\n  \"rec_all2_less f = (let cond1 = CN rec_eq [Id 4 0, Id 4 1] in\n                      let cond2 = CN f [Id 4 0, Id 4 2, Id 4 3] in\n                      CN (rec_all3 (CN rec_disj [cond1, cond2])) [Id 3 0, Id 3 0, Id 3 1, Id 3 2])\""], ["", "definition\n  \"rec_ex1 f = CN rec_sign [rec_sigma1 f]\""], ["", "definition\n  \"rec_ex2 f = CN rec_sign [rec_sigma2 f]\""], ["", "lemma ex1_lemma [simp]:\n  \"rec_eval (rec_ex1 f) [x, y] = (if (\\<exists>z \\<le> x. 0 < rec_eval f [z, y]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_ex1 f) [x, y] =\n    (if \\<exists>z\\<le>x. 0 < rec_eval f [z, y] then 1 else 0)", "by (simp add: rec_ex1_def)"], ["", "lemma ex2_lemma [simp]:\n  \"rec_eval (rec_ex2 f) [x, y1, y2] = (if (\\<exists>z \\<le> x. 0 < rec_eval f [z, y1, y2]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_ex2 f) [x, y1, y2] =\n    (if \\<exists>z\\<le>x. 0 < rec_eval f [z, y1, y2] then 1 else 0)", "by (simp add: rec_ex2_def)"], ["", "lemma all1_lemma [simp]:\n  \"rec_eval (rec_all1 f) [x, y] = (if (\\<forall>z \\<le> x. 0 < rec_eval f [z, y]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_all1 f) [x, y] =\n    (if \\<forall>z\\<le>x. 0 < rec_eval f [z, y] then 1 else 0)", "by (simp add: rec_all1_def)"], ["", "lemma all2_lemma [simp]:\n  \"rec_eval (rec_all2 f) [x, y1, y2] = (if (\\<forall>z \\<le> x. 0 < rec_eval f [z, y1, y2]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_all2 f) [x, y1, y2] =\n    (if \\<forall>z\\<le>x. 0 < rec_eval f [z, y1, y2] then 1 else 0)", "by (simp add: rec_all2_def)"], ["", "lemma all3_lemma [simp]:\n  \"rec_eval (rec_all3 f) [x, y1, y2, y3] = (if (\\<forall>z \\<le> x. 0 < rec_eval f [z, y1, y2, y3]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_all3 f) [x, y1, y2, y3] =\n    (if \\<forall>z\\<le>x. 0 < rec_eval f [z, y1, y2, y3] then 1 else 0)", "by (simp add: rec_all3_def)"], ["", "lemma all1_less_lemma [simp]:\n  \"rec_eval (rec_all1_less f) [x, y] = (if (\\<forall>z < x. 0 < rec_eval f [z, y]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_all1_less f) [x, y] =\n    (if \\<forall>z<x. 0 < rec_eval f [z, y] then 1 else 0)", "apply(auto simp add: Let_def rec_all1_less_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>z\\<le>x. z = x \\<or> 0 < rec_eval f [z, y]; z < x;\n        rec_eval f [z, y] = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<le>x.\n                            z \\<noteq> x \\<and> rec_eval f [z, y] = 0\n 2. \\<And>z.\n       \\<lbrakk>z \\<le> x; z \\<noteq> x; rec_eval f [z, y] = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z<x. rec_eval f [z, y] = 0", "apply (metis nat_less_le)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma all2_less_lemma [simp]:\n  \"rec_eval (rec_all2_less f) [x, y1, y2] = (if (\\<forall>z < x. 0 < rec_eval f [z, y1, y2]) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_all2_less f) [x, y1, y2] =\n    (if \\<forall>z<x. 0 < rec_eval f [z, y1, y2] then 1 else 0)", "apply(auto simp add: Let_def rec_all2_less_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>z\\<le>x. z = x \\<or> 0 < rec_eval f [z, y1, y2];\n        z < x; rec_eval f [z, y1, y2] = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z\\<le>x.\n                            z \\<noteq> x \\<and> rec_eval f [z, y1, y2] = 0\n 2. \\<And>z.\n       \\<lbrakk>z \\<le> x; z \\<noteq> x; rec_eval f [z, y1, y2] = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z<x. rec_eval f [z, y1, y2] = 0", "apply(metis nat_less_le)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Quotients\\<close>"], ["", "definition\n  \"rec_quo = (let lhs = CN S [Id 3 0] in\n              let rhs = CN rec_mult [Id 3 2, CN S [Id 3 1]] in\n              let cond = CN rec_eq [lhs, rhs] in\n              let if_stmt = CN rec_if [cond, CN S [Id 3 1], Id 3 1]\n              in PR Z if_stmt)\""], ["", "fun Quo where\n  \"Quo x 0 = 0\"\n| \"Quo x (Suc y) = (if (Suc y = x * (Suc (Quo x y))) then Suc (Quo x y) else Quo x y)\""], ["", "lemma Quo0:\n  shows \"Quo 0 y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quo 0 y = 0", "by (induct y) (auto)"], ["", "lemma Quo1:\n  \"x * (Quo x y) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * Quo x y \\<le> y", "by (induct y) (simp_all)"], ["", "lemma Quo2:\n  \"b * (Quo b a) + a mod b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * Quo b a + a mod b = a", "by (induct a) (auto simp add: mod_Suc)"], ["", "lemma Quo3:\n  \"n * (Quo n m) = m - m mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * Quo n m = m - m mod n", "using Quo2[of n m]"], ["proof (prove)\nusing this:\n  n * Quo n m + m mod n = m\n\ngoal (1 subgoal):\n 1. n * Quo n m = m - m mod n", "by (auto)"], ["", "lemma Quo4:\n  assumes h: \"0 < x\"\n  shows \"y < x + x * Quo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x + x * Quo x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y < x + x * Quo x y", "have \"x - (y mod x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x - y mod x", "using mod_less_divisor assms"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> ?m mod ?n < ?n\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 < x - y mod x", "by auto"], ["proof (state)\nthis:\n  0 < x - y mod x\n\ngoal (1 subgoal):\n 1. y < x + x * Quo x y", "then"], ["proof (chain)\npicking this:\n  0 < x - y mod x", "have \"y < y + (x - (y mod x))\""], ["proof (prove)\nusing this:\n  0 < x - y mod x\n\ngoal (1 subgoal):\n 1. y < y + (x - y mod x)", "by simp"], ["proof (state)\nthis:\n  y < y + (x - y mod x)\n\ngoal (1 subgoal):\n 1. y < x + x * Quo x y", "then"], ["proof (chain)\npicking this:\n  y < y + (x - y mod x)", "have \"y < x + (y - (y mod x))\""], ["proof (prove)\nusing this:\n  y < y + (x - y mod x)\n\ngoal (1 subgoal):\n 1. y < x + (y - y mod x)", "by simp"], ["proof (state)\nthis:\n  y < x + (y - y mod x)\n\ngoal (1 subgoal):\n 1. y < x + x * Quo x y", "then"], ["proof (chain)\npicking this:\n  y < x + (y - y mod x)", "show \"y < x + x * (Quo x y)\""], ["proof (prove)\nusing this:\n  y < x + (y - y mod x)\n\ngoal (1 subgoal):\n 1. y < x + x * Quo x y", "by (simp add: Quo3)"], ["proof (state)\nthis:\n  y < x + x * Quo x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Quo_div:\n  shows \"Quo x y = y div x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quo x y = y div x", "by (metis Quo0 Quo1 Quo4 div_by_0 div_nat_eqI mult_Suc_right neq0_conv)"], ["", "lemma Quo_rec_quo:\n  shows \"rec_eval rec_quo [y, x] = Quo x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_quo [y, x] = Quo x y", "by (induct y) (simp_all add: rec_quo_def)"], ["", "lemma quo_lemma [simp]:\n  shows \"rec_eval rec_quo [y, x] = y div x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_quo [y, x] = y div x", "by (simp add: Quo_div Quo_rec_quo)"], ["", "section \\<open>Iteration\\<close>"], ["", "definition\n  \"rec_iter f = PR (Id 1 0) (CN f [Id 3 1])\""], ["", "fun Iter where\n  \"Iter f 0 = id\"\n| \"Iter f (Suc n) = f \\<circ> (Iter f n)\""], ["", "lemma Iter_comm:\n  \"(Iter f n) (f x) = f ((Iter f n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Iter f n (f x) = f (Iter f n x)", "by (induct n) (simp_all)"], ["", "lemma iter_lemma [simp]:\n  \"rec_eval (rec_iter f) [n, x] =  Iter (\\<lambda>x. rec_eval f [x]) n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_iter f) [n, x] = Iter (\\<lambda>x. rec_eval f [x]) n x", "by (induct n) (simp_all add: rec_iter_def)"], ["", "section \\<open>Bounded Maximisation\\<close>"], ["", "fun BMax_rec where\n  \"BMax_rec R 0 = 0\"\n| \"BMax_rec R (Suc n) = (if R (Suc n) then (Suc n) else BMax_rec R n)\""], ["", "definition\n  BMax_set :: \"(nat \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"BMax_set R x = Max ({z. z \\<le> x \\<and> R z} \\<union> {0})\""], ["", "lemma BMax_rec_eq1:\n  \"BMax_rec R x = (GREATEST z. (R z \\<and> z \\<le> x) \\<or> z = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BMax_rec R x = (GREATEST z. R z \\<and> z \\<le> x \\<or> z = 0)", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BMax_rec R 0 = (GREATEST z. R z \\<and> z \\<le> 0 \\<or> z = 0)\n 2. \\<And>x.\n       BMax_rec R x =\n       (GREATEST z. R z \\<and> z \\<le> x \\<or> z = 0) \\<Longrightarrow>\n       BMax_rec R (Suc x) =\n       (GREATEST z. R z \\<and> z \\<le> Suc x \\<or> z = 0)", "apply(auto intro: Greatest_equality Greatest_equality[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>BMax_rec R x =\n                (GREATEST z. R z \\<and> z \\<le> x \\<or> z = 0);\n        \\<not> R (Suc x)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST z. R z \\<and> z \\<le> x \\<or> z = 0) =\n                         (GREATEST z. R z \\<and> z \\<le> Suc x \\<or> z = 0)", "apply(simp add: le_Suc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>BMax_rec R x =\n                (GREATEST z. R z \\<and> z \\<le> x \\<or> z = 0);\n        \\<not> R (Suc x)\\<rbrakk>\n       \\<Longrightarrow> (GREATEST z. R z \\<and> z \\<le> x \\<or> z = 0) =\n                         (GREATEST z.\n                             R z \\<and> (z \\<le> x \\<or> z = Suc x) \\<or>\n                             z = 0)", "by metis"], ["", "lemma BMax_rec_eq2:\n  \"BMax_rec R x = Max ({z. z \\<le> x \\<and> R z} \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BMax_rec R x = Max ({z. z \\<le> x \\<and> R z} \\<union> {0})", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. BMax_rec R 0 = Max ({z. z \\<le> 0 \\<and> R z} \\<union> {0})\n 2. \\<And>x.\n       BMax_rec R x =\n       Max ({z. z \\<le> x \\<and> R z} \\<union> {0}) \\<Longrightarrow>\n       BMax_rec R (Suc x) = Max ({z. z \\<le> Suc x \\<and> R z} \\<union> {0})", "apply(auto intro: Max_eqI Max_eqI[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>BMax_rec R x = Max (insert 0 {z. z \\<le> x \\<and> R z});\n        \\<not> R (Suc x)\\<rbrakk>\n       \\<Longrightarrow> Max (insert 0 {z. z \\<le> x \\<and> R z}) =\n                         Max (insert 0 {z. z \\<le> Suc x \\<and> R z})", "apply(simp add: le_Suc_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>BMax_rec R x = Max (insert 0 {z. z \\<le> x \\<and> R z});\n        \\<not> R (Suc x)\\<rbrakk>\n       \\<Longrightarrow> Max (insert 0 {z. z \\<le> x \\<and> R z}) =\n                         Max (insert 0\n                               {z. (z \\<le> x \\<or> z = Suc x) \\<and> R z})", "by metis"], ["", "lemma BMax_rec_eq3:\n  \"BMax_rec R x = Max (Set.filter (\\<lambda>z. R z) {..x} \\<union> {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BMax_rec R x = Max (Set.filter R {..x} \\<union> {0})", "by (simp add: BMax_rec_eq2 Set.filter_def)"], ["", "definition\n  \"rec_max1 f = PR Z (CN rec_ifz [CN f [CN S [Id 3 0], Id 3 2], CN S [Id 3 0], Id 3 1])\""], ["", "lemma max1_lemma [simp]:\n  \"rec_eval (rec_max1 f) [x, y] = BMax_rec (\\<lambda>u. rec_eval f [u, y] = 0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_max1 f) [x, y] =\n    BMax_rec (\\<lambda>u. rec_eval f [u, y] = 0) x", "by (induct x) (simp_all add: rec_max1_def)"], ["", "definition\n  \"rec_max2 f = PR Z (CN rec_ifz [CN f [CN S [Id 4 0], Id 4 2, Id 4 3], CN S [Id 4 0], Id 4 1])\""], ["", "lemma max2_lemma [simp]:\n  \"rec_eval (rec_max2 f) [x, y1, y2] = BMax_rec (\\<lambda>u. rec_eval f [u, y1, y2] = 0) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_max2 f) [x, y1, y2] =\n    BMax_rec (\\<lambda>u. rec_eval f [u, y1, y2] = 0) x", "by (induct x) (simp_all add: rec_max2_def)"], ["", "section \\<open>Encodings using Cantor's pairing function\\<close>"], ["", "text \\<open>\n  We use Cantor's pairing function from Nat-Bijection.\n  However, we need to prove that the formulation of the\n  decoding function there is recursive. For this we first\n  prove that we can extract the maximal triangle number\n  using @{term prod_decode}.\n\\<close>"], ["", "abbreviation Max_triangle_aux where\n  \"Max_triangle_aux k z \\<equiv> fst (prod_decode_aux k z) + snd (prod_decode_aux k z)\""], ["", "abbreviation Max_triangle where\n  \"Max_triangle z \\<equiv> Max_triangle_aux 0 z\""], ["", "abbreviation\n  \"pdec1 z \\<equiv> fst (prod_decode z)\""], ["", "abbreviation\n  \"pdec2 z \\<equiv> snd (prod_decode z)\""], ["", "abbreviation\n  \"penc m n \\<equiv> prod_encode (m, n)\""], ["", "lemma fst_prod_decode:\n  \"pdec1 z = z - triangle (Max_triangle z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 z = z - triangle (Max_triangle z)", "by (subst (3) prod_decode_inverse[symmetric])\n    (simp add: prod_encode_def prod_decode_def split: prod.split)"], ["", "lemma snd_prod_decode:\n  \"pdec2 z = Max_triangle z - pdec1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 z = Max_triangle z - pdec1 z", "by (simp only: prod_decode_def)"], ["", "lemma le_triangle:\n  \"m \\<le> triangle (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> triangle (n + m)", "by (induct m) (simp_all)"], ["", "lemma Max_triangle_triangle_le:\n  \"triangle (Max_triangle z) \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triangle (Max_triangle z) \\<le> z", "by (subst (9) prod_decode_inverse[symmetric])\n    (simp add: prod_decode_def prod_encode_def split: prod.split)"], ["", "lemma Max_triangle_le:\n  \"Max_triangle z \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> z", "have \"Max_triangle z \\<le> triangle (Max_triangle z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> triangle (Max_triangle z)", "using le_triangle[of _ 0, simplified]"], ["proof (prove)\nusing this:\n  ?m \\<le> triangle ?m\n\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> triangle (Max_triangle z)", "by simp"], ["proof (state)\nthis:\n  Max_triangle z \\<le> triangle (Max_triangle z)\n\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> z", "also"], ["proof (state)\nthis:\n  Max_triangle z \\<le> triangle (Max_triangle z)\n\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> z", "have \"... \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triangle (Max_triangle z) \\<le> z", "by (rule Max_triangle_triangle_le)"], ["proof (state)\nthis:\n  triangle (Max_triangle z) \\<le> z\n\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> z", "finally"], ["proof (chain)\npicking this:\n  Max_triangle z \\<le> z", "show \"Max_triangle z \\<le> z\""], ["proof (prove)\nusing this:\n  Max_triangle z \\<le> z\n\ngoal (1 subgoal):\n 1. Max_triangle z \\<le> z", "."], ["proof (state)\nthis:\n  Max_triangle z \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma w_aux:\n  \"Max_triangle (triangle k + m) = Max_triangle_aux k m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_triangle (triangle k + m) = Max_triangle_aux k m", "by (simp add: prod_decode_def[symmetric] prod_decode_triangle_add)"], ["", "lemma y_aux: \"y \\<le> Max_triangle_aux y k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> Max_triangle_aux y k", "apply(induct k arbitrary: y rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<forall>m<n.\n          \\<forall>x. x \\<le> Max_triangle_aux x m \\<Longrightarrow>\n       y \\<le> Max_triangle_aux y n", "apply(subst (1 2) prod_decode_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<forall>m<n.\n          \\<forall>x. x \\<le> Max_triangle_aux x m \\<Longrightarrow>\n       y \\<le> fst (if n \\<le> y then (n, y - n)\n                    else prod_decode_aux (Suc y) (n - Suc y)) +\n               snd (if n \\<le> y then (n, y - n)\n                    else prod_decode_aux (Suc y) (n - Suc y))", "by(auto dest!:spec mp elim:Suc_leD)"], ["", "lemma Max_triangle_greatest:\n  \"Max_triangle z = (GREATEST k. (triangle k \\<le> z \\<and> k \\<le> z) \\<or> k = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_triangle z =\n    (GREATEST k. triangle k \\<le> z \\<and> k \\<le> z \\<or> k = 0)", "apply(rule Greatest_equality[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. triangle (Max_triangle z) \\<le> z \\<and> Max_triangle z \\<le> z \\<or>\n    Max_triangle z = 0\n 2. \\<And>y.\n       triangle y \\<le> z \\<and> y \\<le> z \\<or> y = 0 \\<Longrightarrow>\n       y \\<le> Max_triangle z", "apply(rule disjI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. triangle (Max_triangle z) \\<le> z \\<and> Max_triangle z \\<le> z\n 2. \\<And>y.\n       triangle y \\<le> z \\<and> y \\<le> z \\<or> y = 0 \\<Longrightarrow>\n       y \\<le> Max_triangle z", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. triangle (Max_triangle z) \\<le> z\n 2. Max_triangle z \\<le> z\n 3. \\<And>y.\n       triangle y \\<le> z \\<and> y \\<le> z \\<or> y = 0 \\<Longrightarrow>\n       y \\<le> Max_triangle z", "apply(rule Max_triangle_triangle_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Max_triangle z \\<le> z\n 2. \\<And>y.\n       triangle y \\<le> z \\<and> y \\<le> z \\<or> y = 0 \\<Longrightarrow>\n       y \\<le> Max_triangle z", "apply(rule Max_triangle_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       triangle y \\<le> z \\<and> y \\<le> z \\<or> y = 0 \\<Longrightarrow>\n       y \\<le> Max_triangle z", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       triangle y \\<le> z \\<and> y \\<le> z \\<Longrightarrow>\n       y \\<le> Max_triangle z\n 2. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(erule conjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>triangle y \\<le> z; y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> y \\<le> Max_triangle z\n 2. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(subst (asm) (1) le_iff_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<exists>c. z = triangle y + c; y \\<le> z\\<rbrakk>\n       \\<Longrightarrow> y \\<le> Max_triangle z\n 2. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y c.\n       \\<lbrakk>y \\<le> z; z = triangle y + c\\<rbrakk>\n       \\<Longrightarrow> y \\<le> Max_triangle z\n 2. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y c.\n       \\<lbrakk>y \\<le> triangle y + c; z = triangle y + c\\<rbrakk>\n       \\<Longrightarrow> y \\<le> Max_triangle (triangle y + c)\n 2. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(simp only: w_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y c.\n       \\<lbrakk>y \\<le> triangle y + c; z = triangle y + c\\<rbrakk>\n       \\<Longrightarrow> y \\<le> Max_triangle_aux y c\n 2. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(rule y_aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y = 0 \\<Longrightarrow> y \\<le> Max_triangle z", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  \"rec_triangle = CN rec_quo [CN rec_mult [Id 1 0, S], constn 2]\""], ["", "definition\n  \"rec_max_triangle =\n       (let cond = CN rec_not [CN rec_le [CN rec_triangle [Id 2 0], Id 2 1]] in\n        CN (rec_max1 cond) [Id 1 0, Id 1 0])\""], ["", "lemma triangle_lemma [simp]:\n  \"rec_eval rec_triangle [x] = triangle x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_triangle [x] = triangle x", "by (simp add: rec_triangle_def triangle_def)"], ["", "lemma max_triangle_lemma [simp]:\n  \"rec_eval rec_max_triangle [x] = Max_triangle x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_max_triangle [x] = Max_triangle x", "by (simp add: Max_triangle_greatest rec_max_triangle_def Let_def BMax_rec_eq1)"], ["", "text \\<open>Encodings for Products\\<close>"], ["", "definition\n  \"rec_penc = CN rec_add [CN rec_triangle [CN rec_add [Id 2 0, Id 2 1]], Id 2 0]\""], ["", "definition\n  \"rec_pdec1 = CN rec_minus [Id 1 0, CN rec_triangle [CN rec_max_triangle [Id 1 0]]]\""], ["", "definition\n  \"rec_pdec2 = CN rec_minus [CN rec_max_triangle [Id 1 0], CN rec_pdec1 [Id 1 0]]\""], ["", "lemma pdec1_lemma [simp]:\n  \"rec_eval rec_pdec1 [z] = pdec1 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_pdec1 [z] = pdec1 z", "by (simp add: rec_pdec1_def fst_prod_decode)"], ["", "lemma pdec2_lemma [simp]:\n  \"rec_eval rec_pdec2 [z] = pdec2 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_pdec2 [z] = pdec2 z", "by (simp add: rec_pdec2_def snd_prod_decode)"], ["", "lemma penc_lemma [simp]:\n  \"rec_eval rec_penc [m, n] = penc m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_penc [m, n] = penc m n", "by (simp add: rec_penc_def prod_encode_def)"], ["", "text \\<open>Encodings of Lists\\<close>"], ["", "fun\n  lenc :: \"nat list \\<Rightarrow> nat\"\n  where\n    \"lenc [] = 0\"\n  | \"lenc (x # xs) = penc (Suc x) (lenc xs)\""], ["", "fun\n  ldec :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where\n    \"ldec z 0 = (pdec1 z) - 1\"\n  | \"ldec z (Suc n) = ldec (pdec2 z) n\""], ["", "lemma pdec_zero_simps [simp]:\n  \"pdec1 0 = 0\"\n  \"pdec2 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 0 = 0 &&& pdec2 0 = 0", "by (simp_all add: prod_decode_def prod_decode_aux.simps)"], ["", "lemma ldec_zero:\n  \"ldec 0 n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldec 0 n = 0", "by (induct n) (simp_all add: prod_decode_def prod_decode_aux.simps)"], ["", "lemma list_encode_inverse:\n  \"ldec (lenc xs) n = (if n < length xs then xs ! n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldec (lenc xs) n = (if n < length xs then xs ! n else 0)", "by (induct xs arbitrary: n rule: lenc.induct)\n    (auto simp add: ldec_zero nth_Cons split: nat.splits)"], ["", "lemma lenc_length_le:\n  \"length xs \\<le> lenc xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> lenc xs", "by (induct xs) (simp_all add: prod_encode_def)"], ["", "text \\<open>Membership for the List Encoding\\<close>"], ["", "fun inside :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"inside z 0 = (0 < z)\"\n| \"inside z (Suc n) = inside (pdec2 z) n\""], ["", "definition enclen :: \"nat \\<Rightarrow> nat\" where\n  \"enclen z = BMax_rec (\\<lambda>x. inside z (x - 1)) z\""], ["", "lemma inside_False [simp]:\n  \"inside 0 n = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inside 0 n = False", "by (induct n) (simp_all)"], ["", "lemma inside_length [simp]:\n  \"inside (lenc xs) s = (s < length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inside (lenc xs) s = (s < length xs)", "proof(induct s arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. inside (lenc xs) 0 = (0 < length xs)\n 2. \\<And>s xs.\n       (\\<And>xs. inside (lenc xs) s = (s < length xs)) \\<Longrightarrow>\n       inside (lenc xs) (Suc s) = (Suc s < length xs)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs. inside (lenc xs) 0 = (0 < length xs)\n 2. \\<And>s xs.\n       (\\<And>xs. inside (lenc xs) s = (s < length xs)) \\<Longrightarrow>\n       inside (lenc xs) (Suc s) = (Suc s < length xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inside (lenc xs) 0 = (0 < length xs)", "by (cases xs) (simp_all add: prod_encode_def)"], ["proof (state)\nthis:\n  inside (lenc xs) 0 = (0 < length xs)\n\ngoal (1 subgoal):\n 1. \\<And>s xs.\n       (\\<And>xs. inside (lenc xs) s = (s < length xs)) \\<Longrightarrow>\n       inside (lenc xs) (Suc s) = (Suc s < length xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s xs.\n       (\\<And>xs. inside (lenc xs) s = (s < length xs)) \\<Longrightarrow>\n       inside (lenc xs) (Suc s) = (Suc s < length xs)", "case (Suc s)"], ["proof (state)\nthis:\n  inside (lenc ?xs) s = (s < length ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>s xs.\n       (\\<And>xs. inside (lenc xs) s = (s < length xs)) \\<Longrightarrow>\n       inside (lenc xs) (Suc s) = (Suc s < length xs)", "then"], ["proof (chain)\npicking this:\n  inside (lenc ?xs) s = (s < length ?xs)", "show ?case"], ["proof (prove)\nusing this:\n  inside (lenc ?xs) s = (s < length ?xs)\n\ngoal (1 subgoal):\n 1. inside (lenc xs) (Suc s) = (Suc s < length xs)", "by (cases xs;auto)"], ["proof (state)\nthis:\n  inside (lenc xs) (Suc s) = (Suc s < length xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Length of Encoded Lists\\<close>"], ["", "lemma enclen_length [simp]:\n  \"enclen (lenc xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enclen (lenc xs) = length xs", "unfolding enclen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. BMax_rec (\\<lambda>x. inside (lenc xs) (x - 1)) (lenc xs) = length xs", "apply(simp add: BMax_rec_eq1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST z. z - 1 < length xs \\<and> z \\<le> lenc xs \\<or> z = 0) =\n    length xs", "apply(rule Greatest_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs - 1 < length xs \\<and> length xs \\<le> lenc xs \\<or>\n    length xs = 0\n 2. \\<And>y.\n       y - 1 < length xs \\<and> y \\<le> lenc xs \\<or>\n       y = 0 \\<Longrightarrow>\n       y \\<le> length xs", "apply(auto simp add: lenc_length_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma enclen_penc [simp]:\n  \"enclen (penc (Suc x) (lenc xs)) = Suc (enclen (lenc xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enclen (penc (Suc x) (lenc xs)) = Suc (enclen (lenc xs))", "by (simp only: lenc.simps[symmetric] enclen_length) (simp)"], ["", "lemma enclen_zero [simp]:\n  \"enclen 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enclen 0 = 0", "by (simp add: enclen_def)"], ["", "text \\<open>Recursive Definitions for List Encodings\\<close>"], ["", "fun\n  rec_lenc :: \"recf list \\<Rightarrow> recf\"\n  where\n    \"rec_lenc [] = Z\"\n  | \"rec_lenc (f # fs) = CN rec_penc [CN S [f], rec_lenc fs]\""], ["", "definition\n  \"rec_ldec = CN rec_predecessor [CN rec_pdec1 [rec_swap (rec_iter rec_pdec2)]]\""], ["", "definition\n  \"rec_inside = CN rec_less [Z, rec_swap (rec_iter rec_pdec2)]\""], ["", "definition\n  \"rec_enclen = CN (rec_max1 (CN rec_not [CN rec_inside [Id 2 1, CN rec_predecessor [Id 2 0]]])) [Id 1 0, Id 1 0]\""], ["", "lemma ldec_iter:\n  \"ldec z n = pdec1 (Iter pdec2 n z) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldec z n = pdec1 (Iter pdec2 n z) - 1", "by (induct n arbitrary: z) (simp | subst Iter_comm)+"], ["", "lemma inside_iter:\n  \"inside z n = (0 < Iter pdec2 n z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inside z n = (0 < Iter pdec2 n z)", "by (induct n arbitrary: z) (simp | subst Iter_comm)+"], ["", "lemma lenc_lemma [simp]:\n  \"rec_eval (rec_lenc fs) xs = lenc (map (\\<lambda>f. rec_eval f xs) fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval (rec_lenc fs) xs = lenc (map (\\<lambda>f. rec_eval f xs) fs)", "by (induct fs) (simp_all)"], ["", "lemma ldec_lemma [simp]:\n  \"rec_eval rec_ldec [z, n] = ldec z n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_ldec [z, n] = ldec z n", "by (simp add: ldec_iter rec_ldec_def)"], ["", "lemma inside_lemma [simp]:\n  \"rec_eval rec_inside [z, n] = (if inside z n then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_inside [z, n] = (if inside z n then 1 else 0)", "by (simp add: inside_iter rec_inside_def)"], ["", "lemma enclen_lemma [simp]:\n  \"rec_eval rec_enclen [z] = enclen z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_eval rec_enclen [z] = enclen z", "by (simp add: rec_enclen_def enclen_def)"], ["", "end"]]}