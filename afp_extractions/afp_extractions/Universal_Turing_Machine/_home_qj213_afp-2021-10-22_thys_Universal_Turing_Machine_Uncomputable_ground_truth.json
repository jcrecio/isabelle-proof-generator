{"file_name": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine/Uncomputable.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Universal_Turing_Machine", "problem_names": ["lemma numeral:\n  shows \"2 = Suc 1\"\n    and \"3 = Suc 2\"\n    and \"4 = Suc 3\" \n    and \"5 = Suc 4\" \n    and \"6 = Suc 5\" \n    and \"7 = Suc 6\"\n    and \"8 = Suc 7\" \n    and \"9 = Suc 8\" \n    and \"10 = Suc 9\"\n    and \"11 = Suc 10\"\n    and \"12 = Suc 11\"", "lemma gr1_conv_Suc:\"Suc 0 < mr \\<longleftrightarrow> (\\<exists> nat. mr = Suc (Suc nat))\"", "lemma split_head_repeat[simp]:\n  \"Oc # list1 = Bk \\<up> j @ list2 \\<longleftrightarrow> j = 0 \\<and> Oc # list1 = list2\"\n  \"Bk # list1 = Oc \\<up> j @ list2 \\<longleftrightarrow> j = 0 \\<and> Bk # list1 = list2\"\n  \"Bk \\<up> j @ list2 = Oc # list1 \\<longleftrightarrow> j = 0 \\<and> Oc # list1 = list2\"\n  \"Oc \\<up> j @ list2 = Bk # list1 \\<longleftrightarrow> j = 0 \\<and> Bk # list1 = list2\"", "lemma inv_begin_step_E: \"\\<lbrakk>0 < i; 0 < j\\<rbrakk> \\<Longrightarrow> \n  \\<exists>ia>0. ia + j - Suc 0 = i + j \\<and> Oc # Oc \\<up> i = Oc \\<up> ia\"", "lemma inv_begin_step: \n  assumes \"inv_begin n cf\"\n    and \"n > 0\"\n  shows \"inv_begin n (step0 cf tcopy_begin)\"", "lemma inv_begin_steps: \n  assumes \"inv_begin n cf\"\n    and \"n > 0\"\n  shows \"inv_begin n (steps0 cf tcopy_begin stp)\"", "lemma begin_partial_correctness:\n  assumes \"is_final (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\"\n  shows \"0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}\"", "lemma wf_measure_begin:\n  shows \"wf measure_begin\"", "lemma measure_begin_induct [case_names Step]: \n  \"\\<lbrakk>\\<And>n. \\<not> P (f n) \\<Longrightarrow> (f (Suc n), (f n)) \\<in> measure_begin\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\"", "lemma begin_halts: \n  assumes h: \"x > 0\"\n  shows \"\\<exists> stp. is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\"", "lemma begin_correct: \n  shows \"0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}\"", "lemma Bk_no_Oc_repeatE[elim]: \"Bk # list = Oc \\<up> t \\<Longrightarrow> RR\"", "lemma inv_loop3_Bk_empty_via_2[elim]: \"\\<lbrakk>0 < x; inv_loop2 x (b, [])\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, [])\"", "lemma inv_loop3_Bk_empty[elim]: \"\\<lbrakk>0 < x; inv_loop3 x (b, [])\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, [])\"", "lemma inv_loop5_Oc_empty_via_4[elim]: \"\\<lbrakk>0 < x; inv_loop4 x (b, [])\\<rbrakk> \\<Longrightarrow> inv_loop5 x (b, [Oc])\"", "lemma inv_loop1_Bk[elim]: \"\\<lbrakk>0 < x; inv_loop1 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list = Oc # Bk \\<up> x @ Oc \\<up> x\"", "lemma inv_loop3_Bk_via_2[elim]: \"\\<lbrakk>0 < x; inv_loop2 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, list)\"", "lemma inv_loop3_Bk_move[elim]: \"\\<lbrakk>0 < x; inv_loop3 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, list)\"", "lemma inv_loop5_Oc_via_4_Bk[elim]: \"\\<lbrakk>0 < x; inv_loop4 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop5 x (b, Oc # list)\"", "lemma inv_loop6_Bk_via_5[elim]: \"\\<lbrakk>0 < x; inv_loop5 x ([], Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop6 x ([], Bk # Bk # list)\"", "lemma inv_loop5_loop_no_Bk[simp]: \"inv_loop5_loop x (b, Bk # list) = False\"", "lemma inv_loop6_exit_no_Bk[simp]: \"inv_loop6_exit x (b, Bk # list) = False\"", "lemma inv_loop6_loopBk_via_5[elim]:\"\\<lbrakk>0 < x; inv_loop5_exit x (b, Bk # list); b \\<noteq> []; hd b = Bk\\<rbrakk> \n          \\<Longrightarrow> inv_loop6_loop x (tl b, Bk # Bk # list)\"", "lemma inv_loop6_loop_no_Oc_Bk[simp]: \"inv_loop6_loop x (b, Oc # Bk # list) = False\"", "lemma inv_loop6_exit_Oc_Bk_via_5[elim]: \"\\<lbrakk>x > 0; inv_loop5_exit x (b, Bk # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \\<Longrightarrow> \n  inv_loop6_exit x (tl b, Oc # Bk # list)\"", "lemma inv_loop6_Bk_tail_via_5[elim]: \"\\<lbrakk>0 < x; inv_loop5 x (b, Bk # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> inv_loop6 x (tl b, hd b # Bk # list)\"", "lemma inv_loop6_loop_Bk_Bk_drop[elim]: \"\\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> []; hd b = Bk\\<rbrakk>\n              \\<Longrightarrow> inv_loop6_loop x (tl b, Bk # Bk # list)\"", "lemma inv_loop6_exit_Oc_Bk_via_loop6[elim]: \"\\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \n        \\<Longrightarrow> inv_loop6_exit x (tl b, Oc # Bk # list)\"", "lemma inv_loop6_Bk_tail[elim]: \"\\<lbrakk>0 < x; inv_loop6 x (b, Bk # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> inv_loop6 x (tl b, hd b # Bk # list)\"", "lemma inv_loop2_Oc_via_1[elim]: \"\\<lbrakk>0 < x; inv_loop1 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop2 x (Oc # b, list)\"", "lemma inv_loop2_Bk_via_Oc[elim]: \"\\<lbrakk>0 < x; inv_loop2 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop2 x (b, Bk # list)\"", "lemma inv_loop4_Oc_via_3[elim]: \"\\<lbrakk>0 < x; inv_loop3 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop4 x (Oc # b, list)\"", "lemma inv_loop4_Oc_move[elim]:\n  assumes \"0 < x\" \"inv_loop4 x (b, Oc # list)\"\n  shows \"inv_loop4 x (Oc # b, list)\"", "lemma inv_loop5_exit_no_Oc[simp]: \"inv_loop5_exit x (b, Oc # list) = False\"", "lemma inv_loop5_exit_Bk_Oc_via_loop[elim]: \" \\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> []; hd b = Bk\\<rbrakk>\n  \\<Longrightarrow> inv_loop5_exit x (tl b, Bk # Oc # list)\"", "lemma inv_loop5_loop_Oc_Oc_drop[elim]: \"\\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \n           \\<Longrightarrow> inv_loop5_loop x (tl b, Oc # Oc # list)\"", "lemma inv_loop5_Oc_tl[elim]: \"\\<lbrakk>inv_loop5 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> inv_loop5 x (tl b, hd b # Oc # list)\"", "lemma inv_loop1_Bk_Oc_via_6[elim]: \"\\<lbrakk>0 < x; inv_loop6 x ([], Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop1 x ([], Bk # Oc # list)\"", "lemma inv_loop1_Oc_via_6[elim]: \"\\<lbrakk>0 < x; inv_loop6 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \n           \\<Longrightarrow> inv_loop1 x (tl b, hd b # Oc # list)\"", "lemma inv_loop_nonempty[simp]:\n  \"inv_loop1 x (b, []) = False\"\n  \"inv_loop2 x ([], b) = False\"\n  \"inv_loop2 x (l', []) = False\"\n  \"inv_loop3 x (b, []) = False\"\n  \"inv_loop4 x ([], b) = False\"\n  \"inv_loop5 x ([], list) = False\"\n  \"inv_loop6 x ([], Bk # xs) = False\"", "lemma inv_loop_nonemptyE[elim]:\n  \"\\<lbrakk>inv_loop5 x (b, [])\\<rbrakk> \\<Longrightarrow> RR\" \"inv_loop6 x (b, []) \\<Longrightarrow> RR\" \n  \"\\<lbrakk>inv_loop1 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> b = []\"", "lemma inv_loop6_Bk_Bk_drop[elim]: \"\\<lbrakk>inv_loop6 x ([], Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop6 x ([], Bk # Bk # list)\"", "lemma inv_loop_step: \n  \"\\<lbrakk>inv_loop x cf; x > 0\\<rbrakk> \\<Longrightarrow> inv_loop x (step cf (tcopy_loop, 0))\"", "lemma inv_loop_steps:\n  \"\\<lbrakk>inv_loop x cf; x > 0\\<rbrakk> \\<Longrightarrow> inv_loop x (steps cf (tcopy_loop, 0) stp)\"", "lemma wf_measure_loop: \"wf measure_loop\"", "lemma measure_loop_induct [case_names Step]: \n  \"\\<lbrakk>\\<And>n. \\<not> P (f n) \\<Longrightarrow> (f (Suc n), (f n)) \\<in> measure_loop\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\"", "lemma inv_loop4_not_just_Oc[elim]: \n  \"\\<lbrakk>inv_loop4 x (l', []);\n  length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ [Oc])) \\<noteq> \n  length (takeWhile (\\<lambda>a. a = Oc) (rev l'))\\<rbrakk>\n  \\<Longrightarrow> RR\"\n  \"\\<lbrakk>inv_loop4 x (l', Bk # list);\n   length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Oc # list)) \\<noteq> \n    length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\\<rbrakk>\n    \\<Longrightarrow> RR\"", "lemma takeWhile_replicate_append: \n  \"P a \\<Longrightarrow> takeWhile P (a\\<up>x @ ys) = a\\<up>x @ takeWhile P ys\"", "lemma takeWhile_replicate: \n  \"P a \\<Longrightarrow> takeWhile P (a\\<up>x) = a\\<up>x\"", "lemma inv_loop5_Bk_E[elim]: \n  \"\\<lbrakk>inv_loop5 x (l', Bk # list); l' \\<noteq> []; \n   length (takeWhile (\\<lambda>a. a = Oc) (rev (tl l') @ hd l' # Bk # list)) \\<noteq>\n   length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\\<rbrakk>\n   \\<Longrightarrow> RR\"", "lemma inv_loop1_hd_Oc[elim]: \"\\<lbrakk>inv_loop1 x (l', Oc # list)\\<rbrakk> \\<Longrightarrow> hd list = Oc\"", "lemma inv_loop6_not_just_Bk[dest!]: \n  \"\\<lbrakk>length (takeWhile P (rev (tl l') @ hd l' # list)) \\<noteq> \n  length (takeWhile P (rev l' @ list))\\<rbrakk>\n  \\<Longrightarrow> l' = []\"", "lemma inv_loop2_OcE[elim]:\n  \"\\<lbrakk>inv_loop2 x (l', Oc # list); l' \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list)) <\n  length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Oc # list))\"", "lemma loop_halts: \n  assumes h: \"n > 0\" \"inv_loop n (1, l, r)\"\n  shows \"\\<exists> stp. is_final (steps0 (1, l, r) tcopy_loop stp)\"", "lemma loop_correct:\n  assumes \"0 < n\"\n  shows \"{inv_loop1 n} tcopy_loop {inv_loop0 n}\"", "lemma inv_end_nonempty[simp]:\n  \"inv_end1 x (b, []) = False\"\n  \"inv_end1 x ([], list) = False\"\n  \"inv_end2 x (b, []) = False\"\n  \"inv_end3 x (b, []) = False\"\n  \"inv_end4 x (b, []) = False\"\n  \"inv_end5 x (b, []) = False\"\n  \"inv_end5 x ([], Oc # list) = False\"", "lemma inv_end0_Bk_via_1[elim]: \"\\<lbrakk>0 < x; inv_end1 x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> inv_end0 x (tl b, hd b # Bk # list)\"", "lemma inv_end3_Oc_via_2[elim]: \"\\<lbrakk>0 < x; inv_end2 x (b, Bk # list)\\<rbrakk> \n  \\<Longrightarrow> inv_end3 x (b, Oc # list)\"", "lemma inv_end2_Bk_via_3[elim]: \"\\<lbrakk>0 < x; inv_end3 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_end2 x (Bk # b, list)\"", "lemma inv_end5_Bk_via_4[elim]: \"\\<lbrakk>0 < x; inv_end4 x ([], Bk # list)\\<rbrakk> \\<Longrightarrow> \n  inv_end5 x ([], Bk # Bk # list)\"", "lemma inv_end5_Bk_tail_via_4[elim]: \"\\<lbrakk>0 < x; inv_end4 x (b, Bk # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  inv_end5 x (tl b, hd b # Bk # list)\"", "lemma inv_end0_Bk_via_5[elim]: \"\\<lbrakk>0 < x; inv_end5 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_end0 x (Bk # b, list)\"", "lemma inv_end2_Oc_via_1[elim]: \"\\<lbrakk>0 < x; inv_end1 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end2 x (Oc # b, list)\"", "lemma inv_end4_Bk_Oc_via_2[elim]: \"\\<lbrakk>0 < x; inv_end2 x ([], Oc # list)\\<rbrakk> \\<Longrightarrow>\n               inv_end4 x ([], Bk # Oc # list)\"", "lemma inv_end4_Oc_via_2[elim]:  \"\\<lbrakk>0 < x; inv_end2 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n  inv_end4 x (tl b, hd b # Oc # list)\"", "lemma inv_end2_Oc_via_3[elim]: \"\\<lbrakk>0 < x; inv_end3 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end2 x (Oc # b, list)\"", "lemma inv_end4_Bk_via_Oc[elim]: \"\\<lbrakk>0 < x; inv_end4 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end4 x (b, Bk # list)\"", "lemma inv_end5_Bk_drop_Oc[elim]: \"\\<lbrakk>0 < x; inv_end5 x ([], Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end5 x ([], Bk # Oc # list)\"", "lemma inv_end5_exit_no_Oc[simp]: \"inv_end5_exit x (b, Oc # list) = False\"", "lemma inv_end5_loop_no_Bk_Oc[simp]: \"inv_end5_loop x (tl b, Bk # Oc # list) = False\"", "lemma inv_end5_exit_Bk_Oc_via_loop[elim]:\n  \"\\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> []; hd b = Bk\\<rbrakk> \\<Longrightarrow>\n  inv_end5_exit x (tl b, Bk # Oc # list)\"", "lemma inv_end5_loop_Oc_Oc_drop[elim]: \n  \"\\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \\<Longrightarrow>\n  inv_end5_loop x (tl b, Oc # Oc # list)\"", "lemma inv_end5_Oc_tail[elim]: \"\\<lbrakk>0 < x; inv_end5 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  inv_end5 x (tl b, hd b # Oc # list)\"", "lemma inv_end_step:\n  \"\\<lbrakk>x > 0; inv_end x cf\\<rbrakk> \\<Longrightarrow> inv_end x (step cf (tcopy_end, 0))\"", "lemma inv_end_steps:\n  \"\\<lbrakk>x > 0; inv_end x cf\\<rbrakk> \\<Longrightarrow> inv_end x (steps cf (tcopy_end, 0) stp)\"", "lemma wf_end_le: \"wf end_LE\"", "lemma halt_lemma: \n  \"\\<lbrakk>wf LE; \\<forall>n. (\\<not> P (f n) \\<longrightarrow> (f (Suc n), (f n)) \\<in> LE)\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\"", "lemma end_halt: \n  \"\\<lbrakk>x > 0; inv_end x (Suc 0, l, r)\\<rbrakk> \\<Longrightarrow> \n      \\<exists> stp. is_final (steps (Suc 0, l, r) (tcopy_end, 0) stp)\"", "lemma end_correct:\n  \"n > 0 \\<Longrightarrow> {inv_end1 n} tcopy_end {inv_end0 n}\"", "lemma tm_wf_tcopy[intro]:\n  \"tm_wf (tcopy_begin, 0)\"\n  \"tm_wf (tcopy_loop, 0)\"\n  \"tm_wf (tcopy_end, 0)\"", "lemma tcopy_correct1: \n  assumes \"0 < x\"\n  shows \"{inv_begin1 x} tcopy {inv_end0 x}\"", "lemma tcopy_correct:\n  shows \"{pre_tcopy n} tcopy {post_tcopy n}\"", "lemma dither_loops_aux: \n  \"(steps0 (1, Bk \\<up> m, [Oc]) dither stp = (1, Bk \\<up> m, [Oc])) \\<or> \n   (steps0 (1, Bk \\<up> m, [Oc]) dither stp = (2, Oc # Bk \\<up> m, []))\"", "lemma dither_loops:\n  shows \"{dither_unhalt_inv} dither \\<up>\"", "lemma dither_halts_aux: \n  shows \"steps0 (1, Bk \\<up> m, [Oc, Oc]) dither 2 = (0, Bk \\<up> m, [Oc, Oc])\"", "lemma dither_halts:\n  shows \"{dither_halt_inv} dither {dither_halt_inv}\"", "lemma tm_wf0_tcopy[intro, simp]: \"tm_wf0 tcopy\"", "lemma tm_wf0_dither[intro, simp]: \"tm_wf0 dither\"", "lemma H_halt_inv:\n  assumes \"\\<not> halts M ns\" \n  shows \"{pre_H_inv M ns} H {post_H_halt_inv}\"", "lemma H_unhalt_inv:\n  assumes \"halts M ns\" \n  shows \"{pre_H_inv M ns} H {post_H_unhalt_inv}\"", "lemma tcontra_unhalt: \n  assumes \"\\<not> halts tcontra [code tcontra]\"\n  shows \"False\"", "lemma tcontra_halt: \n  assumes \"halts tcontra [code tcontra]\"\n  shows \"False\"", "lemma false: \"False\""], "translations": [["", "lemma numeral:\n  shows \"2 = Suc 1\"\n    and \"3 = Suc 2\"\n    and \"4 = Suc 3\" \n    and \"5 = Suc 4\" \n    and \"6 = Suc 5\" \n    and \"7 = Suc 6\"\n    and \"8 = Suc 7\" \n    and \"9 = Suc 8\" \n    and \"10 = Suc 9\"\n    and \"11 = Suc 10\"\n    and \"12 = Suc 11\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2 = Suc 1 &&& 3 = Suc 2) &&&\n     4 = Suc 3 &&& 5 = Suc 4 &&& 6 = Suc 5) &&&\n    (7 = Suc 6 &&& 8 = Suc 7 &&& 9 = Suc 8) &&&\n    10 = Suc 9 &&& 11 = Suc 10 &&& 12 = Suc 11", "by simp_all"], ["", "lemma gr1_conv_Suc:\"Suc 0 < mr \\<longleftrightarrow> (\\<exists> nat. mr = Suc (Suc nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc 0 < mr) = (\\<exists>nat. mr = Suc (Suc nat))", "by presburger"], ["", "text \\<open>The Copying TM, which duplicates its input.\\<close>"], ["", "definition \n  tcopy_begin :: \"instr list\"\n  where\n    \"tcopy_begin \\<equiv> [(W0, 0), (R, 2), (R, 3), (R, 2),\n                 (W1, 3), (L, 4), (L, 4), (L, 0)]\""], ["", "definition \n  tcopy_loop :: \"instr list\"\n  where\n    \"tcopy_loop \\<equiv> [(R, 0), (R, 2),  (R, 3), (W0, 2),\n                 (R, 3), (R, 4), (W1, 5), (R, 4),\n                 (L, 6), (L, 5), (L, 6), (L, 1)]\""], ["", "definition \n  tcopy_end :: \"instr list\"\n  where\n    \"tcopy_end \\<equiv> [(L, 0), (R, 2), (W1, 3), (L, 4),\n                (R, 2), (R, 2), (L, 5), (W0, 4),\n                (R, 0), (L, 5)]\""], ["", "definition \n  tcopy :: \"instr list\"\n  where\n    \"tcopy \\<equiv> (tcopy_begin |+| tcopy_loop) |+| tcopy_end\""], ["", "(* tcopy_begin *)"], ["", "fun \n  inv_begin0 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_begin1 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_begin2 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_begin3 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_begin4 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"inv_begin0 n (l, r) = ((n > 1 \\<and> (l, r) = (Oc \\<up> (n - 2), [Oc, Oc, Bk, Oc])) \\<or>   \n                          (n = 1 \\<and> (l, r) = ([], [Bk, Oc, Bk, Oc])))\"\n  | \"inv_begin1 n (l, r) = ((l, r) = ([], Oc \\<up> n))\"\n  | \"inv_begin2 n (l, r) = (\\<exists> i j. i > 0 \\<and> i + j = n \\<and> (l, r) = (Oc \\<up> i, Oc \\<up> j))\"\n  | \"inv_begin3 n (l, r) = (n > 0 \\<and> (l, tl r) = (Bk # Oc \\<up> n, []))\"\n  | \"inv_begin4 n (l, r) = (n > 0 \\<and> (l, r) = (Oc \\<up> n, [Bk, Oc]) \\<or> (l, r) = (Oc \\<up> (n - 1), [Oc, Bk, Oc]))\""], ["", "fun inv_begin :: \"nat \\<Rightarrow> config \\<Rightarrow> bool\"\n  where\n    \"inv_begin n (s, tp) = \n        (if s = 0 then inv_begin0 n tp else\n         if s = 1 then inv_begin1 n tp else\n         if s = 2 then inv_begin2 n tp else\n         if s = 3 then inv_begin3 n tp else\n         if s = 4 then inv_begin4 n tp \n         else False)\""], ["", "lemma split_head_repeat[simp]:\n  \"Oc # list1 = Bk \\<up> j @ list2 \\<longleftrightarrow> j = 0 \\<and> Oc # list1 = list2\"\n  \"Bk # list1 = Oc \\<up> j @ list2 \\<longleftrightarrow> j = 0 \\<and> Bk # list1 = list2\"\n  \"Bk \\<up> j @ list2 = Oc # list1 \\<longleftrightarrow> j = 0 \\<and> Oc # list1 = list2\"\n  \"Oc \\<up> j @ list2 = Bk # list1 \\<longleftrightarrow> j = 0 \\<and> Bk # list1 = list2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Oc # list1 = Bk \\<up> j @ list2) =\n     (j = 0 \\<and> Oc # list1 = list2) &&&\n     (Bk # list1 = Oc \\<up> j @ list2) =\n     (j = 0 \\<and> Bk # list1 = list2)) &&&\n    (Bk \\<up> j @ list2 = Oc # list1) =\n    (j = 0 \\<and> Oc # list1 = list2) &&&\n    (Oc \\<up> j @ list2 = Bk # list1) = (j = 0 \\<and> Bk # list1 = list2)", "by(cases j;force)+"], ["", "lemma inv_begin_step_E: \"\\<lbrakk>0 < i; 0 < j\\<rbrakk> \\<Longrightarrow> \n  \\<exists>ia>0. ia + j - Suc 0 = i + j \\<and> Oc # Oc \\<up> i = Oc \\<up> ia\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; 0 < j\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ia>0.\n                         ia + j - Suc 0 = i + j \\<and>\n                         Oc # Oc \\<up> i = Oc \\<up> ia", "by (rule_tac x = \"Suc i\" in exI, simp)"], ["", "lemma inv_begin_step: \n  assumes \"inv_begin n cf\"\n    and \"n > 0\"\n  shows \"inv_begin n (step0 cf tcopy_begin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_begin n (step0 cf tcopy_begin)", "using assms"], ["proof (prove)\nusing this:\n  inv_begin n cf\n  0 < n\n\ngoal (1 subgoal):\n 1. inv_begin n (step0 cf tcopy_begin)", "unfolding tcopy_begin_def"], ["proof (prove)\nusing this:\n  inv_begin n cf\n  0 < n\n\ngoal (1 subgoal):\n 1. inv_begin n\n     (step0 cf\n       [(W0, 0), (R, 2), (R, 3), (R, 2), (W1, 3), (L, 4), (L, 4), (L, 0)])", "apply(cases cf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>inv_begin n cf; 0 < n; cf = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> inv_begin n\n                          (step0 cf\n                            [(W0, 0), (R, 2), (R, 3), (R, 2), (W1, 3),\n                             (L, 4), (L, 4), (L, 0)])", "apply(auto simp: numeral split: if_splits elim:inv_begin_step_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>0 < n; cf = (Suc (Suc (Suc 0)), Bk # Oc \\<up> n, c);\n        tl c = []; c \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> inv_begin n\n                          (case fetch\n                                 [(W0, 0), (R, Suc (Suc 0)),\n                                  (R, Suc (Suc (Suc 0))), (R, Suc (Suc 0)),\n                                  (W1, Suc (Suc (Suc 0))),\n                                  (L, Suc (Suc (Suc (Suc 0)))),\n                                  (L, Suc (Suc (Suc (Suc 0)))), (L, 0)]\n                                 (Suc (Suc (Suc 0))) (hd c) of\n                           (a, s') \\<Rightarrow>\n                             (s', update a (Bk # Oc \\<up> n, c)))", "apply(cases \"hd (snd (snd cf))\";cases \"(snd (snd cf))\",auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_begin_steps: \n  assumes \"inv_begin n cf\"\n    and \"n > 0\"\n  shows \"inv_begin n (steps0 cf tcopy_begin stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_begin n (steps0 cf tcopy_begin stp)", "apply(induct stp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inv_begin n (steps0 cf tcopy_begin 0)\n 2. \\<And>stp.\n       inv_begin n (steps0 cf tcopy_begin stp) \\<Longrightarrow>\n       inv_begin n (steps0 cf tcopy_begin (Suc stp))", "apply(simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       inv_begin n (steps0 cf tcopy_begin stp) \\<Longrightarrow>\n       inv_begin n (steps0 cf tcopy_begin (Suc stp))", "apply(auto simp del: steps.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       inv_begin n (steps0 cf tcopy_begin stp) \\<Longrightarrow>\n       inv_begin n (step0 (steps0 cf tcopy_begin stp) tcopy_begin)", "apply(rule_tac inv_begin_step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>stp.\n       inv_begin n (steps0 cf tcopy_begin stp) \\<Longrightarrow>\n       inv_begin n (steps0 cf tcopy_begin stp)\n 2. \\<And>stp.\n       inv_begin n (steps0 cf tcopy_begin stp) \\<Longrightarrow> 0 < n", "apply(simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma begin_partial_correctness:\n  assumes \"is_final (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\"\n  shows \"0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}", "proof(rule_tac Hoare_haltI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_begin1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final\n                             (steps0 (1, l, r) tcopy_begin na) \\<and>\n                            inv_begin0\n                             n holds_for steps0 (1, l, r) tcopy_begin na", "fix l r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_begin1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final\n                             (steps0 (1, l, r) tcopy_begin na) \\<and>\n                            inv_begin0\n                             n holds_for steps0 (1, l, r) tcopy_begin na", "assume h: \"0 < n\" \"inv_begin1 n (l, r)\""], ["proof (state)\nthis:\n  0 < n\n  inv_begin1 n (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_begin1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final\n                             (steps0 (1, l, r) tcopy_begin na) \\<and>\n                            inv_begin0\n                             n holds_for steps0 (1, l, r) tcopy_begin na", "have \"inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)", "using h"], ["proof (prove)\nusing this:\n  0 < n\n  inv_begin1 n (l, r)\n\ngoal (1 subgoal):\n 1. inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)", "by (rule_tac inv_begin_steps) (simp_all)"], ["proof (state)\nthis:\n  inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_begin1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final\n                             (steps0 (1, l, r) tcopy_begin na) \\<and>\n                            inv_begin0\n                             n holds_for steps0 (1, l, r) tcopy_begin na", "then"], ["proof (chain)\npicking this:\n  inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)", "show\n    \"\\<exists>stp. is_final (steps0 (1, l, r) tcopy_begin stp) \\<and> \n    inv_begin0 n holds_for steps (1, l, r) (tcopy_begin, 0) stp\""], ["proof (prove)\nusing this:\n  inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final (steps0 (1, l, r) tcopy_begin stp) \\<and>\n       inv_begin0 n holds_for steps0 (1, l, r) tcopy_begin stp", "using h assms"], ["proof (prove)\nusing this:\n  inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\n  0 < n\n  inv_begin1 n (l, r)\n  is_final (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final (steps0 (1, l, r) tcopy_begin stp) \\<and>\n       inv_begin0 n holds_for steps0 (1, l, r) tcopy_begin stp", "apply(rule_tac x = stp in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_begin n (steps0 (1, [], Oc \\<up> n) tcopy_begin stp);\n     0 < n; inv_begin1 n (l, r);\n     is_final (steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\\<rbrakk>\n    \\<Longrightarrow> is_final (steps0 (1, l, r) tcopy_begin stp) \\<and>\n                      inv_begin0\n                       n holds_for steps0 (1, l, r) tcopy_begin stp", "apply(case_tac \"(steps0 (1, [], Oc \\<up> n) tcopy_begin stp)\", simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     is_final (steps0 (1, l, r) tcopy_begin stp) \\<and>\n     inv_begin0 n holds_for steps0 (1, l, r) tcopy_begin stp\n\ngoal:\nNo subgoals!", "qed"], ["", "fun measure_begin_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"measure_begin_state (s, l, r) = (if s = 0 then 0 else 5 - s)\""], ["", "fun measure_begin_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"measure_begin_step (s, l, r) = \n        (if s = 2 then length r else\n         if s = 3 then (if r = [] \\<or> r = [Bk] then 1 else 0) else\n         if s = 4 then length l \n         else 0)\""], ["", "definition\n  \"measure_begin = measures [measure_begin_state, measure_begin_step]\""], ["", "lemma wf_measure_begin:\n  shows \"wf measure_begin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf measure_begin", "unfolding measure_begin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures [measure_begin_state, measure_begin_step])", "by auto"], ["", "lemma measure_begin_induct [case_names Step]: \n  \"\\<lbrakk>\\<And>n. \\<not> P (f n) \\<Longrightarrow> (f (Suc n), (f n)) \\<in> measure_begin\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> P (f n) \\<Longrightarrow>\n        (f (Suc n), f n) \\<in> measure_begin) \\<Longrightarrow>\n    \\<exists>n. P (f n)", "using wf_measure_begin"], ["proof (prove)\nusing this:\n  wf measure_begin\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> P (f n) \\<Longrightarrow>\n        (f (Suc n), f n) \\<in> measure_begin) \\<Longrightarrow>\n    \\<exists>n. P (f n)", "by (metis wf_iff_no_infinite_down_chain)"], ["", "lemma begin_halts: \n  assumes h: \"x > 0\"\n  shows \"\\<exists> stp. is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin stp)", "proof (induct rule: measure_begin_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "case (Step n)"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "have \"\\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)", "by fact"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "moreover"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "have \"inv_begin x (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_begin x (steps0 (1, [], Oc \\<up> x) tcopy_begin n)", "by (rule_tac inv_begin_steps) (simp_all add:  h)"], ["proof (state)\nthis:\n  inv_begin x (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "moreover"], ["proof (state)\nthis:\n  inv_begin x (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "obtain s l r where eq: \"(steps0 (1, [], Oc \\<up> x) tcopy_begin n) = (s, l, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s l r.\n        steps0 (1, [], Oc \\<up> x) tcopy_begin n =\n        (s, l, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis measure_begin_state.cases)"], ["proof (state)\nthis:\n  steps0 (1, [], Oc \\<up> x) tcopy_begin n = (s, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n  inv_begin x (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n  steps0 (1, [], Oc \\<up> x) tcopy_begin n = (s, l, r)", "have \"(step0 (s, l, r) tcopy_begin, s, l, r) \\<in> measure_begin\""], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n  inv_begin x (steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n  steps0 (1, [], Oc \\<up> x) tcopy_begin n = (s, l, r)\n\ngoal (1 subgoal):\n 1. (step0 (s, l, r) tcopy_begin, s, l, r) \\<in> measure_begin", "apply(auto simp: measure_begin_def tcopy_begin_def numeral split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, [], Oc \\<up> x)\n              [(W0, 0), (R, Suc (Suc 0)), (R, Suc (Suc (Suc 0))),\n               (R, Suc (Suc 0)), (W1, Suc (Suc (Suc 0))),\n               (L, Suc (Suc (Suc (Suc 0)))), (L, Suc (Suc (Suc (Suc 0)))),\n               (L, 0)]\n              n =\n             (Suc (Suc (Suc 0)), Bk # Oc \\<up> x, r);\n     s = Suc (Suc (Suc 0)); 0 < x; l = Bk # Oc \\<up> x; tl r = [];\n     r \\<noteq> []; r \\<noteq> [Bk]\\<rbrakk>\n    \\<Longrightarrow> measure_begin_state\n                       (case fetch\n                              [(W0, 0), (R, Suc (Suc 0)),\n                               (R, Suc (Suc (Suc 0))), (R, Suc (Suc 0)),\n                               (W1, Suc (Suc (Suc 0))),\n                               (L, Suc (Suc (Suc (Suc 0)))),\n                               (L, Suc (Suc (Suc (Suc 0)))), (L, 0)]\n                              (Suc (Suc (Suc 0))) (hd r) of\n                        (a, s') \\<Rightarrow>\n                          (s', update a (Bk # Oc \\<up> x, r)))\n                      < Suc (Suc 0)", "apply(subgoal_tac \"r = [Oc]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>steps0 (Suc 0, [], Oc \\<up> x)\n              [(W0, 0), (R, Suc (Suc 0)), (R, Suc (Suc (Suc 0))),\n               (R, Suc (Suc 0)), (W1, Suc (Suc (Suc 0))),\n               (L, Suc (Suc (Suc (Suc 0)))), (L, Suc (Suc (Suc (Suc 0)))),\n               (L, 0)]\n              n =\n             (Suc (Suc (Suc 0)), Bk # Oc \\<up> x, r);\n     s = Suc (Suc (Suc 0)); 0 < x; l = Bk # Oc \\<up> x; tl r = [];\n     r \\<noteq> []; r \\<noteq> [Bk]; r = [Oc]\\<rbrakk>\n    \\<Longrightarrow> measure_begin_state\n                       (case fetch\n                              [(W0, 0), (R, Suc (Suc 0)),\n                               (R, Suc (Suc (Suc 0))), (R, Suc (Suc 0)),\n                               (W1, Suc (Suc (Suc 0))),\n                               (L, Suc (Suc (Suc (Suc 0)))),\n                               (L, Suc (Suc (Suc (Suc 0)))), (L, 0)]\n                              (Suc (Suc (Suc 0))) (hd r) of\n                        (a, s') \\<Rightarrow>\n                          (s', update a (Bk # Oc \\<up> x, r)))\n                      < Suc (Suc 0)\n 2. \\<lbrakk>steps0 (Suc 0, [], Oc \\<up> x)\n              [(W0, 0), (R, Suc (Suc 0)), (R, Suc (Suc (Suc 0))),\n               (R, Suc (Suc 0)), (W1, Suc (Suc (Suc 0))),\n               (L, Suc (Suc (Suc (Suc 0)))), (L, Suc (Suc (Suc (Suc 0)))),\n               (L, 0)]\n              n =\n             (Suc (Suc (Suc 0)), Bk # Oc \\<up> x, r);\n     s = Suc (Suc (Suc 0)); 0 < x; l = Bk # Oc \\<up> x; tl r = [];\n     r \\<noteq> []; r \\<noteq> [Bk]\\<rbrakk>\n    \\<Longrightarrow> r = [Oc]", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>steps0 (Suc 0, [], Oc \\<up> x)\n              [(W0, 0), (R, Suc (Suc 0)), (R, Suc (Suc (Suc 0))),\n               (R, Suc (Suc 0)), (W1, Suc (Suc (Suc 0))),\n               (L, Suc (Suc (Suc (Suc 0)))), (L, Suc (Suc (Suc (Suc 0)))),\n               (L, 0)]\n              n =\n             (Suc (Suc (Suc 0)), Bk # Oc \\<up> x, r);\n     s = Suc (Suc (Suc 0)); 0 < x; l = Bk # Oc \\<up> x; tl r = [];\n     r \\<noteq> []; r \\<noteq> [Bk]\\<rbrakk>\n    \\<Longrightarrow> r = [Oc]", "by (metis cell.exhaust list.exhaust list.sel(3))"], ["proof (state)\nthis:\n  (step0 (s, l, r) tcopy_begin, s, l, r) \\<in> measure_begin\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final\n               (steps0 (1, [], Oc \\<up> x) tcopy_begin\n                 stp) \\<Longrightarrow>\n       (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc stp),\n        steps0 (1, [], Oc \\<up> x) tcopy_begin stp)\n       \\<in> measure_begin", "then"], ["proof (chain)\npicking this:\n  (step0 (s, l, r) tcopy_begin, s, l, r) \\<in> measure_begin", "show \"(steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc n), steps0 (1, [], Oc \\<up> x) tcopy_begin n) \\<in> measure_begin\""], ["proof (prove)\nusing this:\n  (step0 (s, l, r) tcopy_begin, s, l, r) \\<in> measure_begin\n\ngoal (1 subgoal):\n 1. (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc n),\n     steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n    \\<in> measure_begin", "using eq"], ["proof (prove)\nusing this:\n  (step0 (s, l, r) tcopy_begin, s, l, r) \\<in> measure_begin\n  steps0 (1, [], Oc \\<up> x) tcopy_begin n = (s, l, r)\n\ngoal (1 subgoal):\n 1. (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc n),\n     steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n    \\<in> measure_begin", "by (simp only: step_red)"], ["proof (state)\nthis:\n  (steps0 (1, [], Oc \\<up> x) tcopy_begin (Suc n),\n   steps0 (1, [], Oc \\<up> x) tcopy_begin n)\n  \\<in> measure_begin\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma begin_correct: \n  shows \"0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}", "using begin_partial_correctness begin_halts"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_final (steps0 (1, [], Oc \\<up> ?n) tcopy_begin ?stp);\n   0 < ?n\\<rbrakk>\n  \\<Longrightarrow> {inv_begin1 ?n} tcopy_begin {inv_begin0 ?n}\n  0 < ?x \\<Longrightarrow>\n  \\<exists>stp. is_final (steps0 (1, [], Oc \\<up> ?x) tcopy_begin stp)\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> {inv_begin1 n} tcopy_begin {inv_begin0 n}", "by blast"], ["", "declare tm_comp.simps [simp del]"], ["", "declare adjust.simps[simp del]"], ["", "declare shift.simps[simp del]"], ["", "declare tm_wf.simps[simp del]"], ["", "declare step.simps[simp del]"], ["", "declare steps.simps[simp del]"], ["", "(* tcopy_loop *)"], ["", "fun \n  inv_loop1_loop :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop1_exit :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop5_loop :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop5_exit :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop6_loop :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop6_exit :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"inv_loop1_loop n (l, r) = (\\<exists> i j. i + j + 1 = n \\<and> (l, r) = (Oc\\<up>i, Oc#Oc#Bk\\<up>j @ Oc\\<up>j) \\<and> j > 0)\"\n  | \"inv_loop1_exit n (l, r) = (0 < n \\<and> (l, r) = ([], Bk#Oc#Bk\\<up>n @ Oc\\<up>n))\"\n  | \"inv_loop5_loop x (l, r) = \n     (\\<exists> i j k t. i + j = Suc x \\<and> i > 0 \\<and> j > 0 \\<and> k + t = j \\<and> t > 0 \\<and> (l, r) = (Oc\\<up>k@Bk\\<up>j@Oc\\<up>i, Oc\\<up>t))\"\n  | \"inv_loop5_exit x (l, r) = \n     (\\<exists> i j. i + j = Suc x \\<and> i > 0 \\<and> j > 0 \\<and> (l, r) = (Bk\\<up>(j - 1)@Oc\\<up>i, Bk # Oc\\<up>j))\"\n  | \"inv_loop6_loop x (l, r) = \n     (\\<exists> i j k t. i + j = Suc x \\<and> i > 0 \\<and> k + t + 1 = j \\<and> (l, r) = (Bk\\<up>k @ Oc\\<up>i, Bk\\<up>(Suc t) @ Oc\\<up>j))\"\n  | \"inv_loop6_exit x (l, r) = \n     (\\<exists> i j. i + j = x \\<and> j > 0 \\<and> (l, r) = (Oc\\<up>i, Oc#Bk\\<up>j @ Oc\\<up>j))\""], ["", "fun \n  inv_loop0 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop1 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop2 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop3 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop4 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop5 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_loop6 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\"\n  where\n    \"inv_loop0 n (l, r) =  (0 < n \\<and> (l, r) = ([Bk], Oc # Bk\\<up>n @ Oc\\<up>n))\"\n  | \"inv_loop1 n (l, r) = (inv_loop1_loop n (l, r) \\<or> inv_loop1_exit n (l, r))\"\n  | \"inv_loop2 n (l, r) = (\\<exists> i j any. i + j = n \\<and> n > 0 \\<and> i > 0 \\<and> j > 0 \\<and> (l, r) = (Oc\\<up>i, any#Bk\\<up>j@Oc\\<up>j))\"\n  | \"inv_loop3 n (l, r) = \n     (\\<exists> i j k t. i + j = n \\<and> i > 0 \\<and> j > 0 \\<and>  k + t = Suc j \\<and> (l, r) = (Bk\\<up>k@Oc\\<up>i, Bk\\<up>t@Oc\\<up>j))\"\n  | \"inv_loop4 n (l, r) = \n     (\\<exists> i j k t. i + j = n \\<and> i > 0 \\<and> j > 0 \\<and>  k + t = j \\<and> (l, r) = (Oc\\<up>k @ Bk\\<up>(Suc j)@Oc\\<up>i, Oc\\<up>t))\"\n  | \"inv_loop5 n (l, r) = (inv_loop5_loop n (l, r) \\<or> inv_loop5_exit n (l, r))\"\n  | \"inv_loop6 n (l, r) = (inv_loop6_loop n (l, r) \\<or> inv_loop6_exit n (l, r))\""], ["", "fun inv_loop :: \"nat \\<Rightarrow> config \\<Rightarrow> bool\"\n  where\n    \"inv_loop x (s, l, r) = \n         (if s = 0 then inv_loop0 x (l, r)\n          else if s = 1 then inv_loop1 x (l, r)\n          else if s = 2 then inv_loop2 x (l, r)\n          else if s = 3 then inv_loop3 x (l, r)\n          else if s = 4 then inv_loop4 x (l, r)\n          else if s = 5 then inv_loop5 x (l, r)\n          else if s = 6 then inv_loop6 x (l, r)\n          else False)\""], ["", "declare inv_loop.simps[simp del] inv_loop1.simps[simp del]\n  inv_loop2.simps[simp del] inv_loop3.simps[simp del] \n  inv_loop4.simps[simp del] inv_loop5.simps[simp del] \n  inv_loop6.simps[simp del]"], ["", "lemma Bk_no_Oc_repeatE[elim]: \"Bk # list = Oc \\<up> t \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bk # list = Oc \\<up> t \\<Longrightarrow> RR", "by (cases t, auto)"], ["", "lemma inv_loop3_Bk_empty_via_2[elim]: \"\\<lbrakk>0 < x; inv_loop2 x (b, [])\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop2 x (b, [])\\<rbrakk>\n    \\<Longrightarrow> inv_loop3 x (Bk # b, [])", "by (auto simp: inv_loop2.simps inv_loop3.simps)"], ["", "lemma inv_loop3_Bk_empty[elim]: \"\\<lbrakk>0 < x; inv_loop3 x (b, [])\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop3 x (b, [])\\<rbrakk>\n    \\<Longrightarrow> inv_loop3 x (Bk # b, [])", "by (auto simp: inv_loop3.simps)"], ["", "lemma inv_loop5_Oc_empty_via_4[elim]: \"\\<lbrakk>0 < x; inv_loop4 x (b, [])\\<rbrakk> \\<Longrightarrow> inv_loop5 x (b, [Oc])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop4 x (b, [])\\<rbrakk>\n    \\<Longrightarrow> inv_loop5 x (b, [Oc])", "by(auto simp: inv_loop4.simps inv_loop5.simps;force)"], ["", "lemma inv_loop1_Bk[elim]: \"\\<lbrakk>0 < x; inv_loop1 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> list = Oc # Bk \\<up> x @ Oc \\<up> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop1 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> list = Oc # Bk \\<up> x @ Oc \\<up> x", "by (auto simp: inv_loop1.simps)"], ["", "lemma inv_loop3_Bk_via_2[elim]: \"\\<lbrakk>0 < x; inv_loop2 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop2 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop3 x (Bk # b, list)", "by(auto simp: inv_loop2.simps inv_loop3.simps;force)"], ["", "lemma inv_loop3_Bk_move[elim]: \"\\<lbrakk>0 < x; inv_loop3 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop3 x (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop3 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop3 x (Bk # b, list)", "apply(auto simp: inv_loop3.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j k t.\n       \\<lbrakk>x = i + j; 0 < j; k + t = Suc j;\n        Bk # list = Bk \\<up> t @ Oc \\<up> j; b = Bk \\<up> k @ Oc \\<up> i;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>ka t.\n                                ka + t = Suc ja \\<and>\n                                Bk # Bk \\<up> k @ Oc \\<up> i =\n                                Bk \\<up> ka @ Oc \\<up> ia \\<and>\n                                list = Bk \\<up> t @ Oc \\<up> ja)\n 2. \\<And>i j k t.\n       \\<lbrakk>x = i + j; 0 < i; k + t = Suc j;\n        Bk # list = Bk \\<up> t @ Oc \\<up> j; b = Bk \\<up> k @ Oc \\<up> i;\n        0 < j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>ka t.\n                                ka + t = Suc ja \\<and>\n                                Bk # Bk \\<up> k @ Oc \\<up> i =\n                                Bk \\<up> ka @ Oc \\<up> ia \\<and>\n                                list = Bk \\<up> t @ Oc \\<up> ja)", "apply (rename_tac i j k t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j k t.\n       \\<lbrakk>x = i + j; 0 < j; k + t = Suc j;\n        Bk # list = Bk \\<up> t @ Oc \\<up> j; b = Bk \\<up> k @ Oc \\<up> i;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>ka t.\n                                ka + t = Suc ja \\<and>\n                                Bk # Bk \\<up> k @ Oc \\<up> i =\n                                Bk \\<up> ka @ Oc \\<up> ia \\<and>\n                                list = Bk \\<up> t @ Oc \\<up> ja)\n 2. \\<And>i j k t.\n       \\<lbrakk>x = i + j; 0 < i; k + t = Suc j;\n        Bk # list = Bk \\<up> t @ Oc \\<up> j; b = Bk \\<up> k @ Oc \\<up> i;\n        0 < j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>ka t.\n                                ka + t = Suc ja \\<and>\n                                Bk # Bk \\<up> k @ Oc \\<up> i =\n                                Bk \\<up> ka @ Oc \\<up> ia \\<and>\n                                list = Bk \\<up> t @ Oc \\<up> ja)", "apply(rule_tac [!] x = i in exI, \n      rule_tac [!] x = j in exI, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j k t.\n       \\<lbrakk>x = i + j; 0 < j; k + t = Suc j;\n        Bk # list = Bk \\<up> t @ Oc \\<up> j; b = Bk \\<up> k @ Oc \\<up> i;\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ka t.\n                            ka + t = Suc j \\<and>\n                            Bk # Bk \\<up> k = Bk \\<up> ka \\<and>\n                            list = Bk \\<up> t @ Oc \\<up> j\n 2. \\<And>i j k t.\n       \\<lbrakk>x = i + j; 0 < i; k + t = Suc j;\n        Bk # list = Bk \\<up> t @ Oc \\<up> j; b = Bk \\<up> k @ Oc \\<up> i;\n        0 < j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ka t.\n                            ka + t = Suc j \\<and>\n                            Bk # Bk \\<up> k = Bk \\<up> ka \\<and>\n                            list = Bk \\<up> t @ Oc \\<up> j", "apply(case_tac [!] t, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop5_Oc_via_4_Bk[elim]: \"\\<lbrakk>0 < x; inv_loop4 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop5 x (b, Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop4 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop5 x (b, Oc # list)", "by (auto simp: inv_loop4.simps inv_loop5.simps)"], ["", "lemma inv_loop6_Bk_via_5[elim]: \"\\<lbrakk>0 < x; inv_loop5 x ([], Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop6 x ([], Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop5 x ([], Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop6 x ([], Bk # Bk # list)", "by (auto simp: inv_loop6.simps inv_loop5.simps)"], ["", "lemma inv_loop5_loop_no_Bk[simp]: \"inv_loop5_loop x (b, Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop5_loop x (b, Bk # list) = False", "by (auto simp: inv_loop5.simps)"], ["", "lemma inv_loop6_exit_no_Bk[simp]: \"inv_loop6_exit x (b, Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop6_exit x (b, Bk # list) = False", "by (auto simp: inv_loop6.simps)"], ["", "declare inv_loop5_loop.simps[simp del]  inv_loop5_exit.simps[simp del]\n  inv_loop6_loop.simps[simp del]  inv_loop6_exit.simps[simp del]"], ["", "lemma inv_loop6_loopBk_via_5[elim]:\"\\<lbrakk>0 < x; inv_loop5_exit x (b, Bk # list); b \\<noteq> []; hd b = Bk\\<rbrakk> \n          \\<Longrightarrow> inv_loop6_loop x (tl b, Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop5_exit x (b, Bk # list); b \\<noteq> [];\n     hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> inv_loop6_loop x (tl b, Bk # Bk # list)", "apply(simp only: inv_loop5_exit.simps inv_loop6_loop.simps )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x;\n     \\<exists>i j.\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        (b, Bk # list) = (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j);\n     b \\<noteq> []; hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j k t.\n                         i + j = Suc x \\<and>\n                         0 < i \\<and>\n                         k + t + 1 = j \\<and>\n                         (tl b, Bk # Bk # list) =\n                         (Bk \\<up> k @ Oc \\<up> i,\n                          Bk \\<up> Suc t @ Oc \\<up> j)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            k + t + 1 = j \\<and>\n                            (tl b, Bk # Bk # list) =\n                            (Bk \\<up> k @ Oc \\<up> i,\n                             Bk \\<up> Suc t @ Oc \\<up> j)", "apply(rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            k + t + 1 = j \\<and>\n                            (tl b, Bk # Bk # list) =\n                            (Bk \\<up> k @ Oc \\<up> i,\n                             Bk \\<up> Suc t @ Oc \\<up> j)", "apply(rule_tac x = i in exI, \n      rule_tac x = j in exI,\n      rule_tac x = \"j - Suc (Suc 0)\" in exI, \n      rule_tac x = \"Suc 0\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) = Bk; i + j = Suc x;\n        0 < i; 0 < j; b = Bk \\<up> (j - Suc 0) @ Oc \\<up> i;\n        list = Oc \\<up> j\\<rbrakk>\n       \\<Longrightarrow> Suc (Suc (j - Suc (Suc 0))) = j\n 2. \\<And>i j.\n       \\<lbrakk>hd (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) = Bk; i + j = Suc x;\n        0 < i; 0 < j; b = Bk \\<up> (j - Suc 0) @ Oc \\<up> i;\n        list = Oc \\<up> j\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) =\n                         Bk \\<up> (j - Suc (Suc 0)) @ Oc \\<up> i", "apply(case_tac [!] j, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j nat.\n       \\<lbrakk>hd (Bk \\<up> nat @ Oc \\<up> i) = Bk; i + nat = x; 0 < i;\n        b = Bk \\<up> nat @ Oc \\<up> i; list = Oc # Oc \\<up> nat;\n        j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Suc (nat - Suc 0) = nat\n 2. \\<And>i j nat.\n       \\<lbrakk>hd (Bk \\<up> nat @ Oc \\<up> i) = Bk; i + nat = x; 0 < i;\n        b = Bk \\<up> nat @ Oc \\<up> i; list = Oc # Oc \\<up> nat;\n        j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> nat @ Oc \\<up> i) =\n                         Bk \\<up> (nat - Suc 0) @ Oc \\<up> i", "apply(case_tac [!] \"j-1\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop6_loop_no_Oc_Bk[simp]: \"inv_loop6_loop x (b, Oc # Bk # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop6_loop x (b, Oc # Bk # list) = False", "by (auto simp: inv_loop6_loop.simps)"], ["", "lemma inv_loop6_exit_Oc_Bk_via_5[elim]: \"\\<lbrakk>x > 0; inv_loop5_exit x (b, Bk # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \\<Longrightarrow> \n  inv_loop6_exit x (tl b, Oc # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop5_exit x (b, Bk # list); b \\<noteq> [];\n     hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> inv_loop6_exit x (tl b, Oc # Bk # list)", "apply(simp only: inv_loop5_exit.simps inv_loop6_exit.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x;\n     \\<exists>i j.\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        (b, Bk # list) = (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j);\n     b \\<noteq> []; hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j.\n                         i + j = x \\<and>\n                         0 < j \\<and>\n                         (tl b, Oc # Bk # list) =\n                         (Oc \\<up> i, Oc # Bk \\<up> j @ Oc \\<up> j)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = x \\<and>\n                            0 < j \\<and>\n                            (tl b, Oc # Bk # list) =\n                            (Oc \\<up> i, Oc # Bk \\<up> j @ Oc \\<up> j)", "apply(rule_tac x = \"x - 1\" in exI, rule_tac x = 1 in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        b = Bk \\<up> (j - Suc 0) @ Oc \\<up> i \\<and>\n        list = Oc \\<up> j\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) =\n                         Oc \\<up> (x - Suc 0) \\<and>\n                         Oc \\<up> j = [Oc]", "apply(rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        b = Bk \\<up> (j - Suc 0) @ Oc \\<up> i \\<and>\n        list = Oc \\<up> j\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> (j - Suc 0) @ Oc \\<up> i) =\n                         Oc \\<up> (x - Suc 0) \\<and>\n                         Oc \\<up> j = [Oc]", "apply(case_tac j;case_tac \"j-1\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop6_Bk_tail_via_5[elim]: \"\\<lbrakk>0 < x; inv_loop5 x (b, Bk # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> inv_loop6 x (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop5 x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop6 x (tl b, hd b # Bk # list)", "apply(simp add: inv_loop5.simps inv_loop6.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop5_exit x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop6_loop x (tl b, hd b # Bk # list) \\<or>\n                      inv_loop6_exit x (tl b, hd b # Bk # list)", "apply(cases \"hd b\", simp_all, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop6_loop_Bk_Bk_drop[elim]: \"\\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> []; hd b = Bk\\<rbrakk>\n              \\<Longrightarrow> inv_loop6_loop x (tl b, Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> [];\n     hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> inv_loop6_loop x (tl b, Bk # Bk # list)", "apply(simp only: inv_loop6_loop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x;\n     \\<exists>i j k t.\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        k + t + 1 = j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> k @ Oc \\<up> i, Bk \\<up> Suc t @ Oc \\<up> j);\n     b \\<noteq> []; hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j k t.\n                         i + j = Suc x \\<and>\n                         0 < i \\<and>\n                         k + t + 1 = j \\<and>\n                         (tl b, Bk # Bk # list) =\n                         (Bk \\<up> k @ Oc \\<up> i,\n                          Bk \\<up> Suc t @ Oc \\<up> j)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        k + t + 1 = j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> k @ Oc \\<up> i, Bk \\<up> Suc t @ Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            k + t + 1 = j \\<and>\n                            (tl b, Bk # Bk # list) =\n                            (Bk \\<up> k @ Oc \\<up> i,\n                             Bk \\<up> Suc t @ Oc \\<up> j)", "apply(rename_tac i j k t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        k + t + 1 = j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> k @ Oc \\<up> i, Bk \\<up> Suc t @ Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            k + t + 1 = j \\<and>\n                            (tl b, Bk # Bk # list) =\n                            (Bk \\<up> k @ Oc \\<up> i,\n                             Bk \\<up> Suc t @ Oc \\<up> j)", "apply(rule_tac x = i in exI, rule_tac x = j in exI, \n      rule_tac x = \"k - 1\" in exI, rule_tac x = \"Suc t\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i k t.\n       \\<lbrakk>hd (Bk \\<up> k @ Oc \\<up> i) = Bk; x = i + (k + t); 0 < i;\n        b = Bk \\<up> k @ Oc \\<up> i;\n        list = Bk \\<up> t @ Oc # Oc \\<up> (k + t)\\<rbrakk>\n       \\<Longrightarrow> Suc (k - Suc 0) = k\n 2. \\<And>i k t.\n       \\<lbrakk>hd (Bk \\<up> k @ Oc \\<up> i) = Bk; x = i + (k + t); 0 < i;\n        b = Bk \\<up> k @ Oc \\<up> i;\n        list = Bk \\<up> t @ Oc # Oc \\<up> (k + t)\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> k @ Oc \\<up> i) =\n                         Bk \\<up> (k - Suc 0) @ Oc \\<up> i", "apply(case_tac [!] k, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop6_exit_Oc_Bk_via_loop6[elim]: \"\\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \n        \\<Longrightarrow> inv_loop6_exit x (tl b, Oc # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> [];\n     hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> inv_loop6_exit x (tl b, Oc # Bk # list)", "apply(simp only: inv_loop6_loop.simps inv_loop6_exit.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x;\n     \\<exists>i j k t.\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        k + t + 1 = j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> k @ Oc \\<up> i, Bk \\<up> Suc t @ Oc \\<up> j);\n     b \\<noteq> []; hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j.\n                         i + j = x \\<and>\n                         0 < j \\<and>\n                         (tl b, Oc # Bk # list) =\n                         (Oc \\<up> i, Oc # Bk \\<up> j @ Oc \\<up> j)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        k + t + 1 = j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> k @ Oc \\<up> i, Bk \\<up> Suc t @ Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = x \\<and>\n                            0 < j \\<and>\n                            (tl b, Oc # Bk # list) =\n                            (Oc \\<up> i, Oc # Bk \\<up> j @ Oc \\<up> j)", "apply(rename_tac i j k t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        k + t + 1 = j \\<and>\n        (b, Bk # list) =\n        (Bk \\<up> k @ Oc \\<up> i, Bk \\<up> Suc t @ Oc \\<up> j)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = x \\<and>\n                            0 < j \\<and>\n                            (tl b, Oc # Bk # list) =\n                            (Oc \\<up> i, Oc # Bk \\<up> j @ Oc \\<up> j)", "apply(rule_tac x = \"i - 1\" in exI, rule_tac x = j in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i k t.\n       \\<lbrakk>hd (Bk \\<up> k @ Oc \\<up> i) = Oc; x = i + (k + t); 0 < i;\n        b = Bk \\<up> k @ Oc \\<up> i;\n        list = Bk \\<up> t @ Oc # Oc \\<up> (k + t)\\<rbrakk>\n       \\<Longrightarrow> tl (Bk \\<up> k @ Oc \\<up> i) = Oc \\<up> (i - Suc 0)\n 2. \\<And>i k t.\n       \\<lbrakk>hd (Bk \\<up> k @ Oc \\<up> i) = Oc; x = i + (k + t); 0 < i;\n        b = Bk \\<up> k @ Oc \\<up> i;\n        list = Bk \\<up> t @ Oc # Oc \\<up> (k + t)\\<rbrakk>\n       \\<Longrightarrow> k = 0", "apply(case_tac [!] k, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop6_Bk_tail[elim]: \"\\<lbrakk>0 < x; inv_loop6 x (b, Bk # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> inv_loop6 x (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop6 x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop6 x (tl b, hd b # Bk # list)", "apply(simp add: inv_loop6.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop6_loop x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop6_loop x (tl b, hd b # Bk # list) \\<or>\n                      inv_loop6_exit x (tl b, hd b # Bk # list)", "apply(case_tac \"hd b\", simp_all, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop2_Oc_via_1[elim]: \"\\<lbrakk>0 < x; inv_loop1 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop2 x (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop1 x (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop2 x (Oc # b, list)", "apply(auto simp: inv_loop1.simps inv_loop2.simps,force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop2_Bk_via_Oc[elim]: \"\\<lbrakk>0 < x; inv_loop2 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop2 x (b, Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop2 x (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop2 x (b, Bk # list)", "by (auto simp: inv_loop2.simps)"], ["", "lemma inv_loop4_Oc_via_3[elim]: \"\\<lbrakk>0 < x; inv_loop3 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop4 x (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop3 x (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop4 x (Oc # b, list)", "apply(auto simp: inv_loop3.simps inv_loop4.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < j; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>k t.\n                                k + t = ja \\<and>\n                                Oc # Bk # Bk \\<up> j @ Oc \\<up> i =\n                                Oc \\<up> k @\n                                Bk # Bk \\<up> ja @ Oc \\<up> ia \\<and>\n                                list = Oc \\<up> t)\n 2. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < i; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>k t.\n                                k + t = ja \\<and>\n                                Oc # Bk # Bk \\<up> j @ Oc \\<up> i =\n                                Oc \\<up> k @\n                                Bk # Bk \\<up> ja @ Oc \\<up> ia \\<and>\n                                list = Oc \\<up> t)", "apply(rename_tac i j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < j; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>k t.\n                                k + t = ja \\<and>\n                                Oc # Bk # Bk \\<up> j @ Oc \\<up> i =\n                                Oc \\<up> k @\n                                Bk # Bk \\<up> ja @ Oc \\<up> ia \\<and>\n                                list = Oc \\<up> t)\n 2. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < i; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia ja.\n                            ia + ja = i + j \\<and>\n                            0 < ia \\<and>\n                            0 < ja \\<and>\n                            (\\<exists>k t.\n                                k + t = ja \\<and>\n                                Oc # Bk # Bk \\<up> j @ Oc \\<up> i =\n                                Oc \\<up> k @\n                                Bk # Bk \\<up> ja @ Oc \\<up> ia \\<and>\n                                list = Oc \\<up> t)", "apply(rule_tac [!] x = i in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < j; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k t.\n                            k + t = j \\<and>\n                            [Oc] = Oc \\<up> k \\<and> list = Oc \\<up> t\n 2. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < i; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k t.\n                            k + t = j \\<and>\n                            [Oc] = Oc \\<up> k \\<and> list = Oc \\<up> t", "apply(rule_tac [!] x = \"Suc 0\" in exI, rule_tac [!] x = \"j - 1\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < j; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < i\\<rbrakk>\n       \\<Longrightarrow> Suc 0 + (j - 1) = j \\<and>\n                         [Oc] = Oc \\<up> Suc 0 \\<and>\n                         list = Oc \\<up> (j - 1)\n 2. \\<And>i j.\n       \\<lbrakk>x = i + j; 0 < i; Oc # list = Oc \\<up> j;\n        b = Bk # Bk \\<up> j @ Oc \\<up> i; 0 < j\\<rbrakk>\n       \\<Longrightarrow> Suc 0 + (j - 1) = j \\<and>\n                         [Oc] = Oc \\<up> Suc 0 \\<and>\n                         list = Oc \\<up> (j - 1)", "apply(case_tac [!] j, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop4_Oc_move[elim]:\n  assumes \"0 < x\" \"inv_loop4 x (b, Oc # list)\"\n  shows \"inv_loop4 x (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop4 x (Oc # b, list)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_loop4 x (Oc # b, list)", "from assms[unfolded inv_loop4.simps]"], ["proof (chain)\npicking this:\n  0 < x\n  \\<exists>i j k t.\n     i + j = x \\<and>\n     0 < i \\<and>\n     0 < j \\<and>\n     k + t = j \\<and>\n     (b, Oc # list) = (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)", "obtain i j k t where\n    \"i + j = x\"\n    \"0 < i\" \"0 < j\" \"k + t = j\" \"(b, Oc # list) = (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\""], ["proof (prove)\nusing this:\n  0 < x\n  \\<exists>i j k t.\n     i + j = x \\<and>\n     0 < i \\<and>\n     0 < j \\<and>\n     k + t = j \\<and>\n     (b, Oc # list) = (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\n\ngoal (1 subgoal):\n 1. (\\<And>i j k t.\n        \\<lbrakk>i + j = x; 0 < i; 0 < j; k + t = j;\n         (b, Oc # list) =\n         (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i + j = x\n  0 < i\n  0 < j\n  k + t = j\n  (b, Oc # list) = (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\n\ngoal (1 subgoal):\n 1. inv_loop4 x (Oc # b, list)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i + j = x\n  0 < i\n  0 < j\n  k + t = j\n  (b, Oc # list) = (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\n\ngoal (1 subgoal):\n 1. inv_loop4 x (Oc # b, list)", "unfolding inv_loop4.simps"], ["proof (prove)\nusing this:\n  i + j = x\n  0 < i\n  0 < j\n  k + t = j\n  (b, Oc # list) = (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\n\ngoal (1 subgoal):\n 1. \\<exists>i j k t.\n       i + j = x \\<and>\n       0 < i \\<and>\n       0 < j \\<and>\n       k + t = j \\<and>\n       (Oc # b, list) =\n       (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)", "apply(rule_tac [!] x = \"i\" in exI,rule_tac [!] x = \"j\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i + j = x; 0 < i; 0 < j; k + t = j;\n     (b, Oc # list) =\n     (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t);\n     i + j = x; 0 < i; 0 < j; k + t = j;\n     (b, Oc # list) =\n     (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>k t.\n                         i + j = x \\<and>\n                         0 < i \\<and>\n                         0 < j \\<and>\n                         k + t = j \\<and>\n                         (Oc # b, list) =\n                         (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i,\n                          Oc \\<up> t)", "apply(rule_tac [!] x = \"Suc k\" in exI,rule_tac [!] x = \"t - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i + j = x; 0 < i; 0 < j; k + t = j;\n     (b, Oc # list) =\n     (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t);\n     i + j = x; 0 < i; 0 < j; k + t = j;\n     (b, Oc # list) =\n     (Oc \\<up> k @ Bk \\<up> Suc j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n    \\<Longrightarrow> i + j = x \\<and>\n                      0 < i \\<and>\n                      0 < j \\<and>\n                      Suc k + (t - 1) = j \\<and>\n                      (Oc # b, list) =\n                      (Oc \\<up> Suc k @ Bk \\<up> Suc j @ Oc \\<up> i,\n                       Oc \\<up> (t - 1))", "by(cases t,auto)"], ["proof (state)\nthis:\n  inv_loop4 x (Oc # b, list)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_loop5_exit_no_Oc[simp]: \"inv_loop5_exit x (b, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop5_exit x (b, Oc # list) = False", "by (auto simp: inv_loop5_exit.simps)"], ["", "lemma inv_loop5_exit_Bk_Oc_via_loop[elim]: \" \\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> []; hd b = Bk\\<rbrakk>\n  \\<Longrightarrow> inv_loop5_exit x (tl b, Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> [];\n     hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> inv_loop5_exit x (tl b, Bk # Oc # list)", "apply(simp only: inv_loop5_loop.simps inv_loop5_exit.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>i j k t.\n                i + j = Suc x \\<and>\n                0 < i \\<and>\n                0 < j \\<and>\n                k + t = j \\<and>\n                0 < t \\<and>\n                (b, Oc # list) =\n                (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t);\n     b \\<noteq> []; hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j.\n                         i + j = Suc x \\<and>\n                         0 < i \\<and>\n                         0 < j \\<and>\n                         (tl b, Bk # Oc # list) =\n                         (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            0 < j \\<and>\n                            (tl b, Bk # Oc # list) =\n                            (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)", "apply(rename_tac i j k t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            0 < j \\<and>\n                            (tl b, Bk # Oc # list) =\n                            (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)", "apply(rule_tac x = i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Bk;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            0 < j \\<and>\n                            (tl b, Bk # Oc # list) =\n                            (Bk \\<up> (j - 1) @ Oc \\<up> i, Bk # Oc \\<up> j)", "apply(case_tac k, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop5_loop_Oc_Oc_drop[elim]: \"\\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \n           \\<Longrightarrow> inv_loop5_loop x (tl b, Oc # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> [];\n     hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> inv_loop5_loop x (tl b, Oc # Oc # list)", "apply(simp only:  inv_loop5_loop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>i j k t.\n                i + j = Suc x \\<and>\n                0 < i \\<and>\n                0 < j \\<and>\n                k + t = j \\<and>\n                0 < t \\<and>\n                (b, Oc # list) =\n                (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t);\n     b \\<noteq> []; hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j k t.\n                         i + j = Suc x \\<and>\n                         0 < i \\<and>\n                         0 < j \\<and>\n                         k + t = j \\<and>\n                         0 < t \\<and>\n                         (tl b, Oc # Oc # list) =\n                         (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            0 < j \\<and>\n                            k + t = j \\<and>\n                            0 < t \\<and>\n                            (tl b, Oc # Oc # list) =\n                            (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i,\n                             Oc \\<up> t)", "apply(rename_tac i j k t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            0 < j \\<and>\n                            k + t = j \\<and>\n                            0 < t \\<and>\n                            (tl b, Oc # Oc # list) =\n                            (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i,\n                             Oc \\<up> t)", "apply(rule_tac x = i in exI, rule_tac x = j in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k t.\n                            i + j = Suc x \\<and>\n                            0 < i \\<and>\n                            0 < j \\<and>\n                            k + t = j \\<and>\n                            0 < t \\<and>\n                            (tl b, Oc # Oc # list) =\n                            (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i,\n                             Oc \\<up> t)", "apply(rule_tac x = \"k - 1\" in exI, rule_tac x = \"Suc t\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j k t.\n       \\<lbrakk>b \\<noteq> []; hd b = Oc;\n        i + j = Suc x \\<and>\n        0 < i \\<and>\n        0 < j \\<and>\n        k + t = j \\<and>\n        0 < t \\<and>\n        (b, Oc # list) =\n        (Oc \\<up> k @ Bk \\<up> j @ Oc \\<up> i, Oc \\<up> t)\\<rbrakk>\n       \\<Longrightarrow> i + j = Suc x \\<and>\n                         0 < i \\<and>\n                         0 < j \\<and>\n                         k - 1 + Suc t = j \\<and>\n                         0 < Suc t \\<and>\n                         (tl b, Oc # Oc # list) =\n                         (Oc \\<up> (k - 1) @ Bk \\<up> j @ Oc \\<up> i,\n                          Oc \\<up> Suc t)", "apply(case_tac k, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop5_Oc_tl[elim]: \"\\<lbrakk>inv_loop5 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> inv_loop5 x (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop5 x (b, Oc # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop5 x (tl b, hd b # Oc # list)", "apply(simp add: inv_loop5.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop5_loop x (b, Oc # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop5_loop x (tl b, hd b # Oc # list) \\<or>\n                      inv_loop5_exit x (tl b, hd b # Oc # list)", "apply(cases \"hd b\", simp_all, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop1_Bk_Oc_via_6[elim]: \"\\<lbrakk>0 < x; inv_loop6 x ([], Oc # list)\\<rbrakk> \\<Longrightarrow> inv_loop1 x ([], Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop6 x ([], Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_loop1 x ([], Bk # Oc # list)", "by(auto simp: inv_loop6.simps inv_loop1.simps inv_loop6_loop.simps inv_loop6_exit.simps)"], ["", "lemma inv_loop1_Oc_via_6[elim]: \"\\<lbrakk>0 < x; inv_loop6 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \n           \\<Longrightarrow> inv_loop1 x (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_loop6 x (b, Oc # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_loop1 x (tl b, hd b # Oc # list)", "by(auto simp: inv_loop6.simps inv_loop1.simps inv_loop6_loop.simps inv_loop6_exit.simps)"], ["", "lemma inv_loop_nonempty[simp]:\n  \"inv_loop1 x (b, []) = False\"\n  \"inv_loop2 x ([], b) = False\"\n  \"inv_loop2 x (l', []) = False\"\n  \"inv_loop3 x (b, []) = False\"\n  \"inv_loop4 x ([], b) = False\"\n  \"inv_loop5 x ([], list) = False\"\n  \"inv_loop6 x ([], Bk # xs) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_loop1 x (b, []) = False &&&\n     inv_loop2 x ([], b) = False &&& inv_loop2 x (l', []) = False) &&&\n    (inv_loop3 x (b, []) = False &&& inv_loop4 x ([], b) = False) &&&\n    inv_loop5 x ([], list) = False &&& inv_loop6 x ([], Bk # xs) = False", "by (auto simp: inv_loop1.simps inv_loop2.simps inv_loop3.simps inv_loop4.simps \n      inv_loop5.simps inv_loop6.simps inv_loop5_exit.simps inv_loop5_loop.simps\n      inv_loop6_loop.simps)"], ["", "lemma inv_loop_nonemptyE[elim]:\n  \"\\<lbrakk>inv_loop5 x (b, [])\\<rbrakk> \\<Longrightarrow> RR\" \"inv_loop6 x (b, []) \\<Longrightarrow> RR\" \n  \"\\<lbrakk>inv_loop1 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> b = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_loop5 x (b, []) \\<Longrightarrow> RR) &&&\n    (inv_loop6 x (b, []) \\<Longrightarrow> RR) &&&\n    (inv_loop1 x (b, Bk # list) \\<Longrightarrow> b = [])", "by (auto simp: inv_loop4.simps inv_loop5.simps inv_loop5_exit.simps inv_loop5_loop.simps\n      inv_loop6.simps inv_loop6_exit.simps inv_loop6_loop.simps inv_loop1.simps)"], ["", "lemma inv_loop6_Bk_Bk_drop[elim]: \"\\<lbrakk>inv_loop6 x ([], Bk # list)\\<rbrakk> \\<Longrightarrow> inv_loop6 x ([], Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop6 x ([], Bk # list) \\<Longrightarrow>\n    inv_loop6 x ([], Bk # Bk # list)", "by (simp)"], ["", "lemma inv_loop_step: \n  \"\\<lbrakk>inv_loop x cf; x > 0\\<rbrakk> \\<Longrightarrow> inv_loop x (step cf (tcopy_loop, 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop x cf; 0 < x\\<rbrakk>\n    \\<Longrightarrow> inv_loop x (step0 cf tcopy_loop)", "apply(cases cf, cases \"snd (snd cf)\"; cases \"hd (snd (snd cf))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>inv_loop x cf; 0 < x; cf = (a, b, c); snd (snd cf) = [];\n        hd (snd (snd cf)) = Bk\\<rbrakk>\n       \\<Longrightarrow> inv_loop x (step0 cf tcopy_loop)\n 2. \\<And>a b c.\n       \\<lbrakk>inv_loop x cf; 0 < x; cf = (a, b, c); snd (snd cf) = [];\n        hd (snd (snd cf)) = Oc\\<rbrakk>\n       \\<Longrightarrow> inv_loop x (step0 cf tcopy_loop)\n 3. \\<And>a b c aa list.\n       \\<lbrakk>inv_loop x cf; 0 < x; cf = (a, b, c);\n        snd (snd cf) = aa # list; hd (snd (snd cf)) = Bk\\<rbrakk>\n       \\<Longrightarrow> inv_loop x (step0 cf tcopy_loop)\n 4. \\<And>a b c aa list.\n       \\<lbrakk>inv_loop x cf; 0 < x; cf = (a, b, c);\n        snd (snd cf) = aa # list; hd (snd (snd cf)) = Oc\\<rbrakk>\n       \\<Longrightarrow> inv_loop x (step0 cf tcopy_loop)", "apply(auto simp: inv_loop.simps step.simps tcopy_loop_def numeral split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop_steps:\n  \"\\<lbrakk>inv_loop x cf; x > 0\\<rbrakk> \\<Longrightarrow> inv_loop x (steps cf (tcopy_loop, 0) stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop x cf; 0 < x\\<rbrakk>\n    \\<Longrightarrow> inv_loop x (steps0 cf tcopy_loop stp)", "apply(induct stp, simp add: steps.simps, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>inv_loop x (steps0 cf tcopy_loop stp); inv_loop x cf;\n        0 < x\\<rbrakk>\n       \\<Longrightarrow> inv_loop x\n                          (step0 (steps0 cf tcopy_loop stp) tcopy_loop)", "apply(erule_tac inv_loop_step, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun loop_stage :: \"config \\<Rightarrow> nat\"\n  where\n    \"loop_stage (s, l, r) = (if s = 0 then 0\n                           else (Suc (length (takeWhile (\\<lambda>a. a = Oc) (rev l @ r)))))\""], ["", "fun loop_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"loop_state (s, l, r) = (if s = 2 \\<and> hd r = Oc then 0\n                           else if s = 1 then 1\n                           else 10 - s)\""], ["", "fun loop_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"loop_step (s, l, r) = (if s = 3 then length r\n                          else if s = 4 then length r\n                          else if s = 5 then length l \n                          else if s = 6 then length l\n                          else 0)\""], ["", "definition measure_loop :: \"(config \\<times> config) set\"\n  where\n    \"measure_loop = measures [loop_stage, loop_state, loop_step]\""], ["", "lemma wf_measure_loop: \"wf measure_loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf measure_loop", "unfolding measure_loop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures [loop_stage, loop_state, loop_step])", "by (auto)"], ["", "lemma measure_loop_induct [case_names Step]: \n  \"\\<lbrakk>\\<And>n. \\<not> P (f n) \\<Longrightarrow> (f (Suc n), (f n)) \\<in> measure_loop\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> P (f n) \\<Longrightarrow>\n        (f (Suc n), f n) \\<in> measure_loop) \\<Longrightarrow>\n    \\<exists>n. P (f n)", "using wf_measure_loop"], ["proof (prove)\nusing this:\n  wf measure_loop\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<not> P (f n) \\<Longrightarrow>\n        (f (Suc n), f n) \\<in> measure_loop) \\<Longrightarrow>\n    \\<exists>n. P (f n)", "by (metis wf_iff_no_infinite_down_chain)"], ["", "lemma inv_loop4_not_just_Oc[elim]: \n  \"\\<lbrakk>inv_loop4 x (l', []);\n  length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ [Oc])) \\<noteq> \n  length (takeWhile (\\<lambda>a. a = Oc) (rev l'))\\<rbrakk>\n  \\<Longrightarrow> RR\"\n  \"\\<lbrakk>inv_loop4 x (l', Bk # list);\n   length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Oc # list)) \\<noteq> \n    length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\\<rbrakk>\n    \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>inv_loop4 x (l', []);\n      length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ [Oc])) \\<noteq>\n      length (takeWhile (\\<lambda>a. a = Oc) (rev l'))\\<rbrakk>\n     \\<Longrightarrow> RR) &&&\n    (\\<lbrakk>inv_loop4 x (l', Bk # list);\n      length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Oc # list)) \\<noteq>\n      length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\\<rbrakk>\n     \\<Longrightarrow> RR)", "apply(auto simp: inv_loop4.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length\n                 (takeWhile (\\<lambda>a. a = Oc)\n                   (Oc \\<up> i @\n                    Bk \\<up> j @ Bk # Oc \\<up> j @ [Oc])) \\<noteq>\n                length\n                 (takeWhile (\\<lambda>a. a = Oc)\n                   (Oc \\<up> i @ Bk \\<up> j @ Bk # Oc \\<up> j));\n        x = i + j; 0 < i; 0 < j;\n        l' = Oc \\<up> j @ Bk # Bk \\<up> j @ Oc \\<up> i\\<rbrakk>\n       \\<Longrightarrow> RR", "apply(rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>length\n                 (takeWhile (\\<lambda>a. a = Oc)\n                   (Oc \\<up> i @\n                    Bk \\<up> j @ Bk # Oc \\<up> j @ [Oc])) \\<noteq>\n                length\n                 (takeWhile (\\<lambda>a. a = Oc)\n                   (Oc \\<up> i @ Bk \\<up> j @ Bk # Oc \\<up> j));\n        x = i + j; 0 < i; 0 < j;\n        l' = Oc \\<up> j @ Bk # Bk \\<up> j @ Oc \\<up> i\\<rbrakk>\n       \\<Longrightarrow> RR", "apply(case_tac [!] j, simp_all add: List.takeWhile_tail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma takeWhile_replicate_append: \n  \"P a \\<Longrightarrow> takeWhile P (a\\<up>x @ ys) = a\\<up>x @ takeWhile P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a \\<Longrightarrow>\n    takeWhile P (a \\<up> x @ ys) = a \\<up> x @ takeWhile P ys", "by (induct x, auto)"], ["", "lemma takeWhile_replicate: \n  \"P a \\<Longrightarrow> takeWhile P (a\\<up>x) = a\\<up>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a \\<Longrightarrow> takeWhile P (a \\<up> x) = a \\<up> x", "by (induct x, auto)"], ["", "lemma inv_loop5_Bk_E[elim]: \n  \"\\<lbrakk>inv_loop5 x (l', Bk # list); l' \\<noteq> []; \n   length (takeWhile (\\<lambda>a. a = Oc) (rev (tl l') @ hd l' # Bk # list)) \\<noteq>\n   length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\\<rbrakk>\n   \\<Longrightarrow> RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop5 x (l', Bk # list); l' \\<noteq> [];\n     length\n      (takeWhile (\\<lambda>a. a = Oc)\n        (rev (tl l') @ hd l' # Bk # list)) \\<noteq>\n     length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\\<rbrakk>\n    \\<Longrightarrow> RR", "apply(cases \"length list\";cases \"length list - 1\"\n      ,auto simp: inv_loop5.simps inv_loop5_exit.simps\n      takeWhile_replicate_append takeWhile_replicate)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nata i.\n       \\<lbrakk>takeWhile (\\<lambda>a. a = Oc)\n                 (Bk \\<up> nata @\n                  Bk # Bk # Oc # Oc # Oc \\<up> nata) \\<noteq>\n                [];\n        0 < i; list = Oc # Oc # Oc \\<up> nata;\n        l' = Bk # Bk \\<up> nata @ Oc \\<up> i; \\<not> RR;\n        x = Suc (i + nata)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>nata i.\n       \\<lbrakk>takeWhile (\\<lambda>a. a = Oc)\n                 (Bk \\<up> nata @\n                  Bk # Bk # Oc # Oc # Oc \\<up> nata) \\<noteq>\n                [];\n        0 < i; list = Oc # Oc # Oc \\<up> nata;\n        l' = Bk # Bk \\<up> nata @ Oc \\<up> i; \\<not> RR;\n        x = Suc (i + nata)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(cases \"length list - 2\"; force simp add: List.takeWhile_tail)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop1_hd_Oc[elim]: \"\\<lbrakk>inv_loop1 x (l', Oc # list)\\<rbrakk> \\<Longrightarrow> hd list = Oc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop1 x (l', Oc # list) \\<Longrightarrow> hd list = Oc", "by (auto simp: inv_loop1.simps)"], ["", "lemma inv_loop6_not_just_Bk[dest!]: \n  \"\\<lbrakk>length (takeWhile P (rev (tl l') @ hd l' # list)) \\<noteq> \n  length (takeWhile P (rev l' @ list))\\<rbrakk>\n  \\<Longrightarrow> l' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (takeWhile P (rev (tl l') @ hd l' # list)) \\<noteq>\n    length (takeWhile P (rev l' @ list)) \\<Longrightarrow>\n    l' = []", "apply(cases l', simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_loop2_OcE[elim]:\n  \"\\<lbrakk>inv_loop2 x (l', Oc # list); l' \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list)) <\n  length (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Oc # list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inv_loop2 x (l', Oc # list); l' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> length\n                       (takeWhile (\\<lambda>a. a = Oc) (rev l' @ Bk # list))\n                      < length\n                         (takeWhile (\\<lambda>a. a = Oc)\n                           (rev l' @ Oc # list))", "apply(auto simp: inv_loop2.simps takeWhile_tail takeWhile_replicate_append\n      takeWhile_replicate)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma loop_halts: \n  assumes h: \"n > 0\" \"inv_loop n (1, l, r)\"\n  shows \"\\<exists> stp. is_final (steps0 (1, l, r) tcopy_loop stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>stp. is_final (steps0 (1, l, r) tcopy_loop stp)", "proof (induct rule: measure_loop_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "case (Step stp)"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "have \"\\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)", "by fact"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "moreover"], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "have \"inv_loop n (steps0 (1, l, r) tcopy_loop stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop n (steps0 (1, l, r) tcopy_loop stp)", "by (rule_tac inv_loop_steps) (simp_all only: h)"], ["proof (state)\nthis:\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "moreover"], ["proof (state)\nthis:\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "obtain s l' r' where eq: \"(steps0 (1, l, r) tcopy_loop stp) = (s, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s l' r'.\n        steps0 (1, l, r) tcopy_loop stp = (s, l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis measure_begin_state.cases)"], ["proof (state)\nthis:\n  steps0 (1, l, r) tcopy_loop stp = (s, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n  steps0 (1, l, r) tcopy_loop stp = (s, l', r')", "have \"(step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop\""], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n  steps0 (1, l, r) tcopy_loop stp = (s, l', r')\n\ngoal (1 subgoal):\n 1. (step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop", "using h(1)"], ["proof (prove)\nusing this:\n  \\<not> is_final (steps0 (1, l, r) tcopy_loop stp)\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n  steps0 (1, l, r) tcopy_loop stp = (s, l', r')\n  0 < n\n\ngoal (1 subgoal):\n 1. (step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop", "apply(cases r';cases \"hd r'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n     inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n     steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n; r' = [];\n     \\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n     inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n     steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n;\n     hd r' = Bk\\<rbrakk>\n    \\<Longrightarrow> (step0 (s, l', r') tcopy_loop, s, l', r')\n                      \\<in> measure_loop\n 2. \\<lbrakk>\\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n     inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n     steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n; r' = [];\n     \\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n     inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n     steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n;\n     hd r' = Oc\\<rbrakk>\n    \\<Longrightarrow> (step0 (s, l', r') tcopy_loop, s, l', r')\n                      \\<in> measure_loop\n 3. \\<And>a list.\n       \\<lbrakk>\\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n        inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n        steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n; r' = a # list;\n        \\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n        inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n        steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n;\n        hd r' = Bk\\<rbrakk>\n       \\<Longrightarrow> (step0 (s, l', r') tcopy_loop, s, l', r')\n                         \\<in> measure_loop\n 4. \\<And>a list.\n       \\<lbrakk>\\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n        inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n        steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n; r' = a # list;\n        \\<not> is_final (steps0 (1, l, r) tcopy_loop stp);\n        inv_loop n (steps0 (1, l, r) tcopy_loop stp);\n        steps0 (1, l, r) tcopy_loop stp = (s, l', r'); 0 < n;\n        hd r' = Oc\\<rbrakk>\n       \\<Longrightarrow> (step0 (s, l', r') tcopy_loop, s, l', r')\n                         \\<in> measure_loop", "apply(auto simp: inv_loop.simps step.simps tcopy_loop_def numeral measure_loop_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop\n\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<not> is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n       (steps0 (1, l, r) tcopy_loop (Suc stp),\n        steps0 (1, l, r) tcopy_loop stp)\n       \\<in> measure_loop", "then"], ["proof (chain)\npicking this:\n  (step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop", "show \"(steps0 (1, l, r) tcopy_loop (Suc stp), steps0 (1, l, r) tcopy_loop stp) \\<in> measure_loop\""], ["proof (prove)\nusing this:\n  (step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop\n\ngoal (1 subgoal):\n 1. (steps0 (1, l, r) tcopy_loop (Suc stp), steps0 (1, l, r) tcopy_loop stp)\n    \\<in> measure_loop", "using eq"], ["proof (prove)\nusing this:\n  (step0 (s, l', r') tcopy_loop, s, l', r') \\<in> measure_loop\n  steps0 (1, l, r) tcopy_loop stp = (s, l', r')\n\ngoal (1 subgoal):\n 1. (steps0 (1, l, r) tcopy_loop (Suc stp), steps0 (1, l, r) tcopy_loop stp)\n    \\<in> measure_loop", "by (simp only: step_red)"], ["proof (state)\nthis:\n  (steps0 (1, l, r) tcopy_loop (Suc stp), steps0 (1, l, r) tcopy_loop stp)\n  \\<in> measure_loop\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loop_correct:\n  assumes \"0 < n\"\n  shows \"{inv_loop1 n} tcopy_loop {inv_loop0 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {inv_loop1 n} tcopy_loop {inv_loop0 n}", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. {inv_loop1 n} tcopy_loop {inv_loop0 n}", "proof(rule_tac Hoare_haltI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_loop na) \\<and>\n                            inv_loop0\n                             n holds_for steps0 (1, l, r) tcopy_loop na", "fix l r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_loop na) \\<and>\n                            inv_loop0\n                             n holds_for steps0 (1, l, r) tcopy_loop na", "assume h: \"0 < n\" \"inv_loop1 n (l, r)\""], ["proof (state)\nthis:\n  0 < n\n  inv_loop1 n (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_loop na) \\<and>\n                            inv_loop0\n                             n holds_for steps0 (1, l, r) tcopy_loop na", "then"], ["proof (chain)\npicking this:\n  0 < n\n  inv_loop1 n (l, r)", "obtain stp where k: \"is_final (steps0 (1, l, r) tcopy_loop stp)\""], ["proof (prove)\nusing this:\n  0 < n\n  inv_loop1 n (l, r)\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using loop_halts"], ["proof (prove)\nusing this:\n  0 < n\n  inv_loop1 n (l, r)\n  \\<lbrakk>0 < ?n; inv_loop ?n (1, ?l, ?r)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>stp.\n                       is_final (steps0 (1, ?l, ?r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        is_final (steps0 (1, l, r) tcopy_loop stp) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(simp add: inv_loop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>stp.\n                is_final\n                 (steps0 (Suc 0, l, r) tcopy_loop stp) \\<Longrightarrow>\n                thesis;\n     0 < n; inv_loop1 n (l, r);\n     \\<And>n l r.\n        \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>stp.\n                             is_final\n                              (steps0 (Suc 0, l, r) tcopy_loop stp)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_final (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_loop na) \\<and>\n                            inv_loop0\n                             n holds_for steps0 (1, l, r) tcopy_loop na", "moreover"], ["proof (state)\nthis:\n  is_final (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_loop na) \\<and>\n                            inv_loop0\n                             n holds_for steps0 (1, l, r) tcopy_loop na", "have \"inv_loop n (steps0 (1, l, r) tcopy_loop stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop n (steps0 (1, l, r) tcopy_loop stp)", "using h"], ["proof (prove)\nusing this:\n  0 < n\n  inv_loop1 n (l, r)\n\ngoal (1 subgoal):\n 1. inv_loop n (steps0 (1, l, r) tcopy_loop stp)", "by (rule_tac inv_loop_steps) (simp_all add: inv_loop.simps)"], ["proof (state)\nthis:\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_loop1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_loop na) \\<and>\n                            inv_loop0\n                             n holds_for steps0 (1, l, r) tcopy_loop na", "ultimately"], ["proof (chain)\npicking this:\n  is_final (steps0 (1, l, r) tcopy_loop stp)\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)", "show\n    \"\\<exists>stp. is_final (steps0 (1, l, r) tcopy_loop stp) \\<and> \n    inv_loop0 n holds_for steps0 (1, l, r) tcopy_loop stp\""], ["proof (prove)\nusing this:\n  is_final (steps0 (1, l, r) tcopy_loop stp)\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final (steps0 (1, l, r) tcopy_loop stp) \\<and>\n       inv_loop0 n holds_for steps0 (1, l, r) tcopy_loop stp", "using h(1)"], ["proof (prove)\nusing this:\n  is_final (steps0 (1, l, r) tcopy_loop stp)\n  inv_loop n (steps0 (1, l, r) tcopy_loop stp)\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final (steps0 (1, l, r) tcopy_loop stp) \\<and>\n       inv_loop0 n holds_for steps0 (1, l, r) tcopy_loop stp", "apply(rule_tac x = stp in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_final (steps0 (1, l, r) tcopy_loop stp);\n     inv_loop n (steps0 (1, l, r) tcopy_loop stp); 0 < n\\<rbrakk>\n    \\<Longrightarrow> is_final (steps0 (1, l, r) tcopy_loop stp) \\<and>\n                      inv_loop0 n holds_for steps0 (1, l, r) tcopy_loop stp", "apply(case_tac \"(steps0 (1, l, r) tcopy_loop stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>is_final (steps0 (1, l, r) tcopy_loop stp);\n        inv_loop n (steps0 (1, l, r) tcopy_loop stp); 0 < n;\n        steps0 (1, l, r) tcopy_loop stp = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> is_final (steps0 (1, l, r) tcopy_loop stp) \\<and>\n                         inv_loop0\n                          n holds_for steps0 (1, l, r) tcopy_loop stp", "apply(simp add: inv_loop.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     is_final (steps0 (1, l, r) tcopy_loop stp) \\<and>\n     inv_loop0 n holds_for steps0 (1, l, r) tcopy_loop stp\n\ngoal:\nNo subgoals!", "qed"], ["", "(* tcopy_end *)"], ["", "fun\n  inv_end5_loop :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_end5_exit :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" \n  where  \n    \"inv_end5_loop x (l, r) = \n     (\\<exists> i j. i + j = x \\<and> x > 0 \\<and> j > 0 \\<and> l = Oc\\<up>i @ [Bk] \\<and> r = Oc\\<up>j @ Bk # Oc\\<up>x)\"\n  | \"inv_end5_exit x (l, r) = (x > 0 \\<and> l = [] \\<and> r = Bk # Oc\\<up>x @ Bk # Oc\\<up>x)\""], ["", "fun \n  inv_end0 :: \"nat \\<Rightarrow> tape \\<Rightarrow>  bool\" and\n  inv_end1 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_end2 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_end3 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and\n  inv_end4 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" and \n  inv_end5 :: \"nat \\<Rightarrow> tape \\<Rightarrow> bool\" \n  where\n    \"inv_end0 n (l, r) = (n > 0 \\<and> (l, r) = ([Bk], Oc\\<up>n @ Bk # Oc\\<up>n))\"\n  | \"inv_end1 n (l, r) = (n > 0 \\<and> (l, r) = ([Bk], Oc # Bk\\<up>n @ Oc\\<up>n))\"\n  | \"inv_end2 n (l, r) = (\\<exists> i j. i + j = Suc n \\<and> n > 0 \\<and> l = Oc\\<up>i @ [Bk] \\<and> r = Bk\\<up>j @ Oc\\<up>n)\"\n  | \"inv_end3 n (l, r) =\n     (\\<exists> i j. n > 0 \\<and> i + j = n \\<and> l = Oc\\<up>i @ [Bk] \\<and> r = Oc # Bk\\<up>j@ Oc\\<up>n)\"\n  | \"inv_end4 n (l, r) = (\\<exists> any. n > 0 \\<and> l = Oc\\<up>n @ [Bk] \\<and> r = any#Oc\\<up>n)\"\n  | \"inv_end5 n (l, r) = (inv_end5_loop n (l, r) \\<or> inv_end5_exit n (l, r))\""], ["", "fun \n  inv_end :: \"nat \\<Rightarrow> config \\<Rightarrow> bool\"\n  where\n    \"inv_end n (s, l, r) = (if s = 0 then inv_end0 n (l, r)\n                          else if s = 1 then inv_end1 n (l, r)\n                          else if s = 2 then inv_end2 n (l, r)\n                          else if s = 3 then inv_end3 n (l, r)\n                          else if s = 4 then inv_end4 n (l, r)\n                          else if s = 5 then inv_end5 n (l, r)\n                          else False)\""], ["", "declare inv_end.simps[simp del] inv_end1.simps[simp del]\n  inv_end0.simps[simp del] inv_end2.simps[simp del]\n  inv_end3.simps[simp del] inv_end4.simps[simp del]\n  inv_end5.simps[simp del]"], ["", "lemma inv_end_nonempty[simp]:\n  \"inv_end1 x (b, []) = False\"\n  \"inv_end1 x ([], list) = False\"\n  \"inv_end2 x (b, []) = False\"\n  \"inv_end3 x (b, []) = False\"\n  \"inv_end4 x (b, []) = False\"\n  \"inv_end5 x (b, []) = False\"\n  \"inv_end5 x ([], Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_end1 x (b, []) = False &&&\n     inv_end1 x ([], list) = False &&& inv_end2 x (b, []) = False) &&&\n    (inv_end3 x (b, []) = False &&& inv_end4 x (b, []) = False) &&&\n    inv_end5 x (b, []) = False &&& inv_end5 x ([], Oc # list) = False", "by (auto simp: inv_end1.simps inv_end2.simps inv_end3.simps inv_end4.simps inv_end5.simps)"], ["", "lemma inv_end0_Bk_via_1[elim]: \"\\<lbrakk>0 < x; inv_end1 x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> inv_end0 x (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end1 x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_end0 x (tl b, hd b # Bk # list)", "by (auto simp: inv_end1.simps inv_end0.simps)"], ["", "lemma inv_end3_Oc_via_2[elim]: \"\\<lbrakk>0 < x; inv_end2 x (b, Bk # list)\\<rbrakk> \n  \\<Longrightarrow> inv_end3 x (b, Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end2 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end3 x (b, Oc # list)", "apply(auto simp: inv_end2.simps inv_end3.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < x; i + j = Suc x; Bk # list = Bk \\<up> j @ Oc \\<up> x;\n        b = Oc \\<up> i @ [Bk]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i + j = x \\<and> list = Bk \\<up> j @ Oc \\<up> x", "by (metis Cons_replicate_eq One_nat_def Suc_inject Suc_pred add_Suc_right cell.distinct(1)\n      empty_replicate list.sel(3) neq0_conv self_append_conv2 tl_append2 tl_replicate)"], ["", "lemma inv_end2_Bk_via_3[elim]: \"\\<lbrakk>0 < x; inv_end3 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_end2 x (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end3 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end2 x (Bk # b, list)", "by (auto simp: inv_end2.simps inv_end3.simps)"], ["", "lemma inv_end5_Bk_via_4[elim]: \"\\<lbrakk>0 < x; inv_end4 x ([], Bk # list)\\<rbrakk> \\<Longrightarrow> \n  inv_end5 x ([], Bk # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end4 x ([], Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end5 x ([], Bk # Bk # list)", "by (auto simp: inv_end4.simps inv_end5.simps)"], ["", "lemma inv_end5_Bk_tail_via_4[elim]: \"\\<lbrakk>0 < x; inv_end4 x (b, Bk # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  inv_end5 x (tl b, hd b # Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end4 x (b, Bk # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_end5 x (tl b, hd b # Bk # list)", "apply(auto simp: inv_end4.simps inv_end5.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; b = Oc \\<up> x @ [Bk]; list = Oc \\<up> x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>j.\n                         x + j - Suc 0 = x \\<and>\n                         0 < j \\<and> [Oc] = Oc \\<up> j", "apply(rule_tac x = 1 in exI, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_end0_Bk_via_5[elim]: \"\\<lbrakk>0 < x; inv_end5 x (b, Bk # list)\\<rbrakk> \\<Longrightarrow> inv_end0 x (Bk # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end5 x (b, Bk # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end0 x (Bk # b, list)", "by(auto simp: inv_end5.simps inv_end0.simps gr0_conv_Suc)"], ["", "lemma inv_end2_Oc_via_1[elim]: \"\\<lbrakk>0 < x; inv_end1 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end2 x (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end1 x (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end2 x (Oc # b, list)", "by (auto simp: inv_end1.simps inv_end2.simps)"], ["", "lemma inv_end4_Bk_Oc_via_2[elim]: \"\\<lbrakk>0 < x; inv_end2 x ([], Oc # list)\\<rbrakk> \\<Longrightarrow>\n               inv_end4 x ([], Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end2 x ([], Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end4 x ([], Bk # Oc # list)", "by (auto simp: inv_end2.simps inv_end4.simps)"], ["", "lemma inv_end4_Oc_via_2[elim]:  \"\\<lbrakk>0 < x; inv_end2 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow>\n  inv_end4 x (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end2 x (b, Oc # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_end4 x (tl b, hd b # Oc # list)", "by(auto simp: inv_end2.simps inv_end4.simps gr0_conv_Suc)"], ["", "lemma inv_end2_Oc_via_3[elim]: \"\\<lbrakk>0 < x; inv_end3 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end2 x (Oc # b, list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end3 x (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end2 x (Oc # b, list)", "by (auto simp: inv_end2.simps inv_end3.simps)"], ["", "lemma inv_end4_Bk_via_Oc[elim]: \"\\<lbrakk>0 < x; inv_end4 x (b, Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end4 x (b, Bk # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end4 x (b, Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end4 x (b, Bk # list)", "by (auto simp: inv_end2.simps inv_end4.simps)"], ["", "lemma inv_end5_Bk_drop_Oc[elim]: \"\\<lbrakk>0 < x; inv_end5 x ([], Oc # list)\\<rbrakk> \\<Longrightarrow> inv_end5 x ([], Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end5 x ([], Oc # list)\\<rbrakk>\n    \\<Longrightarrow> inv_end5 x ([], Bk # Oc # list)", "by (auto simp: inv_end2.simps inv_end5.simps)"], ["", "declare inv_end5_loop.simps[simp del]\n  inv_end5_exit.simps[simp del]"], ["", "lemma inv_end5_exit_no_Oc[simp]: \"inv_end5_exit x (b, Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_end5_exit x (b, Oc # list) = False", "by (auto simp: inv_end5_exit.simps)"], ["", "lemma inv_end5_loop_no_Bk_Oc[simp]: \"inv_end5_loop x (tl b, Bk # Oc # list) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_end5_loop x (tl b, Bk # Oc # list) = False", "by (auto simp: inv_end5_loop.simps)"], ["", "lemma inv_end5_exit_Bk_Oc_via_loop[elim]:\n  \"\\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> []; hd b = Bk\\<rbrakk> \\<Longrightarrow>\n  inv_end5_exit x (tl b, Bk # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> [];\n     hd b = Bk\\<rbrakk>\n    \\<Longrightarrow> inv_end5_exit x (tl b, Bk # Oc # list)", "apply(auto simp: inv_end5_loop.simps inv_end5_exit.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Bk; x = i + j;\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j);\n        b = Oc \\<up> i @ [Bk]; 0 < j;\n        tl (Oc \\<up> i @ [Bk]) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> i = 0\n 2. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Bk; x = i + j;\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j);\n        b = Oc \\<up> i @ [Bk]; 0 < j;\n        tl (Oc \\<up> i @ [Bk]) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "using hd_replicate"], ["proof (prove)\nusing this:\n  ?n \\<noteq> 0 \\<Longrightarrow> hd (?x \\<up> ?n) = ?x\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Bk; x = i + j;\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j);\n        b = Oc \\<up> i @ [Bk]; 0 < j;\n        tl (Oc \\<up> i @ [Bk]) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> i = 0\n 2. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Bk; x = i + j;\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j);\n        b = Oc \\<up> i @ [Bk]; 0 < j;\n        tl (Oc \\<up> i @ [Bk]) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Bk; x = i + j;\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j);\n        b = Oc \\<up> i @ [Bk]; 0 < j;\n        tl (Oc \\<up> i @ [Bk]) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis cell.distinct(1) hd_append2 hd_replicate list.sel(3) self_append_conv2\n      split_head_repeat(2))"], ["", "lemma inv_end5_loop_Oc_Oc_drop[elim]: \n  \"\\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> []; hd b = Oc\\<rbrakk> \\<Longrightarrow>\n  inv_end5_loop x (tl b, Oc # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> [];\n     hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> inv_end5_loop x (tl b, Oc # Oc # list)", "apply(simp only: inv_end5_loop.simps inv_end5_exit.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x;\n     \\<exists>i j.\n        i + j = x \\<and>\n        True \\<and>\n        0 < j \\<and>\n        b = Oc \\<up> i @ [Bk] \\<and>\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> x;\n     b \\<noteq> []; hd b = Oc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i j.\n                         i + j = x \\<and>\n                         True \\<and>\n                         0 < j \\<and>\n                         tl b = Oc \\<up> i @ [Bk] \\<and>\n                         Oc # Oc # list = Oc \\<up> j @ Bk # Oc \\<up> x", "apply(erule_tac exE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Oc;\n        i + j = x \\<and>\n        True \\<and>\n        0 < j \\<and>\n        b = Oc \\<up> i @ [Bk] \\<and>\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = x \\<and>\n                            True \\<and>\n                            0 < j \\<and>\n                            tl b = Oc \\<up> i @ [Bk] \\<and>\n                            Oc # Oc # list = Oc \\<up> j @ Bk # Oc \\<up> x", "apply(rename_tac i j)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>0 < x; b \\<noteq> []; hd b = Oc;\n        i + j = x \\<and>\n        True \\<and>\n        0 < j \\<and>\n        b = Oc \\<up> i @ [Bk] \\<and>\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i j.\n                            i + j = x \\<and>\n                            True \\<and>\n                            0 < j \\<and>\n                            tl b = Oc \\<up> i @ [Bk] \\<and>\n                            Oc # Oc # list = Oc \\<up> j @ Bk # Oc \\<up> x", "apply(rule_tac x = \"i - 1\" in exI, \n      rule_tac x = \"Suc j\" in exI, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Oc; x = i + j; 0 < j;\n        b = Oc \\<up> i @ [Bk];\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j)\\<rbrakk>\n       \\<Longrightarrow> Suc (i - Suc 0) = i\n 2. \\<And>i j.\n       \\<lbrakk>hd (Oc \\<up> i @ [Bk]) = Oc; x = i + j; 0 < j;\n        b = Oc \\<up> i @ [Bk];\n        Oc # list = Oc \\<up> j @ Bk # Oc \\<up> (i + j)\\<rbrakk>\n       \\<Longrightarrow> tl (Oc \\<up> i @ [Bk]) =\n                         Oc \\<up> (i - Suc 0) @ [Bk]", "apply(case_tac [!] i, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_end5_Oc_tail[elim]: \"\\<lbrakk>0 < x; inv_end5 x (b, Oc # list); b \\<noteq> []\\<rbrakk> \\<Longrightarrow> \n  inv_end5 x (tl b, hd b # Oc # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end5 x (b, Oc # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_end5 x (tl b, hd b # Oc # list)", "apply(simp add: inv_end2.simps inv_end5.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end5_loop x (b, Oc # list); b \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> inv_end5_loop x (tl b, hd b # Oc # list) \\<or>\n                      inv_end5_exit x (tl b, hd b # Oc # list)", "apply(case_tac \"hd b\", simp_all, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_end_step:\n  \"\\<lbrakk>x > 0; inv_end x cf\\<rbrakk> \\<Longrightarrow> inv_end x (step cf (tcopy_end, 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end x cf\\<rbrakk>\n    \\<Longrightarrow> inv_end x (step0 cf tcopy_end)", "apply(cases cf, cases \"snd (snd cf)\"; cases \"hd (snd (snd cf))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>0 < x; inv_end x cf; cf = (a, b, c); snd (snd cf) = [];\n        hd (snd (snd cf)) = Bk\\<rbrakk>\n       \\<Longrightarrow> inv_end x (step0 cf tcopy_end)\n 2. \\<And>a b c.\n       \\<lbrakk>0 < x; inv_end x cf; cf = (a, b, c); snd (snd cf) = [];\n        hd (snd (snd cf)) = Oc\\<rbrakk>\n       \\<Longrightarrow> inv_end x (step0 cf tcopy_end)\n 3. \\<And>a b c aa list.\n       \\<lbrakk>0 < x; inv_end x cf; cf = (a, b, c);\n        snd (snd cf) = aa # list; hd (snd (snd cf)) = Bk\\<rbrakk>\n       \\<Longrightarrow> inv_end x (step0 cf tcopy_end)\n 4. \\<And>a b c aa list.\n       \\<lbrakk>0 < x; inv_end x cf; cf = (a, b, c);\n        snd (snd cf) = aa # list; hd (snd (snd cf)) = Oc\\<rbrakk>\n       \\<Longrightarrow> inv_end x (step0 cf tcopy_end)", "apply(auto simp: inv_end.simps step.simps tcopy_end_def numeral split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inv_end_steps:\n  \"\\<lbrakk>x > 0; inv_end x cf\\<rbrakk> \\<Longrightarrow> inv_end x (steps cf (tcopy_end, 0) stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end x cf\\<rbrakk>\n    \\<Longrightarrow> inv_end x (steps0 cf tcopy_end stp)", "apply(induct stp, simp add:steps.simps, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>stp.\n       \\<lbrakk>inv_end x (steps0 cf tcopy_end stp); 0 < x;\n        inv_end x cf\\<rbrakk>\n       \\<Longrightarrow> inv_end x\n                          (step0 (steps0 cf tcopy_end stp) tcopy_end)", "apply(erule_tac inv_end_step, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun end_state :: \"config \\<Rightarrow> nat\"\n  where\n    \"end_state (s, l, r) = \n       (if s = 0 then 0\n        else if s = 1 then 5\n        else if s = 2 \\<or> s = 3 then 4\n        else if s = 4 then 3 \n        else if s = 5 then 2\n        else 0)\""], ["", "fun end_stage :: \"config \\<Rightarrow> nat\"\n  where\n    \"end_stage (s, l, r) = \n          (if s = 2 \\<or> s = 3 then (length r) else 0)\""], ["", "fun end_step :: \"config \\<Rightarrow> nat\"\n  where\n    \"end_step (s, l, r) = \n         (if s = 4 then (if hd r = Oc then 1 else 0)\n          else if s = 5 then length l\n          else if s = 2 then 1\n          else if s = 3 then 0\n          else 0)\""], ["", "definition end_LE :: \"(config \\<times> config) set\"\n  where\n    \"end_LE = measures [end_state, end_stage, end_step]\""], ["", "lemma wf_end_le: \"wf end_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf end_LE", "unfolding end_LE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures [end_state, end_stage, end_step])", "by auto"], ["", "lemma halt_lemma: \n  \"\\<lbrakk>wf LE; \\<forall>n. (\\<not> P (f n) \\<longrightarrow> (f (Suc n), (f n)) \\<in> LE)\\<rbrakk> \\<Longrightarrow> \\<exists>n. P (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf LE;\n     \\<forall>n.\n        \\<not> P (f n) \\<longrightarrow> (f (Suc n), f n) \\<in> LE\\<rbrakk>\n    \\<Longrightarrow> \\<exists>n. P (f n)", "by (metis wf_iff_no_infinite_down_chain)"], ["", "lemma end_halt: \n  \"\\<lbrakk>x > 0; inv_end x (Suc 0, l, r)\\<rbrakk> \\<Longrightarrow> \n      \\<exists> stp. is_final (steps (Suc 0, l, r) (tcopy_end, 0) stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end x (Suc 0, l, r)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>stp.\n                         is_final (steps0 (Suc 0, l, r) tcopy_end stp)", "proof(rule halt_lemma[OF wf_end_le])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end x (Suc 0, l, r)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>stp.\n                         \\<not> is_final\n                                 (steps0 (Suc 0, l, r) tcopy_end\n                                   stp) \\<longrightarrow>\n                         (steps0 (Suc 0, l, r) tcopy_end (Suc stp),\n                          steps0 (Suc 0, l, r) tcopy_end stp)\n                         \\<in> end_LE", "assume great: \"0 < x\"\n    and inv_start: \"inv_end x (Suc 0, l, r)\""], ["proof (state)\nthis:\n  0 < x\n  inv_end x (Suc 0, l, r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; inv_end x (Suc 0, l, r)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>stp.\n                         \\<not> is_final\n                                 (steps0 (Suc 0, l, r) tcopy_end\n                                   stp) \\<longrightarrow>\n                         (steps0 (Suc 0, l, r) tcopy_end (Suc stp),\n                          steps0 (Suc 0, l, r) tcopy_end stp)\n                         \\<in> end_LE", "show \"\\<forall>n. \\<not> is_final (steps (Suc 0, l, r) (tcopy_end, 0) n) \\<longrightarrow> \n    (steps (Suc 0, l, r) (tcopy_end, 0) (Suc n), steps (Suc 0, l, r) (tcopy_end, 0) n) \\<in> end_LE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "proof(rule_tac allI, rule_tac impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<Longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<Longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "assume notfinal: \"\\<not> is_final (steps (Suc 0, l, r) (tcopy_end, 0) n)\""], ["proof (state)\nthis:\n  \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<Longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "obtain s' l' r' where d: \"steps (Suc 0, l, r) (tcopy_end, 0) n = (s', l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s' l' r'.\n        steps0 (Suc 0, l, r) tcopy_end n = (s', l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(case_tac \"steps (Suc 0, l, r) (tcopy_end, 0) n\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  steps0 (Suc 0, l, r) tcopy_end n = (s', l', r')\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<Longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "hence \"inv_end x (s', l', r') \\<and> s' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) tcopy_end n = (s', l', r')\n\ngoal (1 subgoal):\n 1. inv_end x (s', l', r') \\<and> s' \\<noteq> 0", "using great inv_start notfinal"], ["proof (prove)\nusing this:\n  steps0 (Suc 0, l, r) tcopy_end n = (s', l', r')\n  0 < x\n  inv_end x (Suc 0, l, r)\n  \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n)\n\ngoal (1 subgoal):\n 1. inv_end x (s', l', r') \\<and> s' \\<noteq> 0", "apply(drule_tac stp = n in inv_end_steps, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv_end x (s', l', r') \\<and> s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<Longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "hence \"(step (s', l', r') (tcopy_end, 0), s', l', r') \\<in> end_LE\""], ["proof (prove)\nusing this:\n  inv_end x (s', l', r') \\<and> s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (step0 (s', l', r') tcopy_end, s', l', r') \\<in> end_LE", "apply(cases r'; cases \"hd r'\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>inv_end x (s', l', r') \\<and> s' \\<noteq> 0; r' = [];\n     inv_end x (s', l', r') \\<and> s' \\<noteq> 0; hd r' = Bk\\<rbrakk>\n    \\<Longrightarrow> (step0 (s', l', r') tcopy_end, s', l', r')\n                      \\<in> end_LE\n 2. \\<lbrakk>inv_end x (s', l', r') \\<and> s' \\<noteq> 0; r' = [];\n     inv_end x (s', l', r') \\<and> s' \\<noteq> 0; hd r' = Oc\\<rbrakk>\n    \\<Longrightarrow> (step0 (s', l', r') tcopy_end, s', l', r')\n                      \\<in> end_LE\n 3. \\<And>a list.\n       \\<lbrakk>inv_end x (s', l', r') \\<and> s' \\<noteq> 0; r' = a # list;\n        inv_end x (s', l', r') \\<and> s' \\<noteq> 0; hd r' = Bk\\<rbrakk>\n       \\<Longrightarrow> (step0 (s', l', r') tcopy_end, s', l', r')\n                         \\<in> end_LE\n 4. \\<And>a list.\n       \\<lbrakk>inv_end x (s', l', r') \\<and> s' \\<noteq> 0; r' = a # list;\n        inv_end x (s', l', r') \\<and> s' \\<noteq> 0; hd r' = Oc\\<rbrakk>\n       \\<Longrightarrow> (step0 (s', l', r') tcopy_end, s', l', r')\n                         \\<in> end_LE", "apply(auto simp: inv_end.simps step.simps tcopy_end_def numeral end_LE_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (step0 (s', l', r') tcopy_end, s', l', r') \\<in> end_LE\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<Longrightarrow>\n       (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n        steps0 (Suc 0, l, r) tcopy_end n)\n       \\<in> end_LE", "thus \"(steps (Suc 0, l, r) (tcopy_end, 0) (Suc n), \n      steps (Suc 0, l, r) (tcopy_end, 0) n) \\<in> end_LE\""], ["proof (prove)\nusing this:\n  (step0 (s', l', r') tcopy_end, s', l', r') \\<in> end_LE\n\ngoal (1 subgoal):\n 1. (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n     steps0 (Suc 0, l, r) tcopy_end n)\n    \\<in> end_LE", "using d"], ["proof (prove)\nusing this:\n  (step0 (s', l', r') tcopy_end, s', l', r') \\<in> end_LE\n  steps0 (Suc 0, l, r) tcopy_end n = (s', l', r')\n\ngoal (1 subgoal):\n 1. (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n     steps0 (Suc 0, l, r) tcopy_end n)\n    \\<in> end_LE", "by simp"], ["proof (state)\nthis:\n  (steps0 (Suc 0, l, r) tcopy_end (Suc n), steps0 (Suc 0, l, r) tcopy_end n)\n  \\<in> end_LE\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<not> is_final (steps0 (Suc 0, l, r) tcopy_end n) \\<longrightarrow>\n     (steps0 (Suc 0, l, r) tcopy_end (Suc n),\n      steps0 (Suc 0, l, r) tcopy_end n)\n     \\<in> end_LE\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma end_correct:\n  \"n > 0 \\<Longrightarrow> {inv_end1 n} tcopy_end {inv_end0 n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> {inv_end1 n} tcopy_end {inv_end0 n}", "proof(rule_tac Hoare_haltI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "fix l r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "assume h: \"0 < n\"\n    \"inv_end1 n (l, r)\""], ["proof (state)\nthis:\n  0 < n\n  inv_end1 n (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "then"], ["proof (chain)\npicking this:\n  0 < n\n  inv_end1 n (l, r)", "have \"\\<exists> stp. is_final (steps0 (1, l, r) tcopy_end stp)\""], ["proof (prove)\nusing this:\n  0 < n\n  inv_end1 n (l, r)\n\ngoal (1 subgoal):\n 1. \\<exists>stp. is_final (steps0 (1, l, r) tcopy_end stp)", "by (simp add: end_halt inv_end.simps)"], ["proof (state)\nthis:\n  \\<exists>stp. is_final (steps0 (1, l, r) tcopy_end stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "then"], ["proof (chain)\npicking this:\n  \\<exists>stp. is_final (steps0 (1, l, r) tcopy_end stp)", "obtain stp where \"is_final (steps0 (1, l, r) tcopy_end stp)\""], ["proof (prove)\nusing this:\n  \\<exists>stp. is_final (steps0 (1, l, r) tcopy_end stp)\n\ngoal (1 subgoal):\n 1. (\\<And>stp.\n        is_final (steps0 (1, l, r) tcopy_end stp) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  is_final (steps0 (1, l, r) tcopy_end stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "moreover"], ["proof (state)\nthis:\n  is_final (steps0 (1, l, r) tcopy_end stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "have \"inv_end n (steps0 (1, l, r) tcopy_end stp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_end n (steps0 (1, l, r) tcopy_end stp)", "apply(rule_tac inv_end_steps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < n\n 2. inv_end n (1, l, r)", "using h"], ["proof (prove)\nusing this:\n  0 < n\n  inv_end1 n (l, r)\n\ngoal (2 subgoals):\n 1. 0 < n\n 2. inv_end n (1, l, r)", "by(simp_all add: inv_end.simps)"], ["proof (state)\nthis:\n  inv_end n (steps0 (1, l, r) tcopy_end stp)\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>0 < n; inv_end1 n (l, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>na.\n                            is_final (steps0 (1, l, r) tcopy_end na) \\<and>\n                            inv_end0\n                             n holds_for steps0 (1, l, r) tcopy_end na", "ultimately"], ["proof (chain)\npicking this:\n  is_final (steps0 (1, l, r) tcopy_end stp)\n  inv_end n (steps0 (1, l, r) tcopy_end stp)", "show\n    \"\\<exists>stp. is_final (steps (1, l, r) (tcopy_end, 0) stp) \\<and> \n    inv_end0 n holds_for steps (1, l, r) (tcopy_end, 0) stp\""], ["proof (prove)\nusing this:\n  is_final (steps0 (1, l, r) tcopy_end stp)\n  inv_end n (steps0 (1, l, r) tcopy_end stp)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final (steps0 (1, l, r) tcopy_end stp) \\<and>\n       inv_end0 n holds_for steps0 (1, l, r) tcopy_end stp", "using h"], ["proof (prove)\nusing this:\n  is_final (steps0 (1, l, r) tcopy_end stp)\n  inv_end n (steps0 (1, l, r) tcopy_end stp)\n  0 < n\n  inv_end1 n (l, r)\n\ngoal (1 subgoal):\n 1. \\<exists>stp.\n       is_final (steps0 (1, l, r) tcopy_end stp) \\<and>\n       inv_end0 n holds_for steps0 (1, l, r) tcopy_end stp", "apply(rule_tac x = stp in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_final (steps0 (1, l, r) tcopy_end stp);\n     inv_end n (steps0 (1, l, r) tcopy_end stp); 0 < n;\n     inv_end1 n (l, r)\\<rbrakk>\n    \\<Longrightarrow> is_final (steps0 (1, l, r) tcopy_end stp) \\<and>\n                      inv_end0 n holds_for steps0 (1, l, r) tcopy_end stp", "apply(cases \"(steps0 (1, l, r) tcopy_end stp)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>is_final (steps0 (1, l, r) tcopy_end stp);\n        inv_end n (steps0 (1, l, r) tcopy_end stp); 0 < n;\n        inv_end1 n (l, r);\n        steps0 (1, l, r) tcopy_end stp = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> is_final (steps0 (1, l, r) tcopy_end stp) \\<and>\n                         inv_end0 n holds_for steps0 (1, l, r) tcopy_end stp", "apply(simp add: inv_end.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>stp.\n     is_final (steps0 (1, l, r) tcopy_end stp) \\<and>\n     inv_end0 n holds_for steps0 (1, l, r) tcopy_end stp\n\ngoal:\nNo subgoals!", "qed"], ["", "(* tcopy *)"], ["", "lemma tm_wf_tcopy[intro]:\n  \"tm_wf (tcopy_begin, 0)\"\n  \"tm_wf (tcopy_loop, 0)\"\n  \"tm_wf (tcopy_end, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 tcopy_begin &&& tm_wf0 tcopy_loop &&& tm_wf0 tcopy_end", "by (auto simp: tm_wf.simps tcopy_end_def tcopy_loop_def tcopy_begin_def)"], ["", "lemma tcopy_correct1: \n  assumes \"0 < x\"\n  shows \"{inv_begin1 x} tcopy {inv_end0 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "have \"{inv_begin1 x} tcopy_begin {inv_begin0 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy_begin {inv_begin0 x}", "by (metis assms begin_correct)"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy_begin {inv_begin0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "moreover"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy_begin {inv_begin0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "have \"inv_begin0 x \\<mapsto> inv_loop1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_begin0 x \\<mapsto> inv_loop1 x", "unfolding assert_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l r. inv_begin0 x (l, r) \\<longrightarrow> inv_loop1 x (l, r)", "unfolding inv_begin0.simps inv_loop1.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l r.\n       1 < x \\<and> (l, r) = (Oc \\<up> (x - 2), [Oc, Oc, Bk, Oc]) \\<or>\n       x = 1 \\<and> (l, r) = ([], [Bk, Oc, Bk, Oc]) \\<longrightarrow>\n       inv_loop1_loop x (l, r) \\<or> inv_loop1_exit x (l, r)", "unfolding inv_loop1_loop.simps inv_loop1_exit.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l r.\n       1 < x \\<and> (l, r) = (Oc \\<up> (x - 2), [Oc, Oc, Bk, Oc]) \\<or>\n       x = 1 \\<and> (l, r) = ([], [Bk, Oc, Bk, Oc]) \\<longrightarrow>\n       (\\<exists>i j.\n           i + j + 1 = x \\<and>\n           (l, r) = (Oc \\<up> i, Oc # Oc # Bk \\<up> j @ Oc \\<up> j) \\<and>\n           0 < j) \\<or>\n       0 < x \\<and> (l, r) = ([], Bk # Oc # Bk \\<up> x @ Oc \\<up> x)", "apply(auto simp add: numeral Cons_eq_append_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < x \\<Longrightarrow>\n    \\<exists>j.\n       Suc (x + j - Suc (Suc 0)) = x \\<and>\n       (j = 0 \\<and> [Bk, Oc] = Oc \\<up> j \\<or>\n        (\\<exists>ys'.\n            Bk # ys' = Bk \\<up> j \\<and>\n            (ys' = [] \\<and> [Oc] = Oc \\<up> j \\<or>\n             [Oc] = ys' \\<and> j = 0))) \\<and>\n       0 < j", "by (rule_tac x = \"Suc 0\" in exI, auto)"], ["proof (state)\nthis:\n  inv_begin0 x \\<mapsto> inv_loop1 x\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "ultimately"], ["proof (chain)\npicking this:\n  {inv_begin1 x} tcopy_begin {inv_begin0 x}\n  inv_begin0 x \\<mapsto> inv_loop1 x", "have \"{inv_begin1 x} tcopy_begin {inv_loop1 x}\""], ["proof (prove)\nusing this:\n  {inv_begin1 x} tcopy_begin {inv_begin0 x}\n  inv_begin0 x \\<mapsto> inv_loop1 x\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy_begin {inv_loop1 x}", "by (rule_tac Hoare_consequence) (auto)"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy_begin {inv_loop1 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "moreover"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy_begin {inv_loop1 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "have \"{inv_loop1 x} tcopy_loop {inv_loop0 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {inv_loop1 x} tcopy_loop {inv_loop0 x}", "by (metis assms loop_correct)"], ["proof (state)\nthis:\n  {inv_loop1 x} tcopy_loop {inv_loop0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "ultimately"], ["proof (chain)\npicking this:\n  {inv_begin1 x} tcopy_begin {inv_loop1 x}\n  {inv_loop1 x} tcopy_loop {inv_loop0 x}", "have \"{inv_begin1 x} (tcopy_begin |+| tcopy_loop) {inv_loop0 x}\""], ["proof (prove)\nusing this:\n  {inv_begin1 x} tcopy_begin {inv_loop1 x}\n  {inv_loop1 x} tcopy_loop {inv_loop0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy_begin |+| tcopy_loop {inv_loop0 x}", "by (rule_tac Hoare_plus_halt) (auto)"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy_begin |+| tcopy_loop {inv_loop0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "moreover"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy_begin |+| tcopy_loop {inv_loop0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "have \"{inv_end1 x} tcopy_end {inv_end0 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {inv_end1 x} tcopy_end {inv_end0 x}", "by (metis assms end_correct)"], ["proof (state)\nthis:\n  {inv_end1 x} tcopy_end {inv_end0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "moreover"], ["proof (state)\nthis:\n  {inv_end1 x} tcopy_end {inv_end0 x}\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "have \"inv_loop0 x = inv_end1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_loop0 x = inv_end1 x", "by(auto simp: inv_end1.simps inv_loop1.simps assert_imp_def)"], ["proof (state)\nthis:\n  inv_loop0 x = inv_end1 x\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "ultimately"], ["proof (chain)\npicking this:\n  {inv_begin1 x} tcopy_begin |+| tcopy_loop {inv_loop0 x}\n  {inv_end1 x} tcopy_end {inv_end0 x}\n  inv_loop0 x = inv_end1 x", "show \"{inv_begin1 x} tcopy {inv_end0 x}\""], ["proof (prove)\nusing this:\n  {inv_begin1 x} tcopy_begin |+| tcopy_loop {inv_loop0 x}\n  {inv_end1 x} tcopy_end {inv_end0 x}\n  inv_loop0 x = inv_end1 x\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy {inv_end0 x}", "unfolding tcopy_def"], ["proof (prove)\nusing this:\n  {inv_begin1 x} tcopy_begin |+| tcopy_loop {inv_loop0 x}\n  {inv_end1 x} tcopy_end {inv_end0 x}\n  inv_loop0 x = inv_end1 x\n\ngoal (1 subgoal):\n 1. {inv_begin1 x} tcopy_begin |+| tcopy_loop |+| tcopy_end {inv_end0 x}", "by (rule_tac Hoare_plus_halt) (auto)"], ["proof (state)\nthis:\n  {inv_begin1 x} tcopy {inv_end0 x}\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation (input)\n  \"pre_tcopy n \\<equiv> \\<lambda>tp. tp = ([]::cell list, Oc \\<up> (Suc n))\""], ["", "abbreviation (input)\n  \"post_tcopy n \\<equiv> \\<lambda>tp. tp= ([Bk], <(n, n::nat)>)\""], ["", "lemma tcopy_correct:\n  shows \"{pre_tcopy n} tcopy {post_tcopy n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "have \"{inv_begin1 (Suc n)} tcopy {inv_end0 (Suc n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {inv_begin1 (Suc n)} tcopy {inv_end0 (Suc n)}", "by (rule tcopy_correct1) (simp)"], ["proof (state)\nthis:\n  {inv_begin1 (Suc n)} tcopy {inv_end0 (Suc n)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "moreover"], ["proof (state)\nthis:\n  {inv_begin1 (Suc n)} tcopy {inv_end0 (Suc n)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "have \"pre_tcopy n = inv_begin1 (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>tp. tp = ([], Oc \\<up> Suc n)) = inv_begin1 (Suc n)", "by (auto)"], ["proof (state)\nthis:\n  (\\<lambda>tp. tp = ([], Oc \\<up> Suc n)) = inv_begin1 (Suc n)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>tp. tp = ([], Oc \\<up> Suc n)) = inv_begin1 (Suc n)\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "have \"inv_end0 (Suc n) = post_tcopy n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_end0 (Suc n) = (\\<lambda>tp. tp = ([Bk], <(n, n)>))", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. inv_end0 (Suc n) x = (x = ([Bk], <(n, n)>))", "by (auto simp add: inv_end0.simps tape_of_nat_def tape_of_prod_def)"], ["proof (state)\nthis:\n  inv_end0 (Suc n) = (\\<lambda>tp. tp = ([Bk], <(n, n)>))\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "ultimately"], ["proof (chain)\npicking this:\n  {inv_begin1 (Suc n)} tcopy {inv_end0 (Suc n)}\n  (\\<lambda>tp. tp = ([], Oc \\<up> Suc n)) = inv_begin1 (Suc n)\n  inv_end0 (Suc n) = (\\<lambda>tp. tp = ([Bk], <(n, n)>))", "show \"{pre_tcopy n} tcopy {post_tcopy n}\""], ["proof (prove)\nusing this:\n  {inv_begin1 (Suc n)} tcopy {inv_end0 (Suc n)}\n  (\\<lambda>tp. tp = ([], Oc \\<up> Suc n)) = inv_begin1 (Suc n)\n  inv_end0 (Suc n) = (\\<lambda>tp. tp = ([Bk], <(n, n)>))\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(n, n)>)}", "by simp"], ["proof (state)\nthis:\n  {\\<lambda>tp. tp = ([], Oc \\<up> Suc n)} tcopy\n  {\\<lambda>tp. tp = ([Bk], <(n, n)>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The {\\em Dithering} Turing Machine\\<close>"], ["", "text \\<open>\n  The {\\em Dithering} TM, when the input is \\<open>1\\<close>, it will loop forever, otherwise, it will\n  terminate.\n\\<close>"], ["", "definition dither :: \"instr list\"\n  where\n    \"dither \\<equiv> [(W0, 1), (R, 2), (L, 1), (L, 0)] \""], ["", "(* invariants of dither *)"], ["", "abbreviation (input)\n  \"dither_halt_inv \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1::nat>)\""], ["", "abbreviation (input)\n  \"dither_unhalt_inv \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0::nat>)\""], ["", "lemma dither_loops_aux: \n  \"(steps0 (1, Bk \\<up> m, [Oc]) dither stp = (1, Bk \\<up> m, [Oc])) \\<or> \n   (steps0 (1, Bk \\<up> m, [Oc]) dither stp = (2, Oc # Bk \\<up> m, []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (1, Bk \\<up> m, [Oc]) dither stp = (1, Bk \\<up> m, [Oc]) \\<or>\n    steps0 (1, Bk \\<up> m, [Oc]) dither stp = (2, Oc # Bk \\<up> m, [])", "apply(induct stp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. steps0 (1, Bk \\<up> m, [Oc]) dither 0 = (1, Bk \\<up> m, [Oc]) \\<or>\n    steps0 (1, Bk \\<up> m, [Oc]) dither 0 = (2, Oc # Bk \\<up> m, [])\n 2. \\<And>stp.\n       steps0 (1, Bk \\<up> m, [Oc]) dither stp = (1, Bk \\<up> m, [Oc]) \\<or>\n       steps0 (1, Bk \\<up> m, [Oc]) dither stp =\n       (2, Oc # Bk \\<up> m, []) \\<Longrightarrow>\n       steps0 (1, Bk \\<up> m, [Oc]) dither (Suc stp) =\n       (1, Bk \\<up> m, [Oc]) \\<or>\n       steps0 (1, Bk \\<up> m, [Oc]) dither (Suc stp) =\n       (2, Oc # Bk \\<up> m, [])", "apply(auto simp: steps.simps step.simps dither_def numeral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dither_loops:\n  shows \"{dither_unhalt_inv} dither \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)} dither \\<up>", "apply(rule Hoare_unhaltI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r n.\n       \\<exists>k. (l, r) = (Bk \\<up> k, <0>) \\<Longrightarrow>\n       \\<not> is_final (steps0 (1, l, r) dither n)", "using dither_loops_aux"], ["proof (prove)\nusing this:\n  steps0 (1, Bk \\<up> ?m, [Oc]) dither ?stp = (1, Bk \\<up> ?m, [Oc]) \\<or>\n  steps0 (1, Bk \\<up> ?m, [Oc]) dither ?stp = (2, Oc # Bk \\<up> ?m, [])\n\ngoal (1 subgoal):\n 1. \\<And>l r n.\n       \\<exists>k. (l, r) = (Bk \\<up> k, <0>) \\<Longrightarrow>\n       \\<not> is_final (steps0 (1, l, r) dither n)", "apply(auto simp add: numeral tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       \\<lbrakk>\\<And>m stp.\n                   steps0 (Suc 0, Bk \\<up> m, [Oc]) dither stp =\n                   (Suc 0, Bk \\<up> m, [Oc]) \\<or>\n                   steps0 (Suc 0, Bk \\<up> m, [Oc]) dither stp =\n                   (Suc (Suc 0), Oc # Bk \\<up> m, []);\n        is_final (steps0 (Suc 0, Bk \\<up> k, [Oc]) dither n)\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis Suc_neq_Zero is_final_eq)"], ["", "lemma dither_halts_aux: \n  shows \"steps0 (1, Bk \\<up> m, [Oc, Oc]) dither 2 = (0, Bk \\<up> m, [Oc, Oc])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (1, Bk \\<up> m, [Oc, Oc]) dither 2 = (0, Bk \\<up> m, [Oc, Oc])", "unfolding dither_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps0 (1, Bk \\<up> m, [Oc, Oc]) [(W0, 1), (R, 2), (L, 1), (L, 0)] 2 =\n    (0, Bk \\<up> m, [Oc, Oc])", "by (simp add: steps.simps step.simps numeral)"], ["", "lemma dither_halts:\n  shows \"{dither_halt_inv} dither {dither_halt_inv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)} dither\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}", "apply(rule Hoare_haltI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<exists>k. (l, r) = (Bk \\<up> k, <1>) \\<Longrightarrow>\n       \\<exists>n.\n          is_final (steps0 (1, l, r) dither n) \\<and>\n          (\\<lambda>tp.\n              \\<exists>k.\n                 tp = (Bk \\<up> k, <1>)) holds_for steps0 (1, l, r) dither n", "using dither_halts_aux"], ["proof (prove)\nusing this:\n  steps0 (1, Bk \\<up> ?m, [Oc, Oc]) dither 2 = (0, Bk \\<up> ?m, [Oc, Oc])\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<exists>k. (l, r) = (Bk \\<up> k, <1>) \\<Longrightarrow>\n       \\<exists>n.\n          is_final (steps0 (1, l, r) dither n) \\<and>\n          (\\<lambda>tp.\n              \\<exists>k.\n                 tp = (Bk \\<up> k, <1>)) holds_for steps0 (1, l, r) dither n", "apply(auto simp add: tape_of_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       (\\<And>m.\n           steps0 (Suc 0, Bk \\<up> m, [Oc, Oc]) dither 2 =\n           (0, Bk \\<up> m, [Oc, Oc])) \\<Longrightarrow>\n       \\<exists>n.\n          is_final (steps0 (Suc 0, Bk \\<up> k, [Oc, Oc]) dither n) \\<and>\n          (\\<lambda>tp.\n              \\<exists>k.\n                 tp =\n                 (Bk \\<up> k,\n                  [Oc,\n                   Oc])) holds_for steps0 (Suc 0, Bk \\<up> k, [Oc, Oc])\n                                    dither n", "by (metis (lifting, mono_tags) holds_for.simps is_final_eq)"], ["", "section \\<open>The diagnal argument below shows the undecidability of Halting problem\\<close>"], ["", "text \\<open>\n  \\<open>halts tp x\\<close> means TM \\<open>tp\\<close> terminates on input \\<open>x\\<close>\n  and the final configuration is standard.\n\\<close>"], ["", "definition halts :: \"tprog0 \\<Rightarrow> nat list \\<Rightarrow> bool\"\n  where\n    \"halts p ns \\<equiv> {(\\<lambda>tp. tp = ([], <ns>))} p {(\\<lambda>tp. (\\<exists>k n l. tp = (Bk \\<up> k,  <n::nat> @ Bk \\<up> l)))}\""], ["", "lemma tm_wf0_tcopy[intro, simp]: \"tm_wf0 tcopy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 tcopy", "by (auto simp: tcopy_def)"], ["", "lemma tm_wf0_dither[intro, simp]: \"tm_wf0 dither\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 dither", "by (auto simp: tm_wf.simps dither_def)"], ["", "text \\<open>\n  The following locale specifies that TM \\<open>H\\<close> can be used to solve \n  the {\\em Halting Problem} and \\<open>False\\<close> is going to be derived \n  under this locale. Therefore, the undecidability of {\\em Halting Problem}\n  is established. \n\\<close>"], ["", "locale uncomputable = \n  (* The coding function of TM, interestingly, the detailed definition of this \n  funciton @{text \"code\"} does not affect the final result. *)\n  fixes code :: \"instr list \\<Rightarrow> nat\" \n    (* \n  The TM @{text \"H\"} is the one which is assummed being able to solve the Halting problem.\n  *)\n    and H :: \"instr list\"\n  assumes h_wf[intro]: \"tm_wf0 H\"\n    (*\n  The following two assumptions specifies that @{text \"H\"} does solve the Halting problem.\n  *)\n    and h_case: \n    \"\\<And> M ns. halts M ns \\<Longrightarrow> {(\\<lambda>tp. tp = ([Bk], <(code M, ns)>))} H {(\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0::nat>))}\"\n    and nh_case: \n    \"\\<And> M ns. \\<not> halts M ns \\<Longrightarrow> {(\\<lambda>tp. tp = ([Bk], <(code M, ns)>))} H {(\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1::nat>))}\"\nbegin"], ["", "(* invariants for H *)"], ["", "abbreviation (input)\n  \"pre_H_inv M ns \\<equiv> \\<lambda>tp. tp = ([Bk], <(code M, ns::nat list)>)\""], ["", "abbreviation (input)\n  \"post_H_halt_inv \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1::nat>)\""], ["", "abbreviation (input)\n  \"post_H_unhalt_inv \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0::nat>)\""], ["", "lemma H_halt_inv:\n  assumes \"\\<not> halts M ns\" \n  shows \"{pre_H_inv M ns} H {post_H_halt_inv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code M, ns)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}", "using assms nh_case"], ["proof (prove)\nusing this:\n  \\<not> halts M ns\n  \\<not> halts ?M ?ns \\<Longrightarrow>\n  {\\<lambda>tp. tp = ([Bk], <(code ?M, ?ns)>)} H\n  {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code M, ns)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}", "by auto"], ["", "lemma H_unhalt_inv:\n  assumes \"halts M ns\" \n  shows \"{pre_H_inv M ns} H {post_H_unhalt_inv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code M, ns)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)}", "using assms h_case"], ["proof (prove)\nusing this:\n  halts M ns\n  halts ?M ?ns \\<Longrightarrow>\n  {\\<lambda>tp. tp = ([Bk], <(code ?M, ?ns)>)} H\n  {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code M, ns)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)}", "by auto"], ["", "(* TM that produces the contradiction and its code *)"], ["", "definition\n  \"tcontra \\<equiv> (tcopy |+| H) |+| dither\""], ["", "abbreviation\n  \"code_tcontra \\<equiv> code tcontra\""], ["", "(* assume tcontra does not halt on its code *)"], ["", "lemma tcontra_unhalt: \n  assumes \"\\<not> halts tcontra [code tcontra]\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "(* invariants *)"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define P1 where \"P1 \\<equiv> \\<lambda>tp. tp = ([]::cell list, <code_tcontra>)\""], ["proof (state)\nthis:\n  P1 \\<equiv> \\<lambda>tp. tp = ([], <code_tcontra>)\n\ngoal (1 subgoal):\n 1. False", "define P2 where \"P2 \\<equiv> \\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)\""], ["proof (state)\nthis:\n  P2 \\<equiv> \\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)\n\ngoal (1 subgoal):\n 1. False", "define P3 where \"P3 \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1::nat>)\""], ["proof (state)\nthis:\n  P3 \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)\n\ngoal (1 subgoal):\n 1. False", "(*\n  {P1} tcopy {P2}  {P2} H {P3} \n  ----------------------------\n     {P1} (tcopy |+| H) {P3}     {P3} dither {P3}\n  ------------------------------------------------\n                 {P1} tcontra {P3}\n  *)"], ["proof (state)\nthis:\n  P3 \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)\n\ngoal (1 subgoal):\n 1. False", "have H_wf: \"tm_wf0 (tcopy |+| H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 (tcopy |+| H)", "by auto"], ["proof (state)\nthis:\n  tm_wf0 (tcopy |+| H)\n\ngoal (1 subgoal):\n 1. False", "(* {P1} (tcopy |+| H) {P3} *)"], ["proof (state)\nthis:\n  tm_wf0 (tcopy |+| H)\n\ngoal (1 subgoal):\n 1. False", "have first: \"{P1} (tcopy |+| H) {P3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcopy |+| H {P3}", "proof (cases rule: Hoare_plus_halt)"], ["proof (state)\ngoal (3 subgoals):\n 1. {P1} tcopy {?Q}\n 2. {?Q} H {P3}\n 3. tm_wf0 tcopy", "case A_halt"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. {P1} tcopy {?Q}\n 2. {?Q} H {P3}\n 3. tm_wf0 tcopy", "(* of tcopy *)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. {P1} tcopy {?Q}\n 2. {?Q} H {P3}\n 3. tm_wf0 tcopy", "show \"{P1} tcopy {P2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcopy {P2}", "unfolding P1_def P2_def tape_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc code_tcontra)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)}", "by (rule tcopy_correct)"], ["proof (state)\nthis:\n  {P1} tcopy {P2}\n\ngoal (2 subgoals):\n 1. {P2} H {P3}\n 2. tm_wf0 tcopy", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {P2} H {P3}\n 2. tm_wf0 tcopy", "case B_halt"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {P2} H {P3}\n 2. tm_wf0 tcopy", "(* of H *)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {P2} H {P3}\n 2. tm_wf0 tcopy", "show \"{P2} H {P3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P2} H {P3}", "unfolding P2_def P3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}", "using H_halt_inv[OF assms]"], ["proof (prove)\nusing this:\n  {\\<lambda>tp. tp = ([Bk], <(code_tcontra, [code_tcontra])>)} H\n  {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}", "by (simp add: tape_of_prod_def tape_of_list_def)"], ["proof (state)\nthis:\n  {P2} H {P3}\n\ngoal (1 subgoal):\n 1. tm_wf0 tcopy", "qed (simp)"], ["proof (state)\nthis:\n  {P1} tcopy |+| H {P3}\n\ngoal (1 subgoal):\n 1. False", "(* {P3} dither {P3} *)"], ["proof (state)\nthis:\n  {P1} tcopy |+| H {P3}\n\ngoal (1 subgoal):\n 1. False", "have second: \"{P3} dither {P3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P3} dither {P3}", "unfolding P3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)} dither\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}", "by (rule dither_halts)"], ["proof (state)\nthis:\n  {P3} dither {P3}\n\ngoal (1 subgoal):\n 1. False", "(* {P1} tcontra {P3} *)"], ["proof (state)\nthis:\n  {P3} dither {P3}\n\ngoal (1 subgoal):\n 1. False", "have \"{P1} tcontra {P3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcontra {P3}", "unfolding tcontra_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcopy |+| H |+| dither {P3}", "by (rule Hoare_plus_halt[OF first second H_wf])"], ["proof (state)\nthis:\n  {P1} tcontra {P3}\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  \\<not> halts tcontra [code_tcontra]\n  {P1} tcontra {P3}", "show \"False\""], ["proof (prove)\nusing this:\n  \\<not> halts tcontra [code_tcontra]\n  {P1} tcontra {P3}\n\ngoal (1 subgoal):\n 1. False", "unfolding P1_def P3_def"], ["proof (prove)\nusing this:\n  \\<not> halts tcontra [code_tcontra]\n  {\\<lambda>tp. tp = ([], <code_tcontra>)} tcontra\n  {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}\n\ngoal (1 subgoal):\n 1. False", "unfolding halts_def"], ["proof (prove)\nusing this:\n  \\<not> {\\<lambda>tp. tp = ([], <[code_tcontra]>)} tcontra\n         {\\<lambda>tp. \\<exists>k n l. tp = (Bk \\<up> k, <n> @ Bk \\<up> l)}\n  {\\<lambda>tp. tp = ([], <code_tcontra>)} tcontra\n  {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <1>)}\n\ngoal (1 subgoal):\n 1. False", "unfolding Hoare_halt_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>tp.\n             tp = ([], <[code_tcontra]>) \\<longrightarrow>\n             (\\<exists>n.\n                 is_final (steps0 (1, tp) tcontra n) \\<and>\n                 (\\<lambda>tp.\n                     \\<exists>k n l.\n                        tp =\n                        (Bk \\<up> k,\n                         <n> @\n                         Bk \\<up> l)) holds_for steps0 (1, tp) tcontra n))\n  \\<forall>tp.\n     tp = ([], <code_tcontra>) \\<longrightarrow>\n     (\\<exists>n.\n         is_final (steps0 (1, tp) tcontra n) \\<and>\n         (\\<lambda>tp.\n             \\<exists>k.\n                tp = (Bk \\<up> k, <1>)) holds_for steps0 (1, tp) tcontra n)\n\ngoal (1 subgoal):\n 1. False", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n.\n                   is_final\n                    (steps0 (Suc 0, [], <[code_tcontra]>) tcontra\n                      n) \\<longrightarrow>\n                   \\<not> (\\<lambda>tp.\n                              \\<exists>k n l.\n                                 tp =\n                                 (Bk \\<up> k,\n                                  <n> @\n                                  Bk \\<up> l)) holds_for steps0\n                    (Suc 0, [], <[code_tcontra]>) tcontra n;\n        is_final (steps0 (Suc 0, [], <code_tcontra>) tcontra n);\n        (\\<lambda>tp.\n            \\<exists>k.\n               tp =\n               (Bk \\<up> k,\n                <Suc 0>)) holds_for steps0 (Suc 0, [], <code_tcontra>)\n                                     tcontra n\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n.\n                   is_final\n                    (steps0 (Suc 0, [], <[code_tcontra]>) tcontra\n                      n) \\<longrightarrow>\n                   \\<not> (\\<lambda>tp.\n                              \\<exists>k n l.\n                                 tp =\n                                 (Bk \\<up> k,\n                                  <n> @\n                                  Bk \\<up> l)) holds_for steps0\n                    (Suc 0, [], <[code_tcontra]>) tcontra n;\n        is_final (steps0 (Suc 0, [], <code_tcontra>) tcontra n);\n        (\\<lambda>tp.\n            \\<exists>k.\n               tp =\n               (Bk \\<up> k,\n                <Suc 0>)) holds_for steps0 (Suc 0, [], <code_tcontra>)\n                                     tcontra n\\<rbrakk>\n       \\<Longrightarrow> False", "apply(drule_tac x = n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>is_final (steps0 (Suc 0, [], <code_tcontra>) tcontra n);\n        (\\<lambda>tp.\n            \\<exists>k.\n               tp =\n               (Bk \\<up> k,\n                <Suc 0>)) holds_for steps0 (Suc 0, [], <code_tcontra>)\n                                     tcontra n;\n        is_final\n         (steps0 (Suc 0, [], <[code_tcontra]>) tcontra n) \\<longrightarrow>\n        \\<not> (\\<lambda>tp.\n                   \\<exists>k n l.\n                      tp =\n                      (Bk \\<up> k,\n                       <n> @\n                       Bk \\<up> l)) holds_for steps0\n         (Suc 0, [], <[code_tcontra]>) tcontra n\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac \"steps0 (Suc 0, [], <code tcontra>) tcontra n\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n a b c.\n       \\<lbrakk>is_final (steps0 (Suc 0, [], <code_tcontra>) tcontra n);\n        (\\<lambda>tp.\n            \\<exists>k.\n               tp =\n               (Bk \\<up> k,\n                <Suc 0>)) holds_for steps0 (Suc 0, [], <code_tcontra>)\n                                     tcontra n;\n        is_final\n         (steps0 (Suc 0, [], <[code_tcontra]>) tcontra n) \\<longrightarrow>\n        \\<not> (\\<lambda>tp.\n                   \\<exists>k n l.\n                      tp =\n                      (Bk \\<up> k,\n                       <n> @\n                       Bk \\<up> l)) holds_for steps0\n         (Suc 0, [], <[code_tcontra]>) tcontra n;\n        steps0 (Suc 0, [], <code_tcontra>) tcontra n = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(auto simp add: tape_of_list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       \\<lbrakk>\\<forall>n l. <Suc 0> \\<noteq> <n> @ Bk \\<up> l;\n        steps0 (Suc 0, [], <code_tcontra>) tcontra n =\n        (0, Bk \\<up> k, <Suc 0>)\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis append_Nil2 replicate_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(* asumme tcontra halts on its code *)"], ["", "lemma tcontra_halt: \n  assumes \"halts tcontra [code tcontra]\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "(* invariants *)"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define P1 where \"P1 \\<equiv> \\<lambda>tp. tp = ([]::cell list, <code_tcontra>)\""], ["proof (state)\nthis:\n  P1 \\<equiv> \\<lambda>tp. tp = ([], <code_tcontra>)\n\ngoal (1 subgoal):\n 1. False", "define P2 where \"P2 \\<equiv> \\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)\""], ["proof (state)\nthis:\n  P2 \\<equiv> \\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)\n\ngoal (1 subgoal):\n 1. False", "define Q3 where \"Q3 \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0::nat>)\""], ["proof (state)\nthis:\n  Q3 \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)\n\ngoal (1 subgoal):\n 1. False", "(*\n  {P1} tcopy {P2}  {P2} H {Q3} \n  ----------------------------\n     {P1} (tcopy |+| H) {Q3}     {Q3} dither loops\n  ------------------------------------------------\n               {P1} tcontra loops\n  *)"], ["proof (state)\nthis:\n  Q3 \\<equiv> \\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)\n\ngoal (1 subgoal):\n 1. False", "have H_wf: \"tm_wf0 (tcopy |+| H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm_wf0 (tcopy |+| H)", "by auto"], ["proof (state)\nthis:\n  tm_wf0 (tcopy |+| H)\n\ngoal (1 subgoal):\n 1. False", "(* {P1} (tcopy |+| H) {Q3} *)"], ["proof (state)\nthis:\n  tm_wf0 (tcopy |+| H)\n\ngoal (1 subgoal):\n 1. False", "have first: \"{P1} (tcopy |+| H) {Q3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcopy |+| H {Q3}", "proof (cases rule: Hoare_plus_halt)"], ["proof (state)\ngoal (3 subgoals):\n 1. {P1} tcopy {?Q}\n 2. {?Q} H {Q3}\n 3. tm_wf0 tcopy", "case A_halt"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. {P1} tcopy {?Q}\n 2. {?Q} H {Q3}\n 3. tm_wf0 tcopy", "(* of tcopy *)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. {P1} tcopy {?Q}\n 2. {?Q} H {Q3}\n 3. tm_wf0 tcopy", "show \"{P1} tcopy {P2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcopy {P2}", "unfolding P1_def P2_def tape_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([], Oc \\<up> Suc code_tcontra)} tcopy\n    {\\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)}", "by (rule tcopy_correct)"], ["proof (state)\nthis:\n  {P1} tcopy {P2}\n\ngoal (2 subgoals):\n 1. {P2} H {Q3}\n 2. tm_wf0 tcopy", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {P2} H {Q3}\n 2. tm_wf0 tcopy", "case B_halt"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {P2} H {Q3}\n 2. tm_wf0 tcopy", "(* of H *)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {P2} H {Q3}\n 2. tm_wf0 tcopy", "then"], ["proof (chain)\npicking this:", "show \"{P2} H {Q3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P2} H {Q3}", "unfolding P2_def Q3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)}", "using H_unhalt_inv[OF assms]"], ["proof (prove)\nusing this:\n  {\\<lambda>tp. tp = ([Bk], <(code_tcontra, [code_tcontra])>)} H\n  {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)}\n\ngoal (1 subgoal):\n 1. {\\<lambda>tp. tp = ([Bk], <(code_tcontra, code_tcontra)>)} H\n    {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)}", "by(simp add: tape_of_prod_def tape_of_list_def)"], ["proof (state)\nthis:\n  {P2} H {Q3}\n\ngoal (1 subgoal):\n 1. tm_wf0 tcopy", "qed (simp)"], ["proof (state)\nthis:\n  {P1} tcopy |+| H {Q3}\n\ngoal (1 subgoal):\n 1. False", "(* {P3} dither loops *)"], ["proof (state)\nthis:\n  {P1} tcopy |+| H {Q3}\n\ngoal (1 subgoal):\n 1. False", "have second: \"{Q3} dither \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Q3} dither \\<up>", "unfolding Q3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<lambda>tp. \\<exists>k. tp = (Bk \\<up> k, <0>)} dither \\<up>", "by (rule dither_loops)"], ["proof (state)\nthis:\n  {Q3} dither \\<up>\n\ngoal (1 subgoal):\n 1. False", "(* {P1} tcontra loops *)"], ["proof (state)\nthis:\n  {Q3} dither \\<up>\n\ngoal (1 subgoal):\n 1. False", "have \"{P1} tcontra \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcontra \\<up>", "unfolding tcontra_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {P1} tcopy |+| H |+| dither \\<up>", "by (rule Hoare_plus_unhalt[OF first second H_wf])"], ["proof (state)\nthis:\n  {P1} tcontra \\<up>\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  halts tcontra [code_tcontra]\n  {P1} tcontra \\<up>", "show \"False\""], ["proof (prove)\nusing this:\n  halts tcontra [code_tcontra]\n  {P1} tcontra \\<up>\n\ngoal (1 subgoal):\n 1. False", "unfolding P1_def"], ["proof (prove)\nusing this:\n  halts tcontra [code_tcontra]\n  {\\<lambda>tp. tp = ([], <code_tcontra>)} tcontra \\<up>\n\ngoal (1 subgoal):\n 1. False", "unfolding halts_def"], ["proof (prove)\nusing this:\n  {\\<lambda>tp. tp = ([], <[code_tcontra]>)} tcontra\n  {\\<lambda>tp. \\<exists>k n l. tp = (Bk \\<up> k, <n> @ Bk \\<up> l)}\n  {\\<lambda>tp. tp = ([], <code_tcontra>)} tcontra \\<up>\n\ngoal (1 subgoal):\n 1. False", "unfolding Hoare_halt_def Hoare_unhalt_def"], ["proof (prove)\nusing this:\n  \\<forall>tp.\n     tp = ([], <[code_tcontra]>) \\<longrightarrow>\n     (\\<exists>n.\n         is_final (steps0 (1, tp) tcontra n) \\<and>\n         (\\<lambda>tp.\n             \\<exists>k n l.\n                tp =\n                (Bk \\<up> k,\n                 <n> @ Bk \\<up> l)) holds_for steps0 (1, tp) tcontra n)\n  \\<forall>tp.\n     tp = ([], <code_tcontra>) \\<longrightarrow>\n     (\\<forall>n. \\<not> is_final (steps0 (1, tp) tcontra n))\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: tape_of_list_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  \\<open>False\\<close> can finally derived.\n\\<close>"], ["", "lemma false: \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using tcontra_halt tcontra_unhalt"], ["proof (prove)\nusing this:\n  halts tcontra [code_tcontra] \\<Longrightarrow> False\n  \\<not> halts tcontra [code_tcontra] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["", "end"], ["", "declare replicate_Suc[simp del]"], ["", "end"]]}