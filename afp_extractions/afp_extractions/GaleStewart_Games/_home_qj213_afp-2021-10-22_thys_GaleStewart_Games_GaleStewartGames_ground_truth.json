{"file_name": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games/GaleStewartGames.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games", "problem_names": ["lemma position_maxlength_cannotbe_augmented:\nassumes \"length p = 2*N\"\nshows \"\\<not> position (p @ [m])\"", "lemma plays_are_positions_conv:\n  shows \"play (llist_of p) \\<longleftrightarrow> position p \\<and> length p = 2*N\"", "lemma finite_plays_are_positions:\n  assumes \"play p\" \"lfinite p\"\n  shows \"position (list_of p)\"", "lemma induced_play_infinite:\n  \"\\<not> lfinite (strategy_progression \\<sigma> p)\"", "lemma plays_from_strategy_lengths[simp]:\n  \"length (strategy_progression \\<sigma> p $ i) = i\"", "lemma length_plays_from_strategy[simp]:\n  \"llength (strategy_progression \\<sigma> p) = \\<infinity>\"", "lemma length_ltl_plays_from_strategy[simp]:\n  \"llength (ltl (strategy_progression \\<sigma> p)) = \\<infinity>\"", "lemma plays_from_strategy_chain_Suc:\n  shows \"prefix (strategy_progression \\<sigma> p  $  n) (strategy_progression \\<sigma> p  $  Suc n)\"", "lemma plays_from_strategy_chain:\n  shows \"n \\<le> m \\<Longrightarrow> prefix (strategy_progression \\<sigma> p  $  n) (strategy_progression \\<sigma> p  $  m)\"", "lemma plays_from_strategy_remains_const:\n  assumes \"n \\<le> i\"\n  shows \"take n (strategy_progression \\<sigma> p  $  i)  =  strategy_progression \\<sigma> p  $  n\"", "lemma infplays_augment_one[simp]:\n  \"strategy_progression \\<sigma> (p @ [\\<sigma> p]) = strategy_progression \\<sigma> p\"", "lemma infplays_augment_many[simp]:\n  \"strategy_progression \\<sigma> ((augment_list \\<sigma> ^^ n) p) = strategy_progression \\<sigma> p\"", "lemma infplays_augment_one_joint[simp]:\n  \"even (length p) \\<Longrightarrow> strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) (augment_list \\<sigma>\\<^sub>e p)\n                     = strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\"\n  \"odd (length p)  \\<Longrightarrow> strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) (augment_list \\<sigma>\\<^sub>o p)\n                     = strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\"", "lemma infplays_eq:\n  assumes \"\\<And> p'. prefix p p' \\<Longrightarrow> augment_list s1 p' = augment_list s2 p'\"\n  shows \"strategy_progression s1 p = strategy_progression s2 p\"", "lemma induced_play_infinite_le[simp]:\n  \"enat x < llength (strategy_progression \\<sigma> p)\"\n  \"enat x < llength (lmap f (strategy_progression \\<sigma> p))\"\n  \"enat x < llength (ltake (2*N) (lmap f (strategy_progression \\<sigma> p))) \\<longleftrightarrow> x < 2*N\"", "lemma induced_play_is_lprefix:\n  assumes \"position p\"\n  shows \"lprefix (llist_of p) (induced_play \\<sigma> p)\"", "lemma length_induced_play[simp]:\n  \"llength (induced_play s p) = 2 * N\"", "lemma induced_play_lprefix_non_positions: (* 'opposite' of induced_play_is_lprefix *)\n  assumes \"length (p::'a list) \\<ge> 2 * N\"\n  shows \"induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\"", "lemma infplays_augment_many_lprefix[simp]:\n  shows \"lprefix (llist_of ((augment_list \\<sigma> ^^ n) p)) (induced_play \\<sigma> p)\n        = position ((augment_list \\<sigma> ^^ n) p)\" (is \"?lhs = ?rhs\")", "lemma at_most_one_player_winning:\nshows \"\\<not> (\\<exists> \\<sigma>\\<^sub>e. strategy_winning_by_Even \\<sigma>\\<^sub>e p) \\<or> \\<not> (\\<exists> \\<sigma>\\<^sub>o. strategy_winning_by_Odd \\<sigma>\\<^sub>o p)\"", "lemma any_moves_remain_winning_Even:\n  assumes \"odd (length p)\" \"strategy_winning_by_Even \\<sigma> p\"\n  shows \"strategy_winning_by_Even \\<sigma> (p @ [m])\"", "lemma any_moves_remain_winning_Odd:\n  assumes \"even (length p)\" \"strategy_winning_by_Odd \\<sigma> p\"\n  shows \"strategy_winning_by_Odd \\<sigma> (p @ [m])\"", "lemma non_winning_moves_remains_non_winning_Even:\n  assumes \"even (length p)\" \"\\<forall> \\<sigma>. \\<not> strategy_winning_by_Even \\<sigma> p\"\n  shows \"\\<not> strategy_winning_by_Even \\<sigma> (p @ [m])\"", "lemma non_winning_moves_remains_non_winning_Odd:\n  assumes \"odd (length p)\" \"\\<forall> \\<sigma>. \\<not> strategy_winning_by_Odd \\<sigma> p\"\n  shows \"\\<not> strategy_winning_by_Odd \\<sigma> (p @ [m])\"", "lemma winning_moves_remain_winning_Even:\n  assumes \"even (length p)\" \"strategy_winning_by_Even \\<sigma> p\"\n  shows \"strategy_winning_by_Even \\<sigma> (p @ [\\<sigma> p])\"", "lemma winning_moves_remain_winning_Odd:\n  assumes \"odd (length p)\" \"strategy_winning_by_Odd \\<sigma> p\"\n  shows \"strategy_winning_by_Odd \\<sigma> (p @ [\\<sigma> p])\"", "lemma winning_position_can_remain_winning_Even:\n  assumes \"even (length p)\" \"\\<forall> m. position (p @ [m])\" \"winning_position_Even p\"\n  shows \"\\<exists> m. winning_position_Even (p @ [m])\"", "lemma winning_position_can_remain_winning_Odd:\n  assumes \"odd (length p)\" \"\\<forall> m. position (p @ [m])\" \"winning_position_Odd p\"\n  shows \"\\<exists> m. winning_position_Odd (p @ [m])\"", "lemma winning_position_will_remain_winning_Even:\n  assumes \"odd (length p)\" \"position (p @ [m])\" \"winning_position_Even p\"\n  shows \"winning_position_Even (p @ [m])\"", "lemma winning_position_will_remain_winning_Odd:\n  assumes \"even (length p)\" \"position (p @ [m])\" \"winning_position_Odd p\"\n  shows \"winning_position_Odd (p @ [m])\"", "lemma induced_play_eq:\nassumes \"\\<forall> p'. prefix p p' \\<longrightarrow> (augment_list s1) p' = (augment_list s2) p'\"\nshows \"induced_play s1 p = induced_play s2 p\""], "translations": [["", "lemma position_maxlength_cannotbe_augmented:\nassumes \"length p = 2*N\"\nshows \"\\<not> position (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> position (p @ [m])", "by (auto simp:position_def assms[symmetric])"], ["", "text \\<open>A play is a sequence of valid moves of the right length.\\<close>"], ["", "definition \"play\" where\n  \"play (e::'a llist) \\<equiv> llength e = 2*N\""], ["", "lemma plays_are_positions_conv:\n  shows \"play (llist_of p) \\<longleftrightarrow> position p \\<and> length p = 2*N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. play (llist_of p) = (position p \\<and> enat (length p) = 2 * N)", "unfolding play_def position_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (llength (llist_of p) = 2 * N) =\n    (enat (length p) \\<le> 2 * N \\<and> enat (length p) = 2 * N)", "by auto"], ["", "lemma finite_plays_are_positions:\n  assumes \"play p\" \"lfinite p\"\n  shows \"position (list_of p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. position (list_of p)", "using assms"], ["proof (prove)\nusing this:\n  play p\n  lfinite p\n\ngoal (1 subgoal):\n 1. position (list_of p)", "unfolding play_def position_def"], ["proof (prove)\nusing this:\n  llength p = 2 * N\n  lfinite p\n\ngoal (1 subgoal):\n 1. enat (length (list_of p)) \\<le> 2 * N", "by (cases \"lfinite p\";auto simp:length_list_of)"], ["", "end"], ["", "text \\<open>We call our players Even and Odd, where Even makes the first move.\n      This means that Even is to make moves on plays of even length, and Odd on the others.\n      This corresponds nicely to Even making all the moves in an even position, as\n      the `nth' and `lnth' functions as predefined in Isabelle's library count from 0.\n      In literature the players are sometimes called I and II.\\<close>"], ["", "text \\<open>A strategy for Even/Odd is simply a function that takes a position of even/odd length and\n      returns a move. We use total functions for strategies. This means that their Isabelle-type\n      determines that it is a strategy. Consequently, we do not have a definition of 'strategy'.\n      Nevertheless, we will use $\\sigma$ as a letter to indicate when something is a strategy.\n      We can combine two strategies into one function, which gives a collective strategy that\n      we will refer to as the joint strategy.\\<close>"], ["", "definition joint_strategy  :: \"('b list \\<Rightarrow> 'a) \\<Rightarrow> ('b list \\<Rightarrow> 'a) \\<Rightarrow> ('b list \\<Rightarrow> 'a)\" where\n  \"joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o p = (if even (length p) then \\<sigma>\\<^sub>e p else \\<sigma>\\<^sub>o p)\""], ["", "text \\<open>Following a strategy leads to an infinite sequence of moves.\n      Note that we are not in the context of 'GSGame' where 'N' determines the length of our plays:\n      we just let sequences go on ad infinitum here.\n      Rather than reasoning about our own recursive definitions,\n      we build this infinite sequence by reusing definitions that are already in place.\n      We do this by first defining all prefixes of the infinite sequence we are interested in.\n      This gives an infinite list such that the nth element is of length n.\n      Note that this definition allows us to talk about how a strategy would continue if it were\n      played from an arbitrary position (not necessarily one that is reached via that strategy). \\<close>"], ["", "definition strategy_progression where\n  \"strategy_progression \\<sigma> p = lappend (llist_of (prefixes p)) (ltl (iterates (augment_list \\<sigma>) p))\""], ["", "lemma induced_play_infinite:\n  \"\\<not> lfinite (strategy_progression \\<sigma> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite (strategy_progression \\<sigma> p)", "unfolding strategy_progression_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite\n            (lappend (llist_of (prefixes p))\n              (ltl (iterates (augment_list \\<sigma>) p)))", "by auto"], ["", "lemma plays_from_strategy_lengths[simp]:\n  \"length (strategy_progression \\<sigma> p $ i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strategy_progression \\<sigma> p $ i) = i", "proof(induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (strategy_progression \\<sigma> p $ 0) = 0\n 2. \\<And>i.\n       length (strategy_progression \\<sigma> p $ i) = i \\<Longrightarrow>\n       length (strategy_progression \\<sigma> p $ Suc i) = Suc i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (strategy_progression \\<sigma> p $ 0) = 0\n 2. \\<And>i.\n       length (strategy_progression \\<sigma> p $ i) = i \\<Longrightarrow>\n       length (strategy_progression \\<sigma> p $ Suc i) = Suc i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (strategy_progression \\<sigma> p $ 0) = 0", "by(cases p;auto simp:strategy_progression_def lnth_lappend take_map ltake_lappend)"], ["proof (state)\nthis:\n  length (strategy_progression \\<sigma> p $ 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       length (strategy_progression \\<sigma> p $ i) = i \\<Longrightarrow>\n       length (strategy_progression \\<sigma> p $ Suc i) = Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       length (strategy_progression \\<sigma> p $ i) = i \\<Longrightarrow>\n       length (strategy_progression \\<sigma> p $ Suc i) = Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  length (strategy_progression \\<sigma> p $ i) = i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       length (strategy_progression \\<sigma> p $ i) = i \\<Longrightarrow>\n       length (strategy_progression \\<sigma> p $ Suc i) = Suc i", "then"], ["proof (chain)\npicking this:\n  length (strategy_progression \\<sigma> p $ i) = i", "show ?case"], ["proof (prove)\nusing this:\n  length (strategy_progression \\<sigma> p $ i) = i\n\ngoal (1 subgoal):\n 1. length (strategy_progression \\<sigma> p $ Suc i) = Suc i", "by (cases \"i<length p\") (auto simp:strategy_progression_def lnth_lappend length_augment_list tl_prefixes_idx)"], ["proof (state)\nthis:\n  length (strategy_progression \\<sigma> p $ Suc i) = Suc i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_plays_from_strategy[simp]:\n  \"llength (strategy_progression \\<sigma> p) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (strategy_progression \\<sigma> p) = \\<infinity>", "unfolding strategy_progression_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (lappend (llist_of (prefixes p))\n       (ltl (iterates (augment_list \\<sigma>) p))) =\n    \\<infinity>", "by auto"], ["", "lemma length_ltl_plays_from_strategy[simp]:\n  \"llength (ltl (strategy_progression \\<sigma> p)) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltl (strategy_progression \\<sigma> p)) = \\<infinity>", "unfolding strategy_progression_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (ltl (lappend (llist_of (prefixes p))\n            (ltl (iterates (augment_list \\<sigma>) p)))) =\n    \\<infinity>", "by auto"], ["", "lemma plays_from_strategy_chain_Suc:\n  shows \"prefix (strategy_progression \\<sigma> p  $  n) (strategy_progression \\<sigma> p  $  Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (strategy_progression \\<sigma> p $ n)\n     (strategy_progression \\<sigma> p $ Suc n)", "unfolding strategy_progression_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\n     (lappend (llist_of (prefixes p))\n       (ltl (iterates (augment_list \\<sigma>) p)) $\n      n)\n     (lappend (llist_of (prefixes p))\n       (ltl (iterates (augment_list \\<sigma>) p)) $\n      Suc n)", "by (auto simp:take_Suc_prefix nth_prefixes lnth_lappend nth_prefixes_is_prefix_tl\n                augment_list_prefix)"], ["", "lemma plays_from_strategy_chain:\n  shows \"n \\<le> m \\<Longrightarrow> prefix (strategy_progression \\<sigma> p  $  n) (strategy_progression \\<sigma> p  $  m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    prefix (strategy_progression \\<sigma> p $ n)\n     (strategy_progression \\<sigma> p $ m)", "proof (induct \"m-n\" arbitrary:m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)\n 2. \\<And>x m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>x = m - n; n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> prefix\n(strategy_progression \\<sigma> p $ n) (strategy_progression \\<sigma> p $ m);\n        Suc x = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?m - ?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ ?n)\n                     (strategy_progression \\<sigma> p $ ?m)\n  Suc x = m - n\n  n \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)\n 2. \\<And>x m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>x = m - n; n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> prefix\n(strategy_progression \\<sigma> p $ n) (strategy_progression \\<sigma> p $ m);\n        Suc x = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)", "hence [simp]:\"Suc (x + n) = m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?m - ?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ ?n)\n                     (strategy_progression \\<sigma> p $ ?m)\n  Suc x = m - n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. Suc (x + n) = m", "by auto"], ["proof (state)\nthis:\n  Suc (x + n) = m\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)\n 2. \\<And>x m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>x = m - n; n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> prefix\n(strategy_progression \\<sigma> p $ n) (strategy_progression \\<sigma> p $ m);\n        Suc x = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)", "from Suc.hyps(2) \n    prefix_order.order.trans[OF Suc.hyps(1)[of \"x + n\" n] plays_from_strategy_chain_Suc[of _ _ \"x+n\"]]"], ["proof (chain)\npicking this:\n  Suc x = m - n\n  \\<lbrakk>x = x + n - n; n \\<le> x + n\\<rbrakk>\n  \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                     (strategy_progression \\<sigma> p $ Suc (x + n))", "show ?case"], ["proof (prove)\nusing this:\n  Suc x = m - n\n  \\<lbrakk>x = x + n - n; n \\<le> x + n\\<rbrakk>\n  \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                     (strategy_progression \\<sigma> p $ Suc (x + n))\n\ngoal (1 subgoal):\n 1. prefix (strategy_progression \\<sigma> p $ n)\n     (strategy_progression \\<sigma> p $ m)", "by auto"], ["proof (state)\nthis:\n  prefix (strategy_progression \\<sigma> p $ n)\n   (strategy_progression \\<sigma> p $ m)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix (strategy_progression \\<sigma> p $ n)\n                          (strategy_progression \\<sigma> p $ m)", "qed auto"], ["", "lemma plays_from_strategy_remains_const:\n  assumes \"n \\<le> i\"\n  shows \"take n (strategy_progression \\<sigma> p  $  i)  =  strategy_progression \\<sigma> p  $  n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n (strategy_progression \\<sigma> p $ i) =\n    strategy_progression \\<sigma> p $ n", "apply(rule sym,subst prefix_same_length_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (strategy_progression \\<sigma> p $ n)\n     (take n (strategy_progression \\<sigma> p $ i)) \\<and>\n    length (strategy_progression \\<sigma> p $ n) =\n    length (take n (strategy_progression \\<sigma> p $ i))", "using assms plays_from_strategy_chain[OF assms]"], ["proof (prove)\nusing this:\n  n \\<le> i\n  prefix (strategy_progression ?\\<sigma> ?p $ n)\n   (strategy_progression ?\\<sigma> ?p $ i)\n\ngoal (1 subgoal):\n 1. prefix (strategy_progression \\<sigma> p $ n)\n     (take n (strategy_progression \\<sigma> p $ i)) \\<and>\n    length (strategy_progression \\<sigma> p $ n) =\n    length (take n (strategy_progression \\<sigma> p $ i))", "by (auto intro!:prefix_takeI)"], ["", "lemma infplays_augment_one[simp]:\n  \"strategy_progression \\<sigma> (p @ [\\<sigma> p]) = strategy_progression \\<sigma> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n    strategy_progression \\<sigma> p", "proof(induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> []) =\n    strategy_progression \\<sigma> []\n 2. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "note defs = strategy_progression_def"], ["proof (state)\nthis:\n  strategy_progression ?\\<sigma> ?p =\n  lappend (llist_of (prefixes ?p))\n   (ltl (iterates (augment_list ?\\<sigma>) ?p))\n\ngoal (2 subgoals):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> []) =\n    strategy_progression \\<sigma> []\n 2. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "{"], ["proof (state)\nthis:\n  strategy_progression ?\\<sigma> ?p =\n  lappend (llist_of (prefixes ?p))\n   (ltl (iterates (augment_list ?\\<sigma>) ?p))\n\ngoal (2 subgoals):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> []) =\n    strategy_progression \\<sigma> []\n 2. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> []) =\n    strategy_progression \\<sigma> []\n 2. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> []) =\n    strategy_progression \\<sigma> []", "by (auto simp:defs iterates.code[of _ \"[\\<sigma> []]\"])"], ["proof (state)\nthis:\n  strategy_progression \\<sigma> (augment_list \\<sigma> []) =\n  strategy_progression \\<sigma> []\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "case (Cons a p)"], ["proof (state)\nthis:\n  strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n  strategy_progression \\<sigma> p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n       strategy_progression \\<sigma> p \\<Longrightarrow>\n       strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n       strategy_progression \\<sigma> (a # p)", "then"], ["proof (chain)\npicking this:\n  strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n  strategy_progression \\<sigma> p", "show ?case"], ["proof (prove)\nusing this:\n  strategy_progression \\<sigma> (augment_list \\<sigma> p) =\n  strategy_progression \\<sigma> p\n\ngoal (1 subgoal):\n 1. strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n    strategy_progression \\<sigma> (a # p)", "by (auto simp:defs iterates.code[of _ \"a # p @ [\\<sigma> (a # p)]\"] lappend_llist_of_LCons)"], ["proof (state)\nthis:\n  strategy_progression \\<sigma> (augment_list \\<sigma> (a # p)) =\n  strategy_progression \\<sigma> (a # p)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  strategy_progression \\<sigma> (augment_list \\<sigma> ?pa2) =\n  strategy_progression \\<sigma> ?pa2 \\<Longrightarrow>\n  strategy_progression \\<sigma> (augment_list \\<sigma> (?a2 # ?pa2)) =\n  strategy_progression \\<sigma> (?a2 # ?pa2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infplays_augment_many[simp]:\n  \"strategy_progression \\<sigma> ((augment_list \\<sigma> ^^ n) p) = strategy_progression \\<sigma> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_progression \\<sigma> ((augment_list \\<sigma> ^^ n) p) =\n    strategy_progression \\<sigma> p", "by(induct n,auto)"], ["", "lemma infplays_augment_one_joint[simp]:\n  \"even (length p) \\<Longrightarrow> strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) (augment_list \\<sigma>\\<^sub>e p)\n                     = strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\"\n  \"odd (length p)  \\<Longrightarrow> strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) (augment_list \\<sigma>\\<^sub>o p)\n                     = strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (even (length p) \\<Longrightarrow>\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      (augment_list \\<sigma>\\<^sub>e p) =\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      p) &&&\n    (odd (length p) \\<Longrightarrow>\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      (augment_list \\<sigma>\\<^sub>o p) =\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      p)", "using infplays_augment_one[of \"joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o\" p]"], ["proof (prove)\nusing this:\n  strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n   (augment_list (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p) =\n  strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\n\ngoal (1 subgoal):\n 1. (even (length p) \\<Longrightarrow>\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      (augment_list \\<sigma>\\<^sub>e p) =\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      p) &&&\n    (odd (length p) \\<Longrightarrow>\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      (augment_list \\<sigma>\\<^sub>o p) =\n     strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o)\n      p)", "unfolding joint_strategy_def"], ["proof (prove)\nusing this:\n  strategy_progression\n   (\\<lambda>p.\n       if even (length p) then \\<sigma>\\<^sub>e p else \\<sigma>\\<^sub>o p)\n   (p @\n    [if even (length p) then \\<sigma>\\<^sub>e p else \\<sigma>\\<^sub>o p]) =\n  strategy_progression\n   (\\<lambda>p.\n       if even (length p) then \\<sigma>\\<^sub>e p else \\<sigma>\\<^sub>o p)\n   p\n\ngoal (1 subgoal):\n 1. (even (length p) \\<Longrightarrow>\n     strategy_progression\n      (\\<lambda>p.\n          if even (length p) then \\<sigma>\\<^sub>e p\n          else \\<sigma>\\<^sub>o p)\n      (augment_list \\<sigma>\\<^sub>e p) =\n     strategy_progression\n      (\\<lambda>p.\n          if even (length p) then \\<sigma>\\<^sub>e p\n          else \\<sigma>\\<^sub>o p)\n      p) &&&\n    (odd (length p) \\<Longrightarrow>\n     strategy_progression\n      (\\<lambda>p.\n          if even (length p) then \\<sigma>\\<^sub>e p\n          else \\<sigma>\\<^sub>o p)\n      (augment_list \\<sigma>\\<^sub>o p) =\n     strategy_progression\n      (\\<lambda>p.\n          if even (length p) then \\<sigma>\\<^sub>e p\n          else \\<sigma>\\<^sub>o p)\n      p)", "by auto"], ["", "text \\<open>Following two different strategies from a single position will lead to the same plays\n      if the strategies agree on moves played after that position.\n      This lemma allows us to ignore the behavior of strategies for moves that are already played. \\<close>"], ["", "lemma infplays_eq:\n  assumes \"\\<And> p'. prefix p p' \\<Longrightarrow> augment_list s1 p' = augment_list s2 p'\"\n  shows \"strategy_progression s1 p = strategy_progression s2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_progression s1 p = strategy_progression s2 p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. strategy_progression s1 p = strategy_progression s2 p", "from assms[of p]"], ["proof (chain)\npicking this:\n  prefix p p \\<Longrightarrow> augment_list s1 p = augment_list s2 p", "have [intro]:\"s1 p = s2 p\""], ["proof (prove)\nusing this:\n  prefix p p \\<Longrightarrow> augment_list s1 p = augment_list s2 p\n\ngoal (1 subgoal):\n 1. s1 p = s2 p", "by auto"], ["proof (state)\nthis:\n  s1 p = s2 p\n\ngoal (1 subgoal):\n 1. strategy_progression s1 p = strategy_progression s2 p", "have \"(augment_list s1 ^^ n) (augment_list s1 p) =\n          (augment_list s2 ^^ n) (augment_list s2 p)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (augment_list s1 ^^ n) (augment_list s1 p) =\n    (augment_list s2 ^^ n) (augment_list s2 p)", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (augment_list s1 ^^ 0) (augment_list s1 p) =\n    (augment_list s2 ^^ 0) (augment_list s2 p)\n 2. \\<And>n.\n       (augment_list s1 ^^ n) (augment_list s1 p) =\n       (augment_list s2 ^^ n) (augment_list s2 p) \\<Longrightarrow>\n       (augment_list s1 ^^ Suc n) (augment_list s1 p) =\n       (augment_list s2 ^^ Suc n) (augment_list s2 p)", "case (Suc n)"], ["proof (state)\nthis:\n  (augment_list s1 ^^ n) (augment_list s1 p) =\n  (augment_list s2 ^^ n) (augment_list s2 p)\n\ngoal (2 subgoals):\n 1. (augment_list s1 ^^ 0) (augment_list s1 p) =\n    (augment_list s2 ^^ 0) (augment_list s2 p)\n 2. \\<And>n.\n       (augment_list s1 ^^ n) (augment_list s1 p) =\n       (augment_list s2 ^^ n) (augment_list s2 p) \\<Longrightarrow>\n       (augment_list s1 ^^ Suc n) (augment_list s1 p) =\n       (augment_list s2 ^^ Suc n) (augment_list s2 p)", "with assms[OF prefix_order.order.trans[OF _ prefix_augment]]"], ["proof (chain)\npicking this:\n  prefix p ?b1 \\<Longrightarrow>\n  augment_list s1 ((augment_list ?s2 ^^ ?n2) ?b1) =\n  augment_list s2 ((augment_list ?s2 ^^ ?n2) ?b1)\n  (augment_list s1 ^^ n) (augment_list s1 p) =\n  (augment_list s2 ^^ n) (augment_list s2 p)", "show ?case"], ["proof (prove)\nusing this:\n  prefix p ?b1 \\<Longrightarrow>\n  augment_list s1 ((augment_list ?s2 ^^ ?n2) ?b1) =\n  augment_list s2 ((augment_list ?s2 ^^ ?n2) ?b1)\n  (augment_list s1 ^^ n) (augment_list s1 p) =\n  (augment_list s2 ^^ n) (augment_list s2 p)\n\ngoal (1 subgoal):\n 1. (augment_list s1 ^^ Suc n) (augment_list s1 p) =\n    (augment_list s2 ^^ Suc n) (augment_list s2 p)", "by (auto)"], ["proof (state)\nthis:\n  (augment_list s1 ^^ Suc n) (augment_list s1 p) =\n  (augment_list s2 ^^ Suc n) (augment_list s2 p)\n\ngoal (1 subgoal):\n 1. (augment_list s1 ^^ 0) (augment_list s1 p) =\n    (augment_list s2 ^^ 0) (augment_list s2 p)", "qed auto"], ["proof (state)\nthis:\n  (augment_list s1 ^^ ?n) (augment_list s1 p) =\n  (augment_list s2 ^^ ?n) (augment_list s2 p)\n\ngoal (1 subgoal):\n 1. strategy_progression s1 p = strategy_progression s2 p", "hence \"strategy_progression s1 p $ n = strategy_progression s2 p $ n\"\n    for n"], ["proof (prove)\nusing this:\n  (augment_list s1 ^^ ?n) (augment_list s1 p) =\n  (augment_list s2 ^^ ?n) (augment_list s2 p)\n\ngoal (1 subgoal):\n 1. strategy_progression s1 p $ n = strategy_progression s2 p $ n", "(* different n *)"], ["proof (prove)\nusing this:\n  (augment_list s1 ^^ ?n) (augment_list s1 p) =\n  (augment_list s2 ^^ ?n) (augment_list s2 p)\n\ngoal (1 subgoal):\n 1. strategy_progression s1 p $ n = strategy_progression s2 p $ n", "unfolding strategy_progression_def lnth_lappend"], ["proof (prove)\nusing this:\n  (augment_list s1 ^^ ?n) (augment_list s1 p) =\n  (augment_list s2 ^^ ?n) (augment_list s2 p)\n\ngoal (1 subgoal):\n 1. (if enat n < llength (llist_of (prefixes p))\n     then llist_of (prefixes p) $ n\n     else ltl (iterates (augment_list s1) p) $\n          n - the_enat (llength (llist_of (prefixes p)))) =\n    (if enat n < llength (llist_of (prefixes p))\n     then llist_of (prefixes p) $ n\n     else ltl (iterates (augment_list s2) p) $\n          n - the_enat (llength (llist_of (prefixes p))))", "by auto"], ["proof (state)\nthis:\n  strategy_progression s1 p $ ?n = strategy_progression s2 p $ ?n\n\ngoal (1 subgoal):\n 1. strategy_progression s1 p = strategy_progression s2 p", "thus ?thesis"], ["proof (prove)\nusing this:\n  strategy_progression s1 p $ ?n = strategy_progression s2 p $ ?n\n\ngoal (1 subgoal):\n 1. strategy_progression s1 p = strategy_progression s2 p", "by(intro coinductive_eq_I,auto)"], ["proof (state)\nthis:\n  strategy_progression s1 p = strategy_progression s2 p\n\ngoal:\nNo subgoals!", "qed"], ["", "context GSgame\nbegin"], ["", "text \\<open>By looking at the last elements of the infinite progression,\n      we can get a single sequence, which we trim down to the right length.\n      Since it has the right length, this always forms a play.\n      We therefore name this the 'induced play'. \\<close>"], ["", "definition induced_play where\n  \"induced_play \\<sigma> \\<equiv> ltake (2*N) o lmap last o ltl o strategy_progression \\<sigma>\""], ["", "lemma induced_play_infinite_le[simp]:\n  \"enat x < llength (strategy_progression \\<sigma> p)\"\n  \"enat x < llength (lmap f (strategy_progression \\<sigma> p))\"\n  \"enat x < llength (ltake (2*N) (lmap f (strategy_progression \\<sigma> p))) \\<longleftrightarrow> x < 2*N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat x < llength (strategy_progression \\<sigma> p) &&&\n    enat x < llength (lmap f (strategy_progression \\<sigma> p)) &&&\n    (enat x\n     < llength (ltake (2 * N) (lmap f (strategy_progression \\<sigma> p)))) =\n    (enat x < 2 * N)", "using induced_play_infinite"], ["proof (prove)\nusing this:\n  \\<not> lfinite (strategy_progression ?\\<sigma> ?p)\n\ngoal (1 subgoal):\n 1. enat x < llength (strategy_progression \\<sigma> p) &&&\n    enat x < llength (lmap f (strategy_progression \\<sigma> p)) &&&\n    (enat x\n     < llength (ltake (2 * N) (lmap f (strategy_progression \\<sigma> p)))) =\n    (enat x < 2 * N)", "by auto"], ["", "lemma induced_play_is_lprefix:\n  assumes \"position p\"\n  shows \"lprefix (llist_of p) (induced_play \\<sigma> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (induced_play \\<sigma> p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (induced_play \\<sigma> p)", "have l:\"llength (llist_of p) \\<le> 2 * N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (llist_of p) \\<le> 2 * N", "using assms"], ["proof (prove)\nusing this:\n  position p\n\ngoal (1 subgoal):\n 1. llength (llist_of p) \\<le> 2 * N", "unfolding position_def"], ["proof (prove)\nusing this:\n  enat (length p) \\<le> 2 * N\n\ngoal (1 subgoal):\n 1. llength (llist_of p) \\<le> 2 * N", "by auto"], ["proof (state)\nthis:\n  llength (llist_of p) \\<le> 2 * N\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (induced_play \\<sigma> p)", "have \"lprefix (llist_of p) (lmap last (ltl (llist_of (prefixes p))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (lmap last (ltl (llist_of (prefixes p))))", "by auto"], ["proof (state)\nthis:\n  lprefix (llist_of p) (lmap last (ltl (llist_of (prefixes p))))\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (induced_play \\<sigma> p)", "hence \"lprefix (llist_of p) ((lmap last o ltl o strategy_progression \\<sigma>) p)\""], ["proof (prove)\nusing this:\n  lprefix (llist_of p) (lmap last (ltl (llist_of (prefixes p))))\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p)\n     ((lmap last \\<circ> ltl \\<circ> strategy_progression \\<sigma>) p)", "unfolding strategy_progression_def"], ["proof (prove)\nusing this:\n  lprefix (llist_of p) (lmap last (ltl (llist_of (prefixes p))))\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p)\n     ((lmap last \\<circ> ltl \\<circ>\n       (\\<lambda>p.\n           lappend (llist_of (prefixes p))\n            (ltl (iterates (augment_list \\<sigma>) p))))\n       p)", "by(auto simp add: lmap_lappend_distrib lprefix_lappend)"], ["proof (state)\nthis:\n  lprefix (llist_of p)\n   ((lmap last \\<circ> ltl \\<circ> strategy_progression \\<sigma>) p)\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (induced_play \\<sigma> p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lprefix (llist_of p)\n   ((lmap last \\<circ> ltl \\<circ> strategy_progression \\<sigma>) p)\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p) (induced_play \\<sigma> p)", "unfolding induced_play_def o_def"], ["proof (prove)\nusing this:\n  lprefix (llist_of p) (lmap last (ltl (strategy_progression \\<sigma> p)))\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p)\n     (ltake (2 * N) (lmap last (ltl (strategy_progression \\<sigma> p))))", "using lprefix_ltakeI[OF _ l]"], ["proof (prove)\nusing this:\n  lprefix (llist_of p) (lmap last (ltl (strategy_progression \\<sigma> p)))\n  lprefix (llist_of p) ?b \\<Longrightarrow>\n  lprefix (llist_of p) (ltake (2 * N) ?b)\n\ngoal (1 subgoal):\n 1. lprefix (llist_of p)\n     (ltake (2 * N) (lmap last (ltl (strategy_progression \\<sigma> p))))", "by blast"], ["proof (state)\nthis:\n  lprefix (llist_of p) (induced_play \\<sigma> p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_induced_play[simp]:\n  \"llength (induced_play s p) = 2 * N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (induced_play s p) = 2 * N", "unfolding induced_play_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     ((ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n       strategy_progression s)\n       p) =\n    2 * N", "by auto"], ["", "lemma induced_play_lprefix_non_positions: (* 'opposite' of induced_play_is_lprefix *)\n  assumes \"length (p::'a list) \\<ge> 2 * N\"\n  shows \"induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "proof(cases \"N\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "case (enat nat)"], ["proof (state)\nthis:\n  N = enat nat\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "let ?p = \"take (2 * nat) p\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "from assms"], ["proof (chain)\npicking this:\n  2 * N \\<le> enat (length p)", "have [intro]:\"2 * N \\<le> enat (length p)\""], ["proof (prove)\nusing this:\n  2 * N \\<le> enat (length p)\n\ngoal (1 subgoal):\n 1. 2 * N \\<le> enat (length p)", "by auto"], ["proof (state)\nthis:\n  2 * N \\<le> enat (length p)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have [intro]:\"2 * N \\<le> enat (min (length p) (2 * nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * N \\<le> enat (min (length p) (2 * nat))", "unfolding enat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * enat nat \\<le> enat (min (length p) (2 * nat))", "by (metis assms enat min.orderI min_def numeral_eq_enat times_enat_simps(1))"], ["proof (state)\nthis:\n  2 * N \\<le> enat (min (length p) (2 * nat))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have [intro]:\"enat (min (length p) (2 * nat)) = 2 * N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (min (length p) (2 * nat)) = 2 * N", "by (metis (mono_tags, lifting) assms enat min.absorb2 min_enat_simps(1)\n        numeral_eq_enat times_enat_simps(1))"], ["proof (state)\nthis:\n  enat (min (length p) (2 * nat)) = 2 * N\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have n:\"2 * N \\<le> llength (llist_of p)\" \"2 * N \\<le> llength (llist_of (take (2 * nat) p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * N \\<le> llength (llist_of p) &&&\n    2 * N \\<le> llength (llist_of (take (2 * nat) p))", "by auto"], ["proof (state)\nthis:\n  2 * N \\<le> llength (llist_of p)\n  2 * N \\<le> llength (llist_of (take (2 * nat) p))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have pp:\"position ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. position (take (2 * nat) p)", "apply(subst position_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (length (take (2 * nat) p)) \\<le> 2 * N", "(* for some reason 'unfolding' does not work here, tested in Isabelle 2021 *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (length (take (2 * nat) p)) \\<le> 2 * N", "by (metis (no_types, lifting) assms dual_order.order_iff_strict enat llength_llist_of\n               llength_ltake' ltake_llist_of numeral_eq_enat take_all times_enat_simps(1))"], ["proof (state)\nthis:\n  position (take (2 * nat) p)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have lp:\"lprefix (llist_of ?p) (induced_play \\<sigma> ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (llist_of (take (2 * nat) p))\n     (induced_play \\<sigma> (take (2 * nat) p))", "by(rule induced_play_is_lprefix[OF pp])"], ["proof (state)\nthis:\n  lprefix (llist_of (take (2 * nat) p))\n   (induced_play \\<sigma> (take (2 * nat) p))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "(* this would make a great separate lemma, but we have a conversion between N and its nat\n     to make that more involved *)"], ["proof (state)\nthis:\n  lprefix (llist_of (take (2 * nat) p))\n   (induced_play \\<sigma> (take (2 * nat) p))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have \"ltake (2 * N) (llist_of p) = ltake (2 * N) (llist_of (take (2 * nat) p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (2 * N) (llist_of p) = ltake (2 * N) (llist_of (take (2 * nat) p))", "unfolding ltake_llist_of[symmetric] enat ltake_ltake numeral_eq_enat"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 2 * enat nat) (llist_of p) =\n    ltake (min (enat 2 * enat nat) (enat (2 * nat))) (llist_of p)", "by auto"], ["proof (state)\nthis:\n  ltake (2 * N) (llist_of p) = ltake (2 * N) (llist_of (take (2 * nat) p))\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "hence eq:\"induced_play \\<sigma> p = induced_play \\<sigma> ?p\""], ["proof (prove)\nusing this:\n  ltake (2 * N) (llist_of p) = ltake (2 * N) (llist_of (take (2 * nat) p))\n\ngoal (1 subgoal):\n 1. induced_play \\<sigma> p = induced_play \\<sigma> (take (2 * nat) p)", "unfolding induced_play_def strategy_progression_def"], ["proof (prove)\nusing this:\n  ltake (2 * N) (llist_of p) = ltake (2 * N) (llist_of (take (2 * nat) p))\n\ngoal (1 subgoal):\n 1. (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n     (\\<lambda>p.\n         lappend (llist_of (prefixes p))\n          (ltl (iterates (augment_list \\<sigma>) p))))\n     p =\n    (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n     (\\<lambda>p.\n         lappend (llist_of (prefixes p))\n          (ltl (iterates (augment_list \\<sigma>) p))))\n     (take (2 * nat) p)", "by(auto simp add: lmap_lappend_distrib n[THEN ltake_lappend1])"], ["proof (state)\nthis:\n  induced_play \\<sigma> p = induced_play \\<sigma> (take (2 * nat) p)\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "have \"llist_of (take (2 * nat) p) = induced_play \\<sigma> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llist_of (take (2 * nat) p) = induced_play \\<sigma> p", "by(rule lprefix_llength_eq_imp_eq[OF lp[folded eq]],auto)"], ["proof (state)\nthis:\n  llist_of (take (2 * nat) p) = induced_play \\<sigma> p\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       N = enat nat \\<Longrightarrow>\n       induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n 2. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "then"], ["proof (chain)\npicking this:\n  llist_of (take (2 * nat) p) = induced_play \\<sigma> p", "show ?thesis"], ["proof (prove)\nusing this:\n  llist_of (take (2 * nat) p) = induced_play \\<sigma> p\n\ngoal (1 subgoal):\n 1. induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "unfolding enat ltake_llist_of[symmetric] (* simp applies this one in the wrong direction *)\n               numeral_eq_enat times_enat_simps(1)"], ["proof (prove)\nusing this:\n  ltake (enat (2 * nat)) (llist_of p) =\n  GSgame.induced_play (enat nat) \\<sigma> p\n\ngoal (1 subgoal):\n 1. GSgame.induced_play (enat nat) \\<sigma> p =\n    ltake (enat (2 * nat)) (llist_of p)", "by metis"], ["proof (state)\nthis:\n  induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n\ngoal (1 subgoal):\n 1. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "case infinity"], ["proof (state)\nthis:\n  N = \\<infinity>\n\ngoal (1 subgoal):\n 1. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "hence \"2 * N = \\<infinity>\""], ["proof (prove)\nusing this:\n  N = \\<infinity>\n\ngoal (1 subgoal):\n 1. 2 * N = \\<infinity>", "by (simp add: imult_is_infinity)"], ["proof (state)\nthis:\n  2 * N = \\<infinity>\n\ngoal (1 subgoal):\n 1. N = \\<infinity> \\<Longrightarrow>\n    induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "then"], ["proof (chain)\npicking this:\n  2 * N = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * N = \\<infinity>\n\ngoal (1 subgoal):\n 1. induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "using assms"], ["proof (prove)\nusing this:\n  2 * N = \\<infinity>\n  2 * N \\<le> enat (length p)\n\ngoal (1 subgoal):\n 1. induced_play \\<sigma> p = ltake (2 * N) (llist_of p)", "by auto"], ["proof (state)\nthis:\n  induced_play \\<sigma> p = ltake (2 * N) (llist_of p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infplays_augment_many_lprefix[simp]:\n  shows \"lprefix (llist_of ((augment_list \\<sigma> ^^ n) p)) (induced_play \\<sigma> p)\n        = position ((augment_list \\<sigma> ^^ n) p)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p) =\n    position ((augment_list \\<sigma> ^^ n) p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p) \\<Longrightarrow>\n    position ((augment_list \\<sigma> ^^ n) p)\n 2. position ((augment_list \\<sigma> ^^ n) p) \\<Longrightarrow>\n    lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p)", "assume ?lhs"], ["proof (state)\nthis:\n  lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n   (induced_play \\<sigma> p)\n\ngoal (2 subgoals):\n 1. lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p) \\<Longrightarrow>\n    position ((augment_list \\<sigma> ^^ n) p)\n 2. position ((augment_list \\<sigma> ^^ n) p) \\<Longrightarrow>\n    lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p)", "from lprefix_llength_le[OF this]"], ["proof (chain)\npicking this:\n  llength (llist_of ((augment_list \\<sigma> ^^ n) p))\n  \\<le> llength (induced_play \\<sigma> p)", "show ?rhs"], ["proof (prove)\nusing this:\n  llength (llist_of ((augment_list \\<sigma> ^^ n) p))\n  \\<le> llength (induced_play \\<sigma> p)\n\ngoal (1 subgoal):\n 1. position ((augment_list \\<sigma> ^^ n) p)", "unfolding induced_play_def"], ["proof (prove)\nusing this:\n  llength (llist_of ((augment_list \\<sigma> ^^ n) p))\n  \\<le> llength\n         ((ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n           strategy_progression \\<sigma>)\n           p)\n\ngoal (1 subgoal):\n 1. position ((augment_list \\<sigma> ^^ n) p)", "by (auto simp:position_def length_augment_list)"], ["proof (state)\nthis:\n  position ((augment_list \\<sigma> ^^ n) p)\n\ngoal (1 subgoal):\n 1. position ((augment_list \\<sigma> ^^ n) p) \\<Longrightarrow>\n    lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. position ((augment_list \\<sigma> ^^ n) p) \\<Longrightarrow>\n    lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p)", "assume assm:?rhs"], ["proof (state)\nthis:\n  position ((augment_list \\<sigma> ^^ n) p)\n\ngoal (1 subgoal):\n 1. position ((augment_list \\<sigma> ^^ n) p) \\<Longrightarrow>\n    lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p)", "from induced_play_is_lprefix[OF this, of \"\\<sigma>\"]"], ["proof (chain)\npicking this:\n  lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n   (induced_play \\<sigma> ((augment_list \\<sigma> ^^ n) p))", "show ?lhs"], ["proof (prove)\nusing this:\n  lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n   (induced_play \\<sigma> ((augment_list \\<sigma> ^^ n) p))\n\ngoal (1 subgoal):\n 1. lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     (induced_play \\<sigma> p)", "unfolding induced_play_def"], ["proof (prove)\nusing this:\n  lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n   ((ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n     strategy_progression \\<sigma>)\n     ((augment_list \\<sigma> ^^ n) p))\n\ngoal (1 subgoal):\n 1. lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n     ((ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n       strategy_progression \\<sigma>)\n       p)", "by simp"], ["proof (state)\nthis:\n  lprefix (llist_of ((augment_list \\<sigma> ^^ n) p))\n   (induced_play \\<sigma> p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Winning strategies \\<close>"], ["", "text \\<open> A strategy is winning (in position p) if, no matter the moves by the other player,\n       it leads to a sequence in the winning set. \\<close>"], ["", "definition strategy_winning_by_Even where\n  \"strategy_winning_by_Even \\<sigma>\\<^sub>e p \\<equiv> (\\<forall> \\<sigma>\\<^sub>o. induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p \\<in> A)\""], ["", "definition strategy_winning_by_Odd where\n  \"strategy_winning_by_Odd \\<sigma>\\<^sub>o p \\<equiv> (\\<forall> \\<sigma>\\<^sub>e. induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p \\<notin> A)\""], ["", "text \\<open> It immediately follows that not both players can have a winning strategy. \\<close>"], ["", "lemma at_most_one_player_winning:\nshows \"\\<not> (\\<exists> \\<sigma>\\<^sub>e. strategy_winning_by_Even \\<sigma>\\<^sub>e p) \\<or> \\<not> (\\<exists> \\<sigma>\\<^sub>o. strategy_winning_by_Odd \\<sigma>\\<^sub>o p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>\\<sigma>\\<^sub>e.\n        strategy_winning_by_Even \\<sigma>\\<^sub>e p) \\<or>\n    (\\<nexists>\\<sigma>\\<^sub>o. strategy_winning_by_Odd \\<sigma>\\<^sub>o p)", "unfolding strategy_winning_by_Even_def strategy_winning_by_Odd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>\\<sigma>\\<^sub>e.\n        \\<forall>\\<sigma>\\<^sub>o.\n           induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\n           \\<in> A) \\<or>\n    (\\<nexists>\\<sigma>\\<^sub>o.\n        \\<forall>\\<sigma>\\<^sub>e.\n           induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>\\<^sub>o) p\n           \\<notin> A)", "by auto"], ["", "text \\<open> If a player whose turn it is not makes any move, winning strategies remain winning.\n       All of the following proofs are duplicated for Even and Odd,\n       as the game is entirely symmetrical. These 'dual' theorems can be obtained\n       by considering a game in which an additional first and final move are played yet ignored,\n       but it is quite convenient to have both theorems at hand regardless, and the proofs are\n       quite small, so we accept the code duplication. \\<close>"], ["", "lemma any_moves_remain_winning_Even:\n  assumes \"odd (length p)\" \"strategy_winning_by_Even \\<sigma> p\"\n  shows \"strategy_winning_by_Even \\<sigma> (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_winning_by_Even \\<sigma> (p @ [m])", "unfolding strategy_winning_by_Even_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>o.\n       induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n       \\<in> A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>o.\n       induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n       \\<in> A", "fix \\<sigma>\\<^sub>o"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>o.\n       induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n       \\<in> A", "let ?s = \"\\<sigma>\\<^sub>o(p:=m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>o.\n       induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n       \\<in> A", "have prfx:\"prefix (p @ [m]) p' \\<Longrightarrow>\n             p' @ [joint_strategy \\<sigma> \\<sigma>\\<^sub>o p'] = p' @ [joint_strategy \\<sigma> ?s p']\"\n    for p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (p @ [m]) p' \\<Longrightarrow>\n    augment_list (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) p' =\n    augment_list (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m))) p'", "by (auto simp: joint_strategy_def)"], ["proof (state)\nthis:\n  prefix (p @ [m]) ?p'1 \\<Longrightarrow>\n  augment_list (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) ?p'1 =\n  augment_list (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m))) ?p'1\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>o.\n       induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n       \\<in> A", "from assms(2)[unfolded strategy_winning_by_Even_def,rule_format,of ?s]\n       infplays_augment_one_joint(2)[OF assms(1)]"], ["proof (chain)\npicking this:\n  induced_play (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m))) p\n  \\<in> A\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>o p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p", "have \"induced_play (joint_strategy \\<sigma> ?s) (augment_list ?s p) \\<in> A\""], ["proof (prove)\nusing this:\n  induced_play (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m))) p\n  \\<in> A\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>o p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p\n\ngoal (1 subgoal):\n 1. induced_play (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m)))\n     (augment_list (\\<sigma>\\<^sub>o(p := m)) p)\n    \\<in> A", "by (metis (mono_tags, lifting) induced_play_def comp_apply)"], ["proof (state)\nthis:\n  induced_play (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m)))\n   (augment_list (\\<sigma>\\<^sub>o(p := m)) p)\n  \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>o.\n       induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n       \\<in> A", "thus \"induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m]) \\<in> A\""], ["proof (prove)\nusing this:\n  induced_play (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m)))\n   (augment_list (\\<sigma>\\<^sub>o(p := m)) p)\n  \\<in> A\n\ngoal (1 subgoal):\n 1. induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m])\n    \\<in> A", "unfolding induced_play_def o_def"], ["proof (prove)\nusing this:\n  ltake (2 * N)\n   (lmap last\n     (ltl (strategy_progression\n            (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m)))\n            (augment_list (\\<sigma>\\<^sub>o(p := m)) p))))\n  \\<in> A\n\ngoal (1 subgoal):\n 1. ltake (2 * N)\n     (lmap last\n       (ltl (strategy_progression (joint_strategy \\<sigma> \\<sigma>\\<^sub>o)\n              (p @ [m]))))\n    \\<in> A", "using infplays_eq[OF prfx]"], ["proof (prove)\nusing this:\n  ltake (2 * N)\n   (lmap last\n     (ltl (strategy_progression\n            (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m)))\n            (augment_list (\\<sigma>\\<^sub>o(p := m)) p))))\n  \\<in> A\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) ?p =\n  strategy_progression (joint_strategy \\<sigma> (\\<sigma>\\<^sub>o(p := m)))\n   ?p\n\ngoal (1 subgoal):\n 1. ltake (2 * N)\n     (lmap last\n       (ltl (strategy_progression (joint_strategy \\<sigma> \\<sigma>\\<^sub>o)\n              (p @ [m]))))\n    \\<in> A", "by auto"], ["proof (state)\nthis:\n  induced_play (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) (p @ [m]) \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma any_moves_remain_winning_Odd:\n  assumes \"even (length p)\" \"strategy_winning_by_Odd \\<sigma> p\"\n  shows \"strategy_winning_by_Odd \\<sigma> (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_winning_by_Odd \\<sigma> (p @ [m])", "unfolding strategy_winning_by_Odd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>e.\n       induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n       \\<notin> A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>e.\n       induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n       \\<notin> A", "fix \\<sigma>\\<^sub>e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>e.\n       induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n       \\<notin> A", "let ?s = \"\\<sigma>\\<^sub>e(p:=m)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>e.\n       induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n       \\<notin> A", "have prfx:\"prefix (p @ [m]) p' \\<Longrightarrow>\n             p' @ [joint_strategy \\<sigma>\\<^sub>e \\<sigma> p'] = p' @ [joint_strategy ?s \\<sigma> p']\"\n    for p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (p @ [m]) p' \\<Longrightarrow>\n    augment_list (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) p' =\n    augment_list (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>) p'", "by (auto simp:joint_strategy_def)"], ["proof (state)\nthis:\n  prefix (p @ [m]) ?p'1 \\<Longrightarrow>\n  augment_list (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) ?p'1 =\n  augment_list (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>) ?p'1\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>e.\n       induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n       \\<notin> A", "from assms(2)[unfolded strategy_winning_by_Odd_def,rule_format,of ?s]\n       infplays_augment_one_joint(1)[OF assms(1)]"], ["proof (chain)\npicking this:\n  induced_play (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>) p\n  \\<notin> A\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>e p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p", "have \"induced_play (joint_strategy ?s \\<sigma>) (augment_list ?s p) \\<notin> A\""], ["proof (prove)\nusing this:\n  induced_play (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>) p\n  \\<notin> A\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>e p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p\n\ngoal (1 subgoal):\n 1. induced_play (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>)\n     (augment_list (\\<sigma>\\<^sub>e(p := m)) p)\n    \\<notin> A", "by (metis (mono_tags, lifting) induced_play_def comp_apply)"], ["proof (state)\nthis:\n  induced_play (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>)\n   (augment_list (\\<sigma>\\<^sub>e(p := m)) p)\n  \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>\\<^sub>e.\n       induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n       \\<notin> A", "thus \"induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m]) \\<notin> A\""], ["proof (prove)\nusing this:\n  induced_play (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>)\n   (augment_list (\\<sigma>\\<^sub>e(p := m)) p)\n  \\<notin> A\n\ngoal (1 subgoal):\n 1. induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n    \\<notin> A", "unfolding induced_play_def o_def"], ["proof (prove)\nusing this:\n  ltake (2 * N)\n   (lmap last\n     (ltl (strategy_progression\n            (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>)\n            (augment_list (\\<sigma>\\<^sub>e(p := m)) p))))\n  \\<notin> A\n\ngoal (1 subgoal):\n 1. ltake (2 * N)\n     (lmap last\n       (ltl (strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>)\n              (p @ [m]))))\n    \\<notin> A", "using infplays_eq[OF prfx]"], ["proof (prove)\nusing this:\n  ltake (2 * N)\n   (lmap last\n     (ltl (strategy_progression\n            (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>)\n            (augment_list (\\<sigma>\\<^sub>e(p := m)) p))))\n  \\<notin> A\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) ?p =\n  strategy_progression (joint_strategy (\\<sigma>\\<^sub>e(p := m)) \\<sigma>)\n   ?p\n\ngoal (1 subgoal):\n 1. ltake (2 * N)\n     (lmap last\n       (ltl (strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>)\n              (p @ [m]))))\n    \\<notin> A", "by auto"], ["proof (state)\nthis:\n  induced_play (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) (p @ [m])\n  \\<notin> A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> If a player does not have a winning strategy,\n       a move by that player will not give it one. \\<close>"], ["", "lemma non_winning_moves_remains_non_winning_Even:\n  assumes \"even (length p)\" \"\\<forall> \\<sigma>. \\<not> strategy_winning_by_Even \\<sigma> p\"\n  shows \"\\<not> strategy_winning_by_Even \\<sigma> (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> strategy_winning_by_Even \\<sigma> (p @ [m])", "proof(rule contrapos_nn[of \"\\<exists> \\<sigma>. strategy_winning_by_Even \\<sigma> p\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n 2. strategy_winning_by_Even \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "assume a:\"strategy_winning_by_Even \\<sigma> (p @ [m])\""], ["proof (state)\nthis:\n  strategy_winning_by_Even \\<sigma> (p @ [m])\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n 2. strategy_winning_by_Even \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "let ?s = \"\\<sigma>(p:=m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n 2. strategy_winning_by_Even \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "have prfx:\"prefix (p @ [m]) p' \\<Longrightarrow>\n             p' @ [joint_strategy \\<sigma> \\<sigma>\\<^sub>o p'] = p' @ [joint_strategy ?s \\<sigma>\\<^sub>o p']\"\n    for p' \\<sigma>\\<^sub>o"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (p @ [m]) p' \\<Longrightarrow>\n    augment_list (joint_strategy \\<sigma> \\<sigma>\\<^sub>o) p' =\n    augment_list (joint_strategy (\\<sigma>(p := m)) \\<sigma>\\<^sub>o) p'", "by (auto simp:joint_strategy_def)"], ["proof (state)\nthis:\n  prefix (p @ [m]) ?p'1 \\<Longrightarrow>\n  augment_list (joint_strategy \\<sigma> ?\\<sigma>\\<^sub>o1) ?p'1 =\n  augment_list (joint_strategy (\\<sigma>(p := m)) ?\\<sigma>\\<^sub>o1) ?p'1\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n 2. strategy_winning_by_Even \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "from a infplays_eq[OF prfx]"], ["proof (chain)\npicking this:\n  strategy_winning_by_Even \\<sigma> (p @ [m])\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression\n   (\\<lambda>p'. joint_strategy \\<sigma> (?\\<sigma>\\<^sub>o2 p') p') ?p =\n  strategy_progression\n   (\\<lambda>p'.\n       joint_strategy (\\<sigma>(p := m)) (?\\<sigma>\\<^sub>o2 p') p')\n   ?p", "have \"strategy_winning_by_Even ?s (p @ [m])\""], ["proof (prove)\nusing this:\n  strategy_winning_by_Even \\<sigma> (p @ [m])\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression\n   (\\<lambda>p'. joint_strategy \\<sigma> (?\\<sigma>\\<^sub>o2 p') p') ?p =\n  strategy_progression\n   (\\<lambda>p'.\n       joint_strategy (\\<sigma>(p := m)) (?\\<sigma>\\<^sub>o2 p') p')\n   ?p\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Even (\\<sigma>(p := m)) (p @ [m])", "unfolding strategy_winning_by_Even_def induced_play_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>\\<^sub>o.\n     (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n      strategy_progression (joint_strategy \\<sigma> \\<sigma>\\<^sub>o))\n      (p @ [m])\n     \\<in> A\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression\n   (\\<lambda>p'. joint_strategy \\<sigma> (?\\<sigma>\\<^sub>o2 p') p') ?p =\n  strategy_progression\n   (\\<lambda>p'.\n       joint_strategy (\\<sigma>(p := m)) (?\\<sigma>\\<^sub>o2 p') p')\n   ?p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>o.\n       (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n        strategy_progression\n         (joint_strategy (\\<sigma>(p := m)) \\<sigma>\\<^sub>o))\n        (p @ [m])\n       \\<in> A", "by simp"], ["proof (state)\nthis:\n  strategy_winning_by_Even (\\<sigma>(p := m)) (p @ [m])\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n 2. strategy_winning_by_Even \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "hence \"strategy_winning_by_Even ?s p\""], ["proof (prove)\nusing this:\n  strategy_winning_by_Even (\\<sigma>(p := m)) (p @ [m])\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Even (\\<sigma>(p := m)) p", "using infplays_augment_one_joint(1)[OF assms(1)]"], ["proof (prove)\nusing this:\n  strategy_winning_by_Even (\\<sigma>(p := m)) (p @ [m])\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>e p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Even (\\<sigma>(p := m)) p", "unfolding strategy_winning_by_Even_def induced_play_def o_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>\\<^sub>o.\n     ltake (2 * N)\n      (lmap last\n        (ltl (strategy_progression\n               (joint_strategy (\\<sigma>(p := m)) \\<sigma>\\<^sub>o)\n               (p @ [m]))))\n     \\<in> A\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>e p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>o.\n       ltake (2 * N)\n        (lmap last\n          (ltl (strategy_progression\n                 (joint_strategy (\\<sigma>(p := m)) \\<sigma>\\<^sub>o) p)))\n       \\<in> A", "by (metis fun_upd_same)"], ["proof (state)\nthis:\n  strategy_winning_by_Even (\\<sigma>(p := m)) p\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n 2. strategy_winning_by_Even \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "thus \"\\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\""], ["proof (prove)\nusing this:\n  strategy_winning_by_Even (\\<sigma>(p := m)) p\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>\\<sigma>. \\<not> strategy_winning_by_Even \\<sigma> p", "show \"\\<not> (\\<exists> \\<sigma>. strategy_winning_by_Even \\<sigma> p)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>. \\<not> strategy_winning_by_Even \\<sigma> p\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p", "by meson"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>. strategy_winning_by_Even \\<sigma> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_winning_moves_remains_non_winning_Odd:\n  assumes \"odd (length p)\" \"\\<forall> \\<sigma>. \\<not> strategy_winning_by_Odd \\<sigma> p\"\n  shows \"\\<not> strategy_winning_by_Odd \\<sigma> (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> strategy_winning_by_Odd \\<sigma> (p @ [m])", "proof(rule contrapos_nn[of \"\\<exists> \\<sigma>. strategy_winning_by_Odd \\<sigma> p\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n 2. strategy_winning_by_Odd \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "assume a:\"strategy_winning_by_Odd \\<sigma> (p @ [m])\""], ["proof (state)\nthis:\n  strategy_winning_by_Odd \\<sigma> (p @ [m])\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n 2. strategy_winning_by_Odd \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "let ?s = \"\\<sigma>(p:=m)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n 2. strategy_winning_by_Odd \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "have prfx:\"prefix (p @ [m]) p' \\<Longrightarrow>\n             p' @ [joint_strategy \\<sigma>\\<^sub>e \\<sigma> p'] = p' @ [joint_strategy \\<sigma>\\<^sub>e ?s p']\"\n    for p' \\<sigma>\\<^sub>e"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (p @ [m]) p' \\<Longrightarrow>\n    augment_list (joint_strategy \\<sigma>\\<^sub>e \\<sigma>) p' =\n    augment_list (joint_strategy \\<sigma>\\<^sub>e (\\<sigma>(p := m))) p'", "by (auto simp:joint_strategy_def)"], ["proof (state)\nthis:\n  prefix (p @ [m]) ?p'1 \\<Longrightarrow>\n  augment_list (joint_strategy ?\\<sigma>\\<^sub>e1 \\<sigma>) ?p'1 =\n  augment_list (joint_strategy ?\\<sigma>\\<^sub>e1 (\\<sigma>(p := m))) ?p'1\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n 2. strategy_winning_by_Odd \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "from a infplays_eq[OF prfx]"], ["proof (chain)\npicking this:\n  strategy_winning_by_Odd \\<sigma> (p @ [m])\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression\n   (\\<lambda>p'. joint_strategy (?\\<sigma>\\<^sub>e2 p') \\<sigma> p') ?p =\n  strategy_progression\n   (\\<lambda>p'.\n       joint_strategy (?\\<sigma>\\<^sub>e2 p') (\\<sigma>(p := m)) p')\n   ?p", "have \"strategy_winning_by_Odd ?s (p @ [m])\""], ["proof (prove)\nusing this:\n  strategy_winning_by_Odd \\<sigma> (p @ [m])\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression\n   (\\<lambda>p'. joint_strategy (?\\<sigma>\\<^sub>e2 p') \\<sigma> p') ?p =\n  strategy_progression\n   (\\<lambda>p'.\n       joint_strategy (?\\<sigma>\\<^sub>e2 p') (\\<sigma>(p := m)) p')\n   ?p\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Odd (\\<sigma>(p := m)) (p @ [m])", "unfolding strategy_winning_by_Odd_def induced_play_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>\\<^sub>e.\n     (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n      strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>))\n      (p @ [m])\n     \\<notin> A\n  (\\<And>p'.\n      prefix ?p p' \\<Longrightarrow> prefix (p @ [m]) p') \\<Longrightarrow>\n  strategy_progression\n   (\\<lambda>p'. joint_strategy (?\\<sigma>\\<^sub>e2 p') \\<sigma> p') ?p =\n  strategy_progression\n   (\\<lambda>p'.\n       joint_strategy (?\\<sigma>\\<^sub>e2 p') (\\<sigma>(p := m)) p')\n   ?p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>e.\n       (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n        strategy_progression\n         (joint_strategy \\<sigma>\\<^sub>e (\\<sigma>(p := m))))\n        (p @ [m])\n       \\<notin> A", "by simp"], ["proof (state)\nthis:\n  strategy_winning_by_Odd (\\<sigma>(p := m)) (p @ [m])\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n 2. strategy_winning_by_Odd \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "hence \"strategy_winning_by_Odd ?s p\""], ["proof (prove)\nusing this:\n  strategy_winning_by_Odd (\\<sigma>(p := m)) (p @ [m])\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Odd (\\<sigma>(p := m)) p", "using infplays_augment_one_joint(2)[OF assms(1)]"], ["proof (prove)\nusing this:\n  strategy_winning_by_Odd (\\<sigma>(p := m)) (p @ [m])\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>o p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Odd (\\<sigma>(p := m)) p", "unfolding strategy_winning_by_Odd_def induced_play_def o_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>\\<^sub>e.\n     ltake (2 * N)\n      (lmap last\n        (ltl (strategy_progression\n               (joint_strategy \\<sigma>\\<^sub>e (\\<sigma>(p := m)))\n               (p @ [m]))))\n     \\<notin> A\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   (augment_list ?\\<sigma>\\<^sub>o p) =\n  strategy_progression (joint_strategy ?\\<sigma>\\<^sub>e ?\\<sigma>\\<^sub>o)\n   p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>e.\n       ltake (2 * N)\n        (lmap last\n          (ltl (strategy_progression\n                 (joint_strategy \\<sigma>\\<^sub>e (\\<sigma>(p := m))) p)))\n       \\<notin> A", "by (metis fun_upd_same)"], ["proof (state)\nthis:\n  strategy_winning_by_Odd (\\<sigma>(p := m)) p\n\ngoal (2 subgoals):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n 2. strategy_winning_by_Odd \\<sigma> (p @ [m]) \\<Longrightarrow>\n    \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "thus \"\\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\""], ["proof (prove)\nusing this:\n  strategy_winning_by_Odd (\\<sigma>(p := m)) p\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>\\<sigma>. \\<not> strategy_winning_by_Odd \\<sigma> p", "show \"\\<not> (\\<exists> \\<sigma>. strategy_winning_by_Odd \\<sigma> p)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>. \\<not> strategy_winning_by_Odd \\<sigma> p\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p", "by meson"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>. strategy_winning_by_Odd \\<sigma> p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> If a player whose turn it is makes a move according to its stragey,\n       the new position will remain winning. \\<close>"], ["", "lemma winning_moves_remain_winning_Even:\n  assumes \"even (length p)\" \"strategy_winning_by_Even \\<sigma> p\"\n  shows \"strategy_winning_by_Even \\<sigma> (p @ [\\<sigma> p])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_winning_by_Even \\<sigma> (augment_list \\<sigma> p)", "using assms infplays_augment_one"], ["proof (prove)\nusing this:\n  even (length p)\n  strategy_winning_by_Even \\<sigma> p\n  strategy_progression ?\\<sigma> (augment_list ?\\<sigma> ?p) =\n  strategy_progression ?\\<sigma> ?p\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Even \\<sigma> (augment_list \\<sigma> p)", "unfolding induced_play_def strategy_winning_by_Even_def"], ["proof (prove)\nusing this:\n  even (length p)\n  \\<forall>\\<sigma>\\<^sub>o.\n     (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n      strategy_progression (joint_strategy \\<sigma> \\<sigma>\\<^sub>o))\n      p\n     \\<in> A\n  strategy_progression ?\\<sigma> (augment_list ?\\<sigma> ?p) =\n  strategy_progression ?\\<sigma> ?p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>o.\n       (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n        strategy_progression (joint_strategy \\<sigma> \\<sigma>\\<^sub>o))\n        (augment_list \\<sigma> p)\n       \\<in> A", "by auto"], ["", "lemma winning_moves_remain_winning_Odd:\n  assumes \"odd (length p)\" \"strategy_winning_by_Odd \\<sigma> p\"\n  shows \"strategy_winning_by_Odd \\<sigma> (p @ [\\<sigma> p])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strategy_winning_by_Odd \\<sigma> (augment_list \\<sigma> p)", "using assms infplays_augment_one"], ["proof (prove)\nusing this:\n  odd (length p)\n  strategy_winning_by_Odd \\<sigma> p\n  strategy_progression ?\\<sigma> (augment_list ?\\<sigma> ?p) =\n  strategy_progression ?\\<sigma> ?p\n\ngoal (1 subgoal):\n 1. strategy_winning_by_Odd \\<sigma> (augment_list \\<sigma> p)", "unfolding induced_play_def strategy_winning_by_Odd_def"], ["proof (prove)\nusing this:\n  odd (length p)\n  \\<forall>\\<sigma>\\<^sub>e.\n     (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n      strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>))\n      p\n     \\<notin> A\n  strategy_progression ?\\<sigma> (augment_list ?\\<sigma> ?p) =\n  strategy_progression ?\\<sigma> ?p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<^sub>e.\n       (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n        strategy_progression (joint_strategy \\<sigma>\\<^sub>e \\<sigma>))\n        (augment_list \\<sigma> p)\n       \\<notin> A", "by auto"], ["", "text \\<open> We speak of winning positions as those positions in which the player has a winning strategy.\n       This is mainly for presentation purposes. \\<close>"], ["", "abbreviation winning_position_Even where\n  \"winning_position_Even p \\<equiv> position p \\<and> (\\<exists> \\<sigma>. strategy_winning_by_Even \\<sigma> p)\""], ["", "abbreviation winning_position_Odd where\n  \"winning_position_Odd p \\<equiv> position p \\<and> (\\<exists> \\<sigma>. strategy_winning_by_Odd \\<sigma> p)\""], ["", "lemma winning_position_can_remain_winning_Even:\n  assumes \"even (length p)\" \"\\<forall> m. position (p @ [m])\" \"winning_position_Even p\"\n  shows \"\\<exists> m. winning_position_Even (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. winning_position_Even (p @ [m])", "using assms winning_moves_remain_winning_Even[OF assms(1)]"], ["proof (prove)\nusing this:\n  even (length p)\n  \\<forall>m. position (p @ [m])\n  winning_position_Even p\n  strategy_winning_by_Even ?\\<sigma> p \\<Longrightarrow>\n  strategy_winning_by_Even ?\\<sigma> (augment_list ?\\<sigma> p)\n\ngoal (1 subgoal):\n 1. \\<exists>m. winning_position_Even (p @ [m])", "by auto"], ["", "lemma winning_position_can_remain_winning_Odd:\n  assumes \"odd (length p)\" \"\\<forall> m. position (p @ [m])\" \"winning_position_Odd p\"\n  shows \"\\<exists> m. winning_position_Odd (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. winning_position_Odd (p @ [m])", "using assms winning_moves_remain_winning_Odd[OF assms(1)]"], ["proof (prove)\nusing this:\n  odd (length p)\n  \\<forall>m. position (p @ [m])\n  winning_position_Odd p\n  strategy_winning_by_Odd ?\\<sigma> p \\<Longrightarrow>\n  strategy_winning_by_Odd ?\\<sigma> (augment_list ?\\<sigma> p)\n\ngoal (1 subgoal):\n 1. \\<exists>m. winning_position_Odd (p @ [m])", "by auto"], ["", "lemma winning_position_will_remain_winning_Even:\n  assumes \"odd (length p)\" \"position (p @ [m])\" \"winning_position_Even p\"\n  shows \"winning_position_Even (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_position_Even (p @ [m])", "using assms any_moves_remain_winning_Even[OF assms(1)]"], ["proof (prove)\nusing this:\n  odd (length p)\n  position (p @ [m])\n  winning_position_Even p\n  strategy_winning_by_Even ?\\<sigma> p \\<Longrightarrow>\n  strategy_winning_by_Even ?\\<sigma> (p @ [?m])\n\ngoal (1 subgoal):\n 1. winning_position_Even (p @ [m])", "by auto"], ["", "lemma winning_position_will_remain_winning_Odd:\n  assumes \"even (length p)\" \"position (p @ [m])\" \"winning_position_Odd p\"\n  shows \"winning_position_Odd (p @ [m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. winning_position_Odd (p @ [m])", "using assms any_moves_remain_winning_Odd[OF assms(1)]"], ["proof (prove)\nusing this:\n  even (length p)\n  position (p @ [m])\n  winning_position_Odd p\n  strategy_winning_by_Odd ?\\<sigma> p \\<Longrightarrow>\n  strategy_winning_by_Odd ?\\<sigma> (p @ [?m])\n\ngoal (1 subgoal):\n 1. winning_position_Odd (p @ [m])", "by auto"], ["", "lemma induced_play_eq:\nassumes \"\\<forall> p'. prefix p p' \\<longrightarrow> (augment_list s1) p' = (augment_list s2) p'\"\nshows \"induced_play s1 p = induced_play s2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_play s1 p = induced_play s2 p", "unfolding induced_play_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n     strategy_progression s1)\n     p =\n    (ltake (2 * N) \\<circ> lmap last \\<circ> ltl \\<circ>\n     strategy_progression s2)\n     p", "by (auto simp:infplays_eq[OF assms[rule_format]])"], ["", "end"], ["", "end"]]}