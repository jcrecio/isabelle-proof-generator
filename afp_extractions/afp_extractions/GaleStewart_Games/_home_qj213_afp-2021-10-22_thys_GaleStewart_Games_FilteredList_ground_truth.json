{"file_name": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games/FilteredList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games", "problem_names": ["lemma ldistinct_lfilter_ltake[intro]:\n  assumes \"ldistinct (lfilter P xs)\"\n  shows \"ldistinct (lfilter P (ltake x xs))\"", "lemma lfilter_lfind:\n  assumes \"lfilter P lst \\<noteq> LNil\"\n  shows \"P (lst $ lfind P lst)\" (is ?g1)\n        \"P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\" (is \"?a \\<Longrightarrow> ?g2\")\n        \"lfind P lst < llength lst\" (is ?g3)", "lemma ltake_lfind_lset:\n  assumes \"x \\<in> lset (ltake (enat (lfind P lst)) lst)\"\n  shows \"\\<not> P x\"", "lemma ltake_lfind_conv:\n  assumes \"lfilter P lst \\<noteq> LNil\"\n  shows \"ltake (lfind P lst) lst = ltakeWhile (Not o P) lst\" (is \"?t1 = ?t2\")\n        \"ldrop (lfind P lst) lst = ldropWhile (Not o P) lst\" (is \"?t3 = ?t4\")", "lemma lfilter_hdtl:\n  assumes \"lfilter P lst \\<noteq> LNil\"\n  shows \"\\<exists> n. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat n) lst) \\<and>\n              ltl (lfilter P lst) = lfilter P (ldrop (enat n) lst)\"", "lemma ltake_lfilter:\n  shows \"\\<exists> n. ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst) \\<and> ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\"", "lemma filter_obtain_two:\n  assumes \"i < j\" \"j < length (filter P lst)\"\n  shows \"\\<exists> i2 j2. i2 < j2 \\<and> j2 < length lst \\<and> lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j\"", "lemma ldistinct_lfilterI:\n  assumes \"\\<And> i j. i < llength lst \\<Longrightarrow> j < llength lst \\<Longrightarrow> lst $ i = lst $ j \\<Longrightarrow> P (lst $ i) \\<Longrightarrow> i = j\"\n  shows \"ldistinct (lfilter P lst)\"", "lemma ldistinct_lfilterE:\n  assumes \"ldistinct (lfilter P lst)\" \"e = lst $ i\" \"e = lst $ j\"\n          \"i < llength lst\" \"j < llength lst\" \"P e\"\n  shows \"i = j\"", "lemma ldistinct_lfilter_conv:\n  \"ldistinct (lfilter P lst) = (\\<forall> i j. i < llength lst \\<longrightarrow> j < llength lst \\<longrightarrow> P (lst $ i) \\<longrightarrow> lst $ i = lst $ j \\<longrightarrow> i = j)\""], "translations": [["", "lemma ldistinct_lfilter_ltake[intro]:\n  assumes \"ldistinct (lfilter P xs)\"\n  shows \"ldistinct (lfilter P (ltake x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P (ltake x xs))", "using assms"], ["proof (prove)\nusing this:\n  ldistinct (lfilter P xs)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P (ltake x xs))", "by(induct xs,force,force\n    ,(* sledgehammer found this gem to prove the inductive step via lfilter_lappend_lfinite!\n        We will use this strategy ourselves later on *)\n     metis lappend_ltake_ldrop ldistinct_lappend lfilter_lappend_lfinite lfinite_LConsI lfinite_ltake)"], ["", "text \\<open>The function lfind is used in multiple proofs, all are introduced to prove ltake_lfilter.\\<close>"], ["", "definition lfind where \"lfind P lst = (LEAST i. P (lst $ i))\""], ["", "lemma lfilter_lfind:\n  assumes \"lfilter P lst \\<noteq> LNil\"\n  shows \"P (lst $ lfind P lst)\" (is ?g1)\n        \"P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\" (is \"?a \\<Longrightarrow> ?g2\")\n        \"lfind P lst < llength lst\" (is ?g3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (lst $ lfind P lst) &&&\n    (P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y) &&&\n    enat (lfind P lst) < llength lst", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. P (lst $ lfind P lst)\n 2. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 3. enat (lfind P lst) < llength lst", "let ?I = \"{n. enat n < llength lst \\<and> P (lst $ n)}\""], ["proof (state)\ngoal (3 subgoals):\n 1. P (lst $ lfind P lst)\n 2. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 3. enat (lfind P lst) < llength lst", "let ?xs = lst"], ["proof (state)\ngoal (3 subgoals):\n 1. P (lst $ lfind P lst)\n 2. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 3. enat (lfind P lst) < llength lst", "from assms[unfolded lfilter_conv_lnths] lset_LNil"], ["proof (chain)\npicking this:\n  lnths lst {n. enat n < llength lst \\<and> P (lst $ n)} \\<noteq> LNil\n  lset LNil = {}", "have \"lset (lnths lst {n. enat n < llength lst \\<and> P (lst $ n)}) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  lnths lst {n. enat n < llength lst \\<and> P (lst $ n)} \\<noteq> LNil\n  lset LNil = {}\n\ngoal (1 subgoal):\n 1. lset (lnths lst {n. enat n < llength lst \\<and> P (lst $ n)}) \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  lset (lnths lst {n. enat n < llength lst \\<and> P (lst $ n)}) \\<noteq> {}\n\ngoal (3 subgoals):\n 1. P (lst $ lfind P lst)\n 2. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 3. enat (lfind P lst) < llength lst", "hence \"{?xs $ i |i. enat i < llength ?xs \\<and> i \\<in> ?I} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  lset (lnths lst {n. enat n < llength lst \\<and> P (lst $ n)}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {lst $ i |i.\n     enat i < llength lst \\<and>\n     i \\<in> {n. enat n < llength lst \\<and> P (lst $ n)}} \\<noteq>\n    {}", "using lset_lnths[of ?xs ?I]"], ["proof (prove)\nusing this:\n  lset (lnths lst {n. enat n < llength lst \\<and> P (lst $ n)}) \\<noteq> {}\n  lset (lnths lst {n. enat n < llength lst \\<and> P (lst $ n)}) =\n  {lst $ i |i.\n   enat i < llength lst \\<and>\n   i \\<in> {n. enat n < llength lst \\<and> P (lst $ n)}}\n\ngoal (1 subgoal):\n 1. {lst $ i |i.\n     enat i < llength lst \\<and>\n     i \\<in> {n. enat n < llength lst \\<and> P (lst $ n)}} \\<noteq>\n    {}", "by metis"], ["proof (state)\nthis:\n  {lst $ i |i.\n   enat i < llength lst \\<and>\n   i \\<in> {n. enat n < llength lst \\<and> P (lst $ n)}} \\<noteq>\n  {}\n\ngoal (3 subgoals):\n 1. P (lst $ lfind P lst)\n 2. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 3. enat (lfind P lst) < llength lst", "then"], ["proof (chain)\npicking this:\n  {lst $ i |i.\n   enat i < llength lst \\<and>\n   i \\<in> {n. enat n < llength lst \\<and> P (lst $ n)}} \\<noteq>\n  {}", "obtain i where p:\"P (lst $ i)\" \"i < llength lst\""], ["proof (prove)\nusing this:\n  {lst $ i |i.\n   enat i < llength lst \\<and>\n   i \\<in> {n. enat n < llength lst \\<and> P (lst $ n)}} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>P (lst $ i); enat i < llength lst\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P (lst $ i)\n  enat i < llength lst\n\ngoal (3 subgoals):\n 1. P (lst $ lfind P lst)\n 2. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 3. enat (lfind P lst) < llength lst", "from p"], ["proof (chain)\npicking this:\n  P (lst $ i)\n  enat i < llength lst", "show ?g1"], ["proof (prove)\nusing this:\n  P (lst $ i)\n  enat i < llength lst\n\ngoal (1 subgoal):\n 1. P (lst $ lfind P lst)", "using LeastI lfind_def"], ["proof (prove)\nusing this:\n  P (lst $ i)\n  enat i < llength lst\n  ?P ?k \\<Longrightarrow> ?P (LEAST x. ?P x)\n  lfind ?P ?lst = (LEAST i. ?P (?lst $ i))\n\ngoal (1 subgoal):\n 1. P (lst $ lfind P lst)", "by metis"], ["proof (state)\nthis:\n  P (lst $ lfind P lst)\n\ngoal (2 subgoals):\n 1. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n 2. enat (lfind P lst) < llength lst", "from p"], ["proof (chain)\npicking this:\n  P (lst $ i)\n  enat i < llength lst", "show \"?a \\<Longrightarrow> ?g2\""], ["proof (prove)\nusing this:\n  P (lst $ i)\n  enat i < llength lst\n\ngoal (1 subgoal):\n 1. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y", "using Least_le lfind_def"], ["proof (prove)\nusing this:\n  P (lst $ i)\n  enat i < llength lst\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n  lfind ?P ?lst = (LEAST i. ?P (?lst $ i))\n\ngoal (1 subgoal):\n 1. P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y", "by metis"], ["proof (state)\nthis:\n  P (lst $ y) \\<Longrightarrow> lfind P lst \\<le> y\n\ngoal (1 subgoal):\n 1. enat (lfind P lst) < llength lst", "from p"], ["proof (chain)\npicking this:\n  P (lst $ i)\n  enat i < llength lst", "show ?g3"], ["proof (prove)\nusing this:\n  P (lst $ i)\n  enat i < llength lst\n\ngoal (1 subgoal):\n 1. enat (lfind P lst) < llength lst", "using Least_le lfind_def"], ["proof (prove)\nusing this:\n  P (lst $ i)\n  enat i < llength lst\n  ?P ?k \\<Longrightarrow> (LEAST x. ?P x) \\<le> ?k\n  lfind ?P ?lst = (LEAST i. ?P (?lst $ i))\n\ngoal (1 subgoal):\n 1. enat (lfind P lst) < llength lst", "by (metis enat_ord_simps(1) le_less_trans)"], ["proof (state)\nthis:\n  enat (lfind P lst) < llength lst\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_lfind_lset:\n  assumes \"x \\<in> lset (ltake (enat (lfind P lst)) lst)\"\n  shows \"\\<not> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P x", "proof(cases \"lfilter P (ltake (enat (lfind P lst)) lst) = LNil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) = LNil \\<Longrightarrow>\n    \\<not> P x\n 2. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "case True"], ["proof (state)\nthis:\n  lfilter P (ltake (enat (lfind P lst)) lst) = LNil\n\ngoal (2 subgoals):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) = LNil \\<Longrightarrow>\n    \\<not> P x\n 2. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "then"], ["proof (chain)\npicking this:\n  lfilter P (ltake (enat (lfind P lst)) lst) = LNil", "show ?thesis"], ["proof (prove)\nusing this:\n  lfilter P (ltake (enat (lfind P lst)) lst) = LNil\n\ngoal (1 subgoal):\n 1. \\<not> P x", "using assms"], ["proof (prove)\nusing this:\n  lfilter P (ltake (enat (lfind P lst)) lst) = LNil\n  x \\<in> lset (ltake (enat (lfind P lst)) lst)\n\ngoal (1 subgoal):\n 1. \\<not> P x", "unfolding lfilter_eq_LNil"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>lset (ltake (enat (lfind P lst)) lst). \\<not> P x\n  x \\<in> lset (ltake (enat (lfind P lst)) lst)\n\ngoal (1 subgoal):\n 1. \\<not> P x", "by auto"], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "case False"], ["proof (state)\nthis:\n  lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "from assms[unfolded in_lset_conv_lnth]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     enat n < llength (ltake (enat (lfind P lst)) lst) \\<and>\n     ltake (enat (lfind P lst)) lst $ n = x", "obtain n where\n    n:\"enat n < llength (ltake (enat (lfind P lst)) lst)\" \"ltake (enat (lfind P lst)) lst $ n = x\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     enat n < llength (ltake (enat (lfind P lst)) lst) \\<and>\n     ltake (enat (lfind P lst)) lst $ n = x\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>enat n < llength (ltake (enat (lfind P lst)) lst);\n         ltake (enat (lfind P lst)) lst $ n = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enat n < llength (ltake (enat (lfind P lst)) lst)\n  ltake (enat (lfind P lst)) lst $ n = x\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "{"], ["proof (state)\nthis:\n  enat n < llength (ltake (enat (lfind P lst)) lst)\n  ltake (enat (lfind P lst)) lst $ n = x\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "assume a:\"P x\""], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "(* The idea of this {block} is that the element n must come after (lfind P lst) by lfilter_lfind(2)\n     but this contradicts n(1).\n     However, in the last step when writing this proof, sledgehammer found one that didn't use\n       any of my previous steps, so here's a one-liner: *)"], ["proof (state)\nthis:\n  P x\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "from n Coinductive_List.lset_ltake False a enat_ord_simps(1) leD lfilter_empty_conv lfilter_lfind(2,3) llength_ltake' lnth_ltake subset_eq"], ["proof (chain)\npicking this:\n  enat n < llength (ltake (enat (lfind P lst)) lst)\n  ltake (enat (lfind P lst)) lst $ n = x\n  lset (ltake ?n ?xs) \\<subseteq> lset ?xs\n  lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq> LNil\n  P x\n  (enat ?m \\<le> enat ?n) = (?m \\<le> ?n)\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  (lfilter ?P ?xs = LNil) = (\\<forall>x\\<in>lset ?xs. \\<not> ?P x)\n  \\<lbrakk>lfilter ?P ?lst \\<noteq> LNil; ?P (?lst $ ?y)\\<rbrakk>\n  \\<Longrightarrow> lfind ?P ?lst \\<le> ?y\n  lfilter ?P ?lst \\<noteq> LNil \\<Longrightarrow>\n  enat (lfind ?P ?lst) < llength ?lst\n  enat ?n < llength ?xs \\<Longrightarrow>\n  llength (ltake (enat ?n) ?xs) = enat ?n\n  enat ?m < ?n \\<Longrightarrow> ltake ?n ?xs $ ?m = ?xs $ ?m\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)", "have False"], ["proof (prove)\nusing this:\n  enat n < llength (ltake (enat (lfind P lst)) lst)\n  ltake (enat (lfind P lst)) lst $ n = x\n  lset (ltake ?n ?xs) \\<subseteq> lset ?xs\n  lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq> LNil\n  P x\n  (enat ?m \\<le> enat ?n) = (?m \\<le> ?n)\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  (lfilter ?P ?xs = LNil) = (\\<forall>x\\<in>lset ?xs. \\<not> ?P x)\n  \\<lbrakk>lfilter ?P ?lst \\<noteq> LNil; ?P (?lst $ ?y)\\<rbrakk>\n  \\<Longrightarrow> lfind ?P ?lst \\<le> ?y\n  lfilter ?P ?lst \\<noteq> LNil \\<Longrightarrow>\n  enat (lfind ?P ?lst) < llength ?lst\n  enat ?n < llength ?xs \\<Longrightarrow>\n  llength (ltake (enat ?n) ?xs) = enat ?n\n  enat ?m < ?n \\<Longrightarrow> ltake ?n ?xs $ ?m = ?xs $ ?m\n  (?A \\<subseteq> ?B) = (\\<forall>x\\<in>?A. x \\<in> ?B)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "}"], ["proof (state)\nthis:\n  P x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (lfind P lst)) lst) \\<noteq>\n    LNil \\<Longrightarrow>\n    \\<not> P x", "then"], ["proof (chain)\npicking this:\n  P x \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  P x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P x", "by blast"], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_lfind_conv:\n  assumes \"lfilter P lst \\<noteq> LNil\"\n  shows \"ltake (lfind P lst) lst = ltakeWhile (Not o P) lst\" (is \"?t1 = ?t2\")\n        \"ldrop (lfind P lst) lst = ldropWhile (Not o P) lst\" (is \"?t3 = ?t4\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst &&&\n    ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have lfin:\"lfinite ?t1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltake (enat (lfind P lst)) lst)", "by simp"], ["proof (state)\nthis:\n  lfinite (ltake (enat (lfind P lst)) lst)\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have [simp]:\"min (enat (lfind P lst)) (llength lst) = (lfind P lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (enat (lfind P lst)) (llength lst) = enat (lfind P lst)", "using lfilter_lfind(3)[OF assms]"], ["proof (prove)\nusing this:\n  enat (lfind P lst) < llength lst\n\ngoal (1 subgoal):\n 1. min (enat (lfind P lst)) (llength lst) = enat (lfind P lst)", "by (metis min.strict_order_iff)"], ["proof (state)\nthis:\n  min (enat (lfind P lst)) (llength lst) = enat (lfind P lst)\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have l1:\"llength ?t1 = lfind P lst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (ltake (enat (lfind P lst)) lst) = enat (lfind P lst)", "by simp"], ["proof (state)\nthis:\n  llength (ltake (enat (lfind P lst)) lst) = enat (lfind P lst)\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "from ltake_lfind_lset ltakeWhile_all"], ["proof (chain)\npicking this:\n  ?x \\<in> lset (ltake (enat (lfind ?P ?lst)) ?lst) \\<Longrightarrow>\n  \\<not> ?P ?x\n  \\<forall>x\\<in>lset ?xs. ?P x \\<Longrightarrow> ltakeWhile ?P ?xs = ?xs", "have t:\"ltakeWhile (Not o P) ?t1 = ?t1\""], ["proof (prove)\nusing this:\n  ?x \\<in> lset (ltake (enat (lfind ?P ?lst)) ?lst) \\<Longrightarrow>\n  \\<not> ?P ?x\n  \\<forall>x\\<in>lset ?xs. ?P x \\<Longrightarrow> ltakeWhile ?P ?xs = ?xs\n\ngoal (1 subgoal):\n 1. ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n    ltake (enat (lfind P lst)) lst", "unfolding o_def"], ["proof (prove)\nusing this:\n  ?x \\<in> lset (ltake (enat (lfind ?P ?lst)) ?lst) \\<Longrightarrow>\n  \\<not> ?P ?x\n  \\<forall>x\\<in>lset ?xs. ?P x \\<Longrightarrow> ltakeWhile ?P ?xs = ?xs\n\ngoal (1 subgoal):\n 1. ltakeWhile (\\<lambda>x. \\<not> P x) (ltake (enat (lfind P lst)) lst) =\n    ltake (enat (lfind P lst)) lst", "by metis"], ["proof (state)\nthis:\n  ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n  ltake (enat (lfind P lst)) lst\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have inset:\"lset (ltake (enat (lfind P lst)) lst) \\<subseteq> {x. (Not \\<circ> P) x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lset (ltake (enat (lfind P lst)) lst) \\<subseteq> {x. (Not \\<circ> P) x}", "using ltake_lfind_lset[of _ P lst]"], ["proof (prove)\nusing this:\n  ?x \\<in> lset (ltake (enat (lfind P lst)) lst) \\<Longrightarrow>\n  \\<not> P ?x\n\ngoal (1 subgoal):\n 1. lset (ltake (enat (lfind P lst)) lst) \\<subseteq> {x. (Not \\<circ> P) x}", "by auto"], ["proof (state)\nthis:\n  lset (ltake (enat (lfind P lst)) lst) \\<subseteq> {x. (Not \\<circ> P) x}\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "(* for use in ltakeWhile_lappend2 *)"], ["proof (state)\nthis:\n  lset (ltake (enat (lfind P lst)) lst) \\<subseteq> {x. (Not \\<circ> P) x}\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have isnull:\"ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil", "apply(cases \"ldrop (enat (lfind P lst)) lst\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. ldrop (enat (lfind P lst)) lst = LNil \\<Longrightarrow>\n    ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil\n 2. \\<And>x21 x22.\n       ldrop (enat (lfind P lst)) lst = LCons x21 x22 \\<Longrightarrow>\n       ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil", "using lfilter_lfind(1)[OF assms] lhd_ldrop[OF lfilter_lfind(3)[OF assms]]"], ["proof (prove)\nusing this:\n  P (lst $ lfind P lst)\n  lhd (ldrop (enat (lfind P lst)) lst) = lst $ the_enat (enat (lfind P lst))\n\ngoal (2 subgoals):\n 1. ldrop (enat (lfind P lst)) lst = LNil \\<Longrightarrow>\n    ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil\n 2. \\<And>x21 x22.\n       ldrop (enat (lfind P lst)) lst = LCons x21 x22 \\<Longrightarrow>\n       ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil", "by auto"], ["proof (state)\nthis:\n  ltakeWhile (Not \\<circ> P) (ldrop (enat (lfind P lst)) lst) = LNil\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have \"ltakeWhile (Not o P) ?t1 = ltakeWhile (Not o P) (lappend ?t1 ?t3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n    ltakeWhile (Not \\<circ> P)\n     (lappend (ltake (enat (lfind P lst)) lst)\n       (ldrop (enat (lfind P lst)) lst))", "unfolding ltakeWhile_lappend2[OF inset] isnull lappend_LNil2 t"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (lfind P lst)) lst = ltake (enat (lfind P lst)) lst", ".."], ["proof (state)\nthis:\n  ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n  ltakeWhile (Not \\<circ> P)\n   (lappend (ltake (enat (lfind P lst)) lst)\n     (ldrop (enat (lfind P lst)) lst))\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "hence leneq:\"llength ?t1 = llength ?t2\""], ["proof (prove)\nusing this:\n  ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n  ltakeWhile (Not \\<circ> P)\n   (lappend (ltake (enat (lfind P lst)) lst)\n     (ldrop (enat (lfind P lst)) lst))\n\ngoal (1 subgoal):\n 1. llength (ltake (enat (lfind P lst)) lst) =\n    llength (ltakeWhile (Not \\<circ> P) lst)", "using t l1 lappend_ltake_ldrop"], ["proof (prove)\nusing this:\n  ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n  ltakeWhile (Not \\<circ> P)\n   (lappend (ltake (enat (lfind P lst)) lst)\n     (ldrop (enat (lfind P lst)) lst))\n  ltakeWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst) =\n  ltake (enat (lfind P lst)) lst\n  llength (ltake (enat (lfind P lst)) lst) = enat (lfind P lst)\n  lappend (ltake ?n ?xs) (ldrop ?n ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. llength (ltake (enat (lfind P lst)) lst) =\n    llength (ltakeWhile (Not \\<circ> P) lst)", "by metis"], ["proof (state)\nthis:\n  llength (ltake (enat (lfind P lst)) lst) =\n  llength (ltakeWhile (Not \\<circ> P) lst)\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have \"lappend ?t1 ?t3 = lappend ?t2 ?t4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend (ltake (enat (lfind P lst)) lst)\n     (ldrop (enat (lfind P lst)) lst) =\n    lappend (ltakeWhile (Not \\<circ> P) lst)\n     (ldropWhile (Not \\<circ> P) lst)", "unfolding lappend_ltakeWhile_ldropWhile[of \"Not \\<circ> P\" lst]\n               lappend_ltake_ldrop[of \"lfind P lst\" lst]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lst = lst", "by simp"], ["proof (state)\nthis:\n  lappend (ltake (enat (lfind P lst)) lst)\n   (ldrop (enat (lfind P lst)) lst) =\n  lappend (ltakeWhile (Not \\<circ> P) lst) (ldropWhile (Not \\<circ> P) lst)\n\ngoal (2 subgoals):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n 2. ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "from this[unfolded lappend_eq_lappend_conv[OF leneq]] lfin"], ["proof (chain)\npicking this:\n  ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst \\<and>\n  (lfinite (ltake (enat (lfind P lst)) lst) \\<longrightarrow>\n   ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst)\n  lfinite (ltake (enat (lfind P lst)) lst)", "show \"?t1 = ?t2\" \"?t3 = ?t4\""], ["proof (prove)\nusing this:\n  ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst \\<and>\n  (lfinite (ltake (enat (lfind P lst)) lst) \\<longrightarrow>\n   ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst)\n  lfinite (ltake (enat (lfind P lst)) lst)\n\ngoal (1 subgoal):\n 1. ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst &&&\n    ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "by auto"], ["proof (state)\nthis:\n  ltake (enat (lfind P lst)) lst = ltakeWhile (Not \\<circ> P) lst\n  ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lfilter_hdtl:\n  assumes \"lfilter P lst \\<noteq> LNil\"\n  shows \"\\<exists> n. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat n) lst) \\<and>\n              ltl (lfilter P lst) = lfilter P (ldrop (enat n) lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       LCons (lhd (lfilter P lst)) LNil =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ltl (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "proof(standard,standard)"], ["proof (state)\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "note * = lfilter_lfind[OF assms]"], ["proof (state)\nthis:\n  P (lst $ lfind P lst)\n  P (lst $ ?y) \\<Longrightarrow> lfind P lst \\<le> ?y\n  enat (lfind P lst) < llength lst\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "let ?n = \"Suc (lfind P lst)\""], ["proof (state)\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "let ?ltake = \"ltake (enat ?n) lst\""], ["proof (state)\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "have ltake:\"lappend (ltakeWhile (Not \\<circ> P) ?ltake) (ldropWhile (Not \\<circ> P) ?ltake) = ?ltake\"\n      (is \"lappend ?ltw ?ldw = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lappend\n     (ltakeWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n     (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst)) =\n    ltake (enat (Suc (lfind P lst))) lst", "using lappend_ltakeWhile_ldropWhile"], ["proof (prove)\nusing this:\n  lappend (ltakeWhile ?P ?xs) (ldropWhile ?P ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. lappend\n     (ltakeWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n     (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst)) =\n    ltake (enat (Suc (lfind P lst))) lst", "by blast"], ["proof (state)\nthis:\n  lappend\n   (ltakeWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n   (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst)) =\n  ltake (enat (Suc (lfind P lst))) lst\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "have \"llength ?ldw \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n    \\<le> 1", "unfolding ldropWhile_lappend ltake_Suc_conv_snoc_lnth[OF *(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength\n     (if \\<exists>x\\<in>lset (ltake (enat (lfind P lst)) lst).\n            \\<not> (Not \\<circ> P) x\n      then lappend\n            (ldropWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst))\n            (LCons (lst $ lfind P lst) LNil)\n      else if lfinite (ltake (enat (lfind P lst)) lst)\n           then ldropWhile (Not \\<circ> P) (LCons (lst $ lfind P lst) LNil)\n           else LNil)\n    \\<le> 1", "using ltake_lfind_lset[of _ P lst]"], ["proof (prove)\nusing this:\n  ?x \\<in> lset (ltake (enat (lfind P lst)) lst) \\<Longrightarrow>\n  \\<not> P ?x\n\ngoal (1 subgoal):\n 1. llength\n     (if \\<exists>x\\<in>lset (ltake (enat (lfind P lst)) lst).\n            \\<not> (Not \\<circ> P) x\n      then lappend\n            (ldropWhile (Not \\<circ> P) (ltake (enat (lfind P lst)) lst))\n            (LCons (lst $ lfind P lst) LNil)\n      else if lfinite (ltake (enat (lfind P lst)) lst)\n           then ldropWhile (Not \\<circ> P) (LCons (lst $ lfind P lst) LNil)\n           else LNil)\n    \\<le> 1", "by (auto intro:* simp:one_eSuc)"], ["proof (state)\nthis:\n  llength\n   (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n  \\<le> 1\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "hence null:\"lnull (ltl (ldropWhile (Not \\<circ> P) ?ltake))\""], ["proof (prove)\nusing this:\n  llength\n   (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. lnull\n     (ltl (ldropWhile (Not \\<circ> P)\n            (ltake (enat (Suc (lfind P lst))) lst)))", "unfolding llength_eq_0[symmetric] llength_ltl"], ["proof (prove)\nusing this:\n  llength\n   (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. epred\n     (llength\n       (ldropWhile (Not \\<circ> P)\n         (ltake (enat (Suc (lfind P lst))) lst))) =\n    0", "by (metis dual_order.order_iff_strict enat_ile epred_0 epred_1 iless_Suc_eq le_zero_eq one_eSuc one_enat_def)"], ["proof (state)\nthis:\n  lnull\n   (ltl (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst)))\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "have e:\"enat (lfind P lst) < enat (Suc (lfind P lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (lfind P lst) < enat (Suc (lfind P lst))", "by auto"], ["proof (state)\nthis:\n  enat (lfind P lst) < enat (Suc (lfind P lst))\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "from *"], ["proof (chain)\npicking this:\n  P (lst $ lfind P lst)\n  P (lst $ ?y) \\<Longrightarrow> lfind P lst \\<le> ?y\n  enat (lfind P lst) < llength lst", "have \"P (?ltake $ lfind P lst)\""], ["proof (prove)\nusing this:\n  P (lst $ lfind P lst)\n  P (lst $ ?y) \\<Longrightarrow> lfind P lst \\<le> ?y\n  enat (lfind P lst) < llength lst\n\ngoal (1 subgoal):\n 1. P (ltake (enat (Suc (lfind P lst))) lst $ lfind P lst)", "using lnth_ltake[OF e]"], ["proof (prove)\nusing this:\n  P (lst $ lfind P lst)\n  P (lst $ ?y) \\<Longrightarrow> lfind P lst \\<le> ?y\n  enat (lfind P lst) < llength lst\n  ltake (enat (Suc (lfind P lst))) ?xs $ lfind P lst = ?xs $ lfind P lst\n\ngoal (1 subgoal):\n 1. P (ltake (enat (Suc (lfind P lst))) lst $ lfind P lst)", "by metis"], ["proof (state)\nthis:\n  P (ltake (enat (Suc (lfind P lst))) lst $ lfind P lst)\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "hence nonnull:\"\\<not> lnull (lfilter P ?ltake)\""], ["proof (prove)\nusing this:\n  P (ltake (enat (Suc (lfind P lst))) lst $ lfind P lst)\n\ngoal (1 subgoal):\n 1. \\<not> lnull (lfilter P (ltake (enat (Suc (lfind P lst))) lst))", "unfolding lnull_lfilter"], ["proof (prove)\nusing this:\n  P (ltake (enat (Suc (lfind P lst))) lst $ lfind P lst)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>lset (ltake (enat (Suc (lfind P lst))) lst).\n               \\<not> P x)", "by (metis \"*\"(3) e in_lset_conv_lnth leI llength_ltake' ltake_all)"], ["proof (state)\nthis:\n  \\<not> lnull (lfilter P (ltake (enat (Suc (lfind P lst))) lst))\n\ngoal (2 subgoals):\n 1. LCons (lhd (lfilter P lst)) LNil = lfilter P (ltake (enat ?n) lst)\n 2. ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)", "show a:\"LCons (lhd (lfilter P lst)) LNil = lfilter P ?ltake\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "have \"lhd (lfilter P ?ltake) = lhd (lfilter P lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (lfilter P (ltake (enat (Suc (lfind P lst))) lst)) =\n    lhd (lfilter P lst)", "by(rule lprefix_lhdD[OF lprefix_lfilterI[OF ltake_is_lprefix] nonnull])"], ["proof (state)\nthis:\n  lhd (lfilter P (ltake (enat (Suc (lfind P lst))) lst)) =\n  lhd (lfilter P lst)\n\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "hence h:\"lhd ?lhs = lhd ?rhs\""], ["proof (prove)\nusing this:\n  lhd (lfilter P (ltake (enat (Suc (lfind P lst))) lst)) =\n  lhd (lfilter P lst)\n\ngoal (1 subgoal):\n 1. lhd (LCons (lhd (lfilter P lst)) LNil) =\n    lhd (lfilter P (ltake (enat (Suc (lfind P lst))) lst))", "by simp"], ["proof (state)\nthis:\n  lhd (LCons (lhd (lfilter P lst)) LNil) =\n  lhd (lfilter P (ltake (enat (Suc (lfind P lst))) lst))\n\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "have \"ltl ?rhs = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltl (lfilter P (ltake (enat (Suc (lfind P lst))) lst)) = LNil", "unfolding ltl_lfilter"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P\n     (ltl (ldropWhile (Not \\<circ> P)\n            (ltake (enat (Suc (lfind P lst))) lst))) =\n    LNil", "using null"], ["proof (prove)\nusing this:\n  lnull\n   (ltl (ldropWhile (Not \\<circ> P) (ltake (enat (Suc (lfind P lst))) lst)))\n\ngoal (1 subgoal):\n 1. lfilter P\n     (ltl (ldropWhile (Not \\<circ> P)\n            (ltake (enat (Suc (lfind P lst))) lst))) =\n    LNil", "by (metis lfilter_LNil llist.collapse(1))"], ["proof (state)\nthis:\n  ltl (lfilter P (ltake (enat (Suc (lfind P lst))) lst)) = LNil\n\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "hence t:\"ltl ?lhs = ltl ?rhs\""], ["proof (prove)\nusing this:\n  ltl (lfilter P (ltake (enat (Suc (lfind P lst))) lst)) = LNil\n\ngoal (1 subgoal):\n 1. ltl (LCons (lhd (lfilter P lst)) LNil) =\n    ltl (lfilter P (ltake (enat (Suc (lfind P lst))) lst))", "by simp"], ["proof (state)\nthis:\n  ltl (LCons (lhd (lfilter P lst)) LNil) =\n  ltl (lfilter P (ltake (enat (Suc (lfind P lst))) lst))\n\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "have flt:\"?rhs \\<noteq> LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (Suc (lfind P lst))) lst) \\<noteq> LNil", "using nonnull"], ["proof (prove)\nusing this:\n  \\<not> lnull (lfilter P (ltake (enat (Suc (lfind P lst))) lst))\n\ngoal (1 subgoal):\n 1. lfilter P (ltake (enat (Suc (lfind P lst))) lst) \\<noteq> LNil", "by fastforce"], ["proof (state)\nthis:\n  lfilter P (ltake (enat (Suc (lfind P lst))) lst) \\<noteq> LNil\n\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LCons (lhd (lfilter P lst)) LNil =\n    lfilter P (ltake (enat (Suc (lfind P lst))) lst)", "by(rule llist_eq_lcons[of ?lhs ?rhs,OF _ flt h t],auto)"], ["proof (state)\nthis:\n  LCons (lhd (lfilter P lst)) LNil =\n  lfilter P (ltake (enat (Suc (lfind P lst))) lst)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LCons (lhd (lfilter P lst)) LNil =\n  lfilter P (ltake (enat (Suc (lfind P lst))) lst)\n\ngoal (1 subgoal):\n 1. ltl (lfilter P lst) = lfilter P (ldrop (enat (Suc (lfind P lst))) lst)", "from lappend_ltake_ldrop[of ?n lst] lappend_ltakeWhile_ldropWhile[of \"Not \\<circ> P\" lst]"], ["proof (chain)\npicking this:\n  lappend (ltake (enat (Suc (lfind P lst))) lst)\n   (ldrop (enat (Suc (lfind P lst))) lst) =\n  lst\n  lappend (ltakeWhile (Not \\<circ> P) lst)\n   (ldropWhile (Not \\<circ> P) lst) =\n  lst", "have \"lappend (ltake ?n lst) (ldrop ?n lst) = lappend (ltakeWhile (Not \\<circ> P) lst) (ldropWhile (Not \\<circ> P) lst)\""], ["proof (prove)\nusing this:\n  lappend (ltake (enat (Suc (lfind P lst))) lst)\n   (ldrop (enat (Suc (lfind P lst))) lst) =\n  lst\n  lappend (ltakeWhile (Not \\<circ> P) lst)\n   (ldropWhile (Not \\<circ> P) lst) =\n  lst\n\ngoal (1 subgoal):\n 1. lappend (ltake (enat (Suc (lfind P lst))) lst)\n     (ldrop (enat (Suc (lfind P lst))) lst) =\n    lappend (ltakeWhile (Not \\<circ> P) lst)\n     (ldropWhile (Not \\<circ> P) lst)", "by auto"], ["proof (state)\nthis:\n  lappend (ltake (enat (Suc (lfind P lst))) lst)\n   (ldrop (enat (Suc (lfind P lst))) lst) =\n  lappend (ltakeWhile (Not \\<circ> P) lst) (ldropWhile (Not \\<circ> P) lst)\n\ngoal (1 subgoal):\n 1. ltl (lfilter P lst) = lfilter P (ldrop (enat (Suc (lfind P lst))) lst)", "from ltake_lfind_conv(2)[OF assms]"], ["proof (chain)\npicking this:\n  ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst", "have \"ltl (ldropWhile (Not \\<circ> P) lst) = ldrop (enat (Suc (lfind P lst))) lst\""], ["proof (prove)\nusing this:\n  ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst\n\ngoal (1 subgoal):\n 1. ltl (ldropWhile (Not \\<circ> P) lst) =\n    ldrop (enat (Suc (lfind P lst))) lst", "unfolding ldrop_eSuc_conv_ltl eSuc_enat[symmetric]"], ["proof (prove)\nusing this:\n  ldrop (enat (lfind P lst)) lst = ldropWhile (Not \\<circ> P) lst\n\ngoal (1 subgoal):\n 1. ltl (ldropWhile (Not \\<circ> P) lst) =\n    ltl (ldrop (enat (lfind P lst)) lst)", "by simp"], ["proof (state)\nthis:\n  ltl (ldropWhile (Not \\<circ> P) lst) =\n  ldrop (enat (Suc (lfind P lst))) lst\n\ngoal (1 subgoal):\n 1. ltl (lfilter P lst) = lfilter P (ldrop (enat (Suc (lfind P lst))) lst)", "thus \"ltl (lfilter P lst) = lfilter P (ldrop (enat ?n) lst)\""], ["proof (prove)\nusing this:\n  ltl (ldropWhile (Not \\<circ> P) lst) =\n  ldrop (enat (Suc (lfind P lst))) lst\n\ngoal (1 subgoal):\n 1. ltl (lfilter P lst) = lfilter P (ldrop (enat (Suc (lfind P lst))) lst)", "unfolding ltl_lfilter"], ["proof (prove)\nusing this:\n  ltl (ldropWhile (Not \\<circ> P) lst) =\n  ldrop (enat (Suc (lfind P lst))) lst\n\ngoal (1 subgoal):\n 1. lfilter P (ltl (ldropWhile (Not \\<circ> P) lst)) =\n    lfilter P (ldrop (enat (Suc (lfind P lst))) lst)", "by metis"], ["proof (state)\nthis:\n  ltl (lfilter P lst) = lfilter P (ldrop (enat (Suc (lfind P lst))) lst)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltake_lfilter:\n  shows \"\\<exists> n. ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst) \\<and> ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat x) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "proof(induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n.\n       ltake (enat 0) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat 0) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>n.\n       ltake (enat 0) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat 0) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat 0) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat 0) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "by (metis LNil_eq_ltake_iff ldrop_enat ldropn_0 lfilter_code(1) zero_enat_def)"], ["proof (state)\nthis:\n  \\<exists>n.\n     ltake (enat 0) (lfilter P lst) = lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat 0) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "let ?fP = \"lfilter P\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "case (Suc x)"], ["proof (state)\nthis:\n  \\<exists>n.\n     ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "then"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "obtain n where n:\"ltake (enat x) (?fP lst) = ?fP (ltake (enat n) lst)\"\n    \"ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>ltake (enat x) (lfilter P lst) =\n                 lfilter P (ltake (enat n) lst);\n         ldrop (enat x) (lfilter P lst) =\n         lfilter P (ldrop (enat n) lst)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "consider \"lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and> x < llength (?fP lst)\" |\n    \"lfilter P (ldrop (enat n) lst) = LNil\" | \"x \\<ge> llength (?fP lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n             enat x < llength (lfilter P lst) \\<Longrightarrow>\n             thesis;\n     lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow> thesis;\n     llength (lfilter P lst) \\<le> enat x \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n           enat x < llength (lfilter P lst) \\<Longrightarrow>\n           ?thesis;\n   lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow> ?thesis;\n   llength (lfilter P lst) \\<le> enat x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>n.\n          ltake (enat x) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat x) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst) \\<Longrightarrow>\n       \\<exists>n.\n          ltake (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ltake (enat n) lst) \\<and>\n          ldrop (enat (Suc x)) (lfilter P lst) =\n          lfilter P (ldrop (enat n) lst)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n           enat x < llength (lfilter P lst) \\<Longrightarrow>\n           ?thesis;\n   lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow> ?thesis;\n   llength (lfilter P lst) \\<le> enat x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n           enat x < llength (lfilter P lst) \\<Longrightarrow>\n           ?thesis;\n   lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow> ?thesis;\n   llength (lfilter P lst) \\<le> enat x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "case 1"], ["proof (state)\nthis:\n  lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n  enat x < llength (lfilter P lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "hence *:\"lfilter P (ldrop (enat n) lst) \\<noteq> LNil\" \"enat x < llength (lfilter P lst)\""], ["proof (prove)\nusing this:\n  lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n  enat x < llength (lfilter P lst)\n\ngoal (1 subgoal):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil &&&\n    enat x < llength (lfilter P lst)", "by auto"], ["proof (state)\nthis:\n  lfilter P (ldrop (enat n) lst) \\<noteq> LNil\n  enat x < llength (lfilter P lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "from lappend_ltake_ldrop"], ["proof (chain)\npicking this:\n  lappend (ltake ?n ?xs) (ldrop ?n ?xs) = ?xs", "have \"lst = lappend (ltake (enat n) lst) (ldrop (enat n) lst)\""], ["proof (prove)\nusing this:\n  lappend (ltake ?n ?xs) (ldrop ?n ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. lst = lappend (ltake (enat n) lst) (ldrop (enat n) lst)", "by metis"], ["proof (state)\nthis:\n  lst = lappend (ltake (enat n) lst) (ldrop (enat n) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "from lfilter_hdtl[OF *(1)]"], ["proof (chain)\npicking this:\n  \\<exists>na.\n     LCons (lhd (lfilter P (ldrop (enat n) lst))) LNil =\n     lfilter P (ltake (enat na) (ldrop (enat n) lst)) \\<and>\n     ltl (lfilter P (ldrop (enat n) lst)) =\n     lfilter P (ldrop (enat na) (ldrop (enat n) lst))", "obtain delta where\n      delta:\"LCons (lhd (?fP (ldrop (enat n) lst))) LNil = ?fP (ltake (enat delta) (ldrop (enat n) lst))\"\n      \"ltl (lfilter P (ldrop (enat n) lst)) = lfilter P (ldrop (enat delta) (ldrop (enat n) lst))\""], ["proof (prove)\nusing this:\n  \\<exists>na.\n     LCons (lhd (lfilter P (ldrop (enat n) lst))) LNil =\n     lfilter P (ltake (enat na) (ldrop (enat n) lst)) \\<and>\n     ltl (lfilter P (ldrop (enat n) lst)) =\n     lfilter P (ldrop (enat na) (ldrop (enat n) lst))\n\ngoal (1 subgoal):\n 1. (\\<And>delta.\n        \\<lbrakk>LCons (lhd (lfilter P (ldrop (enat n) lst))) LNil =\n                 lfilter P (ltake (enat delta) (ldrop (enat n) lst));\n         ltl (lfilter P (ldrop (enat n) lst)) =\n         lfilter P (ldrop (enat delta) (ldrop (enat n) lst))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  LCons (lhd (lfilter P (ldrop (enat n) lst))) LNil =\n  lfilter P (ltake (enat delta) (ldrop (enat n) lst))\n  ltl (lfilter P (ldrop (enat n) lst)) =\n  lfilter P (ldrop (enat delta) (ldrop (enat n) lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"ltake (enat (Suc x)) (?fP lst) = lappend (?fP (ltake (enat n) lst)) (LCons (?fP lst $ x) LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc x)) (lfilter P lst) =\n    lappend (lfilter P (ltake (enat n) lst))\n     (LCons (lfilter P lst $ x) LNil)", "using n ltake_Suc_conv_snoc_lnth *"], ["proof (prove)\nusing this:\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n  enat ?m < llength ?xs \\<Longrightarrow>\n  ltake (enat (Suc ?m)) ?xs =\n  lappend (ltake (enat ?m) ?xs) (LCons (?xs $ ?m) LNil)\n  lfilter P (ldrop (enat n) lst) \\<noteq> LNil\n  enat x < llength (lfilter P lst)\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc x)) (lfilter P lst) =\n    lappend (lfilter P (ltake (enat n) lst))\n     (LCons (lfilter P lst $ x) LNil)", "by metis"], ["proof (state)\nthis:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lappend (lfilter P (ltake (enat n) lst)) (LCons (lfilter P lst $ x) LNil)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lappend (lfilter P (ltake (enat n) lst)) (LCons (lfilter P lst $ x) LNil)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"?fP lst $ x = ?fP lst $ (the_enat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P lst $ x = lfilter P lst $ the_enat (enat x)", "by auto"], ["proof (state)\nthis:\n  lfilter P lst $ x = lfilter P lst $ the_enat (enat x)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  lfilter P lst $ x = lfilter P lst $ the_enat (enat x)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"\\<dots> = lhd (ldrop x (?fP lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P lst $ the_enat (enat x) = lhd (ldrop (enat x) (lfilter P lst))", "using lhd_ldrop[symmetric] *(2)"], ["proof (prove)\nusing this:\n  ?n < llength ?xs \\<Longrightarrow> ?xs $ the_enat ?n = lhd (ldrop ?n ?xs)\n  enat x < llength (lfilter P lst)\n\ngoal (1 subgoal):\n 1. lfilter P lst $ the_enat (enat x) = lhd (ldrop (enat x) (lfilter P lst))", "by metis"], ["proof (state)\nthis:\n  lfilter P lst $ the_enat (enat x) = lhd (ldrop (enat x) (lfilter P lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  lfilter P lst $ the_enat (enat x) = lhd (ldrop (enat x) (lfilter P lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"\\<dots> = lhd (?fP (ldrop (enat n) lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhd (ldrop (enat x) (lfilter P lst)) =\n    lhd (lfilter P (ldrop (enat n) lst))", "using n"], ["proof (prove)\nusing this:\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. lhd (ldrop (enat x) (lfilter P lst)) =\n    lhd (lfilter P (ldrop (enat n) lst))", "by metis"], ["proof (state)\nthis:\n  lhd (ldrop (enat x) (lfilter P lst)) =\n  lhd (lfilter P (ldrop (enat n) lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  lhd (ldrop (enat x) (lfilter P lst)) =\n  lhd (lfilter P (ldrop (enat n) lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "note delta(1)"], ["proof (state)\nthis:\n  LCons (lhd (lfilter P (ldrop (enat n) lst))) LNil =\n  lfilter P (ltake (enat delta) (ldrop (enat n) lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "finally"], ["proof (chain)\npicking this:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lappend (lfilter P (ltake (enat n) lst))\n   (lfilter P (ltake (enat delta) (ldrop (enat n) lst)))", "have take_part:\"ltake (enat (Suc x)) (?fP lst) = ?fP (ltake (enat (n + delta)) lst)\""], ["proof (prove)\nusing this:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lappend (lfilter P (ltake (enat n) lst))\n   (lfilter P (ltake (enat delta) (ldrop (enat n) lst)))\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc x)) (lfilter P lst) =\n    lfilter P (ltake (enat (n + delta)) lst)", "using ltake_plus_conv_lappend"], ["proof (prove)\nusing this:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lappend (lfilter P (ltake (enat n) lst))\n   (lfilter P (ltake (enat delta) (ldrop (enat n) lst)))\n  ltake (?n + ?m) ?xs = lappend (ltake ?n ?xs) (ltake ?m (ldrop ?n ?xs))\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc x)) (lfilter P lst) =\n    lfilter P (ltake (enat (n + delta)) lst)", "by (metis infinite_small_llength lfilter_lappend_lfinite llength_ltake' ltake_all min.strict_order_iff not_less plus_enat_simps(1))"], ["proof (state)\nthis:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ltake (enat (n + delta)) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"ldrop (enat (Suc x)) (?fP lst) = ltl (ldrop x (?fP lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat (Suc x)) (lfilter P lst) =\n    ltl (ldrop (enat x) (lfilter P lst))", "by (simp add: ltl_ldropn ldrop_eSuc_ltl ldrop_enat)"], ["proof (state)\nthis:\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  ltl (ldrop (enat x) (lfilter P lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  ltl (ldrop (enat x) (lfilter P lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"ldrop x (?fP lst) = ?fP (ldrop (enat n) lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "using n"], ["proof (prove)\nusing this:\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "by metis"], ["proof (state)\nthis:\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "note delta(2)"], ["proof (state)\nthis:\n  ltl (lfilter P (ldrop (enat n) lst)) =\n  lfilter P (ldrop (enat delta) (ldrop (enat n) lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  ltl (lfilter P (ldrop (enat n) lst)) =\n  lfilter P (ldrop (enat delta) (ldrop (enat n) lst))\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"lfilter P (ldrop (enat delta) (ldrop (enat n) lst)) = lfilter P (ldrop (enat delta + enat n) lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfilter P (ldrop (enat delta) (ldrop (enat n) lst)) =\n    lfilter P (ldrop (enat delta + enat n) lst)", "by simp"], ["proof (state)\nthis:\n  lfilter P (ldrop (enat delta) (ldrop (enat n) lst)) =\n  lfilter P (ldrop (enat delta + enat n) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "also"], ["proof (state)\nthis:\n  lfilter P (ldrop (enat delta) (ldrop (enat n) lst)) =\n  lfilter P (ldrop (enat delta + enat n) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have \"(enat delta + enat n) = enat (n + delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat delta + enat n = enat (n + delta)", "by simp"], ["proof (state)\nthis:\n  enat delta + enat n = enat (n + delta)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "finally"], ["proof (chain)\npicking this:\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ldrop (enat (n + delta)) lst)", "have drop_part:\"ldrop (enat (Suc x)) (?fP lst) = ?fP (ldrop (enat (n + delta)) lst)\""], ["proof (prove)\nusing this:\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ldrop (enat (n + delta)) lst)\n\ngoal (1 subgoal):\n 1. ldrop (enat (Suc x)) (lfilter P lst) =\n    lfilter P (ldrop (enat (n + delta)) lst)", "."], ["proof (state)\nthis:\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ldrop (enat (n + delta)) lst)\n\ngoal (3 subgoals):\n 1. lfilter P (ldrop (enat n) lst) \\<noteq> LNil \\<and>\n    enat x < llength (lfilter P lst) \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 3. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "from take_part drop_part"], ["proof (chain)\npicking this:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ltake (enat (n + delta)) lst)\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ldrop (enat (n + delta)) lst)", "show ?thesis"], ["proof (prove)\nusing this:\n  ltake (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ltake (enat (n + delta)) lst)\n  ldrop (enat (Suc x)) (lfilter P lst) =\n  lfilter P (ldrop (enat (n + delta)) lst)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     ltake (enat (Suc x)) (lfilter P lst) =\n     lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (2 subgoals):\n 1. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "case 2"], ["proof (state)\nthis:\n  lfilter P (ldrop (enat n) lst) = LNil\n\ngoal (2 subgoals):\n 1. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "note * = 2 lappend_ltake_ldrop[of \"enat n\" lst] Suc_llength infinite_small_llength\n             lappend_LNil2 leI lfilter_lappend_lfinite llength_ltake' min.strict_order_iff n"], ["proof (state)\nthis:\n  lfilter P (ldrop (enat n) lst) = LNil\n  lappend (ltake (enat n) lst) (ldrop (enat n) lst) = lst\n  enat (Suc ?n) < llength ?xs \\<Longrightarrow> enat ?n < llength ?xs\n  \\<not> lfinite ?xs \\<Longrightarrow> enat ?n < llength ?xs\n  lappend ?xs LNil = ?xs\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  lfinite ?xs \\<Longrightarrow>\n  lfilter ?P (lappend ?xs ?ys) = lappend (lfilter ?P ?xs) (lfilter ?P ?ys)\n  enat ?n < llength ?xs \\<Longrightarrow>\n  llength (ltake (enat ?n) ?xs) = enat ?n\n  (?a < ?b) = (?a = min ?a ?b \\<and> ?a \\<noteq> ?b)\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (2 subgoals):\n 1. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "have take_part:\"ltake (enat (Suc x)) (?fP lst) = ?fP (ltake (enat n) lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc x)) (lfilter P lst) = lfilter P (ltake (enat n) lst)", "using *"], ["proof (prove)\nusing this:\n  lfilter P (ldrop (enat n) lst) = LNil\n  lappend (ltake (enat n) lst) (ldrop (enat n) lst) = lst\n  enat (Suc ?n) < llength ?xs \\<Longrightarrow> enat ?n < llength ?xs\n  \\<not> lfinite ?xs \\<Longrightarrow> enat ?n < llength ?xs\n  lappend ?xs LNil = ?xs\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  lfinite ?xs \\<Longrightarrow>\n  lfilter ?P (lappend ?xs ?ys) = lappend (lfilter ?P ?xs) (lfilter ?P ?ys)\n  enat ?n < llength ?xs \\<Longrightarrow>\n  llength (ltake (enat ?n) ?xs) = enat ?n\n  (?a < ?b) = (?a = min ?a ?b \\<and> ?a \\<noteq> ?b)\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc x)) (lfilter P lst) = lfilter P (ltake (enat n) lst)", "by (smt (z3) ltake_all)"], ["proof (state)\nthis:\n  ltake (enat (Suc x)) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n\ngoal (2 subgoals):\n 1. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "from 2"], ["proof (chain)\npicking this:\n  lfilter P (ldrop (enat n) lst) = LNil", "have drop_part:\"ldrop (enat (Suc x)) (?fP lst) = ?fP (ldrop (enat n) lst)\""], ["proof (prove)\nusing this:\n  lfilter P (ldrop (enat n) lst) = LNil\n\ngoal (1 subgoal):\n 1. ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "using *"], ["proof (prove)\nusing this:\n  lfilter P (ldrop (enat n) lst) = LNil\n  lfilter P (ldrop (enat n) lst) = LNil\n  lappend (ltake (enat n) lst) (ldrop (enat n) lst) = lst\n  enat (Suc ?n) < llength ?xs \\<Longrightarrow> enat ?n < llength ?xs\n  \\<not> lfinite ?xs \\<Longrightarrow> enat ?n < llength ?xs\n  lappend ?xs LNil = ?xs\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  lfinite ?xs \\<Longrightarrow>\n  lfilter ?P (lappend ?xs ?ys) = lappend (lfilter ?P ?xs) (lfilter ?P ?ys)\n  enat ?n < llength ?xs \\<Longrightarrow>\n  llength (ltake (enat ?n) ?xs) = enat ?n\n  (?a < ?b) = (?a = min ?a ?b \\<and> ?a \\<noteq> ?b)\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "by (smt (z3) ldrop_all)"], ["proof (state)\nthis:\n  ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (2 subgoals):\n 1. lfilter P (ldrop (enat n) lst) = LNil \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n 2. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "from take_part drop_part"], ["proof (chain)\npicking this:\n  ltake (enat (Suc x)) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "show ?thesis"], ["proof (prove)\nusing this:\n  ltake (enat (Suc x)) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     ltake (enat (Suc x)) (lfilter P lst) =\n     lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal (1 subgoal):\n 1. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "case 3"], ["proof (state)\nthis:\n  llength (lfilter P lst) \\<le> enat x\n\ngoal (1 subgoal):\n 1. llength (lfilter P lst) \\<le> enat x \\<Longrightarrow>\n    \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "then"], ["proof (chain)\npicking this:\n  llength (lfilter P lst) \\<le> enat x", "show ?thesis"], ["proof (prove)\nusing this:\n  llength (lfilter P lst) \\<le> enat x\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "using n dual_order.order_iff_strict eSuc_enat iless_Suc_eq le_less_trans ltake_all ldrop_all"], ["proof (prove)\nusing this:\n  llength (lfilter P lst) \\<le> enat x\n  ltake (enat x) (lfilter P lst) = lfilter P (ltake (enat n) lst)\n  ldrop (enat x) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n  eSuc (enat ?n) = enat (Suc ?n)\n  (enat ?m < eSuc ?n) = (enat ?m \\<le> ?n)\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  llength ?xs \\<le> ?m \\<Longrightarrow> ltake ?m ?xs = ?xs\n  llength ?xs \\<le> ?m \\<Longrightarrow> ldrop ?m ?xs = LNil\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       ltake (enat (Suc x)) (lfilter P lst) =\n       lfilter P (ltake (enat n) lst) \\<and>\n       ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)", "by metis"], ["proof (state)\nthis:\n  \\<exists>n.\n     ltake (enat (Suc x)) (lfilter P lst) =\n     lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n.\n     ltake (enat (Suc x)) (lfilter P lst) =\n     lfilter P (ltake (enat n) lst) \\<and>\n     ldrop (enat (Suc x)) (lfilter P lst) = lfilter P (ldrop (enat n) lst)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_obtain_two:\n  assumes \"i < j\" \"j < length (filter P lst)\"\n  shows \"\\<exists> i2 j2. i2 < j2 \\<and> j2 < length lst \\<and> lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length lst \\<and>\n       lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j", "using assms"], ["proof (prove)\nusing this:\n  i < j\n  j < length (filter P lst)\n\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length lst \\<and>\n       lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j", "proof(induct lst arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (filter P [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length [] \\<and>\n                            [] ! i2 = filter P [] ! i \\<and>\n                            [] ! j2 = filter P [] ! j\n 2. \\<And>a lst i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; j < length (filter P lst)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i2 j2.\n  i2 < j2 \\<and>\n  j2 < length lst \\<and>\n  lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j;\n        i < j; j < length (filter P (a # lst))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length (a # lst) \\<and>\n                            (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n                            (a # lst) ! j2 = filter P (a # lst) ! j", "case (Cons a lst)"], ["proof (state)\nthis:\n  \\<lbrakk>?i < ?j; ?j < length (filter P lst)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i2 j2.\n                       i2 < j2 \\<and>\n                       j2 < length lst \\<and>\n                       lst ! i2 = filter P lst ! ?i \\<and>\n                       lst ! j2 = filter P lst ! ?j\n  i < j\n  j < length (filter P (a # lst))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (filter P [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length [] \\<and>\n                            [] ! i2 = filter P [] ! i \\<and>\n                            [] ! j2 = filter P [] ! j\n 2. \\<And>a lst i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; j < length (filter P lst)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i2 j2.\n  i2 < j2 \\<and>\n  j2 < length lst \\<and>\n  lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j;\n        i < j; j < length (filter P (a # lst))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length (a # lst) \\<and>\n                            (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n                            (a # lst) ! j2 = filter P (a # lst) ! j", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < ?j; ?j < length (filter P lst)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i2 j2.\n                       i2 < j2 \\<and>\n                       j2 < length lst \\<and>\n                       lst ! i2 = filter P lst ! ?i \\<and>\n                       lst ! j2 = filter P lst ! ?j\n  i < j\n  j < length (filter P (a # lst))", "obtain jprev where jprev:\"j = Suc jprev\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length (filter P lst)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i2 j2.\n                       i2 < j2 \\<and>\n                       j2 < length lst \\<and>\n                       lst ! i2 = filter P lst ! ?i \\<and>\n                       lst ! j2 = filter P lst ! ?j\n  i < j\n  j < length (filter P (a # lst))\n\ngoal (1 subgoal):\n 1. (\\<And>jprev. j = Suc jprev \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lessE"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length (filter P lst)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i2 j2.\n                       i2 < j2 \\<and>\n                       j2 < length lst \\<and>\n                       lst ! i2 = filter P lst ! ?i \\<and>\n                       lst ! j2 = filter P lst ! ?j\n  i < j\n  j < length (filter P (a # lst))\n  \\<lbrakk>?i < ?k; ?k = Suc ?i \\<Longrightarrow> ?P;\n   \\<And>j.\n      \\<lbrakk>?i < j; ?k = Suc j\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>jprev. j = Suc jprev \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  j = Suc jprev\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (filter P [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length [] \\<and>\n                            [] ! i2 = filter P [] ! i \\<and>\n                            [] ! j2 = filter P [] ! j\n 2. \\<And>a lst i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; j < length (filter P lst)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>i2 j2.\n  i2 < j2 \\<and>\n  j2 < length lst \\<and>\n  lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j;\n        i < j; j < length (filter P (a # lst))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length (a # lst) \\<and>\n                            (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n                            (a # lst) ! j2 = filter P (a # lst) ! j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "proof(cases \"P a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "case True"], ["proof (state)\nthis:\n  P a\n\ngoal (2 subgoals):\n 1. P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "hence lnth[simp]:\"length (filter P (a # lst)) = Suc (length (filter P lst))\""], ["proof (prove)\nusing this:\n  P a\n\ngoal (1 subgoal):\n 1. length (filter P (a # lst)) = Suc (length (filter P lst))", "by auto"], ["proof (state)\nthis:\n  length (filter P (a # lst)) = Suc (length (filter P lst))\n\ngoal (2 subgoals):\n 1. P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "from jprev True Cons(3)"], ["proof (chain)\npicking this:\n  j = Suc jprev\n  P a\n  j < length (filter P (a # lst))", "have \"jprev < length (filter P lst) \""], ["proof (prove)\nusing this:\n  j = Suc jprev\n  P a\n  j < length (filter P (a # lst))\n\ngoal (1 subgoal):\n 1. jprev < length (filter P lst)", "by auto"], ["proof (state)\nthis:\n  jprev < length (filter P lst)\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "from nth_mem[OF this]"], ["proof (chain)\npicking this:\n  filter P lst ! jprev \\<in> set (filter P lst)", "have \"filter P lst ! jprev \\<in> set lst\""], ["proof (prove)\nusing this:\n  filter P lst ! jprev \\<in> set (filter P lst)\n\ngoal (1 subgoal):\n 1. filter P lst ! jprev \\<in> set lst", "by auto"], ["proof (state)\nthis:\n  filter P lst ! jprev \\<in> set lst\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "from this[unfolded in_set_conv_nth]"], ["proof (chain)\npicking this:\n  \\<exists>i<length lst. lst ! i = filter P lst ! jprev", "obtain j2 where\n        \"j2<length lst\" \"lst ! j2 = filter P lst ! jprev\""], ["proof (prove)\nusing this:\n  \\<exists>i<length lst. lst ! i = filter P lst ! jprev\n\ngoal (1 subgoal):\n 1. (\\<And>j2.\n        \\<lbrakk>j2 < length lst; lst ! j2 = filter P lst ! jprev\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j2 < length lst\n  lst ! j2 = filter P lst ! jprev\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "hence \"0 < Suc j2\" \"Suc j2 < length (a # lst)\"\n        \"(a # lst) ! 0 = filter P (a # lst) ! i\"\n        \"(a # lst) ! Suc j2 = filter P (a # lst) ! j\""], ["proof (prove)\nusing this:\n  j2 < length lst\n  lst ! j2 = filter P lst ! jprev\n\ngoal (1 subgoal):\n 1. (0 < Suc j2 &&& Suc j2 < length (a # lst)) &&&\n    (a # lst) ! 0 = filter P (a # lst) ! i &&&\n    (a # lst) ! Suc j2 = filter P (a # lst) ! j", "using 0 True jprev"], ["proof (prove)\nusing this:\n  j2 < length lst\n  lst ! j2 = filter P lst ! jprev\n  i = 0\n  P a\n  j = Suc jprev\n\ngoal (1 subgoal):\n 1. (0 < Suc j2 &&& Suc j2 < length (a # lst)) &&&\n    (a # lst) ! 0 = filter P (a # lst) ! i &&&\n    (a # lst) ! Suc j2 = filter P (a # lst) ! j", "by auto"], ["proof (state)\nthis:\n  0 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! 0 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "then"], ["proof (chain)\npicking this:\n  0 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! 0 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! 0 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "by blast"], ["proof (state)\nthis:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length (a # lst) \\<and>\n     (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n     (a # lst) ! j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "case (Suc nat)"], ["proof (state)\nthis:\n  i = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "then"], ["proof (chain)\npicking this:\n  i = Suc nat", "obtain jprev where jprev:\"j = Suc jprev\""], ["proof (prove)\nusing this:\n  i = Suc nat\n\ngoal (1 subgoal):\n 1. (\\<And>jprev. j = Suc jprev \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons lessE"], ["proof (prove)\nusing this:\n  i = Suc nat\n  \\<lbrakk>?i < ?j; ?j < length (filter P lst)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i2 j2.\n                       i2 < j2 \\<and>\n                       j2 < length lst \\<and>\n                       lst ! i2 = filter P lst ! ?i \\<and>\n                       lst ! j2 = filter P lst ! ?j\n  i < j\n  j < length (filter P (a # lst))\n  \\<lbrakk>?i < ?k; ?k = Suc ?i \\<Longrightarrow> ?P;\n   \\<And>j.\n      \\<lbrakk>?i < j; ?k = Suc j\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>jprev. j = Suc jprev \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  j = Suc jprev\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "hence \"nat < jprev\" \"jprev < length (filter P lst)\""], ["proof (prove)\nusing this:\n  j = Suc jprev\n\ngoal (1 subgoal):\n 1. nat < jprev &&& jprev < length (filter P lst)", "using Cons Suc lnth"], ["proof (prove)\nusing this:\n  j = Suc jprev\n  \\<lbrakk>?i < ?j; ?j < length (filter P lst)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i2 j2.\n                       i2 < j2 \\<and>\n                       j2 < length lst \\<and>\n                       lst ! i2 = filter P lst ! ?i \\<and>\n                       lst ! j2 = filter P lst ! ?j\n  i < j\n  j < length (filter P (a # lst))\n  i = Suc nat\n  length (filter P (a # lst)) = Suc (length (filter P lst))\n\ngoal (1 subgoal):\n 1. nat < jprev &&& jprev < length (filter P lst)", "by auto"], ["proof (state)\nthis:\n  nat < jprev\n  jprev < length (filter P lst)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "from Cons(1)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length lst \\<and>\n     lst ! i2 = filter P lst ! nat \\<and> lst ! j2 = filter P lst ! jprev", "obtain i2 j2 where \"i2 < j2\" \"j2 < length lst\"\n        \"lst ! i2 = filter P lst ! nat\" \"lst ! j2 = filter P lst ! jprev\""], ["proof (prove)\nusing this:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length lst \\<and>\n     lst ! i2 = filter P lst ! nat \\<and> lst ! j2 = filter P lst ! jprev\n\ngoal (1 subgoal):\n 1. (\\<And>i2 j2.\n        \\<lbrakk>i2 < j2; j2 < length lst; lst ! i2 = filter P lst ! nat;\n         lst ! j2 = filter P lst ! jprev\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i2 < j2\n  j2 < length lst\n  lst ! i2 = filter P lst ! nat\n  lst ! j2 = filter P lst ! jprev\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "hence \"Suc i2 < Suc j2\" \"Suc j2 < length (a # lst)\"\n        \"(a # lst) ! Suc i2 = filter P (a # lst) ! Suc nat\"\n        \"(a # lst) ! Suc j2 = filter P (a # lst) ! Suc jprev\""], ["proof (prove)\nusing this:\n  i2 < j2\n  j2 < length lst\n  lst ! i2 = filter P lst ! nat\n  lst ! j2 = filter P lst ! jprev\n\ngoal (1 subgoal):\n 1. (Suc i2 < Suc j2 &&& Suc j2 < length (a # lst)) &&&\n    (a # lst) ! Suc i2 = filter P (a # lst) ! Suc nat &&&\n    (a # lst) ! Suc j2 = filter P (a # lst) ! Suc jprev", "using lnth"], ["proof (prove)\nusing this:\n  i2 < j2\n  j2 < length lst\n  lst ! i2 = filter P lst ! nat\n  lst ! j2 = filter P lst ! jprev\n  length (filter P (a # lst)) = Suc (length (filter P lst))\n\ngoal (1 subgoal):\n 1. (Suc i2 < Suc j2 &&& Suc j2 < length (a # lst)) &&&\n    (a # lst) ! Suc i2 = filter P (a # lst) ! Suc nat &&&\n    (a # lst) ! Suc j2 = filter P (a # lst) ! Suc jprev", "by auto"], ["proof (state)\nthis:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! Suc nat\n  (a # lst) ! Suc j2 = filter P (a # lst) ! Suc jprev\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       \\<exists>i2 j2.\n          i2 < j2 \\<and>\n          j2 < length (a # lst) \\<and>\n          (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n          (a # lst) ! j2 = filter P (a # lst) ! j", "then"], ["proof (chain)\npicking this:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! Suc nat\n  (a # lst) ! Suc j2 = filter P (a # lst) ! Suc jprev", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! Suc nat\n  (a # lst) ! Suc j2 = filter P (a # lst) ! Suc jprev\n\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "unfolding jprev[symmetric] Suc[symmetric]"], ["proof (prove)\nusing this:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "by blast"], ["proof (state)\nthis:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length (a # lst) \\<and>\n     (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n     (a # lst) ! j2 = filter P (a # lst) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length (a # lst) \\<and>\n     (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n     (a # lst) ! j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "case False"], ["proof (state)\nthis:\n  \\<not> P a\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "hence [simp]: \"filter P (a # lst) = filter P lst\""], ["proof (prove)\nusing this:\n  \\<not> P a\n\ngoal (1 subgoal):\n 1. filter P (a # lst) = filter P lst", "by auto"], ["proof (state)\nthis:\n  filter P (a # lst) = filter P lst\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "from Cons(1)[OF Cons(2)] Cons(3)[unfolded this]"], ["proof (chain)\npicking this:\n  j < length (filter P lst) \\<Longrightarrow>\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length lst \\<and>\n     lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j\n  j < length (filter P lst)", "obtain i2 j2 where \"i2 < j2\" \"j2 < length lst\"\n      \"lst ! i2 = filter P lst ! i\" \"lst ! j2 = filter P lst ! j\""], ["proof (prove)\nusing this:\n  j < length (filter P lst) \\<Longrightarrow>\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length lst \\<and>\n     lst ! i2 = filter P lst ! i \\<and> lst ! j2 = filter P lst ! j\n  j < length (filter P lst)\n\ngoal (1 subgoal):\n 1. (\\<And>i2 j2.\n        \\<lbrakk>i2 < j2; j2 < length lst; lst ! i2 = filter P lst ! i;\n         lst ! j2 = filter P lst ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i2 < j2\n  j2 < length lst\n  lst ! i2 = filter P lst ! i\n  lst ! j2 = filter P lst ! j\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "hence \"Suc i2 < Suc j2\" \"Suc j2 < length (a # lst)\"\n      \"(a # lst) ! Suc i2 = filter P (a # lst) ! i\"\n      \"(a # lst) ! Suc j2 = filter P (a # lst) ! j\""], ["proof (prove)\nusing this:\n  i2 < j2\n  j2 < length lst\n  lst ! i2 = filter P lst ! i\n  lst ! j2 = filter P lst ! j\n\ngoal (1 subgoal):\n 1. (Suc i2 < Suc j2 &&& Suc j2 < length (a # lst)) &&&\n    (a # lst) ! Suc i2 = filter P (a # lst) ! i &&&\n    (a # lst) ! Suc j2 = filter P (a # lst) ! j", "by (auto simp:False)"], ["proof (state)\nthis:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<not> P a \\<Longrightarrow>\n    \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "then"], ["proof (chain)\npicking this:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc i2 < Suc j2\n  Suc j2 < length (a # lst)\n  (a # lst) ! Suc i2 = filter P (a # lst) ! i\n  (a # lst) ! Suc j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<exists>i2 j2.\n       i2 < j2 \\<and>\n       j2 < length (a # lst) \\<and>\n       (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n       (a # lst) ! j2 = filter P (a # lst) ! j", "by blast"], ["proof (state)\nthis:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length (a # lst) \\<and>\n     (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n     (a # lst) ! j2 = filter P (a # lst) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length (a # lst) \\<and>\n     (a # lst) ! i2 = filter P (a # lst) ! i \\<and>\n     (a # lst) ! j2 = filter P (a # lst) ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (filter P [])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i2 j2.\n                            i2 < j2 \\<and>\n                            j2 < length [] \\<and>\n                            [] ! i2 = filter P [] ! i \\<and>\n                            [] ! j2 = filter P [] ! j", "qed auto"], ["", "lemma ldistinct_lfilterI:\n  assumes \"\\<And> i j. i < llength lst \\<Longrightarrow> j < llength lst \\<Longrightarrow> lst $ i = lst $ j \\<Longrightarrow> P (lst $ i) \\<Longrightarrow> i = j\"\n  shows \"ldistinct (lfilter P lst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "assume *: \"enat i < llength (lfilter P lst)\"\n            \"enat j < llength (lfilter P lst)\"\n            \"lfilter P lst $ i = lfilter P lst $ j\"\n            \"i < j\""], ["proof (state)\nthis:\n  enat i < llength (lfilter P lst)\n  enat j < llength (lfilter P lst)\n  lfilter P lst $ i = lfilter P lst $ j\n  i < j\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "hence \"lfilter P lst $ i \\<in> lset (lfilter P lst)\""], ["proof (prove)\nusing this:\n  enat i < llength (lfilter P lst)\n  enat j < llength (lfilter P lst)\n  lfilter P lst $ i = lfilter P lst $ j\n  i < j\n\ngoal (1 subgoal):\n 1. lfilter P lst $ i \\<in> lset (lfilter P lst)", "unfolding in_lset_conv_lnth"], ["proof (prove)\nusing this:\n  enat i < llength (lfilter P lst)\n  enat j < llength (lfilter P lst)\n  lfilter P lst $ i = lfilter P lst $ j\n  i < j\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       enat n < llength (lfilter P lst) \\<and>\n       lfilter P lst $ n = lfilter P lst $ i", "by auto"], ["proof (state)\nthis:\n  lfilter P lst $ i \\<in> lset (lfilter P lst)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "with lset_lfilter"], ["proof (chain)\npicking this:\n  lset (lfilter ?P ?xs) = {x \\<in> lset ?xs. ?P x}\n  lfilter P lst $ i \\<in> lset (lfilter P lst)", "have P:\"P (lfilter P lst $ i)\""], ["proof (prove)\nusing this:\n  lset (lfilter ?P ?xs) = {x \\<in> lset ?xs. ?P x}\n  lfilter P lst $ i \\<in> lset (lfilter P lst)\n\ngoal (1 subgoal):\n 1. P (lfilter P lst $ i)", "by auto"], ["proof (state)\nthis:\n  P (lfilter P lst $ i)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "let ?maxij = \"Suc (max i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "from ltake_lfilter"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     ltake (enat ?x) (lfilter ?P ?lst) =\n     lfilter ?P (ltake (enat n) ?lst) \\<and>\n     ldrop (enat ?x) (lfilter ?P ?lst) = lfilter ?P (ldrop (enat n) ?lst)", "obtain maxij where\n    maxij:\"ltake ?maxij (lfilter P lst) = lfilter P (ltake (enat maxij) lst)\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     ltake (enat ?x) (lfilter ?P ?lst) =\n     lfilter ?P (ltake (enat n) ?lst) \\<and>\n     ldrop (enat ?x) (lfilter ?P ?lst) = lfilter ?P (ldrop (enat n) ?lst)\n\ngoal (1 subgoal):\n 1. (\\<And>maxij.\n        ltake (enat (Suc (max i j))) (lfilter P lst) =\n        lfilter P (ltake (enat maxij) lst) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ltake (enat (Suc (max i j))) (lfilter P lst) =\n  lfilter P (ltake (enat maxij) lst)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "let ?lst = \"ltake (enat maxij) lst\""], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "have \"lfinite ?lst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (ltake (enat maxij) lst)", "by auto"], ["proof (state)\nthis:\n  lfinite (ltake (enat maxij) lst)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "define flst where \"flst = list_of ?lst\""], ["proof (state)\nthis:\n  flst = list_of (ltake (enat maxij) lst)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "hence flst:\"llist_of flst = ?lst\""], ["proof (prove)\nusing this:\n  flst = list_of (ltake (enat maxij) lst)\n\ngoal (1 subgoal):\n 1. llist_of flst = ltake (enat maxij) lst", "by auto"], ["proof (state)\nthis:\n  llist_of flst = ltake (enat maxij) lst\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "let ?flst = \"llist_of flst\""], ["proof (state)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "from * P"], ["proof (chain)\npicking this:\n  enat i < llength (lfilter P lst)\n  enat j < llength (lfilter P lst)\n  lfilter P lst $ i = lfilter P lst $ j\n  i < j\n  P (lfilter P lst $ i)", "have \"enat i < llength (lfilter P ?flst)\"\n         \"enat j < llength (lfilter P ?flst)\"\n         \"lfilter P ?flst $ i = lfilter P ?flst $ j\"\n    and P2:\"P (lfilter P ?lst $ i)\""], ["proof (prove)\nusing this:\n  enat i < llength (lfilter P lst)\n  enat j < llength (lfilter P lst)\n  lfilter P lst $ i = lfilter P lst $ j\n  i < j\n  P (lfilter P lst $ i)\n\ngoal (1 subgoal):\n 1. (enat i < llength (lfilter P (llist_of flst)) &&&\n     enat j < llength (lfilter P (llist_of flst)) &&&\n     lfilter P (llist_of flst) $ i = lfilter P (llist_of flst) $ j) &&&\n    P (lfilter P (ltake (enat maxij) lst) $ i)", "unfolding maxij[symmetric] flst"], ["proof (prove)\nusing this:\n  enat i < llength (lfilter P lst)\n  enat j < llength (lfilter P lst)\n  lfilter P lst $ i = lfilter P lst $ j\n  i < j\n  P (lfilter P lst $ i)\n\ngoal (1 subgoal):\n 1. (enat i < llength (ltake (enat (Suc (max i j))) (lfilter P lst)) &&&\n     enat j < llength (ltake (enat (Suc (max i j))) (lfilter P lst)) &&&\n     ltake (enat (Suc (max i j))) (lfilter P lst) $ i =\n     ltake (enat (Suc (max i j))) (lfilter P lst) $ j) &&&\n    P (ltake (enat (Suc (max i j))) (lfilter P lst) $ i)", "by (auto simp add: lnth_ltake)"], ["proof (state)\nthis:\n  enat i < llength (lfilter P (llist_of flst))\n  enat j < llength (lfilter P (llist_of flst))\n  lfilter P (llist_of flst) $ i = lfilter P (llist_of flst) $ j\n  P (lfilter P (ltake (enat maxij) lst) $ i)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "hence \"i < length (filter P flst)\"\n        \"j < length (filter P flst)\"\n    and eq_ij: \"filter P flst ! i = filter P flst ! j\""], ["proof (prove)\nusing this:\n  enat i < llength (lfilter P (llist_of flst))\n  enat j < llength (lfilter P (llist_of flst))\n  lfilter P (llist_of flst) $ i = lfilter P (llist_of flst) $ j\n  P (lfilter P (ltake (enat maxij) lst) $ i)\n\ngoal (1 subgoal):\n 1. (i < length (filter P flst) &&& j < length (filter P flst)) &&&\n    filter P flst ! i = filter P flst ! j", "unfolding llength_llist_of lfilter_llist_of lnth_llist_of"], ["proof (prove)\nusing this:\n  enat i < enat (length (filter P flst))\n  enat j < enat (length (filter P flst))\n  filter P flst ! i = filter P flst ! j\n  P (lfilter P (ltake (enat maxij) lst) $ i)\n\ngoal (1 subgoal):\n 1. (i < length (filter P flst) &&& j < length (filter P flst)) &&&\n    filter P flst ! i = filter P flst ! j", "by auto"], ["proof (state)\nthis:\n  i < length (filter P flst)\n  j < length (filter P flst)\n  filter P flst ! i = filter P flst ! j\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "with filter_obtain_two[OF *(4) this(2)]"], ["proof (chain)\npicking this:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length flst \\<and>\n     flst ! i2 = filter P flst ! i \\<and> flst ! j2 = filter P flst ! j\n  i < length (filter P flst)\n  j < length (filter P flst)\n  filter P flst ! i = filter P flst ! j", "obtain i2 j2\n    where \"i2 < length flst\" \"j2 < length flst\"\n          \"flst ! i2 = filter P flst ! i\"\n          \"flst ! j2 = filter P flst ! j\"\n          and ineq:\"i2<j2\""], ["proof (prove)\nusing this:\n  \\<exists>i2 j2.\n     i2 < j2 \\<and>\n     j2 < length flst \\<and>\n     flst ! i2 = filter P flst ! i \\<and> flst ! j2 = filter P flst ! j\n  i < length (filter P flst)\n  j < length (filter P flst)\n  filter P flst ! i = filter P flst ! j\n\ngoal (1 subgoal):\n 1. (\\<And>i2 j2.\n        \\<lbrakk>i2 < length flst; j2 < length flst;\n         flst ! i2 = filter P flst ! i; flst ! j2 = filter P flst ! j;\n         i2 < j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i2 < length flst\n  j2 < length flst\n  flst ! i2 = filter P flst ! i\n  flst ! j2 = filter P flst ! j\n  i2 < j2\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "hence \"i2 < llength ?flst\" \"j2 < llength ?flst\" \"?flst $ i2 = ?flst $ j2\" \"?flst $ i2 = lfilter P ?flst $ i\" \"i2<j2\""], ["proof (prove)\nusing this:\n  i2 < length flst\n  j2 < length flst\n  flst ! i2 = filter P flst ! i\n  flst ! j2 = filter P flst ! j\n  i2 < j2\n\ngoal (1 subgoal):\n 1. (enat i2 < llength (llist_of flst) &&&\n     enat j2 < llength (llist_of flst)) &&&\n    llist_of flst $ i2 = llist_of flst $ j2 &&&\n    llist_of flst $ i2 = lfilter P (llist_of flst) $ i &&& i2 < j2", "unfolding llength_llist_of lfilter_llist_of lnth_llist_of eq_ij"], ["proof (prove)\nusing this:\n  i2 < length flst\n  j2 < length flst\n  flst ! i2 = filter P flst ! j\n  flst ! j2 = filter P flst ! j\n  i2 < j2\n\ngoal (1 subgoal):\n 1. (enat i2 < enat (length flst) &&& enat j2 < enat (length flst)) &&&\n    flst ! i2 = flst ! j2 &&& flst ! i2 = filter P flst ! j &&& i2 < j2", "by auto"], ["proof (state)\nthis:\n  enat i2 < llength (llist_of flst)\n  enat j2 < llength (llist_of flst)\n  llist_of flst $ i2 = llist_of flst $ j2\n  llist_of flst $ i2 = lfilter P (llist_of flst) $ i\n  i2 < j2\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "hence \"enat i2 < llength lst\" \"enat j2 < llength lst\" \"lst $ i2 = lst $ j2\" \"P (lst $ i2)\""], ["proof (prove)\nusing this:\n  enat i2 < llength (llist_of flst)\n  enat j2 < llength (llist_of flst)\n  llist_of flst $ i2 = llist_of flst $ j2\n  llist_of flst $ i2 = lfilter P (llist_of flst) $ i\n  i2 < j2\n\ngoal (1 subgoal):\n 1. (enat i2 < llength lst &&& enat j2 < llength lst) &&&\n    lst $ i2 = lst $ j2 &&& P (lst $ i2)", "using P2"], ["proof (prove)\nusing this:\n  enat i2 < llength (llist_of flst)\n  enat j2 < llength (llist_of flst)\n  llist_of flst $ i2 = llist_of flst $ j2\n  llist_of flst $ i2 = lfilter P (llist_of flst) $ i\n  i2 < j2\n  P (lfilter P (ltake (enat maxij) lst) $ i)\n\ngoal (1 subgoal):\n 1. (enat i2 < llength lst &&& enat j2 < llength lst) &&&\n    lst $ i2 = lst $ j2 &&& P (lst $ i2)", "unfolding flst"], ["proof (prove)\nusing this:\n  enat i2 < llength (ltake (enat maxij) lst)\n  enat j2 < llength (ltake (enat maxij) lst)\n  ltake (enat maxij) lst $ i2 = ltake (enat maxij) lst $ j2\n  ltake (enat maxij) lst $ i2 = lfilter P (ltake (enat maxij) lst) $ i\n  i2 < j2\n  P (lfilter P (ltake (enat maxij) lst) $ i)\n\ngoal (1 subgoal):\n 1. (enat i2 < llength lst &&& enat j2 < llength lst) &&&\n    lst $ i2 = lst $ j2 &&& P (lst $ i2)", "by (auto simp add: lnth_ltake)"], ["proof (state)\nthis:\n  enat i2 < llength lst\n  enat j2 < llength lst\n  lst $ i2 = lst $ j2\n  P (lst $ i2)\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "from assms[OF this]"], ["proof (chain)\npicking this:\n  i2 = j2", "have False"], ["proof (prove)\nusing this:\n  i2 = j2\n\ngoal (1 subgoal):\n 1. False", "using ineq"], ["proof (prove)\nusing this:\n  i2 = j2\n  i2 < j2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>enat ?i2 < llength (lfilter P lst);\n   enat ?j2 < llength (lfilter P lst);\n   lfilter P lst $ ?i2 = lfilter P lst $ ?j2; ?i2 < ?j2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat ?i2 < llength (lfilter P lst);\n   enat ?j2 < llength (lfilter P lst);\n   lfilter P lst $ ?i2 = lfilter P lst $ ?j2; ?i2 < ?j2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst)", "unfolding ldistinct_conv_lnth"], ["proof (prove)\nusing this:\n  \\<lbrakk>enat ?i2 < llength (lfilter P lst);\n   enat ?j2 < llength (lfilter P lst);\n   lfilter P lst $ ?i2 = lfilter P lst $ ?j2; ?i2 < ?j2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       enat i < llength (lfilter P lst) \\<longrightarrow>\n       enat j < llength (lfilter P lst) \\<longrightarrow>\n       i \\<noteq> j \\<longrightarrow>\n       lfilter P lst $ i \\<noteq> lfilter P lst $ j", "by (smt (z3) le_cases3 less_le)"], ["proof (state)\nthis:\n  ldistinct (lfilter P lst)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lfilterE:\n  assumes \"ldistinct (lfilter P lst)\" \"e = lst $ i\" \"e = lst $ j\"\n          \"i < llength lst\" \"j < llength lst\" \"P e\"\n  shows \"i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "let ?maxij = \"Suc (max i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "let ?lst = \"ltake (enat ?maxij) lst\""], ["proof (state)\ngoal (1 subgoal):\n 1. i = j", "have jle:\"j < length (list_of (ltake (enat (Suc (max i j))) lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length (list_of (ltake (enat (Suc (max i j))) lst))", "using assms(4,5)"], ["proof (prove)\nusing this:\n  enat i < llength lst\n  enat j < llength lst\n\ngoal (1 subgoal):\n 1. j < length (list_of (ltake (enat (Suc (max i j))) lst))", "apply(subst length_list_of_conv_the_enat,force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat i < llength lst; enat j < llength lst\\<rbrakk>\n    \\<Longrightarrow> j < the_enat\n                           (llength (ltake (enat (Suc (max i j))) lst))", "by(cases \"llength lst\", auto simp:min_enat2_conv_enat min_enat1_conv_enat)"], ["proof (state)\nthis:\n  j < length (list_of (ltake (enat (Suc (max i j))) lst))\n\ngoal (1 subgoal):\n 1. i = j", "have ile:\"i < length (list_of (ltake (enat (Suc (max i j))) lst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (list_of (ltake (enat (Suc (max i j))) lst))", "using assms(4,5)"], ["proof (prove)\nusing this:\n  enat i < llength lst\n  enat j < llength lst\n\ngoal (1 subgoal):\n 1. i < length (list_of (ltake (enat (Suc (max i j))) lst))", "apply(subst length_list_of_conv_the_enat,force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>enat i < llength lst; enat j < llength lst\\<rbrakk>\n    \\<Longrightarrow> i < the_enat\n                           (llength (ltake (enat (Suc (max i j))) lst))", "by(cases \"llength lst\", auto simp:min_enat2_conv_enat min_enat1_conv_enat)"], ["proof (state)\nthis:\n  i < length (list_of (ltake (enat (Suc (max i j))) lst))\n\ngoal (1 subgoal):\n 1. i = j", "have \"enat i < ?maxij\" \"enat j < ?maxij\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat i < enat (Suc (max i j)) &&& enat j < enat (Suc (max i j))", "by auto"], ["proof (state)\nthis:\n  enat i < enat (Suc (max i j))\n  enat j < enat (Suc (max i j))\n\ngoal (1 subgoal):\n 1. i = j", "from this[THEN lnth_ltake,of lst] assms"], ["proof (chain)\npicking this:\n  ltake (enat (Suc (max i j))) lst $ i = lst $ i\n  ltake (enat (Suc (max i j))) lst $ j = lst $ j\n  ldistinct (lfilter P lst)\n  e = lst $ i\n  e = lst $ j\n  enat i < llength lst\n  enat j < llength lst\n  P e", "have \"ldistinct (lfilter P ?lst)\" \"e = ?lst $ i\" \"e = ?lst $ j\""], ["proof (prove)\nusing this:\n  ltake (enat (Suc (max i j))) lst $ i = lst $ i\n  ltake (enat (Suc (max i j))) lst $ j = lst $ j\n  ldistinct (lfilter P lst)\n  e = lst $ i\n  e = lst $ j\n  enat i < llength lst\n  enat j < llength lst\n  P e\n\ngoal (1 subgoal):\n 1. ldistinct (lfilter P (ltake (enat (Suc (max i j))) lst)) &&&\n    e = ltake (enat (Suc (max i j))) lst $ i &&&\n    e = ltake (enat (Suc (max i j))) lst $ j", "by auto"], ["proof (state)\nthis:\n  ldistinct (lfilter P (ltake (enat (Suc (max i j))) lst))\n  e = ltake (enat (Suc (max i j))) lst $ i\n  e = ltake (enat (Suc (max i j))) lst $ j\n\ngoal (1 subgoal):\n 1. i = j", "hence d:\"distinct (filter P (list_of ?lst))\"\n       \"(list_of ?lst) ! j = e\" \"(list_of ?lst) ! i = e\""], ["proof (prove)\nusing this:\n  ldistinct (lfilter P (ltake (enat (Suc (max i j))) lst))\n  e = ltake (enat (Suc (max i j))) lst $ i\n  e = ltake (enat (Suc (max i j))) lst $ j\n\ngoal (1 subgoal):\n 1. distinct (filter P (list_of (ltake (enat (Suc (max i j))) lst))) &&&\n    list_of (ltake (enat (Suc (max i j))) lst) ! j = e &&&\n    list_of (ltake (enat (Suc (max i j))) lst) ! i = e", "using lfilter_llist_of[of P \"list_of ?lst\"]"], ["proof (prove)\nusing this:\n  ldistinct (lfilter P (ltake (enat (Suc (max i j))) lst))\n  e = ltake (enat (Suc (max i j))) lst $ i\n  e = ltake (enat (Suc (max i j))) lst $ j\n  lfilter P (llist_of (list_of (ltake (enat (Suc (max i j))) lst))) =\n  llist_of (filter P (list_of (ltake (enat (Suc (max i j))) lst)))\n\ngoal (1 subgoal):\n 1. distinct (filter P (list_of (ltake (enat (Suc (max i j))) lst))) &&&\n    list_of (ltake (enat (Suc (max i j))) lst) ! j = e &&&\n    list_of (ltake (enat (Suc (max i j))) lst) ! i = e", "by auto"], ["proof (state)\nthis:\n  distinct (filter P (list_of (ltake (enat (Suc (max i j))) lst)))\n  list_of (ltake (enat (Suc (max i j))) lst) ! j = e\n  list_of (ltake (enat (Suc (max i j))) lst) ! i = e\n\ngoal (1 subgoal):\n 1. i = j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j", "by(rule distinct_filterD[OF d(1) jle ile assms(6) d(2,3)])"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ldistinct_lfilter_conv:\n  \"ldistinct (lfilter P lst) = (\\<forall> i j. i < llength lst \\<longrightarrow> j < llength lst \\<longrightarrow> P (lst $ i) \\<longrightarrow> lst $ i = lst $ j \\<longrightarrow> i = j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst) =\n    (\\<forall>i j.\n        enat i < llength lst \\<longrightarrow>\n        enat j < llength lst \\<longrightarrow>\n        P (lst $ i) \\<longrightarrow>\n        lst $ i = lst $ j \\<longrightarrow> i = j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ldistinct (lfilter P lst) \\<Longrightarrow>\n    \\<forall>i j.\n       enat i < llength lst \\<longrightarrow>\n       enat j < llength lst \\<longrightarrow>\n       P (lst $ i) \\<longrightarrow>\n       lst $ i = lst $ j \\<longrightarrow> i = j\n 2. \\<forall>i j.\n       enat i < llength lst \\<longrightarrow>\n       enat j < llength lst \\<longrightarrow>\n       P (lst $ i) \\<longrightarrow>\n       lst $ i = lst $ j \\<longrightarrow> i = j \\<Longrightarrow>\n    ldistinct (lfilter P lst)", "show \"ldistinct (lfilter P lst) \\<Longrightarrow> \\<forall>i j. enat i < llength lst \\<longrightarrow> enat j < llength lst \\<longrightarrow> P (lst $ i) \\<longrightarrow> lst $ i = lst $ j \\<longrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldistinct (lfilter P lst) \\<Longrightarrow>\n    \\<forall>i j.\n       enat i < llength lst \\<longrightarrow>\n       enat j < llength lst \\<longrightarrow>\n       P (lst $ i) \\<longrightarrow>\n       lst $ i = lst $ j \\<longrightarrow> i = j", "by (auto simp add: ldistinct_lfilterE)"], ["proof (state)\nthis:\n  ldistinct (lfilter P lst) \\<Longrightarrow>\n  \\<forall>i j.\n     enat i < llength lst \\<longrightarrow>\n     enat j < llength lst \\<longrightarrow>\n     P (lst $ i) \\<longrightarrow> lst $ i = lst $ j \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       enat i < llength lst \\<longrightarrow>\n       enat j < llength lst \\<longrightarrow>\n       P (lst $ i) \\<longrightarrow>\n       lst $ i = lst $ j \\<longrightarrow> i = j \\<Longrightarrow>\n    ldistinct (lfilter P lst)", "show \"\\<forall>i j. enat i < llength lst \\<longrightarrow> enat j < llength lst \\<longrightarrow> P (lst $ i) \\<longrightarrow> lst $ i = lst $ j \\<longrightarrow> i = j \\<Longrightarrow> ldistinct (lfilter P lst) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       enat i < llength lst \\<longrightarrow>\n       enat j < llength lst \\<longrightarrow>\n       P (lst $ i) \\<longrightarrow>\n       lst $ i = lst $ j \\<longrightarrow> i = j \\<Longrightarrow>\n    ldistinct (lfilter P lst)", "using ldistinct_lfilterI"], ["proof (prove)\nusing this:\n  (\\<And>i j.\n      \\<lbrakk>enat i < llength ?lst; enat j < llength ?lst;\n       ?lst $ i = ?lst $ j; ?P (?lst $ i)\\<rbrakk>\n      \\<Longrightarrow> i = j) \\<Longrightarrow>\n  ldistinct (lfilter ?P ?lst)\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       enat i < llength lst \\<longrightarrow>\n       enat j < llength lst \\<longrightarrow>\n       P (lst $ i) \\<longrightarrow>\n       lst $ i = lst $ j \\<longrightarrow> i = j \\<Longrightarrow>\n    ldistinct (lfilter P lst)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i j.\n     enat i < llength lst \\<longrightarrow>\n     enat j < llength lst \\<longrightarrow>\n     P (lst $ i) \\<longrightarrow>\n     lst $ i = lst $ j \\<longrightarrow> i = j \\<Longrightarrow>\n  ldistinct (lfilter P lst)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}