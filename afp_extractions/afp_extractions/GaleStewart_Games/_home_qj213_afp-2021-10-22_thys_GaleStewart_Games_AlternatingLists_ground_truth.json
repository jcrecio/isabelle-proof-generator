{"file_name": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games/AlternatingLists.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games", "problem_names": ["lemma lalternate_ltake:\n  \"ltake (enat n) (lalternate xs) = lalternate (ltake (2*n) xs)\"", "lemma lalternate_llist_of[simp]:\n  \"lalternate (llist_of xs) = llist_of (alternate xs)\"", "lemma lalternate_finite_helper: (* The other direction is proved later, added as SIMP rule *)\n  assumes \"lfinite (lalternate xs)\"\n  shows \"lfinite xs\"", "lemma alternate_list_of: (* Note that this only holds for finite lists,\n                    as the other direction is left undefined with arguments (not just undefined) *)\n  assumes \"lfinite xs\"\n  shows \"alternate (list_of xs) = list_of (lalternate xs)\"", "lemma alternate_length:\n  \"length (alternate xs) = (1+length xs) div 2\"", "lemma lalternate_llength:\n  \"llength (lalternate xs) * 2 = (1+llength xs) \\<or> llength (lalternate xs) * 2 = llength xs\"", "lemma lalternate_finite[simp]:\n  shows \"lfinite (lalternate xs) = lfinite xs\"", "lemma nth_alternate:\n  assumes \"2*n < length xs\"\n  shows \"alternate xs ! n = xs ! (2 * n)\"", "lemma lnth_lalternate:\n  assumes \"2*n < llength xs\"\n  shows \"lalternate xs $ n = xs $ (2 * n)\"", "lemma lnth_lalternate2[simp]:\n  assumes \"n < llength (lalternate xs)\"\n  shows \"lalternate xs $ n = xs $ (2 * n)\""], "translations": [["", "lemma lalternate_ltake:\n  \"ltake (enat n) (lalternate xs) = lalternate (ltake (2*n) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat n) (lalternate xs) = lalternate (ltake (enat (2 * n)) xs)", "proof(induct n arbitrary:xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ltake (enat 0) (lalternate xs) = lalternate (ltake (enat (2 * 0)) xs)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (lalternate xs) =\n           lalternate (ltake (enat (2 * n)) xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       ltake (enat 0) (lalternate xs) = lalternate (ltake (enat (2 * 0)) xs)\n 2. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (lalternate xs) =\n           lalternate (ltake (enat (2 * n)) xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 0) (lalternate xs) = lalternate (ltake (enat (2 * 0)) xs)", "by (metis LNil_eq_ltake_iff enat_defs(1) lalternate.ctr(1) lnull_def mult_zero_right)"], ["proof (state)\nthis:\n  ltake (enat 0) (lalternate xs) = lalternate (ltake (enat (2 * 0)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (lalternate xs) =\n           lalternate (ltake (enat (2 * n)) xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (lalternate xs) =\n           lalternate (ltake (enat (2 * n)) xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "case (Suc n)"], ["proof (state)\nthis:\n  ltake (enat n) (lalternate ?xs) = lalternate (ltake (enat (2 * n)) ?xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (lalternate xs) =\n           lalternate (ltake (enat (2 * n)) xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "hence lt:\"ltake (enat n) (lalternate (ltl (ltl xs))) = lalternate (ltake (enat (2 * n)) (ltl (ltl xs)))\""], ["proof (prove)\nusing this:\n  ltake (enat n) (lalternate ?xs) = lalternate (ltake (enat (2 * n)) ?xs)\n\ngoal (1 subgoal):\n 1. ltake (enat n) (lalternate (ltl (ltl xs))) =\n    lalternate (ltake (enat (2 * n)) (ltl (ltl xs)))", "."], ["proof (state)\nthis:\n  ltake (enat n) (lalternate (ltl (ltl xs))) =\n  lalternate (ltake (enat (2 * n)) (ltl (ltl xs)))\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       (\\<And>xs.\n           ltake (enat n) (lalternate xs) =\n           lalternate (ltake (enat (2 * n)) xs)) \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (2 * Suc n)) xs)", "proof(cases \"lalternate xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lalternate xs = LNil \\<Longrightarrow>\n    ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (2 * Suc n)) xs)\n 2. \\<And>x21 x22.\n       lalternate xs = LCons x21 x22 \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "case LNil"], ["proof (state)\nthis:\n  lalternate xs = LNil\n\ngoal (2 subgoals):\n 1. lalternate xs = LNil \\<Longrightarrow>\n    ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (2 * Suc n)) xs)\n 2. \\<And>x21 x22.\n       lalternate xs = LCons x21 x22 \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "then"], ["proof (chain)\npicking this:\n  lalternate xs = LNil", "show ?thesis"], ["proof (prove)\nusing this:\n  lalternate xs = LNil\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (2 * Suc n)) xs)", "by(metis lalternate.disc(2) lnull_def ltake_LNil)"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (lalternate xs) =\n  lalternate (ltake (enat (2 * Suc n)) xs)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lalternate xs = LCons x21 x22 \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lalternate xs = LCons x21 x22 \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "case (LCons x21 x22)"], ["proof (state)\nthis:\n  lalternate xs = LCons x21 x22\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       lalternate xs = LCons x21 x22 \\<Longrightarrow>\n       ltake (enat (Suc n)) (lalternate xs) =\n       lalternate (ltake (enat (2 * Suc n)) xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  lalternate xs = LCons x21 x22\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (2 * Suc n)) xs)", "unfolding ltake_ltl mult_Suc_right add_2_eq_Suc"], ["proof (prove)\nusing this:\n  lalternate xs = LCons x21 x22\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (Suc (Suc (2 * n)))) xs)", "using eSuc_enat lalternate.code lalternate.ctr(1) lhd_LCons_ltl llist.sel(1)"], ["proof (prove)\nusing this:\n  lalternate xs = LCons x21 x22\n  eSuc (enat ?n) = enat (Suc ?n)\n  lalternate ?xs =\n  (case ?xs of LNil \\<Rightarrow> LNil\n   | LCons x xs \\<Rightarrow> LCons x (lalternate (ltl xs)))\n  lnull ?xs \\<Longrightarrow> lalternate ?xs = LNil\n  \\<not> lnull ?llist \\<Longrightarrow>\n  LCons (lhd ?llist) (ltl ?llist) = ?llist\n  lhd (LCons ?x21.0 ?x22.0) = ?x21.0\n\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (lalternate xs) =\n    lalternate (ltake (enat (Suc (Suc (2 * n)))) xs)", "by (smt (z3) lt ltake_ltl llist.simps(3) llist.simps(5) ltake_eSuc_LCons)"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (lalternate xs) =\n  lalternate (ltake (enat (2 * Suc n)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ltake (enat (Suc n)) (lalternate xs) =\n  lalternate (ltake (enat (2 * Suc n)) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lalternate_llist_of[simp]:\n  \"lalternate (llist_of xs) = llist_of (alternate xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lalternate (llist_of xs) = llist_of (alternate xs)", "proof(induct \"alternate xs\" arbitrary:xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       [] = alternate xs \\<Longrightarrow>\n       lalternate (llist_of xs) = llist_of (alternate xs)\n 2. \\<And>a x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = alternate xs \\<Longrightarrow>\n                   lalternate (llist_of xs) = llist_of (alternate xs);\n        a # x = alternate xs\\<rbrakk>\n       \\<Longrightarrow> lalternate (llist_of xs) = llist_of (alternate xs)", "case Nil"], ["proof (state)\nthis:\n  [] = alternate xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       [] = alternate xs \\<Longrightarrow>\n       lalternate (llist_of xs) = llist_of (alternate xs)\n 2. \\<And>a x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = alternate xs \\<Longrightarrow>\n                   lalternate (llist_of xs) = llist_of (alternate xs);\n        a # x = alternate xs\\<rbrakk>\n       \\<Longrightarrow> lalternate (llist_of xs) = llist_of (alternate xs)", "then"], ["proof (chain)\npicking this:\n  [] = alternate xs", "show ?case"], ["proof (prove)\nusing this:\n  [] = alternate xs\n\ngoal (1 subgoal):\n 1. lalternate (llist_of xs) = llist_of (alternate xs)", "by (metis alternate.elims lalternate.ctr(1) list.simps(3) llist_of.simps(1) lnull_llist_of)"], ["proof (state)\nthis:\n  lalternate (llist_of xs) = llist_of (alternate xs)\n\ngoal (1 subgoal):\n 1. \\<And>a x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = alternate xs \\<Longrightarrow>\n                   lalternate (llist_of xs) = llist_of (alternate xs);\n        a # x = alternate xs\\<rbrakk>\n       \\<Longrightarrow> lalternate (llist_of xs) = llist_of (alternate xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = alternate xs \\<Longrightarrow>\n                   lalternate (llist_of xs) = llist_of (alternate xs);\n        a # x = alternate xs\\<rbrakk>\n       \\<Longrightarrow> lalternate (llist_of xs) = llist_of (alternate xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  xsa__ = alternate ?xs \\<Longrightarrow>\n  lalternate (llist_of ?xs) = llist_of (alternate ?xs)\n  a # xsa__ = alternate xs\n\ngoal (1 subgoal):\n 1. \\<And>a x xs.\n       \\<lbrakk>\\<And>xs.\n                   x = alternate xs \\<Longrightarrow>\n                   lalternate (llist_of xs) = llist_of (alternate xs);\n        a # x = alternate xs\\<rbrakk>\n       \\<Longrightarrow> lalternate (llist_of xs) = llist_of (alternate xs)", "then"], ["proof (chain)\npicking this:\n  xsa__ = alternate ?xs \\<Longrightarrow>\n  lalternate (llist_of ?xs) = llist_of (alternate ?xs)\n  a # xsa__ = alternate xs", "show ?case"], ["proof (prove)\nusing this:\n  xsa__ = alternate ?xs \\<Longrightarrow>\n  lalternate (llist_of ?xs) = llist_of (alternate ?xs)\n  a # xsa__ = alternate xs\n\ngoal (1 subgoal):\n 1. lalternate (llist_of xs) = llist_of (alternate xs)", "by(cases xs,auto simp: lalternate.ctr)"], ["proof (state)\nthis:\n  lalternate (llist_of xs) = llist_of (alternate xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lalternate_finite_helper: (* The other direction is proved later, added as SIMP rule *)\n  assumes \"lfinite (lalternate xs)\"\n  shows \"lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite xs", "using assms"], ["proof (prove)\nusing this:\n  lfinite (lalternate xs)\n\ngoal (1 subgoal):\n 1. lfinite xs", "proof(induct \"lalternate xs\" arbitrary:xs rule:lfinite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs. lnull (lalternate xs) \\<Longrightarrow> lfinite xs\n 2. \\<And>xs.\n       \\<lbrakk>lfinite (lalternate xs); \\<not> lnull (lalternate xs);\n        \\<And>xsa.\n           ltl (lalternate xs) = lalternate xsa \\<Longrightarrow>\n           lfinite xsa\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "case LNil"], ["proof (state)\nthis:\n  lnull (lalternate xs)\n\ngoal (2 subgoals):\n 1. \\<And>xs. lnull (lalternate xs) \\<Longrightarrow> lfinite xs\n 2. \\<And>xs.\n       \\<lbrakk>lfinite (lalternate xs); \\<not> lnull (lalternate xs);\n        \\<And>xsa.\n           ltl (lalternate xs) = lalternate xsa \\<Longrightarrow>\n           lfinite xsa\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "then"], ["proof (chain)\npicking this:\n  lnull (lalternate xs)", "show ?case"], ["proof (prove)\nusing this:\n  lnull (lalternate xs)\n\ngoal (1 subgoal):\n 1. lfinite xs", "unfolding lalternate.code[of xs]"], ["proof (prove)\nusing this:\n  lnull\n   (case xs of LNil \\<Rightarrow> LNil\n    | LCons x xs \\<Rightarrow> LCons x (lalternate (ltl xs)))\n\ngoal (1 subgoal):\n 1. lfinite xs", "by(cases xs;auto)"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lalternate xs); \\<not> lnull (lalternate xs);\n        \\<And>xsa.\n           ltl (lalternate xs) = lalternate xsa \\<Longrightarrow>\n           lfinite xsa\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lalternate xs); \\<not> lnull (lalternate xs);\n        \\<And>xsa.\n           ltl (lalternate xs) = lalternate xsa \\<Longrightarrow>\n           lfinite xsa\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "case (LCons xs)"], ["proof (state)\nthis:\n  lfinite (lalternate xs)\n  \\<not> lnull (lalternate xs)\n  ltl (lalternate xs) = lalternate ?xs \\<Longrightarrow> lfinite ?xs\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>lfinite (lalternate xs); \\<not> lnull (lalternate xs);\n        \\<And>xsa.\n           ltl (lalternate xs) = lalternate xsa \\<Longrightarrow>\n           lfinite xsa\\<rbrakk>\n       \\<Longrightarrow> lfinite xs", "then"], ["proof (chain)\npicking this:\n  lfinite (lalternate xs)\n  \\<not> lnull (lalternate xs)\n  ltl (lalternate xs) = lalternate ?xs \\<Longrightarrow> lfinite ?xs", "show ?case"], ["proof (prove)\nusing this:\n  lfinite (lalternate xs)\n  \\<not> lnull (lalternate xs)\n  ltl (lalternate xs) = lalternate ?xs \\<Longrightarrow> lfinite ?xs\n\ngoal (1 subgoal):\n 1. lfinite xs", "unfolding lalternate.code[of xs]"], ["proof (prove)\nusing this:\n  lfinite\n   (case xs of LNil \\<Rightarrow> LNil\n    | LCons x xs \\<Rightarrow> LCons x (lalternate (ltl xs)))\n  \\<not> lnull\n          (case xs of LNil \\<Rightarrow> LNil\n           | LCons x xs \\<Rightarrow> LCons x (lalternate (ltl xs)))\n  ltl (case xs of LNil \\<Rightarrow> LNil\n       | LCons x xs \\<Rightarrow> LCons x (lalternate (ltl xs))) =\n  lalternate ?xs \\<Longrightarrow>\n  lfinite ?xs\n\ngoal (1 subgoal):\n 1. lfinite xs", "by(cases \"xs\";cases \"ltl xs\";auto)"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alternate_list_of: (* Note that this only holds for finite lists,\n                    as the other direction is left undefined with arguments (not just undefined) *)\n  assumes \"lfinite xs\"\n  shows \"alternate (list_of xs) = list_of (lalternate xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternate (list_of xs) = list_of (lalternate xs)", "using assms"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. alternate (list_of xs) = list_of (lalternate xs)", "by (metis lalternate_llist_of list_of_llist_of llist_of_list_of)"], ["", "lemma alternate_length:\n  \"length (alternate xs) = (1+length xs) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (alternate xs) = (1 + length xs) div 2", "by (induct xs rule:induct_list012;simp)"], ["", "lemma lalternate_llength:\n  \"llength (lalternate xs) * 2 = (1+llength xs) \\<or> llength (lalternate xs) * 2 = llength xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "let ?xs = \"list_of xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "have \"length (alternate ?xs) = (1+length ?xs) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (alternate (list_of xs)) = (1 + length (list_of xs)) div 2", "using alternate_length"], ["proof (prove)\nusing this:\n  length (alternate ?xs) = (1 + length ?xs) div 2\n\ngoal (1 subgoal):\n 1. length (alternate (list_of xs)) = (1 + length (list_of xs)) div 2", "by auto"], ["proof (state)\nthis:\n  length (alternate (list_of xs)) = (1 + length (list_of xs)) div 2\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "hence \"length (alternate ?xs) * 2 = (1+length ?xs) \\<or> length (alternate ?xs) * 2 = length ?xs\""], ["proof (prove)\nusing this:\n  length (alternate (list_of xs)) = (1 + length (list_of xs)) div 2\n\ngoal (1 subgoal):\n 1. length (alternate (list_of xs)) * 2 = 1 + length (list_of xs) \\<or>\n    length (alternate (list_of xs)) * 2 = length (list_of xs)", "by auto"], ["proof (state)\nthis:\n  length (alternate (list_of xs)) * 2 = 1 + length (list_of xs) \\<or>\n  length (alternate (list_of xs)) * 2 = length (list_of xs)\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs\n 2. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "then"], ["proof (chain)\npicking this:\n  length (alternate (list_of xs)) * 2 = 1 + length (list_of xs) \\<or>\n  length (alternate (list_of xs)) * 2 = length (list_of xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (alternate (list_of xs)) * 2 = 1 + length (list_of xs) \\<or>\n  length (alternate (list_of xs)) * 2 = length (list_of xs)\n\ngoal (1 subgoal):\n 1. llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "using alternate_list_of[OF True] lalternate_llist_of True\n    length_list_of_conv_the_enat[OF True] llist_of_list_of[OF True]"], ["proof (prove)\nusing this:\n  length (alternate (list_of xs)) * 2 = 1 + length (list_of xs) \\<or>\n  length (alternate (list_of xs)) * 2 = length (list_of xs)\n  alternate (list_of xs) = list_of (lalternate xs)\n  lalternate (llist_of ?xs) = llist_of (alternate ?xs)\n  lfinite xs\n  length (list_of xs) = the_enat (llength xs)\n  llist_of (list_of xs) = xs\n\ngoal (1 subgoal):\n 1. llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "by (metis llength_llist_of numeral_One of_nat_eq_enat of_nat_mult of_nat_numeral plus_enat_simps(1))"], ["proof (state)\nthis:\n  llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n  llength (lalternate xs) * 2 = llength xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "have \"\\<not> lfinite (lalternate xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lfinite (lalternate xs)", "using False lalternate_finite_helper"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n  lfinite (lalternate ?xs) \\<Longrightarrow> lfinite ?xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite (lalternate xs)", "by auto"], ["proof (state)\nthis:\n  \\<not> lfinite (lalternate xs)\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "hence l1:\"llength (lalternate xs) = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> lfinite (lalternate xs)\n\ngoal (1 subgoal):\n 1. llength (lalternate xs) = \\<infinity>", "by(rule not_lfinite_llength)"], ["proof (state)\nthis:\n  llength (lalternate xs) = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "from False"], ["proof (chain)\npicking this:\n  \\<not> lfinite xs", "have l2:\"llength xs = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. llength xs = \\<infinity>", "using not_lfinite_llength"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n  \\<not> lfinite ?xs \\<Longrightarrow> llength ?xs = \\<infinity>\n\ngoal (1 subgoal):\n 1. llength xs = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  llength xs = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow>\n    llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "using l1 l2"], ["proof (prove)\nusing this:\n  llength (lalternate xs) = \\<infinity>\n  llength xs = \\<infinity>\n\ngoal (1 subgoal):\n 1. llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n    llength (lalternate xs) * 2 = llength xs", "by (simp add: mult_2_right)"], ["proof (state)\nthis:\n  llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n  llength (lalternate xs) * 2 = llength xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lalternate_finite[simp]:\n  shows \"lfinite (lalternate xs) = lfinite xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfinite (lalternate xs) = lfinite xs", "proof(cases \"lfinite xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs\n 2. \\<not> lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "case True"], ["proof (state)\nthis:\n  lfinite xs\n\ngoal (2 subgoals):\n 1. lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs\n 2. \\<not> lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "then"], ["proof (chain)\npicking this:\n  lfinite xs", "show ?thesis"], ["proof (prove)\nusing this:\n  lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lalternate xs) = lfinite xs", "proof(cases \"lfinite (lalternate xs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lfinite xs; lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs\n 2. \\<lbrakk>lfinite xs; \\<not> lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite (lalternate xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lfinite xs; lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs\n 2. \\<lbrakk>lfinite xs; \\<not> lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "hence False"], ["proof (prove)\nusing this:\n  \\<not> lfinite (lalternate xs)\n\ngoal (1 subgoal):\n 1. False", "using not_lfinite_llength[OF False] True[unfolded lfinite_conv_llength_enat]\n                      lalternate_llength[of xs]"], ["proof (prove)\nusing this:\n  \\<not> lfinite (lalternate xs)\n  llength (lalternate xs) = \\<infinity>\n  \\<exists>n. llength xs = enat n\n  llength (lalternate xs) * 2 = 1 + llength xs \\<or>\n  llength (lalternate xs) * 2 = llength xs\n\ngoal (1 subgoal):\n 1. False", "by (auto simp:one_enat_def numeral_eq_enat)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lfinite xs; lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs\n 2. \\<lbrakk>lfinite xs; \\<not> lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. lfinite (lalternate xs) = lfinite xs", "by metis"], ["proof (state)\nthis:\n  lfinite (lalternate xs) = lfinite xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lfinite xs; lfinite (lalternate xs)\\<rbrakk>\n    \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "qed auto"], ["proof (state)\nthis:\n  lfinite (lalternate xs) = lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "case False"], ["proof (state)\nthis:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. \\<not> lfinite xs \\<Longrightarrow> lfinite (lalternate xs) = lfinite xs", "then"], ["proof (chain)\npicking this:\n  \\<not> lfinite xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n\ngoal (1 subgoal):\n 1. lfinite (lalternate xs) = lfinite xs", "using lalternate_finite_helper"], ["proof (prove)\nusing this:\n  \\<not> lfinite xs\n  lfinite (lalternate ?xs) \\<Longrightarrow> lfinite ?xs\n\ngoal (1 subgoal):\n 1. lfinite (lalternate xs) = lfinite xs", "by blast"], ["proof (state)\nthis:\n  lfinite (lalternate xs) = lfinite xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_alternate:\n  assumes \"2*n < length xs\"\n  shows \"alternate xs ! n = xs ! (2 * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alternate xs ! n = xs ! (2 * n)", "using assms"], ["proof (prove)\nusing this:\n  2 * n < length xs\n\ngoal (1 subgoal):\n 1. alternate xs ! n = xs ! (2 * n)", "proof (induct xs arbitrary:n rule:induct_list012)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       2 * n < length [] \\<Longrightarrow> alternate [] ! n = [] ! (2 * n)\n 2. \\<And>x n.\n       2 * n < length [x] \\<Longrightarrow>\n       alternate [x] ! n = [x] ! (2 * n)\n 3. \\<And>x y zs n.\n       \\<lbrakk>\\<And>n.\n                   2 * n < length zs \\<Longrightarrow>\n                   alternate zs ! n = zs ! (2 * n);\n        \\<And>n.\n           2 * n < length (y # zs) \\<Longrightarrow>\n           alternate (y # zs) ! n = (y # zs) ! (2 * n);\n        2 * n < length (x # y # zs)\\<rbrakk>\n       \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "case (3 x y zs)"], ["proof (state)\nthis:\n  2 * ?n < length zs \\<Longrightarrow> alternate zs ! ?n = zs ! (2 * ?n)\n  2 * ?n < length (y # zs) \\<Longrightarrow>\n  alternate (y # zs) ! ?n = (y # zs) ! (2 * ?n)\n  2 * n < length (x # y # zs)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       2 * n < length [] \\<Longrightarrow> alternate [] ! n = [] ! (2 * n)\n 2. \\<And>x n.\n       2 * n < length [x] \\<Longrightarrow>\n       alternate [x] ! n = [x] ! (2 * n)\n 3. \\<And>x y zs n.\n       \\<lbrakk>\\<And>n.\n                   2 * n < length zs \\<Longrightarrow>\n                   alternate zs ! n = zs ! (2 * n);\n        \\<And>n.\n           2 * n < length (y # zs) \\<Longrightarrow>\n           alternate (y # zs) ! n = (y # zs) ! (2 * n);\n        2 * n < length (x # y # zs)\\<rbrakk>\n       \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "then"], ["proof (chain)\npicking this:\n  2 * ?n < length zs \\<Longrightarrow> alternate zs ! ?n = zs ! (2 * ?n)\n  2 * ?n < length (y # zs) \\<Longrightarrow>\n  alternate (y # zs) ! ?n = (y # zs) ! (2 * ?n)\n  2 * n < length (x # y # zs)", "show ?case"], ["proof (prove)\nusing this:\n  2 * ?n < length zs \\<Longrightarrow> alternate zs ! ?n = zs ! (2 * ?n)\n  2 * ?n < length (y # zs) \\<Longrightarrow>\n  alternate (y # zs) ! ?n = (y # zs) ! (2 * ?n)\n  2 * n < length (x # y # zs)\n\ngoal (1 subgoal):\n 1. alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                2 * n < length zs \\<Longrightarrow>\n                alternate zs ! n = zs ! (2 * n);\n     \\<And>n.\n        2 * n < length (y # zs) \\<Longrightarrow>\n        alternate (y # zs) ! n = (y # zs) ! (2 * n);\n     2 * n < length (x # y # zs); n = 0\\<rbrakk>\n    \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   2 * n < length zs \\<Longrightarrow>\n                   alternate zs ! n = zs ! (2 * n);\n        \\<And>n.\n           2 * n < length (y # zs) \\<Longrightarrow>\n           alternate (y # zs) ! n = (y # zs) ! (2 * n);\n        2 * n < length (x # y # zs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "case (Suc nat)"], ["proof (state)\nthis:\n  n = Suc nat\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n.\n                2 * n < length zs \\<Longrightarrow>\n                alternate zs ! n = zs ! (2 * n);\n     \\<And>n.\n        2 * n < length (y # zs) \\<Longrightarrow>\n        alternate (y # zs) ! n = (y # zs) ! (2 * n);\n     2 * n < length (x # y # zs); n = 0\\<rbrakk>\n    \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>n.\n                   2 * n < length zs \\<Longrightarrow>\n                   alternate zs ! n = zs ! (2 * n);\n        \\<And>n.\n           2 * n < length (y # zs) \\<Longrightarrow>\n           alternate (y # zs) ! n = (y # zs) ! (2 * n);\n        2 * n < length (x # y # zs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "using \"3.hyps\"(1) \"3.prems\" Suc"], ["proof (prove)\nusing this:\n  2 * ?n < length zs \\<Longrightarrow> alternate zs ! ?n = zs ! (2 * ?n)\n  2 * n < length (x # y # zs)\n  n = Suc nat\n\ngoal (1 subgoal):\n 1. alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "by force"], ["proof (state)\nthis:\n  alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                2 * n < length zs \\<Longrightarrow>\n                alternate zs ! n = zs ! (2 * n);\n     \\<And>n.\n        2 * n < length (y # zs) \\<Longrightarrow>\n        alternate (y # zs) ! n = (y # zs) ! (2 * n);\n     2 * n < length (x # y # zs); n = 0\\<rbrakk>\n    \\<Longrightarrow> alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)", "qed simp"], ["proof (state)\nthis:\n  alternate (x # y # zs) ! n = (x # y # zs) ! (2 * n)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       2 * n < length [] \\<Longrightarrow> alternate [] ! n = [] ! (2 * n)\n 2. \\<And>x n.\n       2 * n < length [x] \\<Longrightarrow>\n       alternate [x] ! n = [x] ! (2 * n)", "qed auto"], ["", "lemma lnth_lalternate:\n  assumes \"2*n < llength xs\"\n  shows \"lalternate xs $ n = xs $ (2 * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "let ?xs = \"ltake (2*Suc n) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "have \"lalternate ?xs $ n = ?xs $ (2 * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lalternate (ltake (enat (2 * Suc n)) xs) $ n =\n    ltake (enat (2 * Suc n)) xs $ 2 * n", "using assms alternate_list_of[of \"ltake (2*Suc n) xs\"] nth_alternate[of n \"list_of ?xs\"]"], ["proof (prove)\nusing this:\n  2 * enat n < llength xs\n  lfinite (ltake (enat (2 * Suc n)) xs) \\<Longrightarrow>\n  alternate (list_of (ltake (enat (2 * Suc n)) xs)) =\n  list_of (lalternate (ltake (enat (2 * Suc n)) xs))\n  2 * n < length (list_of (ltake (enat (2 * Suc n)) xs)) \\<Longrightarrow>\n  alternate (list_of (ltake (enat (2 * Suc n)) xs)) ! n =\n  list_of (ltake (enat (2 * Suc n)) xs) ! (2 * n)\n\ngoal (1 subgoal):\n 1. lalternate (ltake (enat (2 * Suc n)) xs) $ n =\n    ltake (enat (2 * Suc n)) xs $ 2 * n", "by (smt (z3) Suc_1 Suc_mult_less_cancel1 enat_ord_simps(2) infinite_small_llength lalternate_ltake length_list_of lessI llength_eq_enat_lfiniteD llength_ltake' ltake_all not_less nth_list_of numeral_eq_enat the_enat.simps times_enat_simps(1))"], ["proof (state)\nthis:\n  lalternate (ltake (enat (2 * Suc n)) xs) $ n =\n  ltake (enat (2 * Suc n)) xs $ 2 * n\n\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "thus ?thesis"], ["proof (prove)\nusing this:\n  lalternate (ltake (enat (2 * Suc n)) xs) $ n =\n  ltake (enat (2 * Suc n)) xs $ 2 * n\n\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "by (metis Suc_1 Suc_mult_less_cancel1 enat_ord_simps(2) lalternate_ltake lessI lnth_ltake)"], ["proof (state)\nthis:\n  lalternate xs $ n = xs $ 2 * n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lnth_lalternate2[simp]:\n  assumes \"n < llength (lalternate xs)\"\n  shows \"lalternate xs $ n = xs $ (2 * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "from assms"], ["proof (chain)\npicking this:\n  enat n < llength (lalternate xs)", "have \"2*enat n < llength xs\""], ["proof (prove)\nusing this:\n  enat n < llength (lalternate xs)\n\ngoal (1 subgoal):\n 1. 2 * enat n < llength xs", "by (metis enat_numeral lalternate_ltake leI linorder_neq_iff llength_ltake' ltake_all times_enat_simps(1))"], ["proof (state)\nthis:\n  2 * enat n < llength xs\n\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "from lnth_lalternate[OF this]"], ["proof (chain)\npicking this:\n  lalternate xs $ n = xs $ 2 * n", "show ?thesis"], ["proof (prove)\nusing this:\n  lalternate xs $ n = xs $ 2 * n\n\ngoal (1 subgoal):\n 1. lalternate xs $ n = xs $ 2 * n", "."], ["proof (state)\nthis:\n  lalternate xs $ n = xs $ 2 * n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}