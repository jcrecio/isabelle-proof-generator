{"file_name": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games/MorePrefix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/GaleStewart_Games", "problem_names": ["lemma head_prefixes [simp]:\n  \"prefixes list ! 0 = []\"", "lemma non_head_prefixes [simp]:\n  assumes \"n < length p\" shows \"(prefixes p ! Suc n) \\<noteq> []\"", "lemma last_prefixes:\n  assumes \"i < length p\"\n  shows \"last (tl (prefixes p) ! i) = p ! i\"", "lemma take_1_prefixes[simp]:\n  \"take (Suc 0) (prefixes list) = [[]]\"", "lemma map_last_prefixes [simp]:\n  shows \"map last (tl (prefixes p)) = p\"", "lemma ltake_zero[simp]: \"ltake (enat (0::nat)) lst = LNil\"", "lemma ltakes_one_iterates:\n  \"ltake (enat (Suc 0)) (iterates f p) = LCons p LNil\"", "lemma ltakes_suc_iterates[simp]:\n  \"ltake (enat (Suc n)) (iterates f p) = LCons p (ltake (enat n) (iterates f (f p)))\"", "lemma prefixes_nth_take[simp]:\n  assumes \"i \\<le> length p\"\n  shows \"prefixes p ! i = take i p\"", "lemma tl_prefixes_idx:\n  assumes \"i < length p\"\n  shows \"tl (prefixes p) ! i = take (Suc i) p\"", "lemma list_of_lappend_llist_of[simp]:\n  assumes \"lfinite q\"\n  shows \"list_of (lappend (llist_of p) q) = append p (list_of q)\"", "lemma nth_prefixes:\n  \"n < length p \\<Longrightarrow> \\<not> Suc n < length p \\<Longrightarrow> tl (prefixes p) ! n = p\"", "lemma take_Suc_prefix:\n  \"prefix (take n p) (take (Suc n) p)\"", "lemma nth_prefixes_is_prefix:\n  \"n < length p  \\<Longrightarrow> prefix ((prefixes p) ! n) ((prefixes p) ! Suc n)\"", "lemma nth_prefixes_is_prefix_tl:\n  \"Suc n < length p  \\<Longrightarrow> prefix (tl (prefixes p) ! n) (tl (prefixes p) ! Suc n)\"", "lemma prefix_same_length_eq:\n  shows \"(prefix a b \\<and> length a = length b) \\<longleftrightarrow> a = b\"", "lemma prefix_takeI:\n  assumes \"prefix a b\" \"n \\<ge> length a\"\n  shows \"prefix a (take n b)\"", "lemma lprefix_llength_lprefix:\n  assumes \"lprefix a c\" \"lprefix b c\" \"llength a \\<le> llength b\"\n  shows \"lprefix a b\"", "lemma lprefix_ltakeI:\n  assumes \"lprefix a b\" \"llength a \\<le> n\"\n  shows \"lprefix a (ltake n b)\"", "lemma length_augment_list:\n  \"length ((augment_list f ^^ n) p) = n + length p\"", "lemma augment_list_nonempty:\n  assumes \"p\\<noteq>[]\" shows \"(augment_list f ^^ i) p \\<noteq> []\"", "lemma augment_list_Suc_prefix:\n  \"prefix ((augment_list f ^^ n) p) ((augment_list f ^^ Suc n) p)\"", "lemma augment_list_prefix:\n  \"n \\<le> m \\<Longrightarrow> prefix ((augment_list f ^^ n) p) ((augment_list f ^^ m) p)\"", "lemma augment_list_nonsense[dest]:\nassumes \"(augment_list \\<sigma> ^^ n) p = []\"\nshows \"n=0\" \"p=[]\"", "lemma prefix_augment:\n  shows \"prefix p ((augment_list s ^^ n) p)\""], "translations": [["", "lemma head_prefixes [simp]:\n  \"prefixes list ! 0 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixes list ! 0 = []", "by (metis hd_conv_nth hd_prefixes prefixes_not_Nil)"], ["", "lemma non_head_prefixes [simp]:\n  assumes \"n < length p\" shows \"(prefixes p ! Suc n) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixes p ! Suc n \\<noteq> []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prefixes p ! Suc n \\<noteq> []", "have \"0 < length (prefixes p)\" \"Suc n < length (prefixes p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (prefixes p) &&& Suc n < length (prefixes p)", "by (auto simp: assms)"], ["proof (state)\nthis:\n  0 < length (prefixes p)\n  Suc n < length (prefixes p)\n\ngoal (1 subgoal):\n 1. prefixes p ! Suc n \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  0 < length (prefixes p)\n  Suc n < length (prefixes p)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < length (prefixes p)\n  Suc n < length (prefixes p)\n\ngoal (1 subgoal):\n 1. prefixes p ! Suc n \\<noteq> []", "by (metis Zero_not_Suc distinct_prefixes head_prefixes nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  prefixes p ! Suc n \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_prefixes:\n  assumes \"i < length p\"\n  shows \"last (tl (prefixes p) ! i) = p ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (tl (prefixes p) ! i) = p ! i", "using assms"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. last (tl (prefixes p) ! i) = p ! i", "proof(induct p arbitrary:i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow> last (tl (prefixes []) ! i) = [] ! i\n 2. \\<And>a p i.\n       \\<lbrakk>\\<And>i.\n                   i < length p \\<Longrightarrow>\n                   last (tl (prefixes p) ! i) = p ! i;\n        i < length (a # p)\\<rbrakk>\n       \\<Longrightarrow> last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "case (Cons a p i)"], ["proof (state)\nthis:\n  ?i < length p \\<Longrightarrow> last (tl (prefixes p) ! ?i) = p ! ?i\n  i < length (a # p)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow> last (tl (prefixes []) ! i) = [] ! i\n 2. \\<And>a p i.\n       \\<lbrakk>\\<And>i.\n                   i < length p \\<Longrightarrow>\n                   last (tl (prefixes p) ! i) = p ! i;\n        i < length (a # p)\\<rbrakk>\n       \\<Longrightarrow> last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> last (tl (prefixes (a # p)) ! i) = (a # p) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "case (Suc nat)"], ["proof (state)\nthis:\n  i = Suc nat\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> last (tl (prefixes (a # p)) ! i) = (a # p) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "with Cons"], ["proof (chain)\npicking this:\n  ?i < length p \\<Longrightarrow> last (tl (prefixes p) ! ?i) = p ! ?i\n  i < length (a # p)\n  i = Suc nat", "have \"p ! nat = last (tl (prefixes p) ! nat)\" \"nat < length p\""], ["proof (prove)\nusing this:\n  ?i < length p \\<Longrightarrow> last (tl (prefixes p) ! ?i) = p ! ?i\n  i < length (a # p)\n  i = Suc nat\n\ngoal (1 subgoal):\n 1. p ! nat = last (tl (prefixes p) ! nat) &&& nat < length p", "by auto"], ["proof (state)\nthis:\n  p ! nat = last (tl (prefixes p) ! nat)\n  nat < length p\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> last (tl (prefixes (a # p)) ! i) = (a # p) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "then"], ["proof (chain)\npicking this:\n  p ! nat = last (tl (prefixes p) ! nat)\n  nat < length p", "show ?thesis"], ["proof (prove)\nusing this:\n  p ! nat = last (tl (prefixes p) ! nat)\n  nat < length p\n\ngoal (1 subgoal):\n 1. last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "unfolding Suc"], ["proof (prove)\nusing this:\n  p ! nat = last (tl (prefixes p) ! nat)\n  nat < length p\n\ngoal (1 subgoal):\n 1. last (tl (prefixes (a # p)) ! Suc nat) = (a # p) ! Suc nat", "by(auto simp:nth_tl)"], ["proof (state)\nthis:\n  last (tl (prefixes (a # p)) ! i) = (a # p) ! i\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> last (tl (prefixes (a # p)) ! i) = (a # p) ! i", "qed auto"], ["proof (state)\nthis:\n  last (tl (prefixes (a # p)) ! i) = (a # p) ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow> last (tl (prefixes []) ! i) = [] ! i", "qed force"], ["", "lemma take_1_prefixes[simp]:\n  \"take (Suc 0) (prefixes list) = [[]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc 0) (prefixes list) = [[]]", "by (simp add: take_Suc)"], ["", "lemma map_last_prefixes [simp]:\n  shows \"map last (tl (prefixes p)) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map last (tl (prefixes p)) = p", "unfolding list_eq_iff_nth_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map last (tl (prefixes p))) = length p \\<and>\n    (\\<forall>i<length (map last (tl (prefixes p))).\n        map last (tl (prefixes p)) ! i = p ! i)", "using last_prefixes"], ["proof (prove)\nusing this:\n  ?i < length ?p \\<Longrightarrow> last (tl (prefixes ?p) ! ?i) = ?p ! ?i\n\ngoal (1 subgoal):\n 1. length (map last (tl (prefixes p))) = length p \\<and>\n    (\\<forall>i<length (map last (tl (prefixes p))).\n        map last (tl (prefixes p)) ! i = p ! i)", "by auto"], ["", "lemma ltake_zero[simp]: \"ltake (enat (0::nat)) lst = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 0) lst = LNil", "(* nitpick finds a counterexample in Isabelle2021*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat 0) lst = LNil", "by (simp add: zero_enat_def)"], ["", "lemma ltakes_one_iterates:\n  \"ltake (enat (Suc 0)) (iterates f p) = LCons p LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc 0)) (iterates f p) = LCons p LNil", "by (metis One_nat_def iterates_lmap ltake_eSuc_LCons ltake_zero one_eSuc one_enat_def zero_enat_def)"], ["", "lemma ltakes_suc_iterates[simp]:\n  \"ltake (enat (Suc n)) (iterates f p) = LCons p (ltake (enat n) (iterates f (f p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ltake (enat (Suc n)) (iterates f p) =\n    LCons p (ltake (enat n) (iterates f (f p)))", "by (induct n,force simp:ltakes_one_iterates,metis eSuc_enat iterates.code ltake_eSuc_LCons)"], ["", "lemma prefixes_nth_take[simp]:\n  assumes \"i \\<le> length p\"\n  shows \"prefixes p ! i = take i p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixes p ! i = take i p", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> length p\n\ngoal (1 subgoal):\n 1. prefixes p ! i = take i p", "proof(induct p arbitrary:i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> length [] \\<Longrightarrow> prefixes [] ! i = take i []\n 2. \\<And>a p i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length p \\<Longrightarrow>\n                   prefixes p ! i = take i p;\n        i \\<le> length (a # p)\\<rbrakk>\n       \\<Longrightarrow> prefixes (a # p) ! i = take i (a # p)", "case (Cons a p i)"], ["proof (state)\nthis:\n  ?i \\<le> length p \\<Longrightarrow> prefixes p ! ?i = take ?i p\n  i \\<le> length (a # p)\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> length [] \\<Longrightarrow> prefixes [] ! i = take i []\n 2. \\<And>a p i.\n       \\<lbrakk>\\<And>i.\n                   i \\<le> length p \\<Longrightarrow>\n                   prefixes p ! i = take i p;\n        i \\<le> length (a # p)\\<rbrakk>\n       \\<Longrightarrow> prefixes (a # p) ! i = take i (a # p)", "thus ?case"], ["proof (prove)\nusing this:\n  ?i \\<le> length p \\<Longrightarrow> prefixes p ! ?i = take ?i p\n  i \\<le> length (a # p)\n\ngoal (1 subgoal):\n 1. prefixes (a # p) ! i = take i (a # p)", "by (cases i, auto)"], ["proof (state)\nthis:\n  prefixes (a # p) ! i = take i (a # p)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> length [] \\<Longrightarrow> prefixes [] ! i = take i []", "qed auto"], ["", "lemma tl_prefixes_idx:\n  assumes \"i < length p\"\n  shows \"tl (prefixes p) ! i = take (Suc i) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (prefixes p) ! i = take (Suc i) p", "using assms"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. tl (prefixes p) ! i = take (Suc i) p", "by(induct p,auto)"], ["", "lemma list_of_lappend_llist_of[simp]:\n  assumes \"lfinite q\"\n  shows \"list_of (lappend (llist_of p) q) = append p (list_of q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of (lappend (llist_of p) q) = p @ list_of q", "using assms"], ["proof (prove)\nusing this:\n  lfinite q\n\ngoal (1 subgoal):\n 1. list_of (lappend (llist_of p) q) = p @ list_of q", "by(induct p,auto)"], ["", "lemma nth_prefixes:\n  \"n < length p \\<Longrightarrow> \\<not> Suc n < length p \\<Longrightarrow> tl (prefixes p) ! n = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < length p; \\<not> Suc n < length p\\<rbrakk>\n    \\<Longrightarrow> tl (prefixes p) ! n = p", "by(induct p arbitrary:n,auto)"], ["", "lemma take_Suc_prefix:\n  \"prefix (take n p) (take (Suc n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (take n p) (take (Suc n) p)", "proof(induct p arbitrary:n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. prefix (take n []) (take (Suc n) [])\n 2. \\<And>a p n.\n       (\\<And>n. prefix (take n p) (take (Suc n) p)) \\<Longrightarrow>\n       prefix (take n (a # p)) (take (Suc n) (a # p))", "case (Cons a p n)"], ["proof (state)\nthis:\n  prefix (take ?n p) (take (Suc ?n) p)\n\ngoal (2 subgoals):\n 1. \\<And>n. prefix (take n []) (take (Suc n) [])\n 2. \\<And>a p n.\n       (\\<And>n. prefix (take n p) (take (Suc n) p)) \\<Longrightarrow>\n       prefix (take n (a # p)) (take (Suc n) (a # p))", "then"], ["proof (chain)\npicking this:\n  prefix (take ?n p) (take (Suc ?n) p)", "show ?case"], ["proof (prove)\nusing this:\n  prefix (take ?n p) (take (Suc ?n) p)\n\ngoal (1 subgoal):\n 1. prefix (take n (a # p)) (take (Suc n) (a # p))", "by(cases n,auto)"], ["proof (state)\nthis:\n  prefix (take n (a # p)) (take (Suc n) (a # p))\n\ngoal (1 subgoal):\n 1. \\<And>n. prefix (take n []) (take (Suc n) [])", "qed auto"], ["", "lemma nth_prefixes_is_prefix:\n  \"n < length p  \\<Longrightarrow> prefix ((prefixes p) ! n) ((prefixes p) ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length p \\<Longrightarrow>\n    prefix (prefixes p ! n) (prefixes p ! Suc n)", "by(induct \"length p\" n arbitrary:p rule:diff_induct,auto simp:take_Suc_prefix)"], ["", "lemma nth_prefixes_is_prefix_tl:\n  \"Suc n < length p  \\<Longrightarrow> prefix (tl (prefixes p) ! n) (tl (prefixes p) ! Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n < length p \\<Longrightarrow>\n    prefix (tl (prefixes p) ! n) (tl (prefixes p) ! Suc n)", "by (cases p) (auto simp:nth_prefixes_is_prefix take_Suc_prefix)"], ["", "lemma prefix_same_length_eq:\n  shows \"(prefix a b \\<and> length a = length b) \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix a b \\<and> length a = length b) = (a = b)", "by (metis prefix_length_le prefix_length_prefix prefix_order.antisym prefix_order.order_refl)"], ["", "lemma prefix_takeI:\n  assumes \"prefix a b\" \"n \\<ge> length a\"\n  shows \"prefix a (take n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix a (take n b)", "using assms"], ["proof (prove)\nusing this:\n  prefix a b\n  length a \\<le> n\n\ngoal (1 subgoal):\n 1. prefix a (take n b)", "by (smt (verit) prefix_length_prefix length_take min.absorb2 nat_le_linear take_all take_is_prefix)"], ["", "thm prefix_length_prefix"], ["", "(* compare to *)"], ["", "lemma lprefix_llength_lprefix:\n  assumes \"lprefix a c\" \"lprefix b c\" \"llength a \\<le> llength b\"\n  shows \"lprefix a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix a b", "using assms"], ["proof (prove)\nusing this:\n  lprefix a c\n  lprefix b c\n  llength a \\<le> llength b\n\ngoal (1 subgoal):\n 1. lprefix a b", "by (metis dual_order.antisym lprefix_down_linear lprefix_llength_eq_imp_eq lprefix_llength_le)"], ["", "thm prefix_takeI"], ["", "(* compare to *)"], ["", "lemma lprefix_ltakeI:\n  assumes \"lprefix a b\" \"llength a \\<le> n\"\n  shows \"lprefix a (ltake n b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lprefix a (ltake n b)", "by (smt (verit, best) dual_order.antisym lappend_eq_lappend_conv lappend_ltake_ldrop llength_ltake\n                        assms lprefix_conv_lappend lprefix_down_linear lprefix_llength_le min_def)"], ["", "abbreviation augment_list where\n  \"augment_list \\<sigma> p \\<equiv> p @ [\\<sigma> p]\""], ["", "lemma length_augment_list:\n  \"length ((augment_list f ^^ n) p) = n + length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ((augment_list f ^^ n) p) = n + length p", "by(induct n,auto)"], ["", "lemma augment_list_nonempty:\n  assumes \"p\\<noteq>[]\" shows \"(augment_list f ^^ i) p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (augment_list f ^^ i) p \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (augment_list f ^^ i) p \\<noteq> []", "by(cases i,auto)"], ["", "lemma augment_list_Suc_prefix:\n  \"prefix ((augment_list f ^^ n) p) ((augment_list f ^^ Suc n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix ((augment_list f ^^ n) p) ((augment_list f ^^ Suc n) p)", "by(cases n,auto simp:take_Suc_prefix)"], ["", "lemma augment_list_prefix:\n  \"n \\<le> m \\<Longrightarrow> prefix ((augment_list f ^^ n) p) ((augment_list f ^^ m) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m \\<Longrightarrow>\n    prefix ((augment_list f ^^ n) p) ((augment_list f ^^ m) p)", "proof(induct \"m-n\" arbitrary:m n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)\n 2. \\<And>x m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>x = m - n; n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n((augment_list f ^^ m) p);\n        Suc x = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?m - ?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> prefix ((augment_list f ^^ ?n) p)\n                     ((augment_list f ^^ ?m) p)\n  Suc x = m - n\n  n \\<le> m\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)\n 2. \\<And>x m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>x = m - n; n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n((augment_list f ^^ m) p);\n        Suc x = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)", "hence [simp]:\"Suc (x + n) = m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?m - ?n; ?n \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> prefix ((augment_list f ^^ ?n) p)\n                     ((augment_list f ^^ ?m) p)\n  Suc x = m - n\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. Suc (x + n) = m", "by auto"], ["proof (state)\nthis:\n  Suc (x + n) = m\n\ngoal (2 subgoals):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)\n 2. \\<And>x m n.\n       \\<lbrakk>\\<And>m n.\n                   \\<lbrakk>x = m - n; n \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n((augment_list f ^^ m) p);\n        Suc x = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)", "from Suc.hyps(2) \n    prefix_order.order.trans[OF Suc.hyps(1)[of \"x + n\" n] augment_list_Suc_prefix[of \"x+n\" f p]]"], ["proof (chain)\npicking this:\n  Suc x = m - n\n  \\<lbrakk>x = x + n - n; n \\<le> x + n\\<rbrakk>\n  \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                     ((augment_list f ^^ Suc (x + n)) p)", "show ?case"], ["proof (prove)\nusing this:\n  Suc x = m - n\n  \\<lbrakk>x = x + n - n; n \\<le> x + n\\<rbrakk>\n  \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                     ((augment_list f ^^ Suc (x + n)) p)\n\ngoal (1 subgoal):\n 1. prefix ((augment_list f ^^ n) p) ((augment_list f ^^ m) p)", "by auto"], ["proof (state)\nthis:\n  prefix ((augment_list f ^^ n) p) ((augment_list f ^^ m) p)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>0 = m - n; n \\<le> m\\<rbrakk>\n       \\<Longrightarrow> prefix ((augment_list f ^^ n) p)\n                          ((augment_list f ^^ m) p)", "qed auto"], ["", "lemma augment_list_nonsense[dest]:\nassumes \"(augment_list \\<sigma> ^^ n) p = []\"\nshows \"n=0\" \"p=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 &&& p = []", "using assms"], ["proof (prove)\nusing this:\n  (augment_list \\<sigma> ^^ n) p = []\n\ngoal (1 subgoal):\n 1. n = 0 &&& p = []", "by(induct n,auto)"], ["", "lemma prefix_augment:\n  shows \"prefix p ((augment_list s ^^ n) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix p ((augment_list s ^^ n) p)", "by (induct n,auto simp:prefix_def)"], ["", "end"]]}