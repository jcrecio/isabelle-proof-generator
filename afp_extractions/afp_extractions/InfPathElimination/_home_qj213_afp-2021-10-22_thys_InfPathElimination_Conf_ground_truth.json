{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/Conf.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma sat_eq :  \n  \"sat c = (states c \\<noteq> {})\"", "lemma subsums_refl :\n  \"c \\<sqsubseteq> c\"", "lemma subsums_trans :\n  \"c1 \\<sqsubseteq> c2 \\<Longrightarrow> c2 \\<sqsubseteq> c3 \\<Longrightarrow> c1 \\<sqsubseteq> c3\"", "lemma\n  assumes \"c1 \\<sqsubseteq> c2\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  shows   \"states c1 = states c2\"", "lemma sat_sub_by_sat :\n  assumes \"sat c\\<^sub>2\"\n  and     \"c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1\"\n  shows   \"sat c\\<^sub>1\"", "lemma unsat_subs_unsat :\n  assumes \"\\<not> sat c1\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  shows   \"\\<not> sat c2\"", "theorem\n  \"c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1 \\<longleftrightarrow> sem c\\<^sub>2 \\<Turnstile>\\<^sub>B sem c\\<^sub>1\"", "lemma \n  \"sem c \\<Turnstile>\\<^sub>B e \\<longleftrightarrow> (\\<forall> \\<sigma> \\<in> states c. e \\<sigma>)\""], "translations": [["", "lemma sat_eq :  \n  \"sat c = (states c \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Conf.sat c = (states c \\<noteq> {})", "using consistentI2"], ["proof (prove)\nusing this:\n  consistent\n   (\\<lambda>v. ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v ?store))\n   ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m ?store\n\ngoal (1 subgoal):\n 1. Conf.sat c = (states c \\<noteq> {})", "by (simp add : sat_def states_def) fast"], ["", "subsubsection \\<open>Subsumption\\<close>"], ["", "text \\<open>A configuration @{term \"c\\<^sub>2\"} is subsumed by a configuration @{term \"c\\<^sub>1\"} if the set of \nstates of @{term \"c\\<^sub>2\"} is a subset of the set of states of @{term \"c\\<^sub>1\"}.\\<close>"], ["", "definition subsums :: \n  \"('v,'d) conf \\<Rightarrow> ('v,'d) conf \\<Rightarrow> bool\" (infixl \"\\<sqsubseteq>\" 55) \nwhere     \n  \"c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1 \\<equiv> (states c\\<^sub>2 \\<subseteq> states c\\<^sub>1)\""], ["", "text \\<open>The subsumption relation is reflexive and transitive.\\<close>"], ["", "lemma subsums_refl :\n  \"c \\<sqsubseteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<sqsubseteq> c", "by (simp only : subsums_def)"], ["", "lemma subsums_trans :\n  \"c1 \\<sqsubseteq> c2 \\<Longrightarrow> c2 \\<sqsubseteq> c3 \\<Longrightarrow> c1 \\<sqsubseteq> c3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c1 \\<sqsubseteq> c2; c2 \\<sqsubseteq> c3\\<rbrakk>\n    \\<Longrightarrow> c1 \\<sqsubseteq> c3", "unfolding subsums_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>states c1 \\<subseteq> states c2;\n     states c2 \\<subseteq> states c3\\<rbrakk>\n    \\<Longrightarrow> states c1 \\<subseteq> states c3", "by simp"], ["", "text \\<open>However, it is not anti-symmetric. This is due to the fact that different configurations \ncan have the same sets of program states. However, the following lemma trivially follows the \ndefinition of subsumption.\\<close>"], ["", "lemma\n  assumes \"c1 \\<sqsubseteq> c2\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  shows   \"states c1 = states c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c1 = states c2", "using assms"], ["proof (prove)\nusing this:\n  c1 \\<sqsubseteq> c2\n  c2 \\<sqsubseteq> c1\n\ngoal (1 subgoal):\n 1. states c1 = states c2", "by (simp add : subsums_def)"], ["", "text \\<open>A satisfiable configuration can only be subsumed by satisfiable configurations.\\<close>"], ["", "lemma sat_sub_by_sat :\n  assumes \"sat c\\<^sub>2\"\n  and     \"c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1\"\n  shows   \"sat c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Conf.sat c\\<^sub>1", "using assms sat_eq[of c\\<^sub>1] sat_eq[of c\\<^sub>2]"], ["proof (prove)\nusing this:\n  Conf.sat c\\<^sub>2\n  c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1\n  Conf.sat c\\<^sub>1 = (states c\\<^sub>1 \\<noteq> {})\n  Conf.sat c\\<^sub>2 = (states c\\<^sub>2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. Conf.sat c\\<^sub>1", "by (simp add : subsums_def) fast"], ["", "text \\<open>On the other hand, an unsatisfiable configuration can only subsume unsatisfiable \nconfigurations.\\<close>"], ["", "lemma unsat_subs_unsat :\n  assumes \"\\<not> sat c1\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  shows   \"\\<not> sat c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Conf.sat c2", "using assms sat_eq[of c1] sat_eq[of c2]"], ["proof (prove)\nusing this:\n  \\<not> Conf.sat c1\n  c2 \\<sqsubseteq> c1\n  Conf.sat c1 = (states c1 \\<noteq> {})\n  Conf.sat c2 = (states c2 \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<not> Conf.sat c2", "by (simp add : subsums_def)"], ["", "subsubsection \\<open>Semantics of a configuration\\<close>"], ["", "text \\<open>The semantics of a configuration @{term \"c\"} is a boolean expression @{term \"e\"} over \nprogram states associating \\emph{true} to a program state if it is a state of @{term \"c\"}. In \npractice, given two configurations @{term \"c\\<^sub>1\"} and @{term \"c\\<^sub>2\"}, it is not possible to enumerate \ntheir sets of states to establish the inclusion in order to detect a subsumption. We detect the \nsubsumption of the former by the latter by asking a constraint solver if @{term \"sem c\\<^sub>1\"} entails \n@{term \"sem c\\<^sub>2\"}. The following theorem shows that the way we detect subsumption in practice is \ncorrect.\\<close>"], ["", "definition sem :: \n  \"('v,'d) conf \\<Rightarrow> ('v,'d) bexp\" \nwhere\n \"sem c = (\\<lambda> \\<sigma>. \\<sigma> \\<in> states c)\""], ["", "theorem\n  \"c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1 \\<longleftrightarrow> sem c\\<^sub>2 \\<Turnstile>\\<^sub>B sem c\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>2 \\<sqsubseteq> c\\<^sub>1 =\n    sem c\\<^sub>2 \\<Turnstile>\\<^sub>B sem c\\<^sub>1", "unfolding subsums_def sem_def subset_iff entails_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>t.\n        t \\<in> states c\\<^sub>2 \\<longrightarrow>\n        t \\<in> states c\\<^sub>1) =\n    (\\<forall>\\<sigma>.\n        \\<sigma> \\<in> states c\\<^sub>2 \\<longrightarrow>\n        \\<sigma> \\<in> states c\\<^sub>1)", "by (rule refl)"], ["", "subsubsection \\<open>Abstractions\\<close>"], ["", "text \\<open>Abstracting a configuration consists in removing a given expression from its @{term \"pred\"} \ncomponent, i.e.\\ weakening its path predicate. This definition of abstraction motivates the fact \nthat the @{term \"pred\"} component of configurations has been defined as a set of boolean expressions \ninstead of a boolean expression.\\<close>"], ["", "definition abstract ::\n  \"('v,'d) conf \\<Rightarrow> ('v,'d) conf \\<Rightarrow> bool\"\nwhere\n  \"abstract c c\\<^sub>a \\<equiv> c \\<sqsubseteq> c\\<^sub>a\""], ["", "subsubsection \\<open>Entailment\\<close>"], ["", "text \\<open>A configuration \\emph{entails} a boolean expression if its semantics entails this expression. \nThis is equivalent to say that this expression holds for any state of this configuration.\\<close>"], ["", "abbreviation entails :: \n  \"('v,'d) conf \\<Rightarrow> ('v,'d) bexp \\<Rightarrow> bool\" (infixl \"\\<Turnstile>\\<^sub>c\" 55) \nwhere\n  \"c \\<Turnstile>\\<^sub>c \\<phi> \\<equiv> sem c \\<Turnstile>\\<^sub>B \\<phi>\""], ["", "lemma \n  \"sem c \\<Turnstile>\\<^sub>B e \\<longleftrightarrow> (\\<forall> \\<sigma> \\<in> states c. e \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<Turnstile>\\<^sub>c e = (\\<forall>\\<sigma>\\<in>states c. e \\<sigma>)", "by (auto simp add : states_def sem_def entails_def)"], ["", "end"]]}