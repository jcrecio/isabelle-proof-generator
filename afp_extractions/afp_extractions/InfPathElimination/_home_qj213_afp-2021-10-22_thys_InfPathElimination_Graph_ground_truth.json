{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma neq_Nil_conv2 :\n  \"xs \\<noteq> [] = (\\<exists> x xs'. xs = xs' @ [x])\"", "lemma fst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2\"\n  shows   \"v1 \\<in> vertices g\"", "lemma lst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2\"\n  shows   \"v2 \\<in> vertices g\"", "lemma\n  \"subpath g (root g) [] (root g)\"", "lemma\n  \"[] \\<in> paths g\"", "lemma sp_one :\n  \"subpath g v1 [e] v2 = (src e = v1 \\<and> e \\<in> edges g \\<and> tgt e = v2)\"", "lemma sp_Cons :\n  \"subpath g v1 (e#es) v2 = (src e = v1 \\<and> e \\<in> edges g \\<and> subpath g (tgt e) es v2)\"", "lemma sp_append_one :\n  \"subpath g v1 (es@[e]) v2 = (subpath g v1 es (src e) \\<and> e \\<in> edges g \\<and> tgt e = v2)\"", "lemma sp_append :\n  \"subpath g v1 (es1@es2) v2 = (\\<exists> v. subpath g v1 es1 v \\<and> subpath g v es2 v2)\"", "lemma sp_same_src_imp_same_tgt :\n  assumes \"subpath g v es v1\"\n  assumes \"subpath g v es v2\"\n  shows   \"v1 = v2\"", "lemma sp_through_de_decomp :\n  assumes \"out_edges g (tgt e) = {}\"\n  assumes \"subpath g v1 es v2\"\n  assumes \"e \\<in> set es\"\n  shows   \"\\<exists> es'. es = es' @ [e] \\<and> e \\<notin> set es'\"", "lemma sp_ends_in_tgt_imp_mem :\n  assumes \"tgt e \\<notin> vertices g\"\n  assumes \"v \\<noteq> tgt e\"\n  assumes \"subpath (add_edge g e) v es (tgt e)\"\n  shows   \"e \\<in> set es\"", "lemma empty_graph_is_tree :\n  assumes \"edges g = {}\"\n  shows   \"is_tree g\""], "translations": [["", "lemma neq_Nil_conv2 :\n  \"xs \\<noteq> [] = (\\<exists> x xs'. xs = xs' @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> []) = (\\<exists>x xs'. xs = xs' @ [x])", "by (induct xs rule : rev_induct, auto)"], ["", "subsection \\<open>Basic Definitions and Properties\\<close>"], ["", "subsubsection \\<open>Edges\\<close>"], ["", "text \\<open>We model edges by a record \\<open>'v edge\\<close> which is parameterized by the type \\<open>'v\\<close> \nof vertices. This allows us to represent the red part\nof red-black graphs as well as the black part (i.e. LTS) using extensible records (more on this later). Edges have two \ncomponents, @{term \"src\"} and @{term \"tgt\"}, which respectively give their source and target.\\<close>"], ["", "record 'v edge = \n  src   :: \"'v\"\n  tgt   :: \"'v\""], ["", "subsubsection \\<open>Rooted graphs\\<close>"], ["", "text \\<open>We model rooted graphs by the record \\<open>'v rgraph\\<close>. It consists of two components: its \nroot and its set of edges.\\<close>"], ["", "record 'v rgraph =\n  root  :: \"'v\"\n  edges :: \"'v edge set\""], ["", "subsubsection \\<open>Vertices\\<close>"], ["", "text \\<open>The set of vertices of a rooted graph is made of its root and the endpoints of its \nedges. Isabelle/HOL provides \\emph{extensible records}, i.e.\\ it is possible to define records using \nexisting records by adding components. The following definition suppose that @{term \"g\"} is of type \n\\<open>('v,'x) rgraph_scheme\\<close>, i.e.\\ an object that has at least all the components of a \n\\<open>'v rgraph\\<close>. The second type parameter \\<open>'x\\<close> stands for the hypothetical type \nparameters that such an object could have in addition of the type of vertices \\<open>'v\\<close>. \nUsing \\<open>('v,'x) rgraph_scheme\\<close> instead of \\<open>'v rgraph\\<close> allows to reuse the following \ndefinition(s) for all type of objects that have at least the components of a rooted graph. For \nexample, we will reuse the following definition to characterize the set of locations of a LTS (see \n\\verb?LTS.thy?).\\<close>"], ["", "definition vertices :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v set\"\nwhere\n  \"vertices g = {root g} \\<union> src `edges g \\<union> tgt ` edges g\""], ["", "subsubsection \\<open>Basic properties of rooted graphs\\<close>"], ["", "text \\<open>In the following, we will be only interested in loop free rooted graphs\nand in what we call \n\\emph{well formed rooted graphs}. A well formed rooted graph is rooted graph that has an empty set \nof edges or, if this is not the case, has at least one edge whose source is its root.\\<close>"], ["", "abbreviation loop_free :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> bool\" \nwhere\n\"loop_free g \\<equiv> \\<forall> e \\<in> edges g. src e \\<noteq> tgt e\""], ["", "abbreviation wf_rgraph :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> bool\" \nwhere\n\"wf_rgraph g \\<equiv> root g \\<in> src ` edges g = (edges g \\<noteq> {})\""], ["", "text \\<open>Even if we are only interested in this kind of rooted graphs, we will not assume the graphs \nare loop free or well formed when this is not needed.\\<close>"], ["", "subsubsection \\<open>Out-going edges\\<close>"], ["", "text \\<open>This abbreviation will prove handy in the following.\\<close>"], ["", "abbreviation out_edges ::\n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v \\<Rightarrow> 'v edge set\" \nwhere\n  \"out_edges g v \\<equiv> {e \\<in> edges g. src e = v}\""], ["", "subsection \\<open>Consistent Edge Sequences, Sub-paths and Paths\\<close>"], ["", "subsubsection \\<open>Consistency of a sequence of edges\\<close>"], ["", "text \\<open>A sequence of edges @{term \"es\"} is consistent from\nvertex @{term \"v1\"} to another vertex @{term \"v2\"} if @{term \"v1 = v2\"} if it is empty, or, if it is \nnot empty:\n\\begin{itemize}\n  \\item @{term \"v1\"} is the source of its first element, and\n  \\item @{term \"v2\"} is the target of its last element, and\n  \\item the target of each of its elements is the source of its follower.\n\\end{itemize}\\<close>"], ["", "fun ces :: \n  \"'v \\<Rightarrow> 'v edge list \\<Rightarrow> 'v \\<Rightarrow> bool\" \nwhere\n  \"ces v1 [] v2 = (v1 = v2)\"\n| \"ces v1 (e#es) v2 = (src e = v1 \\<and> ces (tgt e) es v2)\""], ["", "subsubsection \\<open>Sub-paths and paths\\<close>"], ["", "text \\<open>Let @{term \"g\"} be a rooted graph, @{term \"es\"} a sequence of edges and @{term \"v1\"} and \n\\<open>v2\\<close> two vertices. @{term \"es\"} is a sub-path in @{term \"g\"} from @{term \"v1\"} to \n@{term \"v2\"} if:\n\\begin{itemize}\n  \\item it is consistent from @{term \"v1\"} to @{term \"v2\"},\n  \\item @{term \"v1\"} is a vertex of @{term \"g\"},\n  \\item all of its elements are edges of @{term \"g\"}.\n\\end{itemize}\n\nThe second constraint is needed in the case of the empty sequence: without it,\nthe empty sequence would be a sub-path of @{term \"g\"} even when @{term \"v1\"} is not one of \nits vertices.\\<close>"], ["", "definition subpath :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v \\<Rightarrow> 'v edge list \\<Rightarrow> 'v \\<Rightarrow> bool\" \nwhere\n  \"subpath g v1 es v2 \\<equiv> ces v1 es v2 \\<and> v1 \\<in> vertices g \\<and> set es \\<subseteq> edges g\""], ["", "text \\<open>Let @{term \"es\"} be a sub-path of @{term \"g\"} leading from @{term \"v1\"} to @{term \"v2\"}. \n@{term \"v1\"} and @{term \"v2\"} are both vertices of @{term \"g\"}.\\<close>"], ["", "lemma fst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2\"\n  shows   \"v1 \\<in> vertices g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<in> vertices g", "using assms"], ["proof (prove)\nusing this:\n  subpath g v1 es v2\n\ngoal (1 subgoal):\n 1. v1 \\<in> vertices g", "by (simp add : subpath_def)"], ["", "lemma lst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2\"\n  shows   \"v2 \\<in> vertices g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<in> vertices g", "using assms"], ["proof (prove)\nusing this:\n  subpath g v1 es v2\n\ngoal (1 subgoal):\n 1. v2 \\<in> vertices g", "by (induction es arbitrary : v1, auto simp add: subpath_def vertices_def)"], ["", "text \\<open>The empty sequence of edges is a sub-path from @{term \"v1\"} to @{term \"v2\"} if and only if \nthey are equal and belong to the graph.\\<close>"], ["", "text \\<open>The empty sequence is a sub-path from the root of any rooted graph.\\<close>"], ["", "lemma\n  \"subpath g (root g) [] (root g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subpath g (root g) [] (root g)", "by (auto simp add : vertices_def subpath_def)"], ["", "text \\<open>In the following, we will not always be interested in the final vertex of a sub-path. We \nwill use the abbreviation @{term \"subpath_from\"} whenever this final vertex has no importance, and \n@{term subpath} otherwise.\\<close>"], ["", "abbreviation subpath_from  ::\n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v \\<Rightarrow> 'v edge list \\<Rightarrow> bool\"\nwhere\n  \"subpath_from g v es \\<equiv> \\<exists> v'. subpath g v es v'\""], ["", "abbreviation subpaths_from ::\n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v \\<Rightarrow> 'v edge list set\"\nwhere\n  \"subpaths_from g v \\<equiv> {es. subpath_from g v es}\""], ["", "text \\<open>A path is a sub-path starting at the root of the graph.\\<close>"], ["", "abbreviation path :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v edge list \\<Rightarrow> 'v \\<Rightarrow> bool\" \nwhere\n  \"path g es v \\<equiv> subpath g (root g) es v\""], ["", "abbreviation paths :: \n  \"('a,'b) rgraph_scheme \\<Rightarrow> 'a edge list set\" \nwhere\n  \"paths g \\<equiv> {es. \\<exists> v. path g es v}\""], ["", "text \\<open>The empty sequence is a path of any rooted graph.\\<close>"], ["", "lemma\n  \"[] \\<in> paths g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> subpaths_from g (root g)", "by (auto simp add : subpath_def vertices_def)"], ["", "text \\<open>Some useful simplification lemmas for @{term \"subpath\"}.\\<close>"], ["", "lemma sp_one :\n  \"subpath g v1 [e] v2 = (src e = v1 \\<and> e \\<in> edges g \\<and> tgt e = v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subpath g v1 [e] v2 =\n    (src e = v1 \\<and> e \\<in> edges g \\<and> tgt e = v2)", "by (auto simp add : subpath_def vertices_def)"], ["", "lemma sp_Cons :\n  \"subpath g v1 (e#es) v2 = (src e = v1 \\<and> e \\<in> edges g \\<and> subpath g (tgt e) es v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subpath g v1 (e # es) v2 =\n    (src e = v1 \\<and> e \\<in> edges g \\<and> subpath g (tgt e) es v2)", "by (auto simp add : subpath_def vertices_def)"], ["", "lemma sp_append_one :\n  \"subpath g v1 (es@[e]) v2 = (subpath g v1 es (src e) \\<and> e \\<in> edges g \\<and> tgt e = v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subpath g v1 (es @ [e]) v2 =\n    (subpath g v1 es (src e) \\<and> e \\<in> edges g \\<and> tgt e = v2)", "by (induct es arbitrary : v1, auto simp add : subpath_def vertices_def)"], ["", "lemma sp_append :\n  \"subpath g v1 (es1@es2) v2 = (\\<exists> v. subpath g v1 es1 v \\<and> subpath g v es2 v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subpath g v1 (es1 @ es2) v2 =\n    (\\<exists>v. subpath g v1 es1 v \\<and> subpath g v es2 v2)", "by (induct es1 arbitrary : v1)\n   ((simp add : subpath_def, fast),\n    (auto simp add : fst_of_sp_is_vert sp_Cons))"], ["", "text \\<open>A sub-path leads to a unique vertex.\\<close>"], ["", "lemma sp_same_src_imp_same_tgt :\n  assumes \"subpath g v es v1\"\n  assumes \"subpath g v es v2\"\n  shows   \"v1 = v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 = v2", "using assms"], ["proof (prove)\nusing this:\n  subpath g v es v1\n  subpath g v es v2\n\ngoal (1 subgoal):\n 1. v1 = v2", "by (induct es arbitrary : v) \n   (auto simp add :  sp_Cons subpath_def vertices_def)"], ["", "text \\<open>In the following, we are interested in the evolution of the set of sub-paths of our symbolic \nexecution graph after symbolic execution of a transition from the LTS representation of the program \nunder analysis. Symbolic execution of a transition results in adding to the graph a new edge whose \nsource is already a vertex of this graph, but not its target. The following lemma describes \nsub-paths ending in the target of such an edge.\\<close>"], ["", "text \\<open>Let @{term \"e\"} be an edge whose target has not out-going edges. A sub-path @{term \"es\"} \ncontaining @{term \"e\"} ends by @{term \"e\"} and this occurrence of @{term \"e\"} is unique along \n@{term \"es\"}.\\<close>"], ["", "lemma sp_through_de_decomp :\n  assumes \"out_edges g (tgt e) = {}\"\n  assumes \"subpath g v1 es v2\"\n  assumes \"e \\<in> set es\"\n  shows   \"\\<exists> es'. es = es' @ [e] \\<and> e \\<notin> set es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'", "using assms(2,3)"], ["proof (prove)\nusing this:\n  subpath g v1 es v2\n  e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'", "proof (induction es arbitrary : v1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<lbrakk>subpath g v1 [] v2; e \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            [] = es' @ [e] \\<and> e \\<notin> set es'\n 2. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>subpath g v1 es v2; e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        subpath g v1 (a # es) v2; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "case Nil"], ["proof (state)\nthis:\n  subpath g v1 [] v2\n  e \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<lbrakk>subpath g v1 [] v2; e \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            [] = es' @ [e] \\<and> e \\<notin> set es'\n 2. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>subpath g v1 es v2; e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        subpath g v1 (a # es) v2; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  subpath g v1 [] v2\n  e \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>es'. [] = es' @ [e] \\<and> e \\<notin> set es'", "by simp"], ["proof (state)\nthis:\n  \\<exists>es'. [] = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>subpath g v1 es v2; e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        subpath g v1 (a # es) v2; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>subpath g v1 es v2; e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        subpath g v1 (a # es) v2; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "case (Cons e' es)"], ["proof (state)\nthis:\n  \\<lbrakk>subpath g ?v1.0 es v2; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n  subpath g v1 (e' # es) v2\n  e \\<in> set (e' # es)\n\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>subpath g v1 es v2; e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        subpath g v1 (a # es) v2; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "hence \"e = e' \\<or> (e \\<noteq> e' \\<and> e \\<in> set es)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>subpath g ?v1.0 es v2; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n  subpath g v1 (e' # es) v2\n  e \\<in> set (e' # es)\n\ngoal (1 subgoal):\n 1. e = e' \\<or> e \\<noteq> e' \\<and> e \\<in> set es", "by auto"], ["proof (state)\nthis:\n  e = e' \\<or> e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>subpath g v1 es v2; e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        subpath g v1 (a # es) v2; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  e = e' \\<or> e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "proof (elim disjE, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. e = e' \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n 2. e \\<noteq> e' \\<and> e \\<in> set es \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "case 1"], ["proof (state)\nthis:\n  e = e'\n\ngoal (2 subgoals):\n 1. e = e' \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n 2. e \\<noteq> e' \\<and> e \\<in> set es \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  e = e'\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "using assms(1) Cons"], ["proof (prove)\nusing this:\n  e = e'\n  out_edges g (tgt e) = {}\n  \\<lbrakk>subpath g ?v1.0 es v2; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n  subpath g v1 (e' # es) v2\n  e \\<in> set (e' # es)\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "by (rule_tac ?x=\"[]\" in exI) (cases es, auto simp add: sp_Cons)"], ["proof (state)\nthis:\n  \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal (1 subgoal):\n 1. e \\<noteq> e' \\<and> e \\<in> set es \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> e' \\<and> e \\<in> set es \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "case 2"], ["proof (state)\nthis:\n  e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. e \\<noteq> e' \\<and> e \\<in> set es \\<Longrightarrow>\n    \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "using assms(1) Cons(1)[of \"tgt e'\"] Cons(2)"], ["proof (prove)\nusing this:\n  e \\<noteq> e' \\<and> e \\<in> set es\n  out_edges g (tgt e) = {}\n  \\<lbrakk>subpath g (tgt e') es v2; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n  subpath g v1 (e' # es) v2\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "by (auto simp add : sp_Cons)"], ["proof (state)\nthis:\n  \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Adding Edges\\<close>"], ["", "text \\<open>This definition and the following lemma are here mainly to ease the definitions and proofs \nin the next theories.\\<close>"], ["", "abbreviation add_edge :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> 'v edge \\<Rightarrow> ('v,'x) rgraph_scheme\" \nwhere\n  \"add_edge g e \\<equiv> rgraph.edges_update (\\<lambda> edges. edges \\<union> {e}) g\""], ["", "text \\<open>Let @{term \"es\"} be a sub-path from a vertex other than the target of @{term \"e\"} in the \ngraph obtained from @{term \"g\"} by the addition of edge @{term \"e\"}. Moreover, assume that the \ntarget of @{term \"e\"} is not a vertex of @{term \"g\"}. Then @{term \"e\"} is an element of \n@{term \"es\"}.\\<close>"], ["", "lemma sp_ends_in_tgt_imp_mem :\n  assumes \"tgt e \\<notin> vertices g\"\n  assumes \"v \\<noteq> tgt e\"\n  assumes \"subpath (add_edge g e) v es (tgt e)\"\n  shows   \"e \\<in> set es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set es", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<in> set es", "have \"es \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es \\<noteq> []", "using assms(2,3)"], ["proof (prove)\nusing this:\n  v \\<noteq> tgt e\n  subpath (add_edge g e) v es (tgt e)\n\ngoal (1 subgoal):\n 1. es \\<noteq> []", "by (auto simp add : subpath_def)"], ["proof (state)\nthis:\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "then"], ["proof (chain)\npicking this:\n  es \\<noteq> []", "obtain e' es' where \"es = es' @ [e']\""], ["proof (prove)\nusing this:\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>es' e'.\n        es = es' @ [e'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add : neq_Nil_conv2) blast"], ["proof (state)\nthis:\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "using assms(1,3)"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  tgt e \\<notin> vertices g\n  subpath (add_edge g e) v es (tgt e)\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "by (auto simp add : sp_append_one vertices_def image_def)"], ["proof (state)\nthis:\n  e \\<in> set es\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Trees\\<close>"], ["", "text \\<open>We define trees as rooted-graphs in which there exists a unique path leading to each vertex.\\<close>"], ["", "definition is_tree :: \n  \"('v,'x) rgraph_scheme \\<Rightarrow> bool\" \nwhere\n  \"is_tree g \\<equiv> \\<forall> l \\<in> Graph.vertices g. \\<exists>! p. Graph.path g p l\""], ["", "text \\<open>The empty graph is thus a tree.\\<close>"], ["", "lemma empty_graph_is_tree :\n  assumes \"edges g = {}\"\n  shows   \"is_tree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_tree g", "using assms"], ["proof (prove)\nusing this:\n  edges g = {}\n\ngoal (1 subgoal):\n 1. is_tree g", "by (auto simp add : is_tree_def subpath_def vertices_def)"], ["", "end"]]}