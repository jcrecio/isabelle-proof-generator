{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/SymExec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma se_sat_imp_sat :\n  assumes \"se c l c'\"\n  assumes \"sat c'\"\n  shows   \"sat c\"", "lemma unsat_imp_se_unsat :\n  assumes \"se c l c'\"\n  assumes \"\\<not> sat c\"\n  shows   \"\\<not> sat c'\"", "lemma [simp] :\n  \"se c Skip c' = (c' = c)\"", "lemma se_Assume_eq :\n  \"se c (Assume e) c' = (c' = \\<lparr> store = store c, pred = pred c \\<union> {adapt_bexp e (store c)} \\<rparr>)\"", "lemma se_Assign_eq :\n  \"se c (Assign v e) c' = \n  (\\<exists> sv. fresh_symvar sv c \n       \\<and> fst sv = v \n       \\<and> c' = \\<lparr> store = (store c)(v := snd sv), \n                pred  = insert (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>) (pred c)\\<rparr>)\"", "lemma path_pred_of_se_Assume :\n  assumes \"se c (Assume e) c'\"\n  shows   \"conjunct (pred c') = \n            (\\<lambda> \\<sigma>. conjunct (pred c) \\<sigma> \\<and> adapt_bexp e (store c) \\<sigma>)\"", "lemma path_pred_of_se_Assign :\n  assumes \"se c (Assign v e) c'\"\n  shows   \"\\<exists> sv. conjunct (pred c') = \n            (\\<lambda> \\<sigma>. conjunct (pred c) \\<sigma> \\<and> \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\"", "theorem states_of_se_assume :\n  assumes \"se c (Assume e) c'\"\n  shows   \"states c' = {\\<sigma> \\<in> states c. e \\<sigma>}\"", "lemma states_of_se_assign1 :\n  assumes \"se c (Assign v e) c'\"\n  assumes \"\\<sigma>' \\<in> states c'\"\n  shows   \"\\<exists> \\<sigma> \\<in> states c. \\<sigma>' = (\\<sigma> (v := e \\<sigma>))\"", "lemma states_of_se_assign2 :\n  assumes \"se c (Assign v e) c'\"\n  assumes \"\\<exists> \\<sigma> \\<in> states c. \\<sigma>' = \\<sigma> (v := e \\<sigma>)\"\n  shows   \"\\<sigma>' \\<in> states c'\"", "theorem states_of_se_assign :\n  assumes \"se c (Assign v e) c'\"\n  shows   \"states c' = {\\<sigma> (v := e \\<sigma>) | \\<sigma>. \\<sigma> \\<in> states c}\"", "theorem se_mono_for_sub :\n  assumes \"se c1 l c1'\"\n  assumes \"se c2 l c2'\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  shows   \"c2' \\<sqsubseteq> c1'\"", "theorem se_mono_for_states_eq :\n  assumes \"states c1 = states c2\"\n  assumes \"se c1 l c1'\"\n  assumes \"se c2 l c2'\"\n  shows   \"states c2' = states c1'\"", "lemma se_succs_states :\n  assumes \"se c l c1\"\n  assumes \"se c l c2\"\n  shows   \"states c1 = states c2\"", "lemma [simp] :\n  \"se_star c [] c' = (c' = c)\"", "lemma se_star_Cons :\n  \"se_star c1 (l # ls) c2 = (\\<exists> c. se c1 l c \\<and> se_star c ls c2)\"", "lemma se_star_one :\n  \"se_star c1 [l] c2 = se c1 l c2\"", "lemma se_star_append :\n  \"se_star c1 (ls1 @ ls2) c2 = (\\<exists> c. se_star c1 ls1 c \\<and> se_star c ls2 c2)\"", "lemma se_star_append_one :\n  \"se_star c1 (ls @ [l]) c2 = (\\<exists> c. se_star c1 ls c \\<and> se c l c2)\"", "lemma unsat_imp_se_star_unsat :\n  assumes \"se_star c ls c'\"\n  assumes \"\\<not> sat c\"\n  shows   \"\\<not> sat c'\"", "lemma se_star_sat_imp_sat :\n  assumes \"se_star c ls c'\"\n  assumes \"sat c'\"\n  shows   \"sat c\"", "theorem se_star_mono_for_sub :\n  assumes \"se_star c1 ls c1'\"\n  assumes \"se_star c2 ls c2'\"\n  assumes \"c2  \\<sqsubseteq> c1\"\n  shows   \"c2' \\<sqsubseteq> c1'\"", "lemma se_star_mono_for_states_eq : \n  assumes \"states c1 = states c2\"\n  assumes \"se_star c1 ls c1'\"\n  assumes \"se_star c2 ls c2'\"\n  shows   \"states c2' = states c1'\"", "lemma se_star_succs_states :\n  assumes \"se_star c ls c1\"\n  assumes \"se_star c ls c2\"\n  shows   \"states c1 = states c2\"", "lemma updatable_imp_ex_se_suc :\n  assumes \"updatable c\"\n  shows   \"\\<exists> c'. se c l c'\"", "lemma finite_symvars_imp_ex_greatest_symvar :\n  fixes SV :: \"'a symvar set\"\n  assumes \"finite SV\"\n  assumes \"\\<exists> sv \\<in> SV. fst sv = v\"\n  shows   \"\\<exists> sv  \\<in> {sv \\<in> SV. fst sv = v}. \n           \\<forall> sv' \\<in> {sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv\"", "lemma finite_pred_imp_se_updatable :\n  assumes \"finite (Bexp.vars (conjunct (pred c)))\" (is \"finite ?V\")\n  shows   \"updatable c\"", "lemma finite_imp_ex_se_succ :\n  assumes \"finite (pred c)\"\n  assumes \"\\<forall> e \\<in> pred c. finite (Bexp.vars e)\"\n  shows   \"\\<exists> c'. se c l c'\"", "lemma se_preserves_finiteness1 :\n  assumes \"finite_label l\"\n  assumes \"se c l c'\"\n  assumes \"\\<forall> e \\<in> pred c.  finite (Bexp.vars e)\"\n  shows   \"\\<forall> e \\<in> pred c'. finite (Bexp.vars e)\"", "lemma se_preserves_finiteness2 :\n  assumes \"se c l c'\"\n  assumes \"finite (pred c)\"\n  shows   \"finite (pred c')\"", "lemma finite_imp_ex_se_star_succ :\n  assumes \"finite (pred c)\"\n  assumes \"\\<forall> e \\<in> pred c. finite (Bexp.vars e)\"\n  assumes \"finite_labels ls\"\n  shows   \"\\<exists> c'. se_star c ls c'\"", "lemma feasible_Cons :\n  \"feasible c (l#ls) = (\\<exists> c'. se c l c' \\<and> sat c' \\<and> feasible c' ls)\"", "lemma subsums_imp_feasible :\n  assumes \"finite_labels ls\"\n  assumes \"finite (pred c1)\"\n  assumes \"finite (pred c2)\"\n  assumes \"\\<forall> e \\<in> pred c1. finite (Bexp.vars e)\"\n  assumes \"\\<forall> e \\<in> pred c2. finite (Bexp.vars e)\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  assumes \"feasible c2 ls\"\n  shows   \"feasible c1 ls\"", "lemma [simp] :\n  \"ce \\<sigma> Skip \\<sigma>' = (\\<sigma>' = \\<sigma>)\"", "lemma [simp] :\n  \"ce \\<sigma> (Assume e) \\<sigma>' = (\\<sigma>' = \\<sigma> \\<and> e \\<sigma>)\"", "lemma [simp] :\n  \"ce \\<sigma> (Assign v e) \\<sigma>' = (\\<sigma>' = \\<sigma>(v := e \\<sigma>))\"", "lemma se_as_ce :\n  assumes \"se c l c'\"\n  shows   \"states c' = {\\<sigma>'. \\<exists> \\<sigma> \\<in> states c. ce \\<sigma> l \\<sigma>'} \"", "lemma [simp] :\n  \"ce_star \\<sigma> [] \\<sigma>' = (\\<sigma>' = \\<sigma>)\"", "lemma ce_star_Cons :\n  \"ce_star \\<sigma>1 (l # ls) \\<sigma>2 = (\\<exists> \\<sigma>. ce \\<sigma>1 l \\<sigma> \\<and> ce_star \\<sigma> ls \\<sigma>2)\"", "lemma se_star_as_ce_star :\n  assumes \"se_star c ls c'\"\n  shows   \"states c' = {\\<sigma>'. \\<exists> \\<sigma> \\<in> states c. ce_star \\<sigma> ls \\<sigma>'}\""], "translations": [["", "lemma se_sat_imp_sat :\n  assumes \"se c l c'\"\n  assumes \"sat c'\"\n  shows   \"sat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Conf.sat c", "using assms"], ["proof (prove)\nusing this:\n  se c l c'\n  Conf.sat c'\n\ngoal (1 subgoal):\n 1. Conf.sat c", "by cases (auto simp add : sat_def conjunct_def)"], ["", "text \\<open>If symbolic execution is performed from an unsatisfiable configuration, then it will yield \nan unsatisfiable configuration.\\<close>"], ["", "lemma unsat_imp_se_unsat :\n  assumes \"se c l c'\"\n  assumes \"\\<not> sat c\"\n  shows   \"\\<not> sat c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Conf.sat c'", "using assms"], ["proof (prove)\nusing this:\n  se c l c'\n  \\<not> Conf.sat c\n\ngoal (1 subgoal):\n 1. \\<not> Conf.sat c'", "by cases (simp add : sat_def conjunct_def)+"], ["", "text \\<open>Given two configurations @{term \"c\"} and @{term \"c'\"} and a label @{term \"l\"} such that \n@{term \"se c l c'\"}, the three following lemmas express @{term \"c'\"} as a function of @{term \"c\"}.\\<close>"], ["", "lemma [simp] :\n  \"se c Skip c' = (c' = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se c Skip c' = (c' = c)", "by (simp add : se.simps)"], ["", "lemma se_Assume_eq :\n  \"se c (Assume e) c' = (c' = \\<lparr> store = store c, pred = pred c \\<union> {adapt_bexp e (store c)} \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se c (Assume e) c' =\n    (c' =\n     \\<lparr>store = store c,\n        pred = pred c \\<union> {adapt_bexp e (store c)}\\<rparr>)", "by (simp add : se.simps)"], ["", "lemma se_Assign_eq :\n  \"se c (Assign v e) c' = \n  (\\<exists> sv. fresh_symvar sv c \n       \\<and> fst sv = v \n       \\<and> c' = \\<lparr> store = (store c)(v := snd sv), \n                pred  = insert (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>) (pred c)\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se c (Assign v e) c' =\n    (\\<exists>sv.\n        Conf.fresh_symvar sv c \\<and>\n        fst sv = v \\<and>\n        c' =\n        \\<lparr>store = (store c)(v := snd sv),\n           pred =\n             insert\n              (\\<lambda>\\<sigma>.\n                  \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n              (pred c)\\<rparr>)", "by (simp only : se.simps, blast)"], ["", "text \\<open>Given two configurations @{term \"c\"} and @{term \"c'\"} and a label @{term \"l\"} such that \n@{term \"se c l c'\"}, the two following lemmas express the path predicate of @{term \"c'\"} as \na function of the path predicate of @{term \"c\"} when @{term \"l\"} models a guard or an \nassignment.\\<close>"], ["", "lemma path_pred_of_se_Assume :\n  assumes \"se c (Assume e) c'\"\n  shows   \"conjunct (pred c') = \n            (\\<lambda> \\<sigma>. conjunct (pred c) \\<sigma> \\<and> adapt_bexp e (store c) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunct (pred c') =\n    (\\<lambda>\\<sigma>.\n        conjunct (pred c) \\<sigma> \\<and> adapt_bexp e (store c) \\<sigma>)", "using assms se_Assume_eq[of c e c']"], ["proof (prove)\nusing this:\n  se c (Assume e) c'\n  se c (Assume e) c' =\n  (c' =\n   \\<lparr>store = store c,\n      pred = pred c \\<union> {adapt_bexp e (store c)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. conjunct (pred c') =\n    (\\<lambda>\\<sigma>.\n        conjunct (pred c) \\<sigma> \\<and> adapt_bexp e (store c) \\<sigma>)", "by (auto simp add : conjunct_def)"], ["", "lemma path_pred_of_se_Assign :\n  assumes \"se c (Assign v e) c'\"\n  shows   \"\\<exists> sv. conjunct (pred c') = \n            (\\<lambda> \\<sigma>. conjunct (pred c) \\<sigma> \\<and> \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sv.\n       conjunct (pred c') =\n       (\\<lambda>\\<sigma>.\n           conjunct (pred c) \\<sigma> \\<and>\n           \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)", "using assms se_Assign_eq[of c v e c']"], ["proof (prove)\nusing this:\n  se c (Assign v e) c'\n  se c (Assign v e) c' =\n  (\\<exists>sv.\n      Conf.fresh_symvar sv c \\<and>\n      fst sv = v \\<and>\n      c' =\n      \\<lparr>store = (store c)(v := snd sv),\n         pred =\n           insert\n            (\\<lambda>\\<sigma>.\n                \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n            (pred c)\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<exists>sv.\n       conjunct (pred c') =\n       (\\<lambda>\\<sigma>.\n           conjunct (pred c) \\<sigma> \\<and>\n           \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)", "by (fastforce simp add : conjunct_def)"], ["", "text \\<open>Let @{term \"c\"} and @{term \"c'\"} be two configurations  such that @{term \"c'\"} is obtained \nfrom @{term \"c\"} by symbolic execution of a label of the form @{term \"Assume e\"}. The states of \n@{term \"c'\"} are the states of @{term \"c\"} that satisfy @{term \"e\"}. This theorem will help prove \nthat symbolic execution is monotonic wrt.\\ subsumption.\\<close>"], ["", "theorem states_of_se_assume :\n  assumes \"se c (Assume e) c'\"\n  shows   \"states c' = {\\<sigma> \\<in> states c. e \\<sigma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c' = {\\<sigma> \\<in> states c. e \\<sigma>}", "using assms se_Assume_eq[of c e c']"], ["proof (prove)\nusing this:\n  se c (Assume e) c'\n  se c (Assume e) c' =\n  (c' =\n   \\<lparr>store = store c,\n      pred = pred c \\<union> {adapt_bexp e (store c)}\\<rparr>)\n\ngoal (1 subgoal):\n 1. states c' = {\\<sigma> \\<in> states c. e \\<sigma>}", "by (auto simp add : adapt_bexp_is_subst states_def conjunct_def)"], ["", "text \\<open>Let @{term \"c\"} and @{term \"c'\"} be two configurations  such that @{term \"c'\"} is obtained \nfrom @{term \"c\"} by symbolic execution of a label of the form @{term \"Assign v e\"}. We want to \nexpress the set of states of @{term \"c'\"} as a function of the set of states of @{term \"c\"}. Since \nthe proof requires a number of details, we split into two sub lemmas.\\<close>"], ["", "text \\<open>First, we show that if @{term \"\\<sigma>'\"} is a state of @{term \"c'\"}, then it has been obtain from \nan adequate update of a state @{term \"\\<sigma>\"} of @{term \"c\"}.\\<close>"], ["", "lemma states_of_se_assign1 :\n  assumes \"se c (Assign v e) c'\"\n  assumes \"\\<sigma>' \\<in> states c'\"\n  shows   \"\\<exists> \\<sigma> \\<in> states c. \\<sigma>' = (\\<sigma> (v := e \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "obtain \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  where 1 : \"consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\"\n  and   2 : \"conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n        \\<lbrakk>consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n                  (store c');\n         conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<sigma>' \\<in> states c'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n        \\<lbrakk>consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n                  (store c');\n         conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding states_def"], ["proof (prove)\nusing this:\n  \\<sigma>'\n  \\<in> {\\<sigma>.\n         \\<exists>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n            consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n             (store c') \\<and>\n            conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n        \\<lbrakk>consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n                  (store c');\n         conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "obtain \\<sigma> \n  where 3 : \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\""], ["proof (prove)\nusing this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n         (store c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using consistentI2"], ["proof (prove)\nusing this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  consistent\n   (\\<lambda>v. ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v ?store))\n   ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m ?store\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n         (store c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "moreover"], ["proof (state)\nthis:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "have \"conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "using assms(1) 2"], ["proof (prove)\nusing this:\n  se c (Assign v e) c'\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "by (auto simp add : se_Assign_eq conjunct_def)"], ["proof (state)\nthis:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "ultimately"], ["proof (chain)\npicking this:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "have \"\\<sigma> \\<in> states c\""], ["proof (prove)\nusing this:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> states c", "by (simp add : states_def) blast"], ["proof (state)\nthis:\n  \\<sigma> \\<in> states c\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "moreover"], ["proof (state)\nthis:\n  \\<sigma> \\<in> states c\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "have \"\\<sigma>' = \\<sigma> (v := e \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "have \"\\<sigma>' v = e \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "have \"\\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))", "using 1"], ["proof (prove)\nusing this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))", "by (simp add : consistent_def)"], ["proof (state)\nthis:\n  \\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "have \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) = (adapt_aexp e (store c)) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "using assms(1) 2 se_Assign_eq[of c v e c']"], ["proof (prove)\nusing this:\n  se c (Assign v e) c'\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  se c (Assign v e) c' =\n  (\\<exists>sv.\n      Conf.fresh_symvar sv c \\<and>\n      fst sv = v \\<and>\n      c' =\n      \\<lparr>store = (store c)(v := snd sv),\n         pred =\n           insert\n            (\\<lambda>\\<sigma>.\n                \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n            (pred c)\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "by (force simp add : symvar_def conjunct_def)"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "moreover"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "have \"(adapt_aexp e (store c)) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "using 3"], ["proof (prove)\nusing this:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n\ngoal (1 subgoal):\n 1. adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "by (rule adapt_aexp_is_subst)"], ["proof (state)\nthis:\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' v = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c'))\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v (store c')) =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>' v = e \\<sigma>", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' v = e \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma>' v = e \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' v = e \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "have \"\\<forall> x. x \\<noteq> v \\<longrightarrow> \\<sigma>' x = \\<sigma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<noteq> v \\<longrightarrow> \\<sigma>' x = \\<sigma> x", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "assume \"x \\<noteq> v\""], ["proof (state)\nthis:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "hence \"\\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))\""], ["proof (prove)\nusing this:\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))", "using assms(1) 1"], ["proof (prove)\nusing this:\n  x \\<noteq> v\n  se c (Assign v e) c'\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c')\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))", "unfolding consistent_def symvar_def"], ["proof (prove)\nusing this:\n  x \\<noteq> v\n  se c (Assign v e) c'\n  \\<forall>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (v, store c' v) = \\<sigma>' v\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (x, store c x)", "by (drule_tac ?x=\"x\" in spec) (auto simp add : se_Assign_eq)"], ["proof (state)\nthis:\n  \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "moreover"], ["proof (state)\nthis:\n  \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "have \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c)) = \\<sigma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c)) = \\<sigma> x", "using 3"], ["proof (prove)\nusing this:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c)) = \\<sigma> x", "by (auto simp add : consistent_def)"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c)) = \\<sigma> x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> v \\<Longrightarrow> \\<sigma>' x = \\<sigma> x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> v\n  \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c)) = \\<sigma> x", "show \"\\<sigma>' x = \\<sigma> x\""], ["proof (prove)\nusing this:\n  x \\<noteq> v\n  \\<sigma>' x = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c))\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x (store c)) = \\<sigma> x\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma> x", "by simp"], ["proof (state)\nthis:\n  \\<sigma>' x = \\<sigma> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. x \\<noteq> v \\<longrightarrow> \\<sigma>' x = \\<sigma> x\n\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>' v = e \\<sigma>\n  \\<forall>x. x \\<noteq> v \\<longrightarrow> \\<sigma>' x = \\<sigma> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' v = e \\<sigma>\n  \\<forall>x. x \\<noteq> v \\<longrightarrow> \\<sigma>' x = \\<sigma> x\n\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> states c\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> states c\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "by (simp add : states_def) blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Then, we show that if there exists a state @{term \"\\<sigma>\"} of @{term \"c\"} from which \n@{term \"\\<sigma>'\"} is obtained by an adequate update, then @{term \"\\<sigma>'\"} is a state of @{term \"c'\"}.\\<close>"], ["", "lemma states_of_se_assign2 :\n  assumes \"se c (Assign v e) c'\"\n  assumes \"\\<exists> \\<sigma> \\<in> states c. \\<sigma>' = \\<sigma> (v := e \\<sigma>)\"\n  shows   \"\\<sigma>' \\<in> states c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "obtain \\<sigma> \n  where \"\\<sigma> \\<in> states c\" \n  and   \"\\<sigma>' = \\<sigma> (v := e \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in> states c;\n         \\<sigma>' = \\<sigma>(v := e \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>\\<in>states c. \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in> states c;\n         \\<sigma>' = \\<sigma>(v := e \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma> \\<in> states c\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "then"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> states c\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)", "obtain \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \n  where 1 : \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\"\n  and   2 : \"conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> states c\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n        \\<lbrakk>consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n                  (store c);\n         conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding states_def"], ["proof (prove)\nusing this:\n  \\<sigma>\n  \\<in> {\\<sigma>.\n         \\<exists>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n            consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n             (store c) \\<and>\n            conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m}\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n        \\<lbrakk>consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n                  (store c);\n         conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "obtain sv \n  where 3 : \"fresh_symvar sv c\"\n  and   4 : \"fst sv = v\"\n  and   5 : \"c' = \\<lparr> store = (store c)(v := snd sv), \n                    pred    = insert (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>) (pred c) \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sv.\n        \\<lbrakk>Conf.fresh_symvar sv c; fst sv = v;\n         c' =\n         \\<lparr>store = (store c)(v := snd sv),\n            pred =\n              insert\n               (\\<lambda>\\<sigma>.\n                   \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n               (pred c)\\<rparr>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) se_Assign_eq[of c v e c']"], ["proof (prove)\nusing this:\n  se c (Assign v e) c'\n  se c (Assign v e) c' =\n  (\\<exists>sv.\n      Conf.fresh_symvar sv c \\<and>\n      fst sv = v \\<and>\n      c' =\n      \\<lparr>store = (store c)(v := snd sv),\n         pred =\n           insert\n            (\\<lambda>\\<sigma>.\n                \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n            (pred c)\\<rparr>)\n\ngoal (1 subgoal):\n 1. (\\<And>sv.\n        \\<lbrakk>Conf.fresh_symvar sv c; fst sv = v;\n         c' =\n         \\<lparr>store = (store c)(v := snd sv),\n            pred =\n              insert\n               (\\<lambda>\\<sigma>.\n                   \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n               (pred c)\\<rparr>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Conf.fresh_symvar sv c\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "define \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' where \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := e \\<sigma>)\""], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' = \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (sv := e \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "have \"consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')", "using \\<open>\\<sigma>' = \\<sigma> (v := e \\<sigma>)\\<close> 1 4 5"], ["proof (prove)\nusing this:\n  \\<sigma>' = \\<sigma>(v := e \\<sigma>)\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (store c)\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n\ngoal (1 subgoal):\n 1. consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')", "by (auto simp add : symvar_def consistent_def \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'_def)"], ["proof (state)\nthis:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "moreover"], ["proof (state)\nthis:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "have \"conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "have \"conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "using 2 3"], ["proof (prove)\nusing this:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  Conf.fresh_symvar sv c\n\ngoal (1 subgoal):\n 1. conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "by (simp add : fresh_symvar_def symvars_def Bexp.vars_def \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'_def)"], ["proof (state)\nthis:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "moreover"], ["proof (state)\nthis:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "have \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv = (adapt_aexp e (store c)) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "have \"Aexp.fresh sv (adapt_aexp e (store c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp.fresh sv (adapt_aexp e (store c))", "using 3 symvars_of_adapt_aexp[of e \"store c\"]"], ["proof (prove)\nusing this:\n  Conf.fresh_symvar sv c\n  Aexp.vars (adapt_aexp e (store c)) \\<subseteq> Store.symvars (store c)\n\ngoal (1 subgoal):\n 1. Aexp.fresh sv (adapt_aexp e (store c))", "by (auto simp add : fresh_symvar_def symvars_def)"], ["proof (state)\nthis:\n  Aexp.fresh sv (adapt_aexp e (store c))\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "thus ?thesis"], ["proof (prove)\nusing this:\n  Aexp.fresh sv (adapt_aexp e (store c))\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "using adapt_aexp_is_subst[OF 1, of e]"], ["proof (prove)\nusing this:\n  Aexp.fresh sv (adapt_aexp e (store c))\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n    adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "by (simp add : Aexp.vars_def \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'_def)"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "ultimately"], ["proof (chain)\npicking this:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "show ?thesis"], ["proof (prove)\nusing this:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "using 5"], ["proof (prove)\nusing this:\n  conjunct (pred c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' sv =\n  adapt_aexp e (store c) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n\ngoal (1 subgoal):\n 1. conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "by (simp add: conjunct_def)"], ["proof (state)\nthis:\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "ultimately"], ["proof (chain)\npicking this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'", "show ?thesis"], ["proof (prove)\nusing this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "unfolding states_def"], ["proof (prove)\nusing this:\n  consistent \\<sigma>' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m' (store c')\n  conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m'\n\ngoal (1 subgoal):\n 1. \\<sigma>'\n    \\<in> {\\<sigma>.\n           \\<exists>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n              consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n               (store c') \\<and>\n              conjunct (pred c') \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m}", "by blast"], ["proof (state)\nthis:\n  \\<sigma>' \\<in> states c'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following theorem expressing the set of states of @{term c'} as a function of the set \nof states of @{term c} trivially follows the two preceding lemmas.\\<close>"], ["", "theorem states_of_se_assign :\n  assumes \"se c (Assign v e) c'\"\n  shows   \"states c' = {\\<sigma> (v := e \\<sigma>) | \\<sigma>. \\<sigma> \\<in> states c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>(v := e \\<sigma>) |\\<sigma>. \\<sigma> \\<in> states c}", "using assms states_of_se_assign1 states_of_se_assign2"], ["proof (prove)\nusing this:\n  se c (Assign v e) c'\n  \\<lbrakk>se ?c (Assign ?v ?e) ?c'; ?\\<sigma>' \\<in> states ?c'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>\\<in>states ?c.\n                       ?\\<sigma>' = \\<sigma>(?v := ?e \\<sigma>)\n  \\<lbrakk>se ?c (Assign ?v ?e) ?c';\n   \\<exists>\\<sigma>\\<in>states ?c.\n      ?\\<sigma>' = \\<sigma>(?v := ?e \\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>' \\<in> states ?c'\n\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>(v := e \\<sigma>) |\\<sigma>. \\<sigma> \\<in> states c}", "by fast"], ["", "subsubsection \\<open>Monotonicity of $\\mathit{se}$\\<close>"], ["", "text \\<open>We are now ready to prove that symbolic execution is monotonic with respect to subsumption. \n\\<close>"], ["", "theorem se_mono_for_sub :\n  assumes \"se c1 l c1'\"\n  assumes \"se c2 l c2'\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  shows   \"c2' \\<sqsubseteq> c1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2' \\<sqsubseteq> c1'", "using assms"], ["proof (prove)\nusing this:\n  se c1 l c1'\n  se c2 l c2'\n  c2 \\<sqsubseteq> c1\n\ngoal (1 subgoal):\n 1. c2' \\<sqsubseteq> c1'", "by ((cases l),\n    (simp add : ),\n    (simp add : states_of_se_assume subsums_def, blast),\n    (simp add : states_of_se_assign subsums_def, blast))"], ["", "text \\<open>A stronger version of the previous theorem: symbolic execution is monotonic with respect to \nstates equality.\\<close>"], ["", "theorem se_mono_for_states_eq :\n  assumes \"states c1 = states c2\"\n  assumes \"se c1 l c1'\"\n  assumes \"se c2 l c2'\"\n  shows   \"states c2' = states c1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c2' = states c1'", "using assms(1) \n      se_mono_for_sub[OF assms(2,3)] \n      se_mono_for_sub[OF assms(3,2)]"], ["proof (prove)\nusing this:\n  states c1 = states c2\n  c2 \\<sqsubseteq> c1 \\<Longrightarrow> c2' \\<sqsubseteq> c1'\n  c1 \\<sqsubseteq> c2 \\<Longrightarrow> c1' \\<sqsubseteq> c2'\n\ngoal (1 subgoal):\n 1. states c2' = states c1'", "by (simp add : subsums_def)"], ["", "text \\<open>The previous theorem confirms the fact that the way the fresh symbolic variable is chosen \nin the case of symbolic execution of an assignment does not matter as long as the new symbolic \nvariable is indeed fresh, which is more precisely expressed by the following lemma.\\<close>"], ["", "lemma se_succs_states :\n  assumes \"se c l c1\"\n  assumes \"se c l c2\"\n  shows   \"states c1 = states c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c1 = states c2", "using assms se_mono_for_states_eq"], ["proof (prove)\nusing this:\n  se c l c1\n  se c l c2\n  \\<lbrakk>states ?c1.0 = states ?c2.0; se ?c1.0 ?l ?c1';\n   se ?c2.0 ?l ?c2'\\<rbrakk>\n  \\<Longrightarrow> states ?c2' = states ?c1'\n\ngoal (1 subgoal):\n 1. states c1 = states c2", "by fast"], ["", "subsubsection \\<open>Basic properties of $\\mathit{se\\_star}$\\<close>"], ["", "text \\<open>Some simplification lemmas for @{term \"se_star\"}.\\<close>"], ["", "lemma [simp] :\n  \"se_star c [] c' = (c' = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se_star c [] c' = (c' = c)", "by (subst se_star.simps) auto"], ["", "lemma se_star_Cons :\n  \"se_star c1 (l # ls) c2 = (\\<exists> c. se c1 l c \\<and> se_star c ls c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se_star c1 (l # ls) c2 = (\\<exists>c. se c1 l c \\<and> se_star c ls c2)", "by (subst (1) se_star.simps) blast"], ["", "lemma se_star_one :\n  \"se_star c1 [l] c2 = se c1 l c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se_star c1 [l] c2 = se c1 l c2", "using se_star_Cons"], ["proof (prove)\nusing this:\n  se_star ?c1.0 (?l # ?ls) ?c2.0 =\n  (\\<exists>c. se ?c1.0 ?l c \\<and> se_star c ?ls ?c2.0)\n\ngoal (1 subgoal):\n 1. se_star c1 [l] c2 = se c1 l c2", "by force"], ["", "lemma se_star_append :\n  \"se_star c1 (ls1 @ ls2) c2 = (\\<exists> c. se_star c1 ls1 c \\<and> se_star c ls2 c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se_star c1 (ls1 @ ls2) c2 =\n    (\\<exists>c. se_star c1 ls1 c \\<and> se_star c ls2 c2)", "by (induct ls1 arbitrary : c1, simp_all add : se_star_Cons) blast"], ["", "lemma se_star_append_one :\n  \"se_star c1 (ls @ [l]) c2 = (\\<exists> c. se_star c1 ls c \\<and> se c l c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. se_star c1 (ls @ [l]) c2 =\n    (\\<exists>c. se_star c1 ls c \\<and> se c l c2)", "unfolding se_star_append se_star_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>c. se_star c1 ls c \\<and> se c l c2) =\n    (\\<exists>c. se_star c1 ls c \\<and> se c l c2)", "by (rule refl)"], ["", "text \\<open>Symbolic execution of a sequence of labels from an unsatisfiable configuration yields \nan unsatisfiable configuration.\\<close>"], ["", "lemma unsat_imp_se_star_unsat :\n  assumes \"se_star c ls c'\"\n  assumes \"\\<not> sat c\"\n  shows   \"\\<not> sat c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Conf.sat c'", "using assms"], ["proof (prove)\nusing this:\n  se_star c ls c'\n  \\<not> Conf.sat c\n\ngoal (1 subgoal):\n 1. \\<not> Conf.sat c'", "by (induct ls arbitrary : c) \n   (simp, force simp add : se_star_Cons unsat_imp_se_unsat)"], ["", "text \\<open>If symbolic execution yields a satisfiable configuration, then it has been performed from \na satisfiable configuration.\\<close>"], ["", "lemma se_star_sat_imp_sat :\n  assumes \"se_star c ls c'\"\n  assumes \"sat c'\"\n  shows   \"sat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Conf.sat c", "using assms"], ["proof (prove)\nusing this:\n  se_star c ls c'\n  Conf.sat c'\n\ngoal (1 subgoal):\n 1. Conf.sat c", "by (induct ls arbitrary : c) \n   (simp, force simp add : se_star_Cons se_sat_imp_sat)"], ["", "subsubsection \\<open>Monotonicity of $\\mathit{se\\_star}$\\<close>"], ["", "text \\<open>Monotonicity of @{term \"se\"} extends to @{term \"se_star\"}.\\<close>"], ["", "theorem se_star_mono_for_sub :\n  assumes \"se_star c1 ls c1'\"\n  assumes \"se_star c2 ls c2'\"\n  assumes \"c2  \\<sqsubseteq> c1\"\n  shows   \"c2' \\<sqsubseteq> c1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2' \\<sqsubseteq> c1'", "using assms"], ["proof (prove)\nusing this:\n  se_star c1 ls c1'\n  se_star c2 ls c2'\n  c2 \\<sqsubseteq> c1\n\ngoal (1 subgoal):\n 1. c2' \\<sqsubseteq> c1'", "by (induct ls arbitrary : c1 c2) \n   (auto simp add :  se_star_Cons se_mono_for_sub)"], ["", "lemma se_star_mono_for_states_eq : \n  assumes \"states c1 = states c2\"\n  assumes \"se_star c1 ls c1'\"\n  assumes \"se_star c2 ls c2'\"\n  shows   \"states c2' = states c1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c2' = states c1'", "using assms(1) \n      se_star_mono_for_sub[OF assms(2,3)] \n      se_star_mono_for_sub[OF assms(3,2)]"], ["proof (prove)\nusing this:\n  states c1 = states c2\n  c2 \\<sqsubseteq> c1 \\<Longrightarrow> c2' \\<sqsubseteq> c1'\n  c1 \\<sqsubseteq> c2 \\<Longrightarrow> c1' \\<sqsubseteq> c2'\n\ngoal (1 subgoal):\n 1. states c2' = states c1'", "by (simp add : subsums_def)"], ["", "lemma se_star_succs_states :\n  assumes \"se_star c ls c1\"\n  assumes \"se_star c ls c2\"\n  shows   \"states c1 = states c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c1 = states c2", "using assms se_star_mono_for_states_eq"], ["proof (prove)\nusing this:\n  se_star c ls c1\n  se_star c ls c2\n  \\<lbrakk>states ?c1.0 = states ?c2.0; se_star ?c1.0 ?ls ?c1';\n   se_star ?c2.0 ?ls ?c2'\\<rbrakk>\n  \\<Longrightarrow> states ?c2' = states ?c1'\n\ngoal (1 subgoal):\n 1. states c1 = states c2", "by fast"], ["", "subsubsection \\<open>Existence of successors\\<close>"], ["", "text \\<open>Here, we are interested in proving that, under certain assumptions, there will always exist \nfresh symbolic variables for configurations on which symbolic execution is performed. Thus symbolic \nexecution cannot ``block'' when an assignment is met. For symbolic execution not to block in this \ncase, the configuration from which it is performed must be such that there exist fresh symbolic \nvariables for each program variable. Such configurations are said to be \\emph{updatable}.\\<close>"], ["", "definition updatable :: \n  \"('v,'d) conf \\<Rightarrow> bool\" \nwhere\n  \"updatable c \\<equiv> \\<forall> v. \\<exists> sv. fst sv = v \\<and> fresh_symvar sv c\""], ["", "text \\<open>The following lemma shows that being updatable is a sufficient condition for a configuration \nin order for @{term \"se\"} not to block.\\<close>"], ["", "lemma updatable_imp_ex_se_suc :\n  assumes \"updatable c\"\n  shows   \"\\<exists> c'. se c l c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. se c l c'", "using assms"], ["proof (prove)\nusing this:\n  updatable c\n\ngoal (1 subgoal):\n 1. \\<exists>c'. se c l c'", "by (cases l, simp_all add :  se_Assume_eq se_Assign_eq updatable_def)"], ["", "text \\<open>A sufficient condition for a configuration to be updatable is that its path predicate has \na finite number of variables. The @{term \"store\"} component has no influence here, since its set of \nsymbolic variables is always a strict subset of the set of symbolic variables (i.e.\\ there always \nexist fresh symbolic variables for a store). To establish this proof, we need the following \nintermediate lemma.\\<close>"], ["", "text \\<open>We want to prove that if the set of symbolic variables of the path predicate of a \nconfiguration is finite, then we can find a fresh symbolic variable for it. However, we express this \nwith a more general lemma. We show that given a finite set of symbolic variables @{term \"SV\"} and a\nprogram variable @{term \"v\"} such that there exist symbolic variables in @{term \"SV\"} that are \nindexed versions of @{term \"v\"}, then there exists a symbolic variable for @{term \"v\"} whose index \nis greater or equal than the index of any other symbolic variable for @{term \"v\"} in @{term SV}.\\<close>"], ["", "lemma finite_symvars_imp_ex_greatest_symvar :\n  fixes SV :: \"'a symvar set\"\n  assumes \"finite SV\"\n  assumes \"\\<exists> sv \\<in> SV. fst sv = v\"\n  shows   \"\\<exists> sv  \\<in> {sv \\<in> SV. fst sv = v}. \n           \\<forall> sv' \\<in> {sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "have \"finite (snd ` {sv \\<in> SV. fst sv = v})\"\n  and  \"snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (snd ` {sv \\<in> SV. fst sv = v}) &&&\n    snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  finite SV\n  \\<exists>sv\\<in>SV. fst sv = v\n\ngoal (1 subgoal):\n 1. finite (snd ` {sv \\<in> SV. fst sv = v}) &&&\n    snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  finite (snd ` {sv \\<in> SV. fst sv = v})\n  snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "moreover"], ["proof (state)\nthis:\n  finite (snd ` {sv \\<in> SV. fst sv = v})\n  snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "have \"\\<forall> (E::nat set). finite E \\<and> E \\<noteq> {} \\<longrightarrow> (\\<exists> n \\<in> E. \\<forall> m \\<in> E. m \\<le> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>E.\n       finite E \\<and> E \\<noteq> {} \\<longrightarrow>\n       (\\<exists>n\\<in>E. \\<forall>m\\<in>E. m \\<le> n)", "by (intro allI impI, induct_tac rule : finite_ne_induct) \n     (simp+, force)"], ["proof (state)\nthis:\n  \\<forall>E.\n     finite E \\<and> E \\<noteq> {} \\<longrightarrow>\n     (\\<exists>n\\<in>E. \\<forall>m\\<in>E. m \\<le> n)\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "ultimately"], ["proof (chain)\npicking this:\n  finite (snd ` {sv \\<in> SV. fst sv = v})\n  snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}\n  \\<forall>E.\n     finite E \\<and> E \\<noteq> {} \\<longrightarrow>\n     (\\<exists>n\\<in>E. \\<forall>m\\<in>E. m \\<le> n)", "obtain n \n  where \"n \\<in> snd ` {sv \\<in> SV. fst sv = v}\"\n  and   \"\\<forall> m \\<in> snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\""], ["proof (prove)\nusing this:\n  finite (snd ` {sv \\<in> SV. fst sv = v})\n  snd ` {sv \\<in> SV. fst sv = v} \\<noteq> {}\n  \\<forall>E.\n     finite E \\<and> E \\<noteq> {} \\<longrightarrow>\n     (\\<exists>n\\<in>E. \\<forall>m\\<in>E. m \\<le> n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<in> snd ` {sv \\<in> SV. fst sv = v};\n         \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n \\<in> snd ` {sv \\<in> SV. fst sv = v}\n  \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "moreover"], ["proof (state)\nthis:\n  n \\<in> snd ` {sv \\<in> SV. fst sv = v}\n  \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "then"], ["proof (chain)\npicking this:\n  n \\<in> snd ` {sv \\<in> SV. fst sv = v}\n  \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n", "obtain sv \n  where \"sv \\<in> {sv \\<in> SV. fst sv = v}\" and \"snd sv = n\""], ["proof (prove)\nusing this:\n  n \\<in> snd ` {sv \\<in> SV. fst sv = v}\n  \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>sv.\n        \\<lbrakk>sv \\<in> {sv \\<in> SV. fst sv = v}; snd sv = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sv \\<in> {sv \\<in> SV. fst sv = v}\n  snd sv = n\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> snd ` {sv \\<in> SV. fst sv = v}\n  \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\n  sv \\<in> {sv \\<in> SV. fst sv = v}\n  snd sv = n", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> snd ` {sv \\<in> SV. fst sv = v}\n  \\<forall>m\\<in>snd ` {sv \\<in> SV. fst sv = v}. m \\<le> n\n  sv \\<in> {sv \\<in> SV. fst sv = v}\n  snd sv = n\n\ngoal (1 subgoal):\n 1. \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n       \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv", "by blast"], ["proof (state)\nthis:\n  \\<exists>sv\\<in>{sv \\<in> SV. fst sv = v}.\n     \\<forall>sv'\\<in>{sv \\<in> SV. fst sv = v}. snd sv' \\<le> snd sv\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Thus, a configuration whose path predicate has a finite set of variables is updatable. For\nexample, for any program variable @{term \"v\"}, the symbolic variable  \\<open>(v,i+1)\\<close> is fresh for \nthis configuration, where @{term \"i\"} is the greater index associated to @{term \"v\"} among the \nsymbolic variables of this configuration. In practice, this is how we choose the fresh symbolic \nvariable.\\<close>"], ["", "lemma finite_pred_imp_se_updatable :\n  assumes \"finite (Bexp.vars (conjunct (pred c)))\" (is \"finite ?V\")\n  shows   \"updatable c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. updatable c", "unfolding updatable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "show \"\\<exists>sv. fst sv = v \\<and> fresh_symvar sv c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "proof (case_tac \"\\<exists> sv \\<in> ?V. fst sv = v\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n       fst sv = v \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c\n 2. \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n               fst sv = v) \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "case 1"], ["proof (state)\nthis:\n  \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v\n\ngoal (2 subgoals):\n 1. \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n       fst sv = v \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c\n 2. \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n               fst sv = v) \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "then"], ["proof (chain)\npicking this:\n  \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v", "obtain max_sv \n    where       \"max_sv \\<in> ?V\"\n    and         \"fst max_sv = v\"\n    and   max : \"\\<forall>sv'\\<in>{sv \\<in> ?V. fst sv = v}. snd sv' \\<le> snd max_sv\""], ["proof (prove)\nusing this:\n  \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v\n\ngoal (1 subgoal):\n 1. (\\<And>max_sv.\n        \\<lbrakk>max_sv \\<in> Bexp.vars (conjunct (pred c)); fst max_sv = v;\n         \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                           fst sv = v}.\n            snd sv' \\<le> snd max_sv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms finite_symvars_imp_ex_greatest_symvar[of ?V v]"], ["proof (prove)\nusing this:\n  \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v\n  finite (Bexp.vars (conjunct (pred c)))\n  \\<lbrakk>finite (Bexp.vars (conjunct (pred c)));\n   \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sv\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                                     fst sv = v}.\n                       \\<forall>sv'\\<in>{sv\n   \\<in> Bexp.vars (conjunct (pred c)).\n   fst sv = v}.\n                          snd sv' \\<le> snd sv\n\ngoal (1 subgoal):\n 1. (\\<And>max_sv.\n        \\<lbrakk>max_sv \\<in> Bexp.vars (conjunct (pred c)); fst max_sv = v;\n         \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                           fst sv = v}.\n            snd sv' \\<le> snd max_sv\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  max_sv \\<in> Bexp.vars (conjunct (pred c))\n  fst max_sv = v\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n\ngoal (2 subgoals):\n 1. \\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n       fst sv = v \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c\n 2. \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n               fst sv = v) \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "using max"], ["proof (prove)\nusing this:\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n\ngoal (1 subgoal):\n 1. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "unfolding fresh_symvar_def symvars_def Store.symvars_def symvar_def"], ["proof (prove)\nusing this:\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n\ngoal (1 subgoal):\n 1. \\<exists>sv.\n       fst sv = v \\<and>\n       sv \\<notin> range (\\<lambda>v. (v, store c v)) \\<union>\n                   Bexp.vars (conjunct (pred c))", "proof (case_tac \"snd max_sv \\<le> store c v\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))\n 2. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     \\<not> snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))", "case 1"], ["proof (state)\nthis:\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n  snd max_sv \\<le> store c v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))\n 2. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     \\<not> snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n  snd max_sv \\<le> store c v\n\ngoal (1 subgoal):\n 1. \\<exists>sv.\n       fst sv = v \\<and>\n       sv \\<notin> range (\\<lambda>v. (v, store c v)) \\<union>\n                   Bexp.vars (conjunct (pred c))", "by (rule_tac ?x=\"(v,Suc (store c v))\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>sv.\n     fst sv = v \\<and>\n     sv \\<notin> range (\\<lambda>v. (v, store c v)) \\<union>\n                 Bexp.vars (conjunct (pred c))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     \\<not> snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     \\<not> snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))", "case 2"], ["proof (state)\nthis:\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n  \\<not> snd max_sv \\<le> store c v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)).\n                               fst sv = v}.\n                snd sv' \\<le> snd max_sv;\n     \\<not> snd max_sv \\<le> store c v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sv.\n                         fst sv = v \\<and>\n                         sv \\<notin> range\n(\\<lambda>v. (v, store c v)) \\<union>\n                                     Bexp.vars (conjunct (pred c))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>sv'\\<in>{sv \\<in> Bexp.vars (conjunct (pred c)). fst sv = v}.\n     snd sv' \\<le> snd max_sv\n  \\<not> snd max_sv \\<le> store c v\n\ngoal (1 subgoal):\n 1. \\<exists>sv.\n       fst sv = v \\<and>\n       sv \\<notin> range (\\<lambda>v. (v, store c v)) \\<union>\n                   Bexp.vars (conjunct (pred c))", "by (rule_tac ?x=\"(v,Suc (snd max_sv))\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>sv.\n     fst sv = v \\<and>\n     sv \\<notin> range (\\<lambda>v. (v, store c v)) \\<union>\n                 Bexp.vars (conjunct (pred c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n               fst sv = v) \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n               fst sv = v) \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "case 2"], ["proof (state)\nthis:\n  \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)).\n               fst sv = v) \\<Longrightarrow>\n    \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>sv\\<in>Bexp.vars (conjunct (pred c)). fst sv = v)\n\ngoal (1 subgoal):\n 1. \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c", "by (rule_tac ?x=\"(v, Suc (store c v))\" in exI)\n       (auto simp add : fresh_symvar_def symvars_def Store.symvars_def symvar_def)"], ["proof (state)\nthis:\n  \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sv. fst sv = v \\<and> Conf.fresh_symvar sv c\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The path predicate of a configuration whose @{term \"pred\"} component is finite and whose \nelements all have finite sets of variables has a finite set of variables. Thus, this configuration \nis updatable, and it has a successor by symbolic execution of any label. The following lemma \nstarts from these two assumptions and use the previous ones in order to directly get to the \nconclusion (this will ease some of the following proofs).\\<close>"], ["", "lemma finite_imp_ex_se_succ :\n  assumes \"finite (pred c)\"\n  assumes \"\\<forall> e \\<in> pred c. finite (Bexp.vars e)\"\n  shows   \"\\<exists> c'. se c l c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. se c l c'", "using finite_pred_imp_se_updatable[OF finite_conj[OF assms(1,2)]]"], ["proof (prove)\nusing this:\n  updatable c\n\ngoal (1 subgoal):\n 1. \\<exists>c'. se c l c'", "by (rule updatable_imp_ex_se_suc)"], ["", "text \\<open>For symbolic execution not to block \\emph{along a sequence of labels}, it is not sufficient \nfor the first configuration to be updatable. It must also be such that (all) its successors are \nupdatable. A sufficient condition for this is that the set of variables of its path predicate is \nfinite and that the sub-expression of the label that is executed also has a finite set of variables. \nUnder these assumptions, symbolic execution preserves finiteness of the @{term \"pred\"} component and \nof the sets of variables of its elements. Thus, successors @{term \"se\"} are also updatable because \nthey also have a path predicate with a finite set of variables. In the following, to prove \nthis we need two intermediate lemmas: \n\\begin{itemize}\n  \\item one stating that symbolic execution perserves the finiteness of the set of variables of the \nelements of the @{term \"pred\"} component, provided that the sub expression of the label that is \nexecuted has a finite set of variables, \n  \\item one stating that symbolic execution preserves the finiteness of the @{term \"pred\"} \ncomponent.\n\\end{itemize}\\<close>"], ["", "lemma se_preserves_finiteness1 :\n  assumes \"finite_label l\"\n  assumes \"se c l c'\"\n  assumes \"\\<forall> e \\<in> pred c.  finite (Bexp.vars e)\"\n  shows   \"\\<forall> e \\<in> pred c'. finite (Bexp.vars e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "proof (cases l)"], ["proof (state)\ngoal (3 subgoals):\n 1. l = Skip \\<Longrightarrow> \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 2. \\<And>x2.\n       l = Assume x2 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 3. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "case Skip"], ["proof (state)\nthis:\n  l = Skip\n\ngoal (3 subgoals):\n 1. l = Skip \\<Longrightarrow> \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 2. \\<And>x2.\n       l = Assume x2 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 3. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Skip\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "using assms"], ["proof (prove)\nusing this:\n  l = Skip\n  finite_label l\n  se c l c'\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "by (simp add : )"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       l = Assume x2 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 2. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       l = Assume x2 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 2. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "case (Assume e)"], ["proof (state)\nthis:\n  l = Assume e\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       l = Assume x2 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n 2. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = Assume e\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "using assms finite_vars_imp_finite_adapt_b"], ["proof (prove)\nusing this:\n  l = Assume e\n  finite_label l\n  se c l c'\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite (Bexp.vars ?e) \\<Longrightarrow>\n  finite (Bexp.vars (adapt_bexp ?e ?s))\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "by (auto simp add : se_Assume_eq finite_label_def)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "case (Assign v e)"], ["proof (state)\nthis:\n  l = Assign v e\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "then"], ["proof (chain)\npicking this:\n  l = Assign v e", "obtain sv \n  where \"fresh_symvar sv c\"\n  and   \"fst sv = v\"\n  and   \"c' = \\<lparr> store = (store c)(v := snd sv),\n                pred  = insert (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>) (pred c)\\<rparr>\""], ["proof (prove)\nusing this:\n  l = Assign v e\n\ngoal (1 subgoal):\n 1. (\\<And>sv.\n        \\<lbrakk>Conf.fresh_symvar sv c; fst sv = v;\n         c' =\n         \\<lparr>store = (store c)(v := snd sv),\n            pred =\n              insert\n               (\\<lambda>\\<sigma>.\n                   \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n               (pred c)\\<rparr>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) se_Assign_eq[of c v e c']"], ["proof (prove)\nusing this:\n  l = Assign v e\n  se c l c'\n  se c (Assign v e) c' =\n  (\\<exists>sv.\n      Conf.fresh_symvar sv c \\<and>\n      fst sv = v \\<and>\n      c' =\n      \\<lparr>store = (store c)(v := snd sv),\n         pred =\n           insert\n            (\\<lambda>\\<sigma>.\n                \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n            (pred c)\\<rparr>)\n\ngoal (1 subgoal):\n 1. (\\<And>sv.\n        \\<lbrakk>Conf.fresh_symvar sv c; fst sv = v;\n         c' =\n         \\<lparr>store = (store c)(v := snd sv),\n            pred =\n              insert\n               (\\<lambda>\\<sigma>.\n                   \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n               (pred c)\\<rparr>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Conf.fresh_symvar sv c\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "moreover"], ["proof (state)\nthis:\n  Conf.fresh_symvar sv c\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "have \"finite (Bexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "have \"finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))", "by (auto simp add : Aexp.vars_def)"], ["proof (state)\nthis:\n  finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))\n\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "moreover"], ["proof (state)\nthis:\n  finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))\n\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "have \"finite (Aexp.vars (adapt_aexp e (store c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Aexp.vars (adapt_aexp e (store c)))", "using assms(1) Assign finite_vars_imp_finite_adapt_a"], ["proof (prove)\nusing this:\n  finite_label l\n  l = Assign v e\n  finite (Aexp.vars ?e) \\<Longrightarrow>\n  finite (Aexp.vars (adapt_aexp ?e ?s))\n\ngoal (1 subgoal):\n 1. finite (Aexp.vars (adapt_aexp e (store c)))", "by (auto simp add : finite_label_def)"], ["proof (state)\nthis:\n  finite (Aexp.vars (adapt_aexp e (store c)))\n\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "ultimately"], ["proof (chain)\npicking this:\n  finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))\n  finite (Aexp.vars (adapt_aexp e (store c)))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))\n  finite (Aexp.vars (adapt_aexp e (store c)))\n\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "using finite_vars_of_a_eq"], ["proof (prove)\nusing this:\n  finite (Aexp.vars (\\<lambda>\\<sigma>. \\<sigma> sv))\n  finite (Aexp.vars (adapt_aexp e (store c)))\n  \\<lbrakk>finite (Aexp.vars ?e1.0); finite (Aexp.vars ?e2.0)\\<rbrakk>\n  \\<Longrightarrow> finite\n                     (Bexp.vars\n                       (\\<lambda>\\<sigma>. ?e1.0 \\<sigma> = ?e2.0 \\<sigma>))\n\ngoal (1 subgoal):\n 1. finite\n     (Bexp.vars\n       (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  finite\n   (Bexp.vars\n     (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   (Bexp.vars\n     (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       l = Assign x31 x32 \\<Longrightarrow>\n       \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "ultimately"], ["proof (chain)\npicking this:\n  Conf.fresh_symvar sv c\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n  finite\n   (Bexp.vars\n     (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))", "show ?thesis"], ["proof (prove)\nusing this:\n  Conf.fresh_symvar sv c\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n  finite\n   (Bexp.vars\n     (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "using assms"], ["proof (prove)\nusing this:\n  Conf.fresh_symvar sv c\n  fst sv = v\n  c' =\n  \\<lparr>store = (store c)(v := snd sv),\n     pred =\n       insert\n        (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>)\n        (pred c)\\<rparr>\n  finite\n   (Bexp.vars\n     (\\<lambda>\\<sigma>. \\<sigma> sv = adapt_aexp e (store c) \\<sigma>))\n  finite_label l\n  se c l c'\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c'. finite (Bexp.vars e)", "by auto"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c'. finite (Bexp.vars e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma se_preserves_finiteness2 :\n  assumes \"se c l c'\"\n  assumes \"finite (pred c)\"\n  shows   \"finite (pred c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pred c')", "using assms"], ["proof (prove)\nusing this:\n  se c l c'\n  finite (pred c)\n\ngoal (1 subgoal):\n 1. finite (pred c')", "by (cases l) \n   (auto simp add :  se_Assume_eq se_Assign_eq)"], ["", "text \\<open>We are now ready to prove that a sufficient condition for symbolic execution not to block \nalong a sequence of labels is that the @{term \"pred\"} component of the ``initial \nconfiguration'' is finite, as well as the set of variables of its elements,  and that the \nsub-expression of the label that is executed also has a finite set of variables.\\<close>"], ["", "lemma finite_imp_ex_se_star_succ :\n  assumes \"finite (pred c)\"\n  assumes \"\\<forall> e \\<in> pred c. finite (Bexp.vars e)\"\n  assumes \"finite_labels ls\"\n  shows   \"\\<exists> c'. se_star c ls c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. se_star c ls c'", "using assms"], ["proof (prove)\nusing this:\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels ls\n\ngoal (1 subgoal):\n 1. \\<exists>c'. se_star c ls c'", "proof (induct ls arbitrary : c, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>finite (pred c);\n        \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels []\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c [])\n 2. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "case 1"], ["proof (state)\nthis:\n  finite (pred c_)\n  \\<forall>e\\<in>pred c_. finite (Bexp.vars e)\n  finite_labels []\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>finite (pred c);\n        \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels []\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c [])\n 2. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (se_star c_ [])", "using se_star.simps"], ["proof (prove)\nusing this:\n  se_star ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>c. ?a1.0 = c \\<and> ?a2.0 = [] \\<and> ?a3.0 = c) \\<or>\n   (\\<exists>c1 l c2 ls c3.\n       ?a1.0 = c1 \\<and>\n       ?a2.0 = l # ls \\<and>\n       ?a3.0 = c3 \\<and> se c1 l c2 \\<and> se_star c2 ls c3))\n\ngoal (1 subgoal):\n 1. Ex (se_star c_ [])", "by blast"], ["proof (state)\nthis:\n  Ex (se_star c_ [])\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "case (2 l ls c)"], ["proof (state)\nthis:\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)", "obtain c1 where \"se c l c1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)\n\ngoal (1 subgoal):\n 1. (\\<And>c1. se c l c1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_imp_ex_se_succ"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)\n  \\<lbrakk>finite (pred ?c);\n   \\<forall>e\\<in>pred ?c. finite (Bexp.vars e)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c'. se ?c ?l c'\n\ngoal (1 subgoal):\n 1. (\\<And>c1. se c l c1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  se c l c1\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "hence \"finite (pred c1)\"\n  and   \"\\<forall> e \\<in> pred c1. finite (Bexp.vars e)\""], ["proof (prove)\nusing this:\n  se c l c1\n\ngoal (1 subgoal):\n 1. finite (pred c1) &&& \\<forall>e\\<in>pred c1. finite (Bexp.vars e)", "using 2 se_preserves_finiteness1 se_preserves_finiteness2"], ["proof (prove)\nusing this:\n  se c l c1\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)\n  \\<lbrakk>finite_label ?l; se ?c ?l ?c';\n   \\<forall>e\\<in>pred ?c. finite (Bexp.vars e)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>e\\<in>pred ?c'. finite (Bexp.vars e)\n  \\<lbrakk>se ?c ?l ?c'; finite (pred ?c)\\<rbrakk>\n  \\<Longrightarrow> finite (pred ?c')\n\ngoal (1 subgoal):\n 1. finite (pred c1) &&& \\<forall>e\\<in>pred c1. finite (Bexp.vars e)", "by fastforce+"], ["proof (state)\nthis:\n  finite (pred c1)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "moreover"], ["proof (state)\nthis:\n  finite (pred c1)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "have \"finite_labels ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_labels ls", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)\n\ngoal (1 subgoal):\n 1. finite_labels ls", "by simp"], ["proof (state)\nthis:\n  finite_labels ls\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "ultimately"], ["proof (chain)\npicking this:\n  finite (pred c1)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  finite_labels ls", "obtain c2 where \"se_star c1 ls c2\""], ["proof (prove)\nusing this:\n  finite (pred c1)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  finite_labels ls\n\ngoal (1 subgoal):\n 1. (\\<And>c2. se_star c1 ls c2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2"], ["proof (prove)\nusing this:\n  finite (pred c1)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  finite_labels ls\n  \\<lbrakk>finite (pred ?c); \\<forall>e\\<in>pred ?c. finite (Bexp.vars e);\n   finite_labels ls\\<rbrakk>\n  \\<Longrightarrow> Ex (se_star ?c ls)\n  finite (pred c)\n  \\<forall>e\\<in>pred c. finite (Bexp.vars e)\n  finite_labels (l # ls)\n\ngoal (1 subgoal):\n 1. (\\<And>c2. se_star c1 ls c2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  se_star c1 ls c2\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>finite (pred c);\n                    \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n                    finite_labels ls\\<rbrakk>\n                   \\<Longrightarrow> Ex (se_star c ls);\n        finite (pred c); \\<forall>e\\<in>pred c. finite (Bexp.vars e);\n        finite_labels (a # ls)\\<rbrakk>\n       \\<Longrightarrow> Ex (se_star c (a # ls))", "thus ?case"], ["proof (prove)\nusing this:\n  se_star c1 ls c2\n\ngoal (1 subgoal):\n 1. Ex (se_star c (l # ls))", "using \\<open>se c l c1\\<close>"], ["proof (prove)\nusing this:\n  se_star c1 ls c2\n  se c l c1\n\ngoal (1 subgoal):\n 1. Ex (se_star c (l # ls))", "using se_star_Cons"], ["proof (prove)\nusing this:\n  se_star c1 ls c2\n  se c l c1\n  se_star ?c1.0 (?l # ?ls) ?c2.0 =\n  (\\<exists>c. se ?c1.0 ?l c \\<and> se_star c ?ls ?c2.0)\n\ngoal (1 subgoal):\n 1. Ex (se_star c (l # ls))", "by blast"], ["proof (state)\nthis:\n  Ex (se_star c (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Feasibility of a sequence of labels\\<close>"], ["", "text \\<open>A sequence of labels @{term \"ls\"} is said to be feasible from a configuration @{term \"c\"} \nif there exists a satisfiable configuration @{term \"c'\"} obtained by symbolic execution of \n@{term \"ls\"} from @{term \"c\"}.\\<close>"], ["", "definition feasible :: \"('v,'d) conf \\<Rightarrow> ('v,'d) label list \\<Rightarrow> bool\" where\n  \"feasible c ls \\<equiv> (\\<exists> c'. se_star c ls c' \\<and> sat c')\""], ["", "text \\<open>A simplification lemma for the case where @{term \"ls\"} is not empty.\\<close>"], ["", "lemma feasible_Cons :\n  \"feasible c (l#ls) = (\\<exists> c'. se c l c' \\<and> sat c' \\<and> feasible c' ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible c (l # ls) =\n    (\\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls)", "proof (intro iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. feasible c (l # ls) \\<Longrightarrow>\n    \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls\n 2. \\<exists>c'.\n       se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls \\<Longrightarrow>\n    feasible c (l # ls)", "case 1"], ["proof (state)\nthis:\n  feasible c (l # ls)\n\ngoal (2 subgoals):\n 1. feasible c (l # ls) \\<Longrightarrow>\n    \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls\n 2. \\<exists>c'.\n       se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls \\<Longrightarrow>\n    feasible c (l # ls)", "thus ?case"], ["proof (prove)\nusing this:\n  feasible c (l # ls)\n\ngoal (1 subgoal):\n 1. \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls", "using se_star_sat_imp_sat"], ["proof (prove)\nusing this:\n  feasible c (l # ls)\n  \\<lbrakk>se_star ?c ?ls ?c'; Conf.sat ?c'\\<rbrakk>\n  \\<Longrightarrow> Conf.sat ?c\n\ngoal (1 subgoal):\n 1. \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls", "by (simp add : feasible_def se_star_Cons) blast"], ["proof (state)\nthis:\n  \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls \\<Longrightarrow>\n    feasible c (l # ls)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls \\<Longrightarrow>\n    feasible c (l # ls)", "case 2"], ["proof (state)\nthis:\n  \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls \\<Longrightarrow>\n    feasible c (l # ls)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>c'. se c l c' \\<and> Conf.sat c' \\<and> feasible c' ls\n\ngoal (1 subgoal):\n 1. feasible c (l # ls)", "unfolding feasible_def se_star_Cons"], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     se c l c' \\<and>\n     Conf.sat c' \\<and>\n     (\\<exists>c'a. se_star c' ls c'a \\<and> Conf.sat c'a)\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       (\\<exists>ca. se c l ca \\<and> se_star ca ls c') \\<and> Conf.sat c'", "by blast"], ["proof (state)\nthis:\n  feasible c (l # ls)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following theorem is very important for the rest of this formalization. It states that, \ngiven two \nconfigurations @{term \"c1\"} and @{term \"c2\"} such that @{term \"c1\"} subsums @{term \"c2\"}, then \nany feasible sequence of labels from @{term \"c2\"} is also feasible from @{term \"c1\"}. This is a crucial \npoint in order to prove that our approach preserves the set of feasible paths of the original LTS. \nThis proof requires a number of assumptions about the finiteness of the sequence of labels, of \nthe path predicates of the two configurations and of their states of variables. \nThose assumptions are needed in order to show that there exist successors of \nboth configurations by symbolic execution of the sequence of labels.\\<close>"], ["", "lemma subsums_imp_feasible :\n  assumes \"finite_labels ls\"\n  assumes \"finite (pred c1)\"\n  assumes \"finite (pred c2)\"\n  assumes \"\\<forall> e \\<in> pred c1. finite (Bexp.vars e)\"\n  assumes \"\\<forall> e \\<in> pred c2. finite (Bexp.vars e)\"\n  assumes \"c2 \\<sqsubseteq> c1\"\n  assumes \"feasible c2 ls\"\n  shows   \"feasible c1 ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible c1 ls", "using assms"], ["proof (prove)\nusing this:\n  finite_labels ls\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 ls\n\ngoal (1 subgoal):\n 1. feasible c1 ls", "proof (induct ls arbitrary : c1 c2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c1 c2.\n       \\<lbrakk>finite_labels []; finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 []\\<rbrakk>\n       \\<Longrightarrow> feasible c1 []\n 2. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "case Nil"], ["proof (state)\nthis:\n  finite_labels []\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 []\n\ngoal (2 subgoals):\n 1. \\<And>c1 c2.\n       \\<lbrakk>finite_labels []; finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 []\\<rbrakk>\n       \\<Longrightarrow> feasible c1 []\n 2. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "thus ?case"], ["proof (prove)\nusing this:\n  finite_labels []\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 []\n\ngoal (1 subgoal):\n 1. feasible c1 []", "by (simp add : feasible_def sat_sub_by_sat)"], ["proof (state)\nthis:\n  feasible c1 []\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "case (Cons l ls c1 c2)"], ["proof (state)\nthis:\n  \\<lbrakk>finite_labels ls; finite (pred ?c1.0); finite (pred ?c2.0);\n   \\<forall>e\\<in>pred ?c1.0. finite (Bexp.vars e);\n   \\<forall>e\\<in>pred ?c2.0. finite (Bexp.vars e);\n   ?c2.0 \\<sqsubseteq> ?c1.0; feasible ?c2.0 ls\\<rbrakk>\n  \\<Longrightarrow> feasible ?c1.0 ls\n  finite_labels (l # ls)\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 (l # ls)\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite_labels ls; finite (pred ?c1.0); finite (pred ?c2.0);\n   \\<forall>e\\<in>pred ?c1.0. finite (Bexp.vars e);\n   \\<forall>e\\<in>pred ?c2.0. finite (Bexp.vars e);\n   ?c2.0 \\<sqsubseteq> ?c1.0; feasible ?c2.0 ls\\<rbrakk>\n  \\<Longrightarrow> feasible ?c1.0 ls\n  finite_labels (l # ls)\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 (l # ls)", "obtain c2' where \"se c2 l c2'\"\n                  and   \"sat c2'\"\n                  and   \"feasible c2' ls\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite_labels ls; finite (pred ?c1.0); finite (pred ?c2.0);\n   \\<forall>e\\<in>pred ?c1.0. finite (Bexp.vars e);\n   \\<forall>e\\<in>pred ?c2.0. finite (Bexp.vars e);\n   ?c2.0 \\<sqsubseteq> ?c1.0; feasible ?c2.0 ls\\<rbrakk>\n  \\<Longrightarrow> feasible ?c1.0 ls\n  finite_labels (l # ls)\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 (l # ls)\n\ngoal (1 subgoal):\n 1. (\\<And>c2'.\n        \\<lbrakk>se c2 l c2'; Conf.sat c2'; feasible c2' ls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using feasible_Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite_labels ls; finite (pred ?c1.0); finite (pred ?c2.0);\n   \\<forall>e\\<in>pred ?c1.0. finite (Bexp.vars e);\n   \\<forall>e\\<in>pred ?c2.0. finite (Bexp.vars e);\n   ?c2.0 \\<sqsubseteq> ?c1.0; feasible ?c2.0 ls\\<rbrakk>\n  \\<Longrightarrow> feasible ?c1.0 ls\n  finite_labels (l # ls)\n  finite (pred c1)\n  finite (pred c2)\n  \\<forall>e\\<in>pred c1. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2. finite (Bexp.vars e)\n  c2 \\<sqsubseteq> c1\n  feasible c2 (l # ls)\n  feasible ?c (?l # ?ls) =\n  (\\<exists>c'. se ?c ?l c' \\<and> Conf.sat c' \\<and> feasible c' ?ls)\n\ngoal (1 subgoal):\n 1. (\\<And>c2'.\n        \\<lbrakk>se c2 l c2'; Conf.sat c2'; feasible c2' ls\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  se c2 l c2'\n  Conf.sat c2'\n  feasible c2' ls\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "obtain c1' where \"se c1 l c1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c1'. se c1 l c1' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_conj[OF Cons(3,5)]\n        finite_pred_imp_se_updatable\n        updatable_imp_ex_se_suc"], ["proof (prove)\nusing this:\n  finite (Bexp.vars (conjunct (pred c1)))\n  finite (Bexp.vars (conjunct (pred ?c))) \\<Longrightarrow> updatable ?c\n  updatable ?c \\<Longrightarrow> \\<exists>c'. se ?c ?l c'\n\ngoal (1 subgoal):\n 1. (\\<And>c1'. se c1 l c1' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  se c1 l c1'\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "moreover"], ["proof (state)\nthis:\n  se c1 l c1'\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "hence \"sat c1'\""], ["proof (prove)\nusing this:\n  se c1 l c1'\n\ngoal (1 subgoal):\n 1. Conf.sat c1'", "using  se_mono_for_sub[OF _ \\<open>se c2 l c2'\\<close> Cons(7)]\n         sat_sub_by_sat[OF \\<open>sat c2'\\<close>]"], ["proof (prove)\nusing this:\n  se c1 l c1'\n  se c1 l ?c1' \\<Longrightarrow> c2' \\<sqsubseteq> ?c1'\n  c2' \\<sqsubseteq> ?c\\<^sub>1 \\<Longrightarrow> Conf.sat ?c\\<^sub>1\n\ngoal (1 subgoal):\n 1. Conf.sat c1'", "by fast"], ["proof (state)\nthis:\n  Conf.sat c1'\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "moreover"], ["proof (state)\nthis:\n  Conf.sat c1'\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "have \"feasible c1' ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. feasible c1' ls", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. feasible c1' ls", "have \"finite_label  l\" \n    and  \"finite_labels ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_label l &&& finite_labels ls", "using Cons(2)"], ["proof (prove)\nusing this:\n  finite_labels (l # ls)\n\ngoal (1 subgoal):\n 1. finite_label l &&& finite_labels ls", "by simp_all"], ["proof (state)\nthis:\n  finite_label l\n  finite_labels ls\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "have \"finite (pred c1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pred c1')", "by (rule se_preserves_finiteness2[OF \\<open>se c1 l c1'\\<close> Cons(3)])"], ["proof (state)\nthis:\n  finite (pred c1')\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "moreover"], ["proof (state)\nthis:\n  finite (pred c1')\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "have \"finite (pred c2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (pred c2')", "by (rule se_preserves_finiteness2[OF \\<open>se c2 l c2'\\<close> Cons(4)])"], ["proof (state)\nthis:\n  finite (pred c2')\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "moreover"], ["proof (state)\nthis:\n  finite (pred c2')\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "have \"\\<forall>e\\<in>pred c1'. finite (Bexp.vars e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c1'. finite (Bexp.vars e)", "by (rule se_preserves_finiteness1[OF \\<open>finite_label l\\<close> \\<open>se c1 l c1'\\<close> Cons(5)])"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c1'. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "moreover"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c1'. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "have \"\\<forall>e\\<in>pred c2'. finite (Bexp.vars e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>pred c2'. finite (Bexp.vars e)", "by (rule se_preserves_finiteness1[OF \\<open>finite_label l\\<close> \\<open>se c2 l c2'\\<close> Cons(6)])"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c2'. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "moreover"], ["proof (state)\nthis:\n  \\<forall>e\\<in>pred c2'. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "have \"c2' \\<sqsubseteq> c1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c2' \\<sqsubseteq> c1'", "by (rule se_mono_for_sub[OF \\<open>se c1 l c1'\\<close> \\<open>se c2 l c2'\\<close> Cons(7)])"], ["proof (state)\nthis:\n  c2' \\<sqsubseteq> c1'\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "ultimately"], ["proof (chain)\npicking this:\n  finite (pred c1')\n  finite (pred c2')\n  \\<forall>e\\<in>pred c1'. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2'. finite (Bexp.vars e)\n  c2' \\<sqsubseteq> c1'", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (pred c1')\n  finite (pred c2')\n  \\<forall>e\\<in>pred c1'. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2'. finite (Bexp.vars e)\n  c2' \\<sqsubseteq> c1'\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "using Cons(1) \\<open>feasible c2' ls\\<close> \\<open>finite_labels ls\\<close>"], ["proof (prove)\nusing this:\n  finite (pred c1')\n  finite (pred c2')\n  \\<forall>e\\<in>pred c1'. finite (Bexp.vars e)\n  \\<forall>e\\<in>pred c2'. finite (Bexp.vars e)\n  c2' \\<sqsubseteq> c1'\n  \\<lbrakk>finite_labels ls; finite (pred ?c1.0); finite (pred ?c2.0);\n   \\<forall>e\\<in>pred ?c1.0. finite (Bexp.vars e);\n   \\<forall>e\\<in>pred ?c2.0. finite (Bexp.vars e);\n   ?c2.0 \\<sqsubseteq> ?c1.0; feasible ?c2.0 ls\\<rbrakk>\n  \\<Longrightarrow> feasible ?c1.0 ls\n  feasible c2' ls\n  finite_labels ls\n\ngoal (1 subgoal):\n 1. feasible c1' ls", "by fast"], ["proof (state)\nthis:\n  feasible c1' ls\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  feasible c1' ls\n\ngoal (1 subgoal):\n 1. \\<And>a ls c1 c2.\n       \\<lbrakk>\\<And>c1 c2.\n                   \\<lbrakk>finite_labels ls; finite (pred c1);\n                    finite (pred c2);\n                    \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n                    \\<forall>e\\<in>pred c2. finite (Bexp.vars e);\n                    c2 \\<sqsubseteq> c1; feasible c2 ls\\<rbrakk>\n                   \\<Longrightarrow> feasible c1 ls;\n        finite_labels (a # ls); finite (pred c1); finite (pred c2);\n        \\<forall>e\\<in>pred c1. finite (Bexp.vars e);\n        \\<forall>e\\<in>pred c2. finite (Bexp.vars e); c2 \\<sqsubseteq> c1;\n        feasible c2 (a # ls)\\<rbrakk>\n       \\<Longrightarrow> feasible c1 (a # ls)", "ultimately"], ["proof (chain)\npicking this:\n  se c1 l c1'\n  Conf.sat c1'\n  feasible c1' ls", "show ?case"], ["proof (prove)\nusing this:\n  se c1 l c1'\n  Conf.sat c1'\n  feasible c1' ls\n\ngoal (1 subgoal):\n 1. feasible c1 (l # ls)", "by (auto simp add : feasible_Cons)"], ["proof (state)\nthis:\n  feasible c1 (l # ls)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Concrete execution\\<close>"], ["", "text \\<open>We illustrate our notion of symbolic execution by relating it with @{term ce}, an inductive \npredicate describing concrete execution. Unlike symbolic execution, concrete execution describes \nprogram behavior given program states, i.e.\\ concrete valuations for program variables. The \ngoal of this section is to show that our notion of symbolic execution is correct, that is: given two \nconfigurations such that one results from the symbolic execution of a sequence of labels from the \nother, then the resulting configuration represents the set of states that are reachable by \nconcrete execution from the states of the original configuration.\\<close>"], ["", "inductive ce ::\n  \"('v,'d) state \\<Rightarrow> ('v,'d) label \\<Rightarrow> ('v,'d) state \\<Rightarrow> bool\"\nwhere\n  \"ce \\<sigma> Skip \\<sigma>\"\n| \"e \\<sigma> \\<Longrightarrow> ce \\<sigma> (Assume e) \\<sigma>\"\n| \"ce \\<sigma> (Assign v e) (\\<sigma>(v := e \\<sigma>))\""], ["", "inductive ce_star :: \"('v,'d) state \\<Rightarrow> ('v,'d) label list \\<Rightarrow> ('v,'d) state \\<Rightarrow> bool\" where\n  \"ce_star c [] c\"\n| \"ce c1 l c2 \\<Longrightarrow> ce_star c2 ls c3 \\<Longrightarrow> ce_star c1 (l # ls) c3\""], ["", "lemma [simp] :\n  \"ce \\<sigma> Skip \\<sigma>' = (\\<sigma>' = \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce \\<sigma> Skip \\<sigma>' = (\\<sigma>' = \\<sigma>)", "by (auto simp add : ce.simps)"], ["", "lemma [simp] :\n  \"ce \\<sigma> (Assume e) \\<sigma>' = (\\<sigma>' = \\<sigma> \\<and> e \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce \\<sigma> (Assume e) \\<sigma>' =\n    (\\<sigma>' = \\<sigma> \\<and> e \\<sigma>)", "by (auto simp add : ce.simps)"], ["", "lemma [simp] :\n  \"ce \\<sigma> (Assign v e) \\<sigma>' = (\\<sigma>' = \\<sigma>(v := e \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce \\<sigma> (Assign v e) \\<sigma>' =\n    (\\<sigma>' = \\<sigma>(v := e \\<sigma>))", "by (auto simp add : ce.simps)"], ["", "lemma se_as_ce :\n  assumes \"se c l c'\"\n  shows   \"states c' = {\\<sigma>'. \\<exists> \\<sigma> \\<in> states c. ce \\<sigma> l \\<sigma>'} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>'. \\<exists>\\<sigma>\\<in>states c. ce \\<sigma> l \\<sigma>'}", "using assms"], ["proof (prove)\nusing this:\n  se c l c'\n\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>'. \\<exists>\\<sigma>\\<in>states c. ce \\<sigma> l \\<sigma>'}", "by (cases l)\n   (auto simp add: states_of_se_assume states_of_se_assign)"], ["", "lemma [simp] :\n  \"ce_star \\<sigma> [] \\<sigma>' = (\\<sigma>' = \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce_star \\<sigma> [] \\<sigma>' = (\\<sigma>' = \\<sigma>)", "by (subst ce_star.simps) simp"], ["", "lemma ce_star_Cons :\n  \"ce_star \\<sigma>1 (l # ls) \\<sigma>2 = (\\<exists> \\<sigma>. ce \\<sigma>1 l \\<sigma> \\<and> ce_star \\<sigma> ls \\<sigma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce_star \\<sigma>1 (l # ls) \\<sigma>2 =\n    (\\<exists>\\<sigma>.\n        ce \\<sigma>1 l \\<sigma> \\<and> ce_star \\<sigma> ls \\<sigma>2)", "by (subst (1) ce_star.simps) blast"], ["", "lemma se_star_as_ce_star :\n  assumes \"se_star c ls c'\"\n  shows   \"states c' = {\\<sigma>'. \\<exists> \\<sigma> \\<in> states c. ce_star \\<sigma> ls \\<sigma>'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>'.\n     \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> ls \\<sigma>'}", "using assms"], ["proof (prove)\nusing this:\n  se_star c ls c'\n\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>'.\n     \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> ls \\<sigma>'}", "proof (induct ls arbitrary : c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       se_star c [] c' \\<Longrightarrow>\n       states c' =\n       {\\<sigma>'.\n        \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> [] \\<sigma>'}\n 2. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   se_star c ls c' \\<Longrightarrow>\n                   states c' =\n                   {\\<sigma>'.\n                    \\<exists>\\<sigma>\\<in>states c.\n                       ce_star \\<sigma> ls \\<sigma>'};\n        se_star c (a # ls) c'\\<rbrakk>\n       \\<Longrightarrow> states c' =\n                         {\\<sigma>'.\n                          \\<exists>\\<sigma>\\<in>states c.\n                             ce_star \\<sigma> (a # ls) \\<sigma>'}", "case Nil"], ["proof (state)\nthis:\n  se_star c [] c'\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       se_star c [] c' \\<Longrightarrow>\n       states c' =\n       {\\<sigma>'.\n        \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> [] \\<sigma>'}\n 2. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   se_star c ls c' \\<Longrightarrow>\n                   states c' =\n                   {\\<sigma>'.\n                    \\<exists>\\<sigma>\\<in>states c.\n                       ce_star \\<sigma> ls \\<sigma>'};\n        se_star c (a # ls) c'\\<rbrakk>\n       \\<Longrightarrow> states c' =\n                         {\\<sigma>'.\n                          \\<exists>\\<sigma>\\<in>states c.\n                             ce_star \\<sigma> (a # ls) \\<sigma>'}", "thus ?case"], ["proof (prove)\nusing this:\n  se_star c [] c'\n\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>'.\n     \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> [] \\<sigma>'}", "by simp"], ["proof (state)\nthis:\n  states c' =\n  {\\<sigma>'. \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> [] \\<sigma>'}\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   se_star c ls c' \\<Longrightarrow>\n                   states c' =\n                   {\\<sigma>'.\n                    \\<exists>\\<sigma>\\<in>states c.\n                       ce_star \\<sigma> ls \\<sigma>'};\n        se_star c (a # ls) c'\\<rbrakk>\n       \\<Longrightarrow> states c' =\n                         {\\<sigma>'.\n                          \\<exists>\\<sigma>\\<in>states c.\n                             ce_star \\<sigma> (a # ls) \\<sigma>'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   se_star c ls c' \\<Longrightarrow>\n                   states c' =\n                   {\\<sigma>'.\n                    \\<exists>\\<sigma>\\<in>states c.\n                       ce_star \\<sigma> ls \\<sigma>'};\n        se_star c (a # ls) c'\\<rbrakk>\n       \\<Longrightarrow> states c' =\n                         {\\<sigma>'.\n                          \\<exists>\\<sigma>\\<in>states c.\n                             ce_star \\<sigma> (a # ls) \\<sigma>'}", "case (Cons l ls c)"], ["proof (state)\nthis:\n  se_star ?c ls c' \\<Longrightarrow>\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states ?c. ce_star \\<sigma> ls \\<sigma>'}\n  se_star c (l # ls) c'\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   se_star c ls c' \\<Longrightarrow>\n                   states c' =\n                   {\\<sigma>'.\n                    \\<exists>\\<sigma>\\<in>states c.\n                       ce_star \\<sigma> ls \\<sigma>'};\n        se_star c (a # ls) c'\\<rbrakk>\n       \\<Longrightarrow> states c' =\n                         {\\<sigma>'.\n                          \\<exists>\\<sigma>\\<in>states c.\n                             ce_star \\<sigma> (a # ls) \\<sigma>'}", "then"], ["proof (chain)\npicking this:\n  se_star ?c ls c' \\<Longrightarrow>\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states ?c. ce_star \\<sigma> ls \\<sigma>'}\n  se_star c (l # ls) c'", "obtain c'' where \"se c l c''\"\n                  and   \"se_star c'' ls c'\""], ["proof (prove)\nusing this:\n  se_star ?c ls c' \\<Longrightarrow>\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states ?c. ce_star \\<sigma> ls \\<sigma>'}\n  se_star c (l # ls) c'\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        \\<lbrakk>se c l c''; se_star c'' ls c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using se_star_Cons"], ["proof (prove)\nusing this:\n  se_star ?c ls c' \\<Longrightarrow>\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states ?c. ce_star \\<sigma> ls \\<sigma>'}\n  se_star c (l # ls) c'\n  se_star ?c1.0 (?l # ?ls) ?c2.0 =\n  (\\<exists>c. se ?c1.0 ?l c \\<and> se_star c ?ls ?c2.0)\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        \\<lbrakk>se c l c''; se_star c'' ls c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  se c l c''\n  se_star c'' ls c'\n\ngoal (1 subgoal):\n 1. \\<And>a ls c.\n       \\<lbrakk>\\<And>c.\n                   se_star c ls c' \\<Longrightarrow>\n                   states c' =\n                   {\\<sigma>'.\n                    \\<exists>\\<sigma>\\<in>states c.\n                       ce_star \\<sigma> ls \\<sigma>'};\n        se_star c (a # ls) c'\\<rbrakk>\n       \\<Longrightarrow> states c' =\n                         {\\<sigma>'.\n                          \\<exists>\\<sigma>\\<in>states c.\n                             ce_star \\<sigma> (a # ls) \\<sigma>'}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. states c' =\n    {\\<sigma>'.\n     \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> (l # ls) \\<sigma>'}", "unfolding set_eq_iff Bex_def mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> states c') =\n       (\\<exists>xa. xa \\<in> states c \\<and> ce_star xa (l # ls) x)", "proof (intro allI iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> states c' \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> states c \\<and> ce_star xa (l # ls) x\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "case (1 \\<sigma>')"], ["proof (state)\nthis:\n  \\<sigma>' \\<in> states c'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> states c' \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> states c \\<and> ce_star xa (l # ls) x\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "then"], ["proof (chain)\npicking this:\n  \\<sigma>' \\<in> states c'", "obtain \\<sigma>'' where \"\\<sigma>'' \\<in> states c''\"\n                    and   \"ce_star \\<sigma>'' ls \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<sigma>' \\<in> states c'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        \\<lbrakk>\\<sigma>'' \\<in> states c'';\n         ce_star \\<sigma>'' ls \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(1) \\<open>se_star c'' ls c'\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma>' \\<in> states c'\n  se_star ?c ls c' \\<Longrightarrow>\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states ?c. ce_star \\<sigma> ls \\<sigma>'}\n  se_star c'' ls c'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        \\<lbrakk>\\<sigma>'' \\<in> states c'';\n         ce_star \\<sigma>'' ls \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> states c' \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> states c \\<and> ce_star xa (l # ls) x\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "moreover"], ["proof (state)\nthis:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> states c' \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> states c \\<and> ce_star xa (l # ls) x\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "then"], ["proof (chain)\npicking this:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'", "obtain \\<sigma> where \"\\<sigma> \\<in> states c\"\n                  and   \"ce \\<sigma> l \\<sigma>''\""], ["proof (prove)\nusing this:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in> states c; ce \\<sigma> l \\<sigma>''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>se c l c''\\<close>  se_as_ce"], ["proof (prove)\nusing this:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'\n  se c l c''\n  se ?c ?l ?c' \\<Longrightarrow>\n  states ?c' =\n  {\\<sigma>'. \\<exists>\\<sigma>\\<in>states ?c. ce \\<sigma> ?l \\<sigma>'}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in> states c; ce \\<sigma> l \\<sigma>''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma> \\<in> states c\n  ce \\<sigma> l \\<sigma>''\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> states c' \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> states c \\<and> ce_star xa (l # ls) x\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'\n  \\<sigma> \\<in> states c\n  ce \\<sigma> l \\<sigma>''", "show ?case"], ["proof (prove)\nusing this:\n  \\<sigma>'' \\<in> states c''\n  ce_star \\<sigma>'' ls \\<sigma>'\n  \\<sigma> \\<in> states c\n  ce \\<sigma> l \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> states c \\<and> ce_star x (l # ls) \\<sigma>'", "by (simp add: ce_star_Cons) blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> states c \\<and> ce_star x (l # ls) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "case (2 \\<sigma>')"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> states c \\<and> ce_star x (l # ls) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> states c \\<and> ce_star x (l # ls) \\<sigma>'", "obtain \\<sigma> where \"\\<sigma> \\<in> states c\"\n                  and   \"ce_star \\<sigma> (l#ls) \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> states c \\<and> ce_star x (l # ls) \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in> states c;\n         ce_star \\<sigma> (l # ls) \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "moreover"], ["proof (state)\nthis:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "then"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'", "obtain \\<sigma>'' where \"ce \\<sigma> l \\<sigma>''\"\n                    and   \"ce_star \\<sigma>'' ls \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        \\<lbrakk>ce \\<sigma> l \\<sigma>'';\n         ce_star \\<sigma>'' ls \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ce_star_Cons"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n  ce_star ?\\<sigma>1.0 (?l # ?ls) ?\\<sigma>2.0 =\n  (\\<exists>\\<sigma>.\n      ce ?\\<sigma>1.0 ?l \\<sigma> \\<and> ce_star \\<sigma> ?ls ?\\<sigma>2.0)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>''.\n        \\<lbrakk>ce \\<sigma> l \\<sigma>'';\n         ce_star \\<sigma>'' ls \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ce \\<sigma> l \\<sigma>''\n  ce_star \\<sigma>'' ls \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> states c \\<and> ce_star xa (l # ls) x \\<Longrightarrow>\n       x \\<in> states c'", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n  ce \\<sigma> l \\<sigma>''\n  ce_star \\<sigma>'' ls \\<sigma>'", "show ?case"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n  ce \\<sigma> l \\<sigma>''\n  ce_star \\<sigma>'' ls \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "using Cons(1) \\<open>se_star c'' ls c'\\<close> \\<open>se c l c''\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> states c\n  ce_star \\<sigma> (l # ls) \\<sigma>'\n  ce \\<sigma> l \\<sigma>''\n  ce_star \\<sigma>'' ls \\<sigma>'\n  se_star ?c ls c' \\<Longrightarrow>\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states ?c. ce_star \\<sigma> ls \\<sigma>'}\n  se_star c'' ls c'\n  se c l c''\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> states c'", "by (auto simp add : se_as_ce)"], ["proof (state)\nthis:\n  \\<sigma>' \\<in> states c'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  states c' =\n  {\\<sigma>'.\n   \\<exists>\\<sigma>\\<in>states c. ce_star \\<sigma> (l # ls) \\<sigma>'}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}