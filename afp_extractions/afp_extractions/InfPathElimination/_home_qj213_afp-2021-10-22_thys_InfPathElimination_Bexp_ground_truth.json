{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/Bexp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma vars_of_conj :\n  \"vars (\\<lambda> \\<sigma>. e1 \\<sigma> \\<and> e2 \\<sigma>) \\<subseteq> vars e1 \\<union> vars e2\" \n(is \"vars ?e \\<subseteq> vars e1 \\<union> vars e2\")", "lemma finite_conj :\n  assumes \"finite E\"\n  assumes \"\\<forall> e \\<in> E. finite (vars e)\"\n  shows   \"finite (vars (conjunct E))\"", "lemma vars_of_eq_a :\n  shows  \"vars (\\<lambda> \\<sigma>. e1 \\<sigma> = e2 \\<sigma>) \\<subseteq> Aexp.vars e1 \\<union> Aexp.vars e2\"\n(is \"vars ?e \\<subseteq> Aexp.vars e1 \\<union> Aexp.vars e2\")", "lemma finite_vars_of_a_eq :\n  assumes \"finite (Aexp.vars e1)\"\n  assumes \"finite (Aexp.vars e2)\"\n  shows   \"finite (vars (\\<lambda> \\<sigma>. e1 \\<sigma> = e2 \\<sigma>))\""], "translations": [["", "lemma vars_of_conj :\n  \"vars (\\<lambda> \\<sigma>. e1 \\<sigma> \\<and> e2 \\<sigma>) \\<subseteq> vars e1 \\<union> vars e2\" \n(is \"vars ?e \\<subseteq> vars e1 \\<union> vars e2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> \\<and> e2 \\<sigma>)\n    \\<subseteq> Bexp.vars e1 \\<union> Bexp.vars e2", "unfolding subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> \\<and> e2 \\<sigma>) \\<longrightarrow>\n       t \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "assume \"v \\<in> vars ?e\""], ["proof (state)\nthis:\n  v \\<in> Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> \\<and> e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "then"], ["proof (chain)\npicking this:\n  v \\<in> Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> \\<and> e2 \\<sigma>)", "obtain \\<sigma> val \n  where \"?e (\\<sigma> (v := val)) \\<noteq> ?e \\<sigma>\""], ["proof (prove)\nusing this:\n  v \\<in> Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> \\<and> e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        (e1 (\\<sigma>(v := val)) \\<and> e2 (\\<sigma>(v := val))) \\<noteq>\n        (e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding vars_def"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>\\<sigma> val.\n                 (e1 (\\<sigma>(v := val)) \\<and>\n                  e2 (\\<sigma>(v := val))) \\<noteq>\n                 (e1 \\<sigma> \\<and> e2 \\<sigma>)}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        (e1 (\\<sigma>(v := val)) \\<and> e2 (\\<sigma>(v := val))) \\<noteq>\n        (e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (e1 (\\<sigma>(v := val)) \\<and> e2 (\\<sigma>(v := val))) \\<noteq>\n  (e1 \\<sigma> \\<and> e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "hence \"e1 (\\<sigma> (v := val)) \\<noteq> e1 \\<sigma> \\<or> e2 (\\<sigma> (v := val)) \\<noteq> e2 \\<sigma>\""], ["proof (prove)\nusing this:\n  (e1 (\\<sigma>(v := val)) \\<and> e2 (\\<sigma>(v := val))) \\<noteq>\n  (e1 \\<sigma> \\<and> e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n    e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>", "by auto"], ["proof (state)\nthis:\n  e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n  e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> \\<and> e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "thus \"v \\<in> vars e1 \\<union> vars e2\""], ["proof (prove)\nusing this:\n  e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n  e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<in> Bexp.vars e1 \\<union> Bexp.vars e2", "unfolding vars_def"], ["proof (prove)\nusing this:\n  e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n  e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<in> {v. \\<exists>\\<sigma> val.\n                   e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma>} \\<union>\n            {v. \\<exists>\\<sigma> val.\n                   e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>}", "by blast"], ["proof (state)\nthis:\n  v \\<in> Bexp.vars e1 \\<union> Bexp.vars e2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_conj :\n  assumes \"finite E\"\n  assumes \"\\<forall> e \\<in> E. finite (vars e)\"\n  shows   \"finite (vars (conjunct E))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Bexp.vars (conjunct E))", "using assms"], ["proof (prove)\nusing this:\n  finite E\n  \\<forall>e\\<in>E. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. finite (Bexp.vars (conjunct E))", "proof (induct rule : finite_induct, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>{}. finite (Bexp.vars e) \\<Longrightarrow>\n    finite (Bexp.vars (conjunct {}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>e\\<in>F. finite (Bexp.vars e) \\<Longrightarrow>\n        finite (Bexp.vars (conjunct F));\n        \\<forall>e\\<in>insert x F. finite (Bexp.vars e)\\<rbrakk>\n       \\<Longrightarrow> finite (Bexp.vars (conjunct (insert x F)))", "case 1"], ["proof (state)\nthis:\n  \\<forall>e\\<in>{}. finite (Bexp.vars e)\n\ngoal (2 subgoals):\n 1. \\<forall>e\\<in>{}. finite (Bexp.vars e) \\<Longrightarrow>\n    finite (Bexp.vars (conjunct {}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>e\\<in>F. finite (Bexp.vars e) \\<Longrightarrow>\n        finite (Bexp.vars (conjunct F));\n        \\<forall>e\\<in>insert x F. finite (Bexp.vars e)\\<rbrakk>\n       \\<Longrightarrow> finite (Bexp.vars (conjunct (insert x F)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>{}. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. finite (Bexp.vars (conjunct {}))", "by (simp add : vars_def conjunct_def)"], ["proof (state)\nthis:\n  finite (Bexp.vars (conjunct {}))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>e\\<in>F. finite (Bexp.vars e) \\<Longrightarrow>\n        finite (Bexp.vars (conjunct F));\n        \\<forall>e\\<in>insert x F. finite (Bexp.vars e)\\<rbrakk>\n       \\<Longrightarrow> finite (Bexp.vars (conjunct (insert x F)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>e\\<in>F. finite (Bexp.vars e) \\<Longrightarrow>\n        finite (Bexp.vars (conjunct F));\n        \\<forall>e\\<in>insert x F. finite (Bexp.vars e)\\<rbrakk>\n       \\<Longrightarrow> finite (Bexp.vars (conjunct (insert x F)))", "case (2 e E)"], ["proof (state)\nthis:\n  finite E\n  e \\<notin> E\n  \\<forall>e\\<in>E. finite (Bexp.vars e) \\<Longrightarrow>\n  finite (Bexp.vars (conjunct E))\n  \\<forall>e\\<in>insert e E. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<forall>e\\<in>F. finite (Bexp.vars e) \\<Longrightarrow>\n        finite (Bexp.vars (conjunct F));\n        \\<forall>e\\<in>insert x F. finite (Bexp.vars e)\\<rbrakk>\n       \\<Longrightarrow> finite (Bexp.vars (conjunct (insert x F)))", "thus ?case"], ["proof (prove)\nusing this:\n  finite E\n  e \\<notin> E\n  \\<forall>e\\<in>E. finite (Bexp.vars e) \\<Longrightarrow>\n  finite (Bexp.vars (conjunct E))\n  \\<forall>e\\<in>insert e E. finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. finite (Bexp.vars (conjunct (insert e E)))", "using vars_of_conj[of e \"conjunct E\"]"], ["proof (prove)\nusing this:\n  finite E\n  e \\<notin> E\n  \\<forall>e\\<in>E. finite (Bexp.vars e) \\<Longrightarrow>\n  finite (Bexp.vars (conjunct E))\n  \\<forall>e\\<in>insert e E. finite (Bexp.vars e)\n  Bexp.vars (\\<lambda>\\<sigma>. e \\<sigma> \\<and> conjunct E \\<sigma>)\n  \\<subseteq> Bexp.vars e \\<union> Bexp.vars (conjunct E)\n\ngoal (1 subgoal):\n 1. finite (Bexp.vars (conjunct (insert e E)))", "by (rule_tac rev_finite_subset, auto simp add : conjunct_def)"], ["proof (state)\nthis:\n  finite (Bexp.vars (conjunct (insert e E)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Variables of an equality\\<close>"], ["", "text \\<open>We proceed analogously for the equality of two arithmetic expressions.\\<close>"], ["", "lemma vars_of_eq_a :\n  shows  \"vars (\\<lambda> \\<sigma>. e1 \\<sigma> = e2 \\<sigma>) \\<subseteq> Aexp.vars e1 \\<union> Aexp.vars e2\"\n(is \"vars ?e \\<subseteq> Aexp.vars e1 \\<union> Aexp.vars e2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>)\n    \\<subseteq> Aexp.vars e1 \\<union> Aexp.vars e2", "unfolding subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> = e2 \\<sigma>) \\<longrightarrow>\n       t \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "assume \"v \\<in> vars ?e\""], ["proof (state)\nthis:\n  v \\<in> Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "then"], ["proof (chain)\npicking this:\n  v \\<in> Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>)", "obtain \\<sigma> val where \"?e (\\<sigma> (v := val)) \\<noteq> ?e \\<sigma>\""], ["proof (prove)\nusing this:\n  v \\<in> Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        (e1 (\\<sigma>(v := val)) = e2 (\\<sigma>(v := val))) \\<noteq>\n        (e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding vars_def"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>\\<sigma> val.\n                 (e1 (\\<sigma>(v := val)) =\n                  e2 (\\<sigma>(v := val))) \\<noteq>\n                 (e1 \\<sigma> = e2 \\<sigma>)}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        (e1 (\\<sigma>(v := val)) = e2 (\\<sigma>(v := val))) \\<noteq>\n        (e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (e1 (\\<sigma>(v := val)) = e2 (\\<sigma>(v := val))) \\<noteq>\n  (e1 \\<sigma> = e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "hence \"e1 (\\<sigma> (v := val)) \\<noteq> e1 \\<sigma> \\<or> e2 (\\<sigma> (v := val)) \\<noteq> e2 \\<sigma>\""], ["proof (prove)\nusing this:\n  (e1 (\\<sigma>(v := val)) = e2 (\\<sigma>(v := val))) \\<noteq>\n  (e1 \\<sigma> = e2 \\<sigma>)\n\ngoal (1 subgoal):\n 1. e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n    e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>", "by auto"], ["proof (state)\nthis:\n  e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n  e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Bexp.vars\n                (\\<lambda>\\<sigma>.\n                    e1 \\<sigma> = e2 \\<sigma>) \\<Longrightarrow>\n       t \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "thus \"v \\<in> Aexp.vars e1 \\<union> Aexp.vars e2\""], ["proof (prove)\nusing this:\n  e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n  e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<in> Aexp.vars e1 \\<union> Aexp.vars e2", "unfolding Aexp.vars_def"], ["proof (prove)\nusing this:\n  e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma> \\<or>\n  e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<in> {v. \\<exists>\\<sigma> val.\n                   e1 (\\<sigma>(v := val)) \\<noteq> e1 \\<sigma>} \\<union>\n            {v. \\<exists>\\<sigma> val.\n                   e2 (\\<sigma>(v := val)) \\<noteq> e2 \\<sigma>}", "by blast"], ["proof (state)\nthis:\n  v \\<in> Aexp.vars e1 \\<union> Aexp.vars e2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_vars_of_a_eq :\n  assumes \"finite (Aexp.vars e1)\"\n  assumes \"finite (Aexp.vars e2)\"\n  shows   \"finite (vars (\\<lambda> \\<sigma>. e1 \\<sigma> = e2 \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>))", "using assms vars_of_eq_a[of e1 e2]"], ["proof (prove)\nusing this:\n  finite (Aexp.vars e1)\n  finite (Aexp.vars e2)\n  Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>)\n  \\<subseteq> Aexp.vars e1 \\<union> Aexp.vars e2\n\ngoal (1 subgoal):\n 1. finite (Bexp.vars (\\<lambda>\\<sigma>. e1 \\<sigma> = e2 \\<sigma>))", "by (rule_tac rev_finite_subset, auto)"], ["", "end"]]}