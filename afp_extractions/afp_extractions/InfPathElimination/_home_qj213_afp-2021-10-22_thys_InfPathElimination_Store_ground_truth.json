{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/Store.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma \n  \"inj (\\<lambda> v. symvar v s)\"", "lemma\n  \"\\<exists> \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m. consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\"", "lemma consistent_eq1 :\n  \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s = (\\<forall> sv \\<in> symvars s. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m sv = \\<sigma> (fst sv))\"", "lemma consistent_eq2 :\n  \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store = (\\<sigma> = (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store)))\"", "lemma consistentI1 : \n  \"consistent \\<sigma> (\\<lambda> sv. \\<sigma> (fst sv)) store\"", "lemma consistentI2 :\n  \"consistent (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store)) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store\"", "lemma adapt_aexp_is_subst :\n  assumes \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\" \n  shows   \"(adapt_aexp e s) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\"", "lemma var_imp_symvar_var :\n  assumes \"v \\<in> Aexp.vars e\"\n  shows   \"symvar v s \\<in> Aexp.vars (adapt_aexp e s)\" (is \"?sv \\<in> Aexp.vars ?e'\")", "lemma symvars_of_adapt_aexp :\n  \"Aexp.vars (adapt_aexp e s) \\<subseteq> symvars s\" (is \"Aexp.vars ?e' \\<subseteq> symvars s\")", "lemma symvar_var_imp_var :\n  assumes \"sv \\<in> Aexp.vars (adapt_aexp e s)\" (is \"sv \\<in> Aexp.vars ?e'\")\n  shows   \"fst sv \\<in> Aexp.vars e\"", "lemma adapt_aexp_vars :\n  \"Aexp.vars (adapt_aexp e s) = (\\<lambda> v. symvar v s) ` Aexp.vars e\"", "lemma finite_vars_imp_finite_adapt_a :\n  assumes \"finite (Aexp.vars e)\"\n  shows   \"finite (Aexp.vars (adapt_aexp e s))\"", "lemma adapt_bexp_is_subst :\n  assumes \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\" \n  shows   \"(adapt_bexp e s) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\"", "lemma var_imp_symvar_var2 :\n  assumes \"v \\<in> Bexp.vars e\"\n  shows   \"symvar v s \\<in> Bexp.vars (adapt_bexp e s)\" (is \"?sv \\<in> Bexp.vars ?e'\")", "lemma symvars_of_adapt_bexp :\n  \"Bexp.vars (adapt_bexp e s) \\<subseteq> symvars s\" (is \"Bexp.vars ?e' \\<subseteq> ?SV\")", "lemma symvar_var_imp_var2 :\n  assumes \"sv \\<in> Bexp.vars (adapt_bexp e s)\" (is \"sv \\<in> Bexp.vars ?e'\")\n  shows   \"fst sv \\<in> Bexp.vars e\"", "lemma adapt_bexp_vars :\n  \"Bexp.vars (adapt_bexp e s) = (\\<lambda> v. symvar v s) ` Bexp.vars e\"\n  (is \"Bexp.vars ?e' = ?R\")", "lemma finite_vars_imp_finite_adapt_b :\n  assumes \"finite (Bexp.vars e)\"\n  shows   \"finite (Bexp.vars (adapt_bexp e s))\""], "translations": [["", "lemma \n  \"inj (\\<lambda> v. symvar v s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>v. symvar v s)", "by (auto simp add : inj_on_def symvar_def)"], ["", "text \\<open>The sets of symbolic variables of a store is the image set of the function @{term \"symvar\"}.\\<close>"], ["", "definition symvars :: \n  \"'a store \\<Rightarrow> 'a symvar set\" \nwhere\n \"symvars s = (\\<lambda> v. symvar v s) ` (UNIV::'a set)\""], ["", "subsubsection \\<open>Fresh symbolic variables\\<close>"], ["", "text \\<open>A symbolic variable is said to be fresh for a store if it is not a member of its set of \nsymbolic variables.\\<close>"], ["", "definition fresh_symvar :: \n  \"'v symvar \\<Rightarrow> 'v store \\<Rightarrow> bool\" \nwhere\n \"fresh_symvar sv s = (sv \\<notin> symvars s)\""], ["", "subsection \\<open>Consistency\\<close>"], ["", "text \\<open>We say that a program state @{term \"\\<sigma>\"} and a symbolic state @{term \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\"} are \n\\emph{consistent} with respect to a store @{term \"s\"} if, for each variable @{term \"v\"}, the \nvalue associated by @{term \"\\<sigma>\"} to @{term \"v\"} is equal to the value associated by @{term \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\"} \nto the symbolic variable associated to @{term \"v\"} by @{term \"s\"}.\\<close>"], ["", "definition consistent ::\n  \"('v,'d) state \\<Rightarrow> ('v symvar, 'd) state \\<Rightarrow> 'v store \\<Rightarrow> bool\"\nwhere\n  \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s \\<equiv> (\\<forall> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s) = \\<sigma> v)\""], ["", "text \\<open>There always exists a couple of consistent states for a given store.\\<close>"], ["", "lemma\n  \"\\<exists> \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m. consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m.\n       consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s", "by (auto simp add : consistent_def)"], ["", "text \\<open>Moreover, given a store and a program (resp. symbolic) state, one can always build a symbolic \n(resp. program) state such that the two states are coherent wrt.\\ the store. The four following \nlemmas show how to build the second state given the first one.\\<close>"], ["", "lemma consistent_eq1 :\n  \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s = (\\<forall> sv \\<in> symvars s. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m sv = \\<sigma> (fst sv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s =\n    (\\<forall>sv\\<in>symvars s.\n        \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m sv = \\<sigma> (fst sv))", "by (auto simp add : consistent_def symvars_def symvar_def)"], ["", "lemma consistent_eq2 :\n  \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store = (\\<sigma> = (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store =\n    (\\<sigma> =\n     (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store)))", "by (auto simp add : consistent_def)"], ["", "lemma consistentI1 : \n  \"consistent \\<sigma> (\\<lambda> sv. \\<sigma> (fst sv)) store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<sigma> (\\<lambda>sv. \\<sigma> (fst sv)) store", "using consistent_eq1"], ["proof (prove)\nusing this:\n  consistent ?\\<sigma> ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m ?s =\n  (\\<forall>sv\\<in>symvars ?s.\n      ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m sv = ?\\<sigma> (fst sv))\n\ngoal (1 subgoal):\n 1. consistent \\<sigma> (\\<lambda>sv. \\<sigma> (fst sv)) store", "by fast"], ["", "lemma consistentI2 :\n  \"consistent (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store)) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent\n     (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store))\n     \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store", "using consistent_eq2"], ["proof (prove)\nusing this:\n  consistent ?\\<sigma> ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m ?store =\n  (?\\<sigma> =\n   (\\<lambda>v. ?\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v ?store)))\n\ngoal (1 subgoal):\n 1. consistent\n     (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v store))\n     \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m store", "by fast"], ["", "subsection \\<open>Adaptation of an arithmetic expression to a store\\<close>"], ["", "text \\<open>Suppose that @{term \"e\"} is a term representing an arithmetic expression over program \nvariables and let @{term \"s\"} be a store. We call \\emph{adaptation of @{term \"e\"} to @{term \"s\"}} \nthe term obtained by substituting occurrences of program variables in @{term \"e\"} by their \nsymbolic counterpart given by @{term \"s\"}. Since we model arithmetic expressions by total \nfunctions and not terms, we define the adaptation of such expressions as follows.\\<close>"], ["", "definition adapt_aexp :: \n  \"('v,'d) aexp \\<Rightarrow> 'v store \\<Rightarrow> ('v symvar,'d) aexp\" \nwhere\n  \"adapt_aexp e s = (\\<lambda> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m. e (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)))\""], ["", "text \\<open>Given an arithmetic expression @{term \"e\"}, a program state @{term \"\\<sigma>\"} and a symbolic \nstate @{term \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\"} coherent with a store @{term \"s\"}, the value associated to @{term \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\"} by \nthe adaptation of @{term \"e\"} to @{term \"s\"} is the same than the value associated by @{term \"e\"} to \n@{term \"\\<sigma>\"}. This confirms the fact that @{term \"adapt_aexp\"} models the act of substituting \noccurrences of program variables by their symbolic counterparts in a term over program variables.\\<close>"], ["", "lemma adapt_aexp_is_subst :\n  assumes \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\" \n  shows   \"(adapt_aexp e s) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\n\ngoal (1 subgoal):\n 1. adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "by (simp add : consistent_eq2 adapt_aexp_def)"], ["", "text \\<open>As said earlier, we will later need to prove that symbolic execution preserves finiteness \nof the set of symbolic variables in use, which requires that the adaptation of an arithmetic \nexpression to a store preserves finiteness of the set of variables of expressions. We proceed as \nfollows.\\<close>"], ["", "text \\<open>First, we show that if @{term \"v\"} is a variable of an expression @{term \"e\"}, \nthen the symbolic variable associated to @{term \"v\"} by a store is a variable of the adaptation of \n@{term \"e\"} to this store.\\<close>"], ["", "lemma var_imp_symvar_var :\n  assumes \"v \\<in> Aexp.vars e\"\n  shows   \"symvar v s \\<in> Aexp.vars (adapt_aexp e s)\" (is \"?sv \\<in> Aexp.vars ?e'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. symvar v s \\<in> Aexp.vars (adapt_aexp e s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. symvar v s \\<in> Aexp.vars (adapt_aexp e s)", "obtain \\<sigma> val where \"e (\\<sigma> (v := val)) \\<noteq> e \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> Aexp.vars e\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Aexp.vars_def"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>\\<sigma> val.\n                 e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Aexp.vars (adapt_aexp e s)", "moreover"], ["proof (state)\nthis:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Aexp.vars (adapt_aexp e s)", "have \"(\\<lambda>va. ((\\<lambda>sv. \\<sigma> (fst sv))(?sv := val)) (symvar va s)) = (\\<sigma>(v := val))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>va.\n        ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val))\n         (symvar va s)) =\n    \\<sigma>(v := val)", "by (auto simp add : symvar_def)"], ["proof (state)\nthis:\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Aexp.vars (adapt_aexp e s)", "ultimately"], ["proof (chain)\npicking this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)", "show ?thesis"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Aexp.vars (adapt_aexp e s)", "unfolding Aexp.vars_def mem_Collect_eq"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma> val.\n       adapt_aexp e s (\\<sigma>(symvar v s := val)) \\<noteq>\n       adapt_aexp e s \\<sigma>", "using consistentI1[of \\<sigma> s] \n        consistentI2[of \"(\\<lambda>sv. \\<sigma> (fst sv))(?sv:= val)\" s]"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n  consistent \\<sigma> (\\<lambda>sv. \\<sigma> (fst sv)) s\n  consistent\n   (\\<lambda>va.\n       ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s))\n   ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma> val.\n       adapt_aexp e s (\\<sigma>(symvar v s := val)) \\<noteq>\n       adapt_aexp e s \\<sigma>", "by (rule_tac ?x=\"\\<lambda>sv. \\<sigma> (fst sv)\" in exI, rule_tac ?x=\"val\" in exI) \n     (simp add : adapt_aexp_is_subst)"], ["proof (state)\nthis:\n  symvar v s \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>On the other hand, if @{term \"sv\"} is a symbolic variable in the adaptation of an expression \nto a store, then the program variable it represents is a variable of this expression. This requires \nto prove that the set of variables of the adaptation of an expression to a store is a subset of the \nsymbolic variables of this store.\\<close>"], ["", "lemma symvars_of_adapt_aexp :\n  \"Aexp.vars (adapt_aexp e s) \\<subseteq> symvars s\" (is \"Aexp.vars ?e' \\<subseteq> symvars s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp.vars (adapt_aexp e s) \\<subseteq> symvars s", "unfolding subset_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<longrightarrow>\n       t \\<in> symvars s", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "fix sv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "assume \"sv \\<in> Aexp.vars ?e'\""], ["proof (state)\nthis:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "then"], ["proof (chain)\npicking this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)", "obtain \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val \n  where \"?e' (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) \\<noteq> ?e' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_aexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add : Aexp.vars_def, blast)"], ["proof (state)\nthis:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "hence \"(\\<lambda> x. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar x s)) \\<noteq> (\\<lambda> x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\""], ["proof (prove)\nusing this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n    (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))", "proof (intro notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>adapt_aexp e s\n              (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n             adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m;\n     (\\<lambda>x.\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) =\n     (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"(\\<lambda>x. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) = (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\""], ["proof (state)\nthis:\n  (\\<lambda>x. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) =\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>adapt_aexp e s\n              (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n             adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m;\n     (\\<lambda>x.\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) =\n     (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"?e' (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) = ?e' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) =\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\n\ngoal (1 subgoal):\n 1. adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) =\n    adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m", "by (simp add : adapt_aexp_def)"], ["proof (state)\nthis:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) =\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>adapt_aexp e s\n              (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n             adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m;\n     (\\<lambda>x.\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) =\n     (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) =\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. False", "using \\<open>?e' (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) \\<noteq> ?e' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\\<close>"], ["proof (prove)\nusing this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) =\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. False", "by (elim notE)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))", "obtain v \n  where \"(\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar v s) \\<noteq> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n        \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "hence \"sv = symvar v s\""], ["proof (prove)\nusing this:\n  (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\n\ngoal (1 subgoal):\n 1. sv = symvar v s", "by (case_tac \"sv = symvar v s\", simp_all)"], ["proof (state)\nthis:\n  sv = symvar v s\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       t \\<in> symvars s", "thus \"sv \\<in> symvars s\""], ["proof (prove)\nusing this:\n  sv = symvar v s\n\ngoal (1 subgoal):\n 1. sv \\<in> symvars s", "by (simp add : symvars_def)"], ["proof (state)\nthis:\n  sv \\<in> symvars s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symvar_var_imp_var :\n  assumes \"sv \\<in> Aexp.vars (adapt_aexp e s)\" (is \"sv \\<in> Aexp.vars ?e'\")\n  shows   \"fst sv \\<in> Aexp.vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "obtain v where \"sv = (v, s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. sv = (v, s v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) symvars_of_adapt_aexp"], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n  Aexp.vars (adapt_aexp ?e ?s) \\<subseteq> symvars ?s\n\ngoal (1 subgoal):\n 1. (\\<And>v. sv = (v, s v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding symvars_def symvar_def"], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n  Aexp.vars (adapt_aexp ?e ?s) \\<subseteq> range (\\<lambda>v. (v, ?s v))\n\ngoal (1 subgoal):\n 1. (\\<And>v. sv = (v, s v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sv = (v, s v)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "obtain \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val where \"?e' (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) \\<noteq> ?e' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_aexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_aexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Aexp.vars_def"], ["proof (prove)\nusing this:\n  sv \\<in> {v. \\<exists>\\<sigma> val.\n                  adapt_aexp e s (\\<sigma>(v := val)) \\<noteq>\n                  adapt_aexp e s \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_aexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "moreover"], ["proof (state)\nthis:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "have \"(\\<lambda> v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar v s)) = (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)) (v := val)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n    (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)", "using \\<open>sv = (v, s v)\\<close>"], ["proof (prove)\nusing this:\n  sv = (v, s v)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n    (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)", "by (auto simp add : symvar_def)"], ["proof (state)\nthis:\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "ultimately"], ["proof (chain)\npicking this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)", "show ?thesis"], ["proof (prove)\nusing this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "using \\<open>sv = (v, s v)\\<close> \n        consistentI2[of \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s] \n        consistentI2[of \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)\" s]"], ["proof (prove)\nusing this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n  sv = (v, s v)\n  consistent (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))\n   \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\n  consistent\n   (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s))\n   (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) s\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Aexp.vars e", "unfolding Aexp.vars_def"], ["proof (prove)\nusing this:\n  adapt_aexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_aexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n  sv = (v, s v)\n  consistent (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))\n   \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\n  consistent\n   (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s))\n   (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) s\n\ngoal (1 subgoal):\n 1. fst sv\n    \\<in> {v. \\<exists>\\<sigma> val.\n                 e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>}", "by (simp add : adapt_aexp_is_subst) blast"], ["proof (state)\nthis:\n  fst sv \\<in> Aexp.vars e\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Thus, we have that the set of variables of the adaptation of an expression to a store is \nthe set of symbolic variables associated by this store to the variables of this \nexpression.\\<close>"], ["", "lemma adapt_aexp_vars :\n  \"Aexp.vars (adapt_aexp e s) = (\\<lambda> v. symvar v s) ` Aexp.vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Aexp.vars (adapt_aexp e s) = (\\<lambda>v. symvar v s) ` Aexp.vars e", "unfolding set_eq_iff image_def mem_Collect_eq Bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> Aexp.vars (adapt_aexp e s)) =\n       (\\<exists>xa. xa \\<in> Aexp.vars e \\<and> x = symvar xa s)", "proof (intro allI iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Aexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "case (1 sv)"], ["proof (state)\nthis:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Aexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "moreover"], ["proof (state)\nthis:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Aexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "have \"sv = symvar (fst sv) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sv = symvar (fst sv) s", "using 1 symvars_of_adapt_aexp"], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n  Aexp.vars (adapt_aexp ?e ?s) \\<subseteq> symvars ?s\n\ngoal (1 subgoal):\n 1. sv = symvar (fst sv) s", "by (force simp add:  symvar_def symvars_def)"], ["proof (state)\nthis:\n  sv = symvar (fst sv) s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Aexp.vars (adapt_aexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Aexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "ultimately"], ["proof (chain)\npicking this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n  sv = symvar (fst sv) s", "show ?case"], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n  sv = symvar (fst sv) s\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Aexp.vars e \\<and> sv = symvar x s", "using symvar_var_imp_var"], ["proof (prove)\nusing this:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n  sv = symvar (fst sv) s\n  ?sv \\<in> Aexp.vars (adapt_aexp ?e ?s) \\<Longrightarrow>\n  fst ?sv \\<in> Aexp.vars ?e\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Aexp.vars e \\<and> sv = symvar x s", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> Aexp.vars e \\<and> sv = symvar x s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "case (2 sv)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> Aexp.vars e \\<and> sv = symvar x s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Aexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Aexp.vars (adapt_aexp e s)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Aexp.vars e \\<and> sv = symvar x s\n\ngoal (1 subgoal):\n 1. sv \\<in> Aexp.vars (adapt_aexp e s)", "using var_imp_symvar_var"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Aexp.vars e \\<and> sv = symvar x s\n  ?v \\<in> Aexp.vars ?e \\<Longrightarrow>\n  symvar ?v ?s \\<in> Aexp.vars (adapt_aexp ?e ?s)\n\ngoal (1 subgoal):\n 1. sv \\<in> Aexp.vars (adapt_aexp e s)", "by fast"], ["proof (state)\nthis:\n  sv \\<in> Aexp.vars (adapt_aexp e s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The fact that the adaptation of an arithmetic expression to a store preserves finiteness \nof the set of variables trivially follows the previous lemma.\\<close>"], ["", "lemma finite_vars_imp_finite_adapt_a :\n  assumes \"finite (Aexp.vars e)\"\n  shows   \"finite (Aexp.vars (adapt_aexp e s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Aexp.vars (adapt_aexp e s))", "unfolding adapt_aexp_vars"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. symvar v s) ` Aexp.vars e)", "using assms"], ["proof (prove)\nusing this:\n  finite (Aexp.vars e)\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. symvar v s) ` Aexp.vars e)", "by auto"], ["", "subsection \\<open>Adaptation of a boolean expression to a store\\<close>"], ["", "text \\<open>We proceed analogously for the adaptation of boolean expressions to a store.\\<close>"], ["", "definition adapt_bexp :: \n  \"('v,'d) bexp \\<Rightarrow> 'v store \\<Rightarrow> ('v symvar,'d) bexp\" \nwhere\n  \"adapt_bexp e s = (\\<lambda> \\<sigma>. e (\\<lambda> x. \\<sigma> (symvar x s)))\""], ["", "lemma adapt_bexp_is_subst :\n  assumes \"consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\" \n  shows   \"(adapt_bexp e s) \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  consistent \\<sigma> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\n\ngoal (1 subgoal):\n 1. adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m = e \\<sigma>", "by (simp add : consistent_eq2 adapt_bexp_def)"], ["", "lemma var_imp_symvar_var2 :\n  assumes \"v \\<in> Bexp.vars e\"\n  shows   \"symvar v s \\<in> Bexp.vars (adapt_bexp e s)\" (is \"?sv \\<in> Bexp.vars ?e'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. symvar v s \\<in> Bexp.vars (adapt_bexp e s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. symvar v s \\<in> Bexp.vars (adapt_bexp e s)", "obtain \\<sigma> val where A : \"e (\\<sigma> (v := val)) \\<noteq> e \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> Bexp.vars e\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Bexp.vars_def"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>\\<sigma> val.\n                 e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Bexp.vars (adapt_bexp e s)", "moreover"], ["proof (state)\nthis:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Bexp.vars (adapt_bexp e s)", "have \"(\\<lambda>va. ((\\<lambda>sv. \\<sigma> (fst sv))(?sv := val)) (symvar va s)) = (\\<sigma>(v := val))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>va.\n        ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val))\n         (symvar va s)) =\n    \\<sigma>(v := val)", "by (auto simp add : symvar_def)"], ["proof (state)\nthis:\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Bexp.vars (adapt_bexp e s)", "ultimately"], ["proof (chain)\npicking this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)", "show ?thesis"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n\ngoal (1 subgoal):\n 1. symvar v s \\<in> Bexp.vars (adapt_bexp e s)", "unfolding Bexp.vars_def mem_Collect_eq"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma> val.\n       adapt_bexp e s (\\<sigma>(symvar v s := val)) \\<noteq>\n       adapt_bexp e s \\<sigma>", "using consistentI1[of \\<sigma> s] \n        consistentI2[of \"(\\<lambda>sv. \\<sigma> (fst sv))(?sv:= val)\" s]"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  (\\<lambda>va.\n      ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s)) =\n  \\<sigma>(v := val)\n  consistent \\<sigma> (\\<lambda>sv. \\<sigma> (fst sv)) s\n  consistent\n   (\\<lambda>va.\n       ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) (symvar va s))\n   ((\\<lambda>sv. \\<sigma> (fst sv))(symvar v s := val)) s\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma> val.\n       adapt_bexp e s (\\<sigma>(symvar v s := val)) \\<noteq>\n       adapt_bexp e s \\<sigma>", "by (rule_tac ?x=\"\\<lambda>sv. \\<sigma> (fst sv)\" in exI, rule_tac ?x=\"val\" in exI) \n     (simp add : adapt_bexp_is_subst)"], ["proof (state)\nthis:\n  symvar v s \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symvars_of_adapt_bexp :\n  \"Bexp.vars (adapt_bexp e s) \\<subseteq> symvars s\" (is \"Bexp.vars ?e' \\<subseteq> ?SV\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bexp.vars (adapt_bexp e s) \\<subseteq> symvars s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "fix sv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "assume \"sv \\<in> Bexp.vars ?e'\""], ["proof (state)\nthis:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "then"], ["proof (chain)\npicking this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)", "obtain \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val \n  where \"?e' (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) \\<noteq> ?e' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\nusing this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_bexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add : Bexp.vars_def, blast)"], ["proof (state)\nthis:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "hence \"(\\<lambda> x. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar x s)) \\<noteq> (\\<lambda> x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\""], ["proof (prove)\nusing this:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n    (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))", "by (auto simp add : adapt_bexp_def)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "hence \"\\<exists> v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar v s) \\<noteq> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar x s)) \\<noteq>\n  (\\<lambda>x. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar x s))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n       \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)", "by force"], ["proof (state)\nthis:\n  \\<exists>v.\n     (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n     \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n     \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)", "obtain v \n  where \"(\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar v s) \\<noteq> \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n     \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n        \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "hence \"sv = symvar v s\""], ["proof (prove)\nusing this:\n  (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s) \\<noteq>\n  \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)\n\ngoal (1 subgoal):\n 1. sv = symvar v s", "by (case_tac \"sv = symvar v s\", simp_all)"], ["proof (state)\nthis:\n  sv = symvar v s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       x \\<in> symvars s", "thus \"sv \\<in> symvars s\""], ["proof (prove)\nusing this:\n  sv = symvar v s\n\ngoal (1 subgoal):\n 1. sv \\<in> symvars s", "by (simp add : symvars_def)"], ["proof (state)\nthis:\n  sv \\<in> symvars s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symvar_var_imp_var2 :\n  assumes \"sv \\<in> Bexp.vars (adapt_bexp e s)\" (is \"sv \\<in> Bexp.vars ?e'\")\n  shows   \"fst sv \\<in> Bexp.vars e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "obtain v where \"sv = (v, s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. sv = (v, s v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms symvars_of_adapt_bexp"], ["proof (prove)\nusing this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n  Bexp.vars (adapt_bexp ?e ?s) \\<subseteq> symvars ?s\n\ngoal (1 subgoal):\n 1. (\\<And>v. sv = (v, s v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding symvars_def symvar_def"], ["proof (prove)\nusing this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n  Bexp.vars (adapt_bexp ?e ?s) \\<subseteq> range (\\<lambda>v. (v, ?s v))\n\ngoal (1 subgoal):\n 1. (\\<And>v. sv = (v, s v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sv = (v, s v)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "obtain \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val where \"?e' (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) \\<noteq> ?e' \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_bexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_bexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding vars_def"], ["proof (prove)\nusing this:\n  sv \\<in> {v. \\<exists>\\<sigma> val.\n                  adapt_bexp e s (\\<sigma>(v := val)) \\<noteq>\n                  adapt_bexp e s \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m val.\n        adapt_bexp e s\n         (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n        adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "moreover"], ["proof (state)\nthis:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "have \"(\\<lambda> v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)) (symvar v s)) = (\\<lambda> v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s)) (v := val)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n    (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)", "using \\<open>sv = (v, s v)\\<close>"], ["proof (prove)\nusing this:\n  sv = (v, s v)\n\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n    (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)", "by (auto simp add : symvar_def)"], ["proof (state)\nthis:\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "ultimately"], ["proof (chain)\npicking this:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)", "show ?thesis"], ["proof (prove)\nusing this:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "using \\<open>sv = (v, s v)\\<close> \n        consistentI2[of \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s] \n        consistentI2[of \"\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (sv := val)\" s]"], ["proof (prove)\nusing this:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n  sv = (v, s v)\n  consistent (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))\n   \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\n  consistent\n   (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s))\n   (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) s\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "unfolding vars_def"], ["proof (prove)\nusing this:\n  adapt_bexp e s (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) \\<noteq>\n  adapt_bexp e s \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m\n  (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s)) =\n  (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))(v := val)\n  sv = (v, s v)\n  consistent (\\<lambda>v. \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m (symvar v s))\n   \\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m s\n  consistent\n   (\\<lambda>v. (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) (symvar v s))\n   (\\<sigma>\\<^sub>s\\<^sub>y\\<^sub>m(sv := val)) s\n\ngoal (1 subgoal):\n 1. fst sv\n    \\<in> {v. \\<exists>\\<sigma> val.\n                 e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>}", "by (simp add : adapt_bexp_is_subst) blast"], ["proof (state)\nthis:\n  fst sv \\<in> Bexp.vars e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adapt_bexp_vars :\n  \"Bexp.vars (adapt_bexp e s) = (\\<lambda> v. symvar v s) ` Bexp.vars e\"\n  (is \"Bexp.vars ?e' = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bexp.vars (adapt_bexp e s) = (\\<lambda>v. symvar v s) ` Bexp.vars e", "unfolding set_eq_iff image_def mem_Collect_eq Bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> Bexp.vars (adapt_bexp e s)) =\n       (\\<exists>xa. xa \\<in> Bexp.vars e \\<and> x = symvar xa s)", "proof (intro allI iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Bexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "case (1 sv)"], ["proof (state)\nthis:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Bexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "hence \"fst sv \\<in> vars e\""], ["proof (prove)\nusing this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal (1 subgoal):\n 1. fst sv \\<in> Bexp.vars e", "by (rule symvar_var_imp_var2)"], ["proof (state)\nthis:\n  fst sv \\<in> Bexp.vars e\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Bexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "moreover"], ["proof (state)\nthis:\n  fst sv \\<in> Bexp.vars e\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Bexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "have \"sv = symvar (fst sv) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sv = symvar (fst sv) s", "using 1 symvars_of_adapt_bexp"], ["proof (prove)\nusing this:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n  Bexp.vars (adapt_bexp ?e ?s) \\<subseteq> symvars ?s\n\ngoal (1 subgoal):\n 1. sv = symvar (fst sv) s", "by (force simp add:  symvar_def symvars_def)"], ["proof (state)\nthis:\n  sv = symvar (fst sv) s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Bexp.vars (adapt_bexp e s) \\<Longrightarrow>\n       \\<exists>xa. xa \\<in> Bexp.vars e \\<and> x = symvar xa s\n 2. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "ultimately"], ["proof (chain)\npicking this:\n  fst sv \\<in> Bexp.vars e\n  sv = symvar (fst sv) s", "show ?case"], ["proof (prove)\nusing this:\n  fst sv \\<in> Bexp.vars e\n  sv = symvar (fst sv) s\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Bexp.vars e \\<and> sv = symvar x s", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> Bexp.vars e \\<and> sv = symvar x s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "case (2 sv)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> Bexp.vars e \\<and> sv = symvar x s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> Bexp.vars e \\<and> sv = symvar x s", "obtain v where \"v \\<in> vars e\" \"sv = symvar v s\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Bexp.vars e \\<and> sv = symvar x s\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> Bexp.vars e; sv = symvar v s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> Bexp.vars e\n  sv = symvar v s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          xa \\<in> Bexp.vars e \\<and> x = symvar xa s \\<Longrightarrow>\n       x \\<in> Bexp.vars (adapt_bexp e s)", "thus ?case"], ["proof (prove)\nusing this:\n  v \\<in> Bexp.vars e\n  sv = symvar v s\n\ngoal (1 subgoal):\n 1. sv \\<in> Bexp.vars (adapt_bexp e s)", "using var_imp_symvar_var2"], ["proof (prove)\nusing this:\n  v \\<in> Bexp.vars e\n  sv = symvar v s\n  ?v \\<in> Bexp.vars ?e \\<Longrightarrow>\n  symvar ?v ?s \\<in> Bexp.vars (adapt_bexp ?e ?s)\n\ngoal (1 subgoal):\n 1. sv \\<in> Bexp.vars (adapt_bexp e s)", "by simp"], ["proof (state)\nthis:\n  sv \\<in> Bexp.vars (adapt_bexp e s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_vars_imp_finite_adapt_b :\n  assumes \"finite (Bexp.vars e)\"\n  shows   \"finite (Bexp.vars (adapt_bexp e s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Bexp.vars (adapt_bexp e s))", "unfolding adapt_bexp_vars"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. symvar v s) ` Bexp.vars e)", "using assms"], ["proof (prove)\nusing this:\n  finite (Bexp.vars e)\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. symvar v s) ` Bexp.vars e)", "by auto"], ["", "end"]]}