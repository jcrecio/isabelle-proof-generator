{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/SubRel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma subsumees_conv :\n  \"subsumees subs = {v. \\<exists> v'. (v,v') \\<in> subs}\"", "lemma subsumers_conv :\n  \"subsumers subs = {v'. \\<exists> v. (v,v') \\<in> subs}\"", "lemmas wf_sub_rel = sub_imp_same_verts subsumed_by_one inter_empty", "lemma (in wf_sub_rel) subsumed_by_two_imp : \n    assumes \"(v,v1) \\<in> subs\"\n    assumes \"(v,v2) \\<in> subs\" \n    shows   \"v1 = v2\"", "lemma in_trancl_imp :\n    assumes \"(v,v') \\<in> subs\\<^sup>+\"\n    shows   \"(v,v') \\<in> subs\"", "lemma trancl_eq :\n    \"subs\\<^sup>+ = subs\"", "lemma\n  \"wf_sub_rel {}\"", "lemmas sub_rel_of = related_are_verts", "lemma trancl_sub_rel_of :\n     \"sub_rel_of g (subs\\<^sup>+)\"", "lemma\n  \"sub_rel_of g {}\"", "lemmas wf_sub_rel_of = sub_rel_of wf_sub_rel", "lemma\n  \"wf_sub_rel_of g {}\"", "lemma\n  assumes \"Graph.ces v1 es v2\"\n  shows   \"ces v1 es v2 subs\"", "lemma\n  assumes \"ces v1 es v2 {}\"\n  shows   \"Graph.ces v1 es v2\"", "lemma acas_imp_dcas :\n  assumes \"(v1,v2) \\<in> subs\"\n  assumes \"ces v2 es v subs\"\n  shows   \"ces v1 es v subs\"", "lemma ces_Un :\n  assumes \"ces v1 es v2  subs1\"\n  shows   \"ces v1 es v2 (subs1 \\<union> subs2)\"", "lemma cas_subset :\n  assumes \"ces v1 es v2  subs1\"\n  assumes \"subs1 \\<subseteq> subs2\"\n  shows   \"ces v1 es v2 subs2\"", "lemma ces_append_one :\n  \"ces v1 (es @ [e]) v2 subs = (ces v1 es (src e) subs \\<and> ces (src e) [e] v2 subs)\"", "lemma ces_append :\n  \"ces v1 (es1 @ es2) v2 subs = (\\<exists> v. ces v1 es1 v subs \\<and> ces v es2 v2 subs)\"", "lemma (in sub_rel_of) ces_imp_ends_vertices :\n  assumes \"ces v1 es v2 subs\"\n  assumes \"set es \\<subseteq> edges g\"\n  assumes \"v1 \\<in> Graph.vertices g\"\n  shows   \"v2 \\<in> Graph.vertices g\"", "lemma Nil_sp :\n  \"subpath g v1 [] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                             \\<and> v1 \\<in> Graph.vertices g \n                             \\<and> (v1 = v2 \\<or> (v1,v2) \\<in> subs\\<^sup>+)\"", "lemma (in wf_sub_rel) Nil_sp :\n  \"subpath g v1 [] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                             \\<and> v1 \\<in> Graph.vertices g \n                             \\<and> (v1 = v2 \\<or> (v1,v2) \\<in> subs)\"", "lemma sp_one :\n  shows   \"subpath g v1 [e] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                      \\<and> (v1 = src e \\<or> (v1,src e) \\<in> subs\\<^sup>+) \n                                      \\<and> e \\<in> edges g \n                                      \\<and> (tgt e = v2 \\<or> (tgt e,v2) \\<in> subs\\<^sup>+)\"", "lemma (in wf_sub_rel_of) sp_one :\n  shows \"subpath g v1 [e] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                    \\<and> (v1 = src e \\<or> (v1,src e) \\<in> subs) \n                                    \\<and> e \\<in> edges g \n                                    \\<and> (tgt e = v2 \\<or> (tgt e,v2) \\<in> subs)\"", "lemma sp_Cons :\n  shows   \"subpath g v1 (e # es) v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                           \\<and> (v1 = src e  \\<or> (v1,src e) \\<in> subs\\<^sup>+) \n                                           \\<and> e \\<in> edges g \n                                           \\<and> subpath g (tgt e) es v2 subs\"", "lemma (in wf_sub_rel_of) sp_Cons :\n  \"subpath g v1 (e # es) v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                   \\<and> (v1 = src e \\<or> (v1,src e) \\<in> subs) \n                                   \\<and> e \\<in> edges g \n                                   \\<and> subpath g (tgt e) es v2 subs\"", "lemma sp_append_one :\n  \"subpath g v1 (es @ [e]) v2 subs \\<longleftrightarrow> subpath g v1 es (src e) subs \n                                     \\<and> e \\<in> edges g  \n                                     \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs\\<^sup>+)\"", "lemma (in wf_sub_rel) sp_append_one :\n  \"subpath g v1 (es @ [e]) v2 subs \\<longleftrightarrow> subpath g v1 es (src e) subs \n                                     \\<and> e \\<in> edges g  \n                                     \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs)\"", "lemma sp_append :\n  \"subpath g v1 (es1 @ es2) v2 subs \\<longleftrightarrow> \n   (\\<exists> v. subpath g v1 es1 v subs \\<and> subpath g v es2 v2 subs)\"", "lemma fst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2 subs\"\n  shows   \"v1 \\<in> Graph.vertices g\"", "lemma lst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2 subs\"\n  shows   \"v2 \\<in> Graph.vertices g\"", "lemma sp_append_sub :\n  assumes \"subpath g v1 es v2 subs\"\n  assumes \"(v2,v3) \\<in> subs\"\n  shows   \"subpath g v1 es v3 subs\"", "lemma (in wf_sub_rel_of) sp_from_subsumee :\n  assumes \"(v1,v2) \\<in> subs\"\n  assumes \"subpath g v1 es v subs\"\n  assumes \"out_edges g v1 = {}\"               \n  shows   \"es = [] \\<or> subpath g v2 es v subs\"", "lemma sp_from_de_empty :\n  assumes \"v1 \\<notin> subsumees subs\"\n  assumes \"out_edges g v1 = {}\"\n  assumes \"subpath g v1 es v2 subs\"\n  shows   \"es = []\"", "lemma sp_through_de_decomp :\n  assumes \"tgt e \\<notin> subsumees subs\"\n  assumes \"out_edges g (tgt e) = {}\"\n  assumes \"subpath g v1 es v2 subs\"\n  assumes \"e \\<in> set es\"\n  shows   \"\\<exists> es'. es = es' @ [e] \\<and> e \\<notin> set es'\"", "lemma (in sub_rel_of) sp_ends_in_tgt_imp_mem :\n  assumes \"tgt e \\<notin> Graph.vertices g\"\n  assumes \"v \\<noteq> tgt e\"\n  assumes \"subpath (add_edge g e) v es (tgt e) subs\"\n  shows   \"e \\<in> set es\""], "translations": [["", "lemma subsumees_conv :\n  \"subsumees subs = {v. \\<exists> v'. (v,v') \\<in> subs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumees subs = {v. \\<exists>v'. (v, v') \\<in> subs}", "by force"], ["", "lemma subsumers_conv :\n  \"subsumers subs = {v'. \\<exists> v. (v,v') \\<in> subs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subsumers subs = {v'. \\<exists>v. (v, v') \\<in> subs}", "by force"], ["", "text \\<open>We call set of vertices of the relation the union of its sets of subsumees and subsumers.\\<close>"], ["", "abbreviation vertices ::\n  \"'v sub_rel_t \\<Rightarrow> ('v \\<times> nat) set\" \nwhere\n  \"vertices subs \\<equiv> subsumers subs \\<union> subsumees subs\""], ["", "subsection \\<open>Well-formed subsumption relation of a graph\\<close>"], ["", "subsubsection \\<open>Well-formed subsumption relations\\<close>"], ["", "text \\<open>In the following, we make an intensive use of \\emph{locales}. We use them as a convenient \nway to add assumptions to the following lemmas, in order to ease their reading. Locales can be \nbuilt from locales, allowing some modularity in the formalization. The following locale simply \nstates that we suppose there exists  a subsumption relation called \\emph{subs}. It will \nbe used later in order to constrain subsumption relations.\\<close>"], ["", "locale sub_rel =\n  fixes subs :: \"'v sub_rel_t\" (structure)"], ["", "text \\<open>We are only interested in subsumptions involving two different\noccurrences of the same LTS \nlocation. Moreover, once a vertex has been subsumed, there is no point in trying to subsume it again\nby another subsumer: subsumees must have a unique subsumer. Finally, we do not allow chains of \nsubsumptions, thus the intersection of the sets of subsumers and subsumees must be empty. Such \nsubsumption relations are said to be \\emph{well-formed}.\\<close>"], ["", "locale wf_sub_rel = sub_rel +\n  assumes sub_imp_same_verts : \n    \"sub \\<in> subs \\<Longrightarrow> fst (subsumee sub) = fst (subsumer sub)\"\n  \n  assumes subsumed_by_one : \n    \"\\<forall> v \\<in> subsumees subs. \\<exists>! v'. (v,v') \\<in> subs\"\n  \n  assumes inter_empty : \n    \"subsumers subs \\<inter> subsumees subs = {}\"\n\nbegin"], ["", "lemmas wf_sub_rel = sub_imp_same_verts subsumed_by_one inter_empty"], ["", "text \\<open>A rephrasing of the assumption @{term \"subsumed_by_one\"}.\\<close>"], ["", "lemma (in wf_sub_rel) subsumed_by_two_imp : \n    assumes \"(v,v1) \\<in> subs\"\n    assumes \"(v,v2) \\<in> subs\" \n    shows   \"v1 = v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 = v2", "using assms wf_sub_rel"], ["proof (prove)\nusing this:\n  (v, v1) \\<in> subs\n  (v, v2) \\<in> subs\n  ?sub \\<in> subs \\<Longrightarrow>\n  fst (subsumee ?sub) = fst (subsumer ?sub)\n  \\<forall>v\\<in>subsumees subs. \\<exists>!v'. (v, v') \\<in> subs\n  subsumers subs \\<inter> subsumees subs = {}\n\ngoal (1 subgoal):\n 1. v1 = v2", "unfolding subsumees_conv"], ["proof (prove)\nusing this:\n  (v, v1) \\<in> subs\n  (v, v2) \\<in> subs\n  ?sub \\<in> subs \\<Longrightarrow>\n  fst (subsumee ?sub) = fst (subsumer ?sub)\n  \\<forall>v\\<in>{v. \\<exists>v'. (v, v') \\<in> subs}.\n     \\<exists>!v'. (v, v') \\<in> subs\n  subsumers subs \\<inter> {v. \\<exists>v'. (v, v') \\<in> subs} = {}\n\ngoal (1 subgoal):\n 1. v1 = v2", "by blast"], ["", "text \\<open>A well-formed subsumption relation is equal to its transitive closure. We will see in the \n  following one has to handle transitive closures of such relations.\\<close>"], ["", "lemma in_trancl_imp :\n    assumes \"(v,v') \\<in> subs\\<^sup>+\"\n    shows   \"(v,v') \\<in> subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, v') \\<in> subs", "using tranclD[OF assms] tranclD[of _ v' subs]\n        rtranclD[of _ v' subs]  \n        inter_empty"], ["proof (prove)\nusing this:\n  \\<exists>z. (v, z) \\<in> subs \\<and> (z, v') \\<in> subs\\<^sup>*\n  (?x, v') \\<in> subs\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> subs \\<and> (z, v') \\<in> subs\\<^sup>*\n  (?a, v') \\<in> subs\\<^sup>* \\<Longrightarrow>\n  ?a = v' \\<or> ?a \\<noteq> v' \\<and> (?a, v') \\<in> subs\\<^sup>+\n  subsumers subs \\<inter> subsumees subs = {}\n\ngoal (1 subgoal):\n 1. (v, v') \\<in> subs", "by force"], ["", "lemma trancl_eq :\n    \"subs\\<^sup>+ = subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subs\\<^sup>+ = subs", "using in_trancl_imp r_into_trancl[of _ _ subs]"], ["proof (prove)\nusing this:\n  (?v, ?v') \\<in> subs\\<^sup>+ \\<Longrightarrow> (?v, ?v') \\<in> subs\n  (?a, ?b) \\<in> subs \\<Longrightarrow> (?a, ?b) \\<in> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. subs\\<^sup>+ = subs", "by fast"], ["", "end"], ["", "text \\<open>The empty subsumption relation is well-formed.\\<close>"], ["", "lemma\n  \"wf_sub_rel {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_sub_rel {}", "by (auto simp add : wf_sub_rel_def)"], ["", "subsubsection \\<open>Subsumption relation of a graph\\<close>"], ["", "text \\<open>We consider subsumption relations to equip rooted graphs. However, nothing in the previous \ndefinitions relates these relations to graphs: subsumptions relations involve objects that are of \nthe type of indexed vertices, but that might to not be vertices of an actual graph. We equip \ngraphs with subsumption relations using the notion of \\emph{sub-relation of a graph}. Such a \nrelation must only involve vertices of the graph it equips.\\<close>"], ["", "locale rgraph = \n  fixes g :: \"('v,'x) rgraph_scheme\" (structure)"], ["", "locale sub_rel_of = rgraph + sub_rel +\n  assumes related_are_verts : \"vertices subs \\<subseteq> Graph.vertices g\"\nbegin"], ["", "lemmas sub_rel_of = related_are_verts"], ["", "text \\<open>The transitive closure of a sub-relation of a graph @{term \"g\"} is also a sub-relation of \n  @{term \"g\"}.\\<close>"], ["", "lemma trancl_sub_rel_of :\n     \"sub_rel_of g (subs\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_rel_of g (subs\\<^sup>+)", "using tranclD[of _ _ subs] tranclD2[of _ _ subs] sub_rel_of"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> subs\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> subs \\<and> (z, ?y) \\<in> subs\\<^sup>*\n  (?x, ?y) \\<in> subs\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> subs\\<^sup>* \\<and> (z, ?y) \\<in> subs\n  SubRel.vertices subs \\<subseteq> Graph.vertices g\n\ngoal (1 subgoal):\n 1. sub_rel_of g (subs\\<^sup>+)", "unfolding sub_rel_of_def subsumers_conv subsumees_conv"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> subs\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> subs \\<and> (z, ?y) \\<in> subs\\<^sup>*\n  (?x, ?y) \\<in> subs\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> subs\\<^sup>* \\<and> (z, ?y) \\<in> subs\n  {v'. \\<exists>v. (v, v') \\<in> subs} \\<union>\n  {v. \\<exists>v'. (v, v') \\<in> subs}\n  \\<subseteq> Graph.vertices g\n\ngoal (1 subgoal):\n 1. {v'. \\<exists>v. (v, v') \\<in> subs\\<^sup>+} \\<union>\n    {v. \\<exists>v'. (v, v') \\<in> subs\\<^sup>+}\n    \\<subseteq> Graph.vertices g", "by blast"], ["", "end"], ["", "text \\<open>The empty relation is a sub-relation of any graph.\\<close>"], ["", "lemma\n  \"sub_rel_of g {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_rel_of g {}", "by (auto simp add : sub_rel_of_def)"], ["", "subsubsection \\<open>Well-formed sub-relations\\<close>"], ["", "text \\<open>We pack both previous locales into a third one. We speak about \n\\emph{well-formed sub-relations}.\\<close>"], ["", "locale wf_sub_rel_of = rgraph + sub_rel +\n  assumes sub_rel_of : \"sub_rel_of g subs\"\n  assumes wf_sub_rel : \"wf_sub_rel subs\"\nbegin"], ["", "lemmas wf_sub_rel_of = sub_rel_of wf_sub_rel"], ["", "end"], ["", "text \\<open>The empty relation is a well-formed sub-relation of any graph.\\<close>"], ["", "lemma\n  \"wf_sub_rel_of g {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_sub_rel_of g {}", "by (auto simp add : sub_rel_of_def wf_sub_rel_def wf_sub_rel_of_def)"], ["", "text \\<open>As previously, even if, in the end, we are only interested by well-formed sub-relations, we \nassume the relation is such only when needed.\\<close>"], ["", "subsection \\<open>Consistent Edge Sequences, Sub-paths\\<close>"], ["", "subsubsection \\<open>Consistency in presence of a subsumption relation\\<close>"], ["", "text \\<open>We model sub-paths in the same spirit than in \\verb?Graph.thy?, by starting with \ndefining the consistency of a sequence of edges wrt.\\ a subsumption relation. The idea is \nthat subsumption links can ``fill the gaps'' between subsequent edges that would have made \nthe sequence inconsistent otherwise. For now, we define consistency of a sequence wrt.\\ any \nsubsumption relation. Thus, we cannot account yet for the fact that we only consider relations \nwithout chains of subsumptions. The empty sequence is consistent wrt.\\ to a subsumption relation \nfrom @{term \"v1\"} to @{term \"v2\"} if these two vertices are equal or if they belong to the \ntransitive closure of the relation. A non-empty sequence is consistent if it is made of consistent \nsequences whose extremities are linked in the transitive closure of the subsumption relation.\\<close>"], ["", "fun ces :: \"('v \\<times> nat) \\<Rightarrow> ('v \\<times> nat) edge list \\<Rightarrow> ('v \\<times> nat) \\<Rightarrow> 'v sub_rel_t \\<Rightarrow> bool\" where\n  \"ces v1 [] v2 subs = (v1 = v2  \\<or> (v1,v2) \\<in> subs\\<^sup>+)\"\n| \"ces v1 (e#es) v2 subs = ((v1 = src e \\<or> (v1,src e) \\<in> subs\\<^sup>+) \\<and> ces (tgt e) es v2 subs)\""], ["", "text \\<open>A consistent sequence from @{term \"v1\"} to @{term \"v2\"} without a  subsumption relation is \nconsistent between these two vertices in presence of any relation.\\<close>"], ["", "lemma\n  assumes \"Graph.ces v1 es v2\"\n  shows   \"ces v1 es v2 subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v2 subs", "using assms"], ["proof (prove)\nusing this:\n  Graph.ces v1 es v2\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v2 subs", "by (induct es arbitrary : v1, auto)"], ["", "text \\<open>Consistency in presence of the empty subsumption relation reduces to consistency as defined \nin \\verb?Graph.thy?.\\<close>"], ["", "lemma\n  assumes \"ces v1 es v2 {}\"\n  shows   \"Graph.ces v1 es v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.ces v1 es v2", "using assms"], ["proof (prove)\nusing this:\n  SubRel.ces v1 es v2 {}\n\ngoal (1 subgoal):\n 1. Graph.ces v1 es v2", "by (induct es arbitrary : v1, auto)"], ["", "text \\<open>Let @{term \"(v1,v2)\"} be an element of a subsumption relation, and @{term \"es\"} a sequence of \nedges consistent wrt.\\ this relation from vertex @{term \"v2\"}. Then @{term \"es\"} is also consistent \nfrom @{term \"v1\"}. Even if this lemma will not be used much in the following, this is the base fact \nfor saying that paths feasible from a subsumee are also feasible from its subsumer.\\<close>"], ["", "lemma acas_imp_dcas :\n  assumes \"(v1,v2) \\<in> subs\"\n  assumes \"ces v2 es v subs\"\n  shows   \"ces v1 es v subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v subs", "using assms"], ["proof (prove)\nusing this:\n  (v1, v2) \\<in> subs\n  SubRel.ces v2 es v subs\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v subs", "by (cases es, simp_all) (intro disjI2, force)+"], ["", "text \\<open>Let @{term \"es\"} be a sequence of edges consistent wrt. a subsumption relation. Extending \nthis relation preserves the consistency of @{term \"es\"}.\\<close>"], ["", "lemma ces_Un :\n  assumes \"ces v1 es v2  subs1\"\n  shows   \"ces v1 es v2 (subs1 \\<union> subs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v2 (subs1 \\<union> subs2)", "using assms"], ["proof (prove)\nusing this:\n  SubRel.ces v1 es v2 subs1\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v2 (subs1 \\<union> subs2)", "by (induct es arbitrary : v1, auto simp add : trancl_mono)"], ["", "text \\<open>A rephrasing of the previous lemma.\\<close>"], ["", "lemma cas_subset :\n  assumes \"ces v1 es v2  subs1\"\n  assumes \"subs1 \\<subseteq> subs2\"\n  shows   \"ces v1 es v2 subs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v2 subs2", "using assms"], ["proof (prove)\nusing this:\n  SubRel.ces v1 es v2 subs1\n  subs1 \\<subseteq> subs2\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 es v2 subs2", "by (induct es arbitrary : v1, auto simp add : trancl_mono)"], ["", "text \\<open>Simplification lemmas for @{term \"ces\"}.\\<close>"], ["", "lemma ces_append_one :\n  \"ces v1 (es @ [e]) v2 subs = (ces v1 es (src e) subs \\<and> ces (src e) [e] v2 subs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.ces v1 (es @ [e]) v2 subs =\n    (SubRel.ces v1 es (src e) subs \\<and> SubRel.ces (src e) [e] v2 subs)", "by (induct es arbitrary : v1, auto)"], ["", "lemma ces_append :\n  \"ces v1 (es1 @ es2) v2 subs = (\\<exists> v. ces v1 es1 v subs \\<and> ces v es2 v2 subs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.ces v1 (es1 @ es2) v2 subs =\n    (\\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs)", "proof (intro iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. SubRel.ces v1 (es1 @ es2) v2 subs \\<Longrightarrow>\n    \\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs\n 2. \\<exists>v.\n       SubRel.ces v1 es1 v subs \\<and>\n       SubRel.ces v es2 v2 subs \\<Longrightarrow>\n    SubRel.ces v1 (es1 @ es2) v2 subs", "case 1"], ["proof (state)\nthis:\n  SubRel.ces v1 (es1 @ es2) v2 subs\n\ngoal (2 subgoals):\n 1. SubRel.ces v1 (es1 @ es2) v2 subs \\<Longrightarrow>\n    \\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs\n 2. \\<exists>v.\n       SubRel.ces v1 es1 v subs \\<and>\n       SubRel.ces v es2 v2 subs \\<Longrightarrow>\n    SubRel.ces v1 (es1 @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.ces v1 (es1 @ es2) v2 subs\n\ngoal (1 subgoal):\n 1. \\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs", "by (induct es1 arbitrary : v1)  \n     (simp_all del : split_paired_Ex, blast)"], ["proof (state)\nthis:\n  \\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.ces v1 es1 v subs \\<and>\n       SubRel.ces v es2 v2 subs \\<Longrightarrow>\n    SubRel.ces v1 (es1 @ es2) v2 subs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.ces v1 es1 v subs \\<and>\n       SubRel.ces v es2 v2 subs \\<Longrightarrow>\n    SubRel.ces v1 (es1 @ es2) v2 subs", "case 2"], ["proof (state)\nthis:\n  \\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.ces v1 es1 v subs \\<and>\n       SubRel.ces v es2 v2 subs \\<Longrightarrow>\n    SubRel.ces v1 (es1 @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>v. SubRel.ces v1 es1 v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 (es1 @ es2) v2 subs", "proof (induct es1 arbitrary : v1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<exists>v.\n          SubRel.ces v1 [] v subs \\<and>\n          SubRel.ces v es2 v2 subs \\<Longrightarrow>\n       SubRel.ces v1 ([] @ es2) v2 subs\n 2. \\<And>a es1 v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<exists>v.\n                      SubRel.ces v1 es1 v subs \\<and>\n                      SubRel.ces v es2 v2 subs \\<Longrightarrow>\n                   SubRel.ces v1 (es1 @ es2) v2 subs;\n        \\<exists>v.\n           SubRel.ces v1 (a # es1) v subs \\<and>\n           SubRel.ces v es2 v2 subs\\<rbrakk>\n       \\<Longrightarrow> SubRel.ces v1 ((a # es1) @ es2) v2 subs", "case (Nil v1)"], ["proof (state)\nthis:\n  \\<exists>v. SubRel.ces v1 [] v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<exists>v.\n          SubRel.ces v1 [] v subs \\<and>\n          SubRel.ces v es2 v2 subs \\<Longrightarrow>\n       SubRel.ces v1 ([] @ es2) v2 subs\n 2. \\<And>a es1 v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<exists>v.\n                      SubRel.ces v1 es1 v subs \\<and>\n                      SubRel.ces v es2 v2 subs \\<Longrightarrow>\n                   SubRel.ces v1 (es1 @ es2) v2 subs;\n        \\<exists>v.\n           SubRel.ces v1 (a # es1) v subs \\<and>\n           SubRel.ces v es2 v2 subs\\<rbrakk>\n       \\<Longrightarrow> SubRel.ces v1 ((a # es1) @ es2) v2 subs", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. SubRel.ces v1 [] v subs \\<and> SubRel.ces v es2 v2 subs", "obtain v where \"ces v1 [] v subs\" \n                  and   \"ces v es2 v2 subs\""], ["proof (prove)\nusing this:\n  \\<exists>v. SubRel.ces v1 [] v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>SubRel.ces v1 [] v subs; SubRel.ces v es2 v2 subs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  SubRel.ces v1 [] v subs\n  SubRel.ces v es2 v2 subs\n\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<exists>v.\n          SubRel.ces v1 [] v subs \\<and>\n          SubRel.ces v es2 v2 subs \\<Longrightarrow>\n       SubRel.ces v1 ([] @ es2) v2 subs\n 2. \\<And>a es1 v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<exists>v.\n                      SubRel.ces v1 es1 v subs \\<and>\n                      SubRel.ces v es2 v2 subs \\<Longrightarrow>\n                   SubRel.ces v1 (es1 @ es2) v2 subs;\n        \\<exists>v.\n           SubRel.ces v1 (a # es1) v subs \\<and>\n           SubRel.ces v es2 v2 subs\\<rbrakk>\n       \\<Longrightarrow> SubRel.ces v1 ((a # es1) @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.ces v1 [] v subs\n  SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 ([] @ es2) v2 subs", "unfolding ces.simps"], ["proof (prove)\nusing this:\n  v1 = v \\<or> (v1, v) \\<in> subs\\<^sup>+\n  SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 ([] @ es2) v2 subs", "proof (elim disjE, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>SubRel.ces v es2 v2 subs; v1 = v\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs\n 2. \\<lbrakk>SubRel.ces v es2 v2 subs; (v1, v) \\<in> subs\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs", "case 1"], ["proof (state)\nthis:\n  SubRel.ces v es2 v2 subs\n  v1 = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>SubRel.ces v es2 v2 subs; v1 = v\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs\n 2. \\<lbrakk>SubRel.ces v es2 v2 subs; (v1, v) \\<in> subs\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.ces v es2 v2 subs\n  v1 = v\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 ([] @ es2) v2 subs", "by simp"], ["proof (state)\nthis:\n  SubRel.ces v1 ([] @ es2) v2 subs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>SubRel.ces v es2 v2 subs; (v1, v) \\<in> subs\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>SubRel.ces v es2 v2 subs; (v1, v) \\<in> subs\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs", "case 2"], ["proof (state)\nthis:\n  SubRel.ces v es2 v2 subs\n  (v1, v) \\<in> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<lbrakk>SubRel.ces v es2 v2 subs; (v1, v) \\<in> subs\\<^sup>+\\<rbrakk>\n    \\<Longrightarrow> SubRel.ces v1 ([] @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.ces v es2 v2 subs\n  (v1, v) \\<in> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 ([] @ es2) v2 subs", "by (cases es2) (simp, intro disjI2, fastforce)+"], ["proof (state)\nthis:\n  SubRel.ces v1 ([] @ es2) v2 subs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SubRel.ces v1 ([] @ es2) v2 subs\n\ngoal (1 subgoal):\n 1. \\<And>a es1 v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<exists>v.\n                      SubRel.ces v1 es1 v subs \\<and>\n                      SubRel.ces v es2 v2 subs \\<Longrightarrow>\n                   SubRel.ces v1 (es1 @ es2) v2 subs;\n        \\<exists>v.\n           SubRel.ces v1 (a # es1) v subs \\<and>\n           SubRel.ces v es2 v2 subs\\<rbrakk>\n       \\<Longrightarrow> SubRel.ces v1 ((a # es1) @ es2) v2 subs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es1 v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<exists>v.\n                      SubRel.ces v1 es1 v subs \\<and>\n                      SubRel.ces v es2 v2 subs \\<Longrightarrow>\n                   SubRel.ces v1 (es1 @ es2) v2 subs;\n        \\<exists>v.\n           SubRel.ces v1 (a # es1) v subs \\<and>\n           SubRel.ces v es2 v2 subs\\<rbrakk>\n       \\<Longrightarrow> SubRel.ces v1 ((a # es1) @ es2) v2 subs", "case Cons"], ["proof (state)\nthis:\n  \\<exists>v.\n     SubRel.ces ?v1.0 es1_ v subs \\<and>\n     SubRel.ces v es2 v2 subs \\<Longrightarrow>\n  SubRel.ces ?v1.0 (es1_ @ es2) v2 subs\n  \\<exists>v.\n     SubRel.ces v1 (a_ # es1_) v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. \\<And>a es1 v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<exists>v.\n                      SubRel.ces v1 es1 v subs \\<and>\n                      SubRel.ces v es2 v2 subs \\<Longrightarrow>\n                   SubRel.ces v1 (es1 @ es2) v2 subs;\n        \\<exists>v.\n           SubRel.ces v1 (a # es1) v subs \\<and>\n           SubRel.ces v es2 v2 subs\\<rbrakk>\n       \\<Longrightarrow> SubRel.ces v1 ((a # es1) @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     SubRel.ces ?v1.0 es1_ v subs \\<and>\n     SubRel.ces v es2 v2 subs \\<Longrightarrow>\n  SubRel.ces ?v1.0 (es1_ @ es2) v2 subs\n  \\<exists>v.\n     SubRel.ces v1 (a_ # es1_) v subs \\<and> SubRel.ces v es2 v2 subs\n\ngoal (1 subgoal):\n 1. SubRel.ces v1 ((a_ # es1_) @ es2) v2 subs", "by auto"], ["proof (state)\nthis:\n  SubRel.ces v1 ((a_ # es1_) @ es2) v2 subs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  SubRel.ces v1 (es1 @ es2) v2 subs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Let @{term \"es\"} be a sequence of edges consistent from @{term \"v1\"} to @{term \"v2\"} wrt.\\ a \nsub-relation @{term \"subs\"} of a graph @{term \"g\"}. Suppose elements of this sequence are edges of \n@{term \"g\"}. If @{term \"v1\"} is a vertex of @{term \"g\"} then @{term \"v2\"} is also a vertex of \n@{term \"g\"}.\\<close>"], ["", "lemma (in sub_rel_of) ces_imp_ends_vertices :\n  assumes \"ces v1 es v2 subs\"\n  assumes \"set es \\<subseteq> edges g\"\n  assumes \"v1 \\<in> Graph.vertices g\"\n  shows   \"v2 \\<in> Graph.vertices g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<in> Graph.vertices g", "using assms trancl_sub_rel_of"], ["proof (prove)\nusing this:\n  SubRel.ces v1 es v2 subs\n  set es \\<subseteq> edges g\n  v1 \\<in> Graph.vertices g\n  sub_rel_of g (subs\\<^sup>+)\n\ngoal (1 subgoal):\n 1. v2 \\<in> Graph.vertices g", "unfolding sub_rel_of_def subsumers_conv vertices_def"], ["proof (prove)\nusing this:\n  SubRel.ces v1 es v2 subs\n  set es \\<subseteq> edges g\n  v1 \\<in> {root g} \\<union> src ` edges g \\<union> tgt ` edges g\n  {v'. \\<exists>v. (v, v') \\<in> subs\\<^sup>+} \\<union>\n  subsumees (subs\\<^sup>+)\n  \\<subseteq> {root g} \\<union> src ` edges g \\<union> tgt ` edges g\n\ngoal (1 subgoal):\n 1. v2 \\<in> {root g} \\<union> src ` edges g \\<union> tgt ` edges g", "by (induct es arbitrary : v1) (force, (simp del : split_paired_Ex, fast))"], ["", "subsubsection \\<open>Sub-paths\\<close>"], ["", "text \\<open>A sub-path leading from @{term \"v1\"} to @{term \"v2\"}, two vertices of a graph @{term \"g\"} \nequipped with a subsumption relation @{term \"subs\"}, is a sequence of edges consistent wrt.\\ \n@{term \"subs\"} from @{term \"v1\"} to @{term \"v2\"} whose elements are edges of @{term \"g\"}. \nMoreover, we must assume that @{term \"subs\"} is a sub-relation of @{term \"g\"}, otherwise \n@{term \"es\"} could ``exit'' @{term \"g\"} through subsumption links.\\<close>"], ["", "definition subpath :: \n  \"(('v \\<times> nat),'x) rgraph_scheme \\<Rightarrow> ('v \\<times> nat) \\<Rightarrow> ('v \\<times> nat) edge list \\<Rightarrow> ('v \\<times> nat) \\<Rightarrow> (('v \\<times> nat) \\<times> ('v \\<times> nat)) set \\<Rightarrow> bool\" \nwhere\n  \"subpath g v1 es v2 subs \\<equiv> sub_rel_of g subs \n                           \\<and> v1 \\<in> Graph.vertices g\n                           \\<and> ces v1 es v2 subs  \n                           \\<and> set es \\<subseteq> edges g\""], ["", "text \\<open>Once again, in some cases, we will not be interested in the ending vertex of a sub-path.\\<close>"], ["", "abbreviation subpath_from ::\n  \"(('v \\<times> nat),'x) rgraph_scheme \\<Rightarrow> ('v \\<times> nat) \\<Rightarrow> ('v \\<times> nat) edge list \\<Rightarrow> 'v sub_rel_t \\<Rightarrow> bool\"\nwhere\n  \"subpath_from g v es subs \\<equiv> \\<exists> v'. subpath g v es v' subs\""], ["", "text \\<open>Simplification lemmas for @{term subpath}.\\<close>"], ["", "lemma Nil_sp :\n  \"subpath g v1 [] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                             \\<and> v1 \\<in> Graph.vertices g \n                             \\<and> (v1 = v2 \\<or> (v1,v2) \\<in> subs\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [] v2 subs =\n    (sub_rel_of g subs \\<and>\n     v1 \\<in> Graph.vertices g \\<and>\n     (v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+))", "by (auto simp add : subpath_def)"], ["", "text \\<open>When the subsumption relation is well-formed (denoted by \\<open>(in wf_sub_rel)\\<close>), \nthere is no need to account for the transitive closure of the relation.\\<close>"], ["", "lemma (in wf_sub_rel) Nil_sp :\n  \"subpath g v1 [] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                             \\<and> v1 \\<in> Graph.vertices g \n                             \\<and> (v1 = v2 \\<or> (v1,v2) \\<in> subs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [] v2 subs =\n    (sub_rel_of g subs \\<and>\n     v1 \\<in> Graph.vertices g \\<and> (v1 = v2 \\<or> (v1, v2) \\<in> subs))", "using trancl_eq"], ["proof (prove)\nusing this:\n  subs\\<^sup>+ = subs\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [] v2 subs =\n    (sub_rel_of g subs \\<and>\n     v1 \\<in> Graph.vertices g \\<and> (v1 = v2 \\<or> (v1, v2) \\<in> subs))", "by (simp add : Nil_sp)"], ["", "text \\<open>Simplification lemma for the one-element sequence.\\<close>"], ["", "lemma sp_one :\n  shows   \"subpath g v1 [e] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                      \\<and> (v1 = src e \\<or> (v1,src e) \\<in> subs\\<^sup>+) \n                                      \\<and> e \\<in> edges g \n                                      \\<and> (tgt e = v2 \\<or> (tgt e,v2) \\<in> subs\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [e] v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs\\<^sup>+) \\<and>\n     e \\<in> edges g \\<and>\n     (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs\\<^sup>+))", "using sub_rel_of.trancl_sub_rel_of[of g subs]"], ["proof (prove)\nusing this:\n  sub_rel_of g subs \\<Longrightarrow> sub_rel_of g (subs\\<^sup>+)\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [e] v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs\\<^sup>+) \\<and>\n     e \\<in> edges g \\<and>\n     (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs\\<^sup>+))", "by (intro iffI, auto simp add : vertices_def sub_rel_of_def subpath_def)"], ["", "text \\<open>Once again, when the subsumption relation is well-formed, the previous lemma can be \nsimplified since, in this case, the transitive closure of the relation is the relation itself.\\<close>"], ["", "lemma (in wf_sub_rel_of) sp_one :\n  shows \"subpath g v1 [e] v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                    \\<and> (v1 = src e \\<or> (v1,src e) \\<in> subs) \n                                    \\<and> e \\<in> edges g \n                                    \\<and> (tgt e = v2 \\<or> (tgt e,v2) \\<in> subs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [e] v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs) \\<and>\n     e \\<in> edges g \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs))", "using sp_one wf_sub_rel.trancl_eq[OF wf_sub_rel]"], ["proof (prove)\nusing this:\n  SubRel.subpath ?g ?v1.0 [?e] ?v2.0 ?subs =\n  (sub_rel_of ?g ?subs \\<and>\n   (?v1.0 = src ?e \\<or> (?v1.0, src ?e) \\<in> ?subs\\<^sup>+) \\<and>\n   ?e \\<in> edges ?g \\<and>\n   (tgt ?e = ?v2.0 \\<or> (tgt ?e, ?v2.0) \\<in> ?subs\\<^sup>+))\n  subs\\<^sup>+ = subs\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 [e] v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs) \\<and>\n     e \\<in> edges g \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs))", "by fast"], ["", "text \\<open>Simplification lemma for the non-empty sequence (which might contain more than one element).\\<close>"], ["", "lemma sp_Cons :\n  shows   \"subpath g v1 (e # es) v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                           \\<and> (v1 = src e  \\<or> (v1,src e) \\<in> subs\\<^sup>+) \n                                           \\<and> e \\<in> edges g \n                                           \\<and> subpath g (tgt e) es v2 subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (e # es) v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs\\<^sup>+) \\<and>\n     e \\<in> edges g \\<and> SubRel.subpath g (tgt e) es v2 subs)", "using sub_rel_of.trancl_sub_rel_of[of g subs]"], ["proof (prove)\nusing this:\n  sub_rel_of g subs \\<Longrightarrow> sub_rel_of g (subs\\<^sup>+)\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (e # es) v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs\\<^sup>+) \\<and>\n     e \\<in> edges g \\<and> SubRel.subpath g (tgt e) es v2 subs)", "by (intro iffI, auto simp add : subpath_def vertices_def sub_rel_of_def)"], ["", "text \\<open>The same lemma when the subsumption relation is well-formed.\\<close>"], ["", "lemma (in wf_sub_rel_of) sp_Cons :\n  \"subpath g v1 (e # es) v2 subs \\<longleftrightarrow> sub_rel_of g subs \n                                   \\<and> (v1 = src e \\<or> (v1,src e) \\<in> subs) \n                                   \\<and> e \\<in> edges g \n                                   \\<and> subpath g (tgt e) es v2 subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (e # es) v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs) \\<and>\n     e \\<in> edges g \\<and> SubRel.subpath g (tgt e) es v2 subs)", "using sp_Cons wf_sub_rel.trancl_eq[OF wf_sub_rel]"], ["proof (prove)\nusing this:\n  SubRel.subpath ?g ?v1.0 (?e # ?es) ?v2.0 ?subs =\n  (sub_rel_of ?g ?subs \\<and>\n   (?v1.0 = src ?e \\<or> (?v1.0, src ?e) \\<in> ?subs\\<^sup>+) \\<and>\n   ?e \\<in> edges ?g \\<and> SubRel.subpath ?g (tgt ?e) ?es ?v2.0 ?subs)\n  subs\\<^sup>+ = subs\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (e # es) v2 subs =\n    (sub_rel_of g subs \\<and>\n     (v1 = src e \\<or> (v1, src e) \\<in> subs) \\<and>\n     e \\<in> edges g \\<and> SubRel.subpath g (tgt e) es v2 subs)", "by fast"], ["", "text \\<open>Simplification lemma for @{term \"subpath\"} when the sequence is known to end by a given \nedge.\\<close>"], ["", "lemma sp_append_one :\n  \"subpath g v1 (es @ [e]) v2 subs \\<longleftrightarrow> subpath g v1 es (src e) subs \n                                     \\<and> e \\<in> edges g  \n                                     \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (es @ [e]) v2 subs =\n    (SubRel.subpath g v1 es (src e) subs \\<and>\n     e \\<in> edges g \\<and>\n     (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs\\<^sup>+))", "unfolding subpath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sub_rel_of g subs \\<and>\n     v1 \\<in> Graph.vertices g \\<and>\n     SubRel.ces v1 (es @ [e]) v2 subs \\<and>\n     set (es @ [e]) \\<subseteq> edges g) =\n    ((sub_rel_of g subs \\<and>\n      v1 \\<in> Graph.vertices g \\<and>\n      SubRel.ces v1 es (src e) subs \\<and>\n      set es \\<subseteq> edges g) \\<and>\n     e \\<in> edges g \\<and>\n     (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs\\<^sup>+))", "by (auto simp add :  ces_append_one)"], ["", "text \\<open>Simpler version in the case of a well-formed subsumption relation.\\<close>"], ["", "lemma (in wf_sub_rel) sp_append_one :\n  \"subpath g v1 (es @ [e]) v2 subs \\<longleftrightarrow> subpath g v1 es (src e) subs \n                                     \\<and> e \\<in> edges g  \n                                     \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (es @ [e]) v2 subs =\n    (SubRel.subpath g v1 es (src e) subs \\<and>\n     e \\<in> edges g \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs))", "using sp_append_one in_trancl_imp"], ["proof (prove)\nusing this:\n  SubRel.subpath ?g ?v1.0 (?es @ [?e]) ?v2.0 ?subs =\n  (SubRel.subpath ?g ?v1.0 ?es (src ?e) ?subs \\<and>\n   ?e \\<in> edges ?g \\<and>\n   (tgt ?e = ?v2.0 \\<or> (tgt ?e, ?v2.0) \\<in> ?subs\\<^sup>+))\n  (?v, ?v') \\<in> subs\\<^sup>+ \\<Longrightarrow> (?v, ?v') \\<in> subs\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (es @ [e]) v2 subs =\n    (SubRel.subpath g v1 es (src e) subs \\<and>\n     e \\<in> edges g \\<and> (tgt e = v2 \\<or> (tgt e, v2) \\<in> subs))", "by fast"], ["", "text \\<open>Simplification lemma when the sequence is known to be the concatenation of two \nsub-sequences.\\<close>"], ["", "lemma sp_append :\n  \"subpath g v1 (es1 @ es2) v2 subs \\<longleftrightarrow> \n   (\\<exists> v. subpath g v1 es1 v subs \\<and> subpath g v es2 v2 subs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (es1 @ es2) v2 subs =\n    (\\<exists>v.\n        SubRel.subpath g v1 es1 v subs \\<and>\n        SubRel.subpath g v es2 v2 subs)", "proof (intro iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. SubRel.subpath g v1 (es1 @ es2) v2 subs \\<Longrightarrow>\n    \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs\n 2. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and>\n       SubRel.subpath g v es2 v2 subs \\<Longrightarrow>\n    SubRel.subpath g v1 (es1 @ es2) v2 subs", "case 1"], ["proof (state)\nthis:\n  SubRel.subpath g v1 (es1 @ es2) v2 subs\n\ngoal (2 subgoals):\n 1. SubRel.subpath g v1 (es1 @ es2) v2 subs \\<Longrightarrow>\n    \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs\n 2. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and>\n       SubRel.subpath g v es2 v2 subs \\<Longrightarrow>\n    SubRel.subpath g v1 (es1 @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.subpath g v1 (es1 @ es2) v2 subs\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs", "using sub_rel_of.ces_imp_ends_vertices"], ["proof (prove)\nusing this:\n  SubRel.subpath g v1 (es1 @ es2) v2 subs\n  \\<lbrakk>sub_rel_of ?g ?subs; SubRel.ces ?v1.0 ?es ?v2.0 ?subs;\n   set ?es \\<subseteq> edges ?g; ?v1.0 \\<in> Graph.vertices ?g\\<rbrakk>\n  \\<Longrightarrow> ?v2.0 \\<in> Graph.vertices ?g\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs", "by (simp add : subpath_def ces_append) blast"], ["proof (state)\nthis:\n  \\<exists>v.\n     SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and>\n       SubRel.subpath g v es2 v2 subs \\<Longrightarrow>\n    SubRel.subpath g v1 (es1 @ es2) v2 subs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and>\n       SubRel.subpath g v es2 v2 subs \\<Longrightarrow>\n    SubRel.subpath g v1 (es1 @ es2) v2 subs", "case 2"], ["proof (state)\nthis:\n  \\<exists>v.\n     SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       SubRel.subpath g v1 es1 v subs \\<and>\n       SubRel.subpath g v es2 v2 subs \\<Longrightarrow>\n    SubRel.subpath g v1 (es1 @ es2) v2 subs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     SubRel.subpath g v1 es1 v subs \\<and> SubRel.subpath g v es2 v2 subs\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 (es1 @ es2) v2 subs", "unfolding subpath_def"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     (sub_rel_of g subs \\<and>\n      v1 \\<in> Graph.vertices g \\<and>\n      SubRel.ces v1 es1 v subs \\<and> set es1 \\<subseteq> edges g) \\<and>\n     sub_rel_of g subs \\<and>\n     v \\<in> Graph.vertices g \\<and>\n     SubRel.ces v es2 v2 subs \\<and> set es2 \\<subseteq> edges g\n\ngoal (1 subgoal):\n 1. sub_rel_of g subs \\<and>\n    v1 \\<in> Graph.vertices g \\<and>\n    SubRel.ces v1 (es1 @ es2) v2 subs \\<and>\n    set (es1 @ es2) \\<subseteq> edges g", "by (simp only : ces_append) fastforce"], ["proof (state)\nthis:\n  SubRel.subpath g v1 (es1 @ es2) v2 subs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Let @{term \"es\"} be a sub-path of a graph @{term \"g\"} starting at vertex @{term \"v1\"}. \nBy definition of @{term \"subpath\"}, @{term \"v1\"} is a vertex of @{term \"g\"}. Even if this is a \ndirect consequence of the definition of @{term \"subpath\"}, this lemma will ease the proofs of some \ngoals in the following.\\<close>"], ["", "lemma fst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2 subs\"\n  shows   \"v1 \\<in> Graph.vertices g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 \\<in> Graph.vertices g", "using assms"], ["proof (prove)\nusing this:\n  SubRel.subpath g v1 es v2 subs\n\ngoal (1 subgoal):\n 1. v1 \\<in> Graph.vertices g", "by (simp add : subpath_def)"], ["", "text \\<open>The same property (which also follows the definition of @{term \"subpath\"}, but not as \ntrivially as the previous lemma) can be established for the final vertex @{term \"v2\"}.\\<close>"], ["", "lemma lst_of_sp_is_vert :\n  assumes \"subpath g v1 es v2 subs\"\n  shows   \"v2 \\<in> Graph.vertices g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v2 \\<in> Graph.vertices g", "using assms sub_rel_of.trancl_sub_rel_of[of g subs]"], ["proof (prove)\nusing this:\n  SubRel.subpath g v1 es v2 subs\n  sub_rel_of g subs \\<Longrightarrow> sub_rel_of g (subs\\<^sup>+)\n\ngoal (1 subgoal):\n 1. v2 \\<in> Graph.vertices g", "by (induction es arbitrary : v1) \n   (force simp add : subpath_def sub_rel_of_def, (simp add : sp_Cons, fast))"], ["", "text \\<open>A sub-path ending in a subsumed vertex can be extended to the subsumer of this vertex, \nprovided that the subsumption relation is a sub-relation of the graph it equips.\\<close>"], ["", "lemma sp_append_sub :\n  assumes \"subpath g v1 es v2 subs\"\n  assumes \"(v2,v3) \\<in> subs\"\n  shows   \"subpath g v1 es v3 subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 es v3 subs", "proof (cases es)"], ["proof (state)\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow> SubRel.subpath g v1 es v3 subs\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "case Nil"], ["proof (state)\nthis:\n  es = []\n\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow> SubRel.subpath g v1 es v3 subs\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "moreover"], ["proof (state)\nthis:\n  es = []\n\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow> SubRel.subpath g v1 es v3 subs\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "hence \"v1 \\<in> Graph.vertices g\" \n  and   \"v1 = v2 \\<or> (v1,v2) \\<in> subs\\<^sup>+\""], ["proof (prove)\nusing this:\n  es = []\n\ngoal (1 subgoal):\n 1. v1 \\<in> Graph.vertices g &&& v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+", "using assms(1)"], ["proof (prove)\nusing this:\n  es = []\n  SubRel.subpath g v1 es v2 subs\n\ngoal (1 subgoal):\n 1. v1 \\<in> Graph.vertices g &&& v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+", "by (simp_all add : Nil_sp)"], ["proof (state)\nthis:\n  v1 \\<in> Graph.vertices g\n  v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+\n\ngoal (2 subgoals):\n 1. es = [] \\<Longrightarrow> SubRel.subpath g v1 es v3 subs\n 2. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "ultimately"], ["proof (chain)\npicking this:\n  es = []\n  v1 \\<in> Graph.vertices g\n  v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  es = []\n  v1 \\<in> Graph.vertices g\n  v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 es v3 subs", "using assms(1,2) \n        Nil_sp[of g v1 v2 subs] \n        trancl_into_trancl[of v1 v2 subs v3]"], ["proof (prove)\nusing this:\n  es = []\n  v1 \\<in> Graph.vertices g\n  v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+\n  SubRel.subpath g v1 es v2 subs\n  (v2, v3) \\<in> subs\n  SubRel.subpath g v1 [] v2 subs =\n  (sub_rel_of g subs \\<and>\n   v1 \\<in> Graph.vertices g \\<and>\n   (v1 = v2 \\<or> (v1, v2) \\<in> subs\\<^sup>+))\n  \\<lbrakk>(v1, v2) \\<in> subs\\<^sup>+; (v2, v3) \\<in> subs\\<rbrakk>\n  \\<Longrightarrow> (v1, v3) \\<in> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 es v3 subs", "by (auto simp add : subpath_def)"], ["proof (state)\nthis:\n  SubRel.subpath g v1 es v3 subs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "case Cons"], ["proof (state)\nthis:\n  es = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "then"], ["proof (chain)\npicking this:\n  es = a_ # list_", "obtain es' e where \"es = es' @ [e]\""], ["proof (prove)\nusing this:\n  es = a_ # list_\n\ngoal (1 subgoal):\n 1. (\\<And>es' e. es = es' @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using neq_Nil_conv2[of es]"], ["proof (prove)\nusing this:\n  es = a_ # list_\n  (es \\<noteq> []) = (\\<exists>x xs'. es = xs' @ [x])\n\ngoal (1 subgoal):\n 1. (\\<And>es' e. es = es' @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  es = es' @ [e]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       es = a # list \\<Longrightarrow> SubRel.subpath g v1 es v3 subs", "thus ?thesis"], ["proof (prove)\nusing this:\n  es = es' @ [e]\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 es v3 subs", "using assms trancl_into_trancl"], ["proof (prove)\nusing this:\n  es = es' @ [e]\n  SubRel.subpath g v1 es v2 subs\n  (v2, v3) \\<in> subs\n  \\<lbrakk>(?a, ?b) \\<in> ?r\\<^sup>+; (?b, ?c) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> (?a, ?c) \\<in> ?r\\<^sup>+\n\ngoal (1 subgoal):\n 1. SubRel.subpath g v1 es v3 subs", "by (simp add : sp_append_one) fast"], ["proof (state)\nthis:\n  SubRel.subpath g v1 es v3 subs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Let @{term \"g\"} be a graph equipped with a well-formed sub-relation. A sub-path starting at \na subsumed vertex @{term \"v1\"} whose set of out-edges is empty is either:\n\\begin{enumerate}\n  \\item empty,\n  \\item a sub-path starting at the subsumer @{term \"v2\"} of @{term \"v1\"}.\n\\end{enumerate}\nThe third assumption represent the fact that, when building red-black graphs, we do not allow to \nbuild the successor of a subsumed vertex.\\<close>"], ["", "lemma (in wf_sub_rel_of) sp_from_subsumee :\n  assumes \"(v1,v2) \\<in> subs\"\n  assumes \"subpath g v1 es v subs\"\n  assumes \"out_edges g v1 = {}\"               \n  shows   \"es = [] \\<or> subpath g v2 es v subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = [] \\<or> SubRel.subpath g v2 es v subs", "using assms\n      wf_sub_rel.subsumed_by_two_imp[OF wf_sub_rel assms(1)]"], ["proof (prove)\nusing this:\n  (v1, v2) \\<in> subs\n  SubRel.subpath g v1 es v subs\n  out_edges g v1 = {}\n  (v1, ?v2.0) \\<in> subs \\<Longrightarrow> v2 = ?v2.0\n\ngoal (1 subgoal):\n 1. es = [] \\<or> SubRel.subpath g v2 es v subs", "by (cases es) \n   (fast, (intro disjI2, fastforce simp add : sp_Cons))"], ["", "text \\<open>Note that it is not possible to split this lemma into two lemmas (one for each member of the \ndisjunctive conclusion). Suppose @{term \"v\"} is @{term \"v1\"}, then \n@{term \"es\"} could be empty or it could also be a non-empty sub-path leading from @{term \"v2\"} to \n@{term \"v1\"}. If @{term \"v\"} is not @{term \"v1\"}, it could be @{term \"v2\"} and @{term \"es\"} could \nbe empty or not.\\<close>"], ["", "text \\<open>A sub-path starting at a non-subsumed vertex whose set of out-edges is empty is also empty.\\<close>"], ["", "lemma sp_from_de_empty :\n  assumes \"v1 \\<notin> subsumees subs\"\n  assumes \"out_edges g v1 = {}\"\n  assumes \"subpath g v1 es v2 subs\"\n  shows   \"es = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = []", "using assms tranclD"], ["proof (prove)\nusing this:\n  v1 \\<notin> subsumees subs\n  out_edges g v1 = {}\n  SubRel.subpath g v1 es v2 subs\n  (?x, ?y) \\<in> ?R\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> ?R \\<and> (z, ?y) \\<in> ?R\\<^sup>*\n\ngoal (1 subgoal):\n 1. es = []", "by (cases es) (auto simp add : sp_Cons, force)"], ["", "text \\<open>Let @{term \"e\"} be an edge whose target is not subsumed and has not out-going edges. A \nsub-path @{term \"es\"} containing @{term \"e\"} ends by @{term \"e\"} and this occurrence of @{term \"e\"} \nis unique along @{term \"es\"}.\\<close>"], ["", "lemma sp_through_de_decomp :\n  assumes \"tgt e \\<notin> subsumees subs\"\n  assumes \"out_edges g (tgt e) = {}\"\n  assumes \"subpath g v1 es v2 subs\"\n  assumes \"e \\<in> set es\"\n  shows   \"\\<exists> es'. es = es' @ [e] \\<and> e \\<notin> set es'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'", "using assms(3,4)"], ["proof (prove)\nusing this:\n  SubRel.subpath g v1 es v2 subs\n  e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'", "proof (induction es arbitrary : v1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<lbrakk>SubRel.subpath g v1 [] v2 subs; e \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            [] = es' @ [e] \\<and> e \\<notin> set es'\n 2. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>SubRel.subpath g v1 es v2 subs;\n                    e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        SubRel.subpath g v1 (a # es) v2 subs; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "case (Nil v1)"], ["proof (state)\nthis:\n  SubRel.subpath g v1 [] v2 subs\n  e \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>v1.\n       \\<lbrakk>SubRel.subpath g v1 [] v2 subs; e \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            [] = es' @ [e] \\<and> e \\<notin> set es'\n 2. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>SubRel.subpath g v1 es v2 subs;\n                    e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        SubRel.subpath g v1 (a # es) v2 subs; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.subpath g v1 [] v2 subs\n  e \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>es'. [] = es' @ [e] \\<and> e \\<notin> set es'", "by simp"], ["proof (state)\nthis:\n  \\<exists>es'. [] = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>SubRel.subpath g v1 es v2 subs;\n                    e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        SubRel.subpath g v1 (a # es) v2 subs; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>SubRel.subpath g v1 es v2 subs;\n                    e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        SubRel.subpath g v1 (a # es) v2 subs; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "case (Cons e' es v1)"], ["proof (state)\nthis:\n  \\<lbrakk>SubRel.subpath g ?v1.0 es v2 subs; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n  SubRel.subpath g v1 (e' # es) v2 subs\n  e \\<in> set (e' # es)\n\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>SubRel.subpath g v1 es v2 subs;\n                    e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        SubRel.subpath g v1 (a # es) v2 subs; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "hence \"subpath g (tgt e') es v2 subs\" \n  and  \"e = e' \\<or> (e \\<noteq> e' \\<and> e \\<in> set es)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>SubRel.subpath g ?v1.0 es v2 subs; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n  SubRel.subpath g v1 (e' # es) v2 subs\n  e \\<in> set (e' # es)\n\ngoal (1 subgoal):\n 1. SubRel.subpath g (tgt e') es v2 subs &&&\n    e = e' \\<or> e \\<noteq> e' \\<and> e \\<in> set es", "by (auto simp add : sp_Cons)"], ["proof (state)\nthis:\n  SubRel.subpath g (tgt e') es v2 subs\n  e = e' \\<or> e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<And>a es v1.\n       \\<lbrakk>\\<And>v1.\n                   \\<lbrakk>SubRel.subpath g v1 es v2 subs;\n                    e \\<in> set es\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>es'.\n  es = es' @ [e] \\<and> e \\<notin> set es';\n        SubRel.subpath g v1 (a # es) v2 subs; e \\<in> set (a # es)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es'.\n                            a # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.subpath g (tgt e') es v2 subs\n  e = e' \\<or> e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "proof (elim disjE, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs; e = e'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'\n 2. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs;\n     e \\<noteq> e' \\<and> e \\<in> set es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'", "case 1"], ["proof (state)\nthis:\n  SubRel.subpath g (tgt e') es v2 subs\n  e = e'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs; e = e'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'\n 2. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs;\n     e \\<noteq> e' \\<and> e \\<in> set es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.subpath g (tgt e') es v2 subs\n  e = e'\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "using sp_from_de_empty[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  SubRel.subpath g (tgt e') es v2 subs\n  e = e'\n  SubRel.subpath g (tgt e) ?es ?v2.0 subs \\<Longrightarrow> ?es = []\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs;\n     e \\<noteq> e' \\<and> e \\<in> set es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs;\n     e \\<noteq> e' \\<and> e \\<in> set es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'", "case 2"], ["proof (state)\nthis:\n  SubRel.subpath g (tgt e') es v2 subs\n  e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs;\n     e \\<noteq> e' \\<and> e \\<in> set es\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es'.\n                         e' # es = es' @ [e] \\<and> e \\<notin> set es'", "thus ?case"], ["proof (prove)\nusing this:\n  SubRel.subpath g (tgt e') es v2 subs\n  e \\<noteq> e' \\<and> e \\<in> set es\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "using Cons(1)[of \"tgt e'\"]"], ["proof (prove)\nusing this:\n  SubRel.subpath g (tgt e') es v2 subs\n  e \\<noteq> e' \\<and> e \\<in> set es\n  \\<lbrakk>SubRel.subpath g (tgt e') es v2 subs; e \\<in> set es\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es'. es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal (1 subgoal):\n 1. \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'", "by force"], ["proof (state)\nthis:\n  \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>es'. e' # es = es' @ [e] \\<and> e \\<notin> set es'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Consider a sub-path ending at the target of a recently added edge @{term \"e\"}, whose target \ndid not belong to the graph prior to its addition. If @{term \"es\"} starts in another vertex than \nthe target of @{term \"e\"}, then it contains @{term \"e\"}.\\<close>"], ["", "lemma (in sub_rel_of) sp_ends_in_tgt_imp_mem :\n  assumes \"tgt e \\<notin> Graph.vertices g\"\n  assumes \"v \\<noteq> tgt e\"\n  assumes \"subpath (add_edge g e) v es (tgt e) subs\"\n  shows   \"e \\<in> set es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> set es", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<in> set es", "have \"tgt e \\<notin> subsumers subs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tgt e \\<notin> subsumers subs", "using assms(1) sub_rel_of"], ["proof (prove)\nusing this:\n  tgt e \\<notin> Graph.vertices g\n  SubRel.vertices subs \\<subseteq> Graph.vertices g\n\ngoal (1 subgoal):\n 1. tgt e \\<notin> subsumers subs", "by auto"], ["proof (state)\nthis:\n  tgt e \\<notin> subsumers subs\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "hence \"(v,tgt e) \\<notin> subs\\<^sup>+\""], ["proof (prove)\nusing this:\n  tgt e \\<notin> subsumers subs\n\ngoal (1 subgoal):\n 1. (v, tgt e) \\<notin> subs\\<^sup>+", "using tranclD2"], ["proof (prove)\nusing this:\n  tgt e \\<notin> subsumers subs\n  (?x, ?y) \\<in> ?R\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> ?R\\<^sup>* \\<and> (z, ?y) \\<in> ?R\n\ngoal (1 subgoal):\n 1. (v, tgt e) \\<notin> subs\\<^sup>+", "by force"], ["proof (state)\nthis:\n  (v, tgt e) \\<notin> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "hence \"es \\<noteq> []\""], ["proof (prove)\nusing this:\n  (v, tgt e) \\<notin> subs\\<^sup>+\n\ngoal (1 subgoal):\n 1. es \\<noteq> []", "using assms(2,3)"], ["proof (prove)\nusing this:\n  (v, tgt e) \\<notin> subs\\<^sup>+\n  v \\<noteq> tgt e\n  SubRel.subpath (add_edge g e) v es (tgt e) subs\n\ngoal (1 subgoal):\n 1. es \\<noteq> []", "by (auto simp add : Nil_sp)"], ["proof (state)\nthis:\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "then"], ["proof (chain)\npicking this:\n  es \\<noteq> []", "obtain es' e' where \"es = es' @ [e']\""], ["proof (prove)\nusing this:\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>es' e'.\n        es = es' @ [e'] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add : neq_Nil_conv2) blast"], ["proof (state)\nthis:\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "moreover"], ["proof (state)\nthis:\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "hence \"e' \\<in> edges (add_edge g e)\""], ["proof (prove)\nusing this:\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. e' \\<in> edges (add_edge g e)", "using assms(3)"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  SubRel.subpath (add_edge g e) v es (tgt e) subs\n\ngoal (1 subgoal):\n 1. e' \\<in> edges (add_edge g e)", "by (auto simp add: subpath_def)"], ["proof (state)\nthis:\n  e' \\<in> edges (add_edge g e)\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "moreover"], ["proof (state)\nthis:\n  e' \\<in> edges (add_edge g e)\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "have \"tgt e' = tgt e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tgt e' = tgt e", "using tranclD2 assms(3) \\<open>tgt e \\<notin> subsumers subs\\<close> \\<open>es = es' @ [e']\\<close>"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> ?R\\<^sup>+ \\<Longrightarrow>\n  \\<exists>z. (?x, z) \\<in> ?R\\<^sup>* \\<and> (z, ?y) \\<in> ?R\n  SubRel.subpath (add_edge g e) v es (tgt e) subs\n  tgt e \\<notin> subsumers subs\n  es = es' @ [e']\n\ngoal (1 subgoal):\n 1. tgt e' = tgt e", "by (force simp add : sp_append_one)"], ["proof (state)\nthis:\n  tgt e' = tgt e\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "ultimately"], ["proof (chain)\npicking this:\n  es = es' @ [e']\n  e' \\<in> edges (add_edge g e)\n  tgt e' = tgt e", "show ?thesis"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  e' \\<in> edges (add_edge g e)\n  tgt e' = tgt e\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "using assms(1)"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  e' \\<in> edges (add_edge g e)\n  tgt e' = tgt e\n  tgt e \\<notin> Graph.vertices g\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "unfolding vertices_def image_def"], ["proof (prove)\nusing this:\n  es = es' @ [e']\n  e' \\<in> edges (add_edge g e)\n  tgt e' = tgt e\n  tgt e\n  \\<notin> {root g} \\<union> {y. \\<exists>x\\<in>edges g. y = src x} \\<union>\n           {y. \\<exists>x\\<in>edges g. y = tgt x}\n\ngoal (1 subgoal):\n 1. e \\<in> set es", "by force"], ["proof (state)\nthis:\n  e \\<in> set es\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}