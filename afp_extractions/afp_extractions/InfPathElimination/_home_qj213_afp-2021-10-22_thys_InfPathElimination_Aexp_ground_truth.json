{"file_name": "/home/qj213/afp-2021-10-22/thys/InfPathElimination/Aexp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InfPathElimination", "problem_names": ["lemma\n  \"\\<not> finite (UNIV::'v symvar set)\"", "lemma vars_example_1 :\n  fixes e::\"('v,integer) aexp\"\n  assumes \"e = (\\<lambda> \\<sigma>. \\<sigma> x - \\<sigma> y)\"\n  assumes \"x \\<noteq> y\"\n  shows   \"vars e = {x,y}\"", "lemma vars_example_2 :\n  fixes e::\"('v,integer) aexp\"\n  assumes \"e = (\\<lambda> \\<sigma>. \\<sigma> x - \\<sigma> y)\"\n  assumes \"x = y\"\n  shows   \"vars e = {}\""], "translations": [["", "lemma\n  \"\\<not> finite (UNIV::'v symvar set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by (simp add : finite_prod)"], ["", "text \\<open>The previous lemma has no name and thus cannot be referenced in the following. Indeed, it is \nof no use for proving the properties we are interested in. In the following, we will give other\nunnamed lemmas when we think they might help the reader to understand the ideas behind our modeling \nchoices.\\<close>"], ["", "paragraph \\<open>Domain of variables.\\<close>"], ["", "text \\<open>We call @{term \"D\"} the domain of program and symbolic variables. In the following, we \nsuppose that @{term \"D\"} is the set of integers.\\<close>"], ["", "subsection\\<open>Program and symbolic states\\<close>"], ["", "text \\<open>A state is a total function giving values in @{term \"D\"} to variables. The latter are \nrepresented by elements of type \\<open>'v\\<close>. Unlike in the \\<open>'v symvar\\<close> type-synonym, here \nthe type \\<open>'v\\<close> can stand for program variables as well as symbolic variables. States over \nprogram variables are called \\emph{program states}, and states over symbolic variables are called \n\\emph{symbolic states}.\\<close>"], ["", "type_synonym ('v,'d) state = \"'v \\<Rightarrow> 'd\""], ["", "subsection\\<open>The \\emph{aexp} type-synonym\\<close>"], ["", "text \\<open>Arithmetic (and boolean, see \\verb?Bexp.thy?) expressions are represented by their \nsemantics, i.e.\\ \ntotal functions giving values in @{term \"D\"} to states. This way of representing expressions has \nthe benefit that it is not necessary to define the syntax of terms (and formulae) appearing \nin program statements and path predicates.\\<close>"], ["", "type_synonym ('v,'d) aexp =  \"('v,'d) state \\<Rightarrow> 'd\""], ["", "text \\<open>In order to represent expressions over program variables as well as symbolic variables, \nthe type synonym @{type \"aexp\"} is parameterized by the type of variables. Arithmetic and boolean \nexpressions over program variables are used to express program statements. Arithmetic and boolean \nexpressions over symbolic variables are used to represent the constraints occurring in path \npredicates during symbolic execution.\\<close>"], ["", "subsection\\<open>Variables of an arithmetic expression\\<close>"], ["", "text\\<open>Expressions being represented by total functions, one can not say that a given variable is \noccurring in a given expression. We define the set of variables of an expression as the set of \nvariables that can actually have an influence on the value associated by an expression to a state. \nFor example, the set of variables of the expression @{term \"\\<lambda> \\<sigma>. \\<sigma> x - \\<sigma> y\"} is @{term \"{x,y}\"}, \nprovided that @{term \"x\"} and @{term \"y\"} are distinct variables, and the empty set otherwise. In \nthe second case, this expression would evaluate to $0$ for any state @{term\n\"\\<sigma>\"}. Similarly, an expression like\n @{term \"\\<lambda> \\<sigma>.  \\<sigma> x * (0::nat)\"} is considered as having no\n variable as if a static evaluation of the multiplication had occurred.\n\\<close>"], ["", "definition vars :: \n  \"('v,'d) aexp \\<Rightarrow> 'v set\" \nwhere\n  \"vars e = {v. \\<exists> \\<sigma> val. e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>}\""], ["", "lemma vars_example_1 :\n  fixes e::\"('v,integer) aexp\"\n  assumes \"e = (\\<lambda> \\<sigma>. \\<sigma> x - \\<sigma> y)\"\n  assumes \"x \\<noteq> y\"\n  shows   \"vars e = {x,y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars e = {x, y}", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa. (xa \\<in> vars e) = (xa \\<in> {x, y})", "proof (intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> vars e \\<Longrightarrow> xa \\<in> {x, y}\n 2. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> vars e \\<Longrightarrow> xa \\<in> {x, y}\n 2. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "assume \"v \\<in> vars e\""], ["proof (state)\nthis:\n  v \\<in> vars e\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> vars e \\<Longrightarrow> xa \\<in> {x, y}\n 2. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "then"], ["proof (chain)\npicking this:\n  v \\<in> vars e", "obtain \\<sigma> val \n  where \"e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\""], ["proof (prove)\nusing this:\n  v \\<in> vars e\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding vars_def"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>\\<sigma> val.\n                 e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> val.\n        e (\\<sigma>(v := val)) \\<noteq> e \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> vars e \\<Longrightarrow> xa \\<in> {x, y}\n 2. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "thus \"v \\<in> {x, y}\""], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<in> {x, y}", "using assms"], ["proof (prove)\nusing this:\n  e (\\<sigma>(v := val)) \\<noteq> e \\<sigma>\n  e = (\\<lambda>\\<sigma>. \\<sigma> x - \\<sigma> y)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. v \\<in> {x, y}", "by (case_tac \"v = x\", simp, (case_tac \"v = y\", simp+))"], ["proof (state)\nthis:\n  v \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "assume \"v \\<in> {x,y}\""], ["proof (state)\nthis:\n  v \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> {x, y} \\<Longrightarrow> xa \\<in> vars e", "thus \"v \\<in> vars e\""], ["proof (prove)\nusing this:\n  v \\<in> {x, y}\n\ngoal (1 subgoal):\n 1. v \\<in> vars e", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> {x, y}\n  e = (\\<lambda>\\<sigma>. \\<sigma> x - \\<sigma> y)\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. v \\<in> vars e", "by (auto simp add : vars_def) \n     (rule_tac ?x=\"\\<lambda> v. 0\" in exI, rule_tac ?x=\"1\" in exI, simp)+"], ["proof (state)\nthis:\n  v \\<in> vars e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_example_2 :\n  fixes e::\"('v,integer) aexp\"\n  assumes \"e = (\\<lambda> \\<sigma>. \\<sigma> x - \\<sigma> y)\"\n  assumes \"x = y\"\n  shows   \"vars e = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars e = {}", "using assms"], ["proof (prove)\nusing this:\n  e = (\\<lambda>\\<sigma>. \\<sigma> x - \\<sigma> y)\n  x = y\n\ngoal (1 subgoal):\n 1. vars e = {}", "by (auto simp add : vars_def)"], ["", "subsection\\<open>Fresh variables\\<close>"], ["", "text \\<open>Our notion of symbolic execution suppose \\emph{static single assignment \nform}. In order to symbolically execute an assignment, we require the existence of a fresh \nsymbolic variable for the configuration from which symbolic execution is performed. We define here \nthe notion of \\emph{freshness} of a variable for an arithmetic expression.\\<close>"], ["", "text \\<open>A variable is fresh for an expression if does not belong to its set of variables.\\<close>"], ["", "abbreviation fresh ::\n  \"'v \\<Rightarrow> ('v,'d) aexp \\<Rightarrow> bool\" \nwhere\n  \"fresh v e \\<equiv> v \\<notin> vars e\""], ["", "end"]]}