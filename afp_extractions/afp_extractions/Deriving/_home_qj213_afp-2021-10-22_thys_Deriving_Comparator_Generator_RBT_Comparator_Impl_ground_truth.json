{"file_name": "/home/qj213/afp-2021-10-22/thys/Deriving/Comparator_Generator/RBT_Comparator_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deriving", "problem_names": ["lemma rbt_comp_lookup: \"rbt_comp_lookup = ord.rbt_lookup (lt_of_comp c)\"", "lemma rbt_comp_ins: \"rbt_comp_ins = ord.rbt_ins (lt_of_comp c)\"", "lemma rbt_comp_insert_with_key: \"rbt_comp_insert_with_key = ord.rbt_insert_with_key (lt_of_comp c)\"", "lemma rbt_comp_insert: \"rbt_comp_insert = ord.rbt_insert (lt_of_comp c)\"", "lemma rbt_comp_del: \"rbt_comp_del = ord.rbt_del (lt_of_comp c)\"", "lemma rbt_comp_delete: \"rbt_comp_delete = ord.rbt_delete (lt_of_comp c)\"", "lemma rbt_comp_bulkload: \"rbt_comp_bulkload = ord.rbt_bulkload (lt_of_comp c)\"", "lemma rbt_comp_map_entry: \"rbt_comp_map_entry = ord.rbt_map_entry (lt_of_comp c)\"", "lemma comp_sunion_with: \"comp_sunion_with = ord.sunion_with (lt_of_comp c)\"", "lemma comp_sinter_with: \"comp_sinter_with = ord.sinter_with (lt_of_comp c)\"", "lemma rbt_comp_union_with_key: \"rbt_comp_union_with_key = ord.rbt_union_with_key (lt_of_comp c)\"", "lemma rbt_comp_inter_with_key: \"rbt_comp_inter_with_key = ord.rbt_inter_with_key (lt_of_comp c)\"", "lemmas rbt_comp_simps = \n  rbt_comp_insert\n  rbt_comp_lookup\n  rbt_comp_delete\n  rbt_comp_bulkload\n  rbt_comp_map_entry\n  rbt_comp_union_with_key\n  rbt_comp_inter_with_key"], "translations": [["", "lemma rbt_comp_lookup: \"rbt_comp_lookup = ord.rbt_lookup (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_lookup = ord.rbt_lookup (lt_of_comp c)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.rbt_comp_lookup x xa = ord.rbt_lookup (lt_of_comp c) x xa", "fix k and t :: \"('a,'b)rbt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       local.rbt_comp_lookup x xa = ord.rbt_lookup (lt_of_comp c) x xa", "show \"rbt_comp_lookup t k = ord.rbt_lookup (lt_of_comp c) t k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_lookup t k = ord.rbt_lookup (lt_of_comp c) t k", "by (induct t, unfold rbt_comp_lookup.simps ord.rbt_lookup.simps\n      comparator.two_comparisons_into_case_order[OF c]) \n      (auto split: order.splits)"], ["proof (state)\nthis:\n  local.rbt_comp_lookup t k = ord.rbt_lookup (lt_of_comp c) t k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rbt_comp_ins: \"rbt_comp_ins = ord.rbt_ins (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_ins = ord.rbt_ins (lt_of_comp c)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       local.rbt_comp_ins x xa xb xc = ord.rbt_ins (lt_of_comp c) x xa xb xc", "fix f k v and t :: \"('a,'b)rbt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc.\n       local.rbt_comp_ins x xa xb xc = ord.rbt_ins (lt_of_comp c) x xa xb xc", "show \"rbt_comp_ins f k v t = ord.rbt_ins (lt_of_comp c) f k v t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_ins f k v t = ord.rbt_ins (lt_of_comp c) f k v t", "by (induct f k v t rule: rbt_comp_ins.induct, unfold rbt_comp_ins.simps ord.rbt_ins.simps\n      comparator.two_comparisons_into_case_order[OF c]) \n      (auto split: order.splits)"], ["proof (state)\nthis:\n  local.rbt_comp_ins f k v t = ord.rbt_ins (lt_of_comp c) f k v t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rbt_comp_insert_with_key: \"rbt_comp_insert_with_key = ord.rbt_insert_with_key (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_insert_with_key = ord.rbt_insert_with_key (lt_of_comp c)", "unfolding rbt_comp_insert_with_key_def[abs_def] ord.rbt_insert_with_key_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f k v t. paint color.B (local.rbt_comp_ins f k v t)) =\n    (\\<lambda>f k v t. paint color.B (ord.rbt_ins (lt_of_comp c) f k v t))", "unfolding rbt_comp_ins"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f k v t. paint color.B (ord.rbt_ins (lt_of_comp c) f k v t)) =\n    (\\<lambda>f k v t. paint color.B (ord.rbt_ins (lt_of_comp c) f k v t))", ".."], ["", "lemma rbt_comp_insert: \"rbt_comp_insert = ord.rbt_insert (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_insert = ord.rbt_insert (lt_of_comp c)", "unfolding rbt_comp_insert_def[abs_def] ord.rbt_insert_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_insert_with_key (\\<lambda>_ _ nv. nv) =\n    ord.rbt_insert_with_key (lt_of_comp c) (\\<lambda>_ _ nv. nv)", "unfolding rbt_comp_insert_with_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord.rbt_insert_with_key (lt_of_comp c) (\\<lambda>_ _ nv. nv) =\n    ord.rbt_insert_with_key (lt_of_comp c) (\\<lambda>_ _ nv. nv)", ".."], ["", "lemma rbt_comp_del: \"rbt_comp_del = ord.rbt_del (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "fix k a b and s t :: \"('a,'b)rbt\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "have \n    \"rbt_comp_del_from_left k t a b s = ord.rbt_del_from_left (lt_of_comp c) k t a b s\"\n    \"rbt_comp_del_from_right k t a b s = ord.rbt_del_from_right (lt_of_comp c) k t a b s\"\n    \"rbt_comp_del k t = ord.rbt_del (lt_of_comp c) k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_del_from_left k t a b s =\n    ord.rbt_del_from_left (lt_of_comp c) k t a b s &&&\n    local.rbt_comp_del_from_right k t a b s =\n    ord.rbt_del_from_right (lt_of_comp c) k t a b s &&&\n    local.rbt_comp_del k t = ord.rbt_del (lt_of_comp c) k t", "by (induct k t a b s and k t a b s and k t rule: rbt_comp_del_from_left_rbt_comp_del_from_right_rbt_comp_del.induct,\n    unfold \n      rbt_comp_del.simps ord.rbt_del.simps\n      rbt_comp_del_from_left.simps ord.rbt_del_from_left.simps\n      rbt_comp_del_from_right.simps ord.rbt_del_from_right.simps\n      comparator.two_comparisons_into_case_order[OF c],\n    auto split: order.split)"], ["proof (state)\nthis:\n  local.rbt_comp_del_from_left k t a b s =\n  ord.rbt_del_from_left (lt_of_comp c) k t a b s\n  local.rbt_comp_del_from_right k t a b s =\n  ord.rbt_del_from_right (lt_of_comp c) k t a b s\n  local.rbt_comp_del k t = ord.rbt_del (lt_of_comp c) k t\n\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "}"], ["proof (state)\nthis:\n  local.rbt_comp_del_from_left ?k32 ?t32 ?a32 ?b32 ?s32 =\n  ord.rbt_del_from_left (lt_of_comp c) ?k32 ?t32 ?a32 ?b32 ?s32\n  local.rbt_comp_del_from_right ?k32 ?t32 ?a32 ?b32 ?s32 =\n  ord.rbt_del_from_right (lt_of_comp c) ?k32 ?t32 ?a32 ?b32 ?s32\n  local.rbt_comp_del ?k32 ?t32 = ord.rbt_del (lt_of_comp c) ?k32 ?t32\n\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.rbt_comp_del_from_left ?k32 ?t32 ?a32 ?b32 ?s32 =\n  ord.rbt_del_from_left (lt_of_comp c) ?k32 ?t32 ?a32 ?b32 ?s32\n  local.rbt_comp_del_from_right ?k32 ?t32 ?a32 ?b32 ?s32 =\n  ord.rbt_del_from_right (lt_of_comp c) ?k32 ?t32 ?a32 ?b32 ?s32\n  local.rbt_comp_del ?k32 ?t32 = ord.rbt_del (lt_of_comp c) ?k32 ?t32\n\ngoal (1 subgoal):\n 1. local.rbt_comp_del = ord.rbt_del (lt_of_comp c)", "by (intro ext)"], ["proof (state)\nthis:\n  local.rbt_comp_del = ord.rbt_del (lt_of_comp c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rbt_comp_delete: \"rbt_comp_delete = ord.rbt_delete (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_delete = ord.rbt_delete (lt_of_comp c)", "unfolding rbt_comp_delete_def[abs_def] ord.rbt_delete_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k t. paint color.B (local.rbt_comp_del k t)) =\n    (\\<lambda>k t. paint color.B (ord.rbt_del (lt_of_comp c) k t))", "unfolding rbt_comp_del"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k t. paint color.B (ord.rbt_del (lt_of_comp c) k t)) =\n    (\\<lambda>k t. paint color.B (ord.rbt_del (lt_of_comp c) k t))", ".."], ["", "lemma rbt_comp_bulkload: \"rbt_comp_bulkload = ord.rbt_bulkload (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_bulkload = ord.rbt_bulkload (lt_of_comp c)", "unfolding rbt_comp_bulkload_def[abs_def] ord.rbt_bulkload_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        foldr (\\<lambda>(x, y). local.rbt_comp_insert x y) xs rbt.Empty) =\n    (\\<lambda>xs.\n        foldr (\\<lambda>(x, y). ord.rbt_insert (lt_of_comp c) x y) xs\n         rbt.Empty)", "unfolding rbt_comp_insert"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs.\n        foldr (\\<lambda>(x, y). ord.rbt_insert (lt_of_comp c) x y) xs\n         rbt.Empty) =\n    (\\<lambda>xs.\n        foldr (\\<lambda>(x, y). ord.rbt_insert (lt_of_comp c) x y) xs\n         rbt.Empty)", ".."], ["", "lemma rbt_comp_map_entry: \"rbt_comp_map_entry = ord.rbt_map_entry (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_map_entry = ord.rbt_map_entry (lt_of_comp c)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       local.rbt_comp_map_entry x xa xb =\n       ord.rbt_map_entry (lt_of_comp c) x xa xb", "fix f k and t :: \"('a,'b)rbt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       local.rbt_comp_map_entry x xa xb =\n       ord.rbt_map_entry (lt_of_comp c) x xa xb", "show \"rbt_comp_map_entry f k t = ord.rbt_map_entry (lt_of_comp c) f k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_map_entry f k t = ord.rbt_map_entry (lt_of_comp c) f k t", "by (induct t, unfold rbt_comp_map_entry.simps ord.rbt_map_entry.simps\n      comparator.two_comparisons_into_case_order[OF c]) \n      (auto split: order.splits)"], ["proof (state)\nthis:\n  local.rbt_comp_map_entry f k t = ord.rbt_map_entry (lt_of_comp c) f k t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_sunion_with: \"comp_sunion_with = ord.sunion_with (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp_sunion_with = ord.sunion_with (lt_of_comp c)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       local.comp_sunion_with x xa xb =\n       ord.sunion_with (lt_of_comp c) x xa xb", "fix f and as bs :: \"('a \\<times> 'b)list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       local.comp_sunion_with x xa xb =\n       ord.sunion_with (lt_of_comp c) x xa xb", "show \"comp_sunion_with f as bs = ord.sunion_with (lt_of_comp c) f as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp_sunion_with f as bs = ord.sunion_with (lt_of_comp c) f as bs", "by (induct f as bs rule: comp_sunion_with.induct,\n      unfold comp_sunion_with.simps ord.sunion_with.simps\n      comparator.two_comparisons_into_case_order[OF c]) \n      (auto split: order.splits)"], ["proof (state)\nthis:\n  local.comp_sunion_with f as bs = ord.sunion_with (lt_of_comp c) f as bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_sinter_with: \"comp_sinter_with = ord.sinter_with (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp_sinter_with = ord.sinter_with (lt_of_comp c)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       local.comp_sinter_with x xa xb =\n       ord.sinter_with (lt_of_comp c) x xa xb", "fix f and as bs :: \"('a \\<times> 'b)list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       local.comp_sinter_with x xa xb =\n       ord.sinter_with (lt_of_comp c) x xa xb", "show \"comp_sinter_with f as bs = ord.sinter_with (lt_of_comp c) f as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp_sinter_with f as bs = ord.sinter_with (lt_of_comp c) f as bs", "by (induct f as bs rule: comp_sinter_with.induct,\n      unfold comp_sinter_with.simps ord.sinter_with.simps\n      comparator.two_comparisons_into_case_order[OF c]) \n      (auto split: order.splits)"], ["proof (state)\nthis:\n  local.comp_sinter_with f as bs = ord.sinter_with (lt_of_comp c) f as bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rbt_comp_union_with_key: \"rbt_comp_union_with_key = ord.rbt_union_with_key (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_union_with_key = ord.rbt_union_with_key (lt_of_comp c)", "unfolding rbt_comp_union_with_key_def[abs_def] ord.rbt_union_with_key_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          RBT_Impl.fold\n           (local.rbt_comp_insert_with_key (\\<lambda>k v w. f k w v)) t1 t2\n        | compare.GT \\<Rightarrow>\n            RBT_Impl.fold (local.rbt_comp_insert_with_key f) t2 t1\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (local.comp_sunion_with f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2))) =\n    (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          RBT_Impl.fold\n           (ord.rbt_insert_with_key (lt_of_comp c)\n             (\\<lambda>k v w. f k w v))\n           t1 t2\n        | compare.GT \\<Rightarrow>\n            RBT_Impl.fold (ord.rbt_insert_with_key (lt_of_comp c) f) t2 t1\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (ord.sunion_with (lt_of_comp c) f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2)))", "unfolding rbt_comp_insert_with_key comp_sunion_with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          RBT_Impl.fold\n           (ord.rbt_insert_with_key (lt_of_comp c)\n             (\\<lambda>k v w. f k w v))\n           t1 t2\n        | compare.GT \\<Rightarrow>\n            RBT_Impl.fold (ord.rbt_insert_with_key (lt_of_comp c) f) t2 t1\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (ord.sunion_with (lt_of_comp c) f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2))) =\n    (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          RBT_Impl.fold\n           (ord.rbt_insert_with_key (lt_of_comp c)\n             (\\<lambda>k v w. f k w v))\n           t1 t2\n        | compare.GT \\<Rightarrow>\n            RBT_Impl.fold (ord.rbt_insert_with_key (lt_of_comp c) f) t2 t1\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (ord.sunion_with (lt_of_comp c) f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2)))", ".."], ["", "lemma rbt_comp_inter_with_key: \"rbt_comp_inter_with_key = ord.rbt_inter_with_key (lt_of_comp c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rbt_comp_inter_with_key = ord.rbt_inter_with_key (lt_of_comp c)", "unfolding rbt_comp_inter_with_key_def[abs_def] ord.rbt_inter_with_key_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          rbtreeify\n           (List.map_filter\n             (\\<lambda>(k, v).\n                 map_option (\\<lambda>w. (k, f k v w))\n                  (local.rbt_comp_lookup t2 k))\n             (RBT_Impl.entries t1))\n        | compare.GT \\<Rightarrow>\n            rbtreeify\n             (List.map_filter\n               (\\<lambda>(k, v).\n                   map_option (\\<lambda>w. (k, f k w v))\n                    (local.rbt_comp_lookup t1 k))\n               (RBT_Impl.entries t2))\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (local.comp_sinter_with f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2))) =\n    (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          rbtreeify\n           (List.map_filter\n             (\\<lambda>(k, v).\n                 map_option (\\<lambda>w. (k, f k v w))\n                  (ord.rbt_lookup (lt_of_comp c) t2 k))\n             (RBT_Impl.entries t1))\n        | compare.GT \\<Rightarrow>\n            rbtreeify\n             (List.map_filter\n               (\\<lambda>(k, v).\n                   map_option (\\<lambda>w. (k, f k w v))\n                    (ord.rbt_lookup (lt_of_comp c) t1 k))\n               (RBT_Impl.entries t2))\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (ord.sinter_with (lt_of_comp c) f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2)))", "unfolding rbt_comp_insert_with_key comp_sinter_with rbt_comp_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          rbtreeify\n           (List.map_filter\n             (\\<lambda>(k, v).\n                 map_option (\\<lambda>w. (k, f k v w))\n                  (ord.rbt_lookup (lt_of_comp c) t2 k))\n             (RBT_Impl.entries t1))\n        | compare.GT \\<Rightarrow>\n            rbtreeify\n             (List.map_filter\n               (\\<lambda>(k, v).\n                   map_option (\\<lambda>w. (k, f k w v))\n                    (ord.rbt_lookup (lt_of_comp c) t1 k))\n               (RBT_Impl.entries t2))\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (ord.sinter_with (lt_of_comp c) f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2))) =\n    (\\<lambda>f t1 t2.\n        case RBT_Impl.compare_height t1 t1 t2 t2 of\n        compare.LT \\<Rightarrow>\n          rbtreeify\n           (List.map_filter\n             (\\<lambda>(k, v).\n                 map_option (\\<lambda>w. (k, f k v w))\n                  (ord.rbt_lookup (lt_of_comp c) t2 k))\n             (RBT_Impl.entries t1))\n        | compare.GT \\<Rightarrow>\n            rbtreeify\n             (List.map_filter\n               (\\<lambda>(k, v).\n                   map_option (\\<lambda>w. (k, f k w v))\n                    (ord.rbt_lookup (lt_of_comp c) t1 k))\n               (RBT_Impl.entries t2))\n        | compare.EQ \\<Rightarrow>\n            rbtreeify\n             (ord.sinter_with (lt_of_comp c) f (RBT_Impl.entries t1)\n               (RBT_Impl.entries t2)))", ".."], ["", "lemmas rbt_comp_simps = \n  rbt_comp_insert\n  rbt_comp_lookup\n  rbt_comp_delete\n  rbt_comp_bulkload\n  rbt_comp_map_entry\n  rbt_comp_union_with_key\n  rbt_comp_inter_with_key"], ["", "end"], ["", "end"], ["", "end"]]}