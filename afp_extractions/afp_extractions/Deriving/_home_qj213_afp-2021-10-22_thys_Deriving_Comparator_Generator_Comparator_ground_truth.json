{"file_name": "/home/qj213/afp-2021-10-22/thys/Deriving/Comparator_Generator/Comparator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deriving", "problem_names": ["lemma comp_of_ords_of_le_lt[simp]: \"comp_of_ords (le_of_comp c) (lt_of_comp c) = c\"", "lemma lt_of_comp_of_ords: \"lt_of_comp (comp_of_ords le lt) = lt\"", "lemma le_of_comp_of_ords_gen: \"(\\<And> x y. lt x y \\<Longrightarrow> le x y) \\<Longrightarrow> le_of_comp (comp_of_ords le lt) = le\"", "lemma le_of_comp_of_ords_linorder: assumes \"class.linorder le lt\"\n  shows \"le_of_comp (comp_of_ords le lt) = le\"", "lemma eq: \"(comp x y = Eq) = (x = y)\"", "lemma comp_same [simp]:\n  \"comp x x = Eq\"", "lemma linorder: \"class.linorder le lt\"", "lemma Gt_lt_conv: \"comp x y = Gt \\<longleftrightarrow> lt y x\"", "lemma Lt_lt_conv: \"comp x y = Lt \\<longleftrightarrow> lt x y\"", "lemma eq_Eq_conv: \"comp x y = Eq \\<longleftrightarrow> x = y\"", "lemma nGt_le_conv: \"comp x y \\<noteq> Gt \\<longleftrightarrow> le x y\"", "lemma nLt_le_conv: \"comp x y \\<noteq> Lt \\<longleftrightarrow> le y x\"", "lemma nEq_neq_conv: \"comp x y \\<noteq> Eq \\<longleftrightarrow> x \\<noteq> y\"", "lemmas le_lt_convs =  nLt_le_conv nGt_le_conv Gt_lt_conv Lt_lt_conv eq_Eq_conv nEq_neq_conv", "lemma two_comparisons_into_case_order: \n  \"(if le x y then (if x = y then P else Q) else R) = (case_order P Q R (comp x y))\" \n  \"(if le x y then (if y = x then P else Q) else R) = (case_order P Q R (comp x y))\" \n  \"(if le x y then (if le y x then P else Q) else R) = (case_order P Q R (comp x y))\" \n  \"(if le x y then (if lt x y then Q else P) else R) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if le x y then P else R)) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if lt y x then R else P)) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if x = y then P else R)) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if y = x then P else R)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if lt y x then R else Q)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if lt x y then Q else R)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if le y x then R else Q)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if le x y then Q else R)) = (case_order P Q R (comp x y))\"", "lemma comp_of_ords: assumes \"class.linorder le lt\"\n  shows \"comparator (comp_of_ords le lt)\"", "lemma comparator_of: \"comparator comparator_of\""], "translations": [["", "lemma comp_of_ords_of_le_lt[simp]: \"comp_of_ords (le_of_comp c) (lt_of_comp c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_of_ords (le_of_comp c) (lt_of_comp c) = c", "by (intro ext, auto simp: comp_of_ords_def le_of_comp_def lt_of_comp_def split: order.split)"], ["", "lemma lt_of_comp_of_ords: \"lt_of_comp (comp_of_ords le lt) = lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (comp_of_ords le lt) = lt", "by (intro ext, auto simp: comp_of_ords_def le_of_comp_def lt_of_comp_def split: order.split)"], ["", "lemma le_of_comp_of_ords_gen: \"(\\<And> x y. lt x y \\<Longrightarrow> le x y) \\<Longrightarrow> le_of_comp (comp_of_ords le lt) = le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. lt x y \\<Longrightarrow> le x y) \\<Longrightarrow>\n    le_of_comp (comp_of_ords le lt) = le", "by (intro ext, auto simp: comp_of_ords_def le_of_comp_def lt_of_comp_def split: order.split)"], ["", "lemma le_of_comp_of_ords_linorder: assumes \"class.linorder le lt\"\n  shows \"le_of_comp (comp_of_ords le lt) = le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_comp (comp_of_ords le lt) = le", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. le_of_comp (comp_of_ords le lt) = le", "interpret linorder le lt"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder le lt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. le_of_comp (comp_of_ords le lt) = le", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_comp (comp_of_ords le lt) = le", "by (rule le_of_comp_of_ords_gen) simp"], ["proof (state)\nthis:\n  le_of_comp (comp_of_ords le lt) = le\n\ngoal:\nNo subgoals!", "qed"], ["", "fun invert_order:: \"order \\<Rightarrow> order\" where\n  \"invert_order Lt = Gt\" |\n  \"invert_order Gt = Lt\" |\n  \"invert_order Eq = Eq\""], ["", "locale comparator =\n  fixes comp :: \"'a comparator\"\n  assumes sym: \"invert_order (comp x y) = comp y x\"\n    and weak_eq: \"comp x y = Eq \\<Longrightarrow> x = y\"\n    and trans: \"comp x y = Lt \\<Longrightarrow> comp y z = Lt \\<Longrightarrow> comp x z = Lt\"\nbegin"], ["", "lemma eq: \"(comp x y = Eq) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y = Eq) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. comp x y = Eq \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> comp x y = Eq", "assume \"x = y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. comp x y = Eq \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> comp x y = Eq", "with sym [of y y]"], ["proof (chain)\npicking this:\n  invert_order (comp y y) = comp y y\n  x = y", "show \"comp x y = Eq\""], ["proof (prove)\nusing this:\n  invert_order (comp y y) = comp y y\n  x = y\n\ngoal (1 subgoal):\n 1. comp x y = Eq", "by (cases \"comp x y\") auto"], ["proof (state)\nthis:\n  comp x y = Eq\n\ngoal (1 subgoal):\n 1. comp x y = Eq \\<Longrightarrow> x = y", "qed (rule weak_eq)"], ["", "lemma comp_same [simp]:\n  \"comp x x = Eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp x x = Eq", "by (simp add: eq)"], ["", "abbreviation \"lt \\<equiv> lt_of_comp comp\""], ["", "abbreviation \"le \\<equiv> le_of_comp comp\""], ["", "lemma linorder: \"class.linorder le lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder le lt", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. lt x y = (le x y \\<and> \\<not> le y x)\n 2. \\<And>x. le x x\n 3. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n 4. \\<And>x y. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. le x y \\<or> le y x", "note [simp] = lt_of_comp_def le_of_comp_def"], ["proof (state)\nthis:\n  lt_of_comp ?acomp ?x ?y =\n  (case ?acomp ?x ?y of Lt \\<Rightarrow> True | _ \\<Rightarrow> False)\n  le_of_comp ?acomp ?x ?y =\n  (case ?acomp ?x ?y of Gt \\<Rightarrow> False | _ \\<Rightarrow> True)\n\ngoal (5 subgoals):\n 1. \\<And>x y. lt x y = (le x y \\<and> \\<not> le y x)\n 2. \\<And>x. le x x\n 3. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n 4. \\<And>x y. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. le x y \\<or> le y x", "fix x y z :: 'a"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x y. lt x y = (le x y \\<and> \\<not> le y x)\n 2. \\<And>x. le x x\n 3. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n 4. \\<And>x y. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. le x y \\<or> le y x", "show \"lt x y = (le x y \\<and> \\<not> le y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt x y = (le x y \\<and> \\<not> le y x)", "using sym [of x y]"], ["proof (prove)\nusing this:\n  invert_order (comp x y) = comp y x\n\ngoal (1 subgoal):\n 1. lt x y = (le x y \\<and> \\<not> le y x)", "by (cases \"comp x y\") (simp_all)"], ["proof (state)\nthis:\n  lt x y = (le x y \\<and> \\<not> le y x)\n\ngoal (4 subgoals):\n 1. \\<And>x. le x x\n 2. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n 3. \\<And>x y. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. le x y \\<or> le y x", "show \"le x y \\<or> le y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le x y \\<or> le y x", "using sym [of x y]"], ["proof (prove)\nusing this:\n  invert_order (comp x y) = comp y x\n\ngoal (1 subgoal):\n 1. le x y \\<or> le y x", "by (cases \"comp x y\") (simp_all)"], ["proof (state)\nthis:\n  le x y \\<or> le y x\n\ngoal (3 subgoals):\n 1. \\<And>x. le x x\n 2. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n 3. \\<And>x y. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y", "show \"le x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le x x", "using eq [of x x]"], ["proof (prove)\nusing this:\n  (comp x x = Eq) = (x = x)\n\ngoal (1 subgoal):\n 1. le x x", "by (simp)"], ["proof (state)\nthis:\n  le x x\n\ngoal (2 subgoals):\n 1. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n 2. \\<And>x y. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y", "show \"le x y \\<Longrightarrow> le y x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y", "using sym [of x y]"], ["proof (prove)\nusing this:\n  invert_order (comp x y) = comp y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y", "by (cases \"comp x y\") (simp_all add: eq)"], ["proof (state)\nthis:\n  \\<lbrakk>le x y; le y x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y z. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z", "show \"le x y \\<Longrightarrow> le y z \\<Longrightarrow> le x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z", "by (cases \"comp x y\" \"comp y z\" rule: order.exhaust [case_product order.exhaust])\n       (auto dest: trans simp: eq)"], ["proof (state)\nthis:\n  \\<lbrakk>le x y; le y z\\<rbrakk> \\<Longrightarrow> le x z\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale linorder le lt"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder le lt", "by (rule linorder)"], ["", "lemma Gt_lt_conv: \"comp x y = Gt \\<longleftrightarrow> lt y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y = Gt) = lt y x", "unfolding lt_of_comp_def sym[of x y, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y = Gt) =\n    (case invert_order (comp x y) of Lt \\<Rightarrow> True\n     | _ \\<Rightarrow> False)", "by (cases \"comp x y\", auto)"], ["", "lemma Lt_lt_conv: \"comp x y = Lt \\<longleftrightarrow> lt x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y = Lt) = lt x y", "unfolding lt_of_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y = Lt) =\n    (case comp x y of Lt \\<Rightarrow> True | _ \\<Rightarrow> False)", "by (cases \"comp x y\", auto)"], ["", "lemma eq_Eq_conv: \"comp x y = Eq \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y = Eq) = (x = y)", "by (rule eq)"], ["", "lemma nGt_le_conv: \"comp x y \\<noteq> Gt \\<longleftrightarrow> le x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y \\<noteq> Gt) = le x y", "unfolding le_of_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y \\<noteq> Gt) =\n    (case comp x y of Gt \\<Rightarrow> False | _ \\<Rightarrow> True)", "by (cases \"comp x y\", auto)"], ["", "lemma nLt_le_conv: \"comp x y \\<noteq> Lt \\<longleftrightarrow> le y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y \\<noteq> Lt) = le y x", "unfolding le_of_comp_def sym[of x y, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y \\<noteq> Lt) =\n    (case invert_order (comp x y) of Gt \\<Rightarrow> False\n     | _ \\<Rightarrow> True)", "by (cases \"comp x y\", auto)"], ["", "lemma nEq_neq_conv: \"comp x y \\<noteq> Eq \\<longleftrightarrow> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (comp x y \\<noteq> Eq) = (x \\<noteq> y)", "using eq_Eq_conv[of x y]"], ["proof (prove)\nusing this:\n  (comp x y = Eq) = (x = y)\n\ngoal (1 subgoal):\n 1. (comp x y \\<noteq> Eq) = (x \\<noteq> y)", "by simp"], ["", "lemmas le_lt_convs =  nLt_le_conv nGt_le_conv Gt_lt_conv Lt_lt_conv eq_Eq_conv nEq_neq_conv"], ["", "lemma two_comparisons_into_case_order: \n  \"(if le x y then (if x = y then P else Q) else R) = (case_order P Q R (comp x y))\" \n  \"(if le x y then (if y = x then P else Q) else R) = (case_order P Q R (comp x y))\" \n  \"(if le x y then (if le y x then P else Q) else R) = (case_order P Q R (comp x y))\" \n  \"(if le x y then (if lt x y then Q else P) else R) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if le x y then P else R)) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if lt y x then R else P)) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if x = y then P else R)) = (case_order P Q R (comp x y))\" \n  \"(if lt x y then Q else (if y = x then P else R)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if lt y x then R else Q)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if lt x y then Q else R)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if le y x then R else Q)) = (case_order P Q R (comp x y))\" \n  \"(if x = y then P else (if le x y then Q else R)) = (case_order P Q R (comp x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((if le x y then if x = y then P else Q else R) =\n      (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n       | Gt \\<Rightarrow> R) &&&\n      (if le x y then if y = x then P else Q else R) =\n      (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n       | Gt \\<Rightarrow> R) &&&\n      (if le x y then if le y x then P else Q else R) =\n      (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n       | Gt \\<Rightarrow> R)) &&&\n     (if le x y then if lt x y then Q else P else R) =\n     (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n      | Gt \\<Rightarrow> R) &&&\n     (if lt x y then Q else if le x y then P else R) =\n     (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n      | Gt \\<Rightarrow> R) &&&\n     (if lt x y then Q else if lt y x then R else P) =\n     (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n      | Gt \\<Rightarrow> R)) &&&\n    ((if lt x y then Q else if x = y then P else R) =\n     (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n      | Gt \\<Rightarrow> R) &&&\n     (if lt x y then Q else if y = x then P else R) =\n     (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n      | Gt \\<Rightarrow> R) &&&\n     (if x = y then P else if lt y x then R else Q) =\n     (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n      | Gt \\<Rightarrow> R)) &&&\n    (if x = y then P else if lt x y then Q else R) =\n    (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n     | Gt \\<Rightarrow> R) &&&\n    (if x = y then P else if le y x then R else Q) =\n    (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n     | Gt \\<Rightarrow> R) &&&\n    (if x = y then P else if le x y then Q else R) =\n    (case comp x y of Eq \\<Rightarrow> P | Lt \\<Rightarrow> Q\n     | Gt \\<Rightarrow> R)", "by (auto simp: le_lt_convs split: order.splits)"], ["", "end"], ["", "lemma comp_of_ords: assumes \"class.linorder le lt\"\n  shows \"comparator (comp_of_ords le lt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (comp_of_ords le lt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (comp_of_ords le lt)", "interpret linorder le lt"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder le lt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. comparator (comp_of_ords le lt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (comp_of_ords le lt)", "by (unfold_locales, auto simp: comp_of_ords_def split: if_splits)"], ["proof (state)\nthis:\n  comparator (comp_of_ords le lt)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition (in linorder) comparator_of :: \"'a comparator\" where\n  \"comparator_of x y = (if x < y then Lt else if x = y then Eq else Gt)\""], ["", "lemma comparator_of: \"comparator comparator_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator comparator_of", "by unfold_locales (auto split: if_splits simp: comparator_of_def)"], ["", "end"]]}