{"file_name": "/home/qj213/afp-2021-10-22/thys/Goedel_HFSet_Semanticless/Coding.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Goedel_HFSet_Semanticless", "problem_names": ["lemma fresh_imp_notin_env: \"atom name \\<sharp> e \\<Longrightarrow> name \\<notin> set e\"", "lemma lookup_notin: \"x \\<notin> set e \\<Longrightarrow> lookup e n x = DBVar x\"", "lemma lookup_in:\n  \"x \\<in> set e \\<Longrightarrow> \\<exists>k. lookup e n x = DBInd k \\<and> n \\<le> k \\<and> k < n + length e\"", "lemma lookup_fresh: \"x \\<sharp> lookup e n y \\<longleftrightarrow> y \\<in> set e \\<or> x \\<noteq> atom y\"", "lemma lookup_eqvt[eqvt]: \"(p \\<bullet> lookup xs n x) = lookup (p \\<bullet> xs) (p \\<bullet> n) (p \\<bullet> x)\"", "lemma lookup_inject [iff]: \"(lookup e n x = lookup e n y) \\<longleftrightarrow> x = y\"", "lemma fresh_trans_tm_iff [simp]: \"i \\<sharp> trans_tm e t \\<longleftrightarrow> i \\<sharp> t \\<or> i \\<in> atom ` set e\"", "lemma trans_tm_forget: \"atom i \\<sharp> t \\<Longrightarrow> trans_tm [i] t = trans_tm [] t\"", "lemma fresh_trans_fm [simp]: \"i \\<sharp> trans_fm e A \\<longleftrightarrow> i \\<sharp> A \\<or> i \\<in> atom ` set e\"", "lemma trans_fm_Conj [simp]: \"trans_fm e (Conj A B) = DBConj (trans_fm e A) (trans_fm e B)\"", "lemma trans_tm_inject [iff]: \"(trans_tm e t = trans_tm e u) \\<longleftrightarrow> t = u\"", "lemma trans_fm_inject [iff]: \"(trans_fm e A = trans_fm e B) \\<longleftrightarrow> A = B\"", "lemma trans_fm_perm:\n  assumes c: \"atom c \\<sharp> (i,j,A,B)\"\n  and     t: \"trans_fm [i] A = trans_fm [j] B\"\n  shows \"(i \\<leftrightarrow> c) \\<bullet> A = (j \\<leftrightarrow> c) \\<bullet> B\"", "lemma wf_dbtm_imp_is_tm:\n  assumes \"wf_dbtm x\"\n  shows \"\\<exists>t::tm. x = trans_tm [] t\"", "lemma wf_dbtm_trans_tm: \"wf_dbtm (trans_tm [] t)\"", "theorem wf_dbtm_iff_is_tm: \"wf_dbtm x \\<longleftrightarrow> (\\<exists>t::tm. x = trans_tm [] t)\"", "lemma fresh_iff_non_subst_dbtm: \"subst_dbtm DBZero i t = t \\<longleftrightarrow> atom i \\<sharp> t\"", "lemma lookup_append: \"lookup (e @ [i]) n j = abst_dbtm i (length e + n) (lookup e n j)\"", "lemma trans_tm_abs: \"trans_tm (e@[name]) t = abst_dbtm name (length e) (trans_tm e t)\"", "lemma fresh_iff_non_subst_dbfm: \"subst_dbfm DBZero i t = t \\<longleftrightarrow> atom i \\<sharp> t\"", "lemma atom_fresh_abst_dbtm [simp]: \"atom i \\<sharp> abst_dbtm i n t\"", "lemma atom_fresh_abst_dbfm [simp]: \"atom i \\<sharp> abst_dbfm i n A\"", "lemma trans_fm_abs: \"trans_fm (e@[name]) A = abst_dbfm name (length e) (trans_fm e A)\"", "lemma abst_trans_fm: \"abst_dbfm name 0 (trans_fm [] A) = trans_fm [name] A\"", "lemma abst_trans_fm2: \"i \\<noteq> j \\<Longrightarrow> abst_dbfm i (Suc 0) (trans_fm [j] A) = trans_fm [j,i] A\"", "lemma wf_dbfm_imp_is_fm:\n  assumes \"wf_dbfm x\" shows \"\\<exists>A::fm. x = trans_fm [] A\"", "lemma wf_dbfm_trans_fm: \"wf_dbfm (trans_fm [] A)\"", "lemma wf_dbfm_iff_is_fm: \"wf_dbfm x \\<longleftrightarrow> (\\<exists>A::fm. x = trans_fm [] A)\"", "lemma dbtm_abst_ignore [simp]:\n  \"abst_dbtm name i (abst_dbtm name j t) = abst_dbtm name j t\"", "lemma abst_dbtm_fresh_ignore [simp]: \"atom name \\<sharp> u \\<Longrightarrow> abst_dbtm name j u = u\"", "lemma dbtm_subst_ignore [simp]:\n  \"subst_dbtm u name (abst_dbtm name j t) = abst_dbtm name j t\"", "lemma dbtm_abst_swap_subst:\n  \"name \\<noteq> name' \\<Longrightarrow> atom name' \\<sharp> u \\<Longrightarrow>\n   subst_dbtm u name (abst_dbtm name' j t) = abst_dbtm name' j (subst_dbtm u name t)\"", "lemma dbfm_abst_swap_subst:\n  \"name \\<noteq> name' \\<Longrightarrow> atom name' \\<sharp> u \\<Longrightarrow>\n   subst_dbfm u name (abst_dbfm name' j A) = abst_dbfm name' j (subst_dbfm u name A)\"", "lemma subst_trans_commute [simp]:\n  \"atom i \\<sharp> e \\<Longrightarrow> subst_dbtm (trans_tm e u) i (trans_tm e t) = trans_tm e (subst i u t)\"", "lemma subst_fm_trans_commute [simp]:\n  \"subst_dbfm (trans_tm [] u) name (trans_fm [] A) = trans_fm [] (A (name::= u))\"", "lemma subst_fm_trans_commute_eq:\n  \"du = trans_tm [] u \\<Longrightarrow> subst_dbfm du i (trans_fm [] A) = trans_fm [] (A(i::=u))\"", "lemma fresh_HTuple [simp]: \"x \\<sharp> HTuple n\"", "lemma HTuple_eqvt[eqvt]: \"(p \\<bullet> HTuple n) = HTuple (p \\<bullet> n)\"", "lemma nat_of_name_inject [simp]: \"nat_of_name n1 = nat_of_name n2 \\<longleftrightarrow> n1 = n2\"", "lemma nat_of_name_Abs_eq [simp]: \"nat_of_name (Abs_name (Atom (Sort ''SyntaxN.name'' []) n)) = n\"", "lemma nat_of_name_name_eq [simp]: \"nat_of_name (name_of_nat n) = n\"", "lemma name_of_nat_nat_of_name [simp]: \"name_of_nat (nat_of_name i) = i\"", "lemma HPair_neq_ORD_OF [simp]: \"HPair x y \\<noteq> ORD_OF i\"", "lemma HTuple_minus_1: \"n > 0 \\<Longrightarrow> HTuple n = HPair Zero (HTuple (n - 1))\"", "lemmas HTS = HTuple_minus_1 HTuple.simps \\<comment> \\<open>for freeness reasoning on codes\\<close>", "lemma quot_dbtm_fresh [simp]: \"s \\<sharp> (quot_dbtm t)\"", "lemma quot_tm_fresh [simp]: fixes t::tm shows \"s \\<sharp> \\<guillemotleft>t\\<guillemotright>\"", "lemma quot_Zero [simp]: \"\\<guillemotleft>Zero\\<guillemotright> = Zero\"", "lemma quot_Var: \"\\<guillemotleft>Var x\\<guillemotright> = SUCC (ORD_OF (nat_of_name x))\"", "lemma quot_Eats: \"\\<guillemotleft>Eats x y\\<guillemotright> = HPair (HTuple 1) (HPair \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright>)\"", "lemma quot_dbfm_fresh [simp]: \"s \\<sharp> (quot_dbfm A)\"", "lemma quot_fm_fresh [simp]: fixes A::fm shows \"s \\<sharp> \\<guillemotleft>A\\<guillemotright>\"", "lemma quot_fm_permute [simp]: fixes A:: fm shows \"p \\<bullet> \\<guillemotleft>A\\<guillemotright> = \\<guillemotleft>A\\<guillemotright>\"", "lemma quot_Mem: \"\\<guillemotleft>x IN y\\<guillemotright> = HPair (HTuple 0) (HPair (\\<guillemotleft>x\\<guillemotright>) (\\<guillemotleft>y\\<guillemotright>))\"", "lemma quot_Eq: \"\\<guillemotleft>x EQ y\\<guillemotright> = HPair (HTuple 2) (HPair (\\<guillemotleft>x\\<guillemotright>) (\\<guillemotleft>y\\<guillemotright>))\"", "lemma quot_Disj: \"\\<guillemotleft>A OR B\\<guillemotright> = HPair (HTuple 3) (HPair (\\<guillemotleft>A\\<guillemotright>) (\\<guillemotleft>B\\<guillemotright>))\"", "lemma quot_Neg: \"\\<guillemotleft>Neg A\\<guillemotright> = HPair (HTuple 4) (\\<guillemotleft>A\\<guillemotright>)\"", "lemma quot_Ex: \"\\<guillemotleft>Ex i A\\<guillemotright> = HPair (HTuple 5) (quot_dbfm (trans_fm [i] A))\"", "lemmas quot_simps = quot_Var quot_Eats quot_Eq quot_Mem quot_Disj quot_Neg quot_Ex", "lemma quot_Succ: \"\\<guillemotleft>SUCC x\\<guillemotright> = Q_Succ \\<guillemotleft>x\\<guillemotright>\"", "lemma quot_subst_eq: \"\\<guillemotleft>A(i::=t)\\<guillemotright> = quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\"", "lemma Q_Succ_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> Q_Succ x EQ Q_Succ x'\"", "lemma coding_tm_Zero [intro]: \"coding_tm Zero\"", "lemma coding_tm_HTuple [intro]: \"coding_tm (HTuple k)\"", "lemma quot_dbtm_coding [simp]: \"coding_tm (quot_dbtm t)\"", "lemma quot_dbfm_coding [simp]: \"coding_tm (quot_dbfm fm)\"", "lemma quot_fm_coding: fixes A::fm shows \"coding_tm \\<guillemotleft>A\\<guillemotright>\"", "lemma fresh_vquot_dbtm [simp]: \"i \\<sharp> vquot_dbtm V tm \\<longleftrightarrow> i \\<sharp> tm \\<or> i \\<notin> atom ` V\"", "lemma fresh_vquot_dbfm [simp]: \"i \\<sharp> vquot_dbfm V fm \\<longleftrightarrow> i \\<sharp> fm \\<or> i \\<notin> atom ` V\"", "lemma vquot_dbtm_empty [simp]: \"vquot_dbtm {} t = quot_dbtm t\"", "lemma vquot_tm_empty [simp]: fixes t::tm shows \"\\<lfloor>t\\<rfloor>{} = \\<guillemotleft>t\\<guillemotright>\"", "lemma vquot_dbtm_eq: \"atom ` V \\<inter> supp t = atom ` W \\<inter> supp t \\<Longrightarrow> vquot_dbtm V t = vquot_dbtm W t\"", "lemma vquot_fm_fresh [simp]: fixes A::fm shows \"i \\<sharp> \\<lfloor>A\\<rfloor>V \\<longleftrightarrow> i \\<sharp> A \\<or> i \\<notin> atom ` V\"", "lemma vquot_dbfm_empty [simp]: \"vquot_dbfm {} A = quot_dbfm A\"", "lemma vquot_fm_empty [simp]: fixes A::fm shows \"\\<lfloor>A\\<rfloor>{} = \\<guillemotleft>A\\<guillemotright>\"", "lemma vquot_dbfm_eq: \"atom ` V \\<inter> supp A = atom ` W \\<inter> supp A \\<Longrightarrow> vquot_dbfm V A = vquot_dbfm W A\"", "lemma vquot_fm_insert:\n  fixes A::fm shows \"atom i \\<notin> supp A \\<Longrightarrow> \\<lfloor>A\\<rfloor>(insert i V) = \\<lfloor>A\\<rfloor>V\""], "translations": [["", "lemma fresh_imp_notin_env: \"atom name \\<sharp> e \\<Longrightarrow> name \\<notin> set e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom name \\<sharp> e \\<Longrightarrow> name \\<notin> set e", "by (metis List.finite_set fresh_finite_set_at_base fresh_set)"], ["", "lemma lookup_notin: \"x \\<notin> set e \\<Longrightarrow> lookup e n x = DBVar x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set e \\<Longrightarrow> lookup e n x = DBVar x", "by (induct e arbitrary: n) auto"], ["", "lemma lookup_in:\n  \"x \\<in> set e \\<Longrightarrow> \\<exists>k. lookup e n x = DBInd k \\<and> n \\<le> k \\<and> k < n + length e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set e \\<Longrightarrow>\n    \\<exists>k.\n       lookup e n x = DBInd k \\<and> n \\<le> k \\<and> k < n + length e", "apply (induct e arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       x \\<in> set [] \\<Longrightarrow>\n       \\<exists>k.\n          lookup [] n x = DBInd k \\<and> n \\<le> k \\<and> k < n + length []\n 2. \\<And>a e n.\n       \\<lbrakk>\\<And>n.\n                   x \\<in> set e \\<Longrightarrow>\n                   \\<exists>k.\n                      lookup e n x = DBInd k \\<and>\n                      n \\<le> k \\<and> k < n + length e;\n        x \\<in> set (a # e)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            lookup (a # e) n x = DBInd k \\<and>\n                            n \\<le> k \\<and> k < n + length (a # e)", "apply (auto intro: Suc_leD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a e n.\n       \\<lbrakk>\\<And>n.\n                   \\<exists>k.\n                      lookup e n x = DBInd k \\<and>\n                      n \\<le> k \\<and> k < n + length e;\n        x \\<noteq> a; x \\<in> set e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            lookup e (Suc n) x = DBInd k \\<and>\n                            n \\<le> k \\<and> k < Suc (n + length e)", "apply (metis Suc_leD add_Suc_right add_Suc_shift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lookup_fresh: \"x \\<sharp> lookup e n y \\<longleftrightarrow> y \\<in> set e \\<or> x \\<noteq> atom y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> lookup e n y = (y \\<in> set e \\<or> x \\<noteq> atom y)", "by (induct arbitrary: n rule: lookup.induct) (auto simp: pure_fresh fresh_at_base)"], ["", "lemma lookup_eqvt[eqvt]: \"(p \\<bullet> lookup xs n x) = lookup (p \\<bullet> xs) (p \\<bullet> n) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> lookup xs n x =\n    lookup (p \\<bullet> xs) (p \\<bullet> n) (p \\<bullet> x)", "by (induct xs arbitrary: n) (simp_all add: permute_pure)"], ["", "lemma lookup_inject [iff]: \"(lookup e n x = lookup e n y) \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup e n x = lookup e n y) = (x = y)", "apply (induct e n x arbitrary: y rule: lookup.induct, force, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y ys n x ya.\n       (\\<And>ya.\n           x \\<noteq> y \\<Longrightarrow>\n           (lookup ys (Suc n) x = lookup ys (Suc n) ya) =\n           (x = ya)) \\<Longrightarrow>\n       (x = y \\<longrightarrow>\n        ya \\<noteq> y \\<longrightarrow>\n        DBInd n \\<noteq> lookup ys (Suc n) ya) \\<and>\n       (x \\<noteq> y \\<longrightarrow>\n        ya = y \\<longrightarrow> lookup ys (Suc n) x \\<noteq> DBInd n)", "by (metis Suc_n_not_le_n dbtm.distinct(7) dbtm.eq_iff(3) lookup_in lookup_notin)"], ["", "nominal_function trans_tm :: \"name list \\<Rightarrow> tm \\<Rightarrow> dbtm\"\n  where\n   \"trans_tm e Zero = DBZero\"\n | \"trans_tm e (Var k) = lookup e 0 k\"\n | \"trans_tm e (Eats t u) = DBEats (trans_tm e t) (trans_tm e u)\""], ["proof (prove)\ngoal (9 subgoals):\n 1. eqvt trans_tm_graph_aux\n 2. \\<And>x y. trans_tm_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>e. x = (e, Zero) \\<Longrightarrow> P;\n        \\<And>e k. x = (e, Var k) \\<Longrightarrow> P;\n        \\<And>e t u. x = (e, Eats t u) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>e ea. (e, Zero) = (ea, Zero) \\<Longrightarrow> DBZero = DBZero\n 5. \\<And>e ea k.\n       (e, Zero) = (ea, Var k) \\<Longrightarrow> DBZero = lookup ea 0 k\n 6. \\<And>e ea t u.\n       \\<lbrakk>eqvt_at trans_tm_sumC (ea, t);\n        eqvt_at trans_tm_sumC (ea, u); True; True;\n        (e, Zero) = (ea, Eats t u)\\<rbrakk>\n       \\<Longrightarrow> DBZero =\n                         DBEats (trans_tm_sumC (ea, t))\n                          (trans_tm_sumC (ea, u))\n 7. \\<And>e k ea ka.\n       (e, Var k) = (ea, Var ka) \\<Longrightarrow>\n       lookup e 0 k = lookup ea 0 ka\n 8. \\<And>e k ea t u.\n       \\<lbrakk>eqvt_at trans_tm_sumC (ea, t);\n        eqvt_at trans_tm_sumC (ea, u); True; True;\n        (e, Var k) = (ea, Eats t u)\\<rbrakk>\n       \\<Longrightarrow> lookup e 0 k =\n                         DBEats (trans_tm_sumC (ea, t))\n                          (trans_tm_sumC (ea, u))\n 9. \\<And>e t u ea ta ua.\n       \\<lbrakk>eqvt_at trans_tm_sumC (e, t); eqvt_at trans_tm_sumC (e, u);\n        eqvt_at trans_tm_sumC (ea, ta); eqvt_at trans_tm_sumC (ea, ua);\n        True; True; True; True; (e, Eats t u) = (ea, Eats ta ua)\\<rbrakk>\n       \\<Longrightarrow> DBEats (trans_tm_sumC (e, t))\n                          (trans_tm_sumC (e, u)) =\n                         DBEats (trans_tm_sumC (ea, ta))\n                          (trans_tm_sumC (ea, ua))", "by (auto simp: eqvt_def trans_tm_graph_aux_def) (metis tm.strong_exhaust)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All trans_tm_dom", "by lexicographic_order"], ["", "lemma fresh_trans_tm_iff [simp]: \"i \\<sharp> trans_tm e t \\<longleftrightarrow> i \\<sharp> t \\<or> i \\<in> atom ` set e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sharp> trans_tm e t = (i \\<sharp> t \\<or> i \\<in> atom ` set e)", "by (induct t rule: tm.induct, auto simp: lookup_fresh fresh_at_base)"], ["", "lemma trans_tm_forget: \"atom i \\<sharp> t \\<Longrightarrow> trans_tm [i] t = trans_tm [] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> t \\<Longrightarrow> trans_tm [i] t = trans_tm [] t", "by (induct t rule: tm.induct, auto simp: fresh_Pair)"], ["", "nominal_function (invariant \"\\<lambda>(xs, _) y. atom ` set xs \\<sharp>* y\")\n  trans_fm :: \"name list \\<Rightarrow> fm \\<Rightarrow> dbfm\"\n  where\n   \"trans_fm e (Mem t u) = DBMem (trans_tm e t) (trans_tm e u)\"\n | \"trans_fm e (Eq t u)  = DBEq (trans_tm e t) (trans_tm e u)\"\n | \"trans_fm e (Disj A B) = DBDisj (trans_fm e A) (trans_fm e B)\"\n | \"trans_fm e (Neg A)   = DBNeg (trans_fm e A)\"\n | \"atom k \\<sharp> e \\<Longrightarrow> trans_fm e (Ex k A) = DBEx (trans_fm (k#e) A)\""], ["proof (prove)\ngoal (18 subgoals):\n 1. eqvt trans_fm_graph_aux\n 2. \\<And>x y.\n       trans_fm_graph x y \\<Longrightarrow>\n       (case x of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs)) y\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>e t u. x = (e, t IN u) \\<Longrightarrow> P;\n        \\<And>e t u. x = (e, t EQ u) \\<Longrightarrow> P;\n        \\<And>e A B. x = (e, A OR B) \\<Longrightarrow> P;\n        \\<And>e A. x = (e, Neg A) \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e; x = (e, SyntaxN.Ex k A)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta IN ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBMem (trans_tm ea ta) (trans_tm ea ua)\n 5. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 6. \\<And>e t u ea A B.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        eqvt_at trans_fm_sumC (ea, B);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (case (ea, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, B));\n        (e, t IN u) = (ea, A OR B)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBDisj (trans_fm_sumC (ea, A))\n                          (trans_fm_sumC (ea, B))\n 7. \\<And>e t u ea A.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (e, t IN u) = (ea, Neg A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBNeg (trans_fm_sumC (ea, A))\n 8. \\<And>e t u k ea A.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        (case (k # ea, A) of\n         (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (k # ea, A));\n        atom k \\<sharp> ea; (e, t IN u) = (ea, SyntaxN.Ex k A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBEx (trans_fm_sumC (k # ea, A))\n 9. \\<And>e t u ea ta ua.\n       (e, t EQ u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBEq (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 10. \\<And>e t u ea A B.\n        \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n         eqvt_at trans_fm_sumC (ea, B);\n         (case (ea, A) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, A));\n         (case (ea, B) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, B));\n         (e, t EQ u) = (ea, A OR B)\\<rbrakk>\n        \\<Longrightarrow> DBEq (trans_tm e t) (trans_tm e u) =\n                          DBDisj (trans_fm_sumC (ea, A))\n                           (trans_fm_sumC (ea, B))\nA total of 18 subgoals...", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (18 subgoals):\n 1. eqvt trans_fm_graph_aux\n 2. \\<And>x y.\n       trans_fm_graph x y \\<Longrightarrow>\n       (case x of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs)) y\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>e t u. x = (e, t IN u) \\<Longrightarrow> P;\n        \\<And>e t u. x = (e, t EQ u) \\<Longrightarrow> P;\n        \\<And>e A B. x = (e, A OR B) \\<Longrightarrow> P;\n        \\<And>e A. x = (e, Neg A) \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e; x = (e, SyntaxN.Ex k A)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta IN ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBMem (trans_tm ea ta) (trans_tm ea ua)\n 5. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 6. \\<And>e t u ea A B.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        eqvt_at trans_fm_sumC (ea, B);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (case (ea, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, B));\n        (e, t IN u) = (ea, A OR B)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBDisj (trans_fm_sumC (ea, A))\n                          (trans_fm_sumC (ea, B))\n 7. \\<And>e t u ea A.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (e, t IN u) = (ea, Neg A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBNeg (trans_fm_sumC (ea, A))\n 8. \\<And>e t u k ea A.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        (case (k # ea, A) of\n         (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (k # ea, A));\n        atom k \\<sharp> ea; (e, t IN u) = (ea, SyntaxN.Ex k A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBEx (trans_fm_sumC (k # ea, A))\n 9. \\<And>e t u ea ta ua.\n       (e, t EQ u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBEq (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 10. \\<And>e t u ea A B.\n        \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n         eqvt_at trans_fm_sumC (ea, B);\n         (case (ea, A) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, A));\n         (case (ea, B) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, B));\n         (e, t EQ u) = (ea, A OR B)\\<rbrakk>\n        \\<Longrightarrow> DBEq (trans_tm e t) (trans_tm e u) =\n                          DBDisj (trans_fm_sumC (ea, A))\n                           (trans_fm_sumC (ea, B))\nA total of 18 subgoals...", "apply(simp add: eqvt_def trans_fm_graph_aux_def)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x y.\n       trans_fm_graph x y \\<Longrightarrow>\n       (case x of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs)) y\n 2. \\<And>P x.\n       \\<lbrakk>\\<And>e t u. x = (e, t IN u) \\<Longrightarrow> P;\n        \\<And>e t u. x = (e, t EQ u) \\<Longrightarrow> P;\n        \\<And>e A B. x = (e, A OR B) \\<Longrightarrow> P;\n        \\<And>e A. x = (e, Neg A) \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e; x = (e, SyntaxN.Ex k A)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta IN ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBMem (trans_tm ea ta) (trans_tm ea ua)\n 4. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 5. \\<And>e t u ea A B.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        eqvt_at trans_fm_sumC (ea, B);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (case (ea, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, B));\n        (e, t IN u) = (ea, A OR B)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBDisj (trans_fm_sumC (ea, A))\n                          (trans_fm_sumC (ea, B))\n 6. \\<And>e t u ea A.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (e, t IN u) = (ea, Neg A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBNeg (trans_fm_sumC (ea, A))\n 7. \\<And>e t u k ea A.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        (case (k # ea, A) of\n         (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (k # ea, A));\n        atom k \\<sharp> ea; (e, t IN u) = (ea, SyntaxN.Ex k A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBEx (trans_fm_sumC (k # ea, A))\n 8. \\<And>e t u ea ta ua.\n       (e, t EQ u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBEq (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 9. \\<And>e t u ea A B.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        eqvt_at trans_fm_sumC (ea, B);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (case (ea, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, B));\n        (e, t EQ u) = (ea, A OR B)\\<rbrakk>\n       \\<Longrightarrow> DBEq (trans_tm e t) (trans_tm e u) =\n                         DBDisj (trans_fm_sumC (ea, A))\n                          (trans_fm_sumC (ea, B))\n 10. \\<And>e t u ea A.\n        \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n         (case (ea, A) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, A));\n         (e, t EQ u) = (ea, Neg A)\\<rbrakk>\n        \\<Longrightarrow> DBEq (trans_tm e t) (trans_tm e u) =\n                          DBNeg (trans_fm_sumC (ea, A))\nA total of 17 subgoals...", "apply(erule trans_fm_graph.induct)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x y trans_fm_sum e t u.\n       (case (e, t IN u) of\n        (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n        (DBMem (trans_tm e t) (trans_tm e u))\n 2. \\<And>x y trans_fm_sum e t u.\n       (case (e, t EQ u) of\n        (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n        (DBEq (trans_tm e t) (trans_tm e u))\n 3. \\<And>x y trans_fm_sum e A B.\n       \\<lbrakk>trans_fm_graph (e, A) (trans_fm_sum (e, A));\n        (case (e, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (e, A));\n        trans_fm_graph (e, B) (trans_fm_sum (e, B));\n        (case (e, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (e, B))\\<rbrakk>\n       \\<Longrightarrow> (case (e, A OR B) of\n                          (xs, uu_) \\<Rightarrow>\n                            fresh_star (atom ` set xs))\n                          (DBDisj (trans_fm_sum (e, A))\n                            (trans_fm_sum (e, B)))\n 4. \\<And>x y trans_fm_sum e A.\n       \\<lbrakk>trans_fm_graph (e, A) (trans_fm_sum (e, A));\n        (case (e, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (e, A))\\<rbrakk>\n       \\<Longrightarrow> (case (e, Neg A) of\n                          (xs, uu_) \\<Rightarrow>\n                            fresh_star (atom ` set xs))\n                          (DBNeg (trans_fm_sum (e, A)))\n 5. \\<And>x y trans_fm_sum k e A.\n       \\<lbrakk>atom k \\<sharp> e;\n        trans_fm_graph (k # e, A) (trans_fm_sum (k # e, A));\n        (case (k # e, A) of\n         (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (k # e, A))\\<rbrakk>\n       \\<Longrightarrow> (case (e, SyntaxN.Ex k A) of\n                          (xs, uu_) \\<Rightarrow>\n                            fresh_star (atom ` set xs))\n                          (DBEx (trans_fm_sum (k # e, A)))\n 6. \\<And>P x.\n       \\<lbrakk>\\<And>e t u. x = (e, t IN u) \\<Longrightarrow> P;\n        \\<And>e t u. x = (e, t EQ u) \\<Longrightarrow> P;\n        \\<And>e A B. x = (e, A OR B) \\<Longrightarrow> P;\n        \\<And>e A. x = (e, Neg A) \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e; x = (e, SyntaxN.Ex k A)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 7. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta IN ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBMem (trans_tm ea ta) (trans_tm ea ua)\n 8. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 9. \\<And>e t u ea A B.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        eqvt_at trans_fm_sumC (ea, B);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (case (ea, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, B));\n        (e, t IN u) = (ea, A OR B)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBDisj (trans_fm_sumC (ea, A))\n                          (trans_fm_sumC (ea, B))\n 10. \\<And>e t u ea A.\n        \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n         (case (ea, A) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, A));\n         (e, t IN u) = (ea, Neg A)\\<rbrakk>\n        \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                          DBNeg (trans_fm_sumC (ea, A))\nA total of 21 subgoals...", "using [[simproc del: alpha_lst]]"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x y trans_fm_sum e t u.\n       (case (e, t IN u) of\n        (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n        (DBMem (trans_tm e t) (trans_tm e u))\n 2. \\<And>x y trans_fm_sum e t u.\n       (case (e, t EQ u) of\n        (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n        (DBEq (trans_tm e t) (trans_tm e u))\n 3. \\<And>x y trans_fm_sum e A B.\n       \\<lbrakk>trans_fm_graph (e, A) (trans_fm_sum (e, A));\n        (case (e, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (e, A));\n        trans_fm_graph (e, B) (trans_fm_sum (e, B));\n        (case (e, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (e, B))\\<rbrakk>\n       \\<Longrightarrow> (case (e, A OR B) of\n                          (xs, uu_) \\<Rightarrow>\n                            fresh_star (atom ` set xs))\n                          (DBDisj (trans_fm_sum (e, A))\n                            (trans_fm_sum (e, B)))\n 4. \\<And>x y trans_fm_sum e A.\n       \\<lbrakk>trans_fm_graph (e, A) (trans_fm_sum (e, A));\n        (case (e, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (e, A))\\<rbrakk>\n       \\<Longrightarrow> (case (e, Neg A) of\n                          (xs, uu_) \\<Rightarrow>\n                            fresh_star (atom ` set xs))\n                          (DBNeg (trans_fm_sum (e, A)))\n 5. \\<And>x y trans_fm_sum k e A.\n       \\<lbrakk>atom k \\<sharp> e;\n        trans_fm_graph (k # e, A) (trans_fm_sum (k # e, A));\n        (case (k # e, A) of\n         (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sum (k # e, A))\\<rbrakk>\n       \\<Longrightarrow> (case (e, SyntaxN.Ex k A) of\n                          (xs, uu_) \\<Rightarrow>\n                            fresh_star (atom ` set xs))\n                          (DBEx (trans_fm_sum (k # e, A)))\n 6. \\<And>P x.\n       \\<lbrakk>\\<And>e t u. x = (e, t IN u) \\<Longrightarrow> P;\n        \\<And>e t u. x = (e, t EQ u) \\<Longrightarrow> P;\n        \\<And>e A B. x = (e, A OR B) \\<Longrightarrow> P;\n        \\<And>e A. x = (e, Neg A) \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e; x = (e, SyntaxN.Ex k A)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 7. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta IN ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBMem (trans_tm ea ta) (trans_tm ea ua)\n 8. \\<And>e t u ea ta ua.\n       (e, t IN u) = (ea, ta EQ ua) \\<Longrightarrow>\n       DBMem (trans_tm e t) (trans_tm e u) =\n       DBEq (trans_tm ea ta) (trans_tm ea ua)\n 9. \\<And>e t u ea A B.\n       \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n        eqvt_at trans_fm_sumC (ea, B);\n        (case (ea, A) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, A));\n        (case (ea, B) of (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n         (trans_fm_sumC (ea, B));\n        (e, t IN u) = (ea, A OR B)\\<rbrakk>\n       \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                         DBDisj (trans_fm_sumC (ea, A))\n                          (trans_fm_sumC (ea, B))\n 10. \\<And>e t u ea A.\n        \\<lbrakk>eqvt_at trans_fm_sumC (ea, A);\n         (case (ea, A) of\n          (xs, uu_) \\<Rightarrow> fresh_star (atom ` set xs))\n          (trans_fm_sumC (ea, A));\n         (e, t IN u) = (ea, Neg A)\\<rbrakk>\n        \\<Longrightarrow> DBMem (trans_tm e t) (trans_tm e u) =\n                          DBNeg (trans_fm_sumC (ea, A))\nA total of 21 subgoals...", "apply(auto simp: fresh_star_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P a b.\n       \\<lbrakk>\\<And>e t u. a = e \\<and> b = t IN u \\<Longrightarrow> P;\n        \\<And>e t u. a = e \\<and> b = t EQ u \\<Longrightarrow> P;\n        \\<And>e A B. a = e \\<and> b = A OR B \\<Longrightarrow> P;\n        \\<And>e A. a = e \\<and> b = Neg A \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e;\n            a = e \\<and> b = SyntaxN.Ex k A\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>k A ka ea Aa.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        [[atom k]]lst. A = [[atom ka]]lst. Aa\\<rbrakk>\n       \\<Longrightarrow> trans_fm_sumC (k # ea, A) =\n                         trans_fm_sumC (ka # ea, Aa)", "apply(rule_tac y=b and c=a in fm.strong_exhaust)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>P a b x11 x12.\n       \\<lbrakk>\\<And>e t u. a = e \\<and> b = t IN u \\<Longrightarrow> P;\n        \\<And>e t u. a = e \\<and> b = t EQ u \\<Longrightarrow> P;\n        \\<And>e A B. a = e \\<and> b = A OR B \\<Longrightarrow> P;\n        \\<And>e A. a = e \\<and> b = Neg A \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e;\n            a = e \\<and> b = SyntaxN.Ex k A\\<rbrakk>\n           \\<Longrightarrow> P;\n        b = x11 IN x12\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P a b x21 x22.\n       \\<lbrakk>\\<And>e t u. a = e \\<and> b = t IN u \\<Longrightarrow> P;\n        \\<And>e t u. a = e \\<and> b = t EQ u \\<Longrightarrow> P;\n        \\<And>e A B. a = e \\<and> b = A OR B \\<Longrightarrow> P;\n        \\<And>e A. a = e \\<and> b = Neg A \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e;\n            a = e \\<and> b = SyntaxN.Ex k A\\<rbrakk>\n           \\<Longrightarrow> P;\n        b = x21 EQ x22\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>P a b x31 x32.\n       \\<lbrakk>\\<And>e t u. a = e \\<and> b = t IN u \\<Longrightarrow> P;\n        \\<And>e t u. a = e \\<and> b = t EQ u \\<Longrightarrow> P;\n        \\<And>e A B. a = e \\<and> b = A OR B \\<Longrightarrow> P;\n        \\<And>e A. a = e \\<and> b = Neg A \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e;\n            a = e \\<and> b = SyntaxN.Ex k A\\<rbrakk>\n           \\<Longrightarrow> P;\n        b = x31 OR x32\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>P a b x4.\n       \\<lbrakk>\\<And>e t u. a = e \\<and> b = t IN u \\<Longrightarrow> P;\n        \\<And>e t u. a = e \\<and> b = t EQ u \\<Longrightarrow> P;\n        \\<And>e A B. a = e \\<and> b = A OR B \\<Longrightarrow> P;\n        \\<And>e A. a = e \\<and> b = Neg A \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e;\n            a = e \\<and> b = SyntaxN.Ex k A\\<rbrakk>\n           \\<Longrightarrow> P;\n        b = Neg x4\\<rbrakk>\n       \\<Longrightarrow> P\n 5. \\<And>P a b x51 x52.\n       \\<lbrakk>\\<And>e t u. a = e \\<and> b = t IN u \\<Longrightarrow> P;\n        \\<And>e t u. a = e \\<and> b = t EQ u \\<Longrightarrow> P;\n        \\<And>e A B. a = e \\<and> b = A OR B \\<Longrightarrow> P;\n        \\<And>e A. a = e \\<and> b = Neg A \\<Longrightarrow> P;\n        \\<And>k e A.\n           \\<lbrakk>atom k \\<sharp> e;\n            a = e \\<and> b = SyntaxN.Ex k A\\<rbrakk>\n           \\<Longrightarrow> P;\n        {atom x51} \\<sharp>* a; b = SyntaxN.Ex x51 x52\\<rbrakk>\n       \\<Longrightarrow> P\n 6. \\<And>k A ka ea Aa.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        [[atom k]]lst. A = [[atom ka]]lst. Aa\\<rbrakk>\n       \\<Longrightarrow> trans_fm_sumC (k # ea, A) =\n                         trans_fm_sumC (ka # ea, Aa)", "apply(auto simp: fresh_star_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k A ka ea Aa.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        [[atom k]]lst. A = [[atom ka]]lst. Aa\\<rbrakk>\n       \\<Longrightarrow> trans_fm_sumC (k # ea, A) =\n                         trans_fm_sumC (ka # ea, Aa)", "apply(erule_tac c=ea in Abs_lst1_fcb2')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>k A ka ea Aa.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea.\n           atom a \\<sharp> trans_fm_sumC (ka # ea, Aa)\\<rbrakk>\n       \\<Longrightarrow> atom k \\<sharp> trans_fm_sumC (k # ea, A)\n 2. \\<And>k A ka ea Aa.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea.\n           atom a \\<sharp> trans_fm_sumC (ka # ea, Aa)\\<rbrakk>\n       \\<Longrightarrow> {atom k, atom ka} \\<sharp>* ea\n 3. \\<And>k A ka ea Aa p.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        supp p \\<sharp>* ea\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> trans_fm_sumC (k # ea, A) =\n                         trans_fm_sumC (p \\<bullet> k # ea, p \\<bullet> A)\n 4. \\<And>k A ka ea Aa p.\n       \\<lbrakk>eqvt_at trans_fm_sumC (k # ea, A);\n        eqvt_at trans_fm_sumC (ka # ea, Aa); atom k \\<sharp> ea;\n        atom ka \\<sharp> ea; atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        supp p \\<sharp>* ea\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> trans_fm_sumC (ka # ea, Aa) =\n                         trans_fm_sumC (p \\<bullet> ka # ea, p \\<bullet> Aa)", "apply (simp_all add: eqvt_at_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k A ka ea Aa.\n       \\<lbrakk>\\<forall>p.\n                   (p \\<bullet> trans_fm_sumC)\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A) =\n                   trans_fm_sumC\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A);\n        \\<forall>p.\n           (p \\<bullet> trans_fm_sumC)\n            (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa) =\n           trans_fm_sumC (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa);\n        atom k \\<sharp> ea; atom ka \\<sharp> ea;\n        atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea.\n           atom a \\<sharp> trans_fm_sumC (ka # ea, Aa)\\<rbrakk>\n       \\<Longrightarrow> {atom k, atom ka} \\<sharp>* ea\n 2. \\<And>k A ka ea Aa p.\n       \\<lbrakk>\\<forall>p.\n                   (p \\<bullet> trans_fm_sumC)\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A) =\n                   trans_fm_sumC\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A);\n        \\<forall>p.\n           (p \\<bullet> trans_fm_sumC)\n            (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa) =\n           trans_fm_sumC (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa);\n        atom k \\<sharp> ea; atom ka \\<sharp> ea;\n        atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        supp p \\<sharp>* ea\\<rbrakk>\n       \\<Longrightarrow> trans_fm_sumC\n                          (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A) =\n                         trans_fm_sumC (p \\<bullet> k # ea, p \\<bullet> A)\n 3. \\<And>k A ka ea Aa p.\n       \\<lbrakk>\\<forall>p.\n                   (p \\<bullet> trans_fm_sumC)\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A) =\n                   trans_fm_sumC\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A);\n        \\<forall>p.\n           (p \\<bullet> trans_fm_sumC)\n            (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa) =\n           trans_fm_sumC (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa);\n        atom k \\<sharp> ea; atom ka \\<sharp> ea;\n        atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        supp p \\<sharp>* ea\\<rbrakk>\n       \\<Longrightarrow> trans_fm_sumC\n                          (p \\<bullet> ka # p \\<bullet> ea,\n                           p \\<bullet> Aa) =\n                         trans_fm_sumC (p \\<bullet> ka # ea, p \\<bullet> Aa)", "apply (simp_all add: fresh_star_Pair perm_supp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k A ka ea Aa.\n       \\<lbrakk>\\<forall>p.\n                   (p \\<bullet> trans_fm_sumC)\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A) =\n                   trans_fm_sumC\n                    (p \\<bullet> k # p \\<bullet> ea, p \\<bullet> A);\n        \\<forall>p.\n           (p \\<bullet> trans_fm_sumC)\n            (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa) =\n           trans_fm_sumC (p \\<bullet> ka # p \\<bullet> ea, p \\<bullet> Aa);\n        atom k \\<sharp> ea; atom ka \\<sharp> ea;\n        atom k \\<sharp> trans_fm_sumC (k # ea, A);\n        \\<forall>a\\<in>set ea. atom a \\<sharp> trans_fm_sumC (k # ea, A);\n        atom ka \\<sharp> trans_fm_sumC (ka # ea, Aa);\n        \\<forall>a\\<in>set ea.\n           atom a \\<sharp> trans_fm_sumC (ka # ea, Aa)\\<rbrakk>\n       \\<Longrightarrow> {atom k, atom ka} \\<sharp>* ea", "apply (simp add: fresh_star_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All trans_fm_dom", "by lexicographic_order"], ["", "lemma fresh_trans_fm [simp]: \"i \\<sharp> trans_fm e A \\<longleftrightarrow> i \\<sharp> A \\<or> i \\<in> atom ` set e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sharp> trans_fm e A = (i \\<sharp> A \\<or> i \\<in> atom ` set e)", "by (nominal_induct A avoiding: e rule: fm.strong_induct, auto simp: fresh_at_base)"], ["", "abbreviation DBConj :: \"dbfm \\<Rightarrow> dbfm \\<Rightarrow> dbfm\"\n  where \"DBConj t u \\<equiv> DBNeg (DBDisj (DBNeg t) (DBNeg u))\""], ["", "lemma trans_fm_Conj [simp]: \"trans_fm e (Conj A B) = DBConj (trans_fm e A) (trans_fm e B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans_fm e (A AND B) = DBConj (trans_fm e A) (trans_fm e B)", "by (simp add: Conj_def)"], ["", "lemma trans_tm_inject [iff]: \"(trans_tm e t = trans_tm e u) \\<longleftrightarrow> t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_tm e t = trans_tm e u) = (t = u)", "proof (induct t arbitrary: e u rule: tm.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e u. (trans_tm e Zero = trans_tm e u) = (Zero = u)\n 2. \\<And>x e u. (trans_tm e (Var x) = trans_tm e u) = (Var x = u)\n 3. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "case Zero"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>e u. (trans_tm e Zero = trans_tm e u) = (Zero = u)\n 2. \\<And>x e u. (trans_tm e (Var x) = trans_tm e u) = (Var x = u)\n 3. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_tm e Zero = trans_tm e u) = (Zero = u)", "apply (cases u rule: tm.exhaust, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>u = Var x2; DBZero = lookup e 0 x2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis dbtm.distinct(1) dbtm.distinct(3) lookup_in lookup_notin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (trans_tm e Zero = trans_tm e u) = (Zero = u)\n\ngoal (2 subgoals):\n 1. \\<And>x e u. (trans_tm e (Var x) = trans_tm e u) = (Var x = u)\n 2. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x e u. (trans_tm e (Var x) = trans_tm e u) = (Var x = u)\n 2. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "case (Var i)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x e u. (trans_tm e (Var x) = trans_tm e u) = (Var x = u)\n 2. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_tm e (Var i) = trans_tm e u) = (Var i = u)", "apply (cases u rule: tm.exhaust, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u = Zero; lookup e 0 i = DBZero\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>x31 x32.\n       \\<lbrakk>u = Eats x31 x32;\n        lookup e 0 i = DBEats (trans_tm e x31) (trans_tm e x32)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis dbtm.distinct(1) dbtm.distinct(3) lookup_in lookup_notin)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>u = Eats x31 x32;\n        lookup e 0 i = DBEats (trans_tm e x31) (trans_tm e x32)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis dbtm.distinct(10) dbtm.distinct(11) lookup_in lookup_notin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (trans_tm e (Var i) = trans_tm e u) = (Var i = u)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "case (Eats tm1 tm2)"], ["proof (state)\nthis:\n  (trans_tm ?e tm1 = trans_tm ?e ?u) = (tm1 = ?u)\n  (trans_tm ?e tm2 = trans_tm ?e ?u) = (tm2 = ?u)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2a e u.\n       \\<lbrakk>\\<And>e u. (trans_tm e x1 = trans_tm e u) = (x1 = u);\n        \\<And>e u. (trans_tm e x2a = trans_tm e u) = (x2a = u)\\<rbrakk>\n       \\<Longrightarrow> (trans_tm e (Eats x1 x2a) = trans_tm e u) =\n                         (Eats x1 x2a = u)", "thus ?case"], ["proof (prove)\nusing this:\n  (trans_tm ?e tm1 = trans_tm ?e ?u) = (tm1 = ?u)\n  (trans_tm ?e tm2 = trans_tm ?e ?u) = (tm2 = ?u)\n\ngoal (1 subgoal):\n 1. (trans_tm e (Eats tm1 tm2) = trans_tm e u) = (Eats tm1 tm2 = u)", "apply (cases u rule: tm.exhaust, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>u = Var x2;\n        \\<And>e u. (trans_tm e tm1 = trans_tm e u) = (tm1 = u);\n        \\<And>e u. (trans_tm e tm2 = trans_tm e u) = (tm2 = u);\n        DBEats (trans_tm e tm1) (trans_tm e tm2) = lookup e 0 x2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis dbtm.distinct(12) dbtm.distinct(9) lookup_in lookup_notin)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (trans_tm e (Eats tm1 tm2) = trans_tm e u) = (Eats tm1 tm2 = u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_fm_inject [iff]: \"(trans_fm e A = trans_fm e B) \\<longleftrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_fm e A = trans_fm e B) = (A = B)", "proof (nominal_induct A avoiding: e B rule: fm.strong_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 e B. (trans_fm e (x1 IN x2) = trans_fm e B) = (x1 IN x2 = B)\n 2. \\<And>x1 x2 e B. (trans_fm e (x1 EQ x2) = trans_fm e B) = (x1 EQ x2 = B)\n 3. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 4. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 5. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "case (Mem tm1 tm2)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 e B. (trans_fm e (x1 IN x2) = trans_fm e B) = (x1 IN x2 = B)\n 2. \\<And>x1 x2 e B. (trans_fm e (x1 EQ x2) = trans_fm e B) = (x1 EQ x2 = B)\n 3. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 4. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 5. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_fm e (tm1 IN tm2) = trans_fm e B) = (tm1 IN tm2 = B)", "by (rule fm.strong_exhaust [where y=B and c=e]) (auto simp: fresh_star_def)"], ["proof (state)\nthis:\n  (trans_fm e (tm1 IN tm2) = trans_fm e B) = (tm1 IN tm2 = B)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 e B. (trans_fm e (x1 EQ x2) = trans_fm e B) = (x1 EQ x2 = B)\n 2. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 3. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 4. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 e B. (trans_fm e (x1 EQ x2) = trans_fm e B) = (x1 EQ x2 = B)\n 2. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 3. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 4. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "case (Eq tm1 tm2)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 e B. (trans_fm e (x1 EQ x2) = trans_fm e B) = (x1 EQ x2 = B)\n 2. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 3. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 4. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_fm e (tm1 EQ tm2) = trans_fm e B) = (tm1 EQ tm2 = B)", "by (rule fm.strong_exhaust [where y=B and c=e]) (auto simp: fresh_star_def)"], ["proof (state)\nthis:\n  (trans_fm e (tm1 EQ tm2) = trans_fm e B) = (tm1 EQ tm2 = B)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 2. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 3. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 2. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 3. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "case (Disj fm1 fm2)"], ["proof (state)\nthis:\n  (trans_fm ?b fm1 = trans_fm ?b ?ba) = (fm1 = ?ba)\n  (trans_fm ?b fm2 = trans_fm ?b ?ba) = (fm2 = ?ba)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 e B.\n       \\<lbrakk>\\<And>b ba. (trans_fm b x1 = trans_fm b ba) = (x1 = ba);\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (x1 OR x2) = trans_fm e B) =\n                         (x1 OR x2 = B)\n 2. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 3. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_fm e (fm1 OR fm2) = trans_fm e B) = (fm1 OR fm2 = B)", "by (rule fm.strong_exhaust [where y=B and c=e]) (auto simp: Disj fresh_star_def)"], ["proof (state)\nthis:\n  (trans_fm e (fm1 OR fm2) = trans_fm e B) = (fm1 OR fm2 = B)\n\ngoal (2 subgoals):\n 1. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 2. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 2. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "case (Neg fm)"], ["proof (state)\nthis:\n  (trans_fm ?b fm = trans_fm ?b ?ba) = (fm = ?ba)\n\ngoal (2 subgoals):\n 1. \\<And>x e B.\n       (\\<And>b ba.\n           (trans_fm b x = trans_fm b ba) = (x = ba)) \\<Longrightarrow>\n       (trans_fm e (Neg x) = trans_fm e B) = (Neg x = B)\n 2. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_fm e (Neg fm) = trans_fm e B) = (Neg fm = B)", "by (rule fm.strong_exhaust [where y=B and c=e]) (auto simp: Neg fresh_star_def)"], ["proof (state)\nthis:\n  (trans_fm e (Neg fm) = trans_fm e B) = (Neg fm = B)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "case (Ex name fm)"], ["proof (state)\nthis:\n  atom name \\<sharp> e\n  atom name \\<sharp> B\n  (trans_fm ?b fm = trans_fm ?b ?ba) = (fm = ?ba)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 e B.\n       \\<lbrakk>atom x1 \\<sharp> e; atom x1 \\<sharp> B;\n        \\<And>b ba. (trans_fm b x2 = trans_fm b ba) = (x2 = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm e (SyntaxN.Ex x1 x2) = trans_fm e B) =\n                         (SyntaxN.Ex x1 x2 = B)", "thus ?case"], ["proof (prove)\nusing this:\n  atom name \\<sharp> e\n  atom name \\<sharp> B\n  (trans_fm ?b fm = trans_fm ?b ?ba) = (fm = ?ba)\n\ngoal (1 subgoal):\n 1. (trans_fm e (SyntaxN.Ex name fm) = trans_fm e B) =\n    (SyntaxN.Ex name fm = B)", "using [[simproc del: alpha_lst]]"], ["proof (prove)\nusing this:\n  atom name \\<sharp> e\n  atom name \\<sharp> B\n  (trans_fm ?b fm = trans_fm ?b ?ba) = (fm = ?ba)\n\ngoal (1 subgoal):\n 1. (trans_fm e (SyntaxN.Ex name fm) = trans_fm e B) =\n    (SyntaxN.Ex name fm = B)", "proof (cases rule: fm.strong_exhaust [where y=B and c=\"(e, name)\"], simp_all add: fresh_star_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>atom name \\<sharp> x52 \\<or> name = x51;\n        atom x51 \\<sharp> (e, name); B = SyntaxN.Ex x51 x52;\n        atom name \\<sharp> e;\n        \\<And>b ba. (trans_fm b fm = trans_fm b ba) = (fm = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm (name # e) fm = trans_fm (x51 # e) x52) =\n                         ([[atom name]]lst. fm = [[atom x51]]lst. x52)", "fix name'::name and fm'::fm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>atom name \\<sharp> x52 \\<or> name = x51;\n        atom x51 \\<sharp> (e, name); B = SyntaxN.Ex x51 x52;\n        atom name \\<sharp> e;\n        \\<And>b ba. (trans_fm b fm = trans_fm b ba) = (fm = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm (name # e) fm = trans_fm (x51 # e) x52) =\n                         ([[atom name]]lst. fm = [[atom x51]]lst. x52)", "assume name': \"atom name' \\<sharp> (e, name)\""], ["proof (state)\nthis:\n  atom name' \\<sharp> (e, name)\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>atom name \\<sharp> x52 \\<or> name = x51;\n        atom x51 \\<sharp> (e, name); B = SyntaxN.Ex x51 x52;\n        atom name \\<sharp> e;\n        \\<And>b ba. (trans_fm b fm = trans_fm b ba) = (fm = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm (name # e) fm = trans_fm (x51 # e) x52) =\n                         ([[atom name]]lst. fm = [[atom x51]]lst. x52)", "assume \"atom name \\<sharp> fm' \\<or> name = name'\""], ["proof (state)\nthis:\n  atom name \\<sharp> fm' \\<or> name = name'\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>atom name \\<sharp> x52 \\<or> name = x51;\n        atom x51 \\<sharp> (e, name); B = SyntaxN.Ex x51 x52;\n        atom name \\<sharp> e;\n        \\<And>b ba. (trans_fm b fm = trans_fm b ba) = (fm = ba)\\<rbrakk>\n       \\<Longrightarrow> (trans_fm (name # e) fm = trans_fm (x51 # e) x52) =\n                         ([[atom name]]lst. fm = [[atom x51]]lst. x52)", "thus \"(trans_fm (name # e) fm = trans_fm (name' # e) fm') = ([[atom name]]lst. fm = [[atom name']]lst. fm')\"\n         (is \"?lhs = ?rhs\")"], ["proof (prove)\nusing this:\n  atom name \\<sharp> fm' \\<or> name = name'\n\ngoal (1 subgoal):\n 1. (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')\n 2. name = name' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "assume \"name = name'\""], ["proof (state)\nthis:\n  name = name'\n\ngoal (2 subgoals):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')\n 2. name = name' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "thus \"?lhs = ?rhs\""], ["proof (prove)\nusing this:\n  name = name'\n\ngoal (1 subgoal):\n 1. (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "by (metis fresh_Pair fresh_at_base(2) name')"], ["proof (state)\nthis:\n  (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n  ([[atom name]]lst. fm = [[atom name']]lst. fm')\n\ngoal (1 subgoal):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "assume name: \"atom name \\<sharp> fm'\""], ["proof (state)\nthis:\n  atom name \\<sharp> fm'\n\ngoal (1 subgoal):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "have eq1: \"(name \\<leftrightarrow> name') \\<bullet> trans_fm (name' # e) fm' = trans_fm (name' # e) fm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name \\<leftrightarrow> name') \\<bullet> trans_fm (name' # e) fm' =\n    trans_fm (name' # e) fm'", "by (simp add: flip_fresh_fresh name)"], ["proof (state)\nthis:\n  (name \\<leftrightarrow> name') \\<bullet> trans_fm (name' # e) fm' =\n  trans_fm (name' # e) fm'\n\ngoal (1 subgoal):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "have eq2: \"(name \\<leftrightarrow> name') \\<bullet> ([[atom name']]lst. fm') = [[atom name']]lst. fm'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (name \\<leftrightarrow> name') \\<bullet> ([[atom name']]lst. fm') =\n    [[atom name']]lst. fm'", "by (rule flip_fresh_fresh) (auto simp: Abs_fresh_iff name)"], ["proof (state)\nthis:\n  (name \\<leftrightarrow> name') \\<bullet> ([[atom name']]lst. fm') =\n  [[atom name']]lst. fm'\n\ngoal (1 subgoal):\n 1. atom name \\<sharp> fm' \\<Longrightarrow>\n    (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "show \"?lhs = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "using name' eq1 eq2 Ex(1) Ex(3) [of \"name#e\" \"(name \\<leftrightarrow> name') \\<bullet> fm'\"]"], ["proof (prove)\nusing this:\n  atom name' \\<sharp> (e, name)\n  (name \\<leftrightarrow> name') \\<bullet> trans_fm (name' # e) fm' =\n  trans_fm (name' # e) fm'\n  (name \\<leftrightarrow> name') \\<bullet> ([[atom name']]lst. fm') =\n  [[atom name']]lst. fm'\n  atom name \\<sharp> e\n  (trans_fm (name # e) fm =\n   trans_fm (name # e) ((name \\<leftrightarrow> name') \\<bullet> fm')) =\n  (fm = (name \\<leftrightarrow> name') \\<bullet> fm')\n\ngoal (1 subgoal):\n 1. (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n    ([[atom name]]lst. fm = [[atom name']]lst. fm')", "by (simp add: flip_fresh_fresh) (metis Abs1_eq(3))"], ["proof (state)\nthis:\n  (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n  ([[atom name]]lst. fm = [[atom name']]lst. fm')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (trans_fm (name # e) fm = trans_fm (name' # e) fm') =\n  ([[atom name]]lst. fm = [[atom name']]lst. fm')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (trans_fm e (SyntaxN.Ex name fm) = trans_fm e B) =\n  (SyntaxN.Ex name fm = B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_fm_perm:\n  assumes c: \"atom c \\<sharp> (i,j,A,B)\"\n  and     t: \"trans_fm [i] A = trans_fm [j] B\"\n  shows \"(i \\<leftrightarrow> c) \\<bullet> A = (j \\<leftrightarrow> c) \\<bullet> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "have c_fresh1: \"atom c \\<sharp> trans_fm [i] A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom c \\<sharp> trans_fm [i] A", "using c"], ["proof (prove)\nusing this:\n  atom c \\<sharp> (i, j, A, B)\n\ngoal (1 subgoal):\n 1. atom c \\<sharp> trans_fm [i] A", "by (auto simp: supp_Pair)"], ["proof (state)\nthis:\n  atom c \\<sharp> trans_fm [i] A\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "moreover"], ["proof (state)\nthis:\n  atom c \\<sharp> trans_fm [i] A\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "have i_fresh: \"atom i \\<sharp> trans_fm [i] A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> trans_fm [i] A", "by auto"], ["proof (state)\nthis:\n  atom i \\<sharp> trans_fm [i] A\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "moreover"], ["proof (state)\nthis:\n  atom i \\<sharp> trans_fm [i] A\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "have c_fresh2: \"atom c \\<sharp> trans_fm [j] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom c \\<sharp> trans_fm [j] B", "using c"], ["proof (prove)\nusing this:\n  atom c \\<sharp> (i, j, A, B)\n\ngoal (1 subgoal):\n 1. atom c \\<sharp> trans_fm [j] B", "by (auto simp: supp_Pair)"], ["proof (state)\nthis:\n  atom c \\<sharp> trans_fm [j] B\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "moreover"], ["proof (state)\nthis:\n  atom c \\<sharp> trans_fm [j] B\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "have j_fresh: \"atom j \\<sharp> trans_fm [j] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom j \\<sharp> trans_fm [j] B", "by auto"], ["proof (state)\nthis:\n  atom j \\<sharp> trans_fm [j] B\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "ultimately"], ["proof (chain)\npicking this:\n  atom c \\<sharp> trans_fm [i] A\n  atom i \\<sharp> trans_fm [i] A\n  atom c \\<sharp> trans_fm [j] B\n  atom j \\<sharp> trans_fm [j] B", "have \"((i \\<leftrightarrow> c) \\<bullet> (trans_fm [i] A)) = ((j \\<leftrightarrow> c) \\<bullet> trans_fm [j] B)\""], ["proof (prove)\nusing this:\n  atom c \\<sharp> trans_fm [i] A\n  atom i \\<sharp> trans_fm [i] A\n  atom c \\<sharp> trans_fm [j] B\n  atom j \\<sharp> trans_fm [j] B\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> trans_fm [i] A =\n    (j \\<leftrightarrow> c) \\<bullet> trans_fm [j] B", "by (simp only: flip_fresh_fresh t)"], ["proof (state)\nthis:\n  (i \\<leftrightarrow> c) \\<bullet> trans_fm [i] A =\n  (j \\<leftrightarrow> c) \\<bullet> trans_fm [j] B\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "then"], ["proof (chain)\npicking this:\n  (i \\<leftrightarrow> c) \\<bullet> trans_fm [i] A =\n  (j \\<leftrightarrow> c) \\<bullet> trans_fm [j] B", "have \"trans_fm [c] ((i \\<leftrightarrow> c) \\<bullet> A) = trans_fm [c] ((j \\<leftrightarrow> c) \\<bullet> B)\""], ["proof (prove)\nusing this:\n  (i \\<leftrightarrow> c) \\<bullet> trans_fm [i] A =\n  (j \\<leftrightarrow> c) \\<bullet> trans_fm [j] B\n\ngoal (1 subgoal):\n 1. trans_fm [c] ((i \\<leftrightarrow> c) \\<bullet> A) =\n    trans_fm [c] ((j \\<leftrightarrow> c) \\<bullet> B)", "by simp"], ["proof (state)\nthis:\n  trans_fm [c] ((i \\<leftrightarrow> c) \\<bullet> A) =\n  trans_fm [c] ((j \\<leftrightarrow> c) \\<bullet> B)\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "then"], ["proof (chain)\npicking this:\n  trans_fm [c] ((i \\<leftrightarrow> c) \\<bullet> A) =\n  trans_fm [c] ((j \\<leftrightarrow> c) \\<bullet> B)", "show \"(i \\<leftrightarrow> c) \\<bullet> A = (j \\<leftrightarrow> c) \\<bullet> B\""], ["proof (prove)\nusing this:\n  trans_fm [c] ((i \\<leftrightarrow> c) \\<bullet> A) =\n  trans_fm [c] ((j \\<leftrightarrow> c) \\<bullet> B)\n\ngoal (1 subgoal):\n 1. (i \\<leftrightarrow> c) \\<bullet> A =\n    (j \\<leftrightarrow> c) \\<bullet> B", "by simp"], ["proof (state)\nthis:\n  (i \\<leftrightarrow> c) \\<bullet> A = (j \\<leftrightarrow> c) \\<bullet> B\n\ngoal:\nNo subgoals!", "qed"], ["", "section\\<open>Characterising the Well-Formed de Bruijn Formulas\\<close>"], ["", "subsection\\<open>Well-Formed Terms\\<close>"], ["", "inductive wf_dbtm :: \"dbtm \\<Rightarrow> bool\"\n  where\n    Zero:  \"wf_dbtm DBZero\"\n  | Var:   \"wf_dbtm (DBVar name)\"\n  | Eats:  \"wf_dbtm t1 \\<Longrightarrow> wf_dbtm t2 \\<Longrightarrow> wf_dbtm (DBEats t1 t2)\""], ["", "equivariance wf_dbtm"], ["", "inductive_cases Zero_wf_dbtm [elim!]: \"wf_dbtm DBZero\""], ["", "inductive_cases Var_wf_dbtm [elim!]:  \"wf_dbtm (DBVar name)\""], ["", "inductive_cases Ind_wf_dbtm [elim!]:  \"wf_dbtm (DBInd i)\""], ["", "inductive_cases Eats_wf_dbtm [elim!]: \"wf_dbtm (DBEats t1 t2)\""], ["", "declare wf_dbtm.intros [intro]"], ["", "lemma wf_dbtm_imp_is_tm:\n  assumes \"wf_dbtm x\"\n  shows \"\\<exists>t::tm. x = trans_tm [] t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. x = trans_tm [] t", "using assms"], ["proof (prove)\nusing this:\n  wf_dbtm x\n\ngoal (1 subgoal):\n 1. \\<exists>t. x = trans_tm [] t", "proof (induct rule: wf_dbtm.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>t. DBZero = trans_tm [] t\n 2. \\<And>name. \\<exists>t. DBVar name = trans_tm [] t\n 3. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "case Zero"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<exists>t. DBZero = trans_tm [] t\n 2. \\<And>name. \\<exists>t. DBVar name = trans_tm [] t\n 3. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. DBZero = trans_tm [] t", "by (metis trans_tm.simps(1))"], ["proof (state)\nthis:\n  \\<exists>t. DBZero = trans_tm [] t\n\ngoal (2 subgoals):\n 1. \\<And>name. \\<exists>t. DBVar name = trans_tm [] t\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>name. \\<exists>t. DBVar name = trans_tm [] t\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "case (Var i)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>name. \\<exists>t. DBVar name = trans_tm [] t\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. DBVar i = trans_tm [] t", "by (metis lookup.simps(1) trans_tm.simps(2))"], ["proof (state)\nthis:\n  \\<exists>t. DBVar i = trans_tm [] t\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "case (Eats dt1 dt2)"], ["proof (state)\nthis:\n  wf_dbtm dt1\n  \\<exists>t. dt1 = trans_tm [] t\n  wf_dbtm dt2\n  \\<exists>t. dt2 = trans_tm [] t\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; \\<exists>t. t1 = trans_tm [] t; wf_dbtm t2;\n        \\<exists>t. t2 = trans_tm [] t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t. DBEats t1 t2 = trans_tm [] t", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbtm dt1\n  \\<exists>t. dt1 = trans_tm [] t\n  wf_dbtm dt2\n  \\<exists>t. dt2 = trans_tm [] t\n\ngoal (1 subgoal):\n 1. \\<exists>t. DBEats dt1 dt2 = trans_tm [] t", "by (metis trans_tm.simps(3))"], ["proof (state)\nthis:\n  \\<exists>t. DBEats dt1 dt2 = trans_tm [] t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_dbtm_trans_tm: \"wf_dbtm (trans_tm [] t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dbtm (trans_tm [] t)", "by (induct t rule: tm.induct) auto"], ["", "theorem wf_dbtm_iff_is_tm: \"wf_dbtm x \\<longleftrightarrow> (\\<exists>t::tm. x = trans_tm [] t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dbtm x = (\\<exists>t. x = trans_tm [] t)", "by (metis wf_dbtm_imp_is_tm wf_dbtm_trans_tm)"], ["", "nominal_function abst_dbtm :: \"name \\<Rightarrow> nat \\<Rightarrow> dbtm \\<Rightarrow> dbtm\"\n  where\n   \"abst_dbtm name i DBZero = DBZero\"\n | \"abst_dbtm name i (DBVar name') = (if name = name' then DBInd i else DBVar name')\"\n | \"abst_dbtm name i (DBInd j) = DBInd j\"\n | \"abst_dbtm name i (DBEats t1 t2) = DBEats (abst_dbtm name i t1) (abst_dbtm name i t2)\""], ["proof (prove)\ngoal (13 subgoals):\n 1. eqvt abst_dbtm_graph_aux\n 2. \\<And>x y. abst_dbtm_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>name i. x = (name, i, DBZero) \\<Longrightarrow> P;\n        \\<And>name i name'. x = (name, i, DBVar name') \\<Longrightarrow> P;\n        \\<And>name i j. x = (name, i, DBInd j) \\<Longrightarrow> P;\n        \\<And>name i t1 t2.\n           x = (name, i, DBEats t1 t2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>name i namea ia.\n       (name, i, DBZero) = (namea, ia, DBZero) \\<Longrightarrow>\n       DBZero = DBZero\n 5. \\<And>name i namea ia name'.\n       (name, i, DBZero) = (namea, ia, DBVar name') \\<Longrightarrow>\n       DBZero = (if namea = name' then DBInd ia else DBVar name')\n 6. \\<And>name i namea ia j.\n       (name, i, DBZero) = (namea, ia, DBInd j) \\<Longrightarrow>\n       DBZero = DBInd j\n 7. \\<And>name i namea ia t1 t2.\n       \\<lbrakk>eqvt_at abst_dbtm_sumC (namea, ia, t1);\n        eqvt_at abst_dbtm_sumC (namea, ia, t2); True; True;\n        (name, i, DBZero) = (namea, ia, DBEats t1 t2)\\<rbrakk>\n       \\<Longrightarrow> DBZero =\n                         DBEats (abst_dbtm_sumC (namea, ia, t1))\n                          (abst_dbtm_sumC (namea, ia, t2))\n 8. \\<And>name i name' namea ia name'a.\n       (name, i, DBVar name') = (namea, ia, DBVar name'a) \\<Longrightarrow>\n       (if name = name' then DBInd i else DBVar name') =\n       (if namea = name'a then DBInd ia else DBVar name'a)\n 9. \\<And>name i name' namea ia j.\n       (name, i, DBVar name') = (namea, ia, DBInd j) \\<Longrightarrow>\n       (if name = name' then DBInd i else DBVar name') = DBInd j\n 10. \\<And>name i name' namea ia t1 t2.\n        \\<lbrakk>eqvt_at abst_dbtm_sumC (namea, ia, t1);\n         eqvt_at abst_dbtm_sumC (namea, ia, t2); True; True;\n         (name, i, DBVar name') = (namea, ia, DBEats t1 t2)\\<rbrakk>\n        \\<Longrightarrow> (if name = name' then DBInd i else DBVar name') =\n                          DBEats (abst_dbtm_sumC (namea, ia, t1))\n                           (abst_dbtm_sumC (namea, ia, t2))\nA total of 13 subgoals...", "apply (simp add: eqvt_def abst_dbtm_graph_aux_def, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P b.\n       \\<lbrakk>b = DBZero \\<Longrightarrow> P;\n        \\<And>name'. b = DBVar name' \\<Longrightarrow> P;\n        \\<And>j. b = DBInd j \\<Longrightarrow> P;\n        \\<And>t1 t2. b = DBEats t1 t2 \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis dbtm.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All abst_dbtm_dom", "by lexicographic_order"], ["", "nominal_function subst_dbtm :: \"dbtm \\<Rightarrow> name \\<Rightarrow> dbtm \\<Rightarrow> dbtm\"\n  where\n   \"subst_dbtm u i DBZero = DBZero\"\n | \"subst_dbtm u i (DBVar name) = (if i = name then u else DBVar name)\"\n | \"subst_dbtm u i (DBInd j) = DBInd j\"\n | \"subst_dbtm u i (DBEats t1 t2) = DBEats (subst_dbtm u i t1) (subst_dbtm u i t2)\""], ["proof (prove)\ngoal (13 subgoals):\n 1. eqvt subst_dbtm_graph_aux\n 2. \\<And>x y. subst_dbtm_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>u i. x = (u, i, DBZero) \\<Longrightarrow> P;\n        \\<And>u i name. x = (u, i, DBVar name) \\<Longrightarrow> P;\n        \\<And>u i j. x = (u, i, DBInd j) \\<Longrightarrow> P;\n        \\<And>u i t1 t2.\n           x = (u, i, DBEats t1 t2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>u i ua ia.\n       (u, i, DBZero) = (ua, ia, DBZero) \\<Longrightarrow> DBZero = DBZero\n 5. \\<And>u i ua ia name.\n       (u, i, DBZero) = (ua, ia, DBVar name) \\<Longrightarrow>\n       DBZero = (if ia = name then ua else DBVar name)\n 6. \\<And>u i ua ia j.\n       (u, i, DBZero) = (ua, ia, DBInd j) \\<Longrightarrow> DBZero = DBInd j\n 7. \\<And>u i ua ia t1 t2.\n       \\<lbrakk>eqvt_at subst_dbtm_sumC (ua, ia, t1);\n        eqvt_at subst_dbtm_sumC (ua, ia, t2); True; True;\n        (u, i, DBZero) = (ua, ia, DBEats t1 t2)\\<rbrakk>\n       \\<Longrightarrow> DBZero =\n                         DBEats (subst_dbtm_sumC (ua, ia, t1))\n                          (subst_dbtm_sumC (ua, ia, t2))\n 8. \\<And>u i name ua ia namea.\n       (u, i, DBVar name) = (ua, ia, DBVar namea) \\<Longrightarrow>\n       (if i = name then u else DBVar name) =\n       (if ia = namea then ua else DBVar namea)\n 9. \\<And>u i name ua ia j.\n       (u, i, DBVar name) = (ua, ia, DBInd j) \\<Longrightarrow>\n       (if i = name then u else DBVar name) = DBInd j\n 10. \\<And>u i name ua ia t1 t2.\n        \\<lbrakk>eqvt_at subst_dbtm_sumC (ua, ia, t1);\n         eqvt_at subst_dbtm_sumC (ua, ia, t2); True; True;\n         (u, i, DBVar name) = (ua, ia, DBEats t1 t2)\\<rbrakk>\n        \\<Longrightarrow> (if i = name then u else DBVar name) =\n                          DBEats (subst_dbtm_sumC (ua, ia, t1))\n                           (subst_dbtm_sumC (ua, ia, t2))\nA total of 13 subgoals...", "by (auto simp: eqvt_def subst_dbtm_graph_aux_def) (metis dbtm.exhaust)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All subst_dbtm_dom", "by lexicographic_order"], ["", "lemma fresh_iff_non_subst_dbtm: \"subst_dbtm DBZero i t = t \\<longleftrightarrow> atom i \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_dbtm DBZero i t = t) = atom i \\<sharp> t", "by (induct t rule: dbtm.induct) (auto simp: pure_fresh fresh_at_base(2))"], ["", "lemma lookup_append: \"lookup (e @ [i]) n j = abst_dbtm i (length e + n) (lookup e n j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (e @ [i]) n j = abst_dbtm i (length e + n) (lookup e n j)", "by (induct e arbitrary: n) (auto simp: fresh_Cons)"], ["", "lemma trans_tm_abs: \"trans_tm (e@[name]) t = abst_dbtm name (length e) (trans_tm e t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans_tm (e @ [name]) t = abst_dbtm name (length e) (trans_tm e t)", "by (induct t rule: tm.induct) (auto simp: lookup_notin lookup_append)"], ["", "subsection\\<open>Well-Formed Formulas\\<close>"], ["", "nominal_function abst_dbfm :: \"name \\<Rightarrow> nat \\<Rightarrow> dbfm \\<Rightarrow> dbfm\"\n  where\n   \"abst_dbfm name i (DBMem t1 t2) = DBMem (abst_dbtm name i t1) (abst_dbtm name i t2)\"\n | \"abst_dbfm name i (DBEq t1 t2) =  DBEq (abst_dbtm name i t1) (abst_dbtm name i t2)\"\n | \"abst_dbfm name i (DBDisj A1 A2) = DBDisj (abst_dbfm name i A1) (abst_dbfm name i A2)\"\n | \"abst_dbfm name i (DBNeg A) = DBNeg (abst_dbfm name i A)\"\n | \"abst_dbfm name i (DBEx A) = DBEx (abst_dbfm name (i+1) A)\""], ["proof (prove)\ngoal (18 subgoals):\n 1. eqvt abst_dbfm_graph_aux\n 2. \\<And>x y. abst_dbfm_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>name i t1 t2.\n                   x = (name, i, DBMem t1 t2) \\<Longrightarrow> P;\n        \\<And>name i t1 t2. x = (name, i, DBEq t1 t2) \\<Longrightarrow> P;\n        \\<And>name i A1 A2. x = (name, i, DBDisj A1 A2) \\<Longrightarrow> P;\n        \\<And>name i A. x = (name, i, DBNeg A) \\<Longrightarrow> P;\n        \\<And>name i A. x = (name, i, DBEx A) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>name i t1 t2 namea ia t1a t2a.\n       (name, i, DBMem t1 t2) = (namea, ia, DBMem t1a t2a) \\<Longrightarrow>\n       DBMem (abst_dbtm name i t1) (abst_dbtm name i t2) =\n       DBMem (abst_dbtm namea ia t1a) (abst_dbtm namea ia t2a)\n 5. \\<And>name i t1 t2 namea ia t1a t2a.\n       (name, i, DBMem t1 t2) = (namea, ia, DBEq t1a t2a) \\<Longrightarrow>\n       DBMem (abst_dbtm name i t1) (abst_dbtm name i t2) =\n       DBEq (abst_dbtm namea ia t1a) (abst_dbtm namea ia t2a)\n 6. \\<And>name i t1 t2 namea ia A1 A2.\n       \\<lbrakk>eqvt_at abst_dbfm_sumC (namea, ia, A1);\n        eqvt_at abst_dbfm_sumC (namea, ia, A2); True; True;\n        (name, i, DBMem t1 t2) = (namea, ia, DBDisj A1 A2)\\<rbrakk>\n       \\<Longrightarrow> DBMem (abst_dbtm name i t1) (abst_dbtm name i t2) =\n                         DBDisj (abst_dbfm_sumC (namea, ia, A1))\n                          (abst_dbfm_sumC (namea, ia, A2))\n 7. \\<And>name i t1 t2 namea ia A.\n       \\<lbrakk>eqvt_at abst_dbfm_sumC (namea, ia, A); True;\n        (name, i, DBMem t1 t2) = (namea, ia, DBNeg A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (abst_dbtm name i t1) (abst_dbtm name i t2) =\n                         DBNeg (abst_dbfm_sumC (namea, ia, A))\n 8. \\<And>name i t1 t2 namea ia A.\n       \\<lbrakk>eqvt_at abst_dbfm_sumC (namea, ia + 1, A); True;\n        (name, i, DBMem t1 t2) = (namea, ia, DBEx A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (abst_dbtm name i t1) (abst_dbtm name i t2) =\n                         DBEx (abst_dbfm_sumC (namea, ia + 1, A))\n 9. \\<And>name i t1 t2 namea ia t1a t2a.\n       (name, i, DBEq t1 t2) = (namea, ia, DBEq t1a t2a) \\<Longrightarrow>\n       DBEq (abst_dbtm name i t1) (abst_dbtm name i t2) =\n       DBEq (abst_dbtm namea ia t1a) (abst_dbtm namea ia t2a)\n 10. \\<And>name i t1 t2 namea ia A1 A2.\n        \\<lbrakk>eqvt_at abst_dbfm_sumC (namea, ia, A1);\n         eqvt_at abst_dbfm_sumC (namea, ia, A2); True; True;\n         (name, i, DBEq t1 t2) = (namea, ia, DBDisj A1 A2)\\<rbrakk>\n        \\<Longrightarrow> DBEq (abst_dbtm name i t1) (abst_dbtm name i t2) =\n                          DBDisj (abst_dbfm_sumC (namea, ia, A1))\n                           (abst_dbfm_sumC (namea, ia, A2))\nA total of 18 subgoals...", "apply (simp add: eqvt_def abst_dbfm_graph_aux_def, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P b.\n       \\<lbrakk>\\<And>t1 t2. b = DBMem t1 t2 \\<Longrightarrow> P;\n        \\<And>t1 t2. b = DBEq t1 t2 \\<Longrightarrow> P;\n        \\<And>A1 A2. b = DBDisj A1 A2 \\<Longrightarrow> P;\n        \\<And>A. b = DBNeg A \\<Longrightarrow> P;\n        \\<And>A. b = DBEx A \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis dbfm.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All abst_dbfm_dom", "by lexicographic_order"], ["", "nominal_function subst_dbfm :: \"dbtm \\<Rightarrow> name \\<Rightarrow> dbfm \\<Rightarrow> dbfm\"\n  where\n   \"subst_dbfm u i (DBMem t1 t2) = DBMem (subst_dbtm u i t1) (subst_dbtm u i t2)\"\n | \"subst_dbfm u i (DBEq t1 t2) =  DBEq (subst_dbtm u i t1) (subst_dbtm u i t2)\"\n | \"subst_dbfm u i (DBDisj A1 A2) = DBDisj (subst_dbfm u i A1) (subst_dbfm u i A2)\"\n | \"subst_dbfm u i (DBNeg A) = DBNeg (subst_dbfm u i A)\"\n | \"subst_dbfm u i (DBEx A) = DBEx (subst_dbfm u i A)\""], ["proof (prove)\ngoal (18 subgoals):\n 1. eqvt subst_dbfm_graph_aux\n 2. \\<And>x y. subst_dbfm_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>u i t1 t2.\n                   x = (u, i, DBMem t1 t2) \\<Longrightarrow> P;\n        \\<And>u i t1 t2. x = (u, i, DBEq t1 t2) \\<Longrightarrow> P;\n        \\<And>u i A1 A2. x = (u, i, DBDisj A1 A2) \\<Longrightarrow> P;\n        \\<And>u i A. x = (u, i, DBNeg A) \\<Longrightarrow> P;\n        \\<And>u i A. x = (u, i, DBEx A) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>u i t1 t2 ua ia t1a t2a.\n       (u, i, DBMem t1 t2) = (ua, ia, DBMem t1a t2a) \\<Longrightarrow>\n       DBMem (subst_dbtm u i t1) (subst_dbtm u i t2) =\n       DBMem (subst_dbtm ua ia t1a) (subst_dbtm ua ia t2a)\n 5. \\<And>u i t1 t2 ua ia t1a t2a.\n       (u, i, DBMem t1 t2) = (ua, ia, DBEq t1a t2a) \\<Longrightarrow>\n       DBMem (subst_dbtm u i t1) (subst_dbtm u i t2) =\n       DBEq (subst_dbtm ua ia t1a) (subst_dbtm ua ia t2a)\n 6. \\<And>u i t1 t2 ua ia A1 A2.\n       \\<lbrakk>eqvt_at subst_dbfm_sumC (ua, ia, A1);\n        eqvt_at subst_dbfm_sumC (ua, ia, A2); True; True;\n        (u, i, DBMem t1 t2) = (ua, ia, DBDisj A1 A2)\\<rbrakk>\n       \\<Longrightarrow> DBMem (subst_dbtm u i t1) (subst_dbtm u i t2) =\n                         DBDisj (subst_dbfm_sumC (ua, ia, A1))\n                          (subst_dbfm_sumC (ua, ia, A2))\n 7. \\<And>u i t1 t2 ua ia A.\n       \\<lbrakk>eqvt_at subst_dbfm_sumC (ua, ia, A); True;\n        (u, i, DBMem t1 t2) = (ua, ia, DBNeg A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (subst_dbtm u i t1) (subst_dbtm u i t2) =\n                         DBNeg (subst_dbfm_sumC (ua, ia, A))\n 8. \\<And>u i t1 t2 ua ia A.\n       \\<lbrakk>eqvt_at subst_dbfm_sumC (ua, ia, A); True;\n        (u, i, DBMem t1 t2) = (ua, ia, DBEx A)\\<rbrakk>\n       \\<Longrightarrow> DBMem (subst_dbtm u i t1) (subst_dbtm u i t2) =\n                         DBEx (subst_dbfm_sumC (ua, ia, A))\n 9. \\<And>u i t1 t2 ua ia t1a t2a.\n       (u, i, DBEq t1 t2) = (ua, ia, DBEq t1a t2a) \\<Longrightarrow>\n       DBEq (subst_dbtm u i t1) (subst_dbtm u i t2) =\n       DBEq (subst_dbtm ua ia t1a) (subst_dbtm ua ia t2a)\n 10. \\<And>u i t1 t2 ua ia A1 A2.\n        \\<lbrakk>eqvt_at subst_dbfm_sumC (ua, ia, A1);\n         eqvt_at subst_dbfm_sumC (ua, ia, A2); True; True;\n         (u, i, DBEq t1 t2) = (ua, ia, DBDisj A1 A2)\\<rbrakk>\n        \\<Longrightarrow> DBEq (subst_dbtm u i t1) (subst_dbtm u i t2) =\n                          DBDisj (subst_dbfm_sumC (ua, ia, A1))\n                           (subst_dbfm_sumC (ua, ia, A2))\nA total of 18 subgoals...", "by (auto simp: eqvt_def subst_dbfm_graph_aux_def) (metis dbfm.exhaust)"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All subst_dbfm_dom", "by lexicographic_order"], ["", "lemma fresh_iff_non_subst_dbfm: \"subst_dbfm DBZero i t = t \\<longleftrightarrow> atom i \\<sharp> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_dbfm DBZero i t = t) = atom i \\<sharp> t", "by (induct t rule: dbfm.induct) (auto simp: fresh_iff_non_subst_dbtm)"], ["", "section\\<open>Well formed terms and formulas (de Bruijn representation)\\<close>"], ["", "inductive wf_dbfm :: \"dbfm \\<Rightarrow> bool\"\n  where\n    Mem:   \"wf_dbtm t1 \\<Longrightarrow> wf_dbtm t2 \\<Longrightarrow> wf_dbfm (DBMem t1 t2)\"\n  | Eq:    \"wf_dbtm t1 \\<Longrightarrow> wf_dbtm t2 \\<Longrightarrow> wf_dbfm (DBEq t1 t2)\"\n  | Disj:  \"wf_dbfm A1 \\<Longrightarrow> wf_dbfm A2 \\<Longrightarrow> wf_dbfm (DBDisj A1 A2)\"\n  | Neg:   \"wf_dbfm A \\<Longrightarrow> wf_dbfm (DBNeg A)\"\n  | Ex:    \"wf_dbfm A \\<Longrightarrow> wf_dbfm (DBEx (abst_dbfm name 0 A))\""], ["", "equivariance wf_dbfm"], ["", "lemma atom_fresh_abst_dbtm [simp]: \"atom i \\<sharp> abst_dbtm i n t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> abst_dbtm i n t", "by (induct t rule: dbtm.induct) (auto simp: pure_fresh)"], ["", "lemma atom_fresh_abst_dbfm [simp]: \"atom i \\<sharp> abst_dbfm i n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> abst_dbfm i n A", "by (nominal_induct A arbitrary: n rule: dbfm.strong_induct) auto"], ["", "text\\<open>Setting up strong induction: \"avoiding\" for name. Necessary to allow some proofs to go through\\<close>"], ["", "nominal_inductive wf_dbfm\n  avoids Ex: name"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A name.\n        wf_dbfm A \\<Longrightarrow>\n        {atom name} \\<sharp>* DBEx (abst_dbfm name 0 A)) &&&\n    (\\<And>A name. wf_dbfm A \\<Longrightarrow> finite {atom name})", "by (auto simp: fresh_star_def)"], ["", "inductive_cases Mem_wf_dbfm [elim!]:  \"wf_dbfm (DBMem t1 t2)\""], ["", "inductive_cases Eq_wf_dbfm [elim!]:   \"wf_dbfm (DBEq t1 t2)\""], ["", "inductive_cases Disj_wf_dbfm [elim!]: \"wf_dbfm (DBDisj A1 A2)\""], ["", "inductive_cases Neg_wf_dbfm [elim!]:  \"wf_dbfm (DBNeg A)\""], ["", "inductive_cases Ex_wf_dbfm [elim!]:   \"wf_dbfm (DBEx z)\""], ["", "declare wf_dbfm.intros [intro]"], ["", "lemma trans_fm_abs: \"trans_fm (e@[name]) A = abst_dbfm name (length e) (trans_fm e A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans_fm (e @ [name]) A = abst_dbfm name (length e) (trans_fm e A)", "apply (nominal_induct A avoiding: name e rule: fm.strong_induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 name e.\n       trans_fm (e @ [name]) (x1 IN x2) =\n       abst_dbfm name (length e) (trans_fm e (x1 IN x2))\n 2. \\<And>x1 x2 name e.\n       trans_fm (e @ [name]) (x1 EQ x2) =\n       abst_dbfm name (length e) (trans_fm e (x1 EQ x2))\n 3. \\<And>x1 x2 name e.\n       \\<lbrakk>\\<And>b ba.\n                   trans_fm (ba @ [b]) x1 =\n                   abst_dbfm b (length ba) (trans_fm ba x1);\n        \\<And>b ba.\n           trans_fm (ba @ [b]) x2 =\n           abst_dbfm b (length ba) (trans_fm ba x2)\\<rbrakk>\n       \\<Longrightarrow> trans_fm (e @ [name]) (x1 OR x2) =\n                         abst_dbfm name (length e) (trans_fm e (x1 OR x2))\n 4. \\<And>x name e.\n       (\\<And>b ba.\n           trans_fm (ba @ [b]) x =\n           abst_dbfm b (length ba) (trans_fm ba x)) \\<Longrightarrow>\n       trans_fm (e @ [name]) (Neg x) =\n       abst_dbfm name (length e) (trans_fm e (Neg x))\n 5. \\<And>x1 x2 name e.\n       \\<lbrakk>atom x1 \\<sharp> name; atom x1 \\<sharp> e;\n        \\<And>b ba.\n           trans_fm (ba @ [b]) x2 =\n           abst_dbfm b (length ba) (trans_fm ba x2)\\<rbrakk>\n       \\<Longrightarrow> trans_fm (e @ [name]) (SyntaxN.Ex x1 x2) =\n                         abst_dbfm name (length e)\n                          (trans_fm e (SyntaxN.Ex x1 x2))", "apply (auto simp: trans_tm_abs fresh_Cons fresh_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 name e.\n       \\<lbrakk>atom x1 \\<sharp> name; atom x1 \\<sharp> e;\n        \\<And>b ba.\n           trans_fm (ba @ [b]) x2 =\n           abst_dbfm b (length ba) (trans_fm ba x2)\\<rbrakk>\n       \\<Longrightarrow> trans_fm (x1 # e @ [name]) x2 =\n                         abst_dbfm name (Suc (length e))\n                          (trans_fm (x1 # e) x2)", "apply (metis One_nat_def Suc_eq_plus1 append_Cons list.size(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma abst_trans_fm: \"abst_dbfm name 0 (trans_fm [] A) = trans_fm [name] A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst_dbfm name 0 (trans_fm [] A) = trans_fm [name] A", "by (metis append_Nil list.size(3) trans_fm_abs)"], ["", "lemma abst_trans_fm2: \"i \\<noteq> j \\<Longrightarrow> abst_dbfm i (Suc 0) (trans_fm [j] A) = trans_fm [j,i] A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    abst_dbfm i (Suc 0) (trans_fm [j] A) = trans_fm [j, i] A", "using trans_fm_abs [where e=\"[j]\" and name=i]"], ["proof (prove)\nusing this:\n  trans_fm ([j] @ [i]) ?A = abst_dbfm i (length [j]) (trans_fm [j] ?A)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    abst_dbfm i (Suc 0) (trans_fm [j] A) = trans_fm [j, i] A", "by auto"], ["", "lemma wf_dbfm_imp_is_fm:\n  assumes \"wf_dbfm x\" shows \"\\<exists>A::fm. x = trans_fm [] A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. x = trans_fm [] A", "using assms"], ["proof (prove)\nusing this:\n  wf_dbfm x\n\ngoal (1 subgoal):\n 1. \\<exists>A. x = trans_fm [] A", "proof (induct rule: wf_dbfm.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBMem t1 t2 = trans_fm [] A\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBEq t1 t2 = trans_fm [] A\n 3. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 4. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 5. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "case (Mem t1 t2)"], ["proof (state)\nthis:\n  wf_dbtm t1\n  wf_dbtm t2\n\ngoal (5 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBMem t1 t2 = trans_fm [] A\n 2. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBEq t1 t2 = trans_fm [] A\n 3. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 4. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 5. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbtm t1\n  wf_dbtm t2\n\ngoal (1 subgoal):\n 1. \\<exists>A. DBMem t1 t2 = trans_fm [] A", "by (metis trans_fm.simps(1) wf_dbtm_imp_is_tm)"], ["proof (state)\nthis:\n  \\<exists>A. DBMem t1 t2 = trans_fm [] A\n\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBEq t1 t2 = trans_fm [] A\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBEq t1 t2 = trans_fm [] A\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "case (Eq t1 t2)"], ["proof (state)\nthis:\n  wf_dbtm t1\n  wf_dbtm t2\n\ngoal (4 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>wf_dbtm t1; wf_dbtm t2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBEq t1 t2 = trans_fm [] A\n 2. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 3. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 4. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbtm t1\n  wf_dbtm t2\n\ngoal (1 subgoal):\n 1. \\<exists>A. DBEq t1 t2 = trans_fm [] A", "by (metis trans_fm.simps(2) wf_dbtm_imp_is_tm)"], ["proof (state)\nthis:\n  \\<exists>A. DBEq t1 t2 = trans_fm [] A\n\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "case (Disj fm1 fm2)"], ["proof (state)\nthis:\n  wf_dbfm fm1\n  \\<exists>A. fm1 = trans_fm [] A\n  wf_dbfm fm2\n  \\<exists>A. fm2 = trans_fm [] A\n\ngoal (3 subgoals):\n 1. \\<And>A1 A2.\n       \\<lbrakk>wf_dbfm A1; \\<exists>A. A1 = trans_fm [] A; wf_dbfm A2;\n        \\<exists>A. A2 = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. DBDisj A1 A2 = trans_fm [] A\n 2. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 3. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbfm fm1\n  \\<exists>A. fm1 = trans_fm [] A\n  wf_dbfm fm2\n  \\<exists>A. fm2 = trans_fm [] A\n\ngoal (1 subgoal):\n 1. \\<exists>A. DBDisj fm1 fm2 = trans_fm [] A", "by (metis trans_fm.simps(3))"], ["proof (state)\nthis:\n  \\<exists>A. DBDisj fm1 fm2 = trans_fm [] A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "case (Neg fm)"], ["proof (state)\nthis:\n  wf_dbfm fm\n  \\<exists>A. fm = trans_fm [] A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa. DBNeg A = trans_fm [] Aa\n 2. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbfm fm\n  \\<exists>A. fm = trans_fm [] A\n\ngoal (1 subgoal):\n 1. \\<exists>A. DBNeg fm = trans_fm [] A", "by (metis trans_fm.simps(4))"], ["proof (state)\nthis:\n  \\<exists>A. DBNeg fm = trans_fm [] A\n\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "case (Ex fm name)"], ["proof (state)\nthis:\n  wf_dbfm fm\n  \\<exists>A. fm = trans_fm [] A\n\ngoal (1 subgoal):\n 1. \\<And>A name.\n       \\<lbrakk>wf_dbfm A; \\<exists>Aa. A = trans_fm [] Aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 A) = trans_fm [] Aa", "thus ?case"], ["proof (prove)\nusing this:\n  wf_dbfm fm\n  \\<exists>A. fm = trans_fm [] A\n\ngoal (1 subgoal):\n 1. \\<exists>A. DBEx (abst_dbfm name 0 fm) = trans_fm [] A", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm (trans_fm [] A); fm = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            DBEx (abst_dbfm name 0 (trans_fm [] A)) =\n                            trans_fm [] Aa", "apply (rule_tac x=\"Ex name A\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>wf_dbfm (trans_fm [] A); fm = trans_fm [] A\\<rbrakk>\n       \\<Longrightarrow> DBEx (abst_dbfm name 0 (trans_fm [] A)) =\n                         trans_fm [] (SyntaxN.Ex name A)", "apply (auto simp: abst_trans_fm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>A. DBEx (abst_dbfm name 0 fm) = trans_fm [] A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_dbfm_trans_fm: \"wf_dbfm (trans_fm [] A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dbfm (trans_fm [] A)", "apply (nominal_induct A rule: fm.strong_induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2. wf_dbfm (trans_fm [] (x1 IN x2))\n 2. \\<And>x1 x2. wf_dbfm (trans_fm [] (x1 EQ x2))\n 3. \\<And>x1 x2.\n       \\<lbrakk>wf_dbfm (trans_fm [] x1); wf_dbfm (trans_fm [] x2)\\<rbrakk>\n       \\<Longrightarrow> wf_dbfm (trans_fm [] (x1 OR x2))\n 4. \\<And>x.\n       wf_dbfm (trans_fm [] x) \\<Longrightarrow>\n       wf_dbfm (trans_fm [] (Neg x))\n 5. \\<And>x1 x2.\n       wf_dbfm (trans_fm [] x2) \\<Longrightarrow>\n       wf_dbfm (trans_fm [] (SyntaxN.Ex x1 x2))", "apply (auto simp: wf_dbtm_trans_tm abst_trans_fm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       wf_dbfm (trans_fm [] x2) \\<Longrightarrow>\n       wf_dbfm (DBEx (trans_fm [x1] x2))", "apply (metis abst_trans_fm wf_dbfm.Ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_dbfm_iff_is_fm: \"wf_dbfm x \\<longleftrightarrow> (\\<exists>A::fm. x = trans_fm [] A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_dbfm x = (\\<exists>A. x = trans_fm [] A)", "by (metis wf_dbfm_imp_is_fm wf_dbfm_trans_fm)"], ["", "lemma dbtm_abst_ignore [simp]:\n  \"abst_dbtm name i (abst_dbtm name j t) = abst_dbtm name j t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abst_dbtm name i (abst_dbtm name j t) = abst_dbtm name j t", "by (induct t rule: dbtm.induct) auto"], ["", "lemma abst_dbtm_fresh_ignore [simp]: \"atom name \\<sharp> u \\<Longrightarrow> abst_dbtm name j u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom name \\<sharp> u \\<Longrightarrow> abst_dbtm name j u = u", "by (induct u rule: dbtm.induct) auto"], ["", "lemma dbtm_subst_ignore [simp]:\n  \"subst_dbtm u name (abst_dbtm name j t) = abst_dbtm name j t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_dbtm u name (abst_dbtm name j t) = abst_dbtm name j t", "by (induct t rule: dbtm.induct) auto"], ["", "lemma dbtm_abst_swap_subst:\n  \"name \\<noteq> name' \\<Longrightarrow> atom name' \\<sharp> u \\<Longrightarrow>\n   subst_dbtm u name (abst_dbtm name' j t) = abst_dbtm name' j (subst_dbtm u name t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name \\<noteq> name'; atom name' \\<sharp> u\\<rbrakk>\n    \\<Longrightarrow> subst_dbtm u name (abst_dbtm name' j t) =\n                      abst_dbtm name' j (subst_dbtm u name t)", "by (induct t rule: dbtm.induct) auto"], ["", "lemma dbfm_abst_swap_subst:\n  \"name \\<noteq> name' \\<Longrightarrow> atom name' \\<sharp> u \\<Longrightarrow>\n   subst_dbfm u name (abst_dbfm name' j A) = abst_dbfm name' j (subst_dbfm u name A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name \\<noteq> name'; atom name' \\<sharp> u\\<rbrakk>\n    \\<Longrightarrow> subst_dbfm u name (abst_dbfm name' j A) =\n                      abst_dbfm name' j (subst_dbfm u name A)", "by (induct A arbitrary: j rule: dbfm.induct) (auto simp: dbtm_abst_swap_subst)"], ["", "lemma subst_trans_commute [simp]:\n  \"atom i \\<sharp> e \\<Longrightarrow> subst_dbtm (trans_tm e u) i (trans_tm e t) = trans_tm e (subst i u t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<sharp> e \\<Longrightarrow>\n    subst_dbtm (trans_tm e u) i (trans_tm e t) = trans_tm e (subst i u t)", "apply (induct t rule: tm.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. atom i \\<sharp> e \\<Longrightarrow>\n    subst_dbtm (trans_tm e u) i (trans_tm e Zero) =\n    trans_tm e (subst i u Zero)\n 2. \\<And>x.\n       atom i \\<sharp> e \\<Longrightarrow>\n       subst_dbtm (trans_tm e u) i (trans_tm e (Var x)) =\n       trans_tm e (subst i u (Var x))\n 3. \\<And>x1 x2a.\n       \\<lbrakk>atom i \\<sharp> e \\<Longrightarrow>\n                subst_dbtm (trans_tm e u) i (trans_tm e x1) =\n                trans_tm e (subst i u x1);\n        atom i \\<sharp> e \\<Longrightarrow>\n        subst_dbtm (trans_tm e u) i (trans_tm e x2a) =\n        trans_tm e (subst i u x2a);\n        atom i \\<sharp> e\\<rbrakk>\n       \\<Longrightarrow> subst_dbtm (trans_tm e u) i\n                          (trans_tm e (Eats x1 x2a)) =\n                         trans_tm e (subst i u (Eats x1 x2a))", "apply (auto simp: lookup_notin fresh_imp_notin_env)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>atom i \\<sharp> e; i \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> subst_dbtm (trans_tm e u) i (lookup e 0 x) =\n                         lookup e 0 x", "apply (metis abst_dbtm_fresh_ignore dbtm_subst_ignore lookup_fresh lookup_notin subst_dbtm.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_fm_trans_commute [simp]:\n  \"subst_dbfm (trans_tm [] u) name (trans_fm [] A) = trans_fm [] (A (name::= u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_dbfm (trans_tm [] u) name (trans_fm [] A) =\n    trans_fm [] (A(name::=u))", "apply (nominal_induct A avoiding: name u rule: fm.strong_induct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 name u.\n       subst_dbfm (trans_tm [] u) name (trans_fm [] (x1 IN x2)) =\n       trans_fm [] ((x1 IN x2)(name::=u))\n 2. \\<And>x1 x2 name u.\n       subst_dbfm (trans_tm [] u) name (trans_fm [] (x1 EQ x2)) =\n       trans_fm [] ((x1 EQ x2)(name::=u))\n 3. \\<And>x1 x2 name u.\n       \\<lbrakk>\\<And>b ba.\n                   subst_dbfm (trans_tm [] ba) b (trans_fm [] x1) =\n                   trans_fm [] (x1(b::=ba));\n        \\<And>b ba.\n           subst_dbfm (trans_tm [] ba) b (trans_fm [] x2) =\n           trans_fm [] (x2(b::=ba))\\<rbrakk>\n       \\<Longrightarrow> subst_dbfm (trans_tm [] u) name\n                          (trans_fm [] (x1 OR x2)) =\n                         trans_fm [] ((x1 OR x2)(name::=u))\n 4. \\<And>x name u.\n       (\\<And>b ba.\n           subst_dbfm (trans_tm [] ba) b (trans_fm [] x) =\n           trans_fm [] (x(b::=ba))) \\<Longrightarrow>\n       subst_dbfm (trans_tm [] u) name (trans_fm [] (Neg x)) =\n       trans_fm [] ((Neg x)(name::=u))\n 5. \\<And>x1 x2 name u.\n       \\<lbrakk>atom x1 \\<sharp> name; atom x1 \\<sharp> u;\n        \\<And>b ba.\n           subst_dbfm (trans_tm [] ba) b (trans_fm [] x2) =\n           trans_fm [] (x2(b::=ba))\\<rbrakk>\n       \\<Longrightarrow> subst_dbfm (trans_tm [] u) name\n                          (trans_fm [] (SyntaxN.Ex x1 x2)) =\n                         trans_fm [] ((SyntaxN.Ex x1 x2)(name::=u))", "apply (auto simp: lookup_notin abst_trans_fm [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 name u.\n       \\<lbrakk>atom x1 \\<sharp> name; atom x1 \\<sharp> u;\n        \\<And>b ba.\n           subst_dbfm (trans_tm [] ba) b (trans_fm [] x2) =\n           trans_fm [] (x2(b::=ba))\\<rbrakk>\n       \\<Longrightarrow> subst_dbfm (trans_tm [] u) name\n                          (abst_dbfm x1 0 (trans_fm [] x2)) =\n                         abst_dbfm x1 0 (trans_fm [] (x2(name::=u)))", "apply (metis dbfm_abst_swap_subst fresh_at_base(2) fresh_trans_tm_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_fm_trans_commute_eq:\n  \"du = trans_tm [] u \\<Longrightarrow> subst_dbfm du i (trans_fm [] A) = trans_fm [] (A(i::=u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. du = trans_tm [] u \\<Longrightarrow>\n    subst_dbfm du i (trans_fm [] A) = trans_fm [] (A(i::=u))", "by (metis subst_fm_trans_commute)"], ["", "section\\<open>Quotations\\<close>"], ["", "fun HTuple :: \"nat \\<Rightarrow> tm\"  where\n   \"HTuple 0 = HPair Zero Zero\"\n | \"HTuple (Suc k) = HPair Zero (HTuple k)\""], ["", "lemma fresh_HTuple [simp]: \"x \\<sharp> HTuple n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sharp> HTuple n", "by (induct n) auto"], ["", "lemma HTuple_eqvt[eqvt]: \"(p \\<bullet> HTuple n) = HTuple (p \\<bullet> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> HTuple n = HTuple (p \\<bullet> n)", "by (induct n, auto simp: HPair_eqvt permute_pure)"], ["", "subsection \\<open>Quotations of de Bruijn terms\\<close>"], ["", "definition nat_of_name :: \"name \\<Rightarrow> nat\"\n  where \"nat_of_name x = nat_of (atom x)\""], ["", "lemma nat_of_name_inject [simp]: \"nat_of_name n1 = nat_of_name n2 \\<longleftrightarrow> n1 = n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat_of_name n1 = nat_of_name n2) = (n1 = n2)", "by (metis nat_of_name_def atom_components_eq_iff atom_eq_iff sort_of_atom_eq)"], ["", "definition name_of_nat :: \"nat \\<Rightarrow> name\"\n  where \"name_of_nat n \\<equiv> Abs_name (Atom (Sort ''SyntaxN.name'' []) n)\""], ["", "lemma nat_of_name_Abs_eq [simp]: \"nat_of_name (Abs_name (Atom (Sort ''SyntaxN.name'' []) n)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_name (Abs_name (Atom (Sort ''SyntaxN.name'' []) n)) = n", "by (auto simp: nat_of_name_def atom_name_def Abs_name_inverse)"], ["", "lemma nat_of_name_name_eq [simp]: \"nat_of_name (name_of_nat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_name (name_of_nat n) = n", "by (simp add: name_of_nat_def)"], ["", "lemma name_of_nat_nat_of_name [simp]: \"name_of_nat (nat_of_name i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. name_of_nat (nat_of_name i) = i", "by (metis nat_of_name_inject nat_of_name_name_eq)"], ["", "lemma HPair_neq_ORD_OF [simp]: \"HPair x y \\<noteq> ORD_OF i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HPair x y \\<noteq> ORD_OF i", "by (metis HPair_def ORD_OF.elims SUCC_def tm.distinct(3) tm.eq_iff(3))"], ["", "text\\<open>Infinite support, so we cannot use nominal primrec.\\<close>"], ["", "function quot_dbtm :: \"dbtm \\<Rightarrow> tm\"\n  where\n   \"quot_dbtm DBZero = Zero\"\n | \"quot_dbtm (DBVar name) = ORD_OF (Suc (nat_of_name name))\"\n | \"quot_dbtm (DBInd k) = HPair (HTuple 6) (ORD_OF k)\"\n | \"quot_dbtm (DBEats t u) = HPair (HTuple 1) (HPair (quot_dbtm t) (quot_dbtm u))\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = DBZero \\<Longrightarrow> P;\n        \\<And>name. x = DBVar name \\<Longrightarrow> P;\n        \\<And>k. x = DBInd k \\<Longrightarrow> P;\n        \\<And>t u. x = DBEats t u \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. DBZero = DBZero \\<Longrightarrow> Zero = Zero\n 3. \\<And>name.\n       DBZero = DBVar name \\<Longrightarrow>\n       Zero = ORD_OF (Suc (nat_of_name name))\n 4. \\<And>k.\n       DBZero = DBInd k \\<Longrightarrow> Zero = HPair (HTuple 6) (ORD_OF k)\n 5. \\<And>t u.\n       DBZero = DBEats t u \\<Longrightarrow>\n       Zero = HPair (HTuple 1) (HPair (quot_dbtm_sumC t) (quot_dbtm_sumC u))\n 6. \\<And>name namea.\n       DBVar name = DBVar namea \\<Longrightarrow>\n       ORD_OF (Suc (nat_of_name name)) = ORD_OF (Suc (nat_of_name namea))\n 7. \\<And>name k.\n       DBVar name = DBInd k \\<Longrightarrow>\n       ORD_OF (Suc (nat_of_name name)) = HPair (HTuple 6) (ORD_OF k)\n 8. \\<And>name t u.\n       DBVar name = DBEats t u \\<Longrightarrow>\n       ORD_OF (Suc (nat_of_name name)) =\n       HPair (HTuple 1) (HPair (quot_dbtm_sumC t) (quot_dbtm_sumC u))\n 9. \\<And>k ka.\n       DBInd k = DBInd ka \\<Longrightarrow>\n       HPair (HTuple 6) (ORD_OF k) = HPair (HTuple 6) (ORD_OF ka)\n 10. \\<And>k t u.\n        DBInd k = DBEats t u \\<Longrightarrow>\n        HPair (HTuple 6) (ORD_OF k) =\n        HPair (HTuple 1) (HPair (quot_dbtm_sumC t) (quot_dbtm_sumC u))\nA total of 11 subgoals...", "by (rule dbtm.exhaust) auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All quot_dbtm_dom", "by lexicographic_order"], ["", "subsection \\<open>Quotations of de Bruijn formulas\\<close>"], ["", "text\\<open>Infinite support, so we cannot use nominal primrec.\\<close>"], ["", "function quot_dbfm :: \"dbfm \\<Rightarrow> tm\"\n  where\n   \"quot_dbfm (DBMem t u) = HPair (HTuple 0) (HPair (quot_dbtm t) (quot_dbtm u))\"\n | \"quot_dbfm (DBEq t u) = HPair (HTuple 2) (HPair (quot_dbtm t) (quot_dbtm u))\"\n | \"quot_dbfm (DBDisj A B) = HPair (HTuple 3) (HPair (quot_dbfm A) (quot_dbfm B))\"\n | \"quot_dbfm (DBNeg A) = HPair (HTuple 4) (quot_dbfm A)\"\n | \"quot_dbfm (DBEx A) = HPair (HTuple 5) (quot_dbfm A)\""], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>t u. x = DBMem t u \\<Longrightarrow> P;\n        \\<And>t u. x = DBEq t u \\<Longrightarrow> P;\n        \\<And>A B. x = DBDisj A B \\<Longrightarrow> P;\n        \\<And>A. x = DBNeg A \\<Longrightarrow> P;\n        \\<And>A. x = DBEx A \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>t u ta ua.\n       DBMem t u = DBMem ta ua \\<Longrightarrow>\n       HPair (HTuple 0) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 0) (HPair (quot_dbtm ta) (quot_dbtm ua))\n 3. \\<And>t u ta ua.\n       DBMem t u = DBEq ta ua \\<Longrightarrow>\n       HPair (HTuple 0) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 2) (HPair (quot_dbtm ta) (quot_dbtm ua))\n 4. \\<And>t u A B.\n       DBMem t u = DBDisj A B \\<Longrightarrow>\n       HPair (HTuple 0) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 3) (HPair (quot_dbfm_sumC A) (quot_dbfm_sumC B))\n 5. \\<And>t u A.\n       DBMem t u = DBNeg A \\<Longrightarrow>\n       HPair (HTuple 0) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 4) (quot_dbfm_sumC A)\n 6. \\<And>t u A.\n       DBMem t u = DBEx A \\<Longrightarrow>\n       HPair (HTuple 0) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 5) (quot_dbfm_sumC A)\n 7. \\<And>t u ta ua.\n       DBEq t u = DBEq ta ua \\<Longrightarrow>\n       HPair (HTuple 2) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 2) (HPair (quot_dbtm ta) (quot_dbtm ua))\n 8. \\<And>t u A B.\n       DBEq t u = DBDisj A B \\<Longrightarrow>\n       HPair (HTuple 2) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 3) (HPair (quot_dbfm_sumC A) (quot_dbfm_sumC B))\n 9. \\<And>t u A.\n       DBEq t u = DBNeg A \\<Longrightarrow>\n       HPair (HTuple 2) (HPair (quot_dbtm t) (quot_dbtm u)) =\n       HPair (HTuple 4) (quot_dbfm_sumC A)\n 10. \\<And>t u A.\n        DBEq t u = DBEx A \\<Longrightarrow>\n        HPair (HTuple 2) (HPair (quot_dbtm t) (quot_dbtm u)) =\n        HPair (HTuple 5) (quot_dbfm_sumC A)\nA total of 16 subgoals...", "by (rule_tac y=x in dbfm.exhaust, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All quot_dbfm_dom", "by lexicographic_order"], ["", "lemma HTuple_minus_1: \"n > 0 \\<Longrightarrow> HTuple n = HPair Zero (HTuple (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> HTuple n = HPair Zero (HTuple (n - 1))", "by (metis Suc_diff_1 HTuple.simps(2))"], ["", "lemmas HTS = HTuple_minus_1 HTuple.simps \\<comment> \\<open>for freeness reasoning on codes\\<close>"], ["", "class quot =\n  fixes quot :: \"'a \\<Rightarrow> tm\"  (\"\\<guillemotleft>_\\<guillemotright>\")"], ["", "instantiation tm :: quot\nbegin"], ["", "definition quot_tm :: \"tm \\<Rightarrow> tm\"\n    where \"quot_tm t = quot_dbtm (trans_tm [] t)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(tm, quot_class)", ".."], ["", "end"], ["", "lemma quot_dbtm_fresh [simp]: \"s \\<sharp> (quot_dbtm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<sharp> quot_dbtm t", "by (induct t rule: dbtm.induct) auto"], ["", "lemma quot_tm_fresh [simp]: fixes t::tm shows \"s \\<sharp> \\<guillemotleft>t\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<sharp> \\<guillemotleft>t\\<guillemotright>", "by (simp add: quot_tm_def)"], ["", "lemma quot_Zero [simp]: \"\\<guillemotleft>Zero\\<guillemotright> = Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>Zero\\<guillemotright> = Zero", "by (simp add: quot_tm_def)"], ["", "lemma quot_Var: \"\\<guillemotleft>Var x\\<guillemotright> = SUCC (ORD_OF (nat_of_name x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>Var x\\<guillemotright> = SUCC (ORD_OF (nat_of_name x))", "by (simp add: quot_tm_def)"], ["", "lemma quot_Eats: \"\\<guillemotleft>Eats x y\\<guillemotright> = HPair (HTuple 1) (HPair \\<guillemotleft>x\\<guillemotright> \\<guillemotleft>y\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>Eats x y\\<guillemotright> =\n    HPair (HTuple 1)\n     (HPair \\<guillemotleft>x\\<guillemotright>\n       \\<guillemotleft>y\\<guillemotright>)", "by (simp add: quot_tm_def)"], ["", "instantiation fm :: quot\nbegin"], ["", "definition quot_fm :: \"fm \\<Rightarrow> tm\"\n    where \"quot_fm A = quot_dbfm (trans_fm [] A)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fm, quot_class)", ".."], ["", "end"], ["", "lemma quot_dbfm_fresh [simp]: \"s \\<sharp> (quot_dbfm A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<sharp> quot_dbfm A", "by (induct A rule: dbfm.induct) auto"], ["", "lemma quot_fm_fresh [simp]: fixes A::fm shows \"s \\<sharp> \\<guillemotleft>A\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<sharp> \\<guillemotleft>A\\<guillemotright>", "by (simp add: quot_fm_def)"], ["", "lemma quot_fm_permute [simp]: fixes A:: fm shows \"p \\<bullet> \\<guillemotleft>A\\<guillemotright> = \\<guillemotleft>A\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> \\<guillemotleft>A\\<guillemotright> =\n    \\<guillemotleft>A\\<guillemotright>", "by (metis fresh_star_def perm_supp_eq quot_fm_fresh)"], ["", "lemma quot_Mem: \"\\<guillemotleft>x IN y\\<guillemotright> = HPair (HTuple 0) (HPair (\\<guillemotleft>x\\<guillemotright>) (\\<guillemotleft>y\\<guillemotright>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x IN y\\<guillemotright> =\n    HPair (HTuple 0)\n     (HPair \\<guillemotleft>x\\<guillemotright>\n       \\<guillemotleft>y\\<guillemotright>)", "by (simp add: quot_fm_def quot_tm_def)"], ["", "lemma quot_Eq: \"\\<guillemotleft>x EQ y\\<guillemotright> = HPair (HTuple 2) (HPair (\\<guillemotleft>x\\<guillemotright>) (\\<guillemotleft>y\\<guillemotright>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>x EQ y\\<guillemotright> =\n    HPair (HTuple 2)\n     (HPair \\<guillemotleft>x\\<guillemotright>\n       \\<guillemotleft>y\\<guillemotright>)", "by (simp add: quot_fm_def quot_tm_def)"], ["", "lemma quot_Disj: \"\\<guillemotleft>A OR B\\<guillemotright> = HPair (HTuple 3) (HPair (\\<guillemotleft>A\\<guillemotright>) (\\<guillemotleft>B\\<guillemotright>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>A OR B\\<guillemotright> =\n    HPair (HTuple 3)\n     (HPair \\<guillemotleft>A\\<guillemotright>\n       \\<guillemotleft>B\\<guillemotright>)", "by (simp add: quot_fm_def)"], ["", "lemma quot_Neg: \"\\<guillemotleft>Neg A\\<guillemotright> = HPair (HTuple 4) (\\<guillemotleft>A\\<guillemotright>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>Neg A\\<guillemotright> =\n    HPair (HTuple 4) \\<guillemotleft>A\\<guillemotright>", "by (simp add: quot_fm_def)"], ["", "lemma quot_Ex: \"\\<guillemotleft>Ex i A\\<guillemotright> = HPair (HTuple 5) (quot_dbfm (trans_fm [i] A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>SyntaxN.Ex i A\\<guillemotright> =\n    HPair (HTuple 5) (quot_dbfm (trans_fm [i] A))", "by (simp add: quot_fm_def)"], ["", "lemmas quot_simps = quot_Var quot_Eats quot_Eq quot_Mem quot_Disj quot_Neg quot_Ex"], ["", "section\\<open>Definitions Involving Coding\\<close>"], ["", "abbreviation Q_Eats :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_Eats t u \\<equiv> HPair (HTuple (Suc 0)) (HPair t u)\""], ["", "abbreviation Q_Succ :: \"tm \\<Rightarrow> tm\"\n  where \"Q_Succ t \\<equiv> Q_Eats t t\""], ["", "lemma quot_Succ: \"\\<guillemotleft>SUCC x\\<guillemotright> = Q_Succ \\<guillemotleft>x\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>SUCC x\\<guillemotright> =\n    Q_Succ \\<guillemotleft>x\\<guillemotright>", "by (auto simp: SUCC_def quot_Eats)"], ["", "abbreviation Q_HPair :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_HPair t u \\<equiv>\n           Q_Eats (Q_Eats Zero (Q_Eats (Q_Eats Zero u) t))\n                  (Q_Eats (Q_Eats Zero t) t)\""], ["", "abbreviation Q_Mem :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_Mem t u \\<equiv> HPair (HTuple 0) (HPair t u)\""], ["", "abbreviation Q_Eq :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_Eq t u \\<equiv> HPair (HTuple 2) (HPair t u)\""], ["", "abbreviation Q_Disj :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_Disj t u \\<equiv> HPair (HTuple 3) (HPair t u)\""], ["", "abbreviation Q_Neg :: \"tm \\<Rightarrow> tm\"\n  where \"Q_Neg t \\<equiv> HPair (HTuple 4) t\""], ["", "abbreviation Q_Conj :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_Conj t u \\<equiv> Q_Neg (Q_Disj (Q_Neg t) (Q_Neg u))\""], ["", "abbreviation Q_Imp :: \"tm \\<Rightarrow> tm \\<Rightarrow> tm\"\n  where \"Q_Imp t u \\<equiv> Q_Disj (Q_Neg t) u\""], ["", "abbreviation Q_Ex :: \"tm \\<Rightarrow> tm\"\n  where \"Q_Ex t \\<equiv> HPair (HTuple 5) t\""], ["", "abbreviation Q_All :: \"tm \\<Rightarrow> tm\"\n  where \"Q_All t \\<equiv> Q_Neg (Q_Ex (Q_Neg t))\""], ["", "lemma quot_subst_eq: \"\\<guillemotleft>A(i::=t)\\<guillemotright> = quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>A(i::=t)\\<guillemotright> =\n    quot_dbfm (subst_dbfm (trans_tm [] t) i (trans_fm [] A))", "by (metis quot_fm_def subst_fm_trans_commute)"], ["", "lemma Q_Succ_cong: \"H \\<turnstile> x EQ x' \\<Longrightarrow> H \\<turnstile> Q_Succ x EQ Q_Succ x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<turnstile> x EQ x' \\<Longrightarrow>\n    H \\<turnstile> Q_Succ x EQ Q_Succ x'", "by (metis HPair_cong Refl)"], ["", "subsection\\<open>The set \\<open>\\<Gamma>\\<close> of Definition 1.1, constant terms used for coding\\<close>"], ["", "inductive coding_tm :: \"tm \\<Rightarrow> bool\"\n  where\n    Ord:    \"\\<exists>i. x = ORD_OF i \\<Longrightarrow> coding_tm x\"\n  | HPair:  \"coding_tm x \\<Longrightarrow> coding_tm y \\<Longrightarrow> coding_tm (HPair x y)\""], ["", "declare coding_tm.intros [intro]"], ["", "lemma coding_tm_Zero [intro]: \"coding_tm Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coding_tm Zero", "by (metis ORD_OF.simps(1) Ord)"], ["", "lemma coding_tm_HTuple [intro]: \"coding_tm (HTuple k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coding_tm (HTuple k)", "by (induct k, auto)"], ["", "inductive_simps coding_tm_HPair [simp]: \"coding_tm (HPair x y)\""], ["", "lemma quot_dbtm_coding [simp]: \"coding_tm (quot_dbtm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coding_tm (quot_dbtm t)", "apply (induct t rule: dbtm.induct, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. coding_tm (SUCC (ORD_OF (nat_of_name x)))", "apply (metis ORD_OF.simps(2) Ord)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma quot_dbfm_coding [simp]: \"coding_tm (quot_dbfm fm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coding_tm (quot_dbfm fm)", "by (induct fm rule: dbfm.induct, auto)"], ["", "lemma quot_fm_coding: fixes A::fm shows \"coding_tm \\<guillemotleft>A\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coding_tm \\<guillemotleft>A\\<guillemotright>", "by (metis quot_dbfm_coding quot_fm_def)"], ["", "section \\<open>V-Coding for terms and formulas, for the Second Theorem\\<close>"], ["", "text\\<open>Infinite support, so we cannot use nominal primrec.\\<close>"], ["", "function vquot_dbtm :: \"name set \\<Rightarrow> dbtm \\<Rightarrow> tm\"\n  where\n   \"vquot_dbtm V DBZero = Zero\"\n | \"vquot_dbtm V (DBVar name) = (if name \\<in> V then Var name\n                                 else ORD_OF (Suc (nat_of_name name)))\"\n | \"vquot_dbtm V (DBInd k) = HPair (HTuple 6) (ORD_OF k)\"\n | \"vquot_dbtm V (DBEats t u) = HPair (HTuple 1) (HPair (vquot_dbtm V t) (vquot_dbtm V u))\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>V. x = (V, DBZero) \\<Longrightarrow> P;\n        \\<And>V name. x = (V, DBVar name) \\<Longrightarrow> P;\n        \\<And>V k. x = (V, DBInd k) \\<Longrightarrow> P;\n        \\<And>V t u. x = (V, DBEats t u) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>V Va. (V, DBZero) = (Va, DBZero) \\<Longrightarrow> Zero = Zero\n 3. \\<And>V Va name.\n       (V, DBZero) = (Va, DBVar name) \\<Longrightarrow>\n       Zero =\n       (if name \\<in> Va then Var name else ORD_OF (Suc (nat_of_name name)))\n 4. \\<And>V Va k.\n       (V, DBZero) = (Va, DBInd k) \\<Longrightarrow>\n       Zero = HPair (HTuple 6) (ORD_OF k)\n 5. \\<And>V Va t u.\n       (V, DBZero) = (Va, DBEats t u) \\<Longrightarrow>\n       Zero =\n       HPair (HTuple 1)\n        (HPair (vquot_dbtm_sumC (Va, t)) (vquot_dbtm_sumC (Va, u)))\n 6. \\<And>V name Va namea.\n       (V, DBVar name) = (Va, DBVar namea) \\<Longrightarrow>\n       (if name \\<in> V then Var name\n        else ORD_OF (Suc (nat_of_name name))) =\n       (if namea \\<in> Va then Var namea\n        else ORD_OF (Suc (nat_of_name namea)))\n 7. \\<And>V name Va k.\n       (V, DBVar name) = (Va, DBInd k) \\<Longrightarrow>\n       (if name \\<in> V then Var name\n        else ORD_OF (Suc (nat_of_name name))) =\n       HPair (HTuple 6) (ORD_OF k)\n 8. \\<And>V name Va t u.\n       (V, DBVar name) = (Va, DBEats t u) \\<Longrightarrow>\n       (if name \\<in> V then Var name\n        else ORD_OF (Suc (nat_of_name name))) =\n       HPair (HTuple 1)\n        (HPair (vquot_dbtm_sumC (Va, t)) (vquot_dbtm_sumC (Va, u)))\n 9. \\<And>V k Va ka.\n       (V, DBInd k) = (Va, DBInd ka) \\<Longrightarrow>\n       HPair (HTuple 6) (ORD_OF k) = HPair (HTuple 6) (ORD_OF ka)\n 10. \\<And>V k Va t u.\n        (V, DBInd k) = (Va, DBEats t u) \\<Longrightarrow>\n        HPair (HTuple 6) (ORD_OF k) =\n        HPair (HTuple 1)\n         (HPair (vquot_dbtm_sumC (Va, t)) (vquot_dbtm_sumC (Va, u)))\nA total of 11 subgoals...", "by (auto, rule_tac y=b in dbtm.exhaust, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All vquot_dbtm_dom", "by lexicographic_order"], ["", "lemma fresh_vquot_dbtm [simp]: \"i \\<sharp> vquot_dbtm V tm \\<longleftrightarrow> i \\<sharp> tm \\<or> i \\<notin> atom ` V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sharp> vquot_dbtm V tm = (i \\<sharp> tm \\<or> i \\<notin> atom ` V)", "by (induct tm rule: dbtm.induct) (auto simp: fresh_at_base pure_fresh)"], ["", "text\\<open>Infinite support, so we cannot use nominal primrec.\\<close>"], ["", "function vquot_dbfm :: \"name set \\<Rightarrow> dbfm \\<Rightarrow> tm\"\n  where\n   \"vquot_dbfm V (DBMem t u) = HPair (HTuple 0) (HPair (vquot_dbtm V t) (vquot_dbtm V u))\"\n | \"vquot_dbfm V (DBEq t u) = HPair (HTuple 2) (HPair (vquot_dbtm V t) (vquot_dbtm V u))\"\n | \"vquot_dbfm V (DBDisj A B) = HPair (HTuple 3) (HPair (vquot_dbfm V A) (vquot_dbfm V B))\"\n | \"vquot_dbfm V (DBNeg A) = HPair (HTuple 4) (vquot_dbfm V A)\"\n | \"vquot_dbfm V (DBEx A) = HPair (HTuple 5) (vquot_dbfm V A)\""], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>V t u. x = (V, DBMem t u) \\<Longrightarrow> P;\n        \\<And>V t u. x = (V, DBEq t u) \\<Longrightarrow> P;\n        \\<And>V A B. x = (V, DBDisj A B) \\<Longrightarrow> P;\n        \\<And>V A. x = (V, DBNeg A) \\<Longrightarrow> P;\n        \\<And>V A. x = (V, DBEx A) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>V t u Va ta ua.\n       (V, DBMem t u) = (Va, DBMem ta ua) \\<Longrightarrow>\n       Q_Mem (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Mem (vquot_dbtm Va ta) (vquot_dbtm Va ua)\n 3. \\<And>V t u Va ta ua.\n       (V, DBMem t u) = (Va, DBEq ta ua) \\<Longrightarrow>\n       Q_Mem (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Eq (vquot_dbtm Va ta) (vquot_dbtm Va ua)\n 4. \\<And>V t u Va A B.\n       (V, DBMem t u) = (Va, DBDisj A B) \\<Longrightarrow>\n       Q_Mem (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Disj (vquot_dbfm_sumC (Va, A)) (vquot_dbfm_sumC (Va, B))\n 5. \\<And>V t u Va A.\n       (V, DBMem t u) = (Va, DBNeg A) \\<Longrightarrow>\n       Q_Mem (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Neg (vquot_dbfm_sumC (Va, A))\n 6. \\<And>V t u Va A.\n       (V, DBMem t u) = (Va, DBEx A) \\<Longrightarrow>\n       Q_Mem (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Ex (vquot_dbfm_sumC (Va, A))\n 7. \\<And>V t u Va ta ua.\n       (V, DBEq t u) = (Va, DBEq ta ua) \\<Longrightarrow>\n       Q_Eq (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Eq (vquot_dbtm Va ta) (vquot_dbtm Va ua)\n 8. \\<And>V t u Va A B.\n       (V, DBEq t u) = (Va, DBDisj A B) \\<Longrightarrow>\n       Q_Eq (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Disj (vquot_dbfm_sumC (Va, A)) (vquot_dbfm_sumC (Va, B))\n 9. \\<And>V t u Va A.\n       (V, DBEq t u) = (Va, DBNeg A) \\<Longrightarrow>\n       Q_Eq (vquot_dbtm V t) (vquot_dbtm V u) =\n       Q_Neg (vquot_dbfm_sumC (Va, A))\n 10. \\<And>V t u Va A.\n        (V, DBEq t u) = (Va, DBEx A) \\<Longrightarrow>\n        Q_Eq (vquot_dbtm V t) (vquot_dbtm V u) =\n        Q_Ex (vquot_dbfm_sumC (Va, A))\nA total of 16 subgoals...", "by (auto, rule_tac y=b in dbfm.exhaust, auto)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. HOL.All vquot_dbfm_dom", "by lexicographic_order"], ["", "lemma fresh_vquot_dbfm [simp]: \"i \\<sharp> vquot_dbfm V fm \\<longleftrightarrow> i \\<sharp> fm \\<or> i \\<notin> atom ` V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sharp> vquot_dbfm V fm = (i \\<sharp> fm \\<or> i \\<notin> atom ` V)", "by (induct fm rule: dbfm.induct) (auto simp: HPair_def HTuple_minus_1)"], ["", "class vquot =\n  fixes vquot :: \"'a \\<Rightarrow> name set \\<Rightarrow> tm\"  (\"\\<lfloor>_\\<rfloor>_\"  [0,1000]1000)"], ["", "instantiation tm :: vquot\nbegin"], ["", "definition vquot_tm :: \"tm \\<Rightarrow> name set \\<Rightarrow> tm\"\n    where \"vquot_tm t V = vquot_dbtm V (trans_tm [] t)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(tm, vquot_class)", ".."], ["", "end"], ["", "lemma vquot_dbtm_empty [simp]: \"vquot_dbtm {} t = quot_dbtm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vquot_dbtm {} t = quot_dbtm t", "by (induct t rule: dbtm.induct) auto"], ["", "lemma vquot_tm_empty [simp]: fixes t::tm shows \"\\<lfloor>t\\<rfloor>{} = \\<guillemotleft>t\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>t\\<rfloor>{} = \\<guillemotleft>t\\<guillemotright>", "by (simp add: vquot_tm_def quot_tm_def)"], ["", "lemma vquot_dbtm_eq: \"atom ` V \\<inter> supp t = atom ` W \\<inter> supp t \\<Longrightarrow> vquot_dbtm V t = vquot_dbtm W t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` V \\<inter> supp t = atom ` W \\<inter> supp t \\<Longrightarrow>\n    vquot_dbtm V t = vquot_dbtm W t", "by (induct t rule: dbtm.induct) (auto simp: image_iff, blast+)"], ["", "instantiation fm :: vquot\nbegin"], ["", "definition vquot_fm :: \"fm \\<Rightarrow> name set \\<Rightarrow> tm\"\n    where \"vquot_fm A V = vquot_dbfm V (trans_fm [] A)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(fm, vquot_class)", ".."], ["", "end"], ["", "lemma vquot_fm_fresh [simp]: fixes A::fm shows \"i \\<sharp> \\<lfloor>A\\<rfloor>V \\<longleftrightarrow> i \\<sharp> A \\<or> i \\<notin> atom ` V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<sharp> \\<lfloor>A\\<rfloor>V =\n    (i \\<sharp> A \\<or> i \\<notin> atom ` V)", "by (simp add: vquot_fm_def)"], ["", "lemma vquot_dbfm_empty [simp]: \"vquot_dbfm {} A = quot_dbfm A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vquot_dbfm {} A = quot_dbfm A", "by (induct A rule: dbfm.induct) auto"], ["", "lemma vquot_fm_empty [simp]: fixes A::fm shows \"\\<lfloor>A\\<rfloor>{} = \\<guillemotleft>A\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>A\\<rfloor>{} = \\<guillemotleft>A\\<guillemotright>", "by (simp add: vquot_fm_def quot_fm_def)"], ["", "lemma vquot_dbfm_eq: \"atom ` V \\<inter> supp A = atom ` W \\<inter> supp A \\<Longrightarrow> vquot_dbfm V A = vquot_dbfm W A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` V \\<inter> supp A = atom ` W \\<inter> supp A \\<Longrightarrow>\n    vquot_dbfm V A = vquot_dbfm W A", "by (induct A rule: dbfm.induct) (auto simp: intro!: vquot_dbtm_eq, blast+)"], ["", "lemma vquot_fm_insert:\n  fixes A::fm shows \"atom i \\<notin> supp A \\<Longrightarrow> \\<lfloor>A\\<rfloor>(insert i V) = \\<lfloor>A\\<rfloor>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom i \\<notin> supp A \\<Longrightarrow>\n    \\<lfloor>A\\<rfloor>(insert i V) = \\<lfloor>A\\<rfloor>V", "by (auto simp: vquot_fm_def supp_conv_fresh intro: vquot_dbfm_eq)"], ["", "declare HTuple.simps [simp del]"], ["", "end"]]}