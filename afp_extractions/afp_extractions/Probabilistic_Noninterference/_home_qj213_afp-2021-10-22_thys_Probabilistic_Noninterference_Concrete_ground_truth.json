{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Noninterference/Concrete.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_Noninterference", "problem_names": ["lemma [simp]: \"\\<And> l. l \\<noteq> Hi \\<longleftrightarrow> l = Lo\" and\n      [simp]: \"\\<And> l. Hi \\<noteq> l \\<longleftrightarrow> Lo = l\" and\n      [simp]: \"\\<And> l. l \\<noteq> Lo \\<longleftrightarrow> l = Hi\" and\n      [simp]: \"\\<And> l. Lo \\<noteq> l \\<longleftrightarrow> Hi = l\"", "lemma [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Lo \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Hi\" and\n      [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Hi \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Lo\"", "lemma sup_eq_Lo[simp]: \"sup a b = Lo \\<longleftrightarrow> a = Lo \\<and> b = Lo\"", "lemma exprSec_Lo_eval_eq: \"exprSec expr = Lo \\<Longrightarrow> (s, t) \\<in> indis \\<Longrightarrow> eval expr s = eval expr t\"", "lemma compatAtmSyntactic[simp]: \"exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow> Example_PL.compatAtm (Assign v expr)\"", "lemma presAtmSyntactic[simp]: \"sec v = Hi \\<Longrightarrow> Example_PL.presAtm (Assign v expr)\"", "lemma compatTstSyntactic[simp]: \"tstSec tst = Lo \\<Longrightarrow> Example_PL.compatTst tst\"", "lemma compatPrchSyntactic[simp]: \"Example_PL.compatCh (Inl p)\"", "lemma compatIfchSyntactic[simp]: \"Example_PL.compatCh (Inr tst) \\<longleftrightarrow> Example_PL.compatTst tst\"", "lemma \"SC_discr (h ::= Ct 0)\"", "theorem \"SC_discr d0\"\n        \"SC_discr d1\"\n        \"SC_Sbis d2\"\n        \"SC_ZObis d2\"", "theorem \"discr d0\"\n        \"discr d1\"\n        \"d2 \\<approx>s d2\"\n        \"d3 \\<approx>01 d3\""], "translations": [["", "lemma [simp]: \"\\<And> l. l \\<noteq> Hi \\<longleftrightarrow> l = Lo\" and\n      [simp]: \"\\<And> l. Hi \\<noteq> l \\<longleftrightarrow> Lo = l\" and\n      [simp]: \"\\<And> l. l \\<noteq> Lo \\<longleftrightarrow> l = Hi\" and\n      [simp]: \"\\<And> l. Lo \\<noteq> l \\<longleftrightarrow> Hi = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>l. (l \\<noteq> Hi) = (l = Lo)) &&&\n     (\\<And>l. (Hi \\<noteq> l) = (Lo = l))) &&&\n    (\\<And>l. (l \\<noteq> Lo) = (l = Hi)) &&&\n    (\\<And>l. (Lo \\<noteq> l) = (Hi = l))", "by (metis level.exhaust level.simps(2))+"], ["", "lemma [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Lo \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Hi\" and\n      [dest]: \"\\<And> l A. \\<lbrakk>l \\<in> A; Hi \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Lo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l A.\n        \\<lbrakk>l \\<in> A; Lo \\<notin> A\\<rbrakk>\n        \\<Longrightarrow> l = Hi) &&&\n    (\\<And>l A.\n        \\<lbrakk>l \\<in> A; Hi \\<notin> A\\<rbrakk> \\<Longrightarrow> l = Lo)", "by (metis level.exhaust)+"], ["", "declare level.split[split]"], ["", "instantiation level :: complete_lattice\nbegin"], ["", "definition top_level: \"top \\<equiv> Hi\""], ["", "definition bot_level: \"bot \\<equiv> Lo\""], ["", "definition inf_level: \"inf l1 l2 \\<equiv> if Lo \\<in> {l1,l2} then Lo else Hi\""], ["", "definition sup_level: \"sup l1 l2 \\<equiv> if Hi \\<in> {l1,l2} then Hi else Lo\""], ["", "definition less_eq_level: \"less_eq l1 l2 \\<equiv> (l1 = Lo \\<or> l2 = Hi)\""], ["", "definition less_level: \"less l1 l2 \\<equiv> l1 = Lo \\<and> l2 = Hi\""], ["", "definition Inf_level: \"Inf L \\<equiv> if Lo \\<in> L then Lo else Hi\""], ["", "definition Sup_level: \"Sup L \\<equiv> if Hi \\<in> L then Hi else Lo\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(level, complete_lattice_class)", "proof"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "qed (auto simp: top_level bot_level inf_level sup_level\n                        less_eq_level less_level Inf_level Sup_level)"], ["", "end"], ["", "lemma sup_eq_Lo[simp]: \"sup a b = Lo \\<longleftrightarrow> a = Lo \\<and> b = Lo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<squnion> b = Lo) = (a = Lo \\<and> b = Lo)", "by (auto simp: sup_level)"], ["", "datatype var = h | h' | l | l'"], ["", "datatype exp = Ct nat | Var var | Plus exp exp | Minus exp exp"], ["", "datatype test = Tr | Eq exp exp | Gt exp exp | Non test"], ["", "datatype atom = Assign var exp"], ["", "type_synonym choice = \"real + test\""], ["", "type_synonym state = \"var \\<Rightarrow> nat\""], ["", "syntax\n \"_assign\" :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"  (\"_ ::= _\" [1000, 61] 61)"], ["", "translations\n  \"x ::= expr\" == \"CONST Atm (CONST Assign x expr)\""], ["", "primrec sec where\n  \"sec h  = Hi\"\n| \"sec h' = Hi\"\n| \"sec l  = Lo\"\n| \"sec l' = Lo\""], ["", "fun eval where\n \"eval (Ct n) s = n\"\n|\"eval (Var x) s = s x\"\n|\"eval (Plus e1 e2) s = eval e1 s + eval e2 s\"\n|\"eval (Minus e1 e2) s = eval e1 s - eval e2 s\""], ["", "fun tval where\n \"tval Tr s = True\"\n|\"tval (Eq e1 e2) s = (eval e1 s = eval e2 s)\"\n|\"tval (Gt e1 e2) s = (eval e1 s > eval e2 s)\"\n|\"tval (Non e) s = (\\<not> tval e s)\""], ["", "fun aval where\n\"aval (Assign x e) s = (s (x := eval e s))\""], ["", "fun cval where\n \"cval (Inl p) s = min 1 (max 0 p)\"\n|\"cval (Inr tst) s = (if tval tst s then 1 else 0)\""], ["", "definition indis :: \"(state * state) set\"where\n\"indis \\<equiv> {(s,t). ALL x. sec x = Lo \\<longrightarrow> s x = t x}\""], ["", "interpretation Example_PL: PL_Indis aval tval cval indis"], ["proof (prove)\ngoal (1 subgoal):\n 1. PL_Indis cval indis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ch s. 0 \\<le> cval ch s \\<and> cval ch s \\<le> 1\n 2. equiv UNIV indis", "fix ch :: choice and  s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ch s. 0 \\<le> cval ch s \\<and> cval ch s \\<le> 1\n 2. equiv UNIV indis", "show \"0 \\<le> cval ch s \\<and> cval ch s \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cval ch s \\<and> cval ch s \\<le> 1", "by (cases ch) auto"], ["proof (state)\nthis:\n  0 \\<le> cval ch s \\<and> cval ch s \\<le> 1\n\ngoal (1 subgoal):\n 1. equiv UNIV indis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. equiv UNIV indis", "show \"equiv UNIV indis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV indis", "unfolding refl_on_def sym_def trans_def equiv_def indis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({(s, t). \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x}\n     \\<subseteq> UNIV \\<times> UNIV \\<and>\n     (\\<forall>x\\<in>UNIV.\n         (x, x)\n         \\<in> {(s, t).\n                \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x})) \\<and>\n    (\\<forall>x y.\n        (x, y)\n        \\<in> {(s, t).\n               \\<forall>x.\n                  sec x = Lo \\<longrightarrow> s x = t x} \\<longrightarrow>\n        (y, x)\n        \\<in> {(s, t).\n               \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x}) \\<and>\n    (\\<forall>x y z.\n        (x, y)\n        \\<in> {(s, t).\n               \\<forall>x.\n                  sec x = Lo \\<longrightarrow> s x = t x} \\<longrightarrow>\n        (y, z)\n        \\<in> {(s, t).\n               \\<forall>x.\n                  sec x = Lo \\<longrightarrow> s x = t x} \\<longrightarrow>\n        (x, z)\n        \\<in> {(s, t). \\<forall>x. sec x = Lo \\<longrightarrow> s x = t x})", "by auto"], ["proof (state)\nthis:\n  equiv UNIV indis\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The security level of expressions: *)"], ["", "fun exprSec where\n \"exprSec (Ct n) = Lo\"\n|\"exprSec (Var x) = sec x\"\n|\"exprSec (Plus e1 e2) = sup (exprSec e1) (exprSec e2)\"\n|\"exprSec (Minus e1 e2) = sup (exprSec e1) (exprSec e2)\""], ["", "(* The security level of tests: *)"], ["", "fun tstSec where\n \"tstSec Tr = Lo\"\n|\"tstSec (Eq e1 e2) = sup (exprSec e1) (exprSec e2)\"\n|\"tstSec (Gt e1 e2) = sup (exprSec e1) (exprSec e2)\"\n|\"tstSec (Non e) = tstSec e\""], ["", "lemma exprSec_Lo_eval_eq: \"exprSec expr = Lo \\<Longrightarrow> (s, t) \\<in> indis \\<Longrightarrow> eval expr s = eval expr t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>exprSec expr = Lo; Example_PL.indisAbbrev s t\\<rbrakk>\n    \\<Longrightarrow> eval expr s = eval expr t", "by (induct expr) (auto simp: indis_def)"], ["", "lemma compatAtmSyntactic[simp]: \"exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow> Example_PL.compatAtm (Assign v expr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow>\n    Example_PL.compatAtm (Assign v expr)", "unfolding Example_PL.compatAtm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exprSec expr = Lo \\<or> sec v = Hi \\<Longrightarrow>\n    \\<forall>s t.\n       Example_PL.indisAbbrev s t \\<longrightarrow>\n       Example_PL.indisAbbrev (aval (Assign v expr) s)\n        (aval (Assign v expr) t)", "by (induct expr)\n     (auto simp: indis_def intro!: arg_cong2[where f=\"(+)\"] arg_cong2[where f=\"(-)\"] exprSec_Lo_eval_eq)"], ["", "lemma presAtmSyntactic[simp]: \"sec v = Hi \\<Longrightarrow> Example_PL.presAtm (Assign v expr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sec v = Hi \\<Longrightarrow> Example_PL.presAtm (Assign v expr)", "unfolding Example_PL.presAtm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sec v = Hi \\<Longrightarrow>\n    \\<forall>s. Example_PL.indisAbbrev s (aval (Assign v expr) s)", "by (simp add: indis_def)"], ["", "lemma compatTstSyntactic[simp]: \"tstSec tst = Lo \\<Longrightarrow> Example_PL.compatTst tst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tstSec tst = Lo \\<Longrightarrow> Example_PL.compatTst tst", "unfolding Example_PL.compatTst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tstSec tst = Lo \\<Longrightarrow>\n    \\<forall>s t.\n       Example_PL.indisAbbrev s t \\<longrightarrow> tval tst s = tval tst t", "by (induct tst)\n     (simp_all, safe del: iffI\n              intro!: arg_cong2[where f=\"(=)\"] arg_cong2[where f=\"(<) :: nat \\<Rightarrow> nat \\<Rightarrow> bool\"] exprSec_Lo_eval_eq)"], ["", "(* Stateless choices are always compatible: *)"], ["", "lemma compatPrchSyntactic[simp]: \"Example_PL.compatCh (Inl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Example_PL.compatCh (Inl p)", "unfolding Example_PL.compatCh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s t.\n       Example_PL.indisAbbrev s t \\<longrightarrow>\n       cval (Inl p) s = cval (Inl p) t", "by auto"], ["", "(* A test-choice is compatible iff its test is compatible: *)"], ["", "lemma compatIfchSyntactic[simp]: \"Example_PL.compatCh (Inr tst) \\<longleftrightarrow> Example_PL.compatTst tst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Example_PL.compatCh (Inr tst) = Example_PL.compatTst tst", "unfolding Example_PL.compatCh_def Example_PL.compatTst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s t.\n        Example_PL.indisAbbrev s t \\<longrightarrow>\n        cval (Inr tst) s = cval (Inr tst) t) =\n    (\\<forall>s t.\n        Example_PL.indisAbbrev s t \\<longrightarrow>\n        tval tst s = tval tst t)", "by auto"], ["", "abbreviation Ch_half (\"Ch\\<^sub>\\<onehalf>\") where \"Ch\\<^sub>\\<onehalf> \\<equiv> Ch (Inl (1/2))\""], ["", "abbreviation If where \"If tst \\<equiv> Ch (Inr tst)\""], ["", "abbreviation \"siso c \\<equiv> Example_PL.siso c\""], ["", "abbreviation \"discr c \\<equiv> Example_PL.discr c\""], ["", "abbreviation Sbis_abbrev (infix \"\\<approx>s\" 55) where \"c1 \\<approx>s c2 \\<equiv> (c1,c2) \\<in> Example_PL.Sbis\""], ["", "abbreviation ZObis_abbrev (infix \"\\<approx>01\" 55) where \"c1 \\<approx>01 c2 \\<equiv> (c1,c2) \\<in> Example_PL.ZObis\""], ["", "abbreviation \"SC_siso c \\<equiv> Example_PL.SC_siso c\""], ["", "abbreviation \"SC_discr c \\<equiv> Example_PL.SC_discr c\""], ["", "abbreviation \"SC_Sbis c \\<equiv> Example_PL.SC_Sbis c\""], ["", "abbreviation \"SC_ZObis c \\<equiv> Example_PL.SC_ZObis c\""], ["", "lemma \"SC_discr (h ::= Ct 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SC_discr (h ::= Ct 0)", "by (simp add: Example_PL.SC_discr.simps)"], ["", "subsection \\<open>The secure programs from the paper's Example 3\\<close>"], ["", "definition [simp]: \"d0 =\n  h' ::= Ct 0 ;;\n  While (Gt (Var h) (Ct 0))\n    (Ch\\<^sub>\\<onehalf> (h ::= Ct 0)\n         (h' ::= Plus (Var h') (Ct 1)))\""], ["", "definition [simp]: \"d1 =\n  While (Gt (Var h) (Ct 0))\n    (Ch\\<^sub>\\<onehalf> (h ::= Minus (Var h) (Ct 1))\n         (h ::= Plus (Var h) (Ct 1)))\""], ["", "definition [simp]: \"d2 =\n  If (Eq (Var l) (Ct 0))\n    (l' ::= Ct 1)\n    d0\""], ["", "definition [simp]: \"d3 =\n  h ::= Ct 5 ;;\n  ParT [d0, (l ::= Ct 1)]\""], ["", "(* The syntactic criteria are checked automatically: *)"], ["", "theorem \"SC_discr d0\"\n        \"SC_discr d1\"\n        \"SC_Sbis d2\"\n        \"SC_ZObis d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SC_discr d0 &&& SC_discr d1) &&& SC_Sbis d2 &&& SC_ZObis d2", "by (auto simp: Example_PL.SC_discr.simps Example_PL.SC_Sbis.simps Example_PL.SC_ZObis.simps)"], ["", "(* Alternatively, the semantic notions follow directly from the compositionality facts\nused as intro rules: *)"], ["", "theorem \"discr d0\"\n        \"discr d1\"\n        \"d2 \\<approx>s d2\"\n        \"d3 \\<approx>01 d3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (discr d0 &&& discr d1) &&& d2 \\<approx>s d2 &&& d3 \\<approx>01 d3", "by (auto intro!: compatAtmSyntactic\n                   Example_PL.ZObis Example_PL.proper_intros\n                   Example_PL.Atm_Sbis)"], ["", "end"]]}