{"file_name": "/home/qj213/afp-2021-10-22/thys/HotelKeyCards/NewCard.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HotelKeyCards", "problem_names": ["lemma currk_issued[simp]: \"s : reach \\<Longrightarrow> currk s r : issued s\"", "lemma prevk_issued[simp]: \"s : reach \\<Longrightarrow> prevk s r : issued s\"", "lemma key2_issued[simp]: \"s : reach \\<Longrightarrow> (k,k') : cards s g \\<Longrightarrow> k' : issued s\"", "lemma key1_issued[simp]: \"s : reach \\<Longrightarrow> (k,k') : cards s g \\<Longrightarrow> k : issued s\"", "lemma roomk_issued[simp]: \"s : reach \\<Longrightarrow> roomk s k : issued s\"", "lemma currk_inj[simp]:\n \"s : reach \\<Longrightarrow> \\<forall>r r'. (currk s r = currk s r') = (r = r')\"", "lemma currk_not_prevk[simp]:\n \"s : reach \\<Longrightarrow> owns s r' = Some g \\<Longrightarrow> currk s r \\<noteq> prevk s r'\"", "lemma key1_not_currk[simp]:\n \"s : reach \\<Longrightarrow> (currk s r,k') \\<notin> cards s g\"", "lemma key2_not_currk:\n \"s : reach \\<Longrightarrow> owns s r = Some g \\<Longrightarrow> g \\<noteq> g' \\<Longrightarrow> (k, currk s r) \\<notin> cards s g'\"", "lemma guest_key2_disj2[simp]:\n\"\\<lbrakk> s : reach; (k\\<^sub>1,k) \\<in> cards s g\\<^sub>1; (k\\<^sub>2,k) \\<in> cards s g\\<^sub>2 \\<rbrakk> \\<Longrightarrow> g\\<^sub>1=g\\<^sub>2\"", "lemma safe_roomk_currk[simp]:\n \"s : reach \\<Longrightarrow> safe s r \\<Longrightarrow> roomk s r = currk s r\"", "lemma only_owner_enter_normal[simp]:\n \"\\<lbrakk> s : reach; safe s r; (k',roomk s r) \\<in> cards s g \\<rbrakk> \\<Longrightarrow> owns s r = Some g\"", "theorem \"s : reach \\<Longrightarrow> safe s r \\<Longrightarrow> g : isin s r \\<Longrightarrow> owns s r = Some g\"", "lemmas new_invs = prevk_issued currk_not_prevk key2_not_currk"], "translations": [["", "lemma currk_issued[simp]: \"s : reach \\<Longrightarrow> currk s r : issued s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach \\<Longrightarrow> currk s r \\<in> issued s", "by (induct set: reach) auto"], ["", "lemma prevk_issued[simp]: \"s : reach \\<Longrightarrow> prevk s r : issued s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach \\<Longrightarrow> prevk s r \\<in> issued s", "by (induct set: reach) auto"], ["", "lemma key2_issued[simp]: \"s : reach \\<Longrightarrow> (k,k') : cards s g \\<Longrightarrow> k' : issued s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; (k, k') \\<in> cards s g\\<rbrakk>\n    \\<Longrightarrow> k' \\<in> issued s", "by (induct set: reach) auto"], ["", "lemma key1_issued[simp]: \"s : reach \\<Longrightarrow> (k,k') : cards s g \\<Longrightarrow> k : issued s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; (k, k') \\<in> cards s g\\<rbrakk>\n    \\<Longrightarrow> k \\<in> issued s", "by (induct set: reach) auto"], ["", "lemma roomk_issued[simp]: \"s : reach \\<Longrightarrow> roomk s k : issued s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach \\<Longrightarrow> roomk s k \\<in> issued s", "by (induct set: reach) auto"], ["", "lemma currk_inj[simp]:\n \"s : reach \\<Longrightarrow> \\<forall>r r'. (currk s r = currk s r') = (r = r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach \\<Longrightarrow>\n    \\<forall>r r'. (currk s r = currk s r') = (r = r')", "by (induct set: reach) auto"], ["", "lemma currk_not_prevk[simp]:\n \"s : reach \\<Longrightarrow> owns s r' = Some g \\<Longrightarrow> currk s r \\<noteq> prevk s r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; owns s r' = \\<lfloor>g\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> currk s r \\<noteq> prevk s r'", "by (induct set: reach) auto"], ["", "lemma key1_not_currk[simp]:\n \"s : reach \\<Longrightarrow> (currk s r,k') \\<notin> cards s g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach \\<Longrightarrow> (currk s r, k') \\<notin> cards s g", "by (induct set: reach) auto"], ["", "lemma key2_not_currk:\n \"s : reach \\<Longrightarrow> owns s r = Some g \\<Longrightarrow> g \\<noteq> g' \\<Longrightarrow> (k, currk s r) \\<notin> cards s g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; owns s r = \\<lfloor>g\\<rfloor>;\n     g \\<noteq> g'\\<rbrakk>\n    \\<Longrightarrow> (k, currk s r) \\<notin> cards s g'", "by (induct set: reach) auto"], ["", "lemma guest_key2_disj2[simp]:\n\"\\<lbrakk> s : reach; (k\\<^sub>1,k) \\<in> cards s g\\<^sub>1; (k\\<^sub>2,k) \\<in> cards s g\\<^sub>2 \\<rbrakk> \\<Longrightarrow> g\\<^sub>1=g\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; (k\\<^sub>1, k) \\<in> cards s g\\<^sub>1;\n     (k\\<^sub>2, k) \\<in> cards s g\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> g\\<^sub>1 = g\\<^sub>2", "by (induct set: reach) (auto simp:key2_not_currk)"], ["", "lemma safe_roomk_currk[simp]:\n \"s : reach \\<Longrightarrow> safe s r \\<Longrightarrow> roomk s r = currk s r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; safe s r\\<rbrakk>\n    \\<Longrightarrow> roomk s r = currk s r", "by (induct set: reach) auto"], ["", "lemma only_owner_enter_normal[simp]:\n \"\\<lbrakk> s : reach; safe s r; (k',roomk s r) \\<in> cards s g \\<rbrakk> \\<Longrightarrow> owns s r = Some g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; safe s r;\n     (k', roomk s r) \\<in> cards s g\\<rbrakk>\n    \\<Longrightarrow> owns s r = \\<lfloor>g\\<rfloor>", "by (induct set: reach) auto"], ["", "theorem \"s : reach \\<Longrightarrow> safe s r \\<Longrightarrow> g : isin s r \\<Longrightarrow> owns s r = Some g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach; safe s r; g \\<in> isin s r\\<rbrakk>\n    \\<Longrightarrow> owns s r = \\<lfloor>g\\<rfloor>", "by (induct set: reach) auto"], ["", "lemmas new_invs = prevk_issued currk_not_prevk key2_not_currk"], ["", "(*>*)"], ["", "subsection\\<open>An extension\\<close>"], ["", "text\\<open>\nTo test the flexibility of our model we extended it with the\npossibility for obtaining a new card, e.g.\\ when one has lost one's\ncard. Now reception needs to remember not just the current but also\nthe previous key for each room, i.e.\\ a new field \\<open>prevk :: room\n\\<Rightarrow> key\\<close> is added to @{typ state}. It is initialized with the same value\nas @{const currk}: though strictly speaking it could be arbitrary,\nthis permits the convenient invariant @{prop\"prevk s r \\<in> issued s\"}.\nUpon check-in we set \\<open>prevk\\<close> to \\mbox{@{term\"(prevk s)(r := currk s r)\"}}.\nEvent \\<open>new_card\\<close> is simple enough:\n@{thm[display] new_card}\n\nThe verification is not seriously affected. Some additional\ninvariants are required\n@{thm[display] new_invs}\nbut the proofs are still of the same trivial induct-auto format.\n\nAdding a further event for loosing a card has no impact at all on the proofs.\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}