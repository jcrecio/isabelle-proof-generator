{"file_name": "/home/qj213/afp-2021-10-22/thys/HotelKeyCards/Equivalence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HotelKeyCards", "problem_names": ["lemma [simp]: \"safe [] = (%r. False)\"", "lemma [simp]: \"safe (Exit g r # t) r' = safe t r'\"", "lemma [simp]: \"\\<not> safe (Check_in g r c # t) r\"", "lemma [simp]: \"r \\<noteq> r' \\<Longrightarrow> safe (Check_in g r' c # t) r = safe t r\"", "lemma [simp]: \"r \\<noteq> r' \\<Longrightarrow> safe (Enter g r' c # t) r = safe t r\"", "lemma reach_cong: \"r : reach \\<Longrightarrow> r = r' \\<Longrightarrow> r' : reach\"", "lemma cards_app: \"cards (s @ s') g = cards s g \\<union> cards s' g\"", "lemma ownsD: \"owns s r = Some g \\<Longrightarrow>\n \\<exists>s\\<^sub>1 s\\<^sub>2 c. s = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and> no_Check_in s\\<^sub>2 r\"", "lemma [simp]: \"safe t r \\<Longrightarrow> safe (Enter g r c # t) r\"", "lemma same_key2D:\n\"hotel (s\\<^sub>2 @ Check_in g r (k\\<^sub>2,k) # s\\<^sub>1) \\<Longrightarrow>\n (k\\<^sub>1,k) : cards(s\\<^sub>2 @ Check_in g r (k\\<^sub>2,k) # s\\<^sub>1) g' \\<Longrightarrow> g=g' \\<and> k\\<^sub>1=k\\<^sub>2\"", "lemma safe_Enter[simp]: \"hotel (Enter g r (k,k') # t) \\<Longrightarrow>\n safe (Enter g r (k,k') # t) r =\n (owns t r = \\<lfloor>g\\<rfloor> \\<and> isin t r = {} \\<and> k' = currk t r \\<or> safe t r)\"", "lemma hotel_reach: \"inj initk \\<Longrightarrow> hotel t \\<Longrightarrow> \\<lparr> state.owns = owns t,\n state.currk = currk t,\n state.issued = issued t,\n state.cards = cards t,\n state.roomk = roomk t,\n state.isin = isin t,\n state.safe = (%r. safe t r \\<or> owns t r =  None)\\<rparr> : reach\"", "lemma reach_hotel: \"s : reach \\<Longrightarrow>\n \\<exists>t ik. initk = ik \\<longrightarrow> hotel t \\<and>\n state.cards s = cards t \\<and>\n state.isin s =  isin t \\<and>\n state.roomk s = roomk t \\<and> state.owns s = owns t \\<and>\n state.currk s = currk t \\<and>\n state.issued s = issued t \\<and>\n state.safe s = (\\<lambda>r. safe t r \\<or> owns t r = None)\""], "translations": [["", "lemma [simp]: \"safe [] = (%r. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Trace.safe [] = (\\<lambda>r. False)", "by(simp add:Trace.safe_def fun_eq_iff)"], ["", "lemma [simp]: \"safe (Exit g r # t) r' = safe t r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Trace.safe (Exit g r # t) r' = Trace.safe t r'", "apply(simp add:Trace.safe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n        Exit g r # t =\n        s\\<^sub>3 @\n        Enter ga r' (a, b) #\n        s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' =\n        {}) =\n    (\\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r' (a, b) #\n        s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' = {})", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' = {}\n 2. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>Exit g r # t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1)\n                             r' =\n                            {}\n 2. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply(case_tac s\\<^sub>3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>Exit g r # t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {};\n        s\\<^sub>3 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1)\n                             r' =\n                            {}\n 2. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>Exit g r # t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1)\n                             r' =\n                            {}\n 3. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>Exit g r # t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1)\n                             r' =\n                            {}\n 2. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>t =\n                list @\n                Enter g r' (a, b) #\n                s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set list \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r' (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in ga r' (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r' (aa, ba) # s\\<^sub>1')\n                             r' =\n                            {}\n 2. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>t =\n                list @\n                Enter g r' (a, b) #\n                s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set list \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r' (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in ga r' (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r' (aa, ba) # s\\<^sub>1)\n                             r' =\n                            {}\n 2. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>t =\n                list @\n                Enter g r' (a, b) #\n                s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set list \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r' (a, b) #\n                            s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r' (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in ga r' (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in ga r' (aa, ba) # s\\<^sub>1)\n                             r' =\n                            {}\n 2. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n       t =\n       s\\<^sub>3 @\n       Enter g r' (a, b) #\n       s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in g r' (a, b) # s\\<^sub>1) r' =\n       {} \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       Exit g r # t =\n       s\\<^sub>3 @\n       Enter ga r' (a, b) #\n       s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 \\<and>\n       (\\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2) \\<and>\n       Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' = {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Exit g r #\n                            s\\<^sub>3 @\n                            Enter ga r' (a, b) #\n                            s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r' (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r' (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r' (aa, ba) # s\\<^sub>1')\n                             r' =\n                            {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Exit g r #\n                            s\\<^sub>3 @\n                            Enter ga r' (a, b) #\n                            s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r' (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r' (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r' (aa, ba) # s\\<^sub>1)\n                             r' =\n                            {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>t =\n                s\\<^sub>3 @\n                Enter ga r' (a, b) #\n                s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r' (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1) r' =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3' gb aa ba.\n                            Exit g r #\n                            s\\<^sub>3 @\n                            Enter ga r' (a, b) #\n                            s\\<^sub>2 @ Check_in ga r' (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r' (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in gb r' (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r' (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in gb r' (aa, ba) # s\\<^sub>1)\n                             r' =\n                            {}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"\\<not> safe (Check_in g r c # t) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Trace.safe (Check_in g r c # t) r", "apply(clarsimp simp add:Trace.safe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>Check_in g r c # t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac s\\<^sub>3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>Check_in g r c # t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>Check_in g r c # t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>Check_in g r c # t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply(cases c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list ab ba.\n       \\<lbrakk>Check_in g r c # t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list; c = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"r \\<noteq> r' \\<Longrightarrow> safe (Check_in g r' c # t) r = safe t r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> r' \\<Longrightarrow>\n    Trace.safe (Check_in g r' c # t) r = Trace.safe t r", "apply(simp add:Trace.safe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> r' \\<Longrightarrow>\n    (\\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n        Check_in g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) #\n        s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {}) =\n    (\\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r = {})", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n        Check_in g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) #\n        s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                         t =\n                         s\\<^sub>3 @\n                         Enter g r (a, b) #\n                         s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n                         {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        Check_in g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply(case_tac s\\<^sub>3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        Check_in g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>r \\<noteq> r';\n        Check_in g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 3. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>r \\<noteq> r';\n        Check_in g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, ba) # s\\<^sub>1')\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in ga r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in ga r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Check_in g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Check_in g r' c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r (aa, ba) # s\\<^sub>1')\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Check_in g r' c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3' gb aa ba.\n                            Check_in g r' c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in gb r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in gb r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"r \\<noteq> r' \\<Longrightarrow> safe (Enter g r' c # t) r = safe t r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> r' \\<Longrightarrow>\n    Trace.safe (Enter g r' c # t) r = Trace.safe t r", "apply(simp add:Trace.safe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> r' \\<Longrightarrow>\n    (\\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n        Enter g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) #\n        s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {}) =\n    (\\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r = {})", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n        Enter g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) #\n        s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                         t =\n                         s\\<^sub>3 @\n                         Enter g r (a, b) #\n                         s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n                         {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        Enter g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply(case_tac s\\<^sub>3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        Enter g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>r \\<noteq> r';\n        Enter g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 3. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>r \\<noteq> r';\n        Enter g r' c # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n                            t =\n                            s\\<^sub>3 @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @\n                            Check_in g r (a, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, ba) # s\\<^sub>1')\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 g a b list.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3 ga aa ba.\n                            list @\n                            Enter g r (a, b) #\n                            s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in ga r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in ga r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}\n 2. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<noteq> r';\n     \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n        t =\n        s\\<^sub>3 @\n        Enter g r (a, b) #\n        s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<and>\n        (\\<forall>g a b.\n            Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n            Check_in g r (a, b) \\<notin> set s\\<^sub>2) \\<and>\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n                         Enter g r' c # t =\n                         s\\<^sub>3 @\n                         Enter ga r (a, b) #\n                         s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 \\<and>\n                         (\\<forall>g a b.\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>3 \\<and>\n                             Check_in g r (a, b)\n                             \\<notin> set s\\<^sub>2) \\<and>\n                         Trace.isin\n                          (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n                         {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Enter g r' c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r (aa, ba) # s\\<^sub>1')\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Enter g r' c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>r \\<noteq> r';\n        t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3' gb aa ba.\n                            Enter g r' c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in gb r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in gb r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reach_cong: \"r : reach \\<Longrightarrow> r = r' \\<Longrightarrow> r' : reach\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> reach; r = r'\\<rbrakk> \\<Longrightarrow> r' \\<in> reach", "by simp"], ["", "lemma cards_app: \"cards (s @ s') g = cards s g \\<union> cards s' g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Trace.cards (s @ s') g = Trace.cards s g \\<union> Trace.cards s' g", "by (induct s) (auto split:event.split)"], ["", "lemma ownsD: \"owns s r = Some g \\<Longrightarrow>\n \\<exists>s\\<^sub>1 s\\<^sub>2 c. s = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and> no_Check_in s\\<^sub>2 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Trace.owns s r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n       s = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n       no_Check_in s\\<^sub>2 r", "apply(induct s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Trace.owns [] r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n    \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n       [] = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n       no_Check_in s\\<^sub>2 r\n 2. \\<And>a s.\n       \\<lbrakk>Trace.owns s r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n                \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n                   s = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n                   no_Check_in s\\<^sub>2 r;\n        Trace.owns (a # s) r = \\<lfloor>g\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n                            a # s =\n                            s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n                            no_Check_in s\\<^sub>2 r", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s.\n       \\<lbrakk>Trace.owns s r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n                \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n                   s = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n                   no_Check_in s\\<^sub>2 r;\n        Trace.owns (a # s) r = \\<lfloor>g\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n                            a # s =\n                            s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n                            no_Check_in s\\<^sub>2 r", "apply (auto split:event.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s aa b.\n       (Trace.owns s r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n        \\<exists>s\\<^sub>1 s\\<^sub>2.\n           (\\<exists>a b.\n               s = s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) \\<and>\n           (\\<forall>g a b.\n               Check_in g r (a, b)\n               \\<notin> set s\\<^sub>2)) \\<Longrightarrow>\n       \\<exists>s\\<^sub>1 s\\<^sub>2.\n          (\\<exists>a ba.\n              Check_in g r (aa, b) # s =\n              s\\<^sub>2 @ Check_in g r (a, ba) # s\\<^sub>1) \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2)\n 2. \\<And>x11 x12 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<lbrakk>x12 \\<noteq> r;\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2'.\n                            (\\<exists>a bb.\n                                Check_in x11 x12 (aa, b) #\n                                s\\<^sub>2 @\n                                Check_in g r (ab, ba) # s\\<^sub>1 =\n                                s\\<^sub>2' @\n                                Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 3. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 4. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply(rule_tac x = s in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s aa b.\n       (Trace.owns s r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n        \\<exists>s\\<^sub>1 s\\<^sub>2.\n           (\\<exists>a b.\n               s = s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) \\<and>\n           (\\<forall>g a b.\n               Check_in g r (a, b)\n               \\<notin> set s\\<^sub>2)) \\<Longrightarrow>\n       \\<exists>s\\<^sub>2.\n          (\\<exists>a ba.\n              Check_in g r (aa, b) # s =\n              s\\<^sub>2 @ Check_in g r (a, ba) # s) \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2)\n 2. \\<And>x11 x12 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<lbrakk>x12 \\<noteq> r;\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2'.\n                            (\\<exists>a bb.\n                                Check_in x11 x12 (aa, b) #\n                                s\\<^sub>2 @\n                                Check_in g r (ab, ba) # s\\<^sub>1 =\n                                s\\<^sub>2' @\n                                Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 3. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 4. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply(rule_tac x = \"[]\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s aa b.\n       (Trace.owns s r = \\<lfloor>g\\<rfloor> \\<Longrightarrow>\n        \\<exists>s\\<^sub>1 s\\<^sub>2.\n           (\\<exists>a b.\n               s = s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) \\<and>\n           (\\<forall>g a b.\n               Check_in g r (a, b)\n               \\<notin> set s\\<^sub>2)) \\<Longrightarrow>\n       (\\<exists>a ba.\n           Check_in g r (aa, b) # s = [] @ Check_in g r (a, ba) # s) \\<and>\n       (\\<forall>g a b. Check_in g r (a, b) \\<notin> set [])\n 2. \\<And>x11 x12 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<lbrakk>x12 \\<noteq> r;\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2'.\n                            (\\<exists>a bb.\n                                Check_in x11 x12 (aa, b) #\n                                s\\<^sub>2 @\n                                Check_in g r (ab, ba) # s\\<^sub>1 =\n                                s\\<^sub>2' @\n                                Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 3. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 4. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<lbrakk>x12 \\<noteq> r;\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2'.\n                            (\\<exists>a bb.\n                                Check_in x11 x12 (aa, b) #\n                                s\\<^sub>2 @\n                                Check_in g r (ab, ba) # s\\<^sub>1 =\n                                s\\<^sub>2' @\n                                Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 2. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 3. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x11 x12 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<lbrakk>x12 \\<noteq> r;\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2'.\n                            (\\<exists>a bb.\n                                Check_in x11 x12 (aa, b) #\n                                s\\<^sub>2 @\n                                Check_in g r (ab, ba) # s\\<^sub>1 =\n                                s\\<^sub>2' @\n                                Check_in g r (a, bb) # s\\<^sub>1) \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 2. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 3. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 2. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 aa b s\\<^sub>1 s\\<^sub>2 ab ba.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>2'.\n          (\\<exists>a bb.\n              Enter x21 x22 (aa, b) #\n              s\\<^sub>2 @ Check_in g r (ab, ba) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, bb) # s\\<^sub>1) \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')\n 2. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>1' s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1') \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x31 x32 s\\<^sub>1 s\\<^sub>2 aa b.\n       \\<forall>g a b.\n          Check_in g r (a, b) \\<notin> set s\\<^sub>2 \\<Longrightarrow>\n       \\<exists>s\\<^sub>2'.\n          (\\<exists>a ba.\n              Exit x31 x32 # s\\<^sub>2 @ Check_in g r (aa, b) # s\\<^sub>1 =\n              s\\<^sub>2' @ Check_in g r (a, ba) # s\\<^sub>1) \\<and>\n          (\\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2')", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"safe t r \\<Longrightarrow> safe (Enter g r c # t) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Trace.safe t r \\<Longrightarrow> Trace.safe (Enter g r c # t) r", "apply(clarsimp simp:Trace.safe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Enter g r c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r (aa, ba) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r (aa, ba) # s\\<^sub>1')\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3' gb aa ba.\n                            Enter g r c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2' @\n                            Check_in gb r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in gb r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>t =\n                s\\<^sub>3 @\n                Enter ga r (a, b) #\n                s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r =\n        {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3' gb aa ba.\n                            Enter g r c #\n                            s\\<^sub>3 @\n                            Enter ga r (a, b) #\n                            s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1 =\n                            s\\<^sub>3' @\n                            Enter gb r (aa, ba) #\n                            s\\<^sub>2 @\n                            Check_in gb r (aa, ba) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3' \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @\n                              Check_in gb r (aa, ba) # s\\<^sub>1)\n                             r =\n                            {}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma same_key2D:\n\"hotel (s\\<^sub>2 @ Check_in g r (k\\<^sub>2,k) # s\\<^sub>1) \\<Longrightarrow>\n (k\\<^sub>1,k) : cards(s\\<^sub>2 @ Check_in g r (k\\<^sub>2,k) # s\\<^sub>1) g' \\<Longrightarrow> g=g' \\<and> k\\<^sub>1=k\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hotel (s\\<^sub>2 @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n     (k\\<^sub>1, k)\n     \\<in> Trace.cards (s\\<^sub>2 @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n            g'\\<rbrakk>\n    \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2", "apply(induct s\\<^sub>2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hotel ([] @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n     (k\\<^sub>1, k)\n     \\<in> Trace.cards ([] @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n            g'\\<rbrakk>\n    \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2\n 2. \\<And>a s\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>hotel\n                          (s\\<^sub>2 @\n                           Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n                 (k\\<^sub>1, k)\n                 \\<in> Trace.cards\n                        (s\\<^sub>2 @\n                         Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n                        g'\\<rbrakk>\n                \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2;\n        hotel ((a # s\\<^sub>2) @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n        (k\\<^sub>1, k)\n        \\<in> Trace.cards\n               ((a # s\\<^sub>2) @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n               g'\\<rbrakk>\n       \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>hotel\n                          (s\\<^sub>2 @\n                           Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n                 (k\\<^sub>1, k)\n                 \\<in> Trace.cards\n                        (s\\<^sub>2 @\n                         Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n                        g'\\<rbrakk>\n                \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2;\n        hotel ((a # s\\<^sub>2) @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n        (k\\<^sub>1, k)\n        \\<in> Trace.cards\n               ((a # s\\<^sub>2) @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n               g'\\<rbrakk>\n       \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2", "using [[simp_depth_limit = 5]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a s\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>hotel\n                          (s\\<^sub>2 @\n                           Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n                 (k\\<^sub>1, k)\n                 \\<in> Trace.cards\n                        (s\\<^sub>2 @\n                         Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n                        g'\\<rbrakk>\n                \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2;\n        hotel ((a # s\\<^sub>2) @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1);\n        (k\\<^sub>1, k)\n        \\<in> Trace.cards\n               ((a # s\\<^sub>2) @ Check_in g r (k\\<^sub>2, k) # s\\<^sub>1)\n               g'\\<rbrakk>\n       \\<Longrightarrow> g = g' \\<and> k\\<^sub>1 = k\\<^sub>2", "apply (auto simp:issued_app split:event.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma safe_Enter[simp]: \"hotel (Enter g r (k,k') # t) \\<Longrightarrow>\n safe (Enter g r (k,k') # t) r =\n (owns t r = \\<lfloor>g\\<rfloor> \\<and> isin t r = {} \\<and> k' = currk t r \\<or> safe t r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hotel (Enter g r (k, k') # t) \\<Longrightarrow>\n    Trace.safe (Enter g r (k, k') # t) r =\n    (Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.safe (Enter g r (k, k') # t) r\\<rbrakk>\n    \\<Longrightarrow> Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n                      Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n                      Trace.safe t r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply(frule_tac g=g in Trace.safe, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.safe (Enter g r (k, k') # t) r\\<rbrakk>\n    \\<Longrightarrow> g \\<in> Trace.isin (Enter g r (k, k') # t) r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.safe (Enter g r (k, k') # t) r;\n     Trace.owns (Enter g r (k, k') # t) r = \\<lfloor>g\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n                      Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n                      Trace.safe t r\n 3. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.safe (Enter g r (k, k') # t) r;\n     Trace.owns (Enter g r (k, k') # t) r = \\<lfloor>g\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n                      Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n                      Trace.safe t r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply(clarsimp simp add:Trace.safe_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>Trace.owns t r = \\<lfloor>g\\<rfloor>; hotel t;\n        Enter g r (k, k') # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        (k, k') \\<in> Trace.cards t g;\n        Trace.roomk t r = k \\<or> Trace.roomk t r = k';\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        \\<forall>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n           t =\n           s\\<^sub>3 @\n           Enter g r (a, b) #\n           s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<longrightarrow>\n           (\\<exists>g a b.\n               Check_in g r (a, b) \\<in> set s\\<^sub>3 \\<or>\n               Check_in g r (a, b) \\<in> set s\\<^sub>2) \\<or>\n           Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n            r \\<noteq>\n           {}\\<rbrakk>\n       \\<Longrightarrow> Trace.isin t r = {} \\<and> k' = Trace.currk t r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply(case_tac s\\<^sub>3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b.\n       \\<lbrakk>Trace.owns t r = \\<lfloor>g\\<rfloor>; hotel t;\n        Enter g r (k, k') # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        (k, k') \\<in> Trace.cards t g;\n        Trace.roomk t r = k \\<or> Trace.roomk t r = k';\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        \\<forall>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n           t =\n           s\\<^sub>3 @\n           Enter g r (a, b) #\n           s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<longrightarrow>\n           (\\<exists>g a b.\n               Check_in g r (a, b) \\<in> set s\\<^sub>3 \\<or>\n               Check_in g r (a, b) \\<in> set s\\<^sub>2) \\<or>\n           Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n            r \\<noteq>\n           {};\n        s\\<^sub>3 = []\\<rbrakk>\n       \\<Longrightarrow> Trace.isin t r = {} \\<and> k' = Trace.currk t r\n 2. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>Trace.owns t r = \\<lfloor>g\\<rfloor>; hotel t;\n        Enter g r (k, k') # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        (k, k') \\<in> Trace.cards t g;\n        Trace.roomk t r = k \\<or> Trace.roomk t r = k';\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        \\<forall>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n           t =\n           s\\<^sub>3 @\n           Enter g r (a, b) #\n           s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<longrightarrow>\n           (\\<exists>g a b.\n               Check_in g r (a, b) \\<in> set s\\<^sub>3 \\<or>\n               Check_in g r (a, b) \\<in> set s\\<^sub>2) \\<or>\n           Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n            r \\<noteq>\n           {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> Trace.isin t r = {} \\<and> k' = Trace.currk t r\n 3. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b aa list.\n       \\<lbrakk>Trace.owns t r = \\<lfloor>g\\<rfloor>; hotel t;\n        Enter g r (k, k') # t =\n        s\\<^sub>3 @\n        Enter ga r (a, b) # s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1;\n        (k, k') \\<in> Trace.cards t g;\n        Trace.roomk t r = k \\<or> Trace.roomk t r = k';\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set s\\<^sub>3 \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in ga r (a, b) # s\\<^sub>1) r = {};\n        \\<forall>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 g a b.\n           t =\n           s\\<^sub>3 @\n           Enter g r (a, b) #\n           s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 \\<longrightarrow>\n           (\\<exists>g a b.\n               Check_in g r (a, b) \\<in> set s\\<^sub>3 \\<or>\n               Check_in g r (a, b) \\<in> set s\\<^sub>2) \\<or>\n           Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n            r \\<noteq>\n           {};\n        s\\<^sub>3 = aa # list\\<rbrakk>\n       \\<Longrightarrow> Trace.isin t r = {} \\<and> k' = Trace.currk t r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 s\\<^sub>3 ga a b list.\n       \\<lbrakk>ga = g;\n        hotel\n         (list @\n          Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1);\n        t =\n        list @\n        Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1;\n        (k, k')\n        \\<in> Trace.cards\n               (list @\n                Enter g r (a, b) #\n                s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n               g;\n        Trace.roomk\n         (list @\n          Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n         r =\n        k \\<or>\n        Trace.roomk\n         (list @\n          Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n         r =\n        k';\n        \\<forall>g a b.\n           Check_in g r (a, b) \\<notin> set list \\<and>\n           Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        Trace.isin (s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1) r = {};\n        \\<forall>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3 ga aa ba.\n           list @\n           Enter g r (a, b) # s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1 =\n           s\\<^sub>3 @\n           Enter ga r (aa, ba) #\n           s\\<^sub>2' @\n           Check_in ga r (aa, ba) # s\\<^sub>1' \\<longrightarrow>\n           (\\<exists>g a b.\n               Check_in g r (a, b) \\<in> set s\\<^sub>3 \\<or>\n               Check_in g r (a, b) \\<in> set s\\<^sub>2') \\<or>\n           Trace.isin (s\\<^sub>2' @ Check_in ga r (aa, ba) # s\\<^sub>1')\n            r \\<noteq>\n           {};\n        s\\<^sub>3 = Enter g r (k, k') # list\\<rbrakk>\n       \\<Longrightarrow> Trace.isin\n                          (list @\n                           Enter g r (a, b) #\n                           s\\<^sub>2 @ Check_in g r (a, b) # s\\<^sub>1)\n                          r =\n                         {} \\<and>\n                         k' = b\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r \\<or>\n     Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t); Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t); Trace.safe t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r\n 2. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n     Trace.isin t r = {} \\<and> k' = Trace.currk t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply (erule conjE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t);\n     Trace.owns t r = \\<lfloor>g\\<rfloor>; Trace.isin t r = {};\n     k' = Trace.currk t r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply(drule ownsD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hotel (Enter g r (k, k') # t); Trace.isin t r = {};\n     k' = Trace.currk t r;\n     \\<exists>s\\<^sub>1 s\\<^sub>2 c.\n        t = s\\<^sub>2 @ [Check_in g r c] @ s\\<^sub>1 \\<and>\n        no_Check_in s\\<^sub>2 r\\<rbrakk>\n    \\<Longrightarrow> Trace.safe (Enter g r (k, k') # t) r", "apply(clarsimp simp add:Trace.safe_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 a.\n       \\<lbrakk>Trace.isin (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1)\n                 r =\n                {};\n        hotel (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1);\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        t = s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1;\n        (k, k')\n        \\<in> Trace.cards (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) g;\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r =\n        k \\<or>\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r =\n        k'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3 ga aa b.\n                            Enter g r (k, k') #\n                            s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, b) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, b) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, b) # s\\<^sub>1')\n                             r =\n                            {}", "apply(frule (1) same_key2D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 a.\n       \\<lbrakk>Trace.isin (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1)\n                 r =\n                {};\n        hotel (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1);\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        t = s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1;\n        (k, k')\n        \\<in> Trace.cards (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) g;\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r =\n        k \\<or>\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r = k';\n        g = g \\<and> k = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>1' s\\<^sub>2' s\\<^sub>3 ga aa b.\n                            Enter g r (k, k') #\n                            s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, b) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, b) # s\\<^sub>1' \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, b) # s\\<^sub>1')\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>1 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 a.\n       \\<lbrakk>Trace.isin (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1)\n                 r =\n                {};\n        hotel (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1);\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        t = s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1;\n        (k, k')\n        \\<in> Trace.cards (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) g;\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r =\n        k \\<or>\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r = k';\n        g = g \\<and> k = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>2' s\\<^sub>3 ga aa b.\n                            Enter g r (k, k') #\n                            s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, b) #\n                            s\\<^sub>2' @\n                            Check_in ga r (aa, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2') \\<and>\n                            Trace.isin\n                             (s\\<^sub>2' @\n                              Check_in ga r (aa, b) # s\\<^sub>1)\n                             r =\n                            {}", "apply(rule_tac x = s\\<^sub>2 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 a.\n       \\<lbrakk>Trace.isin (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1)\n                 r =\n                {};\n        hotel (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1);\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        t = s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1;\n        (k, k')\n        \\<in> Trace.cards (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) g;\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r =\n        k \\<or>\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r = k';\n        g = g \\<and> k = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<^sub>3 ga aa b.\n                            Enter g r (k, k') #\n                            s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1 =\n                            s\\<^sub>3 @\n                            Enter ga r (aa, b) #\n                            s\\<^sub>2 @\n                            Check_in ga r (aa, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>3 \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in ga r (aa, b) # s\\<^sub>1)\n                             r =\n                            {}", "apply(rule_tac x = \"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>1 s\\<^sub>2 a.\n       \\<lbrakk>Trace.isin (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1)\n                 r =\n                {};\n        hotel (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1);\n        \\<forall>g a b. Check_in g r (a, b) \\<notin> set s\\<^sub>2;\n        t = s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1;\n        (k, k')\n        \\<in> Trace.cards (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) g;\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r =\n        k \\<or>\n        Trace.roomk (s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1) r = k';\n        g = g \\<and> k = a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ga aa b.\n                            Enter g r (k, k') #\n                            s\\<^sub>2 @ Check_in g r (a, k') # s\\<^sub>1 =\n                            [] @\n                            Enter ga r (aa, b) #\n                            s\\<^sub>2 @\n                            Check_in ga r (aa, b) # s\\<^sub>1 \\<and>\n                            (\\<forall>g a b.\n                                Check_in g r (a, b) \\<notin> set [] \\<and>\n                                Check_in g r (a, b)\n                                \\<notin> set s\\<^sub>2) \\<and>\n                            Trace.isin\n                             (s\\<^sub>2 @ Check_in ga r (aa, b) # s\\<^sub>1)\n                             r =\n                            {}", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hotel_reach: \"inj initk \\<Longrightarrow> hotel t \\<Longrightarrow> \\<lparr> state.owns = owns t,\n state.currk = currk t,\n state.issued = issued t,\n state.cards = cards t,\n state.roomk = roomk t,\n state.isin = isin t,\n state.safe = (%r. safe t r \\<or> owns t r =  None)\\<rparr> : reach\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inj initk; hotel t\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                         currk = Trace.currk t, issued = Trace.issued t,\n                         cards = Trace.cards t, roomk = Trace.roomk t,\n                         isin = Trace.isin t,\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe t r \\<or>\n                              Trace.owns t r = None\\<rparr>\n                      \\<in> reach", "apply(induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj initk; hotel []\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>state.owns = Trace.owns [],\n                         currk = Trace.currk [], issued = Trace.issued [],\n                         cards = Trace.cards [], roomk = Trace.roomk [],\n                         isin = Trace.isin [],\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe [] r \\<or>\n                              Trace.owns [] r = None\\<rparr>\n                      \\<in> reach\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>inj initk; hotel t\\<rbrakk>\n                \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  \\<in> reach;\n        inj initk; hotel (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (a # t),\n                            currk = Trace.currk (a # t),\n                            issued = Trace.issued (a # t),\n                            cards = Trace.cards (a # t),\n                            roomk = Trace.roomk (a # t),\n                            isin = Trace.isin (a # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (a # t) r \\<or>\n                                 Trace.owns (a # t) r = None\\<rparr>\n                         \\<in> reach", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj initk \\<Longrightarrow>\n    \\<lparr>state.owns = Trace.owns [], currk = Trace.currk [],\n       issued = range initk, cards = Trace.cards [], roomk = Trace.roomk [],\n       isin = Trace.isin [], safe = \\<lambda>r. True\\<rparr>\n    \\<in> reach\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>inj initk; hotel t\\<rbrakk>\n                \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  \\<in> reach;\n        inj initk; hotel (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (a # t),\n                            currk = Trace.currk (a # t),\n                            issued = Trace.issued (a # t),\n                            cards = Trace.cards (a # t),\n                            roomk = Trace.roomk (a # t),\n                            isin = Trace.isin (a # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (a # t) r \\<or>\n                                 Trace.owns (a # t) r = None\\<rparr>\n                         \\<in> reach", "apply(insert State.init[where initk=initk])[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj initk;\n     inj initk \\<Longrightarrow>\n     \\<lparr>state.owns = Map.empty, currk = initk, issued = range initk,\n        cards = \\<lambda>g. {}, roomk = initk, isin = \\<lambda>r. {},\n        safe = \\<lambda>r. True\\<rparr>\n     \\<in> reach\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>state.owns = Trace.owns [],\n                         currk = Trace.currk [], issued = range initk,\n                         cards = Trace.cards [], roomk = Trace.roomk [],\n                         isin = Trace.isin [],\n                         safe = \\<lambda>r. True\\<rparr>\n                      \\<in> reach\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>inj initk; hotel t\\<rbrakk>\n                \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  \\<in> reach;\n        inj initk; hotel (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (a # t),\n                            currk = Trace.currk (a # t),\n                            issued = Trace.issued (a # t),\n                            cards = Trace.cards (a # t),\n                            roomk = Trace.roomk (a # t),\n                            isin = Trace.isin (a # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (a # t) r \\<or>\n                                 Trace.owns (a # t) r = None\\<rparr>\n                         \\<in> reach", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>inj initk;\n     \\<lparr>state.owns = Map.empty, currk = initk, issued = range initk,\n        cards = \\<lambda>g. {}, roomk = initk, isin = \\<lambda>r. {},\n        safe = \\<lambda>r. True\\<rparr>\n     \\<in> reach\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>state.owns = Trace.owns [],\n                         currk = Trace.currk [], issued = range initk,\n                         cards = Trace.cards [], roomk = Trace.roomk [],\n                         isin = Trace.isin [],\n                         safe = \\<lambda>r. True\\<rparr>\n                      \\<in> reach\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>inj initk; hotel t\\<rbrakk>\n                \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  \\<in> reach;\n        inj initk; hotel (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (a # t),\n                            currk = Trace.currk (a # t),\n                            issued = Trace.issued (a # t),\n                            cards = Trace.cards (a # t),\n                            roomk = Trace.roomk (a # t),\n                            isin = Trace.isin (a # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (a # t) r \\<or>\n                                 Trace.owns (a # t) r = None\\<rparr>\n                         \\<in> reach", "apply(erule reach_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj initk \\<Longrightarrow>\n    \\<lparr>state.owns = Map.empty, currk = initk, issued = range initk,\n       cards = \\<lambda>g. {}, roomk = initk, isin = \\<lambda>r. {},\n       safe = \\<lambda>r. True\\<rparr> =\n    \\<lparr>state.owns = Trace.owns [], currk = Trace.currk [],\n       issued = range initk, cards = Trace.cards [], roomk = Trace.roomk [],\n       isin = Trace.isin [], safe = \\<lambda>r. True\\<rparr>\n 2. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>inj initk; hotel t\\<rbrakk>\n                \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  \\<in> reach;\n        inj initk; hotel (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (a # t),\n                            currk = Trace.currk (a # t),\n                            issued = Trace.issued (a # t),\n                            cards = Trace.cards (a # t),\n                            roomk = Trace.roomk (a # t),\n                            isin = Trace.isin (a # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (a # t) r \\<or>\n                                 Trace.owns (a # t) r = None\\<rparr>\n                         \\<in> reach", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a t.\n       \\<lbrakk>\\<lbrakk>inj initk; hotel t\\<rbrakk>\n                \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  \\<in> reach;\n        inj initk; hotel (a # t)\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (a # t),\n                            currk = Trace.currk (a # t),\n                            issued = Trace.issued (a # t),\n                            cards = Trace.cards (a # t),\n                            roomk = Trace.roomk (a # t),\n                            isin = Trace.isin (a # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (a # t) r \\<or>\n                                 Trace.owns (a # t) r = None\\<rparr>\n                         \\<in> reach", "apply (clarsimp split:event.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x11 x12 ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; ba \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in x11 x12\n(Trace.currk t x12, ba) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            issued = {ba} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 x12 \\<noteq> r \\<and>\n                                 (x12 \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 2. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach\n 3. \\<And>t x31 x32.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; x31 \\<in> Trace.isin t x32\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (Exit x31 x32 # t),\n                            currk = Trace.currk (Exit x31 x32 # t),\n                            issued = Trace.issued t,\n                            cards = Trace.cards (Exit x31 x32 # t),\n                            roomk = Trace.roomk (Exit x31 x32 # t),\n                            isin = Trace.isin (Exit x31 x32 # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x31 x32.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; x31 \\<in> Trace.isin t x32\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (Exit x31 x32 # t),\n                            currk = Trace.currk (Exit x31 x32 # t),\n                            issued = Trace.issued t,\n                            cards = Trace.cards (Exit x31 x32 # t),\n                            roomk = Trace.roomk (Exit x31 x32 # t),\n                            isin = Trace.isin (Exit x31 x32 # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach\n 2. \\<And>t x11 x12 ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; ba \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in x11 x12\n(Trace.currk t x12, ba) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            issued = {ba} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 x12 \\<noteq> r \\<and>\n                                 (x12 \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 3. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(drule exit_room)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t x31 x32.\n       \\<lbrakk>inj initk; hotel t; x31 \\<in> Trace.isin t x32\\<rbrakk>\n       \\<Longrightarrow> ?g88 t x31 x32\n                         \\<in> state.isin\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                (?r88 t x31 x32)\n 2. \\<And>t x31 x32.\n       \\<lbrakk>inj initk; hotel t; x31 \\<in> Trace.isin t x32;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>isin :=\n                  (state.isin\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (?r88 t x31 x32 :=\n                     state.isin\n                      \\<lparr>state.owns = Trace.owns t,\n                         currk = Trace.currk t, issued = Trace.issued t,\n                         cards = Trace.cards t, roomk = Trace.roomk t,\n                         isin = Trace.isin t,\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe t r \\<or>\n                              Trace.owns t r = None\\<rparr>\n                      (?r88 t x31 x32) -\n                     {?g88 t x31 x32})\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (Exit x31 x32 # t),\n                            currk = Trace.currk (Exit x31 x32 # t),\n                            issued = Trace.issued t,\n                            cards = Trace.cards (Exit x31 x32 # t),\n                            roomk = Trace.roomk (Exit x31 x32 # t),\n                            isin = Trace.isin (Exit x31 x32 # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach\n 3. \\<And>t x11 x12 ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; ba \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in x11 x12\n(Trace.currk t x12, ba) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            issued = {ba} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 x12 \\<noteq> r \\<and>\n                                 (x12 \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 4. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x31 x32.\n       \\<lbrakk>inj initk; hotel t; x31 \\<in> Trace.isin t x32;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>isin :=\n                  (state.isin\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (x32 :=\n                     state.isin\n                      \\<lparr>state.owns = Trace.owns t,\n                         currk = Trace.currk t, issued = Trace.issued t,\n                         cards = Trace.cards t, roomk = Trace.roomk t,\n                         isin = Trace.isin t,\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe t r \\<or>\n                              Trace.owns t r = None\\<rparr>\n                      x32 -\n                     {x31})\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns (Exit x31 x32 # t),\n                            currk = Trace.currk (Exit x31 x32 # t),\n                            issued = Trace.issued t,\n                            cards = Trace.cards (Exit x31 x32 # t),\n                            roomk = Trace.roomk (Exit x31 x32 # t),\n                            isin = Trace.isin (Exit x31 x32 # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach\n 2. \\<And>t x11 x12 ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; ba \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in x11 x12\n(Trace.currk t x12, ba) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            issued = {ba} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 x12 \\<noteq> r \\<and>\n                                 (x12 \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 3. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(erule reach_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t x31 x32.\n       \\<lbrakk>inj initk; hotel t; x31 \\<in> Trace.isin t x32\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                            currk = Trace.currk t, issued = Trace.issued t,\n                            cards = Trace.cards t, roomk = Trace.roomk t,\n                            isin = Trace.isin t,\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<lparr>isin :=\n                                   (state.isin\n                                     \\<lparr>state.owns = Trace.owns t,\n  currk = Trace.currk t, issued = Trace.issued t, cards = Trace.cards t,\n  roomk = Trace.roomk t, isin = Trace.isin t,\n  safe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                                   (x32 :=\nstate.isin\n \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n    issued = Trace.issued t, cards = Trace.cards t, roomk = Trace.roomk t,\n    isin = Trace.isin t,\n    safe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n x32 -\n{x31})\\<rparr> =\n                         \\<lparr>state.owns = Trace.owns (Exit x31 x32 # t),\n                            currk = Trace.currk (Exit x31 x32 # t),\n                            issued = Trace.issued t,\n                            cards = Trace.cards (Exit x31 x32 # t),\n                            roomk = Trace.roomk (Exit x31 x32 # t),\n                            isin = Trace.isin (Exit x31 x32 # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n 2. \\<And>t x11 x12 ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; ba \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in x11 x12\n(Trace.currk t x12, ba) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            issued = {ba} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 x12 \\<noteq> r \\<and>\n                                 (x12 \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 3. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t x11 x12 ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; ba \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in x11 x12\n(Trace.currk t x12, ba) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            issued = {ba} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in x11 x12 (Trace.currk t x12, ba) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 x12 \\<noteq> r \\<and>\n                                 (x12 \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 2. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(rename_tac guest room key)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t guest room key.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; key \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in guest room\n(Trace.currk t room, key) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            issued = {key} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 room \\<noteq> r \\<and>\n                                 (room \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 2. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(drule_tac g = guest and r = room in check_in)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t guest room key.\n       \\<lbrakk>inj initk; hotel t; key \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> ?k100 t guest room key\n                         \\<notin> state.issued\n                                   \\<lparr>state.owns = Trace.owns t,\ncurrk = Trace.currk t, issued = Trace.issued t, cards = Trace.cards t,\nroomk = Trace.roomk t, isin = Trace.isin t,\nsafe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n 2. \\<And>t guest room key.\n       \\<lbrakk>inj initk; hotel t; key \\<notin> Trace.issued t;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>currk :=\n                  (state.currk\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (room := ?k100 t guest room key),\n           issued :=\n             state.issued\n              \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                 issued = Trace.issued t, cards = Trace.cards t,\n                 roomk = Trace.roomk t, isin = Trace.isin t,\n                 safe =\n                   \\<lambda>r.\n                      Trace.safe t r \\<or>\n                      Trace.owns t r = None\\<rparr> \\<union>\n             {?k100 t guest room key},\n           cards :=\n             (state.cards\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (guest :=\n                state.cards\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 guest \\<union>\n                {(state.currk\n                   \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                      issued = Trace.issued t, cards = Trace.cards t,\n                      roomk = Trace.roomk t, isin = Trace.isin t,\n                      safe =\n                        \\<lambda>r.\n                           Trace.safe t r \\<or>\n                           Trace.owns t r = None\\<rparr>\n                   room,\n                  ?k100 t guest room key)}),\n           owns :=\n             (state.owns\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := \\<lfloor>guest\\<rfloor>),\n           safe :=\n             (state.safe\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := False)\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in guest room\n(Trace.currk t room, key) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            issued = {key} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 room \\<noteq> r \\<and>\n                                 (room \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 3. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t guest room key.\n       \\<lbrakk>inj initk; hotel t; key \\<notin> Trace.issued t;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>currk :=\n                  (state.currk\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (room := key),\n           issued :=\n             state.issued\n              \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                 issued = Trace.issued t, cards = Trace.cards t,\n                 roomk = Trace.roomk t, isin = Trace.isin t,\n                 safe =\n                   \\<lambda>r.\n                      Trace.safe t r \\<or>\n                      Trace.owns t r = None\\<rparr> \\<union>\n             {key},\n           cards :=\n             (state.cards\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (guest :=\n                state.cards\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 guest \\<union>\n                {(state.currk\n                   \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                      issued = Trace.issued t, cards = Trace.cards t,\n                      roomk = Trace.roomk t, isin = Trace.isin t,\n                      safe =\n                        \\<lambda>r.\n                           Trace.safe t r \\<or>\n                           Trace.owns t r = None\\<rparr>\n                   room,\n                  key)}),\n           owns :=\n             (state.owns\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := \\<lfloor>guest\\<rfloor>),\n           safe :=\n             (state.safe\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := False)\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in guest room\n(Trace.currk t room, key) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            issued = {key} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 room \\<noteq> r \\<and>\n                                 (room \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n                         \\<in> reach\n 2. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(erule reach_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t guest room key.\n       \\<lbrakk>inj initk; hotel t; key \\<notin> Trace.issued t\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                            currk = Trace.currk t, issued = Trace.issued t,\n                            cards = Trace.cards t, roomk = Trace.roomk t,\n                            isin = Trace.isin t,\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<lparr>currk :=\n                                   (state.currk\n                                     \\<lparr>state.owns = Trace.owns t,\n  currk = Trace.currk t, issued = Trace.issued t, cards = Trace.cards t,\n  roomk = Trace.roomk t, isin = Trace.isin t,\n  safe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                                   (room := key),\n                            issued :=\n                              state.issued\n                               \\<lparr>state.owns = Trace.owns t,\n                                  currk = Trace.currk t,\n                                  issued = Trace.issued t,\n                                  cards = Trace.cards t,\n                                  roomk = Trace.roomk t,\n                                  isin = Trace.isin t,\n                                  safe =\n                                    \\<lambda>r.\n Trace.safe t r \\<or> Trace.owns t r = None\\<rparr> \\<union>\n                              {key},\n                            cards :=\n                              (state.cards\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                              (guest :=\n                                 state.cards\n                                  \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  guest \\<union>\n                                 {(state.currk\n                                    \\<lparr>state.owns = Trace.owns t,\n currk = Trace.currk t, issued = Trace.issued t, cards = Trace.cards t,\n roomk = Trace.roomk t, isin = Trace.isin t,\n safe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                    room,\n                                   key)}),\n                            owns :=\n                              (state.owns\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                              (room := \\<lfloor>guest\\<rfloor>),\n                            safe :=\n                              (state.safe\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                              (room := False)\\<rparr> =\n                         \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Check_in guest room\n(Trace.currk t room, key) #\n                                     t),\n                            currk =\n                              Trace.currk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            issued = {key} \\<union> Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            roomk =\n                              Trace.roomk\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            isin =\n                              Trace.isin\n                               (Check_in guest room\n                                 (Trace.currk t room, key) #\n                                t),\n                            safe =\n                              \\<lambda>r.\n                                 room \\<noteq> r \\<and>\n                                 (room \\<noteq> r \\<longrightarrow>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None)\\<rparr>\n 2. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x21 x22 ab ba.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (ab, ba) \\<in> Trace.cards t x21;\n        Trace.roomk t x22 = ab \\<or> Trace.roomk t x22 = ba\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns (Enter x21 x22 (ab, ba) # t),\n                            currk =\n                              Trace.currk (Enter x21 x22 (ab, ba) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards (Enter x21 x22 (ab, ba) # t),\n                            roomk =\n                              Trace.roomk (Enter x21 x22 (ab, ba) # t),\n                            isin = Trace.isin (Enter x21 x22 (ab, ba) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe (Enter x21 x22 (ab, ba) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(rename_tac guest room key1 key2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t guest room key1 key2.\n       \\<lbrakk>\\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                   issued = Trace.issued t, cards = Trace.cards t,\n                   roomk = Trace.roomk t, isin = Trace.isin t,\n                   safe =\n                     \\<lambda>r.\n                        Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                \\<in> reach;\n        inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Enter guest room (key1, key2) # t),\n                            currk =\n                              Trace.currk\n                               (Enter guest room (key1, key2) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Enter guest room (key1, key2) # t),\n                            roomk =\n                              Trace.roomk\n                               (Enter guest room (key1, key2) # t),\n                            isin =\n                              Trace.isin\n                               (Enter guest room (key1, key2) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe\n                                  (Enter guest room (key1, key2) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(drule_tac g = guest and r = room in enter_room)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2\\<rbrakk>\n       \\<Longrightarrow> (?k132 t guest room key1 key2,\n                          ?k'132 t guest room key1 key2)\n                         \\<in> state.cards\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                guest\n 2. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2\\<rbrakk>\n       \\<Longrightarrow> state.roomk\n                          \\<lparr>state.owns = Trace.owns t,\n                             currk = Trace.currk t, issued = Trace.issued t,\n                             cards = Trace.cards t, roomk = Trace.roomk t,\n                             isin = Trace.isin t,\n                             safe =\n                               \\<lambda>r.\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None\\<rparr>\n                          room\n                         \\<in> {?k132 t guest room key1 key2,\n                                ?k'132 t guest room key1 key2}\n 3. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>isin :=\n                  (state.isin\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (room :=\n                     state.isin\n                      \\<lparr>state.owns = Trace.owns t,\n                         currk = Trace.currk t, issued = Trace.issued t,\n                         cards = Trace.cards t, roomk = Trace.roomk t,\n                         isin = Trace.isin t,\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe t r \\<or>\n                              Trace.owns t r = None\\<rparr>\n                      room \\<union>\n                     {guest}),\n           roomk :=\n             (state.roomk\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := ?k'132 t guest room key1 key2),\n           safe :=\n             (state.safe\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room :=\n                state.owns\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room =\n                \\<lfloor>guest\\<rfloor> \\<and>\n                state.isin\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room =\n                {} \\<and>\n                ?k'132 t guest room key1 key2 =\n                state.currk\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room \\<or>\n                state.safe\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room)\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Enter guest room (key1, key2) # t),\n                            currk =\n                              Trace.currk\n                               (Enter guest room (key1, key2) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Enter guest room (key1, key2) # t),\n                            roomk =\n                              Trace.roomk\n                               (Enter guest room (key1, key2) # t),\n                            isin =\n                              Trace.isin\n                               (Enter guest room (key1, key2) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe\n                                  (Enter guest room (key1, key2) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2\\<rbrakk>\n       \\<Longrightarrow> state.roomk\n                          \\<lparr>state.owns = Trace.owns t,\n                             currk = Trace.currk t, issued = Trace.issued t,\n                             cards = Trace.cards t, roomk = Trace.roomk t,\n                             isin = Trace.isin t,\n                             safe =\n                               \\<lambda>r.\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None\\<rparr>\n                          room\n                         \\<in> {key1, key2}\n 2. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>isin :=\n                  (state.isin\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (room :=\n                     state.isin\n                      \\<lparr>state.owns = Trace.owns t,\n                         currk = Trace.currk t, issued = Trace.issued t,\n                         cards = Trace.cards t, roomk = Trace.roomk t,\n                         isin = Trace.isin t,\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe t r \\<or>\n                              Trace.owns t r = None\\<rparr>\n                      room \\<union>\n                     {guest}),\n           roomk :=\n             (state.roomk\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := key2),\n           safe :=\n             (state.safe\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room :=\n                state.owns\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room =\n                \\<lfloor>guest\\<rfloor> \\<and>\n                state.isin\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room =\n                {} \\<and>\n                key2 =\n                state.currk\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room \\<or>\n                state.safe\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room)\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Enter guest room (key1, key2) # t),\n                            currk =\n                              Trace.currk\n                               (Enter guest room (key1, key2) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Enter guest room (key1, key2) # t),\n                            roomk =\n                              Trace.roomk\n                               (Enter guest room (key1, key2) # t),\n                            isin =\n                              Trace.isin\n                               (Enter guest room (key1, key2) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe\n                                  (Enter guest room (key1, key2) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2;\n        \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n           issued = Trace.issued t, cards = Trace.cards t,\n           roomk = Trace.roomk t, isin = Trace.isin t,\n           safe =\n             \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n        \\<lparr>isin :=\n                  (state.isin\n                    \\<lparr>state.owns = Trace.owns t,\n                       currk = Trace.currk t, issued = Trace.issued t,\n                       cards = Trace.cards t, roomk = Trace.roomk t,\n                       isin = Trace.isin t,\n                       safe =\n                         \\<lambda>r.\n                            Trace.safe t r \\<or>\n                            Trace.owns t r = None\\<rparr>)\n                  (room :=\n                     state.isin\n                      \\<lparr>state.owns = Trace.owns t,\n                         currk = Trace.currk t, issued = Trace.issued t,\n                         cards = Trace.cards t, roomk = Trace.roomk t,\n                         isin = Trace.isin t,\n                         safe =\n                           \\<lambda>r.\n                              Trace.safe t r \\<or>\n                              Trace.owns t r = None\\<rparr>\n                      room \\<union>\n                     {guest}),\n           roomk :=\n             (state.roomk\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room := key2),\n           safe :=\n             (state.safe\n               \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                  issued = Trace.issued t, cards = Trace.cards t,\n                  roomk = Trace.roomk t, isin = Trace.isin t,\n                  safe =\n                    \\<lambda>r.\n                       Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n             (room :=\n                state.owns\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room =\n                \\<lfloor>guest\\<rfloor> \\<and>\n                state.isin\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room =\n                {} \\<and>\n                key2 =\n                state.currk\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room \\<or>\n                state.safe\n                 \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n                    issued = Trace.issued t, cards = Trace.cards t,\n                    roomk = Trace.roomk t, isin = Trace.isin t,\n                    safe =\n                      \\<lambda>r.\n                         Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                 room)\\<rparr>\n        \\<in> reach\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Enter guest room (key1, key2) # t),\n                            currk =\n                              Trace.currk\n                               (Enter guest room (key1, key2) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Enter guest room (key1, key2) # t),\n                            roomk =\n                              Trace.roomk\n                               (Enter guest room (key1, key2) # t),\n                            isin =\n                              Trace.isin\n                               (Enter guest room (key1, key2) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe\n                                  (Enter guest room (key1, key2) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<in> reach", "apply(erule reach_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t guest room key1 key2.\n       \\<lbrakk>inj initk; hotel t; (key1, key2) \\<in> Trace.cards t guest;\n        Trace.roomk t room = key1 \\<or> Trace.roomk t room = key2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>state.owns = Trace.owns t,\n                            currk = Trace.currk t, issued = Trace.issued t,\n                            cards = Trace.cards t, roomk = Trace.roomk t,\n                            isin = Trace.isin t,\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe t r \\<or>\n                                 Trace.owns t r = None\\<rparr>\n                         \\<lparr>isin :=\n                                   (state.isin\n                                     \\<lparr>state.owns = Trace.owns t,\n  currk = Trace.currk t, issued = Trace.issued t, cards = Trace.cards t,\n  roomk = Trace.roomk t, isin = Trace.isin t,\n  safe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                                   (room :=\nstate.isin\n \\<lparr>state.owns = Trace.owns t, currk = Trace.currk t,\n    issued = Trace.issued t, cards = Trace.cards t, roomk = Trace.roomk t,\n    isin = Trace.isin t,\n    safe = \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n room \\<union>\n{guest}),\n                            roomk :=\n                              (state.roomk\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                              (room := key2),\n                            safe :=\n                              (state.safe\n                                \\<lparr>state.owns = Trace.owns t,\n                                   currk = Trace.currk t,\n                                   issued = Trace.issued t,\n                                   cards = Trace.cards t,\n                                   roomk = Trace.roomk t,\n                                   isin = Trace.isin t,\n                                   safe =\n                                     \\<lambda>r.\n  Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>)\n                              (room :=\n                                 state.owns\n                                  \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  room =\n                                 \\<lfloor>guest\\<rfloor> \\<and>\n                                 state.isin\n                                  \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  room =\n                                 {} \\<and>\n                                 key2 =\n                                 state.currk\n                                  \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  room \\<or>\n                                 state.safe\n                                  \\<lparr>state.owns = Trace.owns t,\n                                     currk = Trace.currk t,\n                                     issued = Trace.issued t,\n                                     cards = Trace.cards t,\n                                     roomk = Trace.roomk t,\n                                     isin = Trace.isin t,\n                                     safe =\n \\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None\\<rparr>\n                                  room)\\<rparr> =\n                         \\<lparr>state.owns =\n                                   Trace.owns\n                                    (Enter guest room (key1, key2) # t),\n                            currk =\n                              Trace.currk\n                               (Enter guest room (key1, key2) # t),\n                            issued = Trace.issued t,\n                            cards =\n                              Trace.cards\n                               (Enter guest room (key1, key2) # t),\n                            roomk =\n                              Trace.roomk\n                               (Enter guest room (key1, key2) # t),\n                            isin =\n                              Trace.isin\n                               (Enter guest room (key1, key2) # t),\n                            safe =\n                              \\<lambda>r.\n                                 Trace.safe\n                                  (Enter guest room (key1, key2) # t)\n                                  r \\<or>\n                                 Trace.owns t r = None\\<rparr>", "apply (fastforce simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reach_hotel: \"s : reach \\<Longrightarrow>\n \\<exists>t ik. initk = ik \\<longrightarrow> hotel t \\<and>\n state.cards s = cards t \\<and>\n state.isin s =  isin t \\<and>\n state.roomk s = roomk t \\<and> state.owns s = owns t \\<and>\n state.currk s = currk t \\<and>\n state.issued s = issued t \\<and>\n state.safe s = (\\<lambda>r. safe t r \\<or> owns t r = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach \\<Longrightarrow>\n    \\<exists>t ik.\n       initk = ik \\<longrightarrow>\n       hotel t \\<and>\n       state.cards s = Trace.cards t \\<and>\n       state.isin s = Trace.isin t \\<and>\n       state.roomk s = Trace.roomk t \\<and>\n       state.owns s = Trace.owns t \\<and>\n       state.currk s = Trace.currk t \\<and>\n       state.issued s = Trace.issued t \\<and>\n       state.safe s =\n       (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None)", "apply(erule reach.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>initka.\n       inj initka \\<Longrightarrow>\n       \\<exists>t ik.\n          initk = ik \\<longrightarrow>\n          hotel t \\<and>\n          state.cards\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.cards t \\<and>\n          state.isin\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.isin t \\<and>\n          state.roomk\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.roomk t \\<and>\n          state.owns\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.owns t \\<and>\n          state.currk\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.currk t \\<and>\n          state.issued\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.issued t \\<and>\n          state.safe\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None)\n 2. \\<And>s k r g.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        k \\<notin> state.issued s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 3. \\<And>s k k' g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        (k, k') \\<in> state.cards s g;\n        state.roomk s r \\<in> {k, k'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 4. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply(rule_tac x = \"[]\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>initka.\n       inj initka \\<Longrightarrow>\n       \\<exists>ik.\n          initk = ik \\<longrightarrow>\n          hotel [] \\<and>\n          state.cards\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.cards [] \\<and>\n          state.isin\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.isin [] \\<and>\n          state.roomk\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.roomk [] \\<and>\n          state.owns\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.owns [] \\<and>\n          state.currk\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.currk [] \\<and>\n          state.issued\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          Trace.issued [] \\<and>\n          state.safe\n           \\<lparr>state.owns = Map.empty, currk = initka,\n              issued = range initka, cards = \\<lambda>g. {}, roomk = initka,\n              isin = \\<lambda>r. {}, safe = \\<lambda>r. True\\<rparr> =\n          (\\<lambda>r. Trace.safe [] r \\<or> Trace.owns [] r = None)\n 2. \\<And>s k r g.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        k \\<notin> state.issued s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 3. \\<And>s k k' g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        (k, k') \\<in> state.cards s g;\n        state.roomk s r \\<in> {k, k'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 4. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s k r g.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        k \\<notin> state.issued s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>currk := (state.currk s)(r := k),\n                                  issued := state.issued s \\<union> {k},\n                                  cards := (state.cards s)\n                                    (g :=\n state.cards s g \\<union> {(state.currk s r, k)}),\n                                  owns := (state.owns s)\n                                    (r := \\<lfloor>g\\<rfloor>),\n                                  safe := (state.safe s)\n                                    (r := False)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 2. \\<And>s k k' g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        (k, k') \\<in> state.cards s g;\n        state.roomk s r \\<in> {k, k'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 3. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s k r g t.\n       \\<lbrakk>s \\<in> reach; k \\<notin> Trace.issued t; All ((=) initk);\n        hotel t; state.cards s = Trace.cards t; state.isin s = Trace.isin t;\n        state.roomk s = Trace.roomk t; state.owns s = Trace.owns t;\n        state.currk s = Trace.currk t; state.issued s = Trace.issued t;\n        state.safe s =\n        (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<lambda>a.\n                                if a = g\n                                then {(state.currk s r, k)} \\<union>\n                                     state.cards s g\n                                else state.cards s a) =\n                            Trace.cards ta \\<and>\n                            Trace.isin t = Trace.isin ta \\<and>\n                            Trace.roomk t = Trace.roomk ta \\<and>\n                            (\\<lambda>a.\n                                if a = r then \\<lfloor>g\\<rfloor>\n                                else state.owns s a) =\n                            Trace.owns ta \\<and>\n                            (\\<lambda>a.\n                                if a = r then k else state.currk s a) =\n                            Trace.currk ta \\<and>\n                            {k} \\<union> Trace.issued t =\n                            Trace.issued ta \\<and>\n                            (\\<lambda>x.\n                                x \\<noteq> r \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.safe t x \\<or>\n                                 Trace.owns t x = None)) =\n                            (\\<lambda>r.\n                                Trace.safe ta r \\<or>\n                                Trace.owns ta r = None)\n 2. \\<And>s k k' g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        (k, k') \\<in> state.cards s g;\n        state.roomk s r \\<in> {k, k'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 3. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply(rule_tac x = \"Check_in g r (currk t r,k) # t\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s k r g t.\n       \\<lbrakk>s \\<in> reach; k \\<notin> Trace.issued t; All ((=) initk);\n        hotel t; state.cards s = Trace.cards t; state.isin s = Trace.isin t;\n        state.roomk s = Trace.roomk t; state.owns s = Trace.owns t;\n        state.currk s = Trace.currk t; state.issued s = Trace.issued t;\n        state.safe s =\n        (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None)\\<rbrakk>\n       \\<Longrightarrow> hotel\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         (\\<lambda>a.\n                             if a = g\n                             then {(state.currk s r, k)} \\<union>\n                                  state.cards s g\n                             else state.cards s a) =\n                         Trace.cards\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         Trace.isin t =\n                         Trace.isin\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         Trace.roomk t =\n                         Trace.roomk\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         (\\<lambda>a.\n                             if a = r then \\<lfloor>g\\<rfloor>\n                             else state.owns s a) =\n                         Trace.owns\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         (\\<lambda>a.\n                             if a = r then k else state.currk s a) =\n                         Trace.currk\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         {k} \\<union> Trace.issued t =\n                         Trace.issued\n                          (Check_in g r (Trace.currk t r, k) # t) \\<and>\n                         (\\<lambda>x.\n                             x \\<noteq> r \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              Trace.safe t x \\<or> Trace.owns t x = None)) =\n                         (\\<lambda>ra.\n                             Trace.safe\n                              (Check_in g r (Trace.currk t r, k) # t)\n                              ra \\<or>\n                             Trace.owns\n                              (Check_in g r (Trace.currk t r, k) # t) ra =\n                             None)\n 2. \\<And>s k k' g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        (k, k') \\<in> state.cards s g;\n        state.roomk s r \\<in> {k, k'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 3. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply (simp add: fun_eq_iff [where 'a=room] fun_eq_iff [where 'a=guest])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s k k' g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        (k, k') \\<in> state.cards s g;\n        state.roomk s r \\<in> {k, k'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r \\<union> {g}),\n                                  roomk := (state.roomk s)(r := k'),\n                                  safe := (state.safe s)\n                                    (r :=\n state.owns s r = \\<lfloor>g\\<rfloor> \\<and>\n state.isin s r = {} \\<and> k' = state.currk s r \\<or>\n state.safe s r)\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)\n 2. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply (clarsimp simp add: fun_eq_iff [where 'a=room] fun_eq_iff [where 'a=guest and 'b=\"(key \\<times> key) set\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s k k' g r t.\n       \\<lbrakk>s \\<in> reach; (k, k') \\<in> Trace.cards t g;\n        Trace.roomk t r = k \\<or> Trace.roomk t r = k';\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x =\n           (Trace.safe t x \\<or> Trace.owns t x = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 2. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply(erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s k k' g r t.\n       \\<lbrakk>s \\<in> reach; (k, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x = (Trace.safe t x \\<or> Trace.owns t x = None);\n        Trace.roomk t r = k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 2. \\<And>s k k' g r t.\n       \\<lbrakk>s \\<in> reach; (k, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x = (Trace.safe t x \\<or> Trace.owns t x = None);\n        Trace.roomk t r = k'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 3. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s k' g r t.\n       \\<lbrakk>s \\<in> reach; (Trace.roomk t r, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x =\n           (Trace.safe t x \\<or> Trace.owns t x = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 2. \\<And>s k k' g r t.\n       \\<lbrakk>s \\<in> reach; (k, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x = (Trace.safe t x \\<or> Trace.owns t x = None);\n        Trace.roomk t r = k'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 3. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply(rule_tac x = \"Enter g r (roomk t r,k') # t\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s k' g r t.\n       \\<lbrakk>s \\<in> reach; (Trace.roomk t r, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x =\n           (Trace.safe t x \\<or> Trace.owns t x = None)\\<rbrakk>\n       \\<Longrightarrow> hotel (Enter g r (Trace.roomk t r, k') # t) \\<and>\n                         (\\<forall>x.\n                             Trace.cards t x =\n                             Trace.cards\n                              (Enter g r (Trace.roomk t r, k') # t)\n                              x) \\<and>\n                         (\\<forall>x.\n                             (x = r \\<longrightarrow>\n                              {g} \\<union> Trace.isin t r =\n                              Trace.isin\n                               (Enter g r (Trace.roomk t r, k') # t)\n                               r) \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              Trace.isin t x =\n                              Trace.isin\n                               (Enter g r (Trace.roomk t r, k') # t)\n                               x)) \\<and>\n                         (\\<forall>x.\n                             (x = r \\<longrightarrow>\n                              k' =\n                              Trace.roomk\n                               (Enter g r (Trace.roomk t r, k') # t)\n                               r) \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              Trace.roomk t x =\n                              Trace.roomk\n                               (Enter g r (Trace.roomk t r, k') # t)\n                               x)) \\<and>\n                         (\\<forall>x.\n                             Trace.owns t x =\n                             Trace.owns\n                              (Enter g r (Trace.roomk t r, k') # t)\n                              x) \\<and>\n                         (\\<forall>x.\n                             Trace.currk t x =\n                             Trace.currk\n                              (Enter g r (Trace.roomk t r, k') # t)\n                              x) \\<and>\n                         Trace.issued t =\n                         Trace.issued\n                          (Enter g r (Trace.roomk t r, k') # t) \\<and>\n                         (\\<forall>x.\n                             (x = r \\<longrightarrow>\n                              (Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n                               Trace.isin t r = {} \\<and>\n                               k' = Trace.currk t r \\<or>\n                               Trace.safe t r \\<or> Trace.owns t r = None) =\n                              (Trace.safe\n                                (Enter g r (Trace.roomk t r, k') # t)\n                                r \\<or>\n                               Trace.owns\n                                (Enter g r (Trace.roomk t r, k') # t) r =\n                               None)) \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              (Trace.safe t x \\<or> Trace.owns t x = None) =\n                              (Trace.safe\n                                (Enter g r (Trace.roomk t r, k') # t)\n                                x \\<or>\n                               Trace.owns\n                                (Enter g r (Trace.roomk t r, k') # t) x =\n                               None)))\n 2. \\<And>s k k' g r t.\n       \\<lbrakk>s \\<in> reach; (k, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x = (Trace.safe t x \\<or> Trace.owns t x = None);\n        Trace.roomk t r = k'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 3. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s k k' g r t.\n       \\<lbrakk>s \\<in> reach; (k, k') \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x = (Trace.safe t x \\<or> Trace.owns t x = None);\n        Trace.roomk t r = k'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 k' = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  k' = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 2. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s k g r t.\n       \\<lbrakk>s \\<in> reach; (k, Trace.roomk t r) \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x =\n           (Trace.safe t x \\<or> Trace.owns t x = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            (\\<forall>x.\n                                Trace.cards t x = Trace.cards ta x) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 {g} \\<union> Trace.isin t r =\n                                 Trace.isin ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.isin t x = Trace.isin ta x)) \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 Trace.roomk t r = Trace.roomk ta r) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 Trace.roomk t x = Trace.roomk ta x)) \\<and>\n                            (\\<forall>x.\n                                Trace.owns t x = Trace.owns ta x) \\<and>\n                            (\\<forall>x.\n                                Trace.currk t x = Trace.currk ta x) \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<forall>x.\n                                (x = r \\<longrightarrow>\n                                 (Trace.owns t r =\n                                  \\<lfloor>g\\<rfloor> \\<and>\n                                  Trace.isin t r = {} \\<and>\n                                  Trace.roomk t r = Trace.currk t r \\<or>\n                                  Trace.safe t r \\<or>\n                                  Trace.owns t r = None) =\n                                 (Trace.safe ta r \\<or>\n                                  Trace.owns ta r = None)) \\<and>\n                                (x \\<noteq> r \\<longrightarrow>\n                                 (Trace.safe t x \\<or>\n                                  Trace.owns t x = None) =\n                                 (Trace.safe ta x \\<or>\n                                  Trace.owns ta x = None)))\n 2. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply(rule_tac x = \"Enter g r (k, roomk t r) # t\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s k g r t.\n       \\<lbrakk>s \\<in> reach; (k, Trace.roomk t r) \\<in> Trace.cards t g;\n        \\<forall>ik x. initk x = ik x; hotel t;\n        \\<forall>x. state.cards s x = Trace.cards t x;\n        \\<forall>x. state.isin s x = Trace.isin t x;\n        \\<forall>x. state.roomk s x = Trace.roomk t x;\n        \\<forall>x. state.owns s x = Trace.owns t x;\n        \\<forall>x. state.currk s x = Trace.currk t x;\n        state.issued s = Trace.issued t;\n        \\<forall>x.\n           state.safe s x =\n           (Trace.safe t x \\<or> Trace.owns t x = None)\\<rbrakk>\n       \\<Longrightarrow> hotel (Enter g r (k, Trace.roomk t r) # t) \\<and>\n                         (\\<forall>x.\n                             Trace.cards t x =\n                             Trace.cards\n                              (Enter g r (k, Trace.roomk t r) # t) x) \\<and>\n                         (\\<forall>x.\n                             (x = r \\<longrightarrow>\n                              {g} \\<union> Trace.isin t r =\n                              Trace.isin\n                               (Enter g r (k, Trace.roomk t r) # t)\n                               r) \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              Trace.isin t x =\n                              Trace.isin\n                               (Enter g r (k, Trace.roomk t r) # t)\n                               x)) \\<and>\n                         (\\<forall>x.\n                             (x = r \\<longrightarrow>\n                              Trace.roomk t r =\n                              Trace.roomk\n                               (Enter g r (k, Trace.roomk t r) # t)\n                               r) \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              Trace.roomk t x =\n                              Trace.roomk\n                               (Enter g r (k, Trace.roomk t r) # t)\n                               x)) \\<and>\n                         (\\<forall>x.\n                             Trace.owns t x =\n                             Trace.owns (Enter g r (k, Trace.roomk t r) # t)\n                              x) \\<and>\n                         (\\<forall>x.\n                             Trace.currk t x =\n                             Trace.currk\n                              (Enter g r (k, Trace.roomk t r) # t) x) \\<and>\n                         Trace.issued t =\n                         Trace.issued\n                          (Enter g r (k, Trace.roomk t r) # t) \\<and>\n                         (\\<forall>x.\n                             (x = r \\<longrightarrow>\n                              (Trace.owns t r = \\<lfloor>g\\<rfloor> \\<and>\n                               Trace.isin t r = {} \\<and>\n                               Trace.roomk t r = Trace.currk t r \\<or>\n                               Trace.safe t r \\<or> Trace.owns t r = None) =\n                              (Trace.safe\n                                (Enter g r (k, Trace.roomk t r) # t) r \\<or>\n                               Trace.owns\n                                (Enter g r (k, Trace.roomk t r) # t) r =\n                               None)) \\<and>\n                             (x \\<noteq> r \\<longrightarrow>\n                              (Trace.safe t x \\<or> Trace.owns t x = None) =\n                              (Trace.safe\n                                (Enter g r (k, Trace.roomk t r) # t) x \\<or>\n                               Trace.owns\n                                (Enter g r (k, Trace.roomk t r) # t) x =\n                               None)))\n 2. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s g r.\n       \\<lbrakk>s \\<in> reach;\n        \\<exists>t ik.\n           initk = ik \\<longrightarrow>\n           hotel t \\<and>\n           state.cards s = Trace.cards t \\<and>\n           state.isin s = Trace.isin t \\<and>\n           state.roomk s = Trace.roomk t \\<and>\n           state.owns s = Trace.owns t \\<and>\n           state.currk s = Trace.currk t \\<and>\n           state.issued s = Trace.issued t \\<and>\n           state.safe s =\n           (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None);\n        g \\<in> state.isin s r\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t ik.\n                            initk = ik \\<longrightarrow>\n                            hotel t \\<and>\n                            state.cards\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.cards t \\<and>\n                            state.isin\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.isin t \\<and>\n                            state.roomk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.roomk t \\<and>\n                            state.owns\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.owns t \\<and>\n                            state.currk\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.currk t \\<and>\n                            state.issued\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            Trace.issued t \\<and>\n                            state.safe\n                             (s\\<lparr>isin := (state.isin s)\n   (r := state.isin s r - {g})\\<rparr>) =\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or> Trace.owns t r = None)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s g r t.\n       \\<lbrakk>s \\<in> reach; g \\<in> Trace.isin t r; All ((=) initk);\n        hotel t; state.cards s = Trace.cards t; state.isin s = Trace.isin t;\n        state.roomk s = Trace.roomk t; state.owns s = Trace.owns t;\n        state.currk s = Trace.currk t; state.issued s = Trace.issued t;\n        state.safe s =\n        (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            hotel ta \\<and>\n                            Trace.cards t = Trace.cards ta \\<and>\n                            (\\<lambda>a.\n                                if a = r then state.isin s r - {g}\n                                else state.isin s a) =\n                            Trace.isin ta \\<and>\n                            Trace.roomk t = Trace.roomk ta \\<and>\n                            Trace.owns t = Trace.owns ta \\<and>\n                            Trace.currk t = Trace.currk ta \\<and>\n                            Trace.issued t = Trace.issued ta \\<and>\n                            (\\<lambda>r.\n                                Trace.safe t r \\<or>\n                                Trace.owns t r = None) =\n                            (\\<lambda>r.\n                                Trace.safe ta r \\<or>\n                                Trace.owns ta r = None)", "apply(rule_tac x = \"Exit g r # t\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s g r t.\n       \\<lbrakk>s \\<in> reach; g \\<in> Trace.isin t r; All ((=) initk);\n        hotel t; state.cards s = Trace.cards t; state.isin s = Trace.isin t;\n        state.roomk s = Trace.roomk t; state.owns s = Trace.owns t;\n        state.currk s = Trace.currk t; state.issued s = Trace.issued t;\n        state.safe s =\n        (\\<lambda>r. Trace.safe t r \\<or> Trace.owns t r = None)\\<rbrakk>\n       \\<Longrightarrow> hotel (Exit g r # t) \\<and>\n                         Trace.cards t = Trace.cards (Exit g r # t) \\<and>\n                         (\\<lambda>a.\n                             if a = r then state.isin s r - {g}\n                             else state.isin s a) =\n                         Trace.isin (Exit g r # t) \\<and>\n                         Trace.roomk t = Trace.roomk (Exit g r # t) \\<and>\n                         Trace.owns t = Trace.owns (Exit g r # t) \\<and>\n                         Trace.currk t = Trace.currk (Exit g r # t) \\<and>\n                         Trace.issued t = Trace.issued (Exit g r # t) \\<and>\n                         (\\<lambda>r.\n                             Trace.safe t r \\<or> Trace.owns t r = None) =\n                         (\\<lambda>ra.\n                             Trace.safe (Exit g r # t) ra \\<or>\n                             Trace.owns (Exit g r # t) ra = None)", "apply (clarsimp simp add: fun_eq_iff [where 'a=room] fun_eq_iff [where 'a=guest and 'b=\"(key \\<times> key) set\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "section\\<open>Equivalence\\<close>"], ["", "text\\<open>Although the state based and the trace based model look similar\nenough, the\nnagging feeling remains that they could be subtly different. Hence I\nwanted to show the equivalence formally. This was very fortunate,\nbecause it revealed some unintended discrepancies (no longer\npresent). Although I had proved both systems safe, it turned out that\nthe state based version of safety was more restrictive than the trace\nbased one. In the state based version of \\<open>safe\\<close> the room had to\nbe empty the first time the owner enters with the latest card, whereas\nin the trace based version any time the owner enters with the latest\ncard can make a room safe.  Such errors in an automaton checking a\ntrace property are very common and show the superiority of the trace\nbased formalism.\n\nWhen comparing the two models we have to take two slight differences\ninto account:\n\\begin{itemize}\n\n\\item The initial setting of the room keys @{const Trace.initk} in the\ntrace based model is an arbitrary but fixed value.  In the state based\nmodel any injective initial value is fine.\n\n\\item As a consequence (see the end of\nSection~\\ref{sec:FormalSafetyTrace}) @{const state.safe} is initially\ntrue whereas @{const Trace.safe} is initially false.\n\n\\end{itemize}\nSince many names occur in both models they are disambiguated by the\nprefixes \\<open>state\\<close> and \\<open>Trace\\<close>.\n\nIn the one direction I have shown that any hotel trace starting\nwith an injective @{const initk} gives rise to a reachable state\nwhen the components of that state are computed by the trace functions:\n@{thm[display]hotel_reach}\n\nConversely, for any reachable state there is a hotel trace leading to it:\n@{thm[display]reach_hotel}\nThe precondition @{prop\"initk = ik\"} just says that we can find some\ninterpretation for @{const initk} that works, namely the one that was\nchosen as the initial setting for the keys in @{term s}.\n\n\\sloppy\nThe proofs are almost automatic, except for the \\<open>safe\\<close>\ncomponent. In essence, we have to show that the procedural @{const\nstate.safe} implements the declarative @{const Trace.safe}. The proof\nwas complicated by the fact that initially it was not true and I had\nto debug @{const Trace.safe} by proof.\nUnfortunately Isabelle's current counterexample\nfinders~\\cite{BerghoferN-SEFM04,Weber05bounded}\ndid not seem to work here due to search space reasons.\nOnce the bugs were ironed out, the following key lemma,\ntogether with some smaller lemmas,\nautomated the correspondence proof for \\<open>safe\\<close>:\n@{thm[display]safe_Enter}\nIn addition we used many lemmas from the trace model, including\nTheorem~\\ref{safe}.\n\\fussy\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}