{"file_name": "/home/qj213/afp-2021-10-22/thys/Hello_World/IO.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hello_World", "problem_names": ["lemma \"bind (foo :: '\\<alpha> io) (\\<lambda>a. bar a) = foo \\<bind> (\\<lambda>a. bar a)\"", "lemma left_id:\n  fixes f :: \"'\\<alpha> \\<Rightarrow> '\\<beta> io\" \\<comment> \\<open>Make sure we use our \\<^const>\\<open>IO.bind\\<close>.\\<close>\n  shows \"(IO.return a \\<bind> f) = f a\"", "lemma right_id:\n  fixes m :: \"'\\<alpha> io\" \\<comment> \\<open>Make sure we use our \\<^const>\\<open>IO.bind\\<close>.\\<close>\n  shows \"(m \\<bind> IO.return) = m\"", "lemma bind_assoc:\n  fixes m :: \"'\\<alpha> io\" \\<comment> \\<open>Make sure we use our \\<^const>\\<open>IO.bind\\<close>.\\<close>\n  shows \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<lambda>x. f x \\<bind> g))\"", "lemma \"bind (println (STR ''foo''))\n            (\\<lambda>_.  println (STR ''bar'')) =\n       println (STR ''foo'') \\<bind> (\\<lambda>_. println (STR ''bar''))\"", "lemma \"do { _ \\<leftarrow> println (STR ''foo'');\n            println (STR ''bar'')} =\n      println (STR ''foo'') \\<then> (println (STR ''bar''))\"", "lemma \"Abs_io (\\<lambda>world. (eval iofun world, exec iofun world)) = iofun\"", "lemma exec_Abs_io: \"exec (Abs_io f) world = snd (f world)\"", "lemma exec_then:\n    \"exec (io\\<^sub>1 \\<then> io\\<^sub>2) world = exec io\\<^sub>2 (exec io\\<^sub>1 world)\"\n  and eval_then:\n    \"eval (io\\<^sub>1 \\<then> io\\<^sub>2) world = eval io\\<^sub>2 (exec io\\<^sub>1 world)\"", "lemma exec_bind:\n    \"exec (io\\<^sub>1 \\<bind> io\\<^sub>2) world = exec (io\\<^sub>2 (eval io\\<^sub>1 world)) (exec io\\<^sub>1 world)\"\n  and eval_bind:\n    \"eval (io\\<^sub>1 \\<bind> io\\<^sub>2) world = eval (io\\<^sub>2 (eval io\\<^sub>1 world)) (exec io\\<^sub>1 world)\"", "lemma exec_return:\n    \"exec (IO.return a) world = world\"\n  and\n    \"eval (IO.return a) world = a\""], "translations": [["", "lemma \"bind (foo :: '\\<alpha> io) (\\<lambda>a. bar a) = foo \\<bind> (\\<lambda>a. bar a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foo \\<bind> bar = foo \\<bind> bar", "by simp"], ["", "definition return :: \"'\\<alpha> \\<Rightarrow> '\\<alpha> io\" where [code del]:\n  \"return a \\<equiv> Abs_io (\\<lambda>world. (a, world))\""], ["", "hide_const (open) return"], ["", "text \\<open>\n  In Haskell, the definition for \\<^verbatim>\\<open>return\\<close> is::\n  \\<^verbatim>\\<open>\n    return :: a -> IO a\n    return a world0  =  (a, world0)\n  \\<close>\n\\<close>"], ["", "subsection\\<open>Monad Laws\\<close>"], ["", "lemma left_id:\n  fixes f :: \"'\\<alpha> \\<Rightarrow> '\\<beta> io\" \\<comment> \\<open>Make sure we use our \\<^const>\\<open>IO.bind\\<close>.\\<close>\n  shows \"(IO.return a \\<bind> f) = f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IO.return a \\<bind> f = f a", "by(simp add: return_def IO.bind_def Abs_io_inverse Rep_io_inverse)"], ["", "lemma right_id:\n  fixes m :: \"'\\<alpha> io\" \\<comment> \\<open>Make sure we use our \\<^const>\\<open>IO.bind\\<close>.\\<close>\n  shows \"(m \\<bind> IO.return) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> IO.return = m", "by(simp add: return_def IO.bind_def Abs_io_inverse Rep_io_inverse)"], ["", "lemma bind_assoc:\n  fixes m :: \"'\\<alpha> io\" \\<comment> \\<open>Make sure we use our \\<^const>\\<open>IO.bind\\<close>.\\<close>\n  shows \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<lambda>x. f x \\<bind> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<bind> g = m \\<bind> (\\<lambda>x. f x \\<bind> g)", "by(simp add: IO.bind_def Abs_io_inverse Abs_io_inject fun_eq_iff split: prod.splits)"], ["", "subsection\\<open>Code Generator Setup\\<close>"], ["", "text \\<open>\n  We don't expose our \\<^const>\\<open>IO.bind\\<close> definition to code.\n  We use the built-in definitions of the target language (e.g., Haskell, SML).\n\\<close>"], ["", "code_printing constant IO.bind \\<rightharpoonup> (Haskell) \"_ >>= _\"\n                                  and (SML) \"bind\"\n            | constant IO.return \\<rightharpoonup> (Haskell) \"return\"\n                                    and (SML) \"(() => _)\""], ["", "text\\<open>SML does not come with a bind function. We just define it (hopefully correct).\\<close>"], ["", "code_printing code_module Bind \\<rightharpoonup> (SML) \\<open>\nfun bind x f () = f (x ()) ();\n\\<close>"], ["", "code_reserved SML bind return"], ["", "text\\<open>\n  Make sure the code generator does not try to define \\<^typ>\\<open>'\\<alpha> io\\<close> by itself, but always uses\n  the one of the target language.\n  For Haskell, this is the fully qualified Prelude.IO.\n  For SML, we wrap it in a nullary function.\n\\<close>"], ["", "code_printing type_constructor io \\<rightharpoonup> (Haskell) \"Prelude.IO _\"\n                                     and (SML) \"unit -> _\""], ["", "text\\<open>\nIn Isabelle, a \\<^typ>\\<open>string\\<close> is just a type synonym for \\<^typ>\\<open>char list\\<close>.\nWhen translating a \\<^typ>\\<open>string\\<close> to Haskell, Isabelle does not use Haskell's \\<^verbatim>\\<open>String\\<close> or \n\\<^verbatim>\\<open>[Prelude.Char]\\<close>. Instead, Isabelle serializes its own\n  \\<^verbatim>\\<open>data Char = Char Bool Bool Bool Bool Bool Bool Bool Bool\\<close>.\nThe resulting code will look just ugly.\n\nTo use the native strings of Haskell, we use the Isabelle type \\<^typ>\\<open>String.literal\\<close>.\nThis gets translated to a Haskell \\<^verbatim>\\<open>String\\<close>.\n\nA string literal in Isabelle is created with \\<^term>\\<open>STR ''foo'' :: String.literal\\<close>.\n\\<close>"], ["", "text\\<open>\n  We define IO functions in Isabelle without implementation.\n  For a proof in Isabelle, we will only describe their externally observable properties.\n  For code generation, we map those functions to the corresponding function of the target language.\n\n  Our assumption is that our description in Isabelle corresponds to the real behavior of those\n  functions in the respective target language.\n\n  We use \\<^theory_text>\\<open>axiomatization\\<close> instead of \\<^theory_text>\\<open>consts\\<close> to axiomatically define that those functions exist,\n  but there is no implementation of them. This makes sure that we have to explicitly write down all\n  our assumptions about their behavior. Currently, no assumptions (apart from their type) can be\n  made about those functions.\n\\<close>"], ["", "axiomatization\n  println :: \"String.literal \\<Rightarrow> unit io\" and\n  getLine :: \"String.literal io\""], ["", "text \\<open>A Haskell module named \\<^verbatim>\\<open>StdIO\\<close> which just implements \\<^verbatim>\\<open>println\\<close> and \\<^verbatim>\\<open>getLine\\<close>.\\<close>"], ["", "code_printing code_module StdIO \\<rightharpoonup> (Haskell) \\<open>\nmodule StdIO (println, getLine) where\nimport qualified Prelude (putStrLn, getLine)\nprintln = Prelude.putStrLn\ngetLine = Prelude.getLine\n\\<close>                              and (SML) \\<open>\n(* Newline behavior in SML is odd.*)\nfun println s () = TextIO.print (s ^ \"\\n\");\nfun getLine () = case (TextIO.inputLine TextIO.stdIn) of\n                  SOME s => String.substring (s, 0, String.size s - 1)\n                | NONE => raise Fail \"getLine\";\n\\<close>"], ["", "code_reserved Haskell StdIO println getLine"], ["", "code_reserved SML println print getLine TextIO"], ["", "text\\<open>\n  When the code generator sees the functions \\<^const>\\<open>println\\<close> or \\<^const>\\<open>getLine\\<close>, we tell it to use\n  our language-specific implementation.\n  \\<close>"], ["", "code_printing constant println \\<rightharpoonup> (Haskell) \"StdIO.println\"\n                              and (SML) \"println\"\n            | constant getLine \\<rightharpoonup> (Haskell) \"StdIO.getLine\"\n                              and (SML) \"getLine\""], ["", "text\\<open>Monad syntax and \\<^const>\\<open>println\\<close> examples.\\<close>"], ["", "lemma \"bind (println (STR ''foo''))\n            (\\<lambda>_.  println (STR ''bar'')) =\n       println (STR ''foo'') \\<bind> (\\<lambda>_. println (STR ''bar''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. println STR ''foo'' \\<bind> (\\<lambda>_. println STR ''bar'') =\n    println STR ''foo'' \\<bind> (\\<lambda>_. println STR ''bar'')", "by simp"], ["", "lemma \"do { _ \\<leftarrow> println (STR ''foo'');\n            println (STR ''bar'')} =\n      println (STR ''foo'') \\<then> (println (STR ''bar''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. println STR ''foo'' \\<bind> (\\<lambda>_. println STR ''bar'') =\n    println STR ''foo'' \\<bind> (\\<lambda>_. println STR ''bar'')", "by simp"], ["", "subsection\\<open>Modelling Running an \\<^typ>\\<open>'\\<alpha> io\\<close> Function\\<close>"], ["", "text\\<open>\n  Apply some function \\<^term>\\<open>iofun :: '\\<alpha> io\\<close> to a specific world and return the new world\n  (discarding the result of \\<^term>\\<open>iofun\\<close>).\n\\<close>"], ["", "definition exec :: \"'\\<alpha> io \\<Rightarrow> \\<^url> \\<Rightarrow> \\<^url>\" where\n  \"exec iofun world = snd (Rep_io iofun world)\""], ["", "text\\<open>Similar, but only get the result.\\<close>"], ["", "definition eval :: \"'\\<alpha> io \\<Rightarrow> \\<^url> \\<Rightarrow> '\\<alpha>\" where\n  \"eval iofun world = fst (Rep_io iofun world)\""], ["", "text\\<open>\n  Essentially, \\<^const>\\<open>exec\\<close> and \\<^const>\\<open>eval\\<close> extract the payload \\<^typ>\\<open>'\\<alpha>\\<close> and \\<^typ>\\<open>\\<^url>\\<close>\n  when executing an \\<^typ>\\<open>'\\<alpha> io\\<close>.\n\\<close>"], ["", "lemma \"Abs_io (\\<lambda>world. (eval iofun world, exec iofun world)) = iofun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_io (\\<lambda>world. (eval iofun world, exec iofun world)) = iofun", "by(simp add: exec_def eval_def Rep_io_inverse)"], ["", "lemma exec_Abs_io: \"exec (Abs_io f) world = snd (f world)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec (Abs_io f) world = snd (f world)", "by(simp add: exec_def Abs_io_inverse)"], ["", "lemma exec_then:\n    \"exec (io\\<^sub>1 \\<then> io\\<^sub>2) world = exec io\\<^sub>2 (exec io\\<^sub>1 world)\"\n  and eval_then:\n    \"eval (io\\<^sub>1 \\<then> io\\<^sub>2) world = eval io\\<^sub>2 (exec io\\<^sub>1 world)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec (io\\<^sub>1 \\<bind> (\\<lambda>_. io\\<^sub>2)) world =\n    exec io\\<^sub>2 (exec io\\<^sub>1 world) &&&\n    eval (io\\<^sub>1 \\<bind> (\\<lambda>_. io\\<^sub>2)) world =\n    eval io\\<^sub>2 (exec io\\<^sub>1 world)", "by (simp_all add: exec_def eval_def bind_def Abs_io_inverse split_beta)"], ["", "lemma exec_bind:\n    \"exec (io\\<^sub>1 \\<bind> io\\<^sub>2) world = exec (io\\<^sub>2 (eval io\\<^sub>1 world)) (exec io\\<^sub>1 world)\"\n  and eval_bind:\n    \"eval (io\\<^sub>1 \\<bind> io\\<^sub>2) world = eval (io\\<^sub>2 (eval io\\<^sub>1 world)) (exec io\\<^sub>1 world)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec (io\\<^sub>1 \\<bind> io\\<^sub>2) world =\n    exec (io\\<^sub>2 (eval io\\<^sub>1 world)) (exec io\\<^sub>1 world) &&&\n    eval (io\\<^sub>1 \\<bind> io\\<^sub>2) world =\n    eval (io\\<^sub>2 (eval io\\<^sub>1 world)) (exec io\\<^sub>1 world)", "by(simp_all add: exec_def eval_def bind_def Abs_io_inverse split_beta)"], ["", "lemma exec_return:\n    \"exec (IO.return a) world = world\"\n  and\n    \"eval (IO.return a) world = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec (IO.return a) world = world &&& eval (IO.return a) world = a", "by (simp_all add: exec_def eval_def Abs_io_inverse return_def)"], ["", "end"]]}