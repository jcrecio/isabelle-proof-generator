{"file_name": "/home/qj213/afp-2021-10-22/thys/LOFT/OpenFlow_Helpers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LOFT", "problem_names": ["lemma hrule: \"(S = UNIV) = (\\<forall>x. x \\<in> S)\"", "lemma foldr_True_set: \"foldr (\\<lambda>x. (\\<and>) (f x)) l True = (\\<forall>x \\<in> set l. f x)\"", "lemma single_valued_code_lam[code_unfold]:\n  \"single_valued (set r) = single_valued_code r\"", "lemma set_Cons: \"e \\<in> set (a # as) \\<longleftrightarrow> (e = a \\<or> e \\<in> set as)\"", "lemma sorted_const: \"sorted (map (\\<lambda>y. x) k)\"", "lemma list_all_map: \"list_all f (map g l) = list_all (f \\<circ> g) l\"", "lemma distinct_2lcomprI: \"distinct as \\<Longrightarrow> distinct bs \\<Longrightarrow>\n\t(\\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i) \\<Longrightarrow>\n\tdistinct [f a b. a \\<leftarrow> as, b \\<leftarrow> bs]\"", "lemma distinct_3lcomprI: \"distinct as \\<Longrightarrow> distinct bs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n\t(\\<And>a b c e i g. f a b c = f e i g \\<Longrightarrow> a = e \\<and> b = i \\<and> c = g) \\<Longrightarrow>\n\tdistinct [f a b c. a \\<leftarrow> as, b \\<leftarrow> bs, c \\<leftarrow> cs]\"", "lemma distinct_fst: \"distinct (map fst a) \\<Longrightarrow> distinct a\"", "lemma distinct_snd: \"distinct (map snd a) \\<Longrightarrow> distinct a\"", "lemma inter_empty_fst2: \"(\\<lambda>(p, m, a). (p, m)) ` S \\<inter> (\\<lambda>(p, m, a). (p, m)) ` T = {} \\<Longrightarrow> S \\<inter> T = {}\"", "lemma card1_eI: \"1 \\<le> card S \\<Longrightarrow> \\<exists>y S'. S = {y} \\<union> S' \\<and> y \\<notin> S'\"", "lemma card2_eI: \"2 \\<le> card S \\<Longrightarrow> \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\"", "lemma card3_eI: \"3 \\<le> card S \\<Longrightarrow> \\<exists>x y z. x \\<noteq> y \\<and> x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S\"", "lemma card1_eE: \"finite S \\<Longrightarrow> \\<exists>y. y \\<in> S \\<Longrightarrow> 1 \\<le> card S\"", "lemma card2_eE: \"finite S \\<Longrightarrow> \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S \\<Longrightarrow> 2 \\<le> card S\"", "lemma card3_eE: \"finite S \\<Longrightarrow> \\<exists>x y z. x \\<noteq> y \\<and> x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S \\<Longrightarrow> 3 \\<le> card S\"", "lemma f_Img_ex_set: \"{f x|x. P x} = f ` {x. P x}\"", "lemma set_maps: \"set (List.maps f a) = (\\<Union>a\\<in>set a. set (f a))\""], "translations": [["", "lemma hrule: \"(S = UNIV) = (\\<forall>x. x \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S = UNIV) = (\\<forall>x. x \\<in> S)", "by blast"], ["", "subsection\\<open>Single valuedness on lists\\<close>"], ["", "lemma foldr_True_set: \"foldr (\\<lambda>x. (\\<and>) (f x)) l True = (\\<forall>x \\<in> set l. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (\\<and>) (f x)) l True = (\\<forall>x\\<in>set l. f x)", "by (induction l) simp_all"], ["", "fun single_valued_code where\n\"single_valued_code [] = True\" |\n\"single_valued_code (e#es) = (foldr (\\<lambda>x. (\\<and>) (fst x \\<noteq> fst e \\<or> snd x = snd e)) es True \\<and> single_valued_code es)\""], ["", "lemma single_valued_code_lam[code_unfold]:\n  \"single_valued (set r) = single_valued_code r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (set r) = single_valued_code r", "proof(induction r)"], ["proof (state)\ngoal (2 subgoals):\n 1. single_valued (set []) = single_valued_code []\n 2. \\<And>a r.\n       single_valued (set r) = single_valued_code r \\<Longrightarrow>\n       single_valued (set (a # r)) = single_valued_code (a # r)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. single_valued (set []) = single_valued_code []\n 2. \\<And>a r.\n       single_valued (set r) = single_valued_code r \\<Longrightarrow>\n       single_valued (set (a # r)) = single_valued_code (a # r)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (set []) = single_valued_code []", "by simp"], ["proof (state)\nthis:\n  single_valued (set []) = single_valued_code []\n\ngoal (1 subgoal):\n 1. \\<And>a r.\n       single_valued (set r) = single_valued_code r \\<Longrightarrow>\n       single_valued (set (a # r)) = single_valued_code (a # r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a r.\n       single_valued (set r) = single_valued_code r \\<Longrightarrow>\n       single_valued (set (a # r)) = single_valued_code (a # r)", "case (Cons e es)"], ["proof (state)\nthis:\n  single_valued (set es) = single_valued_code es\n\ngoal (1 subgoal):\n 1. \\<And>a r.\n       single_valued (set r) = single_valued_code r \\<Longrightarrow>\n       single_valued (set (a # r)) = single_valued_code (a # r)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) = single_valued_code (e # es)", "proof (rule iffI, goal_cases fwd bwd)"], ["proof (state)\ngoal (2 subgoals):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)\n 2. single_valued_code (e # es) \\<Longrightarrow>\n    single_valued (set (e # es))", "case bwd"], ["proof (state)\nthis:\n  single_valued_code (e # es)\n\ngoal (2 subgoals):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)\n 2. single_valued_code (e # es) \\<Longrightarrow>\n    single_valued (set (e # es))", "have \"single_valued (set es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (set es)", "using Cons.IH conjunct2[OF bwd[unfolded single_valued_code.simps]]"], ["proof (prove)\nusing this:\n  single_valued (set es) = single_valued_code es\n  single_valued_code es\n\ngoal (1 subgoal):\n 1. single_valued (set es)", ".."], ["proof (state)\nthis:\n  single_valued (set es)\n\ngoal (2 subgoals):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)\n 2. single_valued_code (e # es) \\<Longrightarrow>\n    single_valued (set (e # es))", "moreover"], ["proof (state)\nthis:\n  single_valued (set es)\n\ngoal (2 subgoals):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)\n 2. single_valued_code (e # es) \\<Longrightarrow>\n    single_valued (set (e # es))", "have \"\\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e", "using conjunct1[OF bwd[unfolded single_valued_code.simps(2)], unfolded foldr_True_set]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e", "."], ["proof (state)\nthis:\n  \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\n\ngoal (2 subgoals):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)\n 2. single_valued_code (e # es) \\<Longrightarrow>\n    single_valued (set (e # es))", "ultimately"], ["proof (chain)\npicking this:\n  single_valued (set es)\n  \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e", "show ?case"], ["proof (prove)\nusing this:\n  single_valued (set es)\n  \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es))", "unfolding single_valued_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y) \\<in> set es \\<longrightarrow>\n     (\\<forall>z. (x, z) \\<in> set es \\<longrightarrow> y = z)\n  \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> set (e # es) \\<longrightarrow>\n       (\\<forall>z. (x, z) \\<in> set (e # es) \\<longrightarrow> y = z)", "by auto"], ["proof (state)\nthis:\n  single_valued (set (e # es))\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "case fwd"], ["proof (state)\nthis:\n  single_valued (set (e # es))\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "have \"single_valued (set es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (set es)", "using fwd"], ["proof (prove)\nusing this:\n  single_valued (set (e # es))\n\ngoal (1 subgoal):\n 1. single_valued (set es)", "unfolding single_valued_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y) \\<in> set (e # es) \\<longrightarrow>\n     (\\<forall>z. (x, z) \\<in> set (e # es) \\<longrightarrow> y = z)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> set es \\<longrightarrow>\n       (\\<forall>z. (x, z) \\<in> set es \\<longrightarrow> y = z)", "by simp"], ["proof (state)\nthis:\n  single_valued (set es)\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "with Cons.IH[symmetric]"], ["proof (chain)\npicking this:\n  single_valued_code es = single_valued (set es)\n  single_valued (set es)", "have \"single_valued_code es\""], ["proof (prove)\nusing this:\n  single_valued_code es = single_valued (set es)\n  single_valued (set es)\n\ngoal (1 subgoal):\n 1. single_valued_code es", ".."], ["proof (state)\nthis:\n  single_valued_code es\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "moreover"], ["proof (state)\nthis:\n  single_valued_code es\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "have \"\\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e", "using fwd"], ["proof (prove)\nusing this:\n  single_valued (set (e # es))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e", "unfolding single_valued_def"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y) \\<in> set (e # es) \\<longrightarrow>\n     (\\<forall>z. (x, z) \\<in> set (e # es) \\<longrightarrow> y = z)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set es. fst x \\<noteq> fst e \\<or> snd x = snd e\n\ngoal (1 subgoal):\n 1. single_valued (set (e # es)) \\<Longrightarrow>\n    single_valued_code (e # es)", "from conjI[OF this calculation, unfolded foldr_True_set[symmetric]]"], ["proof (chain)\npicking this:\n  foldr (\\<lambda>x. (\\<and>) (fst x \\<noteq> fst e \\<or> snd x = snd e)) es\n   True \\<and>\n  single_valued_code es", "show ?case"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x. (\\<and>) (fst x \\<noteq> fst e \\<or> snd x = snd e)) es\n   True \\<and>\n  single_valued_code es\n\ngoal (1 subgoal):\n 1. single_valued_code (e # es)", "unfolding single_valued_code.simps"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x. (\\<and>) (fst x \\<noteq> fst e \\<or> snd x = snd e)) es\n   True \\<and>\n  single_valued_code es\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x. (\\<and>) (fst x \\<noteq> fst e \\<or> snd x = snd e))\n     es True \\<and>\n    single_valued_code es", "."], ["proof (state)\nthis:\n  single_valued_code (e # es)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  single_valued (set (e # es)) = single_valued_code (e # es)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_Cons: \"e \\<in> set (a # as) \\<longleftrightarrow> (e = a \\<or> e \\<in> set as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e \\<in> set (a # as)) = (e = a \\<or> e \\<in> set as)", "by simp"], ["", "subsection\\<open>List fun\\<close>"], ["", "lemma sorted_const: \"sorted (map (\\<lambda>y. x) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map (\\<lambda>y. x) k)", "by(induction k) simp_all"], ["", "lemma list_all_map: \"list_all f (map g l) = list_all (f \\<circ> g) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all f (map g l) = list_all (f \\<circ> g) l", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all f (map g l) = list_all (\\<lambda>x. f (g x)) l", "by (simp add: list_all_length)"], ["", "(* by(induction l) simp_all *)"], ["", "lemma distinct_2lcomprI: \"distinct as \\<Longrightarrow> distinct bs \\<Longrightarrow>\n\t(\\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i) \\<Longrightarrow>\n\tdistinct [f a b. a \\<leftarrow> as, b \\<leftarrow> bs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct as; distinct bs;\n     \\<And>a b e i.\n        f a b = f e i \\<Longrightarrow> a = e \\<and> b = i\\<rbrakk>\n    \\<Longrightarrow> distinct (concat (map (\\<lambda>a. map (f a) bs) as))", "apply(induction as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; distinct bs;\n     \\<And>a b e i.\n        f a b = f e i \\<Longrightarrow> a = e \\<and> b = i\\<rbrakk>\n    \\<Longrightarrow> distinct (concat (map (\\<lambda>a. map (f a) bs) []))\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>distinct as; distinct bs;\n                 \\<And>a b e i.\n                    f a b = f e i \\<Longrightarrow>\n                    a = e \\<and> b = i\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map (\\<lambda>a. map (f a) bs) as));\n        distinct (a # as); distinct bs;\n        \\<And>a b e i.\n           f a b = f e i \\<Longrightarrow> a = e \\<and> b = i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (concat (map (\\<lambda>a. map (f a) bs) (a # as)))", "apply(simp;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>distinct as; distinct bs;\n                 \\<And>a b e i.\n                    f a b = f e i \\<Longrightarrow>\n                    a = e \\<and> b = i\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map (\\<lambda>a. map (f a) bs) as));\n        distinct (a # as); distinct bs;\n        \\<And>a b e i.\n           f a b = f e i \\<Longrightarrow> a = e \\<and> b = i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (concat (map (\\<lambda>a. map (f a) bs) (a # as)))", "apply(clarsimp simp only: distinct.simps simp_thms list.map concat.simps map_append distinct_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True;\n                 \\<And>a b e i.\n                    f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map (\\<lambda>a. map (f a) bs) as));\n        distinct bs;\n        \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> distinct (map (f a) bs) \\<and>\n                         set (map (f a) bs) \\<inter>\n                         set (concat (map (\\<lambda>a. map (f a) bs) as)) =\n                         {}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True;\n                 \\<And>a b e i.\n                    f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map (\\<lambda>a. map (f a) bs) as));\n        distinct bs;\n        \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> distinct (map (f a) bs)\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True;\n                 \\<And>a b e i.\n                    f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map (\\<lambda>a. map (f a) bs) as));\n        distinct bs;\n        \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> set (map (f a) bs) \\<inter>\n                         set (concat (map (\\<lambda>a. map (f a) bs) as)) =\n                         {}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>True; True;\n              \\<And>a b e i. f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n             \\<Longrightarrow> distinct\n                                (concat\n                                  (map (\\<lambda>a. map (f a) bs) as_));\n     distinct bs;\n     \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n     a_ \\<notin> set as_; distinct as_\\<rbrakk>\n    \\<Longrightarrow> distinct (map (f a_) bs)", "apply(clarify;fail | subst distinct_map, rule)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>True; True;\n              \\<And>a b e i. f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n             \\<Longrightarrow> distinct\n                                (concat\n                                  (map (\\<lambda>a. map (f a) bs) as_));\n     distinct bs;\n     \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n     a_ \\<notin> set as_; distinct as_\\<rbrakk>\n    \\<Longrightarrow> inj_on (f a_) (set bs)", "by (rule inj_onI) simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True;\n                 \\<And>a b e i.\n                    f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map (\\<lambda>a. map (f a) bs) as));\n        distinct bs;\n        \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> set (map (f a) bs) \\<inter>\n                         set (concat (map (\\<lambda>a. map (f a) bs) as)) =\n                         {}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>True; True;\n              \\<And>a b e i. f a b = f e i \\<Longrightarrow> True\\<rbrakk>\n             \\<Longrightarrow> distinct\n                                (concat\n                                  (map (\\<lambda>a. map (f a) bs) as_));\n     distinct bs;\n     \\<And>a b e i. f a b = f e i \\<Longrightarrow> a = e \\<and> b = i;\n     a_ \\<notin> set as_; distinct as_\\<rbrakk>\n    \\<Longrightarrow> set (map (f a_) bs) \\<inter>\n                      set (concat (map (\\<lambda>a. map (f a) bs) as_)) =\n                      {}", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_3lcomprI: \"distinct as \\<Longrightarrow> distinct bs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n\t(\\<And>a b c e i g. f a b c = f e i g \\<Longrightarrow> a = e \\<and> b = i \\<and> c = g) \\<Longrightarrow>\n\tdistinct [f a b c. a \\<leftarrow> as, b \\<leftarrow> bs, c \\<leftarrow> cs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct as; distinct bs; distinct cs;\n     \\<And>a b c e i g.\n        f a b c = f e i g \\<Longrightarrow>\n        a = e \\<and> b = i \\<and> c = g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (concat\n                         (map (\\<lambda>a.\n                                  concat\n                                   (map (\\<lambda>b. map (f a b) cs) bs))\n                           as))", "apply(induction as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; distinct bs; distinct cs;\n     \\<And>a b c e i g.\n        f a b c = f e i g \\<Longrightarrow>\n        a = e \\<and> b = i \\<and> c = g\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (concat\n                         (map (\\<lambda>a.\n                                  concat\n                                   (map (\\<lambda>b. map (f a b) cs) bs))\n                           []))\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>distinct as; distinct bs; distinct cs;\n                 \\<And>a b c e i g.\n                    f a b c = f e i g \\<Longrightarrow>\n                    a = e \\<and> b = i \\<and> c = g\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map\n (\\<lambda>a. concat (map (\\<lambda>b. map (f a b) cs) bs)) as));\n        distinct (a # as); distinct bs; distinct cs;\n        \\<And>a b c e i g.\n           f a b c = f e i g \\<Longrightarrow>\n           a = e \\<and> b = i \\<and> c = g\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (concat\n                            (map (\\<lambda>a.\n                                     concat\n(map (\\<lambda>b. map (f a b) cs) bs))\n                              (a # as)))", "apply(simp;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>distinct as; distinct bs; distinct cs;\n                 \\<And>a b c e i g.\n                    f a b c = f e i g \\<Longrightarrow>\n                    a = e \\<and> b = i \\<and> c = g\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map\n (\\<lambda>a. concat (map (\\<lambda>b. map (f a b) cs) bs)) as));\n        distinct (a # as); distinct bs; distinct cs;\n        \\<And>a b c e i g.\n           f a b c = f e i g \\<Longrightarrow>\n           a = e \\<and> b = i \\<and> c = g\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (concat\n                            (map (\\<lambda>a.\n                                     concat\n(map (\\<lambda>b. map (f a b) cs) bs))\n                              (a # as)))", "apply(clarsimp simp only: distinct.simps simp_thms list.map concat.simps map_append distinct_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True; True;\n                 \\<And>a b c e i g.\n                    f a b c = f e i g \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map\n (\\<lambda>a. concat (map (\\<lambda>b. map (f a b) cs) bs)) as));\n        distinct bs; distinct cs;\n        \\<And>a b c e i g.\n           f a b c = f e i g \\<Longrightarrow>\n           a = e \\<and> b = i \\<and> c = g;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (concat\n                            (map (\\<lambda>b. map (f a b) cs) bs)) \\<and>\n                         set (concat\n                               (map (\\<lambda>b. map (f a b) cs)\n                                 bs)) \\<inter>\n                         set (concat\n                               (map (\\<lambda>a.\n  concat (map (\\<lambda>b. map (f a b) cs) bs))\n                                 as)) =\n                         {}", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True; True;\n                 \\<And>a b c e i g.\n                    f a b c = f e i g \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map\n (\\<lambda>a. concat (map (\\<lambda>b. map (f a b) cs) bs)) as));\n        distinct bs; distinct cs;\n        \\<And>a b c e i g.\n           f a b c = f e i g \\<Longrightarrow>\n           a = e \\<and> b = i \\<and> c = g;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (concat (map (\\<lambda>b. map (f a b) cs) bs))\n 2. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True; True;\n                 \\<And>a b c e i g.\n                    f a b c = f e i g \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map\n (\\<lambda>a. concat (map (\\<lambda>b. map (f a b) cs) bs)) as));\n        distinct bs; distinct cs;\n        \\<And>a b c e i g.\n           f a b c = f e i g \\<Longrightarrow>\n           a = e \\<and> b = i \\<and> c = g;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> set (concat\n                               (map (\\<lambda>b. map (f a b) cs)\n                                 bs)) \\<inter>\n                         set (concat\n                               (map (\\<lambda>a.\n  concat (map (\\<lambda>b. map (f a b) cs) bs))\n                                 as)) =\n                         {}", "apply(rule distinct_2lcomprI; simp_all; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>\\<lbrakk>True; True; True;\n                 \\<And>a b c e i g.\n                    f a b c = f e i g \\<Longrightarrow> True\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (concat\n                                     (map\n (\\<lambda>a. concat (map (\\<lambda>b. map (f a b) cs) bs)) as));\n        distinct bs; distinct cs;\n        \\<And>a b c e i g.\n           f a b c = f e i g \\<Longrightarrow>\n           a = e \\<and> b = i \\<and> c = g;\n        a \\<notin> set as; distinct as\\<rbrakk>\n       \\<Longrightarrow> set (concat\n                               (map (\\<lambda>b. map (f a b) cs)\n                                 bs)) \\<inter>\n                         set (concat\n                               (map (\\<lambda>a.\n  concat (map (\\<lambda>b. map (f a b) cs) bs))\n                                 as)) =\n                         {}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_fst: \"distinct (map fst a) \\<Longrightarrow> distinct a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst a) \\<Longrightarrow> distinct a", "by (metis distinct_zipI1 zip_map_fst_snd)"], ["", "lemma distinct_snd: \"distinct (map snd a) \\<Longrightarrow> distinct a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map snd a) \\<Longrightarrow> distinct a", "by (metis distinct_zipI2 zip_map_fst_snd)"], ["", "lemma inter_empty_fst2: \"(\\<lambda>(p, m, a). (p, m)) ` S \\<inter> (\\<lambda>(p, m, a). (p, m)) ` T = {} \\<Longrightarrow> S \\<inter> T = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(p, m, a). (p, m)) ` S \\<inter>\n    (\\<lambda>(p, m, a). (p, m)) ` T =\n    {} \\<Longrightarrow>\n    S \\<inter> T = {}", "by blast"], ["", "subsection\\<open>Cardinality and Existence of Distinct Members\\<close>"], ["", "lemma card1_eI: \"1 \\<le> card S \\<Longrightarrow> \\<exists>y S'. S = {y} \\<union> S' \\<and> y \\<notin> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card S \\<Longrightarrow>\n    \\<exists>y S'. S = {y} \\<union> S' \\<and> y \\<notin> S'", "by (metis One_nat_def card.infinite card_le_Suc_iff insert_is_Un leD zero_less_Suc)"], ["", "lemma card2_eI: \"2 \\<le> card S \\<Longrightarrow> \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "case (1)"], ["proof (state)\nthis:\n  2 \\<le> card S\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card S", "have \"1 \\<le> card S\""], ["proof (prove)\nusing this:\n  2 \\<le> card S\n\ngoal (1 subgoal):\n 1. 1 \\<le> card S", "by simp"], ["proof (state)\nthis:\n  1 \\<le> card S\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "note card1_eI[OF this]"], ["proof (state)\nthis:\n  \\<exists>y S'. S = {y} \\<union> S' \\<and> y \\<notin> S'\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  \\<exists>y S'. S = {y} \\<union> S' \\<and> y \\<notin> S'", "obtain x S' where xs: \"S = {x} \\<union> S' \\<and> x \\<notin> S'\""], ["proof (prove)\nusing this:\n  \\<exists>y S'. S = {y} \\<union> S' \\<and> y \\<notin> S'\n\ngoal (1 subgoal):\n 1. (\\<And>x S'.\n        S = {x} \\<union> S' \\<and> x \\<notin> S' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  S = {x} \\<union> S' \\<and> x \\<notin> S'\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  S = {x} \\<union> S' \\<and> x \\<notin> S'", "have \"1 \\<le> card S'\""], ["proof (prove)\nusing this:\n  S = {x} \\<union> S' \\<and> x \\<notin> S'\n\ngoal (1 subgoal):\n 1. 1 \\<le> card S'", "by (metis 1 Suc_1 card.infinite card_insert_if finite_Un insert_is_Un le0 not_less_eq_eq)"], ["proof (state)\nthis:\n  1 \\<le> card S'\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card S'", "obtain y where \"y \\<in> S'\""], ["proof (prove)\nusing this:\n  1 \\<le> card S'\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> S' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  y \\<in> S'\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  y \\<in> S'", "show ?case"], ["proof (prove)\nusing this:\n  y \\<in> S'\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "using xs"], ["proof (prove)\nusing this:\n  y \\<in> S'\n  S = {x} \\<union> S' \\<and> x \\<notin> S'\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "by force"], ["proof (state)\nthis:\n  \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card3_eI: \"3 \\<le> card S \\<Longrightarrow> \\<exists>x y z. x \\<noteq> y \\<and> x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "case 1"], ["proof (state)\nthis:\n  3 \\<le> card S\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  3 \\<le> card S", "have \"2 \\<le> card S\""], ["proof (prove)\nusing this:\n  3 \\<le> card S\n\ngoal (1 subgoal):\n 1. 2 \\<le> card S", "by simp"], ["proof (state)\nthis:\n  2 \\<le> card S\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "note card2_eI[OF this]"], ["proof (state)\nthis:\n  \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S", "obtain x y S' where xs: \"S = {x,y} \\<union> S' \\<and> x \\<notin> S' \\<and> y \\<notin> S' \\<and> x \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>x y S'.\n        S = {x, y} \\<union> S' \\<and>\n        x \\<notin> S' \\<and>\n        y \\<notin> S' \\<and> x \\<noteq> y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Set.set_insert Un_insert_left insert_eq_iff insert_is_Un)"], ["proof (state)\nthis:\n  S = {x, y} \\<union> S' \\<and>\n  x \\<notin> S' \\<and> y \\<notin> S' \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  S = {x, y} \\<union> S' \\<and>\n  x \\<notin> S' \\<and> y \\<notin> S' \\<and> x \\<noteq> y", "have \"1 \\<le> card S'\""], ["proof (prove)\nusing this:\n  S = {x, y} \\<union> S' \\<and>\n  x \\<notin> S' \\<and> y \\<notin> S' \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 1 \\<le> card S'", "using 1"], ["proof (prove)\nusing this:\n  S = {x, y} \\<union> S' \\<and>\n  x \\<notin> S' \\<and> y \\<notin> S' \\<and> x \\<noteq> y\n  3 \\<le> card S\n\ngoal (1 subgoal):\n 1. 1 \\<le> card S'", "by (metis One_nat_def Suc_leI Un_insert_left card_gt_0_iff insert_absorb numeral_3_eq_3 singleton_insert_inj_eq card.infinite card_insert_if finite_Un insert_is_Un le0 not_less_eq_eq)"], ["proof (state)\nthis:\n  1 \\<le> card S'\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "(* uuuh *)"], ["proof (state)\nthis:\n  1 \\<le> card S'\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card S'", "obtain z where \"z \\<in> S'\""], ["proof (prove)\nusing this:\n  1 \\<le> card S'\n\ngoal (1 subgoal):\n 1. (\\<And>z. z \\<in> S' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  z \\<in> S'\n\ngoal (1 subgoal):\n 1. 3 \\<le> card S \\<Longrightarrow>\n    \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "then"], ["proof (chain)\npicking this:\n  z \\<in> S'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<in> S'\n\ngoal (1 subgoal):\n 1. \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "using xs"], ["proof (prove)\nusing this:\n  z \\<in> S'\n  S = {x, y} \\<union> S' \\<and>\n  x \\<notin> S' \\<and> y \\<notin> S' \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>x y z.\n       x \\<noteq> y \\<and>\n       x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S", "by force"], ["proof (state)\nthis:\n  \\<exists>x y z.\n     x \\<noteq> y \\<and>\n     x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card1_eE: \"finite S \\<Longrightarrow> \\<exists>y. y \\<in> S \\<Longrightarrow> 1 \\<le> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; \\<exists>y. y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card S", "using card_0_eq"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow> (card ?A = 0) = (?A = {})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; \\<exists>y. y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card S", "by fastforce"], ["", "lemma card2_eE: \"finite S \\<Longrightarrow> \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S \\<Longrightarrow> 2 \\<le> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S;\n     \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> card S", "using card1_eE card_Suc_eq card_insert_if"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S; \\<exists>y. y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card ?S\n  (card ?A = Suc ?k) =\n  (\\<exists>b B.\n      ?A = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = ?k \\<and> (?k = 0 \\<longrightarrow> B = {}))\n  finite ?A \\<Longrightarrow>\n  card (insert ?x ?A) = (if ?x \\<in> ?A then card ?A else Suc (card ?A))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S;\n     \\<exists>x y. x \\<noteq> y \\<and> x \\<in> S \\<and> y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> card S", "by fastforce"], ["", "lemma card3_eE: \"finite S \\<Longrightarrow> \\<exists>x y z. x \\<noteq> y \\<and> x \\<noteq> z \\<and> y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S \\<Longrightarrow> 3 \\<le> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S;\n     \\<exists>x y z.\n        x \\<noteq> y \\<and>\n        x \\<noteq> z \\<and>\n        y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> 3 \\<le> card S", "using card2_eE card_Suc_eq card_insert_if"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?S;\n   \\<exists>x y. x \\<noteq> y \\<and> x \\<in> ?S \\<and> y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> 2 \\<le> card ?S\n  (card ?A = Suc ?k) =\n  (\\<exists>b B.\n      ?A = insert b B \\<and>\n      b \\<notin> B \\<and>\n      card B = ?k \\<and> (?k = 0 \\<longrightarrow> B = {}))\n  finite ?A \\<Longrightarrow>\n  card (insert ?x ?A) = (if ?x \\<in> ?A then card ?A else Suc (card ?A))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S;\n     \\<exists>x y z.\n        x \\<noteq> y \\<and>\n        x \\<noteq> z \\<and>\n        y \\<noteq> z \\<and> x \\<in> S \\<and> y \\<in> S\\<rbrakk>\n    \\<Longrightarrow> 3 \\<le> card S", "oops"], ["", "lemma f_Img_ex_set: \"{f x|x. P x} = f ` {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x |x. P x} = f ` {x. P x}", "by auto"], ["", "lemma set_maps: \"set (List.maps f a) = (\\<Union>a\\<in>set a. set (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (List.maps f a) = (\\<Union>a\\<in>set a. set (f a))", "unfolding List.maps_def set_concat set_map UN_simps(10)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>a\\<in>set a. set (f a)) = (\\<Union>a\\<in>set a. set (f a))", ".."], ["", "end"]]}