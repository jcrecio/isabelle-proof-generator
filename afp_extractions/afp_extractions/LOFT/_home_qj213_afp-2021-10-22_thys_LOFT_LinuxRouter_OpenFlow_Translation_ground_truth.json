{"file_name": "/home/qj213/afp-2021-10-22/thys/LOFT/LinuxRouter_OpenFlow_Translation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LOFT", "problem_names": ["lemma prefix_match_semantics_simple_match: \n  assumes some: \"toprefixmatch m = Some pm\"\n\tassumes vld: \"valid_prefix pm\"\n\tshows \"prefix_match_semantics pm = simple_match_ip m\"", "lemma smtoms_eq_hlp: \"simple_match_to_of_match_single r a b c d = simple_match_to_of_match_single r f g h i \\<longleftrightarrow> (a = f \\<and> b = g \\<and> c = h \\<and> d = i)\"", "lemma simple_match_to_of_match_generates_prereqs: \"simple_match_valid m \\<Longrightarrow> r \\<in> set (simple_match_to_of_match m ifs) \\<Longrightarrow> all_prerequisites r\"", "lemma and_assoc: \"a \\<and> b \\<and> c \\<longleftrightarrow> (a \\<and> b) \\<and> c\"", "lemmas custom_simpset = Let_def set_concat set_map map_map comp_def concat_map_maps set_maps UN_iff fun_app_def Set.image_iff", "lemma simple_match_port_alt: \"simple_match_port m p \\<longleftrightarrow> p \\<in> wordinterval_to_set (uncurry WordInterval m)\"", "lemma simple_match_src_alt: \"simple_match_valid r \\<Longrightarrow> \n\tsimple_match_ip (src r) p \\<longleftrightarrow> prefix_match_semantics (PrefixMatch (fst (src r)) (snd (src r))) p\"", "lemma simple_match_dst_alt: \"simple_match_valid r \\<Longrightarrow> \n\tsimple_match_ip (dst r) p \\<longleftrightarrow> prefix_match_semantics (PrefixMatch (fst (dst r)) (snd (dst r))) p\"", "lemma \"x \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<Longrightarrow> valid_prefix x\"", "lemma simple_match_to_of_matchI: \n\tassumes mv: \"simple_match_valid r\"\n\tassumes mm: \"simple_matches r p\"\n\tassumes ii: \"p_iiface p \\<in> set ifs\"\n\tassumes ippkt: \"p_l2type p = 0x800\"\n\tshows eq: \"\\<exists>gr \\<in> set (simple_match_to_of_match r ifs). OF_match_fields gr p = Some True\"", "lemma prefix_match_00[simp,intro!]: \"prefix_match_semantics (PrefixMatch 0 0) p\"", "lemma simple_match_to_of_matchD:\n\tassumes eg: \"gr \\<in> set (simple_match_to_of_match r ifs)\"\n\tassumes mo: \"OF_match_fields gr p = Some True\"\n\tassumes me: \"match_iface (oiface r) (p_oiface p)\"\n\tassumes mv: \"simple_match_valid r\"\n\tshows \"simple_matches r p\"", "lemma \"annotate_rlen ''asdf'' = [(3, CHR ''a''), (2, CHR ''s''), (1, CHR ''d''), (0, CHR ''f'')]\"", "lemma fst_annotate_rlen_le: \"(k, a) \\<in> set (annotate_rlen l) \\<Longrightarrow> k < length l\"", "lemma distinct_fst_annotate_rlen: \"distinct (map fst (annotate_rlen l))\"", "lemma distinct_annotate_rlen: \"distinct (annotate_rlen l)\"", "lemma in_annotate_rlen: \"(a,x) \\<in> set (annotate_rlen l) \\<Longrightarrow> x \\<in> set l\"", "lemma map_snd_annotate_rlen: \"map snd (annotate_rlen l) = l\"", "lemma \"sorted_descending (map fst (annotate_rlen l))\"", "lemma \"annotate_rlen l = zip (rev [0..<length l]) l\"", "lemma annotate_rlen_len: \"fst (annotate_rlen_code r) = length r\"", "lemma annotate_rlen_code[code]: \"annotate_rlen s = snd (annotate_rlen_code s)\"", "lemma suc2plus_inj_on: \"inj_on (of_nat :: nat \\<Rightarrow> ('l :: len) word) {0..unat (max_word :: 'l word)}\"", "lemma distinct_of_nat_list: (* TODO: Move to CaesarWordLemmaBucket *)\n\t\"distinct l \\<Longrightarrow> \\<forall>e \\<in> set l. e \\<le> unat (max_word :: ('l::len) word) \\<Longrightarrow> distinct (map (of_nat :: nat \\<Rightarrow> 'l word) l)\"", "lemma annotate_first_le_hlp:\n\t\"length l < unat (max_word :: ('l :: len) word) \\<Longrightarrow> \\<forall>e\\<in>set (map fst (annotate_rlen l)). e \\<le> unat (max_word :: 'l word)\"", "lemmas distinct_of_prio_hlp = distinct_of_nat_list[OF distinct_fst_annotate_rlen annotate_first_le_hlp]", "lemma fst_annotate_rlen: \"map fst (annotate_rlen l) = rev [0..<length l]\"", "lemma sorted_word_upt:\n  defines[simp]: \"won \\<equiv> (of_nat :: nat \\<Rightarrow> ('l :: len) word)\"\n  assumes \"length l \\<le> unat (max_word :: 'l word)\"\n  shows \"sorted_descending (map won (rev [0..<Suc (length l)]))\"", "lemma sorted_annotated:\n\tassumes \"length l \\<le> unat (max_word :: ('l :: len) word)\"\n\tshows \"sorted_descending (map fst (map (apfst (of_nat :: nat \\<Rightarrow> 'l word)) (annotate_rlen l)))\"", "lemma max_16_word_max[simp]: \"(a :: 16 word) \\<le> 0xffff\"", "lemma replicate_FT_hlp: \"x \\<le> 16 \\<and> y \\<le> 16 \\<Longrightarrow> replicate (16 - x) False @ replicate x True = replicate (16 - y) False @ replicate y True \\<Longrightarrow> x = y\"", "lemma mask_inj_hlp1: \"inj_on (mask :: nat \\<Rightarrow> 16 word) {0..16}\"", "lemma distinct_simple_match_to_of_match_portlist_hlp: \n  fixes ps :: \"(16 word \\<times> 16 word)\"\n  shows \"distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = max_word then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ (pfxm_mask pfx))))\n                 (wordinterval_CIDR_split_prefixmatch (WordInterval (fst ps) (snd ps)))\n           else [])\"", "lemma distinct_simple_match_to_of_match: \"distinct ifs \\<Longrightarrow> distinct (simple_match_to_of_match m ifs)\"", "lemma inj_inj_on: \"inj F \\<Longrightarrow> inj_on F A\"", "lemma no_overlaps_lroft_hlp2: \"distinct (map fst amr) \\<Longrightarrow> (\\<And>r. distinct (fm r)) \\<Longrightarrow>\n    distinct (concat (map (\\<lambda>(p, r, c, a). map (\\<lambda>b. (p, b, fs a c)) (fm r)) amr))\"", "lemma distinct_lroft_s3: \"\\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk> \\<Longrightarrow> distinct (lr_of_tran_s3 ifs amr)\"", "lemma no_overlaps_lroft_hlp3: \"distinct (map fst amr) \\<Longrightarrow>\n(aa, ab, ac) \\<in> set (lr_of_tran_s3 ifs amr) \\<Longrightarrow> (ba, bb, bc) \\<in> set (lr_of_tran_s3 ifs amr) \\<Longrightarrow>\nac \\<noteq> bc \\<Longrightarrow> aa \\<noteq> ba\"", "lemma no_overlaps_lroft_s3_hlp_hlp: (* I hlps *)\n  \"\\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p; ab \\<noteq> ad \\<or> ba \\<noteq> bb; OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr); (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> False\"", "lemma no_overlaps_lroft_s3_hlp: \"distinct (map fst amr) \\<Longrightarrow> distinct ifs \\<Longrightarrow> \nno_overlaps OF_match_fields_unsafe (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))\"", "lemma lr_of_tran_no_overlaps: assumes \"distinct ifs\" shows \"Inr t = (lr_of_tran rt fw ifs) \\<Longrightarrow> no_overlaps OF_match_fields_unsafe t\"", "lemma sorted_lr_of_tran_s3_hlp: \"\\<forall>x\\<in>set f. fst x \\<le> a \\<Longrightarrow> b \\<in> set (lr_of_tran_s3 s f) \\<Longrightarrow> fst b \\<le> a\"", "lemma lr_of_tran_s3_Cons: \"lr_of_tran_s3 ifs (a#ard) = (\n\t[(p, b, case a of simple_action.Accept \\<Rightarrow> [Forward c] | simple_action.Drop \\<Rightarrow> []).\n\t\t(p,r,(c,a)) \\<leftarrow> [a], b \\<leftarrow> simple_match_to_of_match r ifs]) @ lr_of_tran_s3 ifs ard\"", "lemma sorted_lr_of_tran_s3: \"sorted_descending (map fst f) \\<Longrightarrow> sorted_descending (map fst (lr_of_tran_s3 s f))\"", "lemma sorted_lr_of_tran_hlp: \"(ofe_prio \\<circ> split3 OFEntry) = fst\"", "lemma lr_of_tran_sorted_descending: \"Inr r = lr_of_tran rt fw ifs \\<Longrightarrow> sorted_descending (map ofe_prio r)\"", "lemma lr_of_tran_s1_split: \"lr_of_tran_s1 (a # rt) = (route2match a, output_iface (routing_action a)) # lr_of_tran_s1 rt\"", "lemma route2match_correct: \"valid_prefix (routing_match a) \\<Longrightarrow> prefix_match_semantics (routing_match a) (p_dst p) \\<longleftrightarrow> simple_matches (route2match a) (p)\"", "lemma s1_correct: \"valid_prefixes rt \\<Longrightarrow> has_default_route (rt::('i::len) prefix_routing) \\<Longrightarrow> \n  \\<exists>rm ra. generalized_sfw (lr_of_tran_s1 rt) p = Some (rm,ra) \\<and> ra = output_iface (routing_table_semantics rt (p_dst p))\"", "lemma OF_match_linear_not_noD: \"OF_match_linear \\<gamma> oms p \\<noteq> NoAction \\<Longrightarrow> \\<exists>ome. ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p\"", "lemma s3_noaction_hlp: \"\\<lbrakk>simple_match_valid ac; \\<not>simple_matches ac p; match_iface (oiface ac) (p_oiface p)\\<rbrakk> \\<Longrightarrow> \nOF_match_linear OF_match_fields_safe (map (\\<lambda>x. split3 OFEntry (x1, x, case ba of simple_action.Accept \\<Rightarrow> [Forward ad] | simple_action.Drop \\<Rightarrow> [])) (simple_match_to_of_match ac ifs)) p = NoAction\"", "lemma aux:\n  \\<open>v = Some x \\<Longrightarrow> the v = x\\<close>", "lemma s3_correct:\n\tassumes vsfwm: \"list_all simple_match_valid (map (fst \\<circ> snd) ard)\"\n\tassumes ippkt: \"p_l2type p = 0x800\"\n\tassumes iiifs: \"p_iiface p \\<in> set ifs\"\n\tassumes oiifs: \"list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\"\n\tshows \"OF_match_linear OF_match_fields_safe (pack_OF_entries ifs ard) p = Action ao \\<longleftrightarrow> (\\<exists>r af. generalized_sfw (map snd ard) p = (Some (r,af)) \\<and> (if snd af = simple_action.Drop then ao = [] else ao = [Forward (fst af)]))\"", "lemma lr_of_tran_s1_valid: \"valid_prefixes rt \\<Longrightarrow> gsfw_valid (lr_of_tran_s1 rt)\"", "lemma simple_match_valid_fbs_rlen: \"\\<lbrakk>valid_prefixes rt; simple_fw_valid fw; (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk> \\<Longrightarrow> simple_match_valid aa\"", "lemma simple_match_valid_fbs: \"\\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk> \\<Longrightarrow> list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ifs))\"", "lemma lr_of_tran_prereqs: \"valid_prefixes rt \\<Longrightarrow> simple_fw_valid fw \\<Longrightarrow> lr_of_tran rt fw ifs = Inr oft \\<Longrightarrow>\nlist_all (all_prerequisites \\<circ> ofe_fields) oft\"", "lemma OF_unsafe_safe_match3_eq: \"\n  list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n  OF_priority_match OF_match_fields_unsafe oft = OF_priority_match OF_match_fields_safe oft\"", "lemma OF_unsafe_safe_match_linear_eq: \"\n  list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n  OF_match_linear OF_match_fields_unsafe oft = OF_match_linear OF_match_fields_safe oft\"", "lemma simple_action_ne[simp]: \n  \"b \\<noteq> simple_action.Accept \\<longleftrightarrow> b = simple_action.Drop\"\n  \"b \\<noteq> simple_action.Drop \\<longleftrightarrow> b = simple_action.Accept\"", "lemma map_snd_apfst: \"map snd (map (apfst x) l) = map snd l\"", "lemma match_ifaceAny_eq: \"oiface m = ifaceAny \\<Longrightarrow> simple_matches m p = simple_matches m (p\\<lparr>p_oiface := any\\<rparr>)\"", "lemma no_oif_matchD: \"no_oif_match fw \\<Longrightarrow> simple_fw fw p = simple_fw fw (p\\<lparr>p_oiface := any\\<rparr>)\"", "lemma lr_of_tran_fbs_acceptD:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\"\n  shows \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Accept) \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>)\"", "lemma lr_of_tran_fbs_acceptI:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\" \"has_default_policy fw\"\n  shows \"simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n  \\<exists>r. generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Accept)\"", "lemma lr_of_tran_fbs_dropD:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\"\n  shows \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Drop) \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw p = None\"", "lemma lr_of_tran_fbs_dropI:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\" \"has_default_policy fw\"\n  shows \"simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n  \\<exists>r oif. generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Drop)\"", "lemma no_oif_match_fbs:\n \"no_oif_match fw \\<Longrightarrow> list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\"", "lemma lr_of_tran_correct:\n\tfixes p :: \"(32, 'a) simple_packet_ext_scheme\"\nassumes nerr: \"lr_of_tran rt fw ifs = Inr oft\"\n\t and ippkt: \"p_l2type p = 0x800\"\n\t and ifvld: \"p_iiface p \\<in> set ifs\"\n\tshows \"OF_priority_match OF_match_fields_safe oft p = Action [Forward oif] \\<longleftrightarrow> simple_linux_router_nol12 rt fw p = (Some (p\\<lparr>p_oiface := oif\\<rparr>))\"\n\t      \"OF_priority_match OF_match_fields_safe oft p = Action [] \\<longleftrightarrow> simple_linux_router_nol12 rt fw p = None\"\n\t      (* fun stuff: *)\n\t      \"OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\" \"OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\"\n\t      \"OF_priority_match OF_match_fields_safe oft p = Action ls \\<longrightarrow> length ls \\<le> 1\"\n\t      \"\\<exists>ls. length ls \\<le> 1 \\<and> OF_priority_match OF_match_fields_safe oft p = Action ls\""], "translations": [["", "lemma prefix_match_semantics_simple_match: \n  assumes some: \"toprefixmatch m = Some pm\"\n\tassumes vld: \"valid_prefix pm\"\n\tshows \"prefix_match_semantics pm = simple_match_ip m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_match_semantics pm = simple_match_ip m", "using some"], ["proof (prove)\nusing this:\n  toprefixmatch m = Some pm\n\ngoal (1 subgoal):\n 1. prefix_match_semantics pm = simple_match_ip m", "by(cases m)\n\t  (clarsimp \n\t   simp add: toprefixmatch_def ipset_from_cidr_def pfxm_mask_def fun_eq_iff\n\t            prefix_match_semantics_ipset_from_netmask[OF vld] NOT_mask_shifted_lenword[symmetric]\n\t   split: if_splits)"], ["", "definition simple_match_to_of_match_single ::\n    \"(32, 'a) simple_match_scheme\n     \\<Rightarrow> char list option \\<Rightarrow> protocol \\<Rightarrow> (16 word \\<times> 16 word) option \\<Rightarrow> (16 word \\<times> 16 word) option \\<Rightarrow> of_match_field set\" \n    where\n\"simple_match_to_of_match_single m iif prot sport dport \\<equiv>\n\t   uncurry L4Src ` option2set sport \\<union> uncurry L4Dst ` option2set dport\n\t \\<union> IPv4Proto ` (case prot of ProtoAny \\<Rightarrow> {} | Proto p \\<Rightarrow> {p}) \\<comment> \\<open>protocol is an 8 word option anyway...\\<close>\n\t \\<union> IngressPort ` option2set iif\n\t \\<union> IPv4Src ` option2set (toprefixmatch (src m)) \\<union> IPv4Dst ` option2set (toprefixmatch (dst m))\n\t \\<union> {EtherType 0x0800}\""], ["", "(* okay, we need to make sure that no packets are output on the interface they were input on. So for rules that don't have an input interface, we'd need to do a product over all interfaces, if we stay naive.\n   The more smart way would be to insert a rule with the same match condition that additionally matches the input interface and drops. However, I'm afraid this is going to be very tricky to verify\\<dots> *)"], ["", "definition simple_match_to_of_match :: \"32 simple_match \\<Rightarrow> string list \\<Rightarrow> of_match_field set list\" where\n\"simple_match_to_of_match m ifs \\<equiv> (let\n\tnpm = (\\<lambda>p. fst p = 0 \\<and> snd p = max_word);\n\tsb = (\\<lambda>p. (if npm p then [None] else if fst p \\<le> snd p\n  then map (Some \\<circ> (\\<lambda>pfx. (pfxm_prefix pfx, NOT (pfxm_mask pfx)))) (wordinterval_CIDR_split_prefixmatch (WordInterval (fst p) (snd p))) else []))\n\tin [simple_match_to_of_match_single m iif (proto m) sport dport.\n\t\tiif \\<leftarrow> (if iiface m = ifaceAny then [None] else [Some i. i \\<leftarrow> ifs, match_iface (iiface m) i]),\n\t\tsport \\<leftarrow> sb (sports m),\n\t\tdport \\<leftarrow> sb (dports m)]\n)\""], ["", "(* I wonder\\<dots> should I check whether list_all (match_iface (iiface m)) ifs instead of iiface m = ifaceAny? It would be pretty stupid if that wasn't the same, but you know\\<dots> *)"], ["", "lemma smtoms_eq_hlp: \"simple_match_to_of_match_single r a b c d = simple_match_to_of_match_single r f g h i \\<longleftrightarrow> (a = f \\<and> b = g \\<and> c = h \\<and> d = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_match_to_of_match_single r a b c d =\n     simple_match_to_of_match_single r f g h i) =\n    (a = f \\<and> b = g \\<and> c = h \\<and> d = i)", "(* In case this proof breaks: there are two alternate proofs in the repo. They are of similar quality, though. Good luck. *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_match_to_of_match_single r a b c d =\n     simple_match_to_of_match_single r f g h i) =\n    (a = f \\<and> b = g \\<and> c = h \\<and> d = i)", "proof(rule iffI,goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    a = f \\<and> b = g \\<and> c = h \\<and> d = i\n 2. a = f \\<and> b = g \\<and> c = h \\<and> d = i \\<Longrightarrow>\n    simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i", "case 1"], ["proof (state)\nthis:\n  simple_match_to_of_match_single r a b c d =\n  simple_match_to_of_match_single r f g h i\n\ngoal (2 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    a = f \\<and> b = g \\<and> c = h \\<and> d = i\n 2. a = f \\<and> b = g \\<and> c = h \\<and> d = i \\<Longrightarrow>\n    simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i", "thus ?case"], ["proof (prove)\nusing this:\n  simple_match_to_of_match_single r a b c d =\n  simple_match_to_of_match_single r f g h i\n\ngoal (1 subgoal):\n 1. a = f \\<and> b = g \\<and> c = h \\<and> d = i", "proof(intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    a = f\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    b = g\n 3. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 4. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "have *: \"\\<And>P z x. \\<lbrakk>\\<forall>x :: of_match_field. P x; z = Some x\\<rbrakk> \\<Longrightarrow> P (IngressPort x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P z x.\n       \\<lbrakk>\\<forall>x. P x; z = Some x\\<rbrakk>\n       \\<Longrightarrow> P (IngressPort x)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x. ?P x; ?z = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?P (IngressPort ?x)\n\ngoal (4 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    a = f\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    b = g\n 3. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 4. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "show \"a = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = f", "using 1"], ["proof (prove)\nusing this:\n  simple_match_to_of_match_single r a b c d =\n  simple_match_to_of_match_single r f g h i\n\ngoal (1 subgoal):\n 1. a = f", "by(cases a; cases f)\n        (simp add: option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def;\n        subst(asm) set_eq_iff; drule (1) *; simp split: option.splits uncurry_splits protocol.splits)+"], ["proof (state)\nthis:\n  a = f\n\ngoal (3 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    b = g\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 3. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    b = g\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 3. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "have *: \"\\<And>P z x. \\<lbrakk>\\<forall>x :: of_match_field. P x; z = Proto x\\<rbrakk> \\<Longrightarrow> P (IPv4Proto x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P z x.\n       \\<lbrakk>\\<forall>x. P x; z = Proto x\\<rbrakk>\n       \\<Longrightarrow> P (IPv4Proto x)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x. ?P x; ?z = Proto ?x\\<rbrakk>\n  \\<Longrightarrow> ?P (IPv4Proto ?x)\n\ngoal (3 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    b = g\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 3. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "show \"b = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = g", "using 1"], ["proof (prove)\nusing this:\n  simple_match_to_of_match_single r a b c d =\n  simple_match_to_of_match_single r f g h i\n\ngoal (1 subgoal):\n 1. b = g", "by(cases b; cases g) \n        (simp add: option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def;\n        subst(asm) set_eq_iff; drule (1) *; simp split: option.splits uncurry_splits protocol.splits)+"], ["proof (state)\nthis:\n  b = g\n\ngoal (2 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "have *: \"\\<And>P z x. \\<lbrakk>\\<forall>x :: of_match_field. P x; z = Some x\\<rbrakk> \\<Longrightarrow> P (uncurry L4Src x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P z x.\n       \\<lbrakk>\\<forall>x. P x; z = Some x\\<rbrakk>\n       \\<Longrightarrow> P (uncurry L4Src x)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x. ?P x; ?z = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?P (uncurry L4Src ?x)\n\ngoal (2 subgoals):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    c = h\n 2. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "show \"c = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = h", "using 1"], ["proof (prove)\nusing this:\n  simple_match_to_of_match_single r a b c d =\n  simple_match_to_of_match_single r f g h i\n\ngoal (1 subgoal):\n 1. c = h", "by(cases c; cases h)\n        (simp add: option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def;\n        subst(asm) set_eq_iff; drule (1) *; simp split: option.splits uncurry_splits protocol.splits)+"], ["proof (state)\nthis:\n  c = h\n\ngoal (1 subgoal):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "have *: \"\\<And>P z x. \\<lbrakk>\\<forall>x :: of_match_field. P x; z = Some x\\<rbrakk> \\<Longrightarrow> P (uncurry L4Dst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P z x.\n       \\<lbrakk>\\<forall>x. P x; z = Some x\\<rbrakk>\n       \\<Longrightarrow> P (uncurry L4Dst x)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x. ?P x; ?z = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?P (uncurry L4Dst ?x)\n\ngoal (1 subgoal):\n 1. simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i \\<Longrightarrow>\n    d = i", "show \"d = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = i", "using 1"], ["proof (prove)\nusing this:\n  simple_match_to_of_match_single r a b c d =\n  simple_match_to_of_match_single r f g h i\n\ngoal (1 subgoal):\n 1. d = i", "by(cases d; cases i)\n        (simp add: option2set_None simple_match_to_of_match_single_def toprefixmatch_def option2set_def;\n        subst(asm) set_eq_iff; drule (1) *; simp split: option.splits uncurry_splits protocol.splits)+"], ["proof (state)\nthis:\n  d = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = f \\<and> b = g \\<and> c = h \\<and> d = i\n\ngoal (1 subgoal):\n 1. a = f \\<and> b = g \\<and> c = h \\<and> d = i \\<Longrightarrow>\n    simple_match_to_of_match_single r a b c d =\n    simple_match_to_of_match_single r f g h i", "qed simp"], ["", "lemma simple_match_to_of_match_generates_prereqs: \"simple_match_valid m \\<Longrightarrow> r \\<in> set (simple_match_to_of_match m ifs) \\<Longrightarrow> all_prerequisites r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_match_valid m;\n     r \\<in> set (simple_match_to_of_match m ifs)\\<rbrakk>\n    \\<Longrightarrow> all_prerequisites r", "unfolding simple_match_to_of_match_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_match_valid m;\n     r \\<in> set (concat\n                   (map (\\<lambda>iif.\n                            concat\n                             (map (\\<lambda>sport.\nmap (simple_match_to_of_match_single m iif (proto m) sport)\n (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n  else if fst (dports m) \\<le> snd (dports m)\n       then map (Some \\<circ>\n                 (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n             (wordinterval_CIDR_split_prefixmatch\n               (WordInterval (fst (dports m)) (snd (dports m))))\n       else []))\n                               (if fst (sports m) = 0 \\<and>\n                                   snd (sports m) = - 1\n                                then [None]\n                                else if fst (sports m) \\<le> snd (sports m)\n                                     then map\n     (Some \\<circ> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n     (wordinterval_CIDR_split_prefixmatch\n       (WordInterval (fst (sports m)) (snd (sports m))))\n                                     else [])))\n                     (if iiface m = ifaceAny then [None]\n                      else concat\n                            (map (\\<lambda>i.\n                                     if match_iface (iiface m) i\n                                     then [Some i] else [])\n                              ifs))))\\<rbrakk>\n    \\<Longrightarrow> all_prerequisites r", "proof(clarsimp, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>simple_match_valid m;\n        x \\<in> set (if iiface m = ifaceAny then [None]\n                     else concat\n                           (map (\\<lambda>i.\n                                    if match_iface (iiface m) i\n                                    then [Some i] else [])\n                             ifs));\n        xa \\<in> set (if fst (sports m) = 0 \\<and> snd (sports m) = - 1\n                      then [None]\n                      else if fst (sports m) \\<le> snd (sports m)\n                           then map (Some \\<circ>\n                                     (\\<lambda>pfx.\n   (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                                 (wordinterval_CIDR_split_prefixmatch\n                                   (WordInterval (fst (sports m))\n                                     (snd (sports m))))\n                           else []);\n        xb \\<in> set (if fst (dports m) = 0 \\<and> snd (dports m) = - 1\n                      then [None]\n                      else if fst (dports m) \\<le> snd (dports m)\n                           then map (Some \\<circ>\n                                     (\\<lambda>pfx.\n   (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                                 (wordinterval_CIDR_split_prefixmatch\n                                   (WordInterval (fst (dports m))\n                                     (snd (dports m))))\n                           else []);\n        r = simple_match_to_of_match_single m x (proto m) xa xb\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites\n                          (simple_match_to_of_match_single m x (proto m) xa\n                            xb)", "case (1 xiface xsrcp xdstp)"], ["proof (state)\nthis:\n  simple_match_valid m\n  xiface\n  \\<in> set (if iiface m = ifaceAny then [None]\n             else concat\n                   (map (\\<lambda>i.\n                            if match_iface (iiface m) i then [Some i]\n                            else [])\n                     ifs))\n  xsrcp\n  \\<in> set (if fst (sports m) = 0 \\<and> snd (sports m) = - 1 then [None]\n             else if fst (sports m) \\<le> snd (sports m)\n                  then map (Some \\<circ>\n                            (\\<lambda>pfx.\n                                (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (sports m)) (snd (sports m))))\n                  else [])\n  xdstp\n  \\<in> set (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n             else if fst (dports m) \\<le> snd (dports m)\n                  then map (Some \\<circ>\n                            (\\<lambda>pfx.\n                                (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (dports m)) (snd (dports m))))\n                  else [])\n  r = simple_match_to_of_match_single m xiface (proto m) xsrcp xdstp\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>simple_match_valid m;\n        x \\<in> set (if iiface m = ifaceAny then [None]\n                     else concat\n                           (map (\\<lambda>i.\n                                    if match_iface (iiface m) i\n                                    then [Some i] else [])\n                             ifs));\n        xa \\<in> set (if fst (sports m) = 0 \\<and> snd (sports m) = - 1\n                      then [None]\n                      else if fst (sports m) \\<le> snd (sports m)\n                           then map (Some \\<circ>\n                                     (\\<lambda>pfx.\n   (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                                 (wordinterval_CIDR_split_prefixmatch\n                                   (WordInterval (fst (sports m))\n                                     (snd (sports m))))\n                           else []);\n        xb \\<in> set (if fst (dports m) = 0 \\<and> snd (dports m) = - 1\n                      then [None]\n                      else if fst (dports m) \\<le> snd (dports m)\n                           then map (Some \\<circ>\n                                     (\\<lambda>pfx.\n   (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                                 (wordinterval_CIDR_split_prefixmatch\n                                   (WordInterval (fst (dports m))\n                                     (snd (dports m))))\n                           else []);\n        r = simple_match_to_of_match_single m x (proto m) xa xb\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites\n                          (simple_match_to_of_match_single m x (proto m) xa\n                            xb)", "note o = this"], ["proof (state)\nthis:\n  simple_match_valid m\n  xiface\n  \\<in> set (if iiface m = ifaceAny then [None]\n             else concat\n                   (map (\\<lambda>i.\n                            if match_iface (iiface m) i then [Some i]\n                            else [])\n                     ifs))\n  xsrcp\n  \\<in> set (if fst (sports m) = 0 \\<and> snd (sports m) = - 1 then [None]\n             else if fst (sports m) \\<le> snd (sports m)\n                  then map (Some \\<circ>\n                            (\\<lambda>pfx.\n                                (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (sports m)) (snd (sports m))))\n                  else [])\n  xdstp\n  \\<in> set (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n             else if fst (dports m) \\<le> snd (dports m)\n                  then map (Some \\<circ>\n                            (\\<lambda>pfx.\n                                (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (dports m)) (snd (dports m))))\n                  else [])\n  r = simple_match_to_of_match_single m xiface (proto m) xsrcp xdstp\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>simple_match_valid m;\n        x \\<in> set (if iiface m = ifaceAny then [None]\n                     else concat\n                           (map (\\<lambda>i.\n                                    if match_iface (iiface m) i\n                                    then [Some i] else [])\n                             ifs));\n        xa \\<in> set (if fst (sports m) = 0 \\<and> snd (sports m) = - 1\n                      then [None]\n                      else if fst (sports m) \\<le> snd (sports m)\n                           then map (Some \\<circ>\n                                     (\\<lambda>pfx.\n   (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                                 (wordinterval_CIDR_split_prefixmatch\n                                   (WordInterval (fst (sports m))\n                                     (snd (sports m))))\n                           else []);\n        xb \\<in> set (if fst (dports m) = 0 \\<and> snd (dports m) = - 1\n                      then [None]\n                      else if fst (dports m) \\<le> snd (dports m)\n                           then map (Some \\<circ>\n                                     (\\<lambda>pfx.\n   (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                                 (wordinterval_CIDR_split_prefixmatch\n                                   (WordInterval (fst (dports m))\n                                     (snd (dports m))))\n                           else []);\n        r = simple_match_to_of_match_single m x (proto m) xa xb\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites\n                          (simple_match_to_of_match_single m x (proto m) xa\n                            xb)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_prerequisites\n     (simple_match_to_of_match_single m xiface (proto m) xsrcp xdstp)", "unfolding simple_match_to_of_match_single_def all_prerequisites_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp \\<union>\n                   uncurry L4Dst ` option2set xdstp \\<union>\n                   IPv4Proto `\n                   (case proto m of ProtoAny \\<Rightarrow> {}\n                    | Proto p \\<Rightarrow> {p}) \\<union>\n                   IngressPort ` option2set xiface \\<union>\n                   IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n                   IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n                   {EtherType 2048}.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "unfolding ball_Un"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((((\\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n             prerequisites f\n              (uncurry L4Src ` option2set xsrcp \\<union>\n               uncurry L4Dst ` option2set xdstp \\<union>\n               IPv4Proto `\n               (case proto m of ProtoAny \\<Rightarrow> {}\n                | Proto p \\<Rightarrow> {p}) \\<union>\n               IngressPort ` option2set xiface \\<union>\n               IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n               IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n               {EtherType 2048})) \\<and>\n         (\\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n             prerequisites f\n              (uncurry L4Src ` option2set xsrcp \\<union>\n               uncurry L4Dst ` option2set xdstp \\<union>\n               IPv4Proto `\n               (case proto m of ProtoAny \\<Rightarrow> {}\n                | Proto p \\<Rightarrow> {p}) \\<union>\n               IngressPort ` option2set xiface \\<union>\n               IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n               IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n               {EtherType 2048}))) \\<and>\n        (\\<forall>f\\<in>IPv4Proto `\n                        (case proto m of ProtoAny \\<Rightarrow> {}\n                         | Proto p \\<Rightarrow> {p}).\n            prerequisites f\n             (uncurry L4Src ` option2set xsrcp \\<union>\n              uncurry L4Dst ` option2set xdstp \\<union>\n              IPv4Proto `\n              (case proto m of ProtoAny \\<Rightarrow> {}\n               | Proto p \\<Rightarrow> {p}) \\<union>\n              IngressPort ` option2set xiface \\<union>\n              IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n              IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n              {EtherType 2048}))) \\<and>\n       (\\<forall>f\\<in>IngressPort ` option2set xiface.\n           prerequisites f\n            (uncurry L4Src ` option2set xsrcp \\<union>\n             uncurry L4Dst ` option2set xdstp \\<union>\n             IPv4Proto `\n             (case proto m of ProtoAny \\<Rightarrow> {}\n              | Proto p \\<Rightarrow> {p}) \\<union>\n             IngressPort ` option2set xiface \\<union>\n             IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n             IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n             {EtherType 2048}))) \\<and>\n      (\\<forall>f\\<in>IPv4Src ` option2set (toprefixmatch (src m)).\n          prerequisites f\n           (uncurry L4Src ` option2set xsrcp \\<union>\n            uncurry L4Dst ` option2set xdstp \\<union>\n            IPv4Proto `\n            (case proto m of ProtoAny \\<Rightarrow> {}\n             | Proto p \\<Rightarrow> {p}) \\<union>\n            IngressPort ` option2set xiface \\<union>\n            IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n            IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n            {EtherType 2048}))) \\<and>\n     (\\<forall>f\\<in>IPv4Dst ` option2set (toprefixmatch (dst m)).\n         prerequisites f\n          (uncurry L4Src ` option2set xsrcp \\<union>\n           uncurry L4Dst ` option2set xdstp \\<union>\n           IPv4Proto `\n           (case proto m of ProtoAny \\<Rightarrow> {}\n            | Proto p \\<Rightarrow> {p}) \\<union>\n           IngressPort ` option2set xiface \\<union>\n           IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n           IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n           {EtherType 2048}))) \\<and>\n    (\\<forall>f\\<in>{EtherType 2048}.\n        prerequisites f\n         (uncurry L4Src ` option2set xsrcp \\<union>\n          uncurry L4Dst ` option2set xdstp \\<union>\n          IPv4Proto `\n          (case proto m of ProtoAny \\<Rightarrow> {}\n           | Proto p \\<Rightarrow> {p}) \\<union>\n          IngressPort ` option2set xiface \\<union>\n          IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n          IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n          {EtherType 2048}))", "proof((intro conjI; ((simp;fail)| - )), goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})\n 2. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})\n 2. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "have e: \"(fst (sports m) = 0 \\<and> snd (sports m) = max_word) \\<or> proto m = Proto TCP \\<or> proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (sports m) = 0 \\<and> snd (sports m) = - 1 \\<or>\n    proto m = Proto TCP \\<or>\n    proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP", "using o(1)"], ["proof (prove)\nusing this:\n  simple_match_valid m\n\ngoal (1 subgoal):\n 1. fst (sports m) = 0 \\<and> snd (sports m) = - 1 \\<or>\n    proto m = Proto TCP \\<or>\n    proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP", "unfolding simple_match_valid_alt Let_def"], ["proof (prove)\nusing this:\n  (if (case sports m of\n       (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n      (case dports m of\n       (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n   then proto m = Proto TCP \\<or>\n        proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n   else True) \\<and>\n  valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m)\n\ngoal (1 subgoal):\n 1. fst (sports m) = 0 \\<and> snd (sports m) = - 1 \\<or>\n    proto m = Proto TCP \\<or>\n    proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP", "by(clarsimp split: if_splits)"], ["proof (state)\nthis:\n  fst (sports m) = 0 \\<and> snd (sports m) = - 1 \\<or>\n  proto m = Proto TCP \\<or>\n  proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n\ngoal (2 subgoals):\n 1. \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})\n 2. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "using o(3) e"], ["proof (prove)\nusing this:\n  xsrcp\n  \\<in> set (if fst (sports m) = 0 \\<and> snd (sports m) = - 1 then [None]\n             else if fst (sports m) \\<le> snd (sports m)\n                  then map (Some \\<circ>\n                            (\\<lambda>pfx.\n                                (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (sports m)) (snd (sports m))))\n                  else [])\n  fst (sports m) = 0 \\<and> snd (sports m) = - 1 \\<or>\n  proto m = Proto TCP \\<or>\n  proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "by(elim disjE; simp add: option2set_def split: if_splits prod.splits uncurry_splits)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>uncurry L4Src ` option2set xsrcp.\n     prerequisites f\n      (uncurry L4Src ` option2set xsrcp \\<union>\n       uncurry L4Dst ` option2set xdstp \\<union>\n       IPv4Proto `\n       (case proto m of ProtoAny \\<Rightarrow> {}\n        | Proto p \\<Rightarrow> {p}) \\<union>\n       IngressPort ` option2set xiface \\<union>\n       IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n       IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n       {EtherType 2048})\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "have e: \"(fst (dports m) = 0 \\<and> snd (dports m) = max_word) \\<or> proto m = Proto TCP \\<or> proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (dports m) = 0 \\<and> snd (dports m) = - 1 \\<or>\n    proto m = Proto TCP \\<or>\n    proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP", "using o(1)"], ["proof (prove)\nusing this:\n  simple_match_valid m\n\ngoal (1 subgoal):\n 1. fst (dports m) = 0 \\<and> snd (dports m) = - 1 \\<or>\n    proto m = Proto TCP \\<or>\n    proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP", "unfolding simple_match_valid_alt Let_def"], ["proof (prove)\nusing this:\n  (if (case sports m of\n       (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n      (case dports m of\n       (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n   then proto m = Proto TCP \\<or>\n        proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n   else True) \\<and>\n  valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m)\n\ngoal (1 subgoal):\n 1. fst (dports m) = 0 \\<and> snd (dports m) = - 1 \\<or>\n    proto m = Proto TCP \\<or>\n    proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP", "by(clarsimp split: if_splits)"], ["proof (state)\nthis:\n  fst (dports m) = 0 \\<and> snd (dports m) = - 1 \\<or>\n  proto m = Proto TCP \\<or>\n  proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "using o(4) e"], ["proof (prove)\nusing this:\n  xdstp\n  \\<in> set (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n             else if fst (dports m) \\<le> snd (dports m)\n                  then map (Some \\<circ>\n                            (\\<lambda>pfx.\n                                (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (dports m)) (snd (dports m))))\n                  else [])\n  fst (dports m) = 0 \\<and> snd (dports m) = - 1 \\<or>\n  proto m = Proto TCP \\<or>\n  proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n       prerequisites f\n        (uncurry L4Src ` option2set xsrcp \\<union>\n         uncurry L4Dst ` option2set xdstp \\<union>\n         IPv4Proto `\n         (case proto m of ProtoAny \\<Rightarrow> {}\n          | Proto p \\<Rightarrow> {p}) \\<union>\n         IngressPort ` option2set xiface \\<union>\n         IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n         IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n         {EtherType 2048})", "by(elim disjE; simp add: option2set_def split: if_splits prod.splits uncurry_splits)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>uncurry L4Dst ` option2set xdstp.\n     prerequisites f\n      (uncurry L4Src ` option2set xsrcp \\<union>\n       uncurry L4Dst ` option2set xdstp \\<union>\n       IPv4Proto `\n       (case proto m of ProtoAny \\<Rightarrow> {}\n        | Proto p \\<Rightarrow> {p}) \\<union>\n       IngressPort ` option2set xiface \\<union>\n       IPv4Src ` option2set (toprefixmatch (src m)) \\<union>\n       IPv4Dst ` option2set (toprefixmatch (dst m)) \\<union>\n       {EtherType 2048})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_prerequisites\n   (simple_match_to_of_match_single m xiface (proto m) xsrcp xdstp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma and_assoc: \"a \\<and> b \\<and> c \\<longleftrightarrow> (a \\<and> b) \\<and> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and> b \\<and> c) = ((a \\<and> b) \\<and> c)", "by simp"], ["", "lemmas custom_simpset = Let_def set_concat set_map map_map comp_def concat_map_maps set_maps UN_iff fun_app_def Set.image_iff"], ["", "abbreviation \"simple_fw_prefix_to_wordinterval \\<equiv> prefix_to_wordinterval \\<circ> uncurry PrefixMatch\""], ["", "lemma simple_match_port_alt: \"simple_match_port m p \\<longleftrightarrow> p \\<in> wordinterval_to_set (uncurry WordInterval m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_port m p =\n    (p \\<in> wordinterval_to_set (uncurry WordInterval m))", "by(simp split: uncurry_splits)"], ["", "lemma simple_match_src_alt: \"simple_match_valid r \\<Longrightarrow> \n\tsimple_match_ip (src r) p \\<longleftrightarrow> prefix_match_semantics (PrefixMatch (fst (src r)) (snd (src r))) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid r \\<Longrightarrow>\n    simple_match_ip (src r) p =\n    prefix_match_semantics (PrefixMatch (fst (src r)) (snd (src r))) p", "by(cases \"(src r)\") (simp add: prefix_match_semantics_ipset_from_netmask2 prefix_to_wordset_ipset_from_cidr simple_match_valid_def valid_prefix_fw_def)"], ["", "lemma simple_match_dst_alt: \"simple_match_valid r \\<Longrightarrow> \n\tsimple_match_ip (dst r) p \\<longleftrightarrow> prefix_match_semantics (PrefixMatch (fst (dst r)) (snd (dst r))) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid r \\<Longrightarrow>\n    simple_match_ip (dst r) p =\n    prefix_match_semantics (PrefixMatch (fst (dst r)) (snd (dst r))) p", "by(cases \"(dst r)\") (simp add: prefix_match_semantics_ipset_from_netmask2 prefix_to_wordset_ipset_from_cidr simple_match_valid_def valid_prefix_fw_def)"], ["", "lemma \"x \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<Longrightarrow> valid_prefix x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<Longrightarrow>\n    valid_prefix x", "using wordinterval_CIDR_split_prefixmatch_all_valid_Ball[THEN bspec, THEN conjunct1]"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set (wordinterval_CIDR_split_prefixmatch ?r2) \\<Longrightarrow>\n  valid_prefix ?x1\n\ngoal (1 subgoal):\n 1. x \\<in> set (wordinterval_CIDR_split_prefixmatch w) \\<Longrightarrow>\n    valid_prefix x", "."], ["", "lemma simple_match_to_of_matchI: \n\tassumes mv: \"simple_match_valid r\"\n\tassumes mm: \"simple_matches r p\"\n\tassumes ii: \"p_iiface p \\<in> set ifs\"\n\tassumes ippkt: \"p_l2type p = 0x800\"\n\tshows eq: \"\\<exists>gr \\<in> set (simple_match_to_of_match r ifs). OF_match_fields gr p = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "let ?npm = \"\\<lambda>p. fst p = 0 \\<and> snd p = max_word\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "let ?sb = \"\\<lambda>p r. (if ?npm p then None else Some r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "obtain si where si: \"case si of Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi | None \\<Rightarrow> True\"\n\t\t\"case si of None \\<Rightarrow> True | Some ssi \\<Rightarrow> ssi \\<in> set (\n\t\twordinterval_CIDR_split_prefixmatch (uncurry WordInterval (sports r)))\"\n\t\t\"si = None \\<longleftrightarrow> ?npm (sports r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>si.\n        \\<lbrakk>case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     p_sport p \\<in> prefix_to_wordset ssi;\n         case si of None \\<Rightarrow> True\n         | Some ssi \\<Rightarrow>\n             ssi\n             \\<in> set (wordinterval_CIDR_split_prefixmatch\n                         (uncurry WordInterval (sports r)));\n         (si = None) =\n         (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases \"?npm (sports r)\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (sports r) = 0 \\<and> snd (sports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (sports r) = 0 \\<and> snd (sports r) = - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (sports r) = 0 \\<and> snd (sports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "(* True *)"], ["proof (state)\nthis:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (sports r) = 0 \\<and> snd (sports r) = - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (sports r) = 0 \\<and> snd (sports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"(case None of None \\<Rightarrow> True | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n            (case None of None \\<Rightarrow> True\n            | Some ssi \\<Rightarrow> ssi \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (sports r))))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (sports r) = 0 \\<and> snd (sports r) = - 1\n\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n    (case None of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (sports r))))", "by simp"], ["proof (state)\nthis:\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (sports r) = 0 \\<and> snd (sports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (sports r) = 0 \\<and> snd (sports r) = - 1\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (sports r) = 0 \\<and> snd (sports r) = - 1\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r))))\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "(* False *)"], ["proof (state)\nthis:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from mm"], ["proof (chain)\npicking this:\n  simple_matches r p", "have \"p_sport p \\<in> wordinterval_to_set (uncurry WordInterval (sports r))\""], ["proof (prove)\nusing this:\n  simple_matches r p\n\ngoal (1 subgoal):\n 1. p_sport p \\<in> wordinterval_to_set (uncurry WordInterval (sports r))", "by(simp only: simple_matches.simps simple_match_port_alt)"], ["proof (state)\nthis:\n  p_sport p \\<in> wordinterval_to_set (uncurry WordInterval (sports r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p_sport p \\<in> wordinterval_to_set (uncurry WordInterval (sports r))", "obtain ssi where ssi:\n\t\t\t\"ssi \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (sports r)))\"\n\t\t\t\"p_sport p \\<in> prefix_to_wordset ssi\""], ["proof (prove)\nusing this:\n  p_sport p \\<in> wordinterval_to_set (uncurry WordInterval (sports r))\n\ngoal (1 subgoal):\n 1. (\\<And>ssi.\n        \\<lbrakk>ssi\n                 \\<in> set (wordinterval_CIDR_split_prefixmatch\n                             (uncurry WordInterval (sports r)));\n         p_sport p \\<in> prefix_to_wordset ssi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wordinterval_CIDR_split_existential"], ["proof (prove)\nusing this:\n  p_sport p \\<in> wordinterval_to_set (uncurry WordInterval (sports r))\n  ?x \\<in> wordinterval_to_set ?w \\<Longrightarrow>\n  \\<exists>s.\n     s \\<in> set (wordinterval_CIDR_split_prefixmatch ?w) \\<and>\n     ?x \\<in> prefix_to_wordset s\n\ngoal (1 subgoal):\n 1. (\\<And>ssi.\n        \\<lbrakk>ssi\n                 \\<in> set (wordinterval_CIDR_split_prefixmatch\n                             (uncurry WordInterval (sports r)));\n         p_sport p \\<in> prefix_to_wordset ssi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ssi\n  \\<in> set (wordinterval_CIDR_split_prefixmatch\n              (uncurry WordInterval (sports r)))\n  p_sport p \\<in> prefix_to_wordset ssi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"(case Some ssi of None \\<Rightarrow> True | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n            (case Some ssi of None \\<Rightarrow> True\n            | Some ssi \\<Rightarrow> ssi \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (sports r))))\""], ["proof (prove)\nusing this:\n  ssi\n  \\<in> set (wordinterval_CIDR_split_prefixmatch\n              (uncurry WordInterval (sports r)))\n  p_sport p \\<in> prefix_to_wordset ssi\n\ngoal (1 subgoal):\n 1. (case Some ssi of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n    (case Some ssi of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (sports r))))", "by simp"], ["proof (state)\nthis:\n  (case Some ssi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case Some ssi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>si.\n                \\<lbrakk>case si of None \\<Rightarrow> True\n                         | Some ssi \\<Rightarrow>\n                             p_sport p \\<in> prefix_to_wordset ssi;\n                 case si of None \\<Rightarrow> True\n                 | Some ssi \\<Rightarrow>\n                     ssi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (sports r)));\n                 (si = None) =\n                 (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n  (case Some ssi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case Some ssi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>case ?si2 of None \\<Rightarrow> True\n           | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n   case ?si2 of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r)));\n   (?si2 = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n  (case Some ssi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case Some ssi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (sports r))))\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow>\n      ssi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (sports r)))\n  (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "obtain di where di: \"case di of Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi | None \\<Rightarrow> True\"\n\t\t\"case di of None \\<Rightarrow> True | Some ddi \\<Rightarrow> ddi \\<in> set (\n\t\twordinterval_CIDR_split_prefixmatch (uncurry WordInterval (dports r)))\"\n\t\t\"di = None \\<longleftrightarrow> ?npm (dports r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>di.\n        \\<lbrakk>case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     p_dport p \\<in> prefix_to_wordset ddi;\n         case di of None \\<Rightarrow> True\n         | Some ddi \\<Rightarrow>\n             ddi\n             \\<in> set (wordinterval_CIDR_split_prefixmatch\n                         (uncurry WordInterval (dports r)));\n         (di = None) =\n         (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(cases \"?npm (dports r)\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (dports r) = 0 \\<and> snd (dports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (dports r) = 0 \\<and> snd (dports r) = - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (dports r) = 0 \\<and> snd (dports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"(case None of None \\<Rightarrow> True | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n            (case None of None \\<Rightarrow> True\n            | Some ssi \\<Rightarrow> ssi \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (dports r))))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (dports r) = 0 \\<and> snd (dports r) = - 1\n\ngoal (1 subgoal):\n 1. (case None of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n    (case None of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (dports r))))", "by simp"], ["proof (state)\nthis:\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     fst (dports r) = 0 \\<and> snd (dports r) = - 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (dports r) = 0 \\<and> snd (dports r) = - 1\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  fst (dports r) = 0 \\<and> snd (dports r) = - 1\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case None of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r))))\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from mm"], ["proof (chain)\npicking this:\n  simple_matches r p", "have \"p_dport p \\<in> wordinterval_to_set (uncurry WordInterval (dports r))\""], ["proof (prove)\nusing this:\n  simple_matches r p\n\ngoal (1 subgoal):\n 1. p_dport p \\<in> wordinterval_to_set (uncurry WordInterval (dports r))", "by(simp only: simple_matches.simps simple_match_port_alt)"], ["proof (state)\nthis:\n  p_dport p \\<in> wordinterval_to_set (uncurry WordInterval (dports r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  p_dport p \\<in> wordinterval_to_set (uncurry WordInterval (dports r))", "obtain ddi where ddi:\n\t\t\t\"ddi \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (dports r)))\"\n\t\t\t\"p_dport p \\<in> prefix_to_wordset ddi\""], ["proof (prove)\nusing this:\n  p_dport p \\<in> wordinterval_to_set (uncurry WordInterval (dports r))\n\ngoal (1 subgoal):\n 1. (\\<And>ddi.\n        \\<lbrakk>ddi\n                 \\<in> set (wordinterval_CIDR_split_prefixmatch\n                             (uncurry WordInterval (dports r)));\n         p_dport p \\<in> prefix_to_wordset ddi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wordinterval_CIDR_split_existential"], ["proof (prove)\nusing this:\n  p_dport p \\<in> wordinterval_to_set (uncurry WordInterval (dports r))\n  ?x \\<in> wordinterval_to_set ?w \\<Longrightarrow>\n  \\<exists>s.\n     s \\<in> set (wordinterval_CIDR_split_prefixmatch ?w) \\<and>\n     ?x \\<in> prefix_to_wordset s\n\ngoal (1 subgoal):\n 1. (\\<And>ddi.\n        \\<lbrakk>ddi\n                 \\<in> set (wordinterval_CIDR_split_prefixmatch\n                             (uncurry WordInterval (dports r)));\n         p_dport p \\<in> prefix_to_wordset ddi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  ddi\n  \\<in> set (wordinterval_CIDR_split_prefixmatch\n              (uncurry WordInterval (dports r)))\n  p_dport p \\<in> prefix_to_wordset ddi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"(case Some ddi of None \\<Rightarrow> True | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n            (case Some ddi of None \\<Rightarrow> True\n            | Some ssi \\<Rightarrow> ssi \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (dports r))))\""], ["proof (prove)\nusing this:\n  ddi\n  \\<in> set (wordinterval_CIDR_split_prefixmatch\n              (uncurry WordInterval (dports r)))\n  p_dport p \\<in> prefix_to_wordset ddi\n\ngoal (1 subgoal):\n 1. (case Some ddi of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n    (case Some ddi of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (dports r))))", "by simp"], ["proof (state)\nthis:\n  (case Some ddi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case Some ddi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>di.\n                \\<lbrakk>case di of None \\<Rightarrow> True\n                         | Some ddi \\<Rightarrow>\n                             p_dport p \\<in> prefix_to_wordset ddi;\n                 case di of None \\<Rightarrow> True\n                 | Some ddi \\<Rightarrow>\n                     ddi\n                     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                                 (uncurry WordInterval (dports r)));\n                 (di = None) =\n                 (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\n  (case Some ddi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case Some ddi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>case ?di2 of None \\<Rightarrow> True\n           | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi;\n   case ?di2 of None \\<Rightarrow> True\n   | Some ddi \\<Rightarrow>\n       ddi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r)));\n   (?di2 = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\n  (case Some ddi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ssi) \\<and>\n  (case Some ddi of None \\<Rightarrow> True\n   | Some ssi \\<Rightarrow>\n       ssi\n       \\<in> set (wordinterval_CIDR_split_prefixmatch\n                   (uncurry WordInterval (dports r))))\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow>\n      ddi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (dports r)))\n  (di = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n       OF_match_fields gr p = Some True", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "let ?mf = \"map_option (apsnd (wordNOT \\<circ> mask \\<circ> (-) 16) \\<circ> prefix_match_dtor)\""], ["proof (state)\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "let ?gr = \"simple_match_to_of_match_single r\n\t\t\t(if iiface r = ifaceAny then None else Some (p_iiface p)) \n\t\t\t(if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n\t\t\t(?mf si) (?mf di)\""], ["proof (state)\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "note mfu = simple_match_port.simps[of \"fst (sports r)\" \"snd (sports r)\", unfolded surjective_pairing[of \"sports r\",symmetric]]\n\t\t\t\t   simple_match_port.simps[of \"fst (dports r)\" \"snd (dports r)\", unfolded surjective_pairing[of \"dports r\",symmetric]]"], ["proof (state)\nthis:\n  simple_match_port (sports r) ?p_p =\n  (?p_p \\<in> {fst (sports r)..snd (sports r)})\n  simple_match_port (dports r) ?p_p =\n  (?p_p \\<in> {fst (dports r)..snd (dports r)})\n\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "note u = mm[unfolded simple_matches.simps mfu ord_class.atLeastAtMost_iff simple_packet_unext_def simple_packet.simps]"], ["proof (state)\nthis:\n  match_iface (iiface r) (p_iiface p) \\<and>\n  match_iface (oiface r) (p_oiface p) \\<and>\n  simple_match_ip (src r) (p_src p) \\<and>\n  simple_match_ip (dst r) (p_dst p) \\<and>\n  match_proto (proto r) (p_proto p) \\<and>\n  (fst (sports r) \\<le> p_sport p \\<and>\n   p_sport p \\<le> snd (sports r)) \\<and>\n  fst (dports r) \\<le> p_dport p \\<and> p_dport p \\<le> snd (dports r)\n\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "note of_safe_unsafe_match_eq[OF simple_match_to_of_match_generates_prereqs]"], ["proof (state)\nthis:\n  \\<lbrakk>simple_match_valid ?m1;\n   ?m \\<in> set (simple_match_to_of_match ?m1 ?ifs1)\\<rbrakk>\n  \\<Longrightarrow> OF_match_fields ?m ?p =\n                    Some (OF_match_fields_unsafe ?m ?p)\n\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "from u"], ["proof (chain)\npicking this:\n  match_iface (iiface r) (p_iiface p) \\<and>\n  match_iface (oiface r) (p_oiface p) \\<and>\n  simple_match_ip (src r) (p_src p) \\<and>\n  simple_match_ip (dst r) (p_dst p) \\<and>\n  match_proto (proto r) (p_proto p) \\<and>\n  (fst (sports r) \\<le> p_sport p \\<and>\n   p_sport p \\<le> snd (sports r)) \\<and>\n  fst (dports r) \\<le> p_dport p \\<and> p_dport p \\<le> snd (dports r)", "have ple: \"fst (sports r) \\<le> snd (sports r)\" \"fst (dports r) \\<le> snd (dports r)\""], ["proof (prove)\nusing this:\n  match_iface (iiface r) (p_iiface p) \\<and>\n  match_iface (oiface r) (p_oiface p) \\<and>\n  simple_match_ip (src r) (p_src p) \\<and>\n  simple_match_ip (dst r) (p_dst p) \\<and>\n  match_proto (proto r) (p_proto p) \\<and>\n  (fst (sports r) \\<le> p_sport p \\<and>\n   p_sport p \\<le> snd (sports r)) \\<and>\n  fst (dports r) \\<le> p_dport p \\<and> p_dport p \\<le> snd (dports r)\n\ngoal (1 subgoal):\n 1. fst (sports r) \\<le> snd (sports r) &&&\n    fst (dports r) \\<le> snd (dports r)", "by force+"], ["proof (state)\nthis:\n  fst (sports r) \\<le> snd (sports r)\n  fst (dports r) \\<le> snd (dports r)\n\ngoal (2 subgoals):\n 1. OF_match_fields ?gr p = Some True\n 2. ?gr \\<in> set (simple_match_to_of_match r ifs)", "show eg: \"?gr \\<in> set (simple_match_to_of_match r ifs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_to_of_match_single r\n     (if iiface r = ifaceAny then None else Some (p_iiface p))\n     (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n     (map_option\n       (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n        prefix_match_dtor)\n       si)\n     (map_option\n       (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n        prefix_match_dtor)\n       di)\n    \\<in> set (simple_match_to_of_match r ifs)", "unfolding simple_match_to_of_match_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_to_of_match_single r\n     (if iiface r = ifaceAny then None else Some (p_iiface p))\n     (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n     (map_option\n       (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n        prefix_match_dtor)\n       si)\n     (map_option\n       (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n        prefix_match_dtor)\n       di)\n    \\<in> set (let npm = \\<lambda>p. fst p = 0 \\<and> snd p = - 1;\n                   sb = \\<lambda>p.\n                           if npm p then [None]\n                           else if fst p \\<le> snd p\n                                then map\n(Some \\<circ> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n(wordinterval_CIDR_split_prefixmatch (WordInterval (fst p) (snd p)))\n                                else []\n               in concat\n                   (map (\\<lambda>iif.\n                            concat\n                             (map (\\<lambda>sport.\nmap (simple_match_to_of_match_single r iif (proto r) sport) (sb (dports r)))\n                               (sb (sports r))))\n                     (if iiface r = ifaceAny then [None]\n                      else concat\n                            (map (\\<lambda>i.\n                                     if match_iface (iiface r) i\n                                     then [Some i] else [])\n                              ifs))))", "unfolding custom_simpset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (if iiface r = ifaceAny then [None]\n                        else List.maps\n                              (\\<lambda>i.\n                                  if match_iface (iiface r) i then [Some i]\n                                  else [])\n                              ifs).\n       \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and>\n                               snd (sports r) = - 1\n                            then [None]\n                            else if fst (sports r) \\<le> snd (sports r)\n                                 then map\n (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n (wordinterval_CIDR_split_prefixmatch\n   (WordInterval (fst (sports r)) (snd (sports r))))\n                                 else []).\n          \\<exists>xb\\<in>set (if fst (dports r) = 0 \\<and>\n                                  snd (dports r) = - 1\n                               then [None]\n                               else if fst (dports r) \\<le> snd (dports r)\n                                    then map\n    (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n    (wordinterval_CIDR_split_prefixmatch\n      (WordInterval (fst (dports r)) (snd (dports r))))\n                                    else []).\n             simple_match_to_of_match_single r\n              (if iiface r = ifaceAny then None else Some (p_iiface p))\n              (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n              (map_option\n                (\\<lambda>x.\n                    apsnd (\\<lambda>x. ~~ mask (16 - x))\n                     (prefix_match_dtor x))\n                si)\n              (map_option\n                (\\<lambda>x.\n                    apsnd (\\<lambda>x. ~~ mask (16 - x))\n                     (prefix_match_dtor x))\n                di) =\n             simple_match_to_of_match_single r x (proto r) xa xb", "unfolding smtoms_eq_hlp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>set (if iiface r = ifaceAny then [None]\n                        else List.maps\n                              (\\<lambda>i.\n                                  if match_iface (iiface r) i then [Some i]\n                                  else [])\n                              ifs).\n       \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and>\n                               snd (sports r) = - 1\n                            then [None]\n                            else if fst (sports r) \\<le> snd (sports r)\n                                 then map\n (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n (wordinterval_CIDR_split_prefixmatch\n   (WordInterval (fst (sports r)) (snd (sports r))))\n                                 else []).\n          \\<exists>xb\\<in>set (if fst (dports r) = 0 \\<and>\n                                  snd (dports r) = - 1\n                               then [None]\n                               else if fst (dports r) \\<le> snd (dports r)\n                                    then map\n    (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n    (wordinterval_CIDR_split_prefixmatch\n      (WordInterval (fst (dports r)) (snd (dports r))))\n                                    else []).\n             (if iiface r = ifaceAny then None else Some (p_iiface p)) =\n             x \\<and>\n             (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) =\n             proto r \\<and>\n             map_option\n              (\\<lambda>x.\n                  apsnd (\\<lambda>x. ~~ mask (16 - x))\n                   (prefix_match_dtor x))\n              si =\n             xa \\<and>\n             map_option\n              (\\<lambda>x.\n                  apsnd (\\<lambda>x. ~~ mask (16 - x))\n                   (prefix_match_dtor x))\n              di =\n             xb", "proof(intro bexI, (intro conjI; ((rule refl)?)), goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     di\n    \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1 then [None]\n               else if fst (dports r) \\<le> snd (dports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (dports r))\n                              (snd (dports r))))\n                    else [])\n 3. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])\n 4. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     di\n    \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1 then [None]\n               else if fst (dports r) \\<le> snd (dports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (dports r))\n                              (snd (dports r))))\n                    else [])\n 3. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])\n 4. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     di\n    \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1 then [None]\n               else if fst (dports r) \\<le> snd (dports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (dports r))\n                              (snd (dports r))))\n                    else [])", "using ple(2) di"], ["proof (prove)\nusing this:\n  fst (dports r) \\<le> snd (dports r)\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow>\n      ddi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (dports r)))\n  (di = None) = (fst (dports r) = 0 \\<and> snd (dports r) = - 1)\n\ngoal (1 subgoal):\n 1. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     di\n    \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1 then [None]\n               else if fst (dports r) \\<le> snd (dports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (dports r))\n                              (snd (dports r))))\n                    else [])", "apply(simp add: pfxm_mask_def prefix_match_dtor_def Set.image_iff \n\t\t\t\t\t           split: option.splits prod.splits uncurry_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x y.\n       \\<lbrakk>x = 0 \\<longrightarrow> y \\<noteq> - 1; x \\<le> y;\n        di = Some x2; p_dport p \\<in> prefix_to_wordset x2;\n        dports r = (x, y);\n        x2 \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval x y))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set\n   (wordinterval_CIDR_split_prefixmatch (WordInterval x y)).\n                            apsnd (\\<lambda>x. ~~ mask (16 - x))\n                             (case x2 of\n                              PrefixMatch x xa \\<Rightarrow> (x, xa)) =\n                            (pfxm_prefix x, ~~ mask (16 - pfxm_length x))", "apply(erule bexI[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x y.\n       \\<lbrakk>x = 0 \\<longrightarrow> y \\<noteq> - 1; x \\<le> y;\n        di = Some x2; p_dport p \\<in> prefix_to_wordset x2;\n        dports r = (x, y)\\<rbrakk>\n       \\<Longrightarrow> apsnd (\\<lambda>x. ~~ mask (16 - x))\n                          (case x2 of\n                           PrefixMatch x xa \\<Rightarrow> (x, xa)) =\n                         (pfxm_prefix x2, ~~ mask (16 - pfxm_length x2))", "apply(simp split: prefix_match.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_option\n   (\\<lambda>x. apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n   di\n  \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1 then [None]\n             else if fst (dports r) \\<le> snd (dports r)\n                  then map (\\<lambda>x.\n                               Some (pfxm_prefix x, ~~ pfxm_mask x))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (dports r)) (snd (dports r))))\n                  else [])\n\ngoal (3 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])\n 3. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])\n 3. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])\n 3. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])", "using ple(1) si"], ["proof (prove)\nusing this:\n  fst (sports r) \\<le> snd (sports r)\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow>\n      ssi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (sports r)))\n  (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n\ngoal (1 subgoal):\n 1. map_option\n     (\\<lambda>x.\n         apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n     si\n    \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n               else if fst (sports r) \\<le> snd (sports r)\n                    then map (\\<lambda>x.\n                                 Some (pfxm_prefix x, ~~ pfxm_mask x))\n                          (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval (fst (sports r))\n                              (snd (sports r))))\n                    else [])", "apply(simp add: pfxm_mask_def prefix_match_dtor_def Set.image_iff \n\t\t\t\t\t           split: option.splits prod.splits uncurry_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x y.\n       \\<lbrakk>x = 0 \\<longrightarrow> y \\<noteq> - 1; x \\<le> y;\n        si = Some x2; p_sport p \\<in> prefix_to_wordset x2;\n        sports r = (x, y);\n        x2 \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval x y))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set\n   (wordinterval_CIDR_split_prefixmatch (WordInterval x y)).\n                            apsnd (\\<lambda>x. ~~ mask (16 - x))\n                             (case x2 of\n                              PrefixMatch x xa \\<Rightarrow> (x, xa)) =\n                            (pfxm_prefix x, ~~ mask (16 - pfxm_length x))", "apply(erule bexI[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x y.\n       \\<lbrakk>x = 0 \\<longrightarrow> y \\<noteq> - 1; x \\<le> y;\n        si = Some x2; p_sport p \\<in> prefix_to_wordset x2;\n        sports r = (x, y)\\<rbrakk>\n       \\<Longrightarrow> apsnd (\\<lambda>x. ~~ mask (16 - x))\n                          (case x2 of\n                           PrefixMatch x xa \\<Rightarrow> (x, xa)) =\n                         (pfxm_prefix x2, ~~ mask (16 - pfxm_length x2))", "apply(simp split: prefix_match.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_option\n   (\\<lambda>x. apsnd (\\<lambda>x. ~~ mask (16 - x)) (prefix_match_dtor x))\n   si\n  \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1 then [None]\n             else if fst (sports r) \\<le> snd (sports r)\n                  then map (\\<lambda>x.\n                               Some (pfxm_prefix x, ~~ pfxm_mask x))\n                        (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval (fst (sports r)) (snd (sports r))))\n                  else [])\n\ngoal (2 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n 2. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "using u ii"], ["proof (prove)\nusing this:\n  match_iface (iiface r) (p_iiface p) \\<and>\n  match_iface (oiface r) (p_oiface p) \\<and>\n  simple_match_ip (src r) (p_src p) \\<and>\n  simple_match_ip (dst r) (p_dst p) \\<and>\n  match_proto (proto r) (p_proto p) \\<and>\n  (fst (sports r) \\<le> p_sport p \\<and>\n   p_sport p \\<le> snd (sports r)) \\<and>\n  fst (dports r) \\<le> p_dport p \\<and> p_dport p \\<le> snd (dports r)\n  p_iiface p \\<in> set ifs\n\ngoal (1 subgoal):\n 1. (if iiface r = ifaceAny then None else Some (p_iiface p))\n    \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)", "by(clarsimp simp: set_maps split: if_splits)"], ["proof (state)\nthis:\n  (if iiface r = ifaceAny then None else Some (p_iiface p))\n  \\<in> set (if iiface r = ifaceAny then [None]\n             else List.maps\n                   (\\<lambda>i.\n                       if match_iface (iiface r) i then [Some i] else [])\n                   ifs)\n\ngoal (1 subgoal):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r", "using ii u"], ["proof (prove)\nusing this:\n  p_iiface p \\<in> set ifs\n  match_iface (iiface r) (p_iiface p) \\<and>\n  match_iface (oiface r) (p_oiface p) \\<and>\n  simple_match_ip (src r) (p_src p) \\<and>\n  simple_match_ip (dst r) (p_dst p) \\<and>\n  match_proto (proto r) (p_proto p) \\<and>\n  (fst (sports r) \\<le> p_sport p \\<and>\n   p_sport p \\<le> snd (sports r)) \\<and>\n  fst (dports r) \\<le> p_dport p \\<and> p_dport p \\<le> snd (dports r)\n\ngoal (1 subgoal):\n 1. (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r", "by simp_all (metis match_proto.elims(2))"], ["proof (state)\nthis:\n  (if proto r = ProtoAny then ProtoAny else Proto (p_proto p)) = proto r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  simple_match_to_of_match_single r\n   (if iiface r = ifaceAny then None else Some (p_iiface p))\n   (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n   (map_option\n     (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n      prefix_match_dtor)\n     si)\n   (map_option\n     (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n      prefix_match_dtor)\n     di)\n  \\<in> set (simple_match_to_of_match r ifs)\n\ngoal (1 subgoal):\n 1. OF_match_fields\n     (simple_match_to_of_match_single r\n       (if iiface r = ifaceAny then None else Some (p_iiface p))\n       (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         si)\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         di))\n     p =\n    Some True", "have dpm: \"di = Some (PrefixMatch x1 x2) \\<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1\" for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "have *: \"di = Some (PrefixMatch x1 x2) \\<Longrightarrow> prefix_match_semantics (the di) (p_dport p) \\<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>di = Some (PrefixMatch x1 x2);\n     prefix_match_semantics (the di) (p_dport p)\\<rbrakk>\n    \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1", "by(clarsimp simp: prefix_match_semantics_def pfxm_mask_def word_bw_comms;fail)"], ["proof (state)\nthis:\n  \\<lbrakk>di = Some (PrefixMatch x1 x2);\n   prefix_match_semantics (the di) (p_dport p)\\<rbrakk>\n  \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1\n\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "have **: \"pfx \\<in> set (wordinterval_CIDR_split_prefixmatch ra) \\<Longrightarrow> prefix_match_semantics pfx a = (a \\<in> prefix_to_wordset pfx)\" for pfx ra and a :: \"16 word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfx \\<in> set (wordinterval_CIDR_split_prefixmatch ra) \\<Longrightarrow>\n    prefix_match_semantics pfx a = (a \\<in> prefix_to_wordset pfx)", "by (fact prefix_match_semantics_wordset[OF wordinterval_CIDR_split_prefixmatch_all_valid_Ball[THEN bspec, THEN conjunct1]])"], ["proof (state)\nthis:\n  ?pfx3\n  \\<in> set (wordinterval_CIDR_split_prefixmatch ?ra3) \\<Longrightarrow>\n  prefix_match_semantics ?pfx3 ?a3 = (?a3 \\<in> prefix_to_wordset ?pfx3)\n\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "have \"\\<lbrakk>di = Some (PrefixMatch x1 x2); p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2); PrefixMatch x1 x2 \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (dports r)))\\<rbrakk>\n             \\<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>di = Some (PrefixMatch x1 x2);\n     p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n     PrefixMatch x1 x2\n     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                 (uncurry WordInterval (dports r)))\\<rbrakk>\n    \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1", "using di(1,2)"], ["proof (prove)\nusing this:\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow>\n      ddi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (dports r)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>di = Some (PrefixMatch x1 x2);\n     p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n     PrefixMatch x1 x2\n     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                 (uncurry WordInterval (dports r)))\\<rbrakk>\n    \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1", "using * **"], ["proof (prove)\nusing this:\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow>\n      ddi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (dports r)))\n  \\<lbrakk>di = Some (PrefixMatch x1 x2);\n   prefix_match_semantics (the di) (p_dport p)\\<rbrakk>\n  \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1\n  ?pfx3\n  \\<in> set (wordinterval_CIDR_split_prefixmatch ?ra3) \\<Longrightarrow>\n  prefix_match_semantics ?pfx3 ?a3 = (?a3 \\<in> prefix_to_wordset ?pfx3)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>di = Some (PrefixMatch x1 x2);\n     p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n     PrefixMatch x1 x2\n     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                 (uncurry WordInterval (dports r)))\\<rbrakk>\n    \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>di = Some (PrefixMatch x1 x2);\n   p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n   PrefixMatch x1 x2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (uncurry WordInterval (dports r)))\\<rbrakk>\n  \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1\n\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "thus \"di = Some (PrefixMatch x1 x2) \\<Longrightarrow> p_dport p && ~~ (mask (16 - x2)) = x1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>di = Some (PrefixMatch x1 x2);\n   p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n   PrefixMatch x1 x2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (uncurry WordInterval (dports r)))\\<rbrakk>\n  \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1\n\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "using di(1,2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>di = Some (PrefixMatch x1 x2);\n   p_dport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n   PrefixMatch x1 x2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (uncurry WordInterval (dports r)))\\<rbrakk>\n  \\<Longrightarrow> p_dport p && ~~ mask (16 - x2) = x1\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow> p_dport p \\<in> prefix_to_wordset ddi\n  case di of None \\<Rightarrow> True\n  | Some ddi \\<Rightarrow>\n      ddi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (dports r)))\n\ngoal (1 subgoal):\n 1. di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_dport p && ~~ mask (16 - x2) = x1", "by auto"], ["proof (state)\nthis:\n  di = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n  p_dport p && ~~ mask (16 - x2) = x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  di = Some (PrefixMatch ?x1.3 ?x2.3) \\<Longrightarrow>\n  p_dport p && ~~ mask (16 - ?x2.3) = ?x1.3\n\ngoal (1 subgoal):\n 1. OF_match_fields\n     (simple_match_to_of_match_single r\n       (if iiface r = ifaceAny then None else Some (p_iiface p))\n       (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         si)\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         di))\n     p =\n    Some True", "have spm: \"si = Some (PrefixMatch x1 x2) \\<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1\" for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. si = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_sport p && ~~ mask (16 - x2) = x1", "using si"], ["proof (prove)\nusing this:\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow>\n      ssi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (sports r)))\n  (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\n\ngoal (1 subgoal):\n 1. si = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_sport p && ~~ mask (16 - x2) = x1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (sports r)));\n     (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "have *: \"si = Some (PrefixMatch x1 x2) \\<Longrightarrow> prefix_match_semantics (the si) (p_sport p) \\<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     prefix_match_semantics (the si) (p_sport p)\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "by(clarsimp simp: prefix_match_semantics_def pfxm_mask_def word_bw_comms;fail)"], ["proof (state)\nthis:\n  \\<lbrakk>si = Some (PrefixMatch x1 x2);\n   prefix_match_semantics (the si) (p_sport p)\\<rbrakk>\n  \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (sports r)));\n     (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "have **: \"pfx \\<in> set (wordinterval_CIDR_split_prefixmatch ra) \\<Longrightarrow> prefix_match_semantics pfx a = (a \\<in> prefix_to_wordset pfx)\" for pfx ra and a :: \"16 word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfx \\<in> set (wordinterval_CIDR_split_prefixmatch ra) \\<Longrightarrow>\n    prefix_match_semantics pfx a = (a \\<in> prefix_to_wordset pfx)", "by (fact prefix_match_semantics_wordset[OF wordinterval_CIDR_split_prefixmatch_all_valid_Ball[THEN bspec, THEN conjunct1]])"], ["proof (state)\nthis:\n  ?pfx3\n  \\<in> set (wordinterval_CIDR_split_prefixmatch ?ra3) \\<Longrightarrow>\n  prefix_match_semantics ?pfx3 ?a3 = (?a3 \\<in> prefix_to_wordset ?pfx3)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (sports r)));\n     (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "have \"\\<lbrakk>si = Some (PrefixMatch x1 x2); p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2); PrefixMatch x1 x2 \\<in> set (wordinterval_CIDR_split_prefixmatch (uncurry WordInterval (sports r)))\\<rbrakk>\n             \\<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n     PrefixMatch x1 x2\n     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                 (uncurry WordInterval (sports r)))\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "using si(1,2)"], ["proof (prove)\nusing this:\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow>\n      ssi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (sports r)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n     PrefixMatch x1 x2\n     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                 (uncurry WordInterval (sports r)))\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "using * **"], ["proof (prove)\nusing this:\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow>\n      ssi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (sports r)))\n  \\<lbrakk>si = Some (PrefixMatch x1 x2);\n   prefix_match_semantics (the si) (p_sport p)\\<rbrakk>\n  \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1\n  ?pfx3\n  \\<in> set (wordinterval_CIDR_split_prefixmatch ?ra3) \\<Longrightarrow>\n  prefix_match_semantics ?pfx3 ?a3 = (?a3 \\<in> prefix_to_wordset ?pfx3)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n     PrefixMatch x1 x2\n     \\<in> set (wordinterval_CIDR_split_prefixmatch\n                 (uncurry WordInterval (sports r)))\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>si = Some (PrefixMatch x1 x2);\n   p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n   PrefixMatch x1 x2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (uncurry WordInterval (sports r)))\\<rbrakk>\n  \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>si = Some (PrefixMatch x1 x2);\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi;\n     case si of None \\<Rightarrow> True\n     | Some ssi \\<Rightarrow>\n         ssi\n         \\<in> set (wordinterval_CIDR_split_prefixmatch\n                     (uncurry WordInterval (sports r)));\n     (si = None) = (fst (sports r) = 0 \\<and> snd (sports r) = - 1)\\<rbrakk>\n    \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1", "thus \"si = Some (PrefixMatch x1 x2) \\<Longrightarrow> p_sport p && ~~ (mask (16 - x2)) = x1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>si = Some (PrefixMatch x1 x2);\n   p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n   PrefixMatch x1 x2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (uncurry WordInterval (sports r)))\\<rbrakk>\n  \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1\n\ngoal (1 subgoal):\n 1. si = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_sport p && ~~ mask (16 - x2) = x1", "using si(1,2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>si = Some (PrefixMatch x1 x2);\n   p_sport p \\<in> prefix_to_wordset (PrefixMatch x1 x2);\n   PrefixMatch x1 x2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (uncurry WordInterval (sports r)))\\<rbrakk>\n  \\<Longrightarrow> p_sport p && ~~ mask (16 - x2) = x1\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow> p_sport p \\<in> prefix_to_wordset ssi\n  case si of None \\<Rightarrow> True\n  | Some ssi \\<Rightarrow>\n      ssi\n      \\<in> set (wordinterval_CIDR_split_prefixmatch\n                  (uncurry WordInterval (sports r)))\n\ngoal (1 subgoal):\n 1. si = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n    p_sport p && ~~ mask (16 - x2) = x1", "by auto"], ["proof (state)\nthis:\n  si = Some (PrefixMatch x1 x2) \\<Longrightarrow>\n  p_sport p && ~~ mask (16 - x2) = x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  si = Some (PrefixMatch ?x1.3 ?x2.3) \\<Longrightarrow>\n  p_sport p && ~~ mask (16 - ?x2.3) = ?x1.3\n\ngoal (1 subgoal):\n 1. OF_match_fields\n     (simple_match_to_of_match_single r\n       (if iiface r = ifaceAny then None else Some (p_iiface p))\n       (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         si)\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         di))\n     p =\n    Some True", "show \"OF_match_fields ?gr p = Some True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_match_fields\n     (simple_match_to_of_match_single r\n       (if iiface r = ifaceAny then None else Some (p_iiface p))\n       (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         si)\n       (map_option\n         (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n          prefix_match_dtor)\n         di))\n     p =\n    Some True", "unfolding of_safe_unsafe_match_eq[OF simple_match_to_of_match_generates_prereqs[OF mv eg]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (OF_match_fields_unsafe\n       (simple_match_to_of_match_single r\n         (if iiface r = ifaceAny then None else Some (p_iiface p))\n         (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n         (map_option\n           (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n            prefix_match_dtor)\n           si)\n         (map_option\n           (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n            prefix_match_dtor)\n           di))\n       p) =\n    Some True", "by(cases si; cases di)\n        (simp_all\n\t\t\t\t\tadd: simple_match_to_of_match_single_def OF_match_fields_unsafe_def spm\n\t\t\t\t\t     option2set_def u ippkt prefix_match_dtor_def toprefixmatch_def dpm\n\t\t\t\t\t     simple_match_dst_alt[OF mv, symmetric] simple_match_src_alt[OF mv, symmetric]\n\t\t\t\t\tsplit: prefix_match.splits)"], ["proof (state)\nthis:\n  OF_match_fields\n   (simple_match_to_of_match_single r\n     (if iiface r = ifaceAny then None else Some (p_iiface p))\n     (if proto r = ProtoAny then ProtoAny else Proto (p_proto p))\n     (map_option\n       (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n        prefix_match_dtor)\n       si)\n     (map_option\n       (apsnd ((wordNOT \\<circ> mask \\<circ>\\<circ> (-)) 16) \\<circ>\n        prefix_match_dtor)\n       di))\n   p =\n  Some True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gr\\<in>set (simple_match_to_of_match r ifs).\n     OF_match_fields gr p = Some True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefix_match_00[simp,intro!]: \"prefix_match_semantics (PrefixMatch 0 0) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_match_semantics (PrefixMatch 0 0) p", "by (simp add: valid_prefix_def zero_prefix_match_all)"], ["", "lemma simple_match_to_of_matchD:\n\tassumes eg: \"gr \\<in> set (simple_match_to_of_match r ifs)\"\n\tassumes mo: \"OF_match_fields gr p = Some True\"\n\tassumes me: \"match_iface (oiface r) (p_oiface p)\"\n\tassumes mv: \"simple_match_valid r\"\n\tshows \"simple_matches r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_matches r p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_matches r p", "from mv"], ["proof (chain)\npicking this:\n  simple_match_valid r", "have validpfx: \n\t\t\"valid_prefix (uncurry PrefixMatch (src r))\" \"valid_prefix (uncurry PrefixMatch (dst r))\"\n\t\t\"\\<And>pm. toprefixmatch (src r) = Some pm \\<Longrightarrow> valid_prefix pm\"\n\t\t\"\\<And>pm. toprefixmatch (dst r) = Some pm \\<Longrightarrow> valid_prefix pm\""], ["proof (prove)\nusing this:\n  simple_match_valid r\n\ngoal (1 subgoal):\n 1. (valid_prefix (uncurry PrefixMatch (src r)) &&&\n     valid_prefix (uncurry PrefixMatch (dst r))) &&&\n    (\\<And>pm.\n        toprefixmatch (src r) = Some pm \\<Longrightarrow>\n        valid_prefix pm) &&&\n    (\\<And>pm.\n        toprefixmatch (dst r) = Some pm \\<Longrightarrow> valid_prefix pm)", "unfolding simple_match_valid_def valid_prefix_fw_def toprefixmatch_def"], ["proof (prove)\nusing this:\n  ({p. simple_match_port (sports r) p} \\<noteq> UNIV \\<or>\n   {p. simple_match_port (dports r) p} \\<noteq> UNIV \\<longrightarrow>\n   proto r \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n  valid_prefix (uncurry PrefixMatch (src r)) \\<and>\n  valid_prefix (uncurry PrefixMatch (dst r))\n\ngoal (1 subgoal):\n 1. (valid_prefix (uncurry PrefixMatch (src r)) &&&\n     valid_prefix (uncurry PrefixMatch (dst r))) &&&\n    (\\<And>pm.\n        (let pm = PrefixMatch (fst (src r)) (snd (src r))\n         in if pm = PrefixMatch 0 0 then None else Some pm) =\n        Some pm \\<Longrightarrow>\n        valid_prefix pm) &&&\n    (\\<And>pm.\n        (let pm = PrefixMatch (fst (dst r)) (snd (dst r))\n         in if pm = PrefixMatch 0 0 then None else Some pm) =\n        Some pm \\<Longrightarrow>\n        valid_prefix pm)", "by(simp_all split: uncurry_splits if_splits)"], ["proof (state)\nthis:\n  valid_prefix (uncurry PrefixMatch (src r))\n  valid_prefix (uncurry PrefixMatch (dst r))\n  toprefixmatch (src r) = Some ?pm \\<Longrightarrow> valid_prefix ?pm\n  toprefixmatch (dst r) = Some ?pm \\<Longrightarrow> valid_prefix ?pm\n\ngoal (1 subgoal):\n 1. simple_matches r p", "from mo"], ["proof (chain)\npicking this:\n  OF_match_fields gr p = Some True", "have mo: \"OF_match_fields_unsafe gr p\""], ["proof (prove)\nusing this:\n  OF_match_fields gr p = Some True\n\ngoal (1 subgoal):\n 1. OF_match_fields_unsafe gr p", "unfolding of_safe_unsafe_match_eq[OF simple_match_to_of_match_generates_prereqs[OF mv eg]]"], ["proof (prove)\nusing this:\n  Some (OF_match_fields_unsafe gr p) = Some True\n\ngoal (1 subgoal):\n 1. OF_match_fields_unsafe gr p", "by simp"], ["proof (state)\nthis:\n  OF_match_fields_unsafe gr p\n\ngoal (1 subgoal):\n 1. simple_matches r p", "note this[unfolded OF_match_fields_unsafe_def]"], ["proof (state)\nthis:\n  \\<forall>f\\<in>gr. match_no_prereq f p\n\ngoal (1 subgoal):\n 1. simple_matches r p", "note eg[unfolded simple_match_to_of_match_def simple_match_to_of_match_single_def  custom_simpset option2set_def]"], ["proof (state)\nthis:\n  \\<exists>x\\<in>set (if iiface r = ifaceAny then [None]\n                      else List.maps\n                            (\\<lambda>i.\n                                if match_iface (iiface r) i then [Some i]\n                                else [])\n                            ifs).\n     \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                          then [None]\n                          else if fst (sports r) \\<le> snd (sports r)\n                               then map (\\<lambda>x.\n      Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                     (wordinterval_CIDR_split_prefixmatch\n (WordInterval (fst (sports r)) (snd (sports r))))\n                               else []).\n        \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and>\n                                 snd (dports r) = - 1\n                              then [None]\n                              else if fst (dports r) \\<le> snd (dports r)\n                                   then map\n   (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n   (wordinterval_CIDR_split_prefixmatch\n     (WordInterval (fst (dports r)) (snd (dports r))))\n                                   else []).\n           gr =\n           uncurry L4Src `\n           (case xa of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           uncurry L4Dst `\n           (case xaa of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Proto `\n           (case proto r of ProtoAny \\<Rightarrow> {}\n            | Proto p \\<Rightarrow> {p}) \\<union>\n           IngressPort `\n           (case x of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Src `\n           (case toprefixmatch (src r) of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Dst `\n           (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>set (if iiface r = ifaceAny then [None]\n                      else List.maps\n                            (\\<lambda>i.\n                                if match_iface (iiface r) i then [Some i]\n                                else [])\n                            ifs).\n     \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                          then [None]\n                          else if fst (sports r) \\<le> snd (sports r)\n                               then map (\\<lambda>x.\n      Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                     (wordinterval_CIDR_split_prefixmatch\n (WordInterval (fst (sports r)) (snd (sports r))))\n                               else []).\n        \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and>\n                                 snd (dports r) = - 1\n                              then [None]\n                              else if fst (dports r) \\<le> snd (dports r)\n                                   then map\n   (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n   (wordinterval_CIDR_split_prefixmatch\n     (WordInterval (fst (dports r)) (snd (dports r))))\n                                   else []).\n           gr =\n           uncurry L4Src `\n           (case xa of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           uncurry L4Dst `\n           (case xaa of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Proto `\n           (case proto r of ProtoAny \\<Rightarrow> {}\n            | Proto p \\<Rightarrow> {p}) \\<union>\n           IngressPort `\n           (case x of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Src `\n           (case toprefixmatch (src r) of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Dst `\n           (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           {EtherType 2048}", "guess x"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>set (if iiface r = ifaceAny then [None]\n                      else List.maps\n                            (\\<lambda>i.\n                                if match_iface (iiface r) i then [Some i]\n                                else [])\n                            ifs).\n     \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                          then [None]\n                          else if fst (sports r) \\<le> snd (sports r)\n                               then map (\\<lambda>x.\n      Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                     (wordinterval_CIDR_split_prefixmatch\n (WordInterval (fst (sports r)) (snd (sports r))))\n                               else []).\n        \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and>\n                                 snd (dports r) = - 1\n                              then [None]\n                              else if fst (dports r) \\<le> snd (dports r)\n                                   then map\n   (\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n   (wordinterval_CIDR_split_prefixmatch\n     (WordInterval (fst (dports r)) (snd (dports r))))\n                                   else []).\n           gr =\n           uncurry L4Src `\n           (case xa of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           uncurry L4Dst `\n           (case xaa of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Proto `\n           (case proto r of ProtoAny \\<Rightarrow> {}\n            | Proto p \\<Rightarrow> {p}) \\<union>\n           IngressPort `\n           (case x of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Src `\n           (case toprefixmatch (src r) of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           IPv4Dst `\n           (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n            | Some s \\<Rightarrow> {s}) \\<union>\n           {EtherType 2048}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n  \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                       then [None]\n                       else if fst (sports r) \\<le> snd (sports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (sports r))\n(snd (sports r))))\n                            else []).\n     \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                           then [None]\n                           else if fst (dports r) \\<le> snd (dports r)\n                                then map\n(\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n(wordinterval_CIDR_split_prefixmatch\n  (WordInterval (fst (dports r)) (snd (dports r))))\n                                else []).\n        gr =\n        uncurry L4Src `\n        (case xa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        uncurry L4Dst `\n        (case xaa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Proto `\n        (case proto r of ProtoAny \\<Rightarrow> {}\n         | Proto p \\<Rightarrow> {p}) \\<union>\n        IngressPort `\n        (case x of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Src `\n        (case toprefixmatch (src r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Dst `\n        (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n  \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                       then [None]\n                       else if fst (sports r) \\<le> snd (sports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (sports r))\n(snd (sports r))))\n                            else []).\n     \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                           then [None]\n                           else if fst (dports r) \\<le> snd (dports r)\n                                then map\n(\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n(wordinterval_CIDR_split_prefixmatch\n  (WordInterval (fst (dports r)) (snd (dports r))))\n                                else []).\n        gr =\n        uncurry L4Src `\n        (case xa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        uncurry L4Dst `\n        (case xaa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Proto `\n        (case proto r of ProtoAny \\<Rightarrow> {}\n         | Proto p \\<Rightarrow> {p}) \\<union>\n        IngressPort `\n        (case x of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Src `\n        (case toprefixmatch (src r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Dst `\n        (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "from this(2)"], ["proof (chain)\npicking this:\n  \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                       then [None]\n                       else if fst (sports r) \\<le> snd (sports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (sports r))\n(snd (sports r))))\n                            else []).\n     \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                           then [None]\n                           else if fst (dports r) \\<le> snd (dports r)\n                                then map\n(\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n(wordinterval_CIDR_split_prefixmatch\n  (WordInterval (fst (dports r)) (snd (dports r))))\n                                else []).\n        gr =\n        uncurry L4Src `\n        (case xa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        uncurry L4Dst `\n        (case xaa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Proto `\n        (case proto r of ProtoAny \\<Rightarrow> {}\n         | Proto p \\<Rightarrow> {p}) \\<union>\n        IngressPort `\n        (case x of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Src `\n        (case toprefixmatch (src r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Dst `\n        (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        {EtherType 2048}", "guess xa"], ["proof (prove)\nusing this:\n  \\<exists>xa\\<in>set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                       then [None]\n                       else if fst (sports r) \\<le> snd (sports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (sports r))\n(snd (sports r))))\n                            else []).\n     \\<exists>xaa\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                           then [None]\n                           else if fst (dports r) \\<le> snd (dports r)\n                                then map\n(\\<lambda>x. Some (pfxm_prefix x, ~~ pfxm_mask x))\n(wordinterval_CIDR_split_prefixmatch\n  (WordInterval (fst (dports r)) (snd (dports r))))\n                                else []).\n        gr =\n        uncurry L4Src `\n        (case xa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        uncurry L4Dst `\n        (case xaa of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Proto `\n        (case proto r of ProtoAny \\<Rightarrow> {}\n         | Proto p \\<Rightarrow> {p}) \\<union>\n        IngressPort `\n        (case x of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Src `\n        (case toprefixmatch (src r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        IPv4Dst `\n        (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n         | Some s \\<Rightarrow> {s}) \\<union>\n        {EtherType 2048}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  xa \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                then [None]\n                else if fst (sports r) \\<le> snd (sports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (sports r))\n                               (snd (sports r))))\n                     else [])\n  \\<exists>xb\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                       then [None]\n                       else if fst (dports r) \\<le> snd (dports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (dports r))\n(snd (dports r))))\n                            else []).\n     gr =\n     uncurry L4Src `\n     (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     uncurry L4Dst `\n     (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Proto `\n     (case proto r of ProtoAny \\<Rightarrow> {}\n      | Proto p \\<Rightarrow> {p}) \\<union>\n     IngressPort `\n     (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Src `\n     (case toprefixmatch (src r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Dst `\n     (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "moreover"], ["proof (state)\nthis:\n  xa \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                then [None]\n                else if fst (sports r) \\<le> snd (sports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (sports r))\n                               (snd (sports r))))\n                     else [])\n  \\<exists>xb\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                       then [None]\n                       else if fst (dports r) \\<le> snd (dports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (dports r))\n(snd (dports r))))\n                            else []).\n     gr =\n     uncurry L4Src `\n     (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     uncurry L4Dst `\n     (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Proto `\n     (case proto r of ProtoAny \\<Rightarrow> {}\n      | Proto p \\<Rightarrow> {p}) \\<union>\n     IngressPort `\n     (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Src `\n     (case toprefixmatch (src r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Dst `\n     (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "from this(2)"], ["proof (chain)\npicking this:\n  \\<exists>xb\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                       then [None]\n                       else if fst (dports r) \\<le> snd (dports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (dports r))\n(snd (dports r))))\n                            else []).\n     gr =\n     uncurry L4Src `\n     (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     uncurry L4Dst `\n     (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Proto `\n     (case proto r of ProtoAny \\<Rightarrow> {}\n      | Proto p \\<Rightarrow> {p}) \\<union>\n     IngressPort `\n     (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Src `\n     (case toprefixmatch (src r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Dst `\n     (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     {EtherType 2048}", "guess xb"], ["proof (prove)\nusing this:\n  \\<exists>xb\\<in>set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                       then [None]\n                       else if fst (dports r) \\<le> snd (dports r)\n                            then map (\\<lambda>x.\n   Some (pfxm_prefix x, ~~ pfxm_mask x))\n                                  (wordinterval_CIDR_split_prefixmatch\n                                    (WordInterval (fst (dports r))\n(snd (dports r))))\n                            else []).\n     gr =\n     uncurry L4Src `\n     (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     uncurry L4Dst `\n     (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Proto `\n     (case proto r of ProtoAny \\<Rightarrow> {}\n      | Proto p \\<Rightarrow> {p}) \\<union>\n     IngressPort `\n     (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Src `\n     (case toprefixmatch (src r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     IPv4Dst `\n     (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n      | Some s \\<Rightarrow> {s}) \\<union>\n     {EtherType 2048}\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  xb \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                then [None]\n                else if fst (dports r) \\<le> snd (dports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (dports r))\n                               (snd (dports r))))\n                     else [])\n  gr =\n  uncurry L4Src `\n  (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  uncurry L4Dst `\n  (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Proto `\n  (case proto r of ProtoAny \\<Rightarrow> {}\n   | Proto p \\<Rightarrow> {p}) \\<union>\n  IngressPort `\n  (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Src `\n  (case toprefixmatch (src r) of None \\<Rightarrow> {}\n   | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Dst `\n  (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n   | Some s \\<Rightarrow> {s}) \\<union>\n  {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "note xx = calculation(1,3) this"], ["proof (state)\nthis:\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n  xa \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                then [None]\n                else if fst (sports r) \\<le> snd (sports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (sports r))\n                               (snd (sports r))))\n                     else [])\n  xb \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                then [None]\n                else if fst (dports r) \\<le> snd (dports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (dports r))\n                               (snd (dports r))))\n                     else [])\n  gr =\n  uncurry L4Src `\n  (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  uncurry L4Dst `\n  (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Proto `\n  (case proto r of ProtoAny \\<Rightarrow> {}\n   | Proto p \\<Rightarrow> {p}) \\<union>\n  IngressPort `\n  (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Src `\n  (case toprefixmatch (src r) of None \\<Rightarrow> {}\n   | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Dst `\n  (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n   | Some s \\<Rightarrow> {s}) \\<union>\n  {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "{"], ["proof (state)\nthis:\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n  xa \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                then [None]\n                else if fst (sports r) \\<le> snd (sports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (sports r))\n                               (snd (sports r))))\n                     else [])\n  xb \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                then [None]\n                else if fst (dports r) \\<le> snd (dports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (dports r))\n                               (snd (dports r))))\n                     else [])\n  gr =\n  uncurry L4Src `\n  (case xa of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  uncurry L4Dst `\n  (case xb of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Proto `\n  (case proto r of ProtoAny \\<Rightarrow> {}\n   | Proto p \\<Rightarrow> {p}) \\<union>\n  IngressPort `\n  (case x of None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Src `\n  (case toprefixmatch (src r) of None \\<Rightarrow> {}\n   | Some s \\<Rightarrow> {s}) \\<union>\n  IPv4Dst `\n  (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n   | Some s \\<Rightarrow> {s}) \\<union>\n  {EtherType 2048}\n\ngoal (1 subgoal):\n 1. simple_matches r p", "fix a b xc xa"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_matches r p", "fix pp :: \"16 word\""], ["proof (state)\ngoal (1 subgoal):\n 1. simple_matches r p", "have \"\\<lbrakk>pp && ~~ (pfxm_mask xc) = pfxm_prefix xc\\<rbrakk>\n              \\<Longrightarrow> prefix_match_semantics xc (pp)\" for xc"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp && ~~ pfxm_mask xc = pfxm_prefix xc \\<Longrightarrow>\n    prefix_match_semantics xc pp", "by(simp add: prefix_match_semantics_def word_bw_comms;fail)"], ["proof (state)\nthis:\n  pp && ~~ pfxm_mask ?xc = pfxm_prefix ?xc \\<Longrightarrow>\n  prefix_match_semantics ?xc pp\n\ngoal (1 subgoal):\n 1. simple_matches r p", "moreover"], ["proof (state)\nthis:\n  pp && ~~ pfxm_mask ?xc = pfxm_prefix ?xc \\<Longrightarrow>\n  prefix_match_semantics ?xc pp\n\ngoal (1 subgoal):\n 1. simple_matches r p", "have \"pp \\<in> wordinterval_to_set (WordInterval a b) \\<Longrightarrow> a \\<le> pp \\<and> pp \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp \\<in> wordinterval_to_set (WordInterval a b) \\<Longrightarrow>\n    a \\<le> pp \\<and> pp \\<le> b", "by simp"], ["proof (state)\nthis:\n  pp \\<in> wordinterval_to_set (WordInterval a b) \\<Longrightarrow>\n  a \\<le> pp \\<and> pp \\<le> b\n\ngoal (1 subgoal):\n 1. simple_matches r p", "moreover"], ["proof (state)\nthis:\n  pp \\<in> wordinterval_to_set (WordInterval a b) \\<Longrightarrow>\n  a \\<le> pp \\<and> pp \\<le> b\n\ngoal (1 subgoal):\n 1. simple_matches r p", "have \"xc \\<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)) \\<Longrightarrow> pp \\<in> prefix_to_wordset xc  \\<Longrightarrow> pp \\<in> wordinterval_to_set (WordInterval a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval a b));\n     pp \\<in> prefix_to_wordset xc\\<rbrakk>\n    \\<Longrightarrow> pp \\<in> wordinterval_to_set (WordInterval a b)", "by(subst wordinterval_CIDR_split_prefixmatch) blast"], ["proof (state)\nthis:\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   pp \\<in> prefix_to_wordset xc\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> wordinterval_to_set (WordInterval a b)\n\ngoal (1 subgoal):\n 1. simple_matches r p", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   pp \\<in> prefix_to_wordset xc\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> wordinterval_to_set (WordInterval a b)\n\ngoal (1 subgoal):\n 1. simple_matches r p", "have \"\\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)); xa = Some (pfxm_prefix xc, ~~ (pfxm_mask xc)); prefix_match_semantics xc (pp)\\<rbrakk> \\<Longrightarrow> pp \\<in> prefix_to_wordset xc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval a b));\n     xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n     prefix_match_semantics xc pp\\<rbrakk>\n    \\<Longrightarrow> pp \\<in> prefix_to_wordset xc", "apply(subst(asm)(1) prefix_match_semantics_wordset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval a b));\n     xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc)\\<rbrakk>\n    \\<Longrightarrow> valid_prefix xc\n 2. \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval a b));\n     xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n     pp \\<in> prefix_to_wordset xc\\<rbrakk>\n    \\<Longrightarrow> pp \\<in> prefix_to_wordset xc", "apply(erule wordinterval_CIDR_split_prefixmatch_all_valid_Ball[THEN bspec, THEN conjunct1];fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval a b));\n     xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n     pp \\<in> prefix_to_wordset xc\\<rbrakk>\n    \\<Longrightarrow> pp \\<in> prefix_to_wordset xc", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n   prefix_match_semantics xc pp\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> prefix_to_wordset xc\n\ngoal (1 subgoal):\n 1. simple_matches r p", "ultimately"], ["proof (chain)\npicking this:\n  pp && ~~ pfxm_mask ?xc = pfxm_prefix ?xc \\<Longrightarrow>\n  prefix_match_semantics ?xc pp\n  pp \\<in> wordinterval_to_set (WordInterval a b) \\<Longrightarrow>\n  a \\<le> pp \\<and> pp \\<le> b\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   pp \\<in> prefix_to_wordset xc\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> wordinterval_to_set (WordInterval a b)\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n   prefix_match_semantics xc pp\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> prefix_to_wordset xc", "have \"\\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch (WordInterval a b)); xa = Some (pfxm_prefix xc, ~~ (pfxm_mask xc));\n               pp && ~~ (pfxm_mask xc) = pfxm_prefix xc\\<rbrakk>\n              \\<Longrightarrow> a \\<le> pp \\<and> pp \\<le> b\""], ["proof (prove)\nusing this:\n  pp && ~~ pfxm_mask ?xc = pfxm_prefix ?xc \\<Longrightarrow>\n  prefix_match_semantics ?xc pp\n  pp \\<in> wordinterval_to_set (WordInterval a b) \\<Longrightarrow>\n  a \\<le> pp \\<and> pp \\<le> b\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   pp \\<in> prefix_to_wordset xc\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> wordinterval_to_set (WordInterval a b)\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n   prefix_match_semantics xc pp\\<rbrakk>\n  \\<Longrightarrow> pp \\<in> prefix_to_wordset xc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                            (WordInterval a b));\n     xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n     pp && ~~ pfxm_mask xc = pfxm_prefix xc\\<rbrakk>\n    \\<Longrightarrow> a \\<le> pp \\<and> pp \\<le> b", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>xc \\<in> set (wordinterval_CIDR_split_prefixmatch\n                          (WordInterval a b));\n   xa = Some (pfxm_prefix xc, ~~ pfxm_mask xc);\n   pp && ~~ pfxm_mask xc = pfxm_prefix xc\\<rbrakk>\n  \\<Longrightarrow> a \\<le> pp \\<and> pp \\<le> b\n\ngoal (1 subgoal):\n 1. simple_matches r p", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xc2\n           \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval ?a2 ?b2));\n   ?xaa2 = Some (pfxm_prefix ?xc2, ~~ pfxm_mask ?xc2);\n   ?pp2 && ~~ pfxm_mask ?xc2 = pfxm_prefix ?xc2\\<rbrakk>\n  \\<Longrightarrow> ?a2 \\<le> ?pp2 \\<and> ?pp2 \\<le> ?b2\n\ngoal (1 subgoal):\n 1. simple_matches r p", "note l4port_logic = this"], ["proof (state)\nthis:\n  \\<lbrakk>?xc2\n           \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval ?a2 ?b2));\n   ?xaa2 = Some (pfxm_prefix ?xc2, ~~ pfxm_mask ?xc2);\n   ?pp2 && ~~ pfxm_mask ?xc2 = pfxm_prefix ?xc2\\<rbrakk>\n  \\<Longrightarrow> ?a2 \\<le> ?pp2 \\<and> ?pp2 \\<le> ?b2\n\ngoal (1 subgoal):\n 1. simple_matches r p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_matches r p", "unfolding simple_matches.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. match_iface (iiface r) (p_iiface p) \\<and>\n    match_iface (oiface r) (p_oiface p) \\<and>\n    simple_match_ip (src r) (p_src p) \\<and>\n    simple_match_ip (dst r) (p_dst p) \\<and>\n    match_proto (proto r) (p_proto p) \\<and>\n    simple_match_port (sports r) (p_sport p) \\<and>\n    simple_match_port (dports r) (p_dport p)", "proof(unfold and_assoc, (rule)+)"], ["proof (state)\ngoal (7 subgoals):\n 1. match_iface (iiface r) (p_iiface p)\n 2. match_iface (oiface r) (p_oiface p)\n 3. simple_match_ip (src r) (p_src p)\n 4. simple_match_ip (dst r) (p_dst p)\n 5. match_proto (proto r) (p_proto p)\n 6. simple_match_port (sports r) (p_sport p)\n 7. simple_match_port (dports r) (p_dport p)", "show \"match_iface (iiface r) (p_iiface p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_iface (iiface r) (p_iiface p)", "apply(cases \"iiface r = ifaceAny\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. iiface r = ifaceAny \\<Longrightarrow>\n    match_iface (iiface r) (p_iiface p)\n 2. iiface r \\<noteq> ifaceAny \\<Longrightarrow>\n    match_iface (iiface r) (p_iiface p)", "apply (simp add: match_ifaceAny)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iiface r \\<noteq> ifaceAny \\<Longrightarrow>\n    match_iface (iiface r) (p_iiface p)", "using xx(1) mo"], ["proof (prove)\nusing this:\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n  OF_match_fields_unsafe gr p\n\ngoal (1 subgoal):\n 1. iiface r \\<noteq> ifaceAny \\<Longrightarrow>\n    match_iface (iiface r) (p_iiface p)", "unfolding xx(4) OF_match_fields_unsafe_def"], ["proof (prove)\nusing this:\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n\ngoal (1 subgoal):\n 1. iiface r \\<noteq> ifaceAny \\<Longrightarrow>\n    match_iface (iiface r) (p_iiface p)", "apply(simp only: if_False set_maps UN_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>iiface r \\<noteq> ifaceAny;\n     \\<exists>a\\<in>set ifs.\n        x \\<in> set (if match_iface (iiface r) a then [Some a] else []);\n     \\<forall>f\\<in>uncurry L4Src `\n                    (case xa of None \\<Rightarrow> {}\n                     | Some s \\<Rightarrow> {s}) \\<union>\n                    uncurry L4Dst `\n                    (case xb of None \\<Rightarrow> {}\n                     | Some s \\<Rightarrow> {s}) \\<union>\n                    IPv4Proto `\n                    (case proto r of ProtoAny \\<Rightarrow> {}\n                     | Proto p \\<Rightarrow> {p}) \\<union>\n                    IngressPort `\n                    (case x of None \\<Rightarrow> {}\n                     | Some s \\<Rightarrow> {s}) \\<union>\n                    IPv4Src `\n                    (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                     | Some s \\<Rightarrow> {s}) \\<union>\n                    IPv4Dst `\n                    (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                     | Some s \\<Rightarrow> {s}) \\<union>\n                    {EtherType 2048}.\n        match_no_prereq f p\\<rbrakk>\n    \\<Longrightarrow> match_iface (iiface r) (p_iiface p)", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>iiface r \\<noteq> ifaceAny;\n        \\<forall>f\\<in>uncurry L4Src `\n                       (case xa of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       uncurry L4Dst `\n                       (case xb of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Proto `\n                       (case proto r of ProtoAny \\<Rightarrow> {}\n                        | Proto p \\<Rightarrow> {p}) \\<union>\n                       IngressPort `\n                       (case x of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Src `\n                       (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Dst `\n                       (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       {EtherType 2048}.\n           match_no_prereq f p;\n        a \\<in> set ifs;\n        x \\<in> set (if match_iface (iiface r) a then [Some a]\n                     else [])\\<rbrakk>\n       \\<Longrightarrow> match_iface (iiface r) (p_iiface p)", "apply(rename_tac a; subgoal_tac \"match_iface (iiface r) a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>iiface r \\<noteq> ifaceAny;\n        \\<forall>f\\<in>uncurry L4Src `\n                       (case xa of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       uncurry L4Dst `\n                       (case xb of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Proto `\n                       (case proto r of ProtoAny \\<Rightarrow> {}\n                        | Proto p \\<Rightarrow> {p}) \\<union>\n                       IngressPort `\n                       (case x of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Src `\n                       (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Dst `\n                       (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       {EtherType 2048}.\n           match_no_prereq f p;\n        a \\<in> set ifs;\n        x \\<in> set (if match_iface (iiface r) a then [Some a] else []);\n        match_iface (iiface r) a\\<rbrakk>\n       \\<Longrightarrow> match_iface (iiface r) (p_iiface p)\n 2. \\<And>a.\n       \\<lbrakk>iiface r \\<noteq> ifaceAny;\n        \\<forall>f\\<in>uncurry L4Src `\n                       (case xa of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       uncurry L4Dst `\n                       (case xb of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Proto `\n                       (case proto r of ProtoAny \\<Rightarrow> {}\n                        | Proto p \\<Rightarrow> {p}) \\<union>\n                       IngressPort `\n                       (case x of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Src `\n                       (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Dst `\n                       (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       {EtherType 2048}.\n           match_no_prereq f p;\n        a \\<in> set ifs;\n        x \\<in> set (if match_iface (iiface r) a then [Some a]\n                     else [])\\<rbrakk>\n       \\<Longrightarrow> match_iface (iiface r) a", "apply(clarsimp simp add: option2set_def;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>iiface r \\<noteq> ifaceAny;\n        \\<forall>f\\<in>uncurry L4Src `\n                       (case xa of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       uncurry L4Dst `\n                       (case xb of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Proto `\n                       (case proto r of ProtoAny \\<Rightarrow> {}\n                        | Proto p \\<Rightarrow> {p}) \\<union>\n                       IngressPort `\n                       (case x of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Src `\n                       (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       IPv4Dst `\n                       (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                        | Some s \\<Rightarrow> {s}) \\<union>\n                       {EtherType 2048}.\n           match_no_prereq f p;\n        a \\<in> set ifs;\n        x \\<in> set (if match_iface (iiface r) a then [Some a]\n                     else [])\\<rbrakk>\n       \\<Longrightarrow> match_iface (iiface r) a", "apply(rule ccontr,simp;fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  match_iface (iiface r) (p_iiface p)\n\ngoal (6 subgoals):\n 1. match_iface (oiface r) (p_oiface p)\n 2. simple_match_ip (src r) (p_src p)\n 3. simple_match_ip (dst r) (p_dst p)\n 4. match_proto (proto r) (p_proto p)\n 5. simple_match_port (sports r) (p_sport p)\n 6. simple_match_port (dports r) (p_dport p)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. match_iface (oiface r) (p_oiface p)\n 2. simple_match_ip (src r) (p_src p)\n 3. simple_match_ip (dst r) (p_dst p)\n 4. match_proto (proto r) (p_proto p)\n 5. simple_match_port (sports r) (p_sport p)\n 6. simple_match_port (dports r) (p_dport p)", "show \"match_iface (oiface r) (p_oiface p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_iface (oiface r) (p_oiface p)", "using me"], ["proof (prove)\nusing this:\n  match_iface (oiface r) (p_oiface p)\n\ngoal (1 subgoal):\n 1. match_iface (oiface r) (p_oiface p)", "."], ["proof (state)\nthis:\n  match_iface (oiface r) (p_oiface p)\n\ngoal (5 subgoals):\n 1. simple_match_ip (src r) (p_src p)\n 2. simple_match_ip (dst r) (p_dst p)\n 3. match_proto (proto r) (p_proto p)\n 4. simple_match_port (sports r) (p_sport p)\n 5. simple_match_port (dports r) (p_dport p)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. simple_match_ip (src r) (p_src p)\n 2. simple_match_ip (dst r) (p_dst p)\n 3. match_proto (proto r) (p_proto p)\n 4. simple_match_port (sports r) (p_sport p)\n 5. simple_match_port (dports r) (p_dport p)", "show \"simple_match_ip (src r) (p_src p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_ip (src r) (p_src p)", "using mo"], ["proof (prove)\nusing this:\n  OF_match_fields_unsafe gr p\n\ngoal (1 subgoal):\n 1. simple_match_ip (src r) (p_src p)", "unfolding xx(4) OF_match_fields_unsafe_def toprefixmatch_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case let pm = PrefixMatch (fst (src r)) (snd (src r))\n                       in if pm = PrefixMatch 0 0 then None else Some pm of\n                  None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case let pm = PrefixMatch (fst (dst r)) (snd (dst r))\n                       in if pm = PrefixMatch 0 0 then None else Some pm of\n                  None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n\ngoal (1 subgoal):\n 1. simple_match_ip (src r) (p_src p)", "by(clarsimp\n\t\t\t  simp add: simple_packet_unext_def option2set_def validpfx simple_match_src_alt[OF mv] toprefixmatch_def \n\t\t\t  split: if_splits)"], ["proof (state)\nthis:\n  simple_match_ip (src r) (p_src p)\n\ngoal (4 subgoals):\n 1. simple_match_ip (dst r) (p_dst p)\n 2. match_proto (proto r) (p_proto p)\n 3. simple_match_port (sports r) (p_sport p)\n 4. simple_match_port (dports r) (p_dport p)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. simple_match_ip (dst r) (p_dst p)\n 2. match_proto (proto r) (p_proto p)\n 3. simple_match_port (sports r) (p_sport p)\n 4. simple_match_port (dports r) (p_dport p)", "show \"simple_match_ip (dst r) (p_dst p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_ip (dst r) (p_dst p)", "using mo"], ["proof (prove)\nusing this:\n  OF_match_fields_unsafe gr p\n\ngoal (1 subgoal):\n 1. simple_match_ip (dst r) (p_dst p)", "unfolding xx(4) OF_match_fields_unsafe_def toprefixmatch_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case let pm = PrefixMatch (fst (src r)) (snd (src r))\n                       in if pm = PrefixMatch 0 0 then None else Some pm of\n                  None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case let pm = PrefixMatch (fst (dst r)) (snd (dst r))\n                       in if pm = PrefixMatch 0 0 then None else Some pm of\n                  None \\<Rightarrow> {} | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n\ngoal (1 subgoal):\n 1. simple_match_ip (dst r) (p_dst p)", "by(clarsimp\n\t\t\t  simp add: simple_packet_unext_def option2set_def validpfx simple_match_dst_alt[OF mv] toprefixmatch_def \n\t\t\t  split: if_splits)"], ["proof (state)\nthis:\n  simple_match_ip (dst r) (p_dst p)\n\ngoal (3 subgoals):\n 1. match_proto (proto r) (p_proto p)\n 2. simple_match_port (sports r) (p_sport p)\n 3. simple_match_port (dports r) (p_dport p)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. match_proto (proto r) (p_proto p)\n 2. simple_match_port (sports r) (p_sport p)\n 3. simple_match_port (dports r) (p_dport p)", "show \"match_proto (proto r) (p_proto p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_proto (proto r) (p_proto p)", "using mo"], ["proof (prove)\nusing this:\n  OF_match_fields_unsafe gr p\n\ngoal (1 subgoal):\n 1. match_proto (proto r) (p_proto p)", "unfolding xx(4) OF_match_fields_unsafe_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n\ngoal (1 subgoal):\n 1. match_proto (proto r) (p_proto p)", "using xx(1)"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n  x \\<in> set (if iiface r = ifaceAny then [None]\n               else List.maps\n                     (\\<lambda>i.\n                         if match_iface (iiface r) i then [Some i] else [])\n                     ifs)\n\ngoal (1 subgoal):\n 1. match_proto (proto r) (p_proto p)", "by(clarsimp \n\t\t\t\tsimp add: singleton_iff simple_packet_unext_def option2set_def prefix_match_semantics_simple_match ball_Un \n\t\t\t\tsplit: if_splits protocol.splits)"], ["proof (state)\nthis:\n  match_proto (proto r) (p_proto p)\n\ngoal (2 subgoals):\n 1. simple_match_port (sports r) (p_sport p)\n 2. simple_match_port (dports r) (p_dport p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. simple_match_port (sports r) (p_sport p)\n 2. simple_match_port (dports r) (p_dport p)", "show \"simple_match_port (sports r) (p_sport p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_port (sports r) (p_sport p)", "using mo xx(2)"], ["proof (prove)\nusing this:\n  OF_match_fields_unsafe gr p\n  xa \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                then [None]\n                else if fst (sports r) \\<le> snd (sports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (sports r))\n                               (snd (sports r))))\n                     else [])\n\ngoal (1 subgoal):\n 1. simple_match_port (sports r) (p_sport p)", "unfolding xx(4) OF_match_fields_unsafe_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n  xa \\<in> set (if fst (sports r) = 0 \\<and> snd (sports r) = - 1\n                then [None]\n                else if fst (sports r) \\<le> snd (sports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (sports r))\n                               (snd (sports r))))\n                     else [])\n\ngoal (1 subgoal):\n 1. simple_match_port (sports r) (p_sport p)", "by(cases \"sports r\") (clarsimp simp add: l4port_logic simple_packet_unext_def option2set_def prefix_match_semantics_simple_match split: if_splits)"], ["proof (state)\nthis:\n  simple_match_port (sports r) (p_sport p)\n\ngoal (1 subgoal):\n 1. simple_match_port (dports r) (p_dport p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_match_port (dports r) (p_dport p)", "show \"simple_match_port (dports r) (p_dport p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_port (dports r) (p_dport p)", "using mo xx(3)"], ["proof (prove)\nusing this:\n  OF_match_fields_unsafe gr p\n  xb \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                then [None]\n                else if fst (dports r) \\<le> snd (dports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (dports r))\n                               (snd (dports r))))\n                     else [])\n\ngoal (1 subgoal):\n 1. simple_match_port (dports r) (p_dport p)", "unfolding xx(4) OF_match_fields_unsafe_def"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>uncurry L4Src `\n                 (case xa of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 uncurry L4Dst `\n                 (case xb of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Proto `\n                 (case proto r of ProtoAny \\<Rightarrow> {}\n                  | Proto p \\<Rightarrow> {p}) \\<union>\n                 IngressPort `\n                 (case x of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Src `\n                 (case toprefixmatch (src r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 IPv4Dst `\n                 (case toprefixmatch (dst r) of None \\<Rightarrow> {}\n                  | Some s \\<Rightarrow> {s}) \\<union>\n                 {EtherType 2048}.\n     match_no_prereq f p\n  xb \\<in> set (if fst (dports r) = 0 \\<and> snd (dports r) = - 1\n                then [None]\n                else if fst (dports r) \\<le> snd (dports r)\n                     then map (\\<lambda>x.\n                                  Some (pfxm_prefix x, ~~ pfxm_mask x))\n                           (wordinterval_CIDR_split_prefixmatch\n                             (WordInterval (fst (dports r))\n                               (snd (dports r))))\n                     else [])\n\ngoal (1 subgoal):\n 1. simple_match_port (dports r) (p_dport p)", "by(cases \"dports r\") (clarsimp simp add: l4port_logic simple_packet_unext_def option2set_def prefix_match_semantics_simple_match split: if_splits)"], ["proof (state)\nthis:\n  simple_match_port (dports r) (p_dport p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  simple_matches r p\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec annotate_rlen where\n\"annotate_rlen [] = []\" |\n\"annotate_rlen (a#as) = (length as, a) # annotate_rlen as\""], ["", "lemma \"annotate_rlen ''asdf'' = [(3, CHR ''a''), (2, CHR ''s''), (1, CHR ''d''), (0, CHR ''f'')]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annotate_rlen ''asdf'' =\n    [(3, CHR ''a''), (2, CHR ''s''), (1, CHR ''d''), (0, CHR ''f'')]", "by simp"], ["", "lemma fst_annotate_rlen_le: \"(k, a) \\<in> set (annotate_rlen l) \\<Longrightarrow> k < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, a) \\<in> set (annotate_rlen l) \\<Longrightarrow> k < length l", "by(induction l arbitrary: k; simp; force)"], ["", "lemma distinct_fst_annotate_rlen: \"distinct (map fst (annotate_rlen l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (annotate_rlen l))", "using fst_annotate_rlen_le"], ["proof (prove)\nusing this:\n  (?k, ?a) \\<in> set (annotate_rlen ?l) \\<Longrightarrow> ?k < length ?l\n\ngoal (1 subgoal):\n 1. distinct (map fst (annotate_rlen l))", "by(induction l) (simp, fastforce)"], ["", "lemma distinct_annotate_rlen: \"distinct (annotate_rlen l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (annotate_rlen l)", "using distinct_fst_annotate_rlen"], ["proof (prove)\nusing this:\n  distinct (map fst (annotate_rlen ?l))\n\ngoal (1 subgoal):\n 1. distinct (annotate_rlen l)", "unfolding distinct_map"], ["proof (prove)\nusing this:\n  distinct (annotate_rlen ?l) \\<and> inj_on fst (set (annotate_rlen ?l))\n\ngoal (1 subgoal):\n 1. distinct (annotate_rlen l)", "by blast"], ["", "lemma in_annotate_rlen: \"(a,x) \\<in> set (annotate_rlen l) \\<Longrightarrow> x \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, x) \\<in> set (annotate_rlen l) \\<Longrightarrow> x \\<in> set l", "by(induction l) (simp_all, blast)"], ["", "lemma map_snd_annotate_rlen: \"map snd (annotate_rlen l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (annotate_rlen l) = l", "by(induction l) simp_all"], ["", "lemma \"sorted_descending (map fst (annotate_rlen l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_descending (map fst (annotate_rlen l))", "by(induction l; clarsimp) (force dest: fst_annotate_rlen_le)"], ["", "lemma \"annotate_rlen l = zip (rev [0..<length l]) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annotate_rlen l = zip (rev [0..<length l]) l", "by(induction l; simp)"], ["", "(* It would probably have been better to just use the zip, but oh well\\<dots> *)"], ["", "primrec annotate_rlen_code where\n\"annotate_rlen_code [] = (0,[])\" |\n\"annotate_rlen_code (a#as) = (case annotate_rlen_code as of (r,aas) \\<Rightarrow> (Suc r, (r, a) # aas))\""], ["", "lemma annotate_rlen_len: \"fst (annotate_rlen_code r) = length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (annotate_rlen_code r) = length r", "by(induction r) (clarsimp split: prod.splits)+"], ["", "lemma annotate_rlen_code[code]: \"annotate_rlen s = snd (annotate_rlen_code s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annotate_rlen s = snd (annotate_rlen_code s)", "proof(induction s)"], ["proof (state)\ngoal (2 subgoals):\n 1. annotate_rlen [] = snd (annotate_rlen_code [])\n 2. \\<And>a s.\n       annotate_rlen s = snd (annotate_rlen_code s) \\<Longrightarrow>\n       annotate_rlen (a # s) = snd (annotate_rlen_code (a # s))", "case (Cons s ss)"], ["proof (state)\nthis:\n  annotate_rlen ss = snd (annotate_rlen_code ss)\n\ngoal (2 subgoals):\n 1. annotate_rlen [] = snd (annotate_rlen_code [])\n 2. \\<And>a s.\n       annotate_rlen s = snd (annotate_rlen_code s) \\<Longrightarrow>\n       annotate_rlen (a # s) = snd (annotate_rlen_code (a # s))", "thus ?case"], ["proof (prove)\nusing this:\n  annotate_rlen ss = snd (annotate_rlen_code ss)\n\ngoal (1 subgoal):\n 1. annotate_rlen (s # ss) = snd (annotate_rlen_code (s # ss))", "using annotate_rlen_len[of ss]"], ["proof (prove)\nusing this:\n  annotate_rlen ss = snd (annotate_rlen_code ss)\n  fst (annotate_rlen_code ss) = length ss\n\ngoal (1 subgoal):\n 1. annotate_rlen (s # ss) = snd (annotate_rlen_code (s # ss))", "by(clarsimp split: prod.split)"], ["proof (state)\nthis:\n  annotate_rlen (s # ss) = snd (annotate_rlen_code (s # ss))\n\ngoal (1 subgoal):\n 1. annotate_rlen [] = snd (annotate_rlen_code [])", "qed simp"], ["", "lemma suc2plus_inj_on: \"inj_on (of_nat :: nat \\<Rightarrow> ('l :: len) word) {0..unat (max_word :: 'l word)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on word_of_nat {0..unat (- 1)}", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "let ?mmw = \"(max_word :: 'l word)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "let ?mstp = \"(of_nat :: nat \\<Rightarrow> 'l word)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> {0..unat ?mmw}\" \"y \\<in> {0..unat ?mmw}\""], ["proof (state)\nthis:\n  x \\<in> {0..unat (- 1)}\n  y \\<in> {0..unat (- 1)}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence se: \"x \\<le> unat ?mmw\" \"y \\<le> unat ?mmw\""], ["proof (prove)\nusing this:\n  x \\<in> {0..unat (- 1)}\n  y \\<in> {0..unat (- 1)}\n\ngoal (1 subgoal):\n 1. x \\<le> unat (- 1) &&& y \\<le> unat (- 1)", "by simp_all"], ["proof (state)\nthis:\n  x \\<le> unat (- 1)\n  y \\<le> unat (- 1)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume eq: \"?mstp x = ?mstp y\""], ["proof (state)\nthis:\n  word_of_nat x = word_of_nat y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "note f = le_unat_uoi[OF se(1)] le_unat_uoi[OF se(2)]"], ["proof (state)\nthis:\n  unat (word_of_nat x) = x\n  unat (word_of_nat y) = y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..unat (- 1)}; y \\<in> {0..unat (- 1)};\n        word_of_nat x = word_of_nat y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using eq le_unat_uoi se"], ["proof (prove)\nusing this:\n  word_of_nat x = word_of_nat y\n  ?y \\<le> unat ?z \\<Longrightarrow> unat (word_of_nat ?y) = ?y\n  x \\<le> unat (- 1)\n  y \\<le> unat (- 1)\n\ngoal (1 subgoal):\n 1. x = y", "by metis"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_of_nat_list: (* TODO: Move to CaesarWordLemmaBucket *)\n\t\"distinct l \\<Longrightarrow> \\<forall>e \\<in> set l. e \\<le> unat (max_word :: ('l::len) word) \\<Longrightarrow> distinct (map (of_nat :: nat \\<Rightarrow> 'l word) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat l)", "proof(induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "let ?mmw = \"(max_word :: 'l word)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "let ?mstp = \"(of_nat :: nat \\<Rightarrow> 'l word)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct as; \\<forall>e\\<in>set as. e \\<le> unat (- 1)\\<rbrakk>\n  \\<Longrightarrow> distinct (map word_of_nat as)\n  distinct (a # as)\n  \\<forall>e\\<in>set (a # as). e \\<le> unat (- 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "have \"distinct as\" \"\\<forall>e\\<in>set as. e \\<le> unat ?mmw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct as &&& \\<forall>e\\<in>set as. e \\<le> unat (- 1)", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct (a # as)\n  \\<forall>e\\<in>set (a # as). e \\<le> unat (- 1)\n\ngoal (1 subgoal):\n 1. distinct as &&& \\<forall>e\\<in>set as. e \\<le> unat (- 1)", "by simp_all"], ["proof (state)\nthis:\n  distinct as\n  \\<forall>e\\<in>set as. e \\<le> unat (- 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "note mIH = Cons.IH[OF this]"], ["proof (state)\nthis:\n  distinct (map word_of_nat as)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "moreover"], ["proof (state)\nthis:\n  distinct (map word_of_nat as)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "have \"?mstp a \\<notin> ?mstp ` set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. word_of_nat a \\<notin> word_of_nat ` set as", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. word_of_nat a \\<in> word_of_nat ` set as \\<Longrightarrow> False", "have representable_set: \"set as \\<subseteq> {0..unat ?mmw}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set as \\<subseteq> {0..unat (- 1)}", "using \\<open>\\<forall>e\\<in>set (a # as). e \\<le> unat max_word\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (a # as). e \\<le> unat (- 1)\n\ngoal (1 subgoal):\n 1. set as \\<subseteq> {0..unat (- 1)}", "by fastforce"], ["proof (state)\nthis:\n  set as \\<subseteq> {0..unat (- 1)}\n\ngoal (1 subgoal):\n 1. word_of_nat a \\<in> word_of_nat ` set as \\<Longrightarrow> False", "have a_reprbl: \"a \\<in> {0..unat ?mmw}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> {0..unat (- 1)}", "using \\<open>\\<forall>e\\<in>set (a # as). e \\<le> unat max_word\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>set (a # as). e \\<le> unat (- 1)\n\ngoal (1 subgoal):\n 1. a \\<in> {0..unat (- 1)}", "by simp"], ["proof (state)\nthis:\n  a \\<in> {0..unat (- 1)}\n\ngoal (1 subgoal):\n 1. word_of_nat a \\<in> word_of_nat ` set as \\<Longrightarrow> False", "assume \"?mstp a \\<in> ?mstp ` set as\""], ["proof (state)\nthis:\n  word_of_nat a \\<in> word_of_nat ` set as\n\ngoal (1 subgoal):\n 1. word_of_nat a \\<in> word_of_nat ` set as \\<Longrightarrow> False", "with inj_on_image_mem_iff[OF suc2plus_inj_on a_reprbl representable_set]"], ["proof (chain)\npicking this:\n  (word_of_nat a \\<in> word_of_nat ` set as) = (a \\<in> set as)\n  word_of_nat a \\<in> word_of_nat ` set as", "have \"a \\<in> set as\""], ["proof (prove)\nusing this:\n  (word_of_nat a \\<in> word_of_nat ` set as) = (a \\<in> set as)\n  word_of_nat a \\<in> word_of_nat ` set as\n\ngoal (1 subgoal):\n 1. a \\<in> set as", "by simp"], ["proof (state)\nthis:\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. word_of_nat a \\<in> word_of_nat ` set as \\<Longrightarrow> False", "with \\<open>distinct (a # as)\\<close>"], ["proof (chain)\npicking this:\n  distinct (a # as)\n  a \\<in> set as", "show False"], ["proof (prove)\nusing this:\n  distinct (a # as)\n  a \\<in> set as\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  word_of_nat a \\<notin> word_of_nat ` set as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>e\\<in>set l. e \\<le> unat (- 1)\\<rbrakk>\n                \\<Longrightarrow> distinct (map word_of_nat l);\n        distinct (a # l);\n        \\<forall>e\\<in>set (a # l). e \\<le> unat (- 1)\\<rbrakk>\n       \\<Longrightarrow> distinct (map word_of_nat (a # l))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map word_of_nat as)\n  word_of_nat a \\<notin> word_of_nat ` set as", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map word_of_nat as)\n  word_of_nat a \\<notin> word_of_nat ` set as\n\ngoal (1 subgoal):\n 1. distinct (map word_of_nat (a # as))", "by simp"], ["proof (state)\nthis:\n  distinct (map word_of_nat (a # as))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct []; \\<forall>e\\<in>set []. e \\<le> unat (- 1)\\<rbrakk>\n    \\<Longrightarrow> distinct (map word_of_nat [])", "qed simp"], ["", "lemma annotate_first_le_hlp:\n\t\"length l < unat (max_word :: ('l :: len) word) \\<Longrightarrow> \\<forall>e\\<in>set (map fst (annotate_rlen l)). e \\<le> unat (max_word :: 'l word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l < unat (- 1) \\<Longrightarrow>\n    \\<forall>e\\<in>set (map fst (annotate_rlen l)). e \\<le> unat (- 1)", "by(clarsimp) (meson fst_annotate_rlen_le less_trans nat_less_le)"], ["", "lemmas distinct_of_prio_hlp = distinct_of_nat_list[OF distinct_fst_annotate_rlen annotate_first_le_hlp]"], ["", "(* don't need these right now, but maybe later? *)"], ["", "lemma fst_annotate_rlen: \"map fst (annotate_rlen l) = rev [0..<length l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (annotate_rlen l) = rev [0..<length l]", "by(induction l) (simp_all)"], ["", "lemma sorted_word_upt:\n  defines[simp]: \"won \\<equiv> (of_nat :: nat \\<Rightarrow> ('l :: len) word)\"\n  assumes \"length l \\<le> unat (max_word :: 'l word)\"\n  shows \"sorted_descending (map won (rev [0..<Suc (length l)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_descending (map won (rev [0..<Suc (length l)]))", "using assms"], ["proof (prove)\nusing this:\n  won \\<equiv> word_of_nat\n  length l \\<le> unat (- 1)\n\ngoal (1 subgoal):\n 1. sorted_descending (map won (rev [0..<Suc (length l)]))", "by(induction l rule: rev_induct;clarsimp)\n    (metis (mono_tags, hide_lams) le_SucI le_unat_uoi of_nat_Suc order_refl word_le_nat_alt)"], ["", "(* This proof is kind of ugly. In case it breaks unfixably, go back to rev a9c4927 and get word_upto.\n       The lemmas on word_upto can be used to shows this trivially. *)"], ["", "lemma sorted_annotated:\n\tassumes \"length l \\<le> unat (max_word :: ('l :: len) word)\"\n\tshows \"sorted_descending (map fst (map (apfst (of_nat :: nat \\<Rightarrow> 'l word)) (annotate_rlen l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))", "let ?won = \"(of_nat :: nat \\<Rightarrow> 'l word)\""], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))", "have \"sorted_descending (map ?won (rev [0..<Suc (length l)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_descending (map word_of_nat (rev [0..<Suc (length l)]))", "using sorted_word_upt[OF assms]"], ["proof (prove)\nusing this:\n  sorted_descending (map word_of_nat (rev [0..<Suc (length l)]))\n\ngoal (1 subgoal):\n 1. sorted_descending (map word_of_nat (rev [0..<Suc (length l)]))", "."], ["proof (state)\nthis:\n  sorted_descending (map word_of_nat (rev [0..<Suc (length l)]))\n\ngoal (1 subgoal):\n 1. sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))", "hence \"sorted_descending (map ?won (map fst (annotate_rlen l)))\""], ["proof (prove)\nusing this:\n  sorted_descending (map word_of_nat (rev [0..<Suc (length l)]))\n\ngoal (1 subgoal):\n 1. sorted_descending (map word_of_nat (map fst (annotate_rlen l)))", "by(simp add: fst_annotate_rlen)"], ["proof (state)\nthis:\n  sorted_descending (map word_of_nat (map fst (annotate_rlen l)))\n\ngoal (1 subgoal):\n 1. sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))", "thus \"sorted_descending (map fst (map (apfst ?won) (annotate_rlen l)))\""], ["proof (prove)\nusing this:\n  sorted_descending (map word_of_nat (map fst (annotate_rlen l)))\n\ngoal (1 subgoal):\n 1. sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))", "by simp"], ["proof (state)\nthis:\n  sorted_descending (map fst (map (apfst word_of_nat) (annotate_rlen l)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>l3 device to l2 forwarding\\<close>"], ["", "definition \"lr_of_tran_s3 ifs ard = (\n\t[(p, b, case a of simple_action.Accept \\<Rightarrow> [Forward c] | simple_action.Drop \\<Rightarrow> []).\n\t\t(p,r,(c,a)) \\<leftarrow> ard, b \\<leftarrow> simple_match_to_of_match r ifs])\""], ["", "definition \"oif_ne_iif_p1 ifs \\<equiv> [(simple_match_any\\<lparr>oiface := Iface oif, iiface := Iface iif\\<rparr>, simple_action.Accept). oif \\<leftarrow> ifs, iif \\<leftarrow> ifs, oif \\<noteq> iif]\""], ["", "definition \"oif_ne_iif_p2 ifs = [(simple_match_any\\<lparr>oiface := Iface i, iiface := Iface i\\<rparr>, simple_action.Drop). i \\<leftarrow> ifs]\""], ["", "definition \"oif_ne_iif ifs = oif_ne_iif_p2 ifs @ oif_ne_iif_p1 ifs\""], ["", "(* order irrelephant *)\n(*value \"oif_ne_iif [''a'', ''b'']\"*)\n(* I first tried something like \"oif_ne_iif ifs \\<equiv> [(simple_match_any\\<lparr>oiface := Iface oi, iiface := Iface ii\\<rparr>, if oi = ii then simple_action.Drop else simple_action.Accept). oi \\<leftarrow> ifs, ii \\<leftarrow> ifs]\", \n   but making the statement I wanted with that was really tricky. Much easier to have the second element constant and do it separately. *)"], ["", "definition \"lr_of_tran_s4 ard ifs \\<equiv> generalized_fw_join ard (oif_ne_iif ifs)\""], ["", "definition \"lr_of_tran_s1 rt = [(route2match r, output_iface (routing_action r)). r \\<leftarrow> rt]\""], ["", "definition \"lr_of_tran_fbs rt fw ifs \\<equiv> let\n\tgfw = map simple_rule_dtor fw; \\<comment> \\<open>generalized simple fw, hopefully for FORWARD\\<close>\n\tfrt = lr_of_tran_s1 rt; \\<comment> \\<open>rt as fw\\<close>\n\tprd = generalized_fw_join frt gfw\n\tin prd\n\""], ["", "definition \"pack_OF_entries ifs ard \\<equiv> (map (split3 OFEntry) (lr_of_tran_s3 ifs ard))\""], ["", "definition \"no_oif_match \\<equiv> list_all (\\<lambda>m. oiface (match_sel m) = ifaceAny)\""], ["", "definition \"lr_of_tran rt fw ifs \\<equiv> \n  if \\<not> (no_oif_match fw \\<and> has_default_policy fw \\<and> simple_fw_valid fw\t\\<and> valid_prefixes rt \\<and> has_default_route rt \\<and> distinct ifs)\n    then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n    else (\n  let\tnrd = lr_of_tran_fbs rt fw ifs;\n\tard = map (apfst of_nat) (annotate_rlen nrd) \\<comment> \\<open>give them a priority\\<close>\n\tin\n\tif length nrd < unat (max_word :: 16 word)\n\tthen Inr (pack_OF_entries ifs ard)\n\telse Inl ''Error in creating OpenFlow table: priority number space exhausted'')\n\""], ["", "definition \"is_iface_name i \\<equiv> i \\<noteq> [] \\<and> \\<not>Iface.iface_name_is_wildcard i\""], ["", "definition \"is_iface_list ifs \\<equiv> distinct ifs \\<and> list_all is_iface_name ifs\""], ["", "lemma max_16_word_max[simp]: \"(a :: 16 word) \\<le> 0xffff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> 65535", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> 65535", "have \"0xFFFF = (- 1 :: 16 word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 65535 = - 1", "by simp"], ["proof (state)\nthis:\n  65535 = - 1\n\ngoal (1 subgoal):\n 1. a \\<le> 65535", "then"], ["proof (chain)\npicking this:\n  65535 = - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  65535 = - 1\n\ngoal (1 subgoal):\n 1. a \\<le> 65535", "by (simp only:) simp"], ["proof (state)\nthis:\n  a \\<le> 65535\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replicate_FT_hlp: \"x \\<le> 16 \\<and> y \\<le> 16 \\<Longrightarrow> replicate (16 - x) False @ replicate x True = replicate (16 - y) False @ replicate y True \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "let ?ns = \"{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"x \\<le> 16 \\<and> y \\<le> 16\""], ["proof (state)\nthis:\n  x \\<le> 16 \\<and> y \\<le> 16\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "hence \"x \\<in> ?ns\" \"y \\<in> ?ns\""], ["proof (prove)\nusing this:\n  x \\<le> 16 \\<and> y \\<le> 16\n\ngoal (1 subgoal):\n 1. x \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16} &&&\n    y \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}", "by(simp; presburger)+"], ["proof (state)\nthis:\n  x \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n  y \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  x \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n  y \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume \"replicate (16 - x) False @ replicate x True = replicate (16 - y) False @ replicate y True\""], ["proof (state)\nthis:\n  replicate (16 - x) False @ replicate x True =\n  replicate (16 - y) False @ replicate y True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> 16 \\<and> y \\<le> 16;\n     replicate (16 - x) False @ replicate x True =\n     replicate (16 - y) False @ replicate y True\\<rbrakk>\n    \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n  y \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n  replicate (16 - x) False @ replicate x True =\n  replicate (16 - y) False @ replicate y True", "show \"x = y\""], ["proof (prove)\nusing this:\n  x \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n  y \\<in> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n  replicate (16 - x) False @ replicate x True =\n  replicate (16 - y) False @ replicate y True\n\ngoal (1 subgoal):\n 1. x = y", "by simp (elim disjE; simp_all add: numeral_eq_Suc)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "(* that's only 289 subgoals after the elim *)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mask_inj_hlp1: \"inj_on (mask :: nat \\<Rightarrow> 16 word) {0..16}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on mask {0..16}", "proof(intro inj_onI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..16}; y \\<in> {0..16}; mask x = mask y\\<rbrakk>\n       \\<Longrightarrow> x = y", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> {0..16}\n  y \\<in> {0..16}\n  mask x = mask y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..16}; y \\<in> {0..16}; mask x = mask y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from 1(3)"], ["proof (chain)\npicking this:\n  mask x = mask y", "have oe: \"of_bl (replicate (16 - x) False @ replicate x True) = (of_bl (replicate (16 - y) False @ replicate y True) :: 16 word)\""], ["proof (prove)\nusing this:\n  mask x = mask y\n\ngoal (1 subgoal):\n 1. of_bl (replicate (16 - x) False @ replicate x True) =\n    of_bl (replicate (16 - y) False @ replicate y True)", "unfolding mask_bl of_bl_rep_False"], ["proof (prove)\nusing this:\n  of_bl (replicate x True) = of_bl (replicate y True)\n\ngoal (1 subgoal):\n 1. of_bl (replicate x True) = of_bl (replicate y True)", "."], ["proof (state)\nthis:\n  of_bl (replicate (16 - x) False @ replicate x True) =\n  of_bl (replicate (16 - y) False @ replicate y True)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..16}; y \\<in> {0..16}; mask x = mask y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<And>z. z \\<le> 16 \\<Longrightarrow> length (replicate (16 - z) False @ replicate z True) = 16\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<le> 16 \\<Longrightarrow>\n       length (replicate (16 - z) False @ replicate z True) = 16", "by auto"], ["proof (state)\nthis:\n  ?z \\<le> 16 \\<Longrightarrow>\n  length (replicate (16 - ?z) False @ replicate ?z True) = 16\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..16}; y \\<in> {0..16}; mask x = mask y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with 1(1,2)"], ["proof (chain)\npicking this:\n  x \\<in> {0..16}\n  y \\<in> {0..16}\n  ?z \\<le> 16 \\<Longrightarrow>\n  length (replicate (16 - ?z) False @ replicate ?z True) = 16", "have ps: \"replicate (16 - x) False @ replicate x True \\<in> {bl. length bl = LENGTH(16)}\" \" replicate (16 - y) False @ replicate y True \\<in> {bl. length bl = LENGTH(16)}\""], ["proof (prove)\nusing this:\n  x \\<in> {0..16}\n  y \\<in> {0..16}\n  ?z \\<le> 16 \\<Longrightarrow>\n  length (replicate (16 - ?z) False @ replicate ?z True) = 16\n\ngoal (1 subgoal):\n 1. replicate (16 - x) False @ replicate x True\n    \\<in> {bl. length bl = LENGTH(16)} &&&\n    replicate (16 - y) False @ replicate y True\n    \\<in> {bl. length bl = LENGTH(16)}", "by simp_all"], ["proof (state)\nthis:\n  replicate (16 - x) False @ replicate x True\n  \\<in> {bl. length bl = LENGTH(16)}\n  replicate (16 - y) False @ replicate y True\n  \\<in> {bl. length bl = LENGTH(16)}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..16}; y \\<in> {0..16}; mask x = mask y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from inj_onD[OF word_bl.Abs_inj_on, OF oe ps]"], ["proof (chain)\npicking this:\n  replicate (16 - x) False @ replicate x True =\n  replicate (16 - y) False @ replicate y True", "show ?case"], ["proof (prove)\nusing this:\n  replicate (16 - x) False @ replicate x True =\n  replicate (16 - y) False @ replicate y True\n\ngoal (1 subgoal):\n 1. x = y", "using 1(1,2)"], ["proof (prove)\nusing this:\n  replicate (16 - x) False @ replicate x True =\n  replicate (16 - y) False @ replicate y True\n  x \\<in> {0..16}\n  y \\<in> {0..16}\n\ngoal (1 subgoal):\n 1. x = y", "by(fastforce intro: replicate_FT_hlp)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_simple_match_to_of_match_portlist_hlp: \n  fixes ps :: \"(16 word \\<times> 16 word)\"\n  shows \"distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = max_word then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ (pfxm_mask pfx))))\n                 (wordinterval_CIDR_split_prefixmatch (WordInterval (fst ps) (snd ps)))\n           else [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "assume di: \"distinct ifs\""], ["proof (state)\nthis:\n  distinct ifs\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "{"], ["proof (state)\nthis:\n  distinct ifs\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "define wis where \"wis = set (wordinterval_CIDR_split_prefixmatch (WordInterval (fst ps) (snd ps)))\""], ["proof (state)\nthis:\n  wis =\n  set (wordinterval_CIDR_split_prefixmatch (WordInterval (fst ps) (snd ps)))\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "fix x y :: \"16 prefix_match\""], ["proof (state)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "obtain xm xn ym yn where xyd[simp]: \"x = PrefixMatch xm xn\" \"y = PrefixMatch ym yn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xm xn ym yn.\n        \\<lbrakk>x = PrefixMatch xm xn; y = PrefixMatch ym yn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x; cases y)"], ["proof (state)\nthis:\n  x = PrefixMatch xm xn\n  y = PrefixMatch ym yn\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "assume iw: \"x \\<in> wis\" \"y \\<in> wis\" and et: \"(pfxm_prefix x, ~~ (pfxm_mask x)) = (pfxm_prefix y, ~~ (pfxm_mask y))\""], ["proof (state)\nthis:\n  x \\<in> wis\n  y \\<in> wis\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "hence le16: \"xn \\<le> 16\" \"yn \\<le> 16\""], ["proof (prove)\nusing this:\n  x \\<in> wis\n  y \\<in> wis\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n\ngoal (1 subgoal):\n 1. xn \\<le> 16 &&& yn \\<le> 16", "unfolding wis_def"], ["proof (prove)\nusing this:\n  x \\<in> set (wordinterval_CIDR_split_prefixmatch\n                (WordInterval (fst ps) (snd ps)))\n  y \\<in> set (wordinterval_CIDR_split_prefixmatch\n                (WordInterval (fst ps) (snd ps)))\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n\ngoal (1 subgoal):\n 1. xn \\<le> 16 &&& yn \\<le> 16", "using wordinterval_CIDR_split_prefixmatch_all_valid_Ball[unfolded Ball_def, THEN spec, THEN mp]"], ["proof (prove)\nusing this:\n  x \\<in> set (wordinterval_CIDR_split_prefixmatch\n                (WordInterval (fst ps) (snd ps)))\n  y \\<in> set (wordinterval_CIDR_split_prefixmatch\n                (WordInterval (fst ps) (snd ps)))\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n  ?x1 \\<in> set (wordinterval_CIDR_split_prefixmatch ?r2) \\<Longrightarrow>\n  valid_prefix ?x1 \\<and> pfxm_length ?x1 \\<le> LENGTH(?'a2)\n\ngoal (1 subgoal):\n 1. xn \\<le> 16 &&& yn \\<le> 16", "by force+"], ["proof (state)\nthis:\n  xn \\<le> 16\n  yn \\<le> 16\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "with et"], ["proof (chain)\npicking this:\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n  xn \\<le> 16\n  yn \\<le> 16", "have \"16 - xn = 16 - yn\""], ["proof (prove)\nusing this:\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n  xn \\<le> 16\n  yn \\<le> 16\n\ngoal (1 subgoal):\n 1. 16 - xn = 16 - yn", "unfolding pfxm_mask_def"], ["proof (prove)\nusing this:\n  (pfxm_prefix x, ~~ mask (LENGTH(16) - pfxm_length x)) =\n  (pfxm_prefix y, ~~ mask (LENGTH(16) - pfxm_length y))\n  xn \\<le> 16\n  yn \\<le> 16\n\ngoal (1 subgoal):\n 1. 16 - xn = 16 - yn", "by(auto intro: mask_inj_hlp1[THEN inj_onD])"], ["proof (state)\nthis:\n  16 - xn = 16 - yn\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "hence \"x = y\""], ["proof (prove)\nusing this:\n  16 - xn = 16 - yn\n\ngoal (1 subgoal):\n 1. x = y", "using et le16"], ["proof (prove)\nusing this:\n  16 - xn = 16 - yn\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n  xn \\<le> 16\n  yn \\<le> 16\n\ngoal (1 subgoal):\n 1. x = y", "using diff_diff_cancel"], ["proof (prove)\nusing this:\n  16 - xn = 16 - yn\n  (pfxm_prefix x, ~~ pfxm_mask x) = (pfxm_prefix y, ~~ pfxm_mask y)\n  xn \\<le> 16\n  yn \\<le> 16\n  ?i \\<le> ?n \\<Longrightarrow> ?n - (?n - ?i) = ?i\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2\n           \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval (fst ps) (snd ps)));\n   ?y2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (WordInterval (fst ps) (snd ps)));\n   (pfxm_prefix ?x2, ~~ pfxm_mask ?x2) =\n   (pfxm_prefix ?y2, ~~ pfxm_mask ?y2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 = ?y2\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2\n           \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval (fst ps) (snd ps)));\n   ?y2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (WordInterval (fst ps) (snd ps)));\n   (pfxm_prefix ?x2, ~~ pfxm_mask ?x2) =\n   (pfxm_prefix ?y2, ~~ pfxm_mask ?y2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 = ?y2\n\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n      else if fst ps \\<le> snd ps\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst ps) (snd ps)))\n           else [])", "apply(clarsimp simp add: smtoms_eq_hlp distinct_map wordinterval_CIDR_split_distinct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst ps \\<le> snd ps;\n     fst ps = 0 \\<longrightarrow> snd ps \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> inj_on\n                       (Some \\<circ>\n                        (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                       (set (wordinterval_CIDR_split_prefixmatch\n                              (WordInterval (fst ps) (snd ps))))", "apply(subst comp_inj_on_iff[symmetric]; intro inj_onI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>fst ps \\<le> snd ps;\n        fst ps = 0 \\<longrightarrow> snd ps \\<noteq> - 1;\n        x \\<in> set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        y \\<in> set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        (pfxm_prefix x, ~~ pfxm_mask x) =\n        (pfxm_prefix y, ~~ pfxm_mask y)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>fst ps \\<le> snd ps;\n        fst ps = 0 \\<longrightarrow> snd ps \\<noteq> - 1;\n        x \\<in> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)) `\n                set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        y \\<in> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)) `\n                set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        Some x = Some y\\<rbrakk>\n       \\<Longrightarrow> x = y", "using *"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2\n           \\<in> set (wordinterval_CIDR_split_prefixmatch\n                       (WordInterval (fst ps) (snd ps)));\n   ?y2\n   \\<in> set (wordinterval_CIDR_split_prefixmatch\n               (WordInterval (fst ps) (snd ps)));\n   (pfxm_prefix ?x2, ~~ pfxm_mask ?x2) =\n   (pfxm_prefix ?y2, ~~ pfxm_mask ?y2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 = ?y2\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>fst ps \\<le> snd ps;\n        fst ps = 0 \\<longrightarrow> snd ps \\<noteq> - 1;\n        x \\<in> set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        y \\<in> set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        (pfxm_prefix x, ~~ pfxm_mask x) =\n        (pfxm_prefix y, ~~ pfxm_mask y)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       \\<lbrakk>fst ps \\<le> snd ps;\n        fst ps = 0 \\<longrightarrow> snd ps \\<noteq> - 1;\n        x \\<in> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)) `\n                set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        y \\<in> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)) `\n                set (wordinterval_CIDR_split_prefixmatch\n                      (WordInterval (fst ps) (snd ps)));\n        Some x = Some y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by simp_all"], ["proof (state)\nthis:\n  distinct\n   (if fst ps = 0 \\<and> snd ps = - 1 then [None]\n    else if fst ps \\<le> snd ps\n         then map (Some \\<circ>\n                   (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n               (wordinterval_CIDR_split_prefixmatch\n                 (WordInterval (fst ps) (snd ps)))\n         else [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_simple_match_to_of_match: \"distinct ifs \\<Longrightarrow> distinct (simple_match_to_of_match m ifs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow> distinct (simple_match_to_of_match m ifs)", "apply(unfold simple_match_to_of_match_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (concat\n       (map (\\<lambda>iif.\n                concat\n                 (map (\\<lambda>sport.\n                          map (simple_match_to_of_match_single m iif\n                                (proto m) sport)\n                           (if fst (dports m) = 0 \\<and>\n                               snd (dports m) = - 1\n                            then [None]\n                            else if fst (dports m) \\<le> snd (dports m)\n                                 then map\n (Some \\<circ> (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n (wordinterval_CIDR_split_prefixmatch\n   (WordInterval (fst (dports m)) (snd (dports m))))\n                                 else []))\n                   (if fst (sports m) = 0 \\<and> snd (sports m) = - 1\n                    then [None]\n                    else if fst (sports m) \\<le> snd (sports m)\n                         then map (Some \\<circ>\n                                   (\\<lambda>pfx.\n (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                               (wordinterval_CIDR_split_prefixmatch\n                                 (WordInterval (fst (sports m))\n                                   (snd (sports m))))\n                         else [])))\n         (if iiface m = ifaceAny then [None]\n          else concat\n                (map (\\<lambda>i.\n                         if match_iface (iiface m) i then [Some i] else [])\n                  ifs))))", "apply(rule distinct_3lcomprI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if iiface m = ifaceAny then [None]\n      else concat\n            (map (\\<lambda>i.\n                     if match_iface (iiface m) i then [Some i] else [])\n              ifs))\n 2. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (sports m) = 0 \\<and> snd (sports m) = - 1 then [None]\n      else if fst (sports m) \\<le> snd (sports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (sports m)) (snd (sports m))))\n           else [])\n 3. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n      else if fst (dports m) \\<le> snd (dports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (dports m)) (snd (dports m))))\n           else [])\n 4. \\<And>iif sport c e i g.\n       \\<lbrakk>distinct ifs;\n        simple_match_to_of_match_single m iif (proto m) sport c =\n        simple_match_to_of_match_single m e (proto m) i g\\<rbrakk>\n       \\<Longrightarrow> iif = e \\<and> sport = i \\<and> c = g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if iiface m = ifaceAny then [None]\n      else concat\n            (map (\\<lambda>i.\n                     if match_iface (iiface m) i then [Some i] else [])\n              ifs))", "by(induction ifs; clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (sports m) = 0 \\<and> snd (sports m) = - 1 then [None]\n      else if fst (sports m) \\<le> snd (sports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (sports m)) (snd (sports m))))\n           else [])\n 2. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n      else if fst (dports m) \\<le> snd (dports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (dports m)) (snd (dports m))))\n           else [])\n 3. \\<And>iif sport c e i g.\n       \\<lbrakk>distinct ifs;\n        simple_match_to_of_match_single m iif (proto m) sport c =\n        simple_match_to_of_match_single m e (proto m) i g\\<rbrakk>\n       \\<Longrightarrow> iif = e \\<and> sport = i \\<and> c = g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (sports m) = 0 \\<and> snd (sports m) = - 1 then [None]\n      else if fst (sports m) \\<le> snd (sports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (sports m)) (snd (sports m))))\n           else [])", "by(fact distinct_simple_match_to_of_match_portlist_hlp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n      else if fst (dports m) \\<le> snd (dports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (dports m)) (snd (dports m))))\n           else [])\n 2. \\<And>iif sport c e i g.\n       \\<lbrakk>distinct ifs;\n        simple_match_to_of_match_single m iif (proto m) sport c =\n        simple_match_to_of_match_single m e (proto m) i g\\<rbrakk>\n       \\<Longrightarrow> iif = e \\<and> sport = i \\<and> c = g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ifs \\<Longrightarrow>\n    distinct\n     (if fst (dports m) = 0 \\<and> snd (dports m) = - 1 then [None]\n      else if fst (dports m) \\<le> snd (dports m)\n           then map (Some \\<circ>\n                     (\\<lambda>pfx. (pfxm_prefix pfx, ~~ pfxm_mask pfx)))\n                 (wordinterval_CIDR_split_prefixmatch\n                   (WordInterval (fst (dports m)) (snd (dports m))))\n           else [])", "by(fact distinct_simple_match_to_of_match_portlist_hlp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iif sport c e i g.\n       \\<lbrakk>distinct ifs;\n        simple_match_to_of_match_single m iif (proto m) sport c =\n        simple_match_to_of_match_single m e (proto m) i g\\<rbrakk>\n       \\<Longrightarrow> iif = e \\<and> sport = i \\<and> c = g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct ifs;\n     simple_match_to_of_match_single m iif_ (proto m) sport_ c_ =\n     simple_match_to_of_match_single m e_ (proto m) i_ g_\\<rbrakk>\n    \\<Longrightarrow> iif_ = e_ \\<and> sport_ = i_ \\<and> c_ = g_", "by(simp_all add: smtoms_eq_hlp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inj_inj_on: \"inj F \\<Longrightarrow> inj_on F A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj F \\<Longrightarrow> inj_on F A", "using subset_inj_on"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj F \\<Longrightarrow> inj_on F A", "by auto"], ["", "(* TODO: include Word_Lib *)"], ["", "lemma no_overlaps_lroft_hlp2: \"distinct (map fst amr) \\<Longrightarrow> (\\<And>r. distinct (fm r)) \\<Longrightarrow>\n    distinct (concat (map (\\<lambda>(p, r, c, a). map (\\<lambda>b. (p, b, fs a c)) (fm r)) amr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); \\<And>r. distinct (fm r)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (concat\n                         (map (\\<lambda>(p, r, c, a).\n                                  map (\\<lambda>b. (p, b, fs a c)) (fm r))\n                           amr))", "by(induction amr; force intro: injI inj_onI simp add: distinct_map split: prod.splits)"], ["", "lemma distinct_lroft_s3: \"\\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk> \\<Longrightarrow> distinct (lr_of_tran_s3 ifs amr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> distinct (lr_of_tran_s3 ifs amr)", "unfolding lr_of_tran_s3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (concat\n                         (map (\\<lambda>(p, r, c, a).\n                                  map (\\<lambda>b.\n    (p, b,\n     case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                   (simple_match_to_of_match r ifs))\n                           amr))", "by(erule no_overlaps_lroft_hlp2, simp add: distinct_simple_match_to_of_match)"], ["", "lemma no_overlaps_lroft_hlp3: \"distinct (map fst amr) \\<Longrightarrow>\n(aa, ab, ac) \\<in> set (lr_of_tran_s3 ifs amr) \\<Longrightarrow> (ba, bb, bc) \\<in> set (lr_of_tran_s3 ifs amr) \\<Longrightarrow>\nac \\<noteq> bc \\<Longrightarrow> aa \\<noteq> ba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr);\n     (aa, ab, ac) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ba, bb, bc) \\<in> set (lr_of_tran_s3 ifs amr); ac \\<noteq> bc\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> ba", "apply(unfold lr_of_tran_s3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr);\n     (aa, ab, ac)\n     \\<in> set (concat\n                 (map (\\<lambda>(p, r, c, a).\n                          map (\\<lambda>b.\n                                  (p, b,\n                                   case a of\n                                   Accept \\<Rightarrow> [Forward c]\n                                   | Drop \\<Rightarrow> []))\n                           (simple_match_to_of_match r ifs))\n                   amr));\n     (ba, bb, bc)\n     \\<in> set (concat\n                 (map (\\<lambda>(p, r, c, a).\n                          map (\\<lambda>b.\n                                  (p, b,\n                                   case a of\n                                   Accept \\<Rightarrow> [Forward c]\n                                   | Drop \\<Rightarrow> []))\n                           (simple_match_to_of_match r ifs))\n                   amr));\n     ac \\<noteq> bc\\<rbrakk>\n    \\<Longrightarrow> aa \\<noteq> ba", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aaa aba b ad ae baa.\n       \\<lbrakk>distinct (map fst amr);\n        (case b of Accept \\<Rightarrow> [Forward aba]\n         | Drop \\<Rightarrow> []) \\<noteq>\n        (case baa of Accept \\<Rightarrow> [Forward ae]\n         | Drop \\<Rightarrow> []);\n        (ba, aaa, aba, b) \\<in> set amr; (ba, ad, ae, baa) \\<in> set amr;\n        ab \\<in> set (simple_match_to_of_match aaa ifs);\n        bb \\<in> set (simple_match_to_of_match ad ifs);\n        ac =\n        (case b of Accept \\<Rightarrow> [Forward aba]\n         | Drop \\<Rightarrow> []);\n        bc =\n        (case baa of Accept \\<Rightarrow> [Forward ae]\n         | Drop \\<Rightarrow> []);\n        aa = ba\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarsimp split: simple_action.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aaa aba ad ae.\n       \\<lbrakk>bc = [Forward ae]; aa = ba; distinct (map fst amr);\n        aba \\<noteq> ae; (ba, aaa, aba, Accept) \\<in> set amr;\n        (ba, ad, ae, Accept) \\<in> set amr;\n        ab \\<in> set (simple_match_to_of_match aaa ifs);\n        bb \\<in> set (simple_match_to_of_match ad ifs);\n        ac = [Forward aba]\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aaa aba ad ae.\n       \\<lbrakk>bc = [Forward ae]; aa = ba; distinct (map fst amr);\n        (ba, aaa, aba, Drop) \\<in> set amr;\n        (ba, ad, ae, Accept) \\<in> set amr;\n        ab \\<in> set (simple_match_to_of_match aaa ifs);\n        bb \\<in> set (simple_match_to_of_match ad ifs); ac = []\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>aaa aba ad ae.\n       \\<lbrakk>bc = []; aa = ba; distinct (map fst amr);\n        (ba, aaa, aba, Accept) \\<in> set amr;\n        (ba, ad, ae, Drop) \\<in> set amr;\n        ab \\<in> set (simple_match_to_of_match aaa ifs);\n        bb \\<in> set (simple_match_to_of_match ad ifs);\n        ac = [Forward aba]\\<rbrakk>\n       \\<Longrightarrow> False", "apply(metis map_of_eq_Some_iff old.prod.inject option.inject)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aaa aba ad ae.\n       \\<lbrakk>bc = [Forward ae]; aa = ba; distinct (map fst amr);\n        (ba, aaa, aba, Drop) \\<in> set amr;\n        (ba, ad, ae, Accept) \\<in> set amr;\n        ab \\<in> set (simple_match_to_of_match aaa ifs);\n        bb \\<in> set (simple_match_to_of_match ad ifs); ac = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aaa aba ad ae.\n       \\<lbrakk>bc = []; aa = ba; distinct (map fst amr);\n        (ba, aaa, aba, Accept) \\<in> set amr;\n        (ba, ad, ae, Drop) \\<in> set amr;\n        ab \\<in> set (simple_match_to_of_match aaa ifs);\n        bb \\<in> set (simple_match_to_of_match ad ifs);\n        ac = [Forward aba]\\<rbrakk>\n       \\<Longrightarrow> False", "apply(metis map_of_eq_Some_iff old.prod.inject option.inject simple_action.distinct(2))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_overlaps_lroft_s3_hlp_hlp: (* I hlps *)\n  \"\\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p; ab \\<noteq> ad \\<or> ba \\<noteq> bb; OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr); (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     ab \\<noteq> ad \\<or> ba \\<noteq> bb; OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n    \\<Longrightarrow> False", "proof(elim disjE, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ab \\<noteq> ad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  distinct (map fst amr)\n  OF_match_fields_unsafe ab p\n  OF_match_fields_unsafe ad p\n  (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr)\n  (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\n  ab \\<noteq> ad\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ab \\<noteq> ad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "have 4: \"\\<lbrakk>distinct (map fst amr);  (ac, ab, x1, x2) \\<in> set amr; (ac, bb, x4, x5) \\<in> set amr; ab \\<noteq> bb\\<rbrakk>\n       \\<Longrightarrow> False\" for ab x1 x2 bb x4 x5"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); (ac, ab, x1, x2) \\<in> set amr;\n     (ac, bb, x4, x5) \\<in> set amr; ab \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "by (meson distinct_map_fstD old.prod.inject)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst amr); (ac, ?ab, ?x1.0, ?x2.0) \\<in> set amr;\n   (ac, ?bb, ?x4.0, ?x5.0) \\<in> set amr; ?ab \\<noteq> ?bb\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ab \\<noteq> ad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "have conjunctSomeProtoAnyD: \"Some ProtoAny = simple_proto_conjunct a (Proto b) \\<Longrightarrow> False\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ProtoAny = simple_proto_conjunct a (Proto b) \\<Longrightarrow>\n    False", "using conjunctProtoD"], ["proof (prove)\nusing this:\n  simple_proto_conjunct ?a (Proto ?b) = Some ?x \\<Longrightarrow>\n  ?x = Proto ?b \\<and> (?a = ProtoAny \\<or> ?a = Proto ?b)\n\ngoal (1 subgoal):\n 1. Some ProtoAny = simple_proto_conjunct a (Proto b) \\<Longrightarrow>\n    False", "by force"], ["proof (state)\nthis:\n  Some ProtoAny = simple_proto_conjunct ?a (Proto ?b) \\<Longrightarrow>\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ab \\<noteq> ad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "have 5:\n       \"\\<lbrakk>OF_match_fields_unsafe am p; OF_match_fields_unsafe bm p; am \\<noteq> bm; \n        am \\<in> set (simple_match_to_of_match ab ifs); bm \\<in> set (simple_match_to_of_match bb ifs); \\<not> ab \\<noteq> bb\\<rbrakk>\n       \\<Longrightarrow> False\" for ab bb am bm"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>OF_match_fields_unsafe am p; OF_match_fields_unsafe bm p;\n     am \\<noteq> bm; am \\<in> set (simple_match_to_of_match ab ifs);\n     bm \\<in> set (simple_match_to_of_match bb ifs);\n     \\<not> ab \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "by(clarify | unfold\n         simple_match_to_of_match_def smtoms_eq_hlp Let_def set_concat set_map de_Morgan_conj not_False_eq_True)+\n        (auto dest: conjunctSomeProtoAnyD cidrsplit_no_overlaps\n\t            simp add: OF_match_fields_unsafe_def simple_match_to_of_match_single_def option2set_def comp_def\n\t            split: if_splits\n\t            cong: smtoms_eq_hlp)"], ["proof (state)\nthis:\n  \\<lbrakk>OF_match_fields_unsafe ?am p; OF_match_fields_unsafe ?bm p;\n   ?am \\<noteq> ?bm; ?am \\<in> set (simple_match_to_of_match ?ab ifs);\n   ?bm \\<in> set (simple_match_to_of_match ?bb ifs);\n   \\<not> ?ab \\<noteq> ?bb\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ab \\<noteq> ad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "(*1min*)"], ["proof (state)\nthis:\n  \\<lbrakk>OF_match_fields_unsafe ?am p; OF_match_fields_unsafe ?bm p;\n   ?am \\<noteq> ?bm; ?am \\<in> set (simple_match_to_of_match ?ab ifs);\n   ?bm \\<in> set (simple_match_to_of_match ?bb ifs);\n   \\<not> ?ab \\<noteq> ?bb\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ab \\<noteq> ad\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  distinct (map fst amr)\n  OF_match_fields_unsafe ab p\n  OF_match_fields_unsafe ad p\n  (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr)\n  (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\n  ab \\<noteq> ad", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst amr)\n  OF_match_fields_unsafe ab p\n  OF_match_fields_unsafe ad p\n  (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr)\n  (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\n  ab \\<noteq> ad\n\ngoal (1 subgoal):\n 1. False", "using 4 5"], ["proof (prove)\nusing this:\n  distinct (map fst amr)\n  OF_match_fields_unsafe ab p\n  OF_match_fields_unsafe ad p\n  (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr)\n  (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\n  ab \\<noteq> ad\n  \\<lbrakk>distinct (map fst amr); (ac, ?ab, ?x1.0, ?x2.0) \\<in> set amr;\n   (ac, ?bb, ?x4.0, ?x5.0) \\<in> set amr; ?ab \\<noteq> ?bb\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>OF_match_fields_unsafe ?am p; OF_match_fields_unsafe ?bm p;\n   ?am \\<noteq> ?bm; ?am \\<in> set (simple_match_to_of_match ?ab ifs);\n   ?bm \\<in> set (simple_match_to_of_match ?bb ifs);\n   \\<not> ?ab \\<noteq> ?bb\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by(clarsimp simp add: lr_of_tran_s3_def) blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); OF_match_fields_unsafe ab p;\n     OF_match_fields_unsafe ad p;\n     (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n     (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr); ba \\<noteq> bb\\<rbrakk>\n    \\<Longrightarrow> False", "qed(metis no_overlaps_lroft_hlp3)"], ["", "lemma no_overlaps_lroft_s3_hlp: \"distinct (map fst amr) \\<Longrightarrow> distinct ifs \\<Longrightarrow> \nno_overlaps OF_match_fields_unsafe (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> no_overlaps OF_match_fields_unsafe\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))", "apply(rule no_overlapsI[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))\n 2. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> check_no_overlap OF_match_fields_unsafe\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))", "apply(subst distinct_map, rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> distinct (lr_of_tran_s3 ifs amr)\n 2. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> inj_on (split3 OFEntry) (set (lr_of_tran_s3 ifs amr))\n 3. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> check_no_overlap OF_match_fields_unsafe\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> distinct (lr_of_tran_s3 ifs amr)", "by(erule (1) distinct_lroft_s3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> inj_on (split3 OFEntry) (set (lr_of_tran_s3 ifs amr))\n 2. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> check_no_overlap OF_match_fields_unsafe\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> inj_on (split3 OFEntry) (set (lr_of_tran_s3 ifs amr))", "apply(rule inj_inj_on)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> inj (split3 OFEntry)", "apply(rule injI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>distinct (map fst amr); distinct ifs;\n        split3 OFEntry x = split3 OFEntry y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(rename_tac x y, case_tac x, case_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y a b c aa ba ca.\n       \\<lbrakk>distinct (map fst amr); distinct ifs;\n        split3 OFEntry x = split3 OFEntry y; x = (a, b, c);\n        y = (aa, ba, ca)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply(simp add: split3_def;fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> check_no_overlap OF_match_fields_unsafe\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> check_no_overlap OF_match_fields_unsafe\n                       (map (split3 OFEntry) (lr_of_tran_s3 ifs amr))", "apply(unfold check_no_overlap_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst amr); distinct ifs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set\n(map (split3 OFEntry) (lr_of_tran_s3 ifs amr)).\n                         \\<forall>b\\<in>set\n   (map (split3 OFEntry) (lr_of_tran_s3 ifs amr)).\n                            \\<forall>p\\<in>UNIV.\n                               ofe_prio a = ofe_prio b \\<and>\n                               OF_match_fields_unsafe (ofe_fields a)\n                                p \\<and>\n                               a \\<noteq> b \\<longrightarrow>\n                               \\<not> OF_match_fields_unsafe (ofe_fields b)\n p", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>distinct (map fst amr); distinct ifs;\n        a \\<in> set (map (split3 OFEntry) (lr_of_tran_s3 ifs amr));\n        b \\<in> set (map (split3 OFEntry) (lr_of_tran_s3 ifs amr));\n        p \\<in> UNIV; ofe_prio a = ofe_prio b;\n        OF_match_fields_unsafe (ofe_fields a) p; a \\<noteq> b;\n        OF_match_fields_unsafe (ofe_fields b) p\\<rbrakk>\n       \\<Longrightarrow> False", "apply(unfold set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>distinct (map fst amr); distinct ifs;\n        a \\<in> split3 OFEntry ` set (lr_of_tran_s3 ifs amr);\n        b \\<in> split3 OFEntry ` set (lr_of_tran_s3 ifs amr); p \\<in> UNIV;\n        ofe_prio a = ofe_prio b; OF_match_fields_unsafe (ofe_fields a) p;\n        a \\<noteq> b; OF_match_fields_unsafe (ofe_fields b) p\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct (map fst amr); distinct ifs; p \\<in> UNIV;\n        ofe_prio (split3 OFEntry (aa, ab, ba)) =\n        ofe_prio (split3 OFEntry (ac, ad, bb));\n        OF_match_fields_unsafe (ofe_fields (split3 OFEntry (aa, ab, ba))) p;\n        split3 OFEntry (aa, ab, ba) \\<noteq> split3 OFEntry (ac, ad, bb);\n        OF_match_fields_unsafe (ofe_fields (split3 OFEntry (ac, ad, bb))) p;\n        (aa, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(unfold split3_def prod.simps flow_entry_match.simps flow_entry_match.sel de_Morgan_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct (map fst amr); distinct ifs; p \\<in> UNIV; aa = ac;\n        OF_match_fields_unsafe ab p;\n        aa \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (aa, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(clarsimp simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct (map fst amr); distinct ifs; p \\<in> UNIV;\n        OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(erule (1) no_overlaps_lroft_s3_hlp_hlp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> ab \\<noteq> ?ad12 a b p aa ab ba ac ad bb \\<or>\n                         ?ba12 a b p aa ab ba ac ad bb \\<noteq>\n                         ?bb12 a b p aa ab ba ac ad bb\n 2. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> OF_match_fields_unsafe\n                          (?ad12 a b p aa ab ba ac ad bb) p\n 3. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (?ac12 a b p aa ab ba ac ad bb, ab,\n                          ?ba12 a b p aa ab ba ac ad bb)\n                         \\<in> set (lr_of_tran_s3\n                                     (?ifs12 a b p aa ab ba ac ad bb) amr)\n 4. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (?ac12 a b p aa ab ba ac ad bb,\n                          ?ad12 a b p aa ab ba ac ad bb,\n                          ?bb12 a b p aa ab ba ac ad bb)\n                         \\<in> set (lr_of_tran_s3\n                                     (?ifs12 a b p aa ab ba ac ad bb) amr)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> OF_match_fields_unsafe ad p\n 2. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (?ac12 a b p aa ab ba ac ad bb, ab, ba)\n                         \\<in> set (lr_of_tran_s3\n                                     (?ifs12 a b p aa ab ba ac ad bb) amr)\n 3. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (?ac12 a b p aa ab ba ac ad bb, ad, bb)\n                         \\<in> set (lr_of_tran_s3\n                                     (?ifs12 a b p aa ab ba ac ad bb) amr)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (?ac12 a b p aa ab ba ac ad bb, ab, ba)\n                         \\<in> set (lr_of_tran_s3\n                                     (?ifs12 a b p aa ab ba ac ad bb) amr)\n 2. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (?ac12 a b p aa ab ba ac ad bb, ad, bb)\n                         \\<in> set (lr_of_tran_s3\n                                     (?ifs12 a b p aa ab ba ac ad bb) amr)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b p aa ab ba ac ad bb.\n       \\<lbrakk>distinct ifs; p \\<in> UNIV; OF_match_fields_unsafe ab p;\n        ac \\<noteq> ac \\<or> ab \\<noteq> ad \\<or> ba \\<noteq> bb;\n        OF_match_fields_unsafe ad p;\n        (ac, ab, ba) \\<in> set (lr_of_tran_s3 ifs amr);\n        (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)\\<rbrakk>\n       \\<Longrightarrow> (ac, ad, bb) \\<in> set (lr_of_tran_s3 ifs amr)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lr_of_tran_no_overlaps: assumes \"distinct ifs\" shows \"Inr t = (lr_of_tran rt fw ifs) \\<Longrightarrow> no_overlaps OF_match_fields_unsafe t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr t = lr_of_tran rt fw ifs \\<Longrightarrow>\n    no_overlaps OF_match_fields_unsafe t", "apply(unfold lr_of_tran_def Let_def pack_OF_entries_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr t =\n    (if \\<not> (no_oif_match fw \\<and>\n                has_default_policy fw \\<and>\n                simple_fw_valid fw \\<and>\n                valid_prefixes rt \\<and>\n                has_default_route rt \\<and> distinct ifs)\n     then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n     else if length (lr_of_tran_fbs rt fw ifs) < unat (- 1)\n          then Inr (map (split3 OFEntry)\n                     (lr_of_tran_s3 ifs\n                       (map (apfst word_of_nat)\n                         (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))\n          else Inl ''Error in creating OpenFlow table: priority number space exhausted'') \\<Longrightarrow>\n    no_overlaps OF_match_fields_unsafe t", "apply(simp split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     t =\n     map (split3 OFEntry)\n      (lr_of_tran_s3 ifs\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> no_overlaps OF_match_fields_unsafe\n                       (map (split3 OFEntry)\n                         (lr_of_tran_s3 ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(thin_tac \"t = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs\\<rbrakk>\n    \\<Longrightarrow> no_overlaps OF_match_fields_unsafe\n                       (map (split3 OFEntry)\n                         (lr_of_tran_s3 ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(drule distinct_of_prio_hlp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     distinct\n      (map word_of_nat\n        (map fst (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> no_overlaps OF_match_fields_unsafe\n                       (map (split3 OFEntry)\n                         (lr_of_tran_s3 ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(rule no_overlaps_lroft_s3_hlp[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     distinct\n      (map word_of_nat\n        (map fst (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> distinct ifs\n 2. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     distinct\n      (map word_of_nat\n        (map fst (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map fst\n                         (map (apfst word_of_nat)\n                           (annotate_rlen (lr_of_tran_fbs rt fw ifs))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     distinct\n      (map word_of_nat\n        (map fst (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> distinct ifs", "by(simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     distinct\n      (map word_of_nat\n        (map fst (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map fst\n                         (map (apfst word_of_nat)\n                           (annotate_rlen (lr_of_tran_fbs rt fw ifs))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     distinct\n      (map word_of_nat\n        (map fst (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map fst\n                         (map (apfst word_of_nat)\n                           (annotate_rlen (lr_of_tran_fbs rt fw ifs))))", "by(simp add: o_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_lr_of_tran_s3_hlp: \"\\<forall>x\\<in>set f. fst x \\<le> a \\<Longrightarrow> b \\<in> set (lr_of_tran_s3 s f) \\<Longrightarrow> fst b \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set f. fst x \\<le> a;\n     b \\<in> set (lr_of_tran_s3 s f)\\<rbrakk>\n    \\<Longrightarrow> fst b \\<le> a", "by(auto simp add: lr_of_tran_s3_def)"], ["", "lemma lr_of_tran_s3_Cons: \"lr_of_tran_s3 ifs (a#ard) = (\n\t[(p, b, case a of simple_action.Accept \\<Rightarrow> [Forward c] | simple_action.Drop \\<Rightarrow> []).\n\t\t(p,r,(c,a)) \\<leftarrow> [a], b \\<leftarrow> simple_match_to_of_match r ifs]) @ lr_of_tran_s3 ifs ard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lr_of_tran_s3 ifs (a # ard) =\n    concat\n     (map (\\<lambda>(p, r, c, a).\n              map (\\<lambda>b.\n                      (p, b,\n                       case a of Accept \\<Rightarrow> [Forward c]\n                       | Drop \\<Rightarrow> []))\n               (simple_match_to_of_match r ifs))\n       [a]) @\n    lr_of_tran_s3 ifs ard", "by(clarsimp simp: lr_of_tran_s3_def)"], ["", "lemma sorted_lr_of_tran_s3: \"sorted_descending (map fst f) \\<Longrightarrow> sorted_descending (map fst (lr_of_tran_s3 s f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_descending (map fst f) \\<Longrightarrow>\n    sorted_descending (map fst (lr_of_tran_s3 s f))", "apply(induction f)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sorted_descending (map fst []) \\<Longrightarrow>\n    sorted_descending (map fst (lr_of_tran_s3 s []))\n 2. \\<And>a f.\n       \\<lbrakk>sorted_descending (map fst f) \\<Longrightarrow>\n                sorted_descending (map fst (lr_of_tran_s3 s f));\n        sorted_descending (map fst (a # f))\\<rbrakk>\n       \\<Longrightarrow> sorted_descending\n                          (map fst (lr_of_tran_s3 s (a # f)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_descending (map fst []) \\<Longrightarrow>\n    sorted_descending (map fst (lr_of_tran_s3 s []))", "by(simp add: lr_of_tran_s3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>sorted_descending (map fst f) \\<Longrightarrow>\n                sorted_descending (map fst (lr_of_tran_s3 s f));\n        sorted_descending (map fst (a # f))\\<rbrakk>\n       \\<Longrightarrow> sorted_descending\n                          (map fst (lr_of_tran_s3 s (a # f)))", "apply(clarsimp simp: lr_of_tran_s3_Cons map_concat comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa f.\n       \\<lbrakk>sorted_descending (map fst (lr_of_tran_s3 s f));\n        \\<forall>x\\<in>set f. fst x \\<le> a;\n        sorted_descending (map fst f)\\<rbrakk>\n       \\<Longrightarrow> sorted_descending\n                          (map (\\<lambda>x. a)\n                            (simple_match_to_of_match aa s) @\n                           map fst (lr_of_tran_s3 s f))", "apply(unfold sorted_descending_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa f.\n       \\<lbrakk>sorted_descending (map fst (lr_of_tran_s3 s f));\n        \\<forall>x\\<in>set f. fst x \\<le> a;\n        sorted_descending (map fst f)\\<rbrakk>\n       \\<Longrightarrow> sorted_descending\n                          (map (\\<lambda>x. a)\n                            (simple_match_to_of_match aa s)) \\<and>\n                         sorted_descending\n                          (map fst (lr_of_tran_s3 s f)) \\<and>\n                         (\\<forall>x\\<in>set\n    (map (\\<lambda>x. a) (simple_match_to_of_match aa s)).\n                             \\<forall>y\n\\<in>set (map fst (lr_of_tran_s3 s f)).\n                                y \\<le> x)", "apply(simp add: sorted_descending_alt rev_map sorted_lr_of_tran_s3_hlp sorted_const)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sorted_lr_of_tran_hlp: \"(ofe_prio \\<circ> split3 OFEntry) = fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ofe_prio \\<circ>\\<circ> split3) OFEntry = fst", "by(simp add: fun_eq_iff comp_def split3_def)"], ["", "lemma lr_of_tran_sorted_descending: \"Inr r = lr_of_tran rt fw ifs \\<Longrightarrow> sorted_descending (map ofe_prio r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr r = lr_of_tran rt fw ifs \\<Longrightarrow>\n    sorted_descending (map ofe_prio r)", "apply(unfold lr_of_tran_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr r =\n    (if \\<not> (no_oif_match fw \\<and>\n                has_default_policy fw \\<and>\n                simple_fw_valid fw \\<and>\n                valid_prefixes rt \\<and>\n                has_default_route rt \\<and> distinct ifs)\n     then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n     else if length (lr_of_tran_fbs rt fw ifs) < unat (- 1)\n          then Inr (pack_OF_entries ifs\n                     (map (apfst word_of_nat)\n                       (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n          else Inl ''Error in creating OpenFlow table: priority number space exhausted'') \\<Longrightarrow>\n    sorted_descending (map ofe_prio r)", "apply(simp split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     r =\n     pack_OF_entries ifs\n      (map (apfst word_of_nat)\n        (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\\<rbrakk>\n    \\<Longrightarrow> sorted_descending\n                       (map ofe_prio\n                         (pack_OF_entries ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(thin_tac \"r = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs\\<rbrakk>\n    \\<Longrightarrow> sorted_descending\n                       (map ofe_prio\n                         (pack_OF_entries ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(unfold sorted_lr_of_tran_hlp pack_OF_entries_def split3_def[abs_def] fun_app_def map_map comp_def prod.case_distrib)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs\\<rbrakk>\n    \\<Longrightarrow> sorted_descending\n                       (map (\\<lambda>x.\n                                case x of\n                                (x1, x1a, x2a) \\<Rightarrow>\n                                  ofe_prio (OFEntry x1 x1a x2a))\n                         (lr_of_tran_s3 ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(simp add: fst_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs\\<rbrakk>\n    \\<Longrightarrow> sorted_descending\n                       (map fst\n                         (lr_of_tran_s3 ifs\n                           (map (apfst word_of_nat)\n                             (annotate_rlen (lr_of_tran_fbs rt fw ifs)))))", "apply(rule sorted_lr_of_tran_s3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n     has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs\\<rbrakk>\n    \\<Longrightarrow> sorted_descending\n                       (map fst\n                         (map (apfst word_of_nat)\n                           (annotate_rlen (lr_of_tran_fbs rt fw ifs))))", "apply(drule sorted_annotated[OF less_or_eq_imp_le, OF disjI1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt; valid_prefixes rt; simple_fw_valid fw;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     sorted_descending\n      (map fst\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\\<rbrakk>\n    \\<Longrightarrow> sorted_descending\n                       (map fst\n                         (map (apfst word_of_nat)\n                           (annotate_rlen (lr_of_tran_fbs rt fw ifs))))", "apply(simp add: o_assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lr_of_tran_s1_split: \"lr_of_tran_s1 (a # rt) = (route2match a, output_iface (routing_action a)) # lr_of_tran_s1 rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lr_of_tran_s1 (a # rt) =\n    (route2match a, routing_oiface a) # lr_of_tran_s1 rt", "by(unfold lr_of_tran_s1_def list.map, rule)"], ["", "lemma route2match_correct: \"valid_prefix (routing_match a) \\<Longrightarrow> prefix_match_semantics (routing_match a) (p_dst p) \\<longleftrightarrow> simple_matches (route2match a) (p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefix (routing_match a) \\<Longrightarrow>\n    prefix_match_semantics (routing_match a) (p_dst p) =\n    simple_matches (route2match a) p", "by(simp add: route2match_def simple_matches.simps match_ifaceAny match_iface_refl ipset_from_cidr_0 prefix_match_semantics_ipset_from_netmask2)"], ["", "lemma s1_correct: \"valid_prefixes rt \\<Longrightarrow> has_default_route (rt::('i::len) prefix_routing) \\<Longrightarrow> \n  \\<exists>rm ra. generalized_sfw (lr_of_tran_s1 rt) p = Some (rm,ra) \\<and> ra = output_iface (routing_table_semantics rt (p_dst p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; has_default_route rt\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rm ra.\n                         generalized_sfw (lr_of_tran_s1 rt) p =\n                         Some (rm, ra) \\<and>\n                         ra =\n                         output_iface (routing_table_semantics rt (p_dst p))", "apply(induction rt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_prefixes []; has_default_route []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rm ra.\n                         generalized_sfw (lr_of_tran_s1 []) p =\n                         Some (rm, ra) \\<and>\n                         ra =\n                         output_iface (routing_table_semantics [] (p_dst p))\n 2. \\<And>a rt.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rt; has_default_route rt\\<rbrakk>\n                \\<Longrightarrow> \\<exists>rm ra.\n                                     generalized_sfw (lr_of_tran_s1 rt) p =\n                                     Some (rm, ra) \\<and>\n                                     ra =\n                                     output_iface\n(routing_table_semantics rt (p_dst p));\n        valid_prefixes (a # rt); has_default_route (a # rt)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rm ra.\n                            generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                            Some (rm, ra) \\<and>\n                            ra =\n                            output_iface\n                             (routing_table_semantics (a # rt) (p_dst p))", "apply(simp;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rt.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rt; has_default_route rt\\<rbrakk>\n                \\<Longrightarrow> \\<exists>rm ra.\n                                     generalized_sfw (lr_of_tran_s1 rt) p =\n                                     Some (rm, ra) \\<and>\n                                     ra =\n                                     output_iface\n(routing_table_semantics rt (p_dst p));\n        valid_prefixes (a # rt); has_default_route (a # rt)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rm ra.\n                            generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                            Some (rm, ra) \\<and>\n                            ra =\n                            output_iface\n                             (routing_table_semantics (a # rt) (p_dst p))", "apply(drule valid_prefixes_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rt.\n       \\<lbrakk>\\<lbrakk>valid_prefixes rt; has_default_route rt\\<rbrakk>\n                \\<Longrightarrow> \\<exists>rm ra.\n                                     generalized_sfw (lr_of_tran_s1 rt) p =\n                                     Some (rm, ra) \\<and>\n                                     ra =\n                                     output_iface\n(routing_table_semantics rt (p_dst p));\n        has_default_route (a # rt);\n        valid_prefix (routing_match a) \\<and> valid_prefixes rt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rm ra.\n                            generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                            Some (rm, ra) \\<and>\n                            ra =\n                            output_iface\n                             (routing_table_semantics (a # rt) (p_dst p))", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rt.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        routing_prefix a = 0 \\<or> has_default_route rt;\n        valid_prefix (routing_match a); valid_prefixes rt\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a rt.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        valid_prefix (routing_match a); valid_prefixes rt;\n        routing_prefix a = 0\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))\n 2. \\<And>a rt.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        valid_prefix (routing_match a); valid_prefixes rt;\n        has_default_route rt\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))", "subgoal for a rt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt \\<Longrightarrow>\n             \\<exists>rm.\n                generalized_sfw (lr_of_tran_s1 rt) p =\n                Some\n                 (rm, output_iface (routing_table_semantics rt (p_dst p)));\n     valid_prefix (routing_match a); valid_prefixes rt;\n     routing_prefix a = 0\\<rbrakk>\n    \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                        (p_dst p) \\<longrightarrow>\n                       (\\<exists>rm.\n                           generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                           Some (rm, routing_oiface a))) \\<and>\n                      (\\<not> prefix_match_semantics (routing_match a)\n                               (p_dst p) \\<longrightarrow>\n                       (\\<exists>rm.\n                           generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                           Some\n                            (rm,\n                             output_iface\n                              (routing_table_semantics rt (p_dst p)))))", "apply(case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>routing_matcha metric routing_action.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        valid_prefix (routing_match a); valid_prefixes rt;\n        routing_prefix a = 0;\n        a =\n        \\<lparr>routing_match = routing_matcha, metric = metric,\n           routing_action = routing_action\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))", "apply(rename_tac routing_m metric routing_action)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>routing_m metric routing_action.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        valid_prefix (routing_match a); valid_prefixes rt;\n        routing_prefix a = 0;\n        a =\n        \\<lparr>routing_match = routing_m, metric = metric,\n           routing_action = routing_action\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))", "apply(case_tac routing_m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>routing_m metric routing_action x1 x2.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        valid_prefix (routing_match a); valid_prefixes rt;\n        routing_prefix a = 0;\n        a =\n        \\<lparr>routing_match = routing_m, metric = metric,\n           routing_action = routing_action\\<rparr>;\n        routing_m = PrefixMatch x1 x2\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))", "apply(simp add: valid_prefix_def pfxm_mask_def prefix_match_semantics_def generalized_sfw_def \n\t       lr_of_tran_s1_def route2match_def simple_matches.simps match_ifaceAny match_iface_refl ipset_from_cidr_0\n\t       max_word_mask[where 'a = 'i, symmetric, simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rt.\n       \\<lbrakk>has_default_route rt \\<Longrightarrow>\n                \\<exists>rm.\n                   generalized_sfw (lr_of_tran_s1 rt) p =\n                   Some\n                    (rm,\n                     output_iface (routing_table_semantics rt (p_dst p)));\n        valid_prefix (routing_match a); valid_prefixes rt;\n        has_default_route rt\\<rbrakk>\n       \\<Longrightarrow> (prefix_match_semantics (routing_match a)\n                           (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some (rm, routing_oiface a))) \\<and>\n                         (\\<not> prefix_match_semantics (routing_match a)\n                                  (p_dst p) \\<longrightarrow>\n                          (\\<exists>rm.\n                              generalized_sfw (lr_of_tran_s1 (a # rt)) p =\n                              Some\n                               (rm,\n                                output_iface\n                                 (routing_table_semantics rt (p_dst p)))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt_ \\<Longrightarrow>\n             \\<exists>rm.\n                generalized_sfw (lr_of_tran_s1 rt_) p =\n                Some\n                 (rm, output_iface (routing_table_semantics rt_ (p_dst p)));\n     valid_prefix (routing_match a_); valid_prefixes rt_;\n     has_default_route rt_\\<rbrakk>\n    \\<Longrightarrow> (prefix_match_semantics (routing_match a_)\n                        (p_dst p) \\<longrightarrow>\n                       (\\<exists>rm.\n                           generalized_sfw (lr_of_tran_s1 (a_ # rt_)) p =\n                           Some (rm, routing_oiface a_))) \\<and>\n                      (\\<not> prefix_match_semantics (routing_match a_)\n                               (p_dst p) \\<longrightarrow>\n                       (\\<exists>rm.\n                           generalized_sfw (lr_of_tran_s1 (a_ # rt_)) p =\n                           Some\n                            (rm,\n                             output_iface\n                              (routing_table_semantics rt_ (p_dst p)))))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>has_default_route rt_ \\<Longrightarrow>\n             \\<exists>rm.\n                generalized_sfw (lr_of_tran_s1 rt_) p =\n                Some\n                 (rm, output_iface (routing_table_semantics rt_ (p_dst p)));\n     valid_prefix (routing_match a_); valid_prefixes rt_;\n     has_default_route rt_\\<rbrakk>\n    \\<Longrightarrow> prefix_match_semantics (routing_match a_)\n                       (p_dst p) \\<longrightarrow>\n                      (\\<exists>rm.\n                          generalized_sfw (lr_of_tran_s1 (a_ # rt_)) p =\n                          Some (rm, routing_oiface a_))\n 2. \\<lbrakk>has_default_route rt_ \\<Longrightarrow>\n             \\<exists>rm.\n                generalized_sfw (lr_of_tran_s1 rt_) p =\n                Some\n                 (rm, output_iface (routing_table_semantics rt_ (p_dst p)));\n     valid_prefix (routing_match a_); valid_prefixes rt_;\n     has_default_route rt_\\<rbrakk>\n    \\<Longrightarrow> \\<not> prefix_match_semantics (routing_match a_)\n                              (p_dst p) \\<longrightarrow>\n                      (\\<exists>rm.\n                          generalized_sfw (lr_of_tran_s1 (a_ # rt_)) p =\n                          Some\n                           (rm,\n                            output_iface\n                             (routing_table_semantics rt_ (p_dst p))))", "apply(simp add: generalized_sfw_def lr_of_tran_s1_def route2match_correct;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_default_route rt_ \\<Longrightarrow>\n             \\<exists>rm.\n                generalized_sfw (lr_of_tran_s1 rt_) p =\n                Some\n                 (rm, output_iface (routing_table_semantics rt_ (p_dst p)));\n     valid_prefix (routing_match a_); valid_prefixes rt_;\n     has_default_route rt_\\<rbrakk>\n    \\<Longrightarrow> \\<not> prefix_match_semantics (routing_match a_)\n                              (p_dst p) \\<longrightarrow>\n                      (\\<exists>rm.\n                          generalized_sfw (lr_of_tran_s1 (a_ # rt_)) p =\n                          Some\n                           (rm,\n                            output_iface\n                             (routing_table_semantics rt_ (p_dst p))))", "apply(simp add: route2match_def simple_matches.simps prefix_match_semantics_ipset_from_netmask2 \n                    lr_of_tran_s1_split generalized_sfw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"to_OF_action a \\<equiv> (case a of (p,d) \\<Rightarrow> (case d of simple_action.Accept \\<Rightarrow> [Forward p] | simple_action.Drop \\<Rightarrow> []))\""], ["", "definition \"from_OF_action a = (case a of [] \\<Rightarrow> ('''',simple_action.Drop) | [Forward p] \\<Rightarrow> (p, simple_action.Accept))\""], ["", "lemma OF_match_linear_not_noD: \"OF_match_linear \\<gamma> oms p \\<noteq> NoAction \\<Longrightarrow> \\<exists>ome. ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_match_linear \\<gamma> oms p \\<noteq> NoAction \\<Longrightarrow>\n    \\<exists>ome. ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p", "apply(induction oms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. OF_match_linear \\<gamma> [] p \\<noteq> NoAction \\<Longrightarrow>\n    \\<exists>ome. ome \\<in> set [] \\<and> \\<gamma> (ofe_fields ome) p\n 2. \\<And>a oms.\n       \\<lbrakk>OF_match_linear \\<gamma> oms p \\<noteq>\n                NoAction \\<Longrightarrow>\n                \\<exists>ome.\n                   ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p;\n        OF_match_linear \\<gamma> (a # oms) p \\<noteq> NoAction\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ome.\n                            ome \\<in> set (a # oms) \\<and>\n                            \\<gamma> (ofe_fields ome) p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a oms.\n       \\<lbrakk>OF_match_linear \\<gamma> oms p \\<noteq>\n                NoAction \\<Longrightarrow>\n                \\<exists>ome.\n                   ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p;\n        OF_match_linear \\<gamma> (a # oms) p \\<noteq> NoAction\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ome.\n                            ome \\<in> set (a # oms) \\<and>\n                            \\<gamma> (ofe_fields ome) p", "apply(simp split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a oms.\n       \\<lbrakk>OF_match_linear \\<gamma> oms p \\<noteq>\n                NoAction \\<Longrightarrow>\n                \\<exists>ome.\n                   ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p;\n        \\<gamma> (ofe_fields a) p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ome.\n                            (ome = a \\<or> ome \\<in> set oms) \\<and>\n                            \\<gamma> (ofe_fields ome) p\n 2. \\<And>a oms.\n       \\<lbrakk>\\<exists>ome.\n                   ome \\<in> set oms \\<and> \\<gamma> (ofe_fields ome) p;\n        \\<not> \\<gamma> (ofe_fields a) p;\n        OF_match_linear \\<gamma> oms p \\<noteq> NoAction\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ome.\n                            (ome = a \\<or> ome \\<in> set oms) \\<and>\n                            \\<gamma> (ofe_fields ome) p", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma s3_noaction_hlp: \"\\<lbrakk>simple_match_valid ac; \\<not>simple_matches ac p; match_iface (oiface ac) (p_oiface p)\\<rbrakk> \\<Longrightarrow> \nOF_match_linear OF_match_fields_safe (map (\\<lambda>x. split3 OFEntry (x1, x, case ba of simple_action.Accept \\<Rightarrow> [Forward ad] | simple_action.Drop \\<Rightarrow> [])) (simple_match_to_of_match ac ifs)) p = NoAction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n     match_iface (oiface ac) (p_oiface p)\\<rbrakk>\n    \\<Longrightarrow> OF_match_linear OF_match_fields_safe\n                       (map (\\<lambda>x.\n                                split3 OFEntry\n                                 (x1, x,\n                                  case ba of\n                                  Accept \\<Rightarrow> [Forward ad]\n                                  | Drop \\<Rightarrow> []))\n                         (simple_match_to_of_match ac ifs))\n                       p =\n                      NoAction", "apply(rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n     match_iface (oiface ac) (p_oiface p);\n     OF_match_linear OF_match_fields_safe\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p \\<noteq>\n     NoAction\\<rbrakk>\n    \\<Longrightarrow> False", "apply(drule OF_match_linear_not_noD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n     match_iface (oiface ac) (p_oiface p);\n     \\<exists>ome.\n        ome\n        \\<in> set (map (\\<lambda>x.\n                           split3 OFEntry\n                            (x1, x,\n                             case ba of Accept \\<Rightarrow> [Forward ad]\n                             | Drop \\<Rightarrow> []))\n                    (simple_match_to_of_match ac ifs)) \\<and>\n        OF_match_fields_safe (ofe_fields ome) p\\<rbrakk>\n    \\<Longrightarrow> False", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ome.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        ome \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, ome,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> False", "apply(rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"all_prerequisites x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x", "apply(drule simple_match_to_of_matchD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> OF_match_fields x (?p6 x) = Some True\n 2. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> match_iface (oiface ac) (p_oiface (?p6 x))\n 3. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> simple_match_valid ac\n 4. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x; simple_matches ac (?p6 x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x", "apply(simp add: split3_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p); OF_match_fields_safe x p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> OF_match_fields x (?p6 x) = Some True\n 2. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> match_iface (oiface ac) (p_oiface (?p6 x))\n 3. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> simple_match_valid ac\n 4. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x; simple_matches ac (?p6 x)\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x", "apply(subst(asm) of_match_fields_safe_eq2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>all_prerequisites x; simple_match_valid ac;\n        \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p)\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x\n 2. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields x p = Some True; all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> OF_match_fields x (?p6 x) = Some True\n 3. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> match_iface (oiface ac) (p_oiface (?p6 x))\n 4. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x\\<rbrakk>\n       \\<Longrightarrow> simple_match_valid ac\n 5. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p;\n        all_prerequisites x; simple_matches ac (?p6 x)\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x", "apply(simp;fail)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x", "using simple_match_to_of_match_generates_prereqs"], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_match_valid ?m;\n   ?r \\<in> set (simple_match_to_of_match ?m ?ifs)\\<rbrakk>\n  \\<Longrightarrow> all_prerequisites ?r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>simple_match_valid ac; \\<not> simple_matches ac p;\n        match_iface (oiface ac) (p_oiface p);\n        x \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields_safe\n         (ofe_fields\n           (split3 OFEntry\n             (x1, x,\n              case ba of Accept \\<Rightarrow> [Forward ad]\n              | Drop \\<Rightarrow> [])))\n         p\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites x", "by blast"], ["", "lemma aux:\n  \\<open>v = Some x \\<Longrightarrow> the v = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = Some x \\<Longrightarrow> the v = x", "by simp"], ["", "lemma s3_correct:\n\tassumes vsfwm: \"list_all simple_match_valid (map (fst \\<circ> snd) ard)\"\n\tassumes ippkt: \"p_l2type p = 0x800\"\n\tassumes iiifs: \"p_iiface p \\<in> set ifs\"\n\tassumes oiifs: \"list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\"\n\tshows \"OF_match_linear OF_match_fields_safe (pack_OF_entries ifs ard) p = Action ao \\<longleftrightarrow> (\\<exists>r af. generalized_sfw (map snd ard) p = (Some (r,af)) \\<and> (if snd af = simple_action.Drop then ao = [] else ao = [Forward (fst af)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (OF_match_linear OF_match_fields_safe (pack_OF_entries ifs ard) p =\n     Action ao) =\n    (\\<exists>r af.\n        generalized_sfw (map snd ard) p = Some (r, af) \\<and>\n        (if snd af = Drop then ao = [] else ao = [Forward (fst af)]))", "unfolding pack_OF_entries_def lr_of_tran_s3_def fun_app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (OF_match_linear OF_match_fields_safe\n      (map (split3 OFEntry)\n        (concat\n          (map (\\<lambda>(p, r, c, a).\n                   map (\\<lambda>b.\n                           (p, b,\n                            case a of Accept \\<Rightarrow> [Forward c]\n                            | Drop \\<Rightarrow> []))\n                    (simple_match_to_of_match r ifs))\n            ard)))\n      p =\n     Action ao) =\n    (\\<exists>r af.\n        generalized_sfw (map snd ard) p = Some (r, af) \\<and>\n        (if snd af = Drop then ao = [] else ao = [Forward (fst af)]))", "using vsfwm oiifs"], ["proof (prove)\nusing this:\n  list_all simple_match_valid (map (fst \\<circ> snd) ard)\n  list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\n\ngoal (1 subgoal):\n 1. (OF_match_linear OF_match_fields_safe\n      (map (split3 OFEntry)\n        (concat\n          (map (\\<lambda>(p, r, c, a).\n                   map (\\<lambda>b.\n                           (p, b,\n                            case a of Accept \\<Rightarrow> [Forward c]\n                            | Drop \\<Rightarrow> []))\n                    (simple_match_to_of_match r ifs))\n            ard)))\n      p =\n     Action ao) =\n    (\\<exists>r af.\n        generalized_sfw (map snd ard) p = Some (r, af) \\<and>\n        (if snd af = Drop then ao = [] else ao = [Forward (fst af)]))", "apply(induction ard)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_all simple_match_valid (map (fst \\<circ> snd) []);\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) []\\<rbrakk>\n    \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                        (map (split3 OFEntry)\n                          (concat\n                            (map (\\<lambda>(p, r, c, a).\n                                     map\n(\\<lambda>b.\n    (p, b,\n     case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n(simple_match_to_of_match r ifs))\n                              [])))\n                        p =\n                       Action ao) =\n                      (\\<exists>r af.\n                          generalized_sfw (map snd []) p =\n                          Some (r, af) \\<and>\n                          (if snd af = Drop then ao = []\n                           else ao = [Forward (fst af)]))\n 2. \\<And>a ard.\n       \\<lbrakk>\\<lbrakk>list_all simple_match_valid\n                          (map (fst \\<circ> snd) ard);\n                 list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n                  ard\\<rbrakk>\n                \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                                    (map (split3 OFEntry)\n(concat\n  (map (\\<lambda>(p, r, c, a).\n           map (\\<lambda>b.\n                   (p, b,\n                    case a of Accept \\<Rightarrow> [Forward c]\n                    | Drop \\<Rightarrow> []))\n            (simple_match_to_of_match r ifs))\n    ard)))\n                                    p =\n                                   Action ao) =\n                                  (\\<exists>r af.\ngeneralized_sfw (map snd ard) p = Some (r, af) \\<and>\n(if snd af = Drop then ao = [] else ao = [Forward (fst af)]));\n        list_all simple_match_valid (map (fst \\<circ> snd) (a # ard));\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n         (a # ard)\\<rbrakk>\n       \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 (a # ard))))\n                           p =\n                          Action ao) =\n                         (\\<exists>r af.\n                             generalized_sfw (map snd (a # ard)) p =\n                             Some (r, af) \\<and>\n                             (if snd af = Drop then ao = []\n                              else ao = [Forward (fst af)]))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all simple_match_valid (map (fst \\<circ> snd) []);\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) []\\<rbrakk>\n    \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                        (map (split3 OFEntry)\n                          (concat\n                            (map (\\<lambda>(p, r, c, a).\n                                     map\n(\\<lambda>b.\n    (p, b,\n     case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n(simple_match_to_of_match r ifs))\n                              [])))\n                        p =\n                       Action ao) =\n                      (\\<exists>r af.\n                          generalized_sfw (map snd []) p =\n                          Some (r, af) \\<and>\n                          (if snd af = Drop then ao = []\n                           else ao = [Forward (fst af)]))", "by(simp add: generalized_sfw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ard.\n       \\<lbrakk>\\<lbrakk>list_all simple_match_valid\n                          (map (fst \\<circ> snd) ard);\n                 list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n                  ard\\<rbrakk>\n                \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                                    (map (split3 OFEntry)\n(concat\n  (map (\\<lambda>(p, r, c, a).\n           map (\\<lambda>b.\n                   (p, b,\n                    case a of Accept \\<Rightarrow> [Forward c]\n                    | Drop \\<Rightarrow> []))\n            (simple_match_to_of_match r ifs))\n    ard)))\n                                    p =\n                                   Action ao) =\n                                  (\\<exists>r af.\ngeneralized_sfw (map snd ard) p = Some (r, af) \\<and>\n(if snd af = Drop then ao = [] else ao = [Forward (fst af)]));\n        list_all simple_match_valid (map (fst \\<circ> snd) (a # ard));\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n         (a # ard)\\<rbrakk>\n       \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 (a # ard))))\n                           p =\n                          Action ao) =\n                         (\\<exists>r af.\n                             generalized_sfw (map snd (a # ard)) p =\n                             Some (r, af) \\<and>\n                             (if snd af = Drop then ao = []\n                              else ao = [Forward (fst af)]))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ard.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid (fst (snd a)) \\<and>\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface (fst (snd a)) = ifaceAny \\<and>\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry)\n                             (case a of\n                              (p, r, c, a) \\<Rightarrow>\n                                map (\\<lambda>b.\n  (p, b,\n   case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                 (simple_match_to_of_match r ifs)) @\n                            map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 ard)))\n                           p =\n                          Action ao) =\n                         (\\<exists>r aa b.\n                             (b = Drop \\<longrightarrow>\n                              generalized_sfw (snd a # map snd ard) p =\n                              Some (r, aa, Drop) \\<and>\n                              ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              generalized_sfw (snd a # map snd ard) p =\n                              Some (r, aa, b) \\<and>\n                              ao = [Forward aa]))", "apply(clarsimp simp add: generalized_sfw_simps split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ard x1 ac ad ba.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> (simple_matches ac p \\<longrightarrow>\n                          (OF_match_linear OF_match_fields_safe\n                            (map (split3 OFEntry \\<circ>\n                                  (\\<lambda>b.\n(x1, b,\n case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                              (simple_match_to_of_match ac ifs) @\n                             map (split3 OFEntry)\n                              (concat\n                                (map (\\<lambda>(p, r, c, a).\n   map (\\<lambda>b.\n           (p, b,\n            case a of Accept \\<Rightarrow> [Forward c]\n            | Drop \\<Rightarrow> []))\n    (simple_match_to_of_match r ifs))\n                                  ard)))\n                            p =\n                           Action ao) =\n                          (\\<exists>r a b.\n                              (b = Drop \\<longrightarrow>\n                               ac = r \\<and>\n                               ad = a \\<and>\n                               ba = Drop \\<and> ao = []) \\<and>\n                              (b \\<noteq> Drop \\<longrightarrow>\n                               ac = r \\<and>\n                               ad = a \\<and>\n                               ba = b \\<and> ao = [Forward a]))) \\<and>\n                         (\\<not> simple_matches ac p \\<longrightarrow>\n                          (OF_match_linear OF_match_fields_safe\n                            (map (split3 OFEntry \\<circ>\n                                  (\\<lambda>b.\n(x1, b,\n case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                              (simple_match_to_of_match ac ifs) @\n                             map (split3 OFEntry)\n                              (concat\n                                (map (\\<lambda>(p, r, c, a).\n   map (\\<lambda>b.\n           (p, b,\n            case a of Accept \\<Rightarrow> [Forward c]\n            | Drop \\<Rightarrow> []))\n    (simple_match_to_of_match r ifs))\n                                  ard)))\n                            p =\n                           Action ao) =\n                          (\\<exists>r a b.\n                              (b = Drop \\<longrightarrow>\n                               generalized_sfw (map snd ard) p =\n                               Some (r, a, Drop) \\<and>\n                               ao = []) \\<and>\n                              (b \\<noteq> Drop \\<longrightarrow>\n                               generalized_sfw (map snd ard) p =\n                               Some (r, a, b) \\<and>\n                               ao = [Forward a])))", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ard x1 ac ad ba.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> simple_matches ac p \\<longrightarrow>\n                         (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry \\<circ>\n                                 (\\<lambda>b.\n                                     (x1, b,\ncase ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                             (simple_match_to_of_match ac ifs) @\n                            map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 ard)))\n                           p =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))\n 2. \\<And>ard x1 ac ad ba.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_matches ac p \\<longrightarrow>\n                         (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry \\<circ>\n                                 (\\<lambda>b.\n                                     (x1, b,\ncase ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                             (simple_match_to_of_match ac ifs) @\n                            map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 ard)))\n                           p =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              generalized_sfw (map snd ard) p =\n                              Some (r, a, Drop) \\<and>\n                              ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              generalized_sfw (map snd ard) p =\n                              Some (r, a, b) \\<and>\n                              ao = [Forward a]))", "(* make two subgoals from one *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ard x1 ac ad ba.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> simple_matches ac p \\<longrightarrow>\n                         (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry \\<circ>\n                                 (\\<lambda>b.\n                                     (x1, b,\ncase ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                             (simple_match_to_of_match ac ifs) @\n                            map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 ard)))\n                           p =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))\n 2. \\<And>ard x1 ac ad ba.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_matches ac p \\<longrightarrow>\n                         (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry \\<circ>\n                                 (\\<lambda>b.\n                                     (x1, b,\ncase ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                             (simple_match_to_of_match ac ifs) @\n                            map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 ard)))\n                           p =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              generalized_sfw (map snd ard) p =\n                              Some (r, a, Drop) \\<and>\n                              ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              generalized_sfw (map snd ard) p =\n                              Some (r, a, b) \\<and>\n                              ao = [Forward a]))", "subgoal for ard x1 ac ad ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> simple_matches ac p \\<longrightarrow>\n                      (OF_match_linear OF_match_fields_safe\n                        (map (split3 OFEntry \\<circ>\n                              (\\<lambda>b.\n                                  (x1, b,\n                                   case ba of\n                                   Accept \\<Rightarrow> [Forward ad]\n                                   | Drop \\<Rightarrow> [])))\n                          (simple_match_to_of_match ac ifs) @\n                         map (split3 OFEntry)\n                          (concat\n                            (map (\\<lambda>(p, r, c, a).\n                                     map\n(\\<lambda>b.\n    (p, b,\n     case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n(simple_match_to_of_match r ifs))\n                              ard)))\n                        p =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(clarsimp simp add: OF_match_linear_append split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     simple_matches ac p\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (split3 OFEntry \\<circ>\n                                    (\\<lambda>b.\n  (x1, b,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(drule simple_match_to_of_matchI[rotated])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> p_iiface p \\<in> set ?ifs4\n 2. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> p_l2type p = 2048\n 3. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid ac\n 4. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<exists>gr\\<in>set (simple_match_to_of_match ac ?ifs4).\n        OF_match_fields gr p = Some True\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (split3 OFEntry \\<circ>\n                                    (\\<lambda>b.\n  (x1, b,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(rule iiifs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> p_l2type p = 2048\n 2. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid ac\n 3. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<exists>gr\\<in>set (simple_match_to_of_match ac ifs).\n        OF_match_fields gr p = Some True\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (split3 OFEntry \\<circ>\n                                    (\\<lambda>b.\n  (x1, b,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(rule ippkt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid ac\n 2. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<exists>gr\\<in>set (simple_match_to_of_match ac ifs).\n        OF_match_fields gr p = Some True\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (split3 OFEntry \\<circ>\n                                    (\\<lambda>b.\n  (x1, b,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<exists>gr\\<in>set (simple_match_to_of_match ac ifs).\n        OF_match_fields gr p = Some True\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (split3 OFEntry \\<circ>\n                                    (\\<lambda>b.\n  (x1, b,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           ac = r \\<and>\n                           ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(clarsimp simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        gr \\<in> set (simple_match_to_of_match ac ifs);\n        OF_match_fields gr p = Some True\\<rbrakk>\n       \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                                 (map (\\<lambda>x.\n    split3 OFEntry\n     (x1, x,\n      case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                   (simple_match_to_of_match ac ifs))\n                                 p of\n                           Action a \\<Rightarrow> Action a\n                           | NoAction \\<Rightarrow>\n                               OF_match_linear OF_match_fields_safe\n                                (map (split3 OFEntry)\n                                  (concat\n                                    (map\n(\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\nard)))\n                                p\n                           | Undefined \\<Rightarrow> Undefined) =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(drule \n       OF_match_linear_match_allsameaction[where\n         \\<gamma>=OF_match_fields_safe and pri = x1 and\n         oms = \"simple_match_to_of_match ac ifs\" and \n         act = \"case ba of simple_action.Accept \\<Rightarrow> [Forward ad] | simple_action.Drop \\<Rightarrow> []\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True\\<rbrakk>\n       \\<Longrightarrow> OF_match_fields_safe gr (?p12 gr) = True\n 2. \\<And>gr.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear OF_match_fields_safe\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         (?p12 gr) =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> [])\\<rbrakk>\n       \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                                 (map (\\<lambda>x.\n    split3 OFEntry\n     (x1, x,\n      case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                   (simple_match_to_of_match ac ifs))\n                                 p of\n                           Action a \\<Rightarrow> Action a\n                           | NoAction \\<Rightarrow>\n                               OF_match_linear OF_match_fields_safe\n                                (map (split3 OFEntry)\n                                  (concat\n                                    (map\n(\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\nard)))\n                                p\n                           | Undefined \\<Rightarrow> Undefined) =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(unfold OF_match_fields_safe_def comp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True\\<rbrakk>\n       \\<Longrightarrow> the (OF_match_fields gr (?p12 gr)) = True\n 2. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         (?p12 gr) =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> [])\\<rbrakk>\n       \\<Longrightarrow> ((case OF_match_linear\n                                 (\\<lambda>m x. the (OF_match_fields m x))\n                                 (map (\\<lambda>x.\n    split3 OFEntry\n     (x1, x,\n      case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                   (simple_match_to_of_match ac ifs))\n                                 p of\n                           Action a \\<Rightarrow> Action a\n                           | NoAction \\<Rightarrow>\n                               OF_match_linear\n                                (\\<lambda>m x. the (OF_match_fields m x))\n                                (map (split3 OFEntry)\n                                  (concat\n                                    (map\n(\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\nard)))\n                                p\n                           | Undefined \\<Rightarrow> Undefined) =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(erule aux)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> [])\\<rbrakk>\n       \\<Longrightarrow> ((case OF_match_linear\n                                 (\\<lambda>m x. the (OF_match_fields m x))\n                                 (map (\\<lambda>x.\n    split3 OFEntry\n     (x1, x,\n      case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                   (simple_match_to_of_match ac ifs))\n                                 p of\n                           Action a \\<Rightarrow> Action a\n                           | NoAction \\<Rightarrow>\n                               OF_match_linear\n                                (\\<lambda>m x. the (OF_match_fields m x))\n                                (map (split3 OFEntry)\n                                  (concat\n                                    (map\n(\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\nard)))\n                                p\n                           | Undefined \\<Rightarrow> Undefined) =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> [])\\<rbrakk>\n       \\<Longrightarrow> ((case ba of Accept \\<Rightarrow> [Forward ad]\n                           | Drop \\<Rightarrow> []) =\n                          ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              ac = r \\<and>\n                              ad = a \\<and> ba = b \\<and> ao = [Forward a]))", "apply(intro iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        (case ba of Accept \\<Rightarrow> [Forward ad]\n         | Drop \\<Rightarrow> []) =\n        ao\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r a b.\n                            (b = Drop \\<longrightarrow>\n                             ac = r \\<and>\n                             ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                            (b \\<noteq> Drop \\<longrightarrow>\n                             ac = r \\<and>\n                             ad = a \\<and> ba = b \\<and> ao = [Forward a])\n 2. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        \\<exists>r a b.\n           (b = Drop \\<longrightarrow>\n            ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n           (b \\<noteq> Drop \\<longrightarrow>\n            ac = r \\<and>\n            ad = a \\<and> ba = b \\<and> ao = [Forward a])\\<rbrakk>\n       \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                          | Drop \\<Rightarrow> []) =\n                         ao", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     OF_match_fields gr_ p = Some True;\n     OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p =\n     Action\n      (case ba of Accept \\<Rightarrow> [Forward ad]\n       | Drop \\<Rightarrow> []);\n     (case ba of Accept \\<Rightarrow> [Forward ad]\n      | Drop \\<Rightarrow> []) =\n     ao\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r a b.\n                         (b = Drop \\<longrightarrow>\n                          ac = r \\<and>\n                          ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                         (b \\<noteq> Drop \\<longrightarrow>\n                          ac = r \\<and>\n                          ad = a \\<and> ba = b \\<and> ao = [Forward a])", "apply(rule exI[where x = ac])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     OF_match_fields gr_ p = Some True;\n     OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p =\n     Action\n      (case ba of Accept \\<Rightarrow> [Forward ad]\n       | Drop \\<Rightarrow> []);\n     (case ba of Accept \\<Rightarrow> [Forward ad]\n      | Drop \\<Rightarrow> []) =\n     ao\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         (b = Drop \\<longrightarrow>\n                          ac = ac \\<and>\n                          ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n                         (b \\<noteq> Drop \\<longrightarrow>\n                          ac = ac \\<and>\n                          ad = a \\<and> ba = b \\<and> ao = [Forward a])", "apply(rule exI[where x = ad])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     OF_match_fields gr_ p = Some True;\n     OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p =\n     Action\n      (case ba of Accept \\<Rightarrow> [Forward ad]\n       | Drop \\<Rightarrow> []);\n     (case ba of Accept \\<Rightarrow> [Forward ad]\n      | Drop \\<Rightarrow> []) =\n     ao\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b.\n                         (b = Drop \\<longrightarrow>\n                          ac = ac \\<and>\n                          ad = ad \\<and> ba = Drop \\<and> ao = []) \\<and>\n                         (b \\<noteq> Drop \\<longrightarrow>\n                          ac = ac \\<and>\n                          ad = ad \\<and> ba = b \\<and> ao = [Forward ad])", "apply(rule exI[where x = ba])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     OF_match_fields gr_ p = Some True;\n     OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p =\n     Action\n      (case ba of Accept \\<Rightarrow> [Forward ad]\n       | Drop \\<Rightarrow> []);\n     (case ba of Accept \\<Rightarrow> [Forward ad]\n      | Drop \\<Rightarrow> []) =\n     ao\\<rbrakk>\n    \\<Longrightarrow> (ba = Drop \\<longrightarrow>\n                       ac = ac \\<and>\n                       ad = ad \\<and> ba = Drop \\<and> ao = []) \\<and>\n                      (ba \\<noteq> Drop \\<longrightarrow>\n                       ac = ac \\<and>\n                       ad = ad \\<and> ba = ba \\<and> ao = [Forward ad])", "apply(clarsimp simp: split3_def split: simple_action.splits flowtable_behavior.splits if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gr.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        \\<exists>r a b.\n           (b = Drop \\<longrightarrow>\n            ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n           (b \\<noteq> Drop \\<longrightarrow>\n            ac = r \\<and>\n            ad = a \\<and> ba = b \\<and> ao = [Forward a])\\<rbrakk>\n       \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                          | Drop \\<Rightarrow> []) =\n                         ao", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     OF_match_fields gr_ p = Some True;\n     OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p =\n     Action\n      (case ba of Accept \\<Rightarrow> [Forward ad]\n       | Drop \\<Rightarrow> []);\n     \\<exists>r a b.\n        (b = Drop \\<longrightarrow>\n         ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = []) \\<and>\n        (b \\<noteq> Drop \\<longrightarrow>\n         ac = r \\<and>\n         ad = a \\<and> ba = b \\<and> ao = [Forward a])\\<rbrakk>\n    \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                       | Drop \\<Rightarrow> []) =\n                      ao", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a b.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr_ p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        b = Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = [];\n        b \\<noteq> Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = b \\<and> ao = [Forward a]\\<rbrakk>\n       \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                          | Drop \\<Rightarrow> []) =\n                         ao", "apply(rename_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a b.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr_ p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        b = Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = [];\n        b \\<noteq> Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = b \\<and> ao = [Forward a]\\<rbrakk>\n       \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                          | Drop \\<Rightarrow> []) =\n                         ao", "apply(case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r a b.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr_ p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        b = Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = [];\n        b \\<noteq> Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = b \\<and> ao = [Forward a];\n        b = Accept\\<rbrakk>\n       \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                          | Drop \\<Rightarrow> []) =\n                         ao\n 2. \\<And>r a b.\n       \\<lbrakk>(OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n        OF_match_fields gr_ p = Some True;\n        OF_match_linear (\\<lambda>m x. the (OF_match_fields m x))\n         (map (\\<lambda>x.\n                  split3 OFEntry\n                   (x1, x,\n                    case ba of Accept \\<Rightarrow> [Forward ad]\n                    | Drop \\<Rightarrow> []))\n           (simple_match_to_of_match ac ifs))\n         p =\n        Action\n         (case ba of Accept \\<Rightarrow> [Forward ad]\n          | Drop \\<Rightarrow> []);\n        b = Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = Drop \\<and> ao = [];\n        b \\<noteq> Drop \\<longrightarrow>\n        ac = r \\<and> ad = a \\<and> ba = b \\<and> ao = [Forward a];\n        b = Drop\\<rbrakk>\n       \\<Longrightarrow> (case ba of Accept \\<Rightarrow> [Forward ad]\n                          | Drop \\<Rightarrow> []) =\n                         ao", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ard x1 ac ad ba.\n       \\<lbrakk>(OF_match_linear OF_match_fields_safe\n                  (map (split3 OFEntry)\n                    (concat\n                      (map (\\<lambda>(p, r, c, a).\n                               map (\\<lambda>b.\n (p, b, case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match r ifs))\n                        ard)))\n                  p =\n                 Action ao) =\n                (\\<exists>r a b.\n                    generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                    (if b = Drop then ao = []\n                     else ao = [Forward (fst (a, b))]));\n        simple_match_valid ac;\n        list_all simple_match_valid (map (fst \\<circ> snd) ard);\n        oiface ac = ifaceAny;\n        list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_matches ac p \\<longrightarrow>\n                         (OF_match_linear OF_match_fields_safe\n                           (map (split3 OFEntry \\<circ>\n                                 (\\<lambda>b.\n                                     (x1, b,\ncase ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> [])))\n                             (simple_match_to_of_match ac ifs) @\n                            map (split3 OFEntry)\n                             (concat\n                               (map (\\<lambda>(p, r, c, a).\n  map (\\<lambda>b.\n          (p, b,\n           case a of Accept \\<Rightarrow> [Forward c]\n           | Drop \\<Rightarrow> []))\n   (simple_match_to_of_match r ifs))\n                                 ard)))\n                           p =\n                          Action ao) =\n                         (\\<exists>r a b.\n                             (b = Drop \\<longrightarrow>\n                              generalized_sfw (map snd ard) p =\n                              Some (r, a, Drop) \\<and>\n                              ao = []) \\<and>\n                             (b \\<noteq> Drop \\<longrightarrow>\n                              generalized_sfw (map snd ard) p =\n                              Some (r, a, b) \\<and>\n                              ao = [Forward a]))", "subgoal for ard x1 ac ad ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (fst \\<circ> snd) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> \\<not> simple_matches ac p \\<longrightarrow>\n                      (OF_match_linear OF_match_fields_safe\n                        (map (split3 OFEntry \\<circ>\n                              (\\<lambda>b.\n                                  (x1, b,\n                                   case ba of\n                                   Accept \\<Rightarrow> [Forward ad]\n                                   | Drop \\<Rightarrow> [])))\n                          (simple_match_to_of_match ac ifs) @\n                         map (split3 OFEntry)\n                          (concat\n                            (map (\\<lambda>(p, r, c, a).\n                                     map\n(\\<lambda>b.\n    (p, b,\n     case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n(simple_match_to_of_match r ifs))\n                              ard)))\n                        p =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, Drop) \\<and>\n                           ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, b) \\<and>\n                           ao = [Forward a]))", "apply(simp add: OF_match_linear_append OF_match_fields_safe_def comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard\\<rbrakk>\n    \\<Longrightarrow> \\<not> simple_matches ac p \\<longrightarrow>\n                      ((case OF_match_linear OF_match_fields_safe\n                              (map (\\<lambda>x.\n split3 OFEntry\n  (x1, x,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, Drop) \\<and>\n                           ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, b) \\<and>\n                           ao = [Forward a]))", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<not> simple_matches ac p\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (\\<lambda>x.\n split3 OFEntry\n  (x1, x,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, Drop) \\<and>\n                           ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, b) \\<and>\n                           ao = [Forward a]))", "apply(subgoal_tac \"OF_match_linear OF_match_fields_safe (map (\\<lambda>x. split3 OFEntry (x1, x, case ba of simple_action.Accept \\<Rightarrow> [Forward ad] | simple_action.Drop \\<Rightarrow> [])) (simple_match_to_of_match ac ifs)) p = NoAction\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<not> simple_matches ac p;\n     OF_match_linear OF_match_fields_safe\n      (map (\\<lambda>x.\n               split3 OFEntry\n                (x1, x,\n                 case ba of Accept \\<Rightarrow> [Forward ad]\n                 | Drop \\<Rightarrow> []))\n        (simple_match_to_of_match ac ifs))\n      p =\n     NoAction\\<rbrakk>\n    \\<Longrightarrow> ((case OF_match_linear OF_match_fields_safe\n                              (map (\\<lambda>x.\n split3 OFEntry\n  (x1, x,\n   case ba of Accept \\<Rightarrow> [Forward ad] | Drop \\<Rightarrow> []))\n                                (simple_match_to_of_match ac ifs))\n                              p of\n                        Action a \\<Rightarrow> Action a\n                        | NoAction \\<Rightarrow>\n                            OF_match_linear OF_match_fields_safe\n                             (map (split3 OFEntry)\n                               (concat\n                                 (map (\\<lambda>(p, r, c, a).\n    map (\\<lambda>b.\n            (p, b,\n             case a of Accept \\<Rightarrow> [Forward c]\n             | Drop \\<Rightarrow> []))\n     (simple_match_to_of_match r ifs))\n                                   ard)))\n                             p\n                        | Undefined \\<Rightarrow> Undefined) =\n                       Action ao) =\n                      (\\<exists>r a b.\n                          (b = Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, Drop) \\<and>\n                           ao = []) \\<and>\n                          (b \\<noteq> Drop \\<longrightarrow>\n                           generalized_sfw (map snd ard) p =\n                           Some (r, a, b) \\<and>\n                           ao = [Forward a]))\n 2. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<not> simple_matches ac p\\<rbrakk>\n    \\<Longrightarrow> OF_match_linear OF_match_fields_safe\n                       (map (\\<lambda>x.\n                                split3 OFEntry\n                                 (x1, x,\n                                  case ba of\n                                  Accept \\<Rightarrow> [Forward ad]\n                                  | Drop \\<Rightarrow> []))\n                         (simple_match_to_of_match ac ifs))\n                       p =\n                      NoAction", "apply(simp;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     simple_match_valid ac;\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<not> simple_matches ac p\\<rbrakk>\n    \\<Longrightarrow> OF_match_linear OF_match_fields_safe\n                       (map (\\<lambda>x.\n                                split3 OFEntry\n                                 (x1, x,\n                                  case ba of\n                                  Accept \\<Rightarrow> [Forward ad]\n                                  | Drop \\<Rightarrow> []))\n                         (simple_match_to_of_match ac ifs))\n                       p =\n                      NoAction", "apply(erule (1) s3_noaction_hlp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(OF_match_linear OF_match_fields_safe\n               (map (split3 OFEntry)\n                 (concat\n                   (map (\\<lambda>(p, r, c, a).\n                            map (\\<lambda>b.\n                                    (p, b,\n                                     case a of\n                                     Accept \\<Rightarrow> [Forward c]\n                                     | Drop \\<Rightarrow> []))\n                             (simple_match_to_of_match r ifs))\n                     ard)))\n               p =\n              Action ao) =\n             (\\<exists>r a b.\n                 generalized_sfw (map snd ard) p = Some (r, a, b) \\<and>\n                 (if b = Drop then ao = []\n                  else ao = [Forward (fst (a, b))]));\n     list_all simple_match_valid (map (\\<lambda>x. fst (snd x)) ard);\n     oiface ac = ifaceAny;\n     list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ard;\n     \\<not> simple_matches ac p\\<rbrakk>\n    \\<Longrightarrow> match_iface (oiface ac) (p_oiface p)", "apply(simp add: match_ifaceAny;fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  notes valid_prefix_00[simp, intro!]\nbegin"], ["", "lemma lr_of_tran_s1_valid: \"valid_prefixes rt \\<Longrightarrow> gsfw_valid (lr_of_tran_s1 rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefixes rt \\<Longrightarrow> gsfw_valid (lr_of_tran_s1 rt)", "unfolding lr_of_tran_s1_def route2match_def gsfw_valid_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_prefixes rt \\<Longrightarrow>\n    Ball\n     (set (map (\\<lambda>r.\n                   (\\<lparr>iiface = ifaceAny, oiface = ifaceAny,\n                       src = (0, 0),\n                       dst =\n                         (pfxm_prefix (routing_match r), routing_prefix r),\n                       proto = ProtoAny, sports = (0, - 1),\n                       dports = (0, - 1)\\<rparr>,\n                    routing_oiface r))\n            rt))\n     (simple_match_valid \\<circ> fst)", "apply(clarsimp simp: simple_match_valid_def valid_prefix_fw_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>valid_prefixes rt; x \\<in> set rt\\<rbrakk>\n       \\<Longrightarrow> Collect (simple_match_port (0, - 1)) = UNIV \\<and>\n                         valid_prefix (routing_match x)", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>valid_prefixes rt; x \\<in> set rt\\<rbrakk>\n       \\<Longrightarrow> Collect (simple_match_port (0, - 1)) = UNIV\n 2. \\<And>x.\n       \\<lbrakk>valid_prefixes rt; x \\<in> set rt\\<rbrakk>\n       \\<Longrightarrow> valid_prefix (routing_match x)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>valid_prefixes rt; x \\<in> set rt\\<rbrakk>\n       \\<Longrightarrow> valid_prefix (routing_match x)", "apply(simp add: valid_prefixes_alt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma simple_match_valid_fbs_rlen: \"\\<lbrakk>valid_prefixes rt; simple_fw_valid fw; (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk> \\<Longrightarrow> simple_match_valid aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "case 1"], ["proof (state)\nthis:\n  valid_prefixes rt\n  simple_fw_valid fw\n  (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "note 1[unfolded lr_of_tran_fbs_def Let_def]"], ["proof (state)\nthis:\n  valid_prefixes rt\n  simple_fw_valid fw\n  (a, aa, ab, b)\n  \\<in> set (annotate_rlen\n              (generalized_fw_join (lr_of_tran_s1 rt)\n                (map simple_rule_dtor fw)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "have \"gsfw_valid (map simple_rule_dtor fw)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsfw_valid (map simple_rule_dtor fw)", "using gsfw_validI 1"], ["proof (prove)\nusing this:\n  simple_fw_valid ?fw \\<Longrightarrow>\n  gsfw_valid (map simple_rule_dtor ?fw)\n  valid_prefixes rt\n  simple_fw_valid fw\n  (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\n\ngoal (1 subgoal):\n 1. gsfw_valid (map simple_rule_dtor fw)", "by blast"], ["proof (state)\nthis:\n  gsfw_valid (map simple_rule_dtor fw)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "moreover"], ["proof (state)\nthis:\n  gsfw_valid (map simple_rule_dtor fw)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "have \"gsfw_valid (lr_of_tran_s1 rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsfw_valid (lr_of_tran_s1 rt)", "using 1 lr_of_tran_s1_valid"], ["proof (prove)\nusing this:\n  valid_prefixes rt\n  simple_fw_valid fw\n  (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\n  valid_prefixes ?rt \\<Longrightarrow> gsfw_valid (lr_of_tran_s1 ?rt)\n\ngoal (1 subgoal):\n 1. gsfw_valid (lr_of_tran_s1 rt)", "by blast"], ["proof (state)\nthis:\n  gsfw_valid (lr_of_tran_s1 rt)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "ultimately"], ["proof (chain)\npicking this:\n  gsfw_valid (map simple_rule_dtor fw)\n  gsfw_valid (lr_of_tran_s1 rt)", "have \"gsfw_valid (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\""], ["proof (prove)\nusing this:\n  gsfw_valid (map simple_rule_dtor fw)\n  gsfw_valid (lr_of_tran_s1 rt)\n\ngoal (1 subgoal):\n 1. gsfw_valid\n     (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))", "using gsfw_join_valid"], ["proof (prove)\nusing this:\n  gsfw_valid (map simple_rule_dtor fw)\n  gsfw_valid (lr_of_tran_s1 rt)\n  \\<lbrakk>gsfw_valid ?f1.0; gsfw_valid ?f2.0\\<rbrakk>\n  \\<Longrightarrow> gsfw_valid (generalized_fw_join ?f1.0 ?f2.0)\n\ngoal (1 subgoal):\n 1. gsfw_valid\n     (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))", "by blast"], ["proof (state)\nthis:\n  gsfw_valid\n   (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "moreover"], ["proof (state)\nthis:\n  gsfw_valid\n   (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "have \"(aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)", "using 1"], ["proof (prove)\nusing this:\n  valid_prefixes rt\n  simple_fw_valid fw\n  (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\n\ngoal (1 subgoal):\n 1. (aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)", "using in_annotate_rlen"], ["proof (prove)\nusing this:\n  valid_prefixes rt\n  simple_fw_valid fw\n  (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\n  (?a, ?x) \\<in> set (annotate_rlen ?l) \\<Longrightarrow> ?x \\<in> set ?l\n\ngoal (1 subgoal):\n 1. (aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)", "by fast"], ["proof (state)\nthis:\n  (aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (a, aa, ab, b)\n     \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs))\\<rbrakk>\n    \\<Longrightarrow> simple_match_valid aa", "ultimately"], ["proof (chain)\npicking this:\n  gsfw_valid\n   (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n  (aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)", "show ?thesis"], ["proof (prove)\nusing this:\n  gsfw_valid\n   (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n  (aa, ab, b) \\<in> set (lr_of_tran_fbs rt fw ifs)\n\ngoal (1 subgoal):\n 1. simple_match_valid aa", "unfolding lr_of_tran_fbs_def Let_def gsfw_valid_def list_all_iff"], ["proof (prove)\nusing this:\n  Ball\n   (set (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw)))\n   (simple_match_valid \\<circ> fst)\n  (aa, ab, b)\n  \\<in> set (generalized_fw_join (lr_of_tran_s1 rt)\n              (map simple_rule_dtor fw))\n\ngoal (1 subgoal):\n 1. simple_match_valid aa", "by fastforce"], ["proof (state)\nthis:\n  simple_match_valid aa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_match_valid_fbs: \"\\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk> \\<Longrightarrow> list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ifs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "case 1"], ["proof (state)\nthis:\n  valid_prefixes rt\n  simple_fw_valid fw\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "note 1[unfolded lr_of_tran_fbs_def Let_def]"], ["proof (state)\nthis:\n  valid_prefixes rt\n  simple_fw_valid fw\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "have \"gsfw_valid (map simple_rule_dtor fw)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsfw_valid (map simple_rule_dtor fw)", "using gsfw_validI 1"], ["proof (prove)\nusing this:\n  simple_fw_valid ?fw \\<Longrightarrow>\n  gsfw_valid (map simple_rule_dtor ?fw)\n  valid_prefixes rt\n  simple_fw_valid fw\n\ngoal (1 subgoal):\n 1. gsfw_valid (map simple_rule_dtor fw)", "by blast"], ["proof (state)\nthis:\n  gsfw_valid (map simple_rule_dtor fw)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "moreover"], ["proof (state)\nthis:\n  gsfw_valid (map simple_rule_dtor fw)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "have \"gsfw_valid (lr_of_tran_s1 rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gsfw_valid (lr_of_tran_s1 rt)", "using 1 lr_of_tran_s1_valid"], ["proof (prove)\nusing this:\n  valid_prefixes rt\n  simple_fw_valid fw\n  valid_prefixes ?rt \\<Longrightarrow> gsfw_valid (lr_of_tran_s1 ?rt)\n\ngoal (1 subgoal):\n 1. gsfw_valid (lr_of_tran_s1 rt)", "by blast"], ["proof (state)\nthis:\n  gsfw_valid (lr_of_tran_s1 rt)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "ultimately"], ["proof (chain)\npicking this:\n  gsfw_valid (map simple_rule_dtor fw)\n  gsfw_valid (lr_of_tran_s1 rt)", "have \"gsfw_valid (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\""], ["proof (prove)\nusing this:\n  gsfw_valid (map simple_rule_dtor fw)\n  gsfw_valid (lr_of_tran_s1 rt)\n\ngoal (1 subgoal):\n 1. gsfw_valid\n     (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))", "using gsfw_join_valid"], ["proof (prove)\nusing this:\n  gsfw_valid (map simple_rule_dtor fw)\n  gsfw_valid (lr_of_tran_s1 rt)\n  \\<lbrakk>gsfw_valid ?f1.0; gsfw_valid ?f2.0\\<rbrakk>\n  \\<Longrightarrow> gsfw_valid (generalized_fw_join ?f1.0 ?f2.0)\n\ngoal (1 subgoal):\n 1. gsfw_valid\n     (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))", "by blast"], ["proof (state)\nthis:\n  gsfw_valid\n   (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw\\<rbrakk>\n    \\<Longrightarrow> list_all simple_match_valid\n                       (map fst (lr_of_tran_fbs rt fw ifs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  gsfw_valid\n   (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n\ngoal (1 subgoal):\n 1. list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ifs))", "unfolding lr_of_tran_fbs_def Let_def gsfw_valid_def list_all_iff"], ["proof (prove)\nusing this:\n  Ball\n   (set (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw)))\n   (simple_match_valid \\<circ> fst)\n\ngoal (1 subgoal):\n 1. Ball\n     (set (map fst\n            (generalized_fw_join (lr_of_tran_s1 rt)\n              (map simple_rule_dtor fw))))\n     simple_match_valid", "by fastforce"], ["proof (state)\nthis:\n  list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ifs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lr_of_tran_prereqs: \"valid_prefixes rt \\<Longrightarrow> simple_fw_valid fw \\<Longrightarrow> lr_of_tran rt fw ifs = Inr oft \\<Longrightarrow>\nlist_all (all_prerequisites \\<circ> ofe_fields) oft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     lr_of_tran rt fw ifs = Inr oft\\<rbrakk>\n    \\<Longrightarrow> list_all (all_prerequisites \\<circ> ofe_fields) oft", "unfolding lr_of_tran_def pack_OF_entries_def lr_of_tran_s3_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     (if \\<not> (no_oif_match fw \\<and>\n                 has_default_policy fw \\<and>\n                 simple_fw_valid fw \\<and>\n                 valid_prefixes rt \\<and>\n                 has_default_route rt \\<and> distinct ifs)\n      then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n      else if length (lr_of_tran_fbs rt fw ifs) < unat (- 1)\n           then Inr (map (split3 OFEntry)\n                      (concat\n                        (map (\\<lambda>(p, r, c, a).\n                                 map (\\<lambda>b.\n   (p, b,\n    case a of Accept \\<Rightarrow> [Forward c] | Drop \\<Rightarrow> []))\n                                  (simple_match_to_of_match r ifs))\n                          (map (apfst word_of_nat)\n                            (annotate_rlen (lr_of_tran_fbs rt fw ifs))))))\n           else Inl ''Error in creating OpenFlow table: priority number space exhausted'') =\n     Inr oft\\<rbrakk>\n    \\<Longrightarrow> list_all (all_prerequisites \\<circ> ofe_fields) oft", "apply(simp add: map_concat comp_def prod.case_distrib split3_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     length (lr_of_tran_fbs rt fw ifs) < unat (- 1); has_default_route rt;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     concat\n      (map (\\<lambda>x.\n               case apfst word_of_nat x of\n               (x1, x1a, x1b, x2) \\<Rightarrow>\n                 map (\\<lambda>x.\n                         OFEntry x1 x\n                          (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                           | Drop \\<Rightarrow> []))\n                  (simple_match_to_of_match x1a ifs))\n        (annotate_rlen (lr_of_tran_fbs rt fw ifs))) =\n     oft\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>x. all_prerequisites (ofe_fields x)) oft", "apply(simp add: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n     length (lr_of_tran_fbs rt fw ifs) < unat (- 1); has_default_route rt;\n     has_default_policy fw; no_oif_match fw; distinct ifs;\n     concat\n      (map (\\<lambda>x.\n               case apfst word_of_nat x of\n               (x1, x1a, x1b, x2) \\<Rightarrow>\n                 map (\\<lambda>x.\n                         OFEntry x1 x\n                          (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                           | Drop \\<Rightarrow> []))\n                  (simple_match_to_of_match x1a ifs))\n        (annotate_rlen (lr_of_tran_fbs rt fw ifs))) =\n     oft\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set oft.\n                         all_prerequisites (ofe_fields x)", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt; simple_fw_valid fw;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs)\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites xa", "apply(drule simple_match_valid_fbs_rlen[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs)\\<rbrakk>\n       \\<Longrightarrow> (?a48 a aa ab b xa, ?aa48 a aa ab b xa,\n                          ?ab48 a aa ab b xa, ?b48 a aa ab b xa)\n                         \\<in> set (annotate_rlen\n                                     (lr_of_tran_fbs (?rt48 a aa ab b xa) fw\n (?ifs48 a aa ab b xa)))\n 2. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs)\\<rbrakk>\n       \\<Longrightarrow> valid_prefixes (?rt48 a aa ab b xa)\n 3. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs);\n        simple_match_valid (?aa48 a aa ab b xa)\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites xa", "apply(simp add: list_all_iff;fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs)\\<rbrakk>\n       \\<Longrightarrow> valid_prefixes rt\n 2. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs);\n        simple_match_valid aa\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites xa", "apply(simp add: list_all_iff;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab b xa.\n       \\<lbrakk>valid_prefixes rt;\n        length (lr_of_tran_fbs rt fw ifs) < unat (- 1);\n        has_default_route rt; has_default_policy fw; no_oif_match fw;\n        distinct ifs;\n        oft =\n        concat\n         (map (\\<lambda>x.\n                  case apfst word_of_nat x of\n                  (x1, x1a, x1b, x2) \\<Rightarrow>\n                    map (\\<lambda>x.\n                            OFEntry x1 x\n                             (case x2 of Accept \\<Rightarrow> [Forward x1b]\n                              | Drop \\<Rightarrow> []))\n                     (simple_match_to_of_match x1a ifs))\n           (annotate_rlen (lr_of_tran_fbs rt fw ifs)));\n        (a, aa, ab, b) \\<in> set (annotate_rlen (lr_of_tran_fbs rt fw ifs));\n        xa \\<in> set (simple_match_to_of_match aa ifs);\n        simple_match_valid aa\\<rbrakk>\n       \\<Longrightarrow> all_prerequisites xa", "apply(rule simple_match_to_of_match_generates_prereqs; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: move. where? *)"], ["", "lemma OF_unsafe_safe_match3_eq: \"\n  list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n  OF_priority_match OF_match_fields_unsafe oft = OF_priority_match OF_match_fields_safe oft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    OF_priority_match OF_match_fields_unsafe oft =\n    OF_priority_match OF_match_fields_safe oft", "unfolding OF_priority_match_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined)))) =\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined))))", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined)))) =\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined))))", "case 1"], ["proof (state)\nthis:\n  list_all (all_prerequisites \\<circ> ofe_fields) oft\n\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined)))) =\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined))))", "from 1"], ["proof (chain)\npicking this:\n  list_all (all_prerequisites \\<circ> ofe_fields) oft", "have \"\\<And>packet. [f\\<leftarrow>oft . OF_match_fields_unsafe (ofe_fields f) packet] = [f\\<leftarrow>oft . OF_match_fields_safe (ofe_fields f) packet]\""], ["proof (prove)\nusing this:\n  list_all (all_prerequisites \\<circ> ofe_fields) oft\n\ngoal (1 subgoal):\n 1. \\<And>packet.\n       filter (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n        oft =\n       filter (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet) oft", "apply(clarsimp simp add: list_all_iff of_match_fields_safe_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>packet.\n       \\<forall>x\\<in>set oft.\n          all_prerequisites (ofe_fields x) \\<Longrightarrow>\n       filter (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n        oft =\n       filter (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet) oft", "using of_match_fields_safe_eq"], ["proof (prove)\nusing this:\n  all_prerequisites ?m \\<Longrightarrow>\n  OF_match_fields_safe ?m = OF_match_fields_unsafe ?m\n\ngoal (1 subgoal):\n 1. \\<And>packet.\n       \\<forall>x\\<in>set oft.\n          all_prerequisites (ofe_fields x) \\<Longrightarrow>\n       filter (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n        oft =\n       filter (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet) oft", "by(metis (mono_tags, lifting) filter_cong)"], ["proof (state)\nthis:\n  filter (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) ?packet) oft =\n  filter (\\<lambda>f. OF_match_fields_safe (ofe_fields f) ?packet) oft\n\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined)))) =\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined))))", "thus ?case"], ["proof (prove)\nusing this:\n  filter (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) ?packet) oft =\n  filter (\\<lambda>f. OF_match_fields_safe (ofe_fields f) ?packet) oft\n\ngoal (1 subgoal):\n 1. (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined)))) =\n    (\\<lambda>packet.\n        let m = filter\n                 (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet)\n                 oft\n        in Let (filter\n                 (\\<lambda>f.\n                     \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n                 m)\n            (case_list NoAction\n              (\\<lambda>s.\n                  case_list (Action (ofe_action s))\n                   (\\<lambda>aa lista. Undefined))))", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>packet.\n      let m = filter\n               (\\<lambda>f. OF_match_fields_unsafe (ofe_fields f) packet)\n               oft\n      in Let (filter\n               (\\<lambda>f.\n                   \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n               m)\n          (case_list NoAction\n            (\\<lambda>s.\n                case_list (Action (ofe_action s))\n                 (\\<lambda>aa lista. Undefined)))) =\n  (\\<lambda>packet.\n      let m = filter\n               (\\<lambda>f. OF_match_fields_safe (ofe_fields f) packet) oft\n      in Let (filter\n               (\\<lambda>f.\n                   \\<forall>fo\\<in>set m. ofe_prio fo \\<le> ofe_prio f)\n               m)\n          (case_list NoAction\n            (\\<lambda>s.\n                case_list (Action (ofe_action s))\n                 (\\<lambda>aa lista. Undefined))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OF_unsafe_safe_match_linear_eq: \"\n  list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n  OF_match_linear OF_match_fields_unsafe oft = OF_match_linear OF_match_fields_safe oft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    OF_match_linear OF_match_fields_unsafe oft =\n    OF_match_linear OF_match_fields_safe oft", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (all_prerequisites \\<circ> ofe_fields) oft \\<Longrightarrow>\n    \\<forall>x.\n       OF_match_linear OF_match_fields_unsafe oft x =\n       OF_match_linear OF_match_fields_safe oft x", "by(induction oft) (clarsimp simp add: list_all_iff of_match_fields_safe_eq)+"], ["", "lemma simple_action_ne[simp]: \n  \"b \\<noteq> simple_action.Accept \\<longleftrightarrow> b = simple_action.Drop\"\n  \"b \\<noteq> simple_action.Drop \\<longleftrightarrow> b = simple_action.Accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<noteq> Accept) = (b = Drop) &&& (b \\<noteq> Drop) = (b = Accept)", "using simple_action.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Accept \\<Longrightarrow> ?P;\n   ?y = Drop \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (b \\<noteq> Accept) = (b = Drop) &&& (b \\<noteq> Drop) = (b = Accept)", "by blast+"], ["", "lemma map_snd_apfst: \"map snd (map (apfst x) l) = map snd l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (map (apfst x) l) = map snd l", "unfolding map_map comp_def snd_apfst"], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd l = map snd l", ".."], ["", "lemma match_ifaceAny_eq: \"oiface m = ifaceAny \\<Longrightarrow> simple_matches m p = simple_matches m (p\\<lparr>p_oiface := any\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oiface m = ifaceAny \\<Longrightarrow>\n    simple_matches m p = simple_matches m (p\\<lparr>p_oiface := any\\<rparr>)", "by(cases m) (simp add: simple_matches.simps match_ifaceAny)"], ["", "lemma no_oif_matchD: \"no_oif_match fw \\<Longrightarrow> simple_fw fw p = simple_fw fw (p\\<lparr>p_oiface := any\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_oif_match fw \\<Longrightarrow>\n    simple_fw fw p = simple_fw fw (p\\<lparr>p_oiface := any\\<rparr>)", "by(induction fw)\n    (auto simp add: no_oif_match_def simple_fw_alt dest: match_ifaceAny_eq)"], ["", "lemma lr_of_tran_fbs_acceptD:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\"\n  shows \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Accept) \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "case 1"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "note 1[unfolded lr_of_tran_fbs_def Let_def, THEN generalized_fw_joinD]"], ["proof (state)\nthis:\n  \\<exists>r1 r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n     Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r1 r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n     Some r = simple_match_and r1 r2", "guess r1"], ["proof (prove)\nusing this:\n  \\<exists>r1 r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n     Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  \\<exists>r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n     Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n     Some r = simple_match_and r1 r2", "guess r2"], ["proof (prove)\nusing this:\n  \\<exists>r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n     Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "note r12 = this"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "note s1_correct[OF s1, of p]"], ["proof (state)\nthis:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))", "guess rm"], ["proof (prove)\nusing this:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))", "guess ra"], ["proof (prove)\nusing this:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "note rmra = this"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "from r12 rmra"], ["proof (chain)\npicking this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))", "have oifra: \"oif = ra\""], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. oif = ra", "by simp"], ["proof (state)\nthis:\n  oif = ra\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "from r12"], ["proof (chain)\npicking this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2", "have sfw: \"simple_fw fw p = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. simple_fw fw p = Decision FinalAllow", "using simple_fw_iff_generalized_fw_accept"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Accept) \\<and>\n  Some r = simple_match_and r1 r2\n  (simple_fw ?fw ?p = Decision FinalAllow) =\n  (\\<exists>r.\n      generalized_sfw (map simple_rule_dtor ?fw) ?p = Some (r, Accept))\n\ngoal (1 subgoal):\n 1. simple_fw fw p = Decision FinalAllow", "by blast"], ["proof (state)\nthis:\n  simple_fw fw p = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "note ifupdateirrel = no_oif_matchD[OF s2, where any = \" output_iface (routing_table_semantics rt (p_dst p))\" and p = p, symmetric]"], ["proof (state)\nthis:\n  simple_fw fw\n   (p\\<lparr>p_oiface :=\n               output_iface\n                (routing_table_semantics rt (p_dst p))\\<rparr>) =\n  simple_fw fw p\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Accept) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "unfolding simple_linux_router_nol12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let rd = routing_table_semantics rt (p_dst p);\n         p = p\\<lparr>p_oiface := output_iface rd\\<rparr>;\n         fd = simple_fw fw p\n     in (case fd of Decision FinalAllow \\<Rightarrow> Some ()\n         | Decision FinalDeny \\<Rightarrow> None) \\<bind>\n        (\\<lambda>_. Some p)) =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "by(simp add: Let_def ifupdateirrel sfw oifra rmra split: Option.bind_splits option.splits)"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lr_of_tran_fbs_acceptI:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\" \"has_default_policy fw\"\n  shows \"simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n  \\<exists>r. generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Accept)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "from s2"], ["proof (chain)\npicking this:\n  no_oif_match fw\n  has_default_policy fw", "have nud: \"\\<And>p. simple_fw fw p \\<noteq> Undecided\""], ["proof (prove)\nusing this:\n  no_oif_match fw\n  has_default_policy fw\n\ngoal (1 subgoal):\n 1. \\<And>p. simple_fw fw p \\<noteq> Undecided", "by (metis has_default_policy state.distinct(1))"], ["proof (state)\nthis:\n  simple_fw fw ?p \\<noteq> Undecided\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "note ifupdateirrel = no_oif_matchD[OF s2(1), symmetric]"], ["proof (state)\nthis:\n  simple_fw fw (?p\\<lparr>p_oiface := ?any\\<rparr>) = simple_fw fw ?p\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "case 1"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "from 1"], ["proof (chain)\npicking this:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)", "have \"simple_fw fw p = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw fw p = Decision FinalAllow", "by(simp add: simple_linux_router_nol12_def Let_def nud ifupdateirrel split: Option.bind_splits state.splits final_decision.splits)"], ["proof (state)\nthis:\n  simple_fw fw p = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "then"], ["proof (chain)\npicking this:\n  simple_fw fw p = Decision FinalAllow", "obtain r where r: \"generalized_sfw (map simple_rule_dtor fw) p = Some (r, simple_action.Accept)\""], ["proof (prove)\nusing this:\n  simple_fw fw p = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        generalized_sfw (map simple_rule_dtor fw) p =\n        Some (r, Accept) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using simple_fw_iff_generalized_fw_accept"], ["proof (prove)\nusing this:\n  simple_fw fw p = Decision FinalAllow\n  (simple_fw ?fw ?p = Decision FinalAllow) =\n  (\\<exists>r.\n      generalized_sfw (map simple_rule_dtor ?fw) ?p = Some (r, Accept))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        generalized_sfw (map simple_rule_dtor fw) p =\n        Some (r, Accept) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r, Accept)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "have oif_def: \"oif = output_iface (routing_table_semantics rt (p_dst p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oif = output_iface (routing_table_semantics rt (p_dst p))", "using 1"], ["proof (prove)\nusing this:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. oif = output_iface (routing_table_semantics rt (p_dst p))", "by(cases p) (simp add: simple_linux_router_nol12_def Let_def nud ifupdateirrel split: Option.bind_splits state.splits final_decision.splits)"], ["proof (state)\nthis:\n  oif = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "note s1_correct[OF s1, of p]"], ["proof (state)\nthis:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "then"], ["proof (chain)\npicking this:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))", "guess rm"], ["proof (prove)\nusing this:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))", "guess ra"], ["proof (prove)\nusing this:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "note rmra = this"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n    \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "unfolding lr_of_tran_fbs_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       generalized_sfw\n        (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n        p =\n       Some (r, oif, Accept)", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. generalized_sfw\n     (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw)) p =\n    Some (?r, oif, Accept)", "apply(rule generalized_fw_joinI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. generalized_sfw (lr_of_tran_s1 rt) p = Some (?r1.2, oif)\n 2. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.2, Accept)", "unfolding oif_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. generalized_sfw (lr_of_tran_s1 rt) p =\n    Some (?r1.2, output_iface (routing_table_semantics rt (p_dst p)))\n 2. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.2, Accept)", "using rmra"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (2 subgoals):\n 1. generalized_sfw (lr_of_tran_s1 rt) p =\n    Some (?r1.2, output_iface (routing_table_semantics rt (p_dst p)))\n 2. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.2, Accept)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.2, Accept)", "apply(rule r)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lr_of_tran_fbs_dropD:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\"\n  shows \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Drop) \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Drop) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Drop) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None", "note ifupdateirrel = no_oif_matchD[OF s2(1), symmetric]"], ["proof (state)\nthis:\n  simple_fw fw (?p\\<lparr>p_oiface := ?any\\<rparr>) = simple_fw fw ?p\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Drop) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None", "case 1"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Drop) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None", "from 1[unfolded lr_of_tran_fbs_def Let_def, THEN generalized_fw_joinD]"], ["proof (chain)\npicking this:\n  \\<exists>r1 r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Drop) \\<and>\n     Some r = simple_match_and r1 r2", "obtain rr fr where \"generalized_sfw (lr_of_tran_s1 rt) p = Some (rr, oif) \\<and>\n          generalized_sfw (map simple_rule_dtor fw) p = Some (fr, simple_action.Drop) \\<and> Some r = simple_match_and rr fr\""], ["proof (prove)\nusing this:\n  \\<exists>r1 r2.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (r1, oif) \\<and>\n     generalized_sfw (map simple_rule_dtor fw) p = Some (r2, Drop) \\<and>\n     Some r = simple_match_and r1 r2\n\ngoal (1 subgoal):\n 1. (\\<And>rr fr.\n        generalized_sfw (lr_of_tran_s1 rt) p = Some (rr, oif) \\<and>\n        generalized_sfw (map simple_rule_dtor fw) p = Some (fr, Drop) \\<and>\n        Some r = simple_match_and rr fr \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by presburger"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rr, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (fr, Drop) \\<and>\n  Some r = simple_match_and rr fr\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Drop) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None", "hence fd: \"\\<And>u. simple_fw fw (p\\<lparr>p_oiface := u\\<rparr>) = Decision FinalDeny\""], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rr, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (fr, Drop) \\<and>\n  Some r = simple_match_and rr fr\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       simple_fw fw (p\\<lparr>p_oiface := u\\<rparr>) = Decision FinalDeny", "unfolding ifupdateirrel"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rr, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (fr, Drop) \\<and>\n  Some r = simple_match_and rr fr\n\ngoal (1 subgoal):\n 1. \\<And>u. simple_fw fw p = Decision FinalDeny", "using simple_fw_iff_generalized_fw_drop"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rr, oif) \\<and>\n  generalized_sfw (map simple_rule_dtor fw) p = Some (fr, Drop) \\<and>\n  Some r = simple_match_and rr fr\n  (simple_fw ?fw ?p = Decision FinalDeny) =\n  (\\<exists>r.\n      generalized_sfw (map simple_rule_dtor ?fw) ?p = Some (r, Drop))\n\ngoal (1 subgoal):\n 1. \\<And>u. simple_fw fw p = Decision FinalDeny", "by blast"], ["proof (state)\nthis:\n  simple_fw fw (p\\<lparr>p_oiface := ?u\\<rparr>) = Decision FinalDeny\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n    Some (r, oif, Drop) \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None", "by(clarsimp simp: simple_linux_router_nol12_def Let_def fd split: Option.bind_splits)"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lr_of_tran_fbs_dropI:\n  assumes s1: \"valid_prefixes rt\" \"has_default_route rt\"\n  assumes s2: \"no_oif_match fw\" \"has_default_policy fw\"\n  shows \"simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n  \\<exists>r oif. generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Drop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "from s2"], ["proof (chain)\npicking this:\n  no_oif_match fw\n  has_default_policy fw", "have nud: \"\\<And>p. simple_fw fw p \\<noteq> Undecided\""], ["proof (prove)\nusing this:\n  no_oif_match fw\n  has_default_policy fw\n\ngoal (1 subgoal):\n 1. \\<And>p. simple_fw fw p \\<noteq> Undecided", "by (metis has_default_policy state.distinct(1))"], ["proof (state)\nthis:\n  simple_fw fw ?p \\<noteq> Undecided\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "note ifupdateirrel = no_oif_matchD[OF s2(1), symmetric]"], ["proof (state)\nthis:\n  simple_fw fw (?p\\<lparr>p_oiface := ?any\\<rparr>) = simple_fw fw ?p\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "case 1"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "from 1"], ["proof (chain)\npicking this:\n  simple_linux_router_nol12 rt fw p = None", "have \"simple_fw fw p = Decision FinalDeny\""], ["proof (prove)\nusing this:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal (1 subgoal):\n 1. simple_fw fw p = Decision FinalDeny", "by(simp add: simple_linux_router_nol12_def Let_def nud ifupdateirrel split: Option.bind_splits state.splits final_decision.splits)"], ["proof (state)\nthis:\n  simple_fw fw p = Decision FinalDeny\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "then"], ["proof (chain)\npicking this:\n  simple_fw fw p = Decision FinalDeny", "obtain r where r: \"generalized_sfw (map simple_rule_dtor fw) p = Some (r, simple_action.Drop)\""], ["proof (prove)\nusing this:\n  simple_fw fw p = Decision FinalDeny\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        generalized_sfw (map simple_rule_dtor fw) p =\n        Some (r, Drop) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using simple_fw_iff_generalized_fw_drop"], ["proof (prove)\nusing this:\n  simple_fw fw p = Decision FinalDeny\n  (simple_fw ?fw ?p = Decision FinalDeny) =\n  (\\<exists>r.\n      generalized_sfw (map simple_rule_dtor ?fw) ?p = Some (r, Drop))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        generalized_sfw (map simple_rule_dtor fw) p =\n        Some (r, Drop) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generalized_sfw (map simple_rule_dtor fw) p = Some (r, Drop)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "note s1_correct[OF s1, of p]"], ["proof (state)\nthis:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "then"], ["proof (chain)\npicking this:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))", "guess rm"], ["proof (prove)\nusing this:\n  \\<exists>rm ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))", "guess ra"], ["proof (prove)\nusing this:\n  \\<exists>ra.\n     generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n     ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "note rmra = this"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r oif.\n       generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "unfolding lr_of_tran_fbs_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r oif.\n       generalized_sfw\n        (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n        p =\n       Some (r, oif, Drop)", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>oif.\n       generalized_sfw\n        (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw))\n        p =\n       Some (?r, oif, Drop)", "apply(rule exI[where x = ra])"], ["proof (prove)\ngoal (1 subgoal):\n 1. generalized_sfw\n     (generalized_fw_join (lr_of_tran_s1 rt) (map simple_rule_dtor fw)) p =\n    Some (?r, ra, Drop)", "apply(rule generalized_fw_joinI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. generalized_sfw (lr_of_tran_s1 rt) p = Some (?r1.4, ra)\n 2. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.4, Drop)", "using rmra"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_s1 rt) p = Some (rm, ra) \\<and>\n  ra = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (2 subgoals):\n 1. generalized_sfw (lr_of_tran_s1 rt) p = Some (?r1.4, ra)\n 2. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.4, Drop)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. generalized_sfw (map simple_rule_dtor fw) p = Some (?r2.4, Drop)", "apply(rule r)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r oif.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_oif_match_fbs:\n \"no_oif_match fw \\<Longrightarrow> list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_oif_match fw \\<Longrightarrow>\n    list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. no_oif_match fw \\<Longrightarrow>\n    list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "case 1"], ["proof (state)\nthis:\n  no_oif_match fw\n\ngoal (1 subgoal):\n 1. no_oif_match fw \\<Longrightarrow>\n    list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "have c: \"\\<And>mr ar mf af f a. \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt); (mf, af) \\<in> simple_rule_dtor ` set fw; simple_match_and mr mf = Some a\\<rbrakk> \\<Longrightarrow> oiface a = ifaceAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mr ar mf af f a.\n       \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt);\n        (mf, af) \\<in> simple_rule_dtor ` set fw;\n        simple_match_and mr mf = Some a\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mr ar mf af f a.\n       \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt);\n        (mf, af) \\<in> simple_rule_dtor ` set fw;\n        simple_match_and mr mf = Some a\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "case (1 mr ar mf af f a)"], ["proof (state)\nthis:\n  (mr, ar) \\<in> set (lr_of_tran_s1 rt)\n  (mf, af) \\<in> simple_rule_dtor ` set fw\n  simple_match_and mr mf = Some a\n\ngoal (1 subgoal):\n 1. \\<And>mr ar mf af f a.\n       \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt);\n        (mf, af) \\<in> simple_rule_dtor ` set fw;\n        simple_match_and mr mf = Some a\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "have \"oiface mr = ifaceAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oiface mr = ifaceAny", "using 1(1)"], ["proof (prove)\nusing this:\n  (mr, ar) \\<in> set (lr_of_tran_s1 rt)\n\ngoal (1 subgoal):\n 1. oiface mr = ifaceAny", "unfolding lr_of_tran_s1_def route2match_def"], ["proof (prove)\nusing this:\n  (mr, ar)\n  \\<in> set (map (\\<lambda>r.\n                     (\\<lparr>iiface = ifaceAny, oiface = ifaceAny,\n                         src = (0, 0),\n                         dst =\n                           (pfxm_prefix (routing_match r),\n                            routing_prefix r),\n                         proto = ProtoAny, sports = (0, - 1),\n                         dports = (0, - 1)\\<rparr>,\n                      routing_oiface r))\n              rt)\n\ngoal (1 subgoal):\n 1. oiface mr = ifaceAny", "by(clarsimp simp add: Set.image_iff)"], ["proof (state)\nthis:\n  oiface mr = ifaceAny\n\ngoal (1 subgoal):\n 1. \\<And>mr ar mf af f a.\n       \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt);\n        (mf, af) \\<in> simple_rule_dtor ` set fw;\n        simple_match_and mr mf = Some a\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "moreover"], ["proof (state)\nthis:\n  oiface mr = ifaceAny\n\ngoal (1 subgoal):\n 1. \\<And>mr ar mf af f a.\n       \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt);\n        (mf, af) \\<in> simple_rule_dtor ` set fw;\n        simple_match_and mr mf = Some a\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "have \"oiface mf = ifaceAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oiface mf = ifaceAny", "using 1(2) \\<open>no_oif_match fw\\<close>"], ["proof (prove)\nusing this:\n  (mf, af) \\<in> simple_rule_dtor ` set fw\n  no_oif_match fw\n\ngoal (1 subgoal):\n 1. oiface mf = ifaceAny", "unfolding no_oif_match_def simple_rule_dtor_def[abs_def]"], ["proof (prove)\nusing this:\n  (mf, af)\n  \\<in> (\\<lambda>r. case r of SimpleRule m a \\<Rightarrow> (m, a)) ` set fw\n  list_all (\\<lambda>m. oiface (match_sel m) = ifaceAny) fw\n\ngoal (1 subgoal):\n 1. oiface mf = ifaceAny", "by(clarsimp simp: list_all_iff split: simple_rule.splits) fastforce"], ["proof (state)\nthis:\n  oiface mf = ifaceAny\n\ngoal (1 subgoal):\n 1. \\<And>mr ar mf af f a.\n       \\<lbrakk>(mr, ar) \\<in> set (lr_of_tran_s1 rt);\n        (mf, af) \\<in> simple_rule_dtor ` set fw;\n        simple_match_and mr mf = Some a\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "ultimately"], ["proof (chain)\npicking this:\n  oiface mr = ifaceAny\n  oiface mf = ifaceAny", "show ?case"], ["proof (prove)\nusing this:\n  oiface mr = ifaceAny\n  oiface mf = ifaceAny\n\ngoal (1 subgoal):\n 1. oiface a = ifaceAny", "using 1(3)"], ["proof (prove)\nusing this:\n  oiface mr = ifaceAny\n  oiface mf = ifaceAny\n  simple_match_and mr mf = Some a\n\ngoal (1 subgoal):\n 1. oiface a = ifaceAny", "by(cases a; cases mr; cases mf) (simp add: iface_conjunct_ifaceAny split: option.splits)"], ["proof (state)\nthis:\n  oiface a = ifaceAny\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(?mr, ?ar) \\<in> set (lr_of_tran_s1 rt);\n   (?mf, ?af) \\<in> simple_rule_dtor ` set fw;\n   simple_match_and ?mr ?mf = Some ?a\\<rbrakk>\n  \\<Longrightarrow> oiface ?a = ifaceAny\n\ngoal (1 subgoal):\n 1. no_oif_match fw \\<Longrightarrow>\n    list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "have la: \"list_all (\\<lambda>m. oiface (fst m) = ifaceAny) (lr_of_tran_fbs rt fw ifs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst m) = ifaceAny)\n     (lr_of_tran_fbs rt fw ifs)", "unfolding lr_of_tran_fbs_def Let_def list_all_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set (generalized_fw_join (lr_of_tran_s1 rt)\n                         (map simple_rule_dtor fw)).\n       oiface (fst m) = ifaceAny", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       (a, aa, b)\n       \\<in> set (generalized_fw_join (lr_of_tran_s1 rt)\n                   (map simple_rule_dtor fw)) \\<Longrightarrow>\n       oiface (fst (a, aa, b)) = ifaceAny", "apply(subst(asm) generalized_sfw_join_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<exists>a1 a2.\n          (a1, aa) \\<in> set (lr_of_tran_s1 rt) \\<and>\n          (a2, b) \\<in> set (map simple_rule_dtor fw) \\<and>\n          simple_match_and a1 a2 = Some a \\<Longrightarrow>\n       oiface (fst (a, aa, b)) = ifaceAny", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a1 a2 x.\n       \\<lbrakk>(a1, aa) \\<in> set (lr_of_tran_s1 rt);\n        simple_match_and a1 a2 = Some a; (a2, b) = simple_rule_dtor x;\n        x \\<in> set fw\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "using c"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?mr, ?ar) \\<in> set (lr_of_tran_s1 rt);\n   (?mf, ?af) \\<in> simple_rule_dtor ` set fw;\n   simple_match_and ?mr ?mf = Some ?a\\<rbrakk>\n  \\<Longrightarrow> oiface ?a = ifaceAny\n\ngoal (1 subgoal):\n 1. \\<And>a aa b a1 a2 x.\n       \\<lbrakk>(a1, aa) \\<in> set (lr_of_tran_s1 rt);\n        simple_match_and a1 a2 = Some a; (a2, b) = simple_rule_dtor x;\n        x \\<in> set fw\\<rbrakk>\n       \\<Longrightarrow> oiface a = ifaceAny", "by blast"], ["proof (state)\nthis:\n  list_all (\\<lambda>m. oiface (fst m) = ifaceAny)\n   (lr_of_tran_fbs rt fw ifs)\n\ngoal (1 subgoal):\n 1. no_oif_match fw \\<Longrightarrow>\n    list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "thus ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>m. oiface (fst m) = ifaceAny)\n   (lr_of_tran_fbs rt fw ifs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "have *: \"(\\<lambda>m. oiface (fst (snd m)) = ifaceAny) = (\\<lambda>m. oiface (fst m) = ifaceAny) \\<circ> snd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) =\n    (\\<lambda>m. oiface (fst m) = ifaceAny) \\<circ> snd", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) =\n    (\\<lambda>x. oiface (fst (snd x)) = ifaceAny)", ".."], ["proof (state)\nthis:\n  (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) =\n  (\\<lambda>m. oiface (fst m) = ifaceAny) \\<circ> snd\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "unfolding * list_all_map[symmetric] map_snd_apfst map_snd_annotate_rlen"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst m) = ifaceAny)\n     (lr_of_tran_fbs rt fw ifs)", "using la"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>m. oiface (fst m) = ifaceAny)\n   (lr_of_tran_fbs rt fw ifs)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst m) = ifaceAny)\n     (lr_of_tran_fbs rt fw ifs)", "."], ["proof (state)\nthis:\n  list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n   (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n   (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lr_of_tran_correct:\n\tfixes p :: \"(32, 'a) simple_packet_ext_scheme\"\nassumes nerr: \"lr_of_tran rt fw ifs = Inr oft\"\n\t and ippkt: \"p_l2type p = 0x800\"\n\t and ifvld: \"p_iiface p \\<in> set ifs\"\n\tshows \"OF_priority_match OF_match_fields_safe oft p = Action [Forward oif] \\<longleftrightarrow> simple_linux_router_nol12 rt fw p = (Some (p\\<lparr>p_oiface := oif\\<rparr>))\"\n\t      \"OF_priority_match OF_match_fields_safe oft p = Action [] \\<longleftrightarrow> simple_linux_router_nol12 rt fw p = None\"\n\t      (* fun stuff: *)\n\t      \"OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\" \"OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\"\n\t      \"OF_priority_match OF_match_fields_safe oft p = Action ls \\<longrightarrow> length ls \\<le> 1\"\n\t      \"\\<exists>ls. length ls \\<le> 1 \\<and> OF_priority_match OF_match_fields_safe oft p = Action ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n     (simple_linux_router_nol12 rt fw p =\n      Some (p\\<lparr>p_oiface := oif\\<rparr>)) &&&\n     (OF_priority_match OF_match_fields_safe oft p = Action []) =\n     (simple_linux_router_nol12 rt fw p = None) &&&\n     OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction) &&&\n    OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined &&&\n    OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1 &&&\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have s1: \"valid_prefixes rt\" \"has_default_route rt\" \n   and s2: \"has_default_policy fw\" \"simple_fw_valid fw\" \"no_oif_match fw\"\n   and difs: \"distinct ifs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_prefixes rt &&& has_default_route rt) &&&\n    (has_default_policy fw &&& simple_fw_valid fw &&& no_oif_match fw) &&&\n    distinct ifs", "using nerr"], ["proof (prove)\nusing this:\n  lr_of_tran rt fw ifs = Inr oft\n\ngoal (1 subgoal):\n 1. (valid_prefixes rt &&& has_default_route rt) &&&\n    (has_default_policy fw &&& simple_fw_valid fw &&& no_oif_match fw) &&&\n    distinct ifs", "unfolding lr_of_tran_def"], ["proof (prove)\nusing this:\n  (if \\<not> (no_oif_match fw \\<and>\n              has_default_policy fw \\<and>\n              simple_fw_valid fw \\<and>\n              valid_prefixes rt \\<and>\n              has_default_route rt \\<and> distinct ifs)\n   then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n   else let nrd = lr_of_tran_fbs rt fw ifs;\n            ard = map (apfst word_of_nat) (annotate_rlen nrd)\n        in if length nrd < unat (- 1) then Inr (pack_OF_entries ifs ard)\n           else Inl ''Error in creating OpenFlow table: priority number space exhausted'') =\n  Inr oft\n\ngoal (1 subgoal):\n 1. (valid_prefixes rt &&& has_default_route rt) &&&\n    (has_default_policy fw &&& simple_fw_valid fw &&& no_oif_match fw) &&&\n    distinct ifs", "by(simp_all split: if_splits)"], ["proof (state)\nthis:\n  valid_prefixes rt\n  has_default_route rt\n  has_default_policy fw\n  simple_fw_valid fw\n  no_oif_match fw\n  distinct ifs\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have \"no_oif_match fw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_oif_match fw", "using nerr"], ["proof (prove)\nusing this:\n  lr_of_tran rt fw ifs = Inr oft\n\ngoal (1 subgoal):\n 1. no_oif_match fw", "unfolding lr_of_tran_def"], ["proof (prove)\nusing this:\n  (if \\<not> (no_oif_match fw \\<and>\n              has_default_policy fw \\<and>\n              simple_fw_valid fw \\<and>\n              valid_prefixes rt \\<and>\n              has_default_route rt \\<and> distinct ifs)\n   then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n   else let nrd = lr_of_tran_fbs rt fw ifs;\n            ard = map (apfst word_of_nat) (annotate_rlen nrd)\n        in if length nrd < unat (- 1) then Inr (pack_OF_entries ifs ard)\n           else Inl ''Error in creating OpenFlow table: priority number space exhausted'') =\n  Inr oft\n\ngoal (1 subgoal):\n 1. no_oif_match fw", "by(simp split: if_splits)"], ["proof (state)\nthis:\n  no_oif_match fw\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "note s2 = s2 this"], ["proof (state)\nthis:\n  has_default_policy fw\n  simple_fw_valid fw\n  no_oif_match fw\n  no_oif_match fw\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have unsafe_safe_eq: \n    \"OF_priority_match OF_match_fields_unsafe oft = OF_priority_match OF_match_fields_safe oft\"\n    \"OF_match_linear OF_match_fields_unsafe oft = OF_match_linear OF_match_fields_safe oft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_unsafe oft =\n    OF_priority_match OF_match_fields_safe oft &&&\n    OF_match_linear OF_match_fields_unsafe oft =\n    OF_match_linear OF_match_fields_safe oft", "apply(subst OF_unsafe_safe_match3_eq; (rule lr_of_tran_prereqs s1 s2 nerr refl)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_match_linear OF_match_fields_unsafe oft =\n    OF_match_linear OF_match_fields_safe oft", "apply(subst OF_unsafe_safe_match_linear_eq; (rule lr_of_tran_prereqs s1 s2 nerr refl)+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  OF_priority_match OF_match_fields_unsafe oft =\n  OF_priority_match OF_match_fields_safe oft\n  OF_match_linear OF_match_fields_unsafe oft =\n  OF_match_linear OF_match_fields_safe oft\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have lin: \"OF_priority_match OF_match_fields_safe oft = OF_match_linear OF_match_fields_safe oft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_safe oft =\n    OF_match_linear OF_match_fields_safe oft", "using OF_eq[OF lr_of_tran_no_overlaps lr_of_tran_sorted_descending, OF difs nerr[symmetric] nerr[symmetric]]"], ["proof (prove)\nusing this:\n  OF_match_linear OF_match_fields_unsafe oft ?p =\n  OF_priority_match OF_match_fields_unsafe oft ?p\n\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_safe oft =\n    OF_match_linear OF_match_fields_safe oft", "unfolding fun_eq_iff unsafe_safe_eq"], ["proof (prove)\nusing this:\n  OF_match_linear OF_match_fields_safe oft ?p =\n  OF_priority_match OF_match_fields_safe oft ?p\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       OF_priority_match OF_match_fields_safe oft x =\n       OF_match_linear OF_match_fields_safe oft x", "by metis"], ["proof (state)\nthis:\n  OF_priority_match OF_match_fields_safe oft =\n  OF_match_linear OF_match_fields_safe oft\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "let ?ard = \"map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))\""], ["proof (state)\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have oft_def: \"oft = pack_OF_entries ifs ?ard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oft =\n    pack_OF_entries ifs\n     (map (apfst word_of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "using nerr"], ["proof (prove)\nusing this:\n  lr_of_tran rt fw ifs = Inr oft\n\ngoal (1 subgoal):\n 1. oft =\n    pack_OF_entries ifs\n     (map (apfst word_of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "unfolding lr_of_tran_def Let_def"], ["proof (prove)\nusing this:\n  (if \\<not> (no_oif_match fw \\<and>\n              has_default_policy fw \\<and>\n              simple_fw_valid fw \\<and>\n              valid_prefixes rt \\<and>\n              has_default_route rt \\<and> distinct ifs)\n   then Inl ''Error in creating OpenFlow table: prerequisites not satisifed''\n   else if length (lr_of_tran_fbs rt fw ifs) < unat (- 1)\n        then Inr (pack_OF_entries ifs\n                   (map (apfst word_of_nat)\n                     (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n        else Inl ''Error in creating OpenFlow table: priority number space exhausted'') =\n  Inr oft\n\ngoal (1 subgoal):\n 1. oft =\n    pack_OF_entries ifs\n     (map (apfst word_of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "by(simp split: if_splits)"], ["proof (state)\nthis:\n  oft =\n  pack_OF_entries ifs\n   (map (apfst word_of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have vld: \"list_all simple_match_valid (map (fst \\<circ> snd) ?ard)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all simple_match_valid\n     (map (fst \\<circ> snd)\n       (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))", "unfolding fun_app_def map_map[symmetric] snd_apfst map_snd_apfst map_snd_annotate_rlen"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ifs))", "using simple_match_valid_fbs[OF s1(1) s2(2)]"], ["proof (prove)\nusing this:\n  list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ?ifs))\n\ngoal (1 subgoal):\n 1. list_all simple_match_valid (map fst (lr_of_tran_fbs rt fw ifs))", "."], ["proof (state)\nthis:\n  list_all simple_match_valid\n   (map (fst \\<circ> snd)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have *: \"list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny) ?ard\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "using no_oif_match_fbs[OF s2(3)]"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n   (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs ?rt fw ?ifs)))\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n     (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))", "."], ["proof (state)\nthis:\n  list_all (\\<lambda>m. oiface (fst (snd m)) = ifaceAny)\n   (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have not_undec: \"\\<And>p. simple_fw fw p \\<noteq> Undecided\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. simple_fw fw p \\<noteq> Undecided", "by (metis has_default_policy s2(1) state.simps(3))"], ["proof (state)\nthis:\n  simple_fw fw ?p5 \\<noteq> Undecided\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have w1_1: \"\\<And>oif. OF_match_linear OF_match_fields_safe oft p = Action [Forward oif] \\<Longrightarrow> simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>) \n    \\<and> oif = output_iface (routing_table_semantics rt (p_dst p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<and>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "proof(intro conjI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>)\n 2. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "case (1 oif)"], ["proof (state)\nthis:\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]\n\ngoal (2 subgoals):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>)\n 2. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "note s3_correct[OF vld ippkt ifvld(1) *, THEN iffD1, unfolded oft_def[symmetric], OF 1]"], ["proof (state)\nthis:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [Forward oif] = []\n      else [Forward oif] = [Forward (fst af)])\n\ngoal (2 subgoals):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>)\n 2. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "hence \"\\<exists>r. generalized_sfw (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))) p = Some (r, (oif, simple_action.Accept))\""], ["proof (prove)\nusing this:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [Forward oif] = []\n      else [Forward oif] = [Forward (fst af)])\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       generalized_sfw\n        (map snd\n          (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n        p =\n       Some (r, oif, Accept)", "by(clarsimp split: if_splits)"], ["proof (state)\nthis:\n  \\<exists>r.\n     generalized_sfw\n      (map snd\n        (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, oif, Accept)\n\ngoal (2 subgoals):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>)\n 2. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "then"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     generalized_sfw\n      (map snd\n        (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, oif, Accept)", "obtain r where \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, (oif, simple_action.Accept))\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     generalized_sfw\n      (map snd\n        (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n        Some (r, oif, Accept) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding map_map comp_def snd_apfst map_snd_annotate_rlen"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n        Some (r, oif, Accept) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (2 subgoals):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>)\n 2. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "thus ?case"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "using lr_of_tran_fbs_acceptD[OF s1 s2(3)]"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n  generalized_sfw (lr_of_tran_fbs rt fw ?ifs) ?p =\n  Some (?r, ?oif, Accept) \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw ?p =\n  Some (?p\\<lparr>p_oiface := ?oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p =\n    Some (p\\<lparr>p_oiface := oif\\<rparr>)", "by metis"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       OF_match_linear OF_match_fields_safe oft p =\n       Action [Forward oif] \\<Longrightarrow>\n       oif = output_iface (routing_table_semantics rt (p_dst p))", "thus \"oif = output_iface (routing_table_semantics rt (p_dst p))\""], ["proof (prove)\nusing this:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. oif = output_iface (routing_table_semantics rt (p_dst p))", "by(cases p) (clarsimp simp: simple_linux_router_nol12_def Let_def not_undec split: Option.bind_splits state.splits final_decision.splits)"], ["proof (state)\nthis:\n  oif = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OF_match_linear OF_match_fields_safe oft p =\n  Action [Forward ?oif6] \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := ?oif6\\<rparr>) \\<and>\n  ?oif6 = output_iface (routing_table_semantics rt (p_dst p))\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have w1_2: \"\\<And>oif. simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow> OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "proof(goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "case (1 oif)"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := oif\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "note lr_of_tran_fbs_acceptI[OF s1 s2(3) s2(1) this, of ifs]"], ["proof (state)\nthis:\n  \\<exists>r.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "then"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "guess r"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "note r = this"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "hence \"generalized_sfw (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))) p = Some (r, (oif, simple_action.Accept))\""], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. generalized_sfw\n     (map snd\n       (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n     p =\n    Some (r, oif, Accept)", "unfolding map_snd_apfst map_snd_annotate_rlen"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Accept)", "."], ["proof (state)\nthis:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "moreover"], ["proof (state)\nthis:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Accept)\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "note s3_correct[OF vld ippkt ifvld(1) *, THEN iffD2, unfolded oft_def[symmetric], of \"[Forward oif]\"]"], ["proof (state)\nthis:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [Forward oif] = []\n      else [Forward oif] = [Forward (fst af)]) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       simple_linux_router_nol12 rt fw p =\n       Some (p\\<lparr>p_oiface := oif\\<rparr>) \\<Longrightarrow>\n       OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "ultimately"], ["proof (chain)\npicking this:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Accept)\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [Forward oif] = []\n      else [Forward oif] = [Forward (fst af)]) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "show ?case"], ["proof (prove)\nusing this:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Accept)\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [Forward oif] = []\n      else [Forward oif] = [Forward (fst af)]) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]\n\ngoal (1 subgoal):\n 1. OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]", "by simp"], ["proof (state)\nthis:\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := ?oif6\\<rparr>) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward ?oif6]\n\ngoal (6 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) =\n    (simple_linux_router_nol12 rt fw p =\n     Some (p\\<lparr>p_oiface := oif\\<rparr>))\n 2. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 4. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 5. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 6. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "show w1: \"\\<And>oif. (OF_priority_match OF_match_fields_safe oft p = Action [Forward oif]) = (simple_linux_router_nol12 rt fw p = Some (p\\<lparr>p_oiface := oif\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oif.\n       (OF_priority_match OF_match_fields_safe oft p =\n        Action [Forward oif]) =\n       (simple_linux_router_nol12 rt fw p =\n        Some (p\\<lparr>p_oiface := oif\\<rparr>))", "unfolding lin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oif.\n       (OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]) =\n       (simple_linux_router_nol12 rt fw p =\n        Some (p\\<lparr>p_oiface := oif\\<rparr>))", "using w1_1 w1_2"], ["proof (prove)\nusing this:\n  OF_match_linear OF_match_fields_safe oft p =\n  Action [Forward ?oif6] \\<Longrightarrow>\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := ?oif6\\<rparr>) \\<and>\n  ?oif6 = output_iface (routing_table_semantics rt (p_dst p))\n  simple_linux_router_nol12 rt fw p =\n  Some (p\\<lparr>p_oiface := ?oif6\\<rparr>) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action [Forward ?oif6]\n\ngoal (1 subgoal):\n 1. \\<And>oif.\n       (OF_match_linear OF_match_fields_safe oft p = Action [Forward oif]) =\n       (simple_linux_router_nol12 rt fw p =\n        Some (p\\<lparr>p_oiface := oif\\<rparr>))", "by blast"], ["proof (state)\nthis:\n  (OF_priority_match OF_match_fields_safe oft p = Action [Forward ?oif6]) =\n  (simple_linux_router_nol12 rt fw p =\n   Some (p\\<lparr>p_oiface := ?oif6\\<rparr>))\n\ngoal (5 subgoals):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)\n 2. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 3. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 4. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 5. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "show w2: \"(OF_priority_match OF_match_fields_safe oft p = Action []) = (simple_linux_router_nol12 rt fw p = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (OF_priority_match OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)", "unfolding lin"], ["proof (prove)\ngoal (1 subgoal):\n 1. (OF_match_linear OF_match_fields_safe oft p = Action []) =\n    (simple_linux_router_nol12 rt fw p = None)", "proof(rule iffI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. OF_match_linear OF_match_fields_safe oft p = Action [] \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None\n 2. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "case 1"], ["proof (state)\nthis:\n  OF_match_linear OF_match_fields_safe oft p = Action []\n\ngoal (2 subgoals):\n 1. OF_match_linear OF_match_fields_safe oft p = Action [] \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None\n 2. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "note s3_correct[OF vld ippkt ifvld(1) *, THEN iffD1, unfolded oft_def[symmetric], OF 1]"], ["proof (state)\nthis:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [] = [] else [] = [Forward (fst af)])\n\ngoal (2 subgoals):\n 1. OF_match_linear OF_match_fields_safe oft p = Action [] \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None\n 2. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "then"], ["proof (chain)\npicking this:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [] = [] else [] = [Forward (fst af)])", "obtain r oif where roif: \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Drop)\""], ["proof (prove)\nusing this:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [] = [] else [] = [Forward (fst af)])\n\ngoal (1 subgoal):\n 1. (\\<And>r oif.\n        generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n        Some (r, oif, Drop) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding map_snd_apfst map_snd_annotate_rlen"], ["proof (prove)\nusing this:\n  \\<exists>r af.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, af) \\<and>\n     (if snd af = Drop then [] = [] else [] = [Forward (fst af)])\n\ngoal (1 subgoal):\n 1. (\\<And>r oif.\n        generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n        Some (r, oif, Drop) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp split: if_splits)"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (2 subgoals):\n 1. OF_match_linear OF_match_fields_safe oft p = Action [] \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None\n 2. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "note lr_of_tran_fbs_dropD[OF s1 s2(3) this]"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal (2 subgoals):\n 1. OF_match_linear OF_match_fields_safe oft p = Action [] \\<Longrightarrow>\n    simple_linux_router_nol12 rt fw p = None\n 2. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "thus ?case"], ["proof (prove)\nusing this:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None", "."], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "case 2"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p = None\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "note lr_of_tran_fbs_dropI[OF s1 s2(3) s2(1) this, of ifs]"], ["proof (state)\nthis:\n  \\<exists>r oif.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "then"], ["proof (chain)\npicking this:\n  \\<exists>r oif.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "obtain r oif where \"generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, simple_action.Drop)\""], ["proof (prove)\nusing this:\n  \\<exists>r oif.\n     generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. (\\<And>r oif.\n        generalized_sfw (lr_of_tran_fbs rt fw ifs) p =\n        Some (r, oif, Drop) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "hence \"generalized_sfw (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs)))) p = Some (r, oif, simple_action.Drop)\""], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. generalized_sfw\n     (map snd\n       (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n     p =\n    Some (r, oif, Drop)", "unfolding map_snd_apfst map_snd_annotate_rlen"], ["proof (prove)\nusing this:\n  generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. generalized_sfw (lr_of_tran_fbs rt fw ifs) p = Some (r, oif, Drop)", "."], ["proof (state)\nthis:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "moreover"], ["proof (state)\nthis:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Drop)\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "note s3_correct[OF vld ippkt ifvld(1) *, THEN iffD2, unfolded oft_def[symmetric], of \"[]\"]"], ["proof (state)\nthis:\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [] = []\n      else [] = [Forward (fst af)]) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action []\n\ngoal (1 subgoal):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_match_linear OF_match_fields_safe oft p = Action []", "ultimately"], ["proof (chain)\npicking this:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Drop)\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [] = []\n      else [] = [Forward (fst af)]) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action []", "show ?case"], ["proof (prove)\nusing this:\n  generalized_sfw\n   (map snd (map (apfst of_nat) (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n   p =\n  Some (r, oif, Drop)\n  \\<exists>r af.\n     generalized_sfw\n      (map snd\n        (map (apfst word_of_nat)\n          (annotate_rlen (lr_of_tran_fbs rt fw ifs))))\n      p =\n     Some (r, af) \\<and>\n     (if snd af = Drop then [] = []\n      else [] = [Forward (fst af)]) \\<Longrightarrow>\n  OF_match_linear OF_match_fields_safe oft p = Action []\n\ngoal (1 subgoal):\n 1. OF_match_linear OF_match_fields_safe oft p = Action []", "by force"], ["proof (state)\nthis:\n  OF_match_linear OF_match_fields_safe oft p = Action []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (OF_priority_match OF_match_fields_safe oft p = Action []) =\n  (simple_linux_router_nol12 rt fw p = None)\n\ngoal (4 subgoals):\n 1. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 2. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 3. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 4. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "have lr_determ: \"\\<And>a. simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow> a = p\\<lparr>p_oiface := output_iface (routing_table_semantics rt (p_dst p))\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       a = p\n       \\<lparr>p_oiface :=\n                 output_iface (routing_table_semantics rt (p_dst p))\\<rparr>", "by(clarsimp simp: simple_linux_router_nol12_def Let_def not_undec split: Option.bind_splits state.splits final_decision.splits)"], ["proof (state)\nthis:\n  simple_linux_router_nol12 rt fw p = Some ?a6 \\<Longrightarrow>\n  ?a6 = p\n  \\<lparr>p_oiface :=\n            output_iface (routing_table_semantics rt (p_dst p))\\<rparr>\n\ngoal (4 subgoals):\n 1. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 2. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 3. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 4. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "show notno: \"OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction", "apply(cases \"simple_linux_router_nol12 rt fw p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 2. \\<And>a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction", "using w2"], ["proof (prove)\nusing this:\n  (OF_priority_match OF_match_fields_safe oft p = Action []) =\n  (simple_linux_router_nol12 rt fw p = None)\n\ngoal (2 subgoals):\n 1. simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n    OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n 2. \\<And>a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction", "using w1[of \"output_iface (routing_table_semantics rt (p_dst p))\"]"], ["proof (prove)\nusing this:\n  (OF_priority_match OF_match_fields_safe oft p =\n   Action [Forward (output_iface (routing_table_semantics rt (p_dst p)))]) =\n  (simple_linux_router_nol12 rt fw p =\n   Some\n    (p\\<lparr>p_oiface :=\n                output_iface\n                 (routing_table_semantics rt (p_dst p))\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>simple_linux_router_nol12 rt fw p = Some a;\n        (OF_priority_match OF_match_fields_safe oft p =\n         Action\n          [Forward (output_iface (routing_table_semantics rt (p_dst p)))]) =\n        (a = p\n         \\<lparr>p_oiface :=\n                   output_iface\n                    (routing_table_semantics rt (p_dst p))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> OF_priority_match OF_match_fields_safe oft\n                          p \\<noteq>\n                         NoAction", "apply(drule lr_determ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(OF_priority_match OF_match_fields_safe oft p =\n                 Action\n                  [Forward\n                    (output_iface\n                      (routing_table_semantics rt (p_dst p)))]) =\n                (a = p\n                 \\<lparr>p_oiface :=\n                           output_iface\n                            (routing_table_semantics rt (p_dst p))\\<rparr>);\n        a = p\n        \\<lparr>p_oiface :=\n                  output_iface\n                   (routing_table_semantics rt (p_dst p))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> OF_priority_match OF_match_fields_safe oft\n                          p \\<noteq>\n                         NoAction", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n\ngoal (3 subgoals):\n 1. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n 2. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 3. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "show notub: \"OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined", "unfolding lin"], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_match_linear OF_match_fields_safe oft p \\<noteq> Undefined", "using OF_match_linear_ne_Undefined"], ["proof (prove)\nusing this:\n  OF_match_linear ?\\<gamma> ?ft ?p \\<noteq> Undefined\n\ngoal (1 subgoal):\n 1. OF_match_linear OF_match_fields_safe oft p \\<noteq> Undefined", "."], ["proof (state)\nthis:\n  OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n\ngoal (2 subgoals):\n 1. OF_priority_match OF_match_fields_safe oft p =\n    Action ls \\<longrightarrow>\n    length ls \\<le> 1\n 2. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "show notmult: \"\\<And>ls. OF_priority_match OF_match_fields_safe oft p = Action ls \\<longrightarrow> length ls \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls.\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1", "apply(cases \"simple_linux_router_nol12 rt fw p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls.\n       simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1\n 2. \\<And>ls a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1", "using w2"], ["proof (prove)\nusing this:\n  (OF_priority_match OF_match_fields_safe oft p = Action []) =\n  (simple_linux_router_nol12 rt fw p = None)\n\ngoal (2 subgoals):\n 1. \\<And>ls.\n       simple_linux_router_nol12 rt fw p = None \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1\n 2. \\<And>ls a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1", "using w1[of \"output_iface (routing_table_semantics rt (p_dst p))\"]"], ["proof (prove)\nusing this:\n  (OF_priority_match OF_match_fields_safe oft p =\n   Action [Forward (output_iface (routing_table_semantics rt (p_dst p)))]) =\n  (simple_linux_router_nol12 rt fw p =\n   Some\n    (p\\<lparr>p_oiface :=\n                output_iface\n                 (routing_table_semantics rt (p_dst p))\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>ls a.\n       simple_linux_router_nol12 rt fw p = Some a \\<Longrightarrow>\n       OF_priority_match OF_match_fields_safe oft p =\n       Action ls \\<longrightarrow>\n       length ls \\<le> 1", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls a.\n       \\<lbrakk>simple_linux_router_nol12 rt fw p = Some a;\n        (OF_priority_match OF_match_fields_safe oft p =\n         Action\n          [Forward (output_iface (routing_table_semantics rt (p_dst p)))]) =\n        (a = p\n         \\<lparr>p_oiface :=\n                   output_iface\n                    (routing_table_semantics rt (p_dst p))\\<rparr>)\\<rbrakk>\n       \\<Longrightarrow> OF_priority_match OF_match_fields_safe oft p =\n                         Action ls \\<longrightarrow>\n                         length ls \\<le> Suc 0", "apply(drule lr_determ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls a.\n       \\<lbrakk>(OF_priority_match OF_match_fields_safe oft p =\n                 Action\n                  [Forward\n                    (output_iface\n                      (routing_table_semantics rt (p_dst p)))]) =\n                (a = p\n                 \\<lparr>p_oiface :=\n                           output_iface\n                            (routing_table_semantics rt (p_dst p))\\<rparr>);\n        a = p\n        \\<lparr>p_oiface :=\n                  output_iface\n                   (routing_table_semantics rt (p_dst p))\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> OF_priority_match OF_match_fields_safe oft p =\n                         Action ls \\<longrightarrow>\n                         length ls \\<le> Suc 0", "apply(clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  OF_priority_match OF_match_fields_safe oft p =\n  Action ?ls6 \\<longrightarrow>\n  length ?ls6 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "show \"\\<exists>ls. length ls \\<le> 1 \\<and> OF_priority_match OF_match_fields_safe oft p = Action ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "apply(cases \"OF_priority_match OF_match_fields_safe oft p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       OF_priority_match OF_match_fields_safe oft p =\n       Action x1 \\<Longrightarrow>\n       \\<exists>ls.\n          length ls \\<le> 1 \\<and>\n          OF_priority_match OF_match_fields_safe oft p = Action ls\n 2. OF_priority_match OF_match_fields_safe oft p =\n    NoAction \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls\n 3. OF_priority_match OF_match_fields_safe oft p =\n    Undefined \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "using notmult"], ["proof (prove)\nusing this:\n  OF_priority_match OF_match_fields_safe oft p =\n  Action ?ls6 \\<longrightarrow>\n  length ?ls6 \\<le> 1\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       OF_priority_match OF_match_fields_safe oft p =\n       Action x1 \\<Longrightarrow>\n       \\<exists>ls.\n          length ls \\<le> 1 \\<and>\n          OF_priority_match OF_match_fields_safe oft p = Action ls\n 2. OF_priority_match OF_match_fields_safe oft p =\n    NoAction \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls\n 3. OF_priority_match OF_match_fields_safe oft p =\n    Undefined \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. OF_priority_match OF_match_fields_safe oft p =\n    NoAction \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls\n 2. OF_priority_match OF_match_fields_safe oft p =\n    Undefined \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "using notno"], ["proof (prove)\nusing this:\n  OF_priority_match OF_match_fields_safe oft p \\<noteq> NoAction\n\ngoal (2 subgoals):\n 1. OF_priority_match OF_match_fields_safe oft p =\n    NoAction \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls\n 2. OF_priority_match OF_match_fields_safe oft p =\n    Undefined \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_safe oft p =\n    Undefined \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "using notub"], ["proof (prove)\nusing this:\n  OF_priority_match OF_match_fields_safe oft p \\<noteq> Undefined\n\ngoal (1 subgoal):\n 1. OF_priority_match OF_match_fields_safe oft p =\n    Undefined \\<Longrightarrow>\n    \\<exists>ls.\n       length ls \\<le> 1 \\<and>\n       OF_priority_match OF_match_fields_safe oft p = Action ls", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ls.\n     length ls \\<le> 1 \\<and>\n     OF_priority_match OF_match_fields_safe oft p = Action ls\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}