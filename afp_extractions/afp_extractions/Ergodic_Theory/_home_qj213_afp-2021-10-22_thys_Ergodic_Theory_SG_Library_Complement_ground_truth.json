{"file_name": "/home/qj213/afp-2021-10-22/thys/Ergodic_Theory/SG_Library_Complement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Ergodic_Theory", "problem_names": ["lemma equiv_neg:\n  \"\\<lbrakk> P \\<Longrightarrow> Q; \\<not>P \\<Longrightarrow> \\<not>Q \\<rbrakk> \\<Longrightarrow> (P\\<longleftrightarrow>Q)\"", "lemma compl_compl_eq_id [simp]:\n  \"UNIV - (UNIV - s) = s\"", "lemma sym_diff_inc:\n  \"A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C\"", "lemma sym_diff_vimage [simp]:\n  \"f-`(A \\<Delta> B) = (f-`A) \\<Delta> (f-`B)\"", "lemma UN_le_eq_Un0_strict:\n  \"(\\<Union>i<n+1::nat. M i) = (\\<Union>i\\<in>{1..<n+1}. M i) \\<union> M 0\" (is \"?A = ?B\")", "lemma union_insert_0:\n  \"(\\<Union>n::nat. A n) = A 0 \\<union> (\\<Union>n\\<in>{1..}. A n)\"", "lemma sum_arith_progression:\n  \"(\\<Sum>r<(N::nat). (\\<Sum>i<a. f (i*N+r))) = (\\<Sum>j<a*N. f j)\"", "lemma ind_from_1 [case_names 1 Suc, consumes 1]:\n  assumes \"n > 0\"\n  assumes \"P 1\"\n      and \"\\<And>n. n > 0 \\<Longrightarrow> P n \\<Longrightarrow> P (Suc n)\"\n  shows \"P n\"", "lemma tends_to_real_e:\n  fixes u::\"nat \\<Rightarrow> real\"\n  assumes \"u \\<longlonglongrightarrow> l\" \"e>0\"\n  shows \"\\<exists>N. \\<forall>n>N. abs(u n -l) < e\"", "lemma nat_mod_cong:\n  assumes \"a = b+(c::nat)\"\n          \"a mod n = b mod n\"\n  shows \"c mod n = 0\"", "lemma funpow_add': \"(f ^^ (m + n)) x = (f ^^ m) ((f ^^ n) x)\"", "lemma abs_Max_sum:\n  fixes A::\"real set\"\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"abs(Max A) \\<le> (\\<Sum>a\\<in>A. abs(a))\"", "lemma abs_Max_sum2:\n  fixes f::\"_ \\<Rightarrow> real\"\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"abs(Max (f`A)) \\<le> (\\<Sum>a\\<in>A. abs(f a))\"", "lemma mono_cInf:\n  fixes f :: \"'a::conditionally_complete_lattice \\<Rightarrow> 'b::conditionally_complete_lattice\"\n  assumes \"mono f\" \"A \\<noteq> {}\" \"bdd_below A\"\n  shows \"f(Inf A) \\<le> Inf (f`A)\"", "lemma mono_bij_cInf:\n  fixes f :: \"'a::conditionally_complete_linorder \\<Rightarrow> 'b::conditionally_complete_linorder\"\n  assumes \"mono f\" \"bij f\" \"A \\<noteq> {}\" \"bdd_below A\"\n  shows \"f (Inf A) = Inf (f`A)\"", "lemma open_less_abs [simp]:\n  \"open {x. (C::real) < abs x}\"", "lemma closed_le_abs [simp]:\n  \"closed {x. (C::real) \\<le> abs x}\"", "lemma eventually_weak_subseq:\n  fixes u::\"nat \\<Rightarrow> nat\"\n  assumes \"(\\<lambda>n. real(u n)) \\<longlonglongrightarrow> \\<infinity>\" \"eventually P sequentially\"\n  shows \"eventually (\\<lambda>n. P (u n)) sequentially\"", "lemma filterlim_weak_subseq:\n  fixes u::\"nat \\<Rightarrow> nat\"\n  assumes \"(\\<lambda>n. real(u n)) \\<longlonglongrightarrow> \\<infinity>\"\n  shows \"LIM n sequentially. u n:> at_top\"", "lemma limit_along_weak_subseq:\n  fixes u::\"nat \\<Rightarrow> nat\" and v::\"nat \\<Rightarrow> _\"\n  assumes \"(\\<lambda>n. real(u n)) \\<longlonglongrightarrow> \\<infinity>\" \"v \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda> n. v(u n)) \\<longlonglongrightarrow> l\"", "lemma frontier_indist_le:\n  assumes \"x \\<in> frontier {y. infdist y S \\<le> r}\"\n  shows \"infdist x S = r\"", "lemma tendsto_shift_1_over_n [tendsto_intros]:\n  fixes f::\"nat \\<Rightarrow> real\"\n  assumes \"(\\<lambda>n. f n / n) \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda>n. f (n+k) / n) \\<longlonglongrightarrow> l\"", "lemma tendsto_shift_1_over_n' [tendsto_intros]:\n  fixes f::\"nat \\<Rightarrow> real\"\n  assumes \"(\\<lambda>n. f n / n) \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda>n. f (n-k) / n) \\<longlonglongrightarrow> l\"", "lemma continuous_on_closure_sequentially':\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\"\n  assumes \"continuous_on (closure C) f\"\n          \"\\<And>(n::nat). u n \\<in> C\"\n          \"u \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l\"", "lemma convex_on_mean_ineq:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"convex_on A f\" \"x \\<in> A\" \"y \\<in> A\"\n  shows \"f ((x+y)/2) \\<le> (f x + f y) / 2\"", "lemma convex_on_closure:\n  assumes \"convex (C::'a::real_normed_vector set)\"\n          \"convex_on C f\"\n          \"continuous_on (closure C) f\"\n  shows \"convex_on (closure C) f\"", "lemma convex_on_norm [simp]:\n  \"convex_on UNIV (\\<lambda>(x::'a::real_normed_vector). norm x)\"", "lemma continuous_abs_powr [continuous_intros]:\n  assumes \"p > 0\"\n  shows \"continuous_on UNIV (\\<lambda>(x::real). \\<bar>x\\<bar> powr p)\"", "lemma continuous_mult_sgn [continuous_intros]:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on UNIV f\" \"f 0 = 0\"\n  shows \"continuous_on UNIV (\\<lambda>x. sgn x * f x)\"", "lemma DERIV_abs_powr [derivative_intros]:\n  assumes \"p > (1::real)\"\n  shows \"DERIV (\\<lambda>x. \\<bar>x\\<bar> powr p) x :> p * sgn x * \\<bar>x\\<bar> powr (p - 1)\"", "lemma convex_abs_powr:\n  assumes \"p \\<ge> 1\"\n  shows \"convex_on UNIV (\\<lambda>x::real. \\<bar>x\\<bar> powr p)\"", "lemma convex_powr:\n  assumes \"p \\<ge> 1\"\n  shows \"convex_on {0..} (\\<lambda>x::real. x powr p)\"", "lemma convex_powr':\n  assumes \"p > 0\" \"p \\<le> 1\"\n  shows \"convex_on {0..} (\\<lambda>x::real. - (x powr p))\"", "lemma convex_fx_plus_fy_ineq:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"convex_on {0..} f\"\n          \"x \\<ge> 0\" \"y \\<ge> 0\" \"f 0 = 0\"\n  shows \"f x + f y \\<le> f (x+y)\"", "lemma x_plus_y_p_le_xp_plus_yp:\n  fixes p x y::real\n  assumes \"p > 0\" \"p \\<le> 1\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"(x + y) powr p \\<le> x powr p + y powr p\"", "lemma x_plus_top_ennreal [simp]:\n  \"x + \\<top> = (\\<top>::ennreal)\"", "lemma ennreal_ge_nat_imp_PInf:\n  fixes x::ennreal\n  assumes \"\\<And>N. x \\<ge> of_nat N\"\n  shows \"x = \\<infinity>\"", "lemma ennreal_archimedean:\n  assumes \"x \\<noteq> (\\<infinity>::ennreal)\"\n  shows \"\\<exists>n::nat. x \\<le> n\"", "lemma e2ennreal_mult:\n  fixes a b::ereal\n  assumes \"a \\<ge> 0\"\n  shows \"e2ennreal(a * b) = e2ennreal a * e2ennreal b\"", "lemma e2ennreal_mult':\n  fixes a b::ereal\n  assumes \"b \\<ge> 0\"\n  shows \"e2ennreal(a * b) = e2ennreal a * e2ennreal b\"", "lemma SUP_real_ennreal:\n  assumes \"A \\<noteq> {}\" \"bdd_above (f`A)\"\n  shows \"(SUP a\\<in>A. ennreal (f a)) = ennreal(SUP a\\<in>A. f a)\"", "lemma e2ennreal_Liminf:\n  \"F \\<noteq> bot \\<Longrightarrow> e2ennreal (Liminf F f) = Liminf F (\\<lambda>n. e2ennreal (f n))\"", "lemma e2ennreal_eq_infty[simp]: \"0 \\<le> x \\<Longrightarrow> e2ennreal x = top \\<longleftrightarrow> x = \\<infinity>\"", "lemma ennreal_Inf_cmult:\n  assumes \"c>(0::real)\"\n  shows \"Inf {ennreal c * x |x. P x} = ennreal c * Inf {x. P x}\"", "lemma continuous_on_const_minus_ennreal:\n  fixes f :: \"'a :: topological_space \\<Rightarrow> ennreal\"\n  shows \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. a - f x)\"", "lemma const_minus_Liminf_ennreal:\n  fixes a :: ennreal\n  shows \"F \\<noteq> bot \\<Longrightarrow> a - Liminf F f = Limsup F (\\<lambda>x. a - f x)\"", "lemma tendsto_cmult_ennreal [tendsto_intros]:\n  fixes c l::ennreal\n  assumes \"\\<not>(c = \\<infinity> \\<and> l = 0)\"\n          \"(f \\<longlongrightarrow> l) F\"\n  shows \"((\\<lambda>x. c * f x) \\<longlongrightarrow> c * l) F\"", "lemma sum_indicator_eq_card2:\n  assumes \"finite I\"\n  shows \"(\\<Sum>i\\<in>I. (indicator (P i) x)::nat) = card {i\\<in>I. x \\<in> P i}\"", "lemma disjoint_family_indicator_le_1:\n  assumes \"disjoint_family_on A I\"\n  shows \"(\\<Sum> i\\<in> I. indicator (A i) x) \\<le> (1::'a:: {comm_monoid_add,zero_less_one})\"", "lemma algebra_intersection:\n  assumes \"algebra \\<Omega> A\"\n          \"algebra \\<Omega> B\"\n  shows \"algebra \\<Omega> (A \\<inter> B)\"", "lemma sigma_algebra_intersection:\n  assumes \"sigma_algebra \\<Omega> A\"\n          \"sigma_algebra \\<Omega> B\"\n  shows \"sigma_algebra \\<Omega> (A \\<inter> B)\"", "lemma subalgebra_M_M [simp]:\n  \"subalgebra M M\"", "lemma disjoint_family_Suc2:\n  assumes Suc: \"\\<And>n. A (Suc n) \\<subseteq> A n\"\n  shows \"disjoint_family (\\<lambda>i. A i - A (Suc i))\"", "lemma AE_equal_sum:\n  assumes \"\\<And>i. AE x in M. f i x = g i x\"\n  shows \"AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\"", "lemma emeasure_pos_unionE:\n  assumes \"\\<And> (N::nat). A N \\<in> sets M\"\n          \"emeasure M (\\<Union>N. A N) > 0\"\n  shows \"\\<exists>N. emeasure M (A N) > 0\"", "lemma (in prob_space) emeasure_intersection:\n  fixes e::\"nat \\<Rightarrow> real\"\n  assumes [measurable]: \"\\<And>n. U n \\<in> sets M\"\n      and [simp]: \"\\<And>n. 0 \\<le> e n\" \"summable e\"\n      and ge: \"\\<And>n. emeasure M (U n) \\<ge> 1 - (e n)\"\n  shows \"emeasure M (\\<Inter>n. U n) \\<ge> 1 - (\\<Sum>n. e n)\"", "lemma null_sym_diff_transitive:\n  assumes \"A \\<Delta> B \\<in> null_sets M\" \"B \\<Delta> C \\<in> null_sets M\"\n      and [measurable]: \"A \\<in> sets M\" \"C \\<in> sets M\"\n  shows \"A \\<Delta> C \\<in> null_sets M\"", "lemma Delta_null_of_null_is_null:\n  assumes \"B \\<in> sets M\" \"A \\<Delta> B \\<in> null_sets M\" \"A \\<in> null_sets M\"\n  shows \"B \\<in> null_sets M\"", "lemma Delta_null_same_emeasure:\n  assumes \"A \\<Delta> B \\<in> null_sets M\" and [measurable]: \"A \\<in> sets M\" \"B \\<in> sets M\"\n  shows \"emeasure M A = emeasure M B\"", "lemma AE_upper_bound_inf_ereal:\n  fixes F G::\"'a \\<Rightarrow> ereal\"\n  assumes \"\\<And>e. (e::real) > 0 \\<Longrightarrow> AE x in M. F x \\<le> G x + e\"\n  shows \"AE x in M. F x \\<le> G x\"", "lemma (in finite_measure) Egorov_lemma:\n  assumes [measurable]: \"\\<And>n. (P n) \\<in> measurable M (count_space UNIV)\"\n      and \"AE x in M. eventually (\\<lambda>n. P n x) sequentially\"\n          \"epsilon > 0\"\n  shows \"\\<exists>U N. U \\<in> sets M \\<and> (\\<forall>n \\<ge> N. \\<forall>x \\<in> U. P n x) \\<and> emeasure M (space M - U) < epsilon\"", "lemma (in finite_measure) uncountable_disjoint_family_then_exists_zero_measure:\n  assumes [measurable]: \"\\<And>i. i \\<in> I \\<Longrightarrow> A i \\<in> sets M\"\n      and \"uncountable I\"\n          \"disjoint_family_on A I\"\n  shows \"\\<exists>i\\<in>I. measure M (A i) = 0\"", "lemma measurable_Inf [measurable]:\n  assumes [measurable]: \"\\<And>(n::nat). P n \\<in> measurable M (count_space UNIV)\"\n  shows \"(\\<lambda>x. Inf {n. P n x}) \\<in> measurable M (count_space UNIV)\" (is \"?f \\<in> _\")", "lemma measurable_T_iter [measurable]:\n  fixes f::\"'a \\<Rightarrow> nat\"\n  assumes [measurable]: \"T \\<in> measurable M M\"\n          \"f \\<in> measurable M (count_space UNIV)\"\n  shows \"(\\<lambda>x. (T^^(f x)) x) \\<in> measurable M M\"", "lemma measurable_infdist [measurable]:\n  \"(\\<lambda>x. infdist x S) \\<in> borel_measurable borel\"", "lemma (in sigma_finite_measure) approx_with_finite_emeasure:\n  assumes W_meas: \"W \\<in> sets M\"\n      and W_inf: \"emeasure M W > C\"\n  obtains Z where \"Z \\<in> sets M\" \"Z \\<subseteq> W\" \"emeasure M Z < \\<infinity>\" \"emeasure M Z > C\"", "lemma nn_integral_densityR:\n  assumes [measurable]: \"f \\<in> borel_measurable F\" \"g \\<in> borel_measurable F\"\n  shows \"(\\<integral>\\<^sup>+ x. f x * g x \\<partial>F) = (\\<integral>\\<^sup>+ x. f x \\<partial>(density F g))\"", "lemma not_AE_zero_int_ennreal_E:\n  fixes f::\"'a \\<Rightarrow> ennreal\"\n  assumes \"(\\<integral>\\<^sup>+x. f x \\<partial>M) > 0\"\n      and [measurable]: \"f \\<in> borel_measurable M\"\n  shows \"\\<exists>A\\<in>sets M. \\<exists>e::real>0. emeasure M A > 0 \\<and> (\\<forall>x \\<in> A. f x \\<ge> e)\"", "lemma (in finite_measure) nn_integral_bounded_eq_bound_then_AE:\n  assumes \"AE x in M. f x \\<le> ennreal c\" \"(\\<integral>\\<^sup>+x. f x \\<partial>M) = c * emeasure M (space M)\"\n      and [measurable]: \"f \\<in> borel_measurable M\"\n  shows \"AE x in M. f x = c\"", "lemma null_sets_density:\n  assumes [measurable]: \"h \\<in> borel_measurable M\"\n      and \"AE x in M. h x \\<noteq> 0\"\n  shows \"null_sets (density M h) = null_sets M\"", "lemma (in prob_space) sum_measure_le_measure_inter:\n  assumes \"A \\<in> sets M\" \"B \\<in> sets M\"\n  shows \"prob A + prob B \\<le> 1 + prob (A \\<inter> B)\"", "lemma (in prob_space) sum_measure_le_measure_inter3:\n  assumes [measurable]: \"A \\<in> sets M\" \"B \\<in> sets M\" \"C \\<in> sets M\"\n  shows \"prob A + prob B + prob C \\<le> 2 + prob (A \\<inter> B \\<inter> C)\"", "lemma (in prob_space) sum_measure_le_measure_Inter:\n  assumes [measurable]: \"finite I\" \"I \\<noteq> {}\" \"\\<And>i. i \\<in> I \\<Longrightarrow> A i \\<in> sets M\"\n  shows \"(\\<Sum>i\\<in>I. prob (A i)) \\<le> real(card I) - 1 + prob (\\<Inter>i\\<in>I. A i)\"", "lemma (in prob_space) random_variable_small_tails:\n  assumes \"alpha > 0\" and [measurable]: \"f \\<in> borel_measurable M\"\n  shows \"\\<exists>(C::real). prob {x \\<in> space M. abs(f x) \\<ge> C} < alpha \\<and> C \\<ge> K\"", "lemma space_eq_univ [simp]: \"space M = UNIV\"", "lemma measurable_finite_borel [simp]:\n  \"f \\<in> borel_measurable borel \\<Longrightarrow> f \\<in> borel_measurable M\"", "lemma approx_closed_set_with_set_zero_measure_boundary:\n  assumes \"closed S\" \"epsilon > 0\" \"S \\<noteq> {}\"\n  shows \"\\<exists>r. r < epsilon \\<and> r > 0 \\<and> measure M {x. infdist x S = r} = 0 \\<and> measure M {x. infdist x S \\<le> r} < measure M S + epsilon\"", "lemma weak_conv_m_subseq:\n  assumes \"weak_conv_m M_seq M\" \"strict_mono r\"\n  shows \"weak_conv_m (\\<lambda>n. M_seq (r n)) M\"", "lemma closed_set_weak_conv_usc:\n  assumes \"closed S\" \"measure M S < l\"\n  shows \"eventually (\\<lambda>n. measure (\\<mu> n) S < l) sequentially\"", "lemma open_set_weak_conv_lsc:\n  assumes \"open S\" \"measure M S > l\"\n  shows \"eventually (\\<lambda>n. measure (\\<mu> n) S > l) sequentially\""], "translations": [["", "lemma equiv_neg:\n  \"\\<lbrakk> P \\<Longrightarrow> Q; \\<not>P \\<Longrightarrow> \\<not>Q \\<rbrakk> \\<Longrightarrow> (P\\<longleftrightarrow>Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<Longrightarrow> Q;\n     \\<not> P \\<Longrightarrow> \\<not> Q\\<rbrakk>\n    \\<Longrightarrow> P = Q", "by blast"], ["", "subsection \\<open>Basic set theory\\<close>"], ["", "lemma compl_compl_eq_id [simp]:\n  \"UNIV - (UNIV - s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV - (UNIV - s) = s", "by auto"], ["", "abbreviation sym_diff :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" (infixl \"\\<Delta>\" 70) where\n  \"sym_diff A B \\<equiv> ((A - B) \\<union> (B-A))\""], ["", "text \\<open>Not sure the next lemmas are useful, as they are proved solely by auto, so they\ncould be reproved automatically whenever necessary.\\<close>"], ["", "lemma sym_diff_inc:\n  \"A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C", "by auto"], ["", "lemma sym_diff_vimage [simp]:\n  \"f-`(A \\<Delta> B) = (f-`A) \\<Delta> (f-`B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` (A \\<Delta> B) = f -` A \\<Delta> f -` B", "by auto"], ["", "subsection \\<open>Set-Interval.thy\\<close>"], ["", "text \\<open>The next two lemmas belong naturally to \\verb+Set_Interval.thy+, next to\n\\verb+UN_le_add_shift+. They are not trivially equivalent to the corresponding lemmas\nwith large inequalities, due to the difference when $n = 0$.\\<close>"], ["", "lemma UN_le_eq_Un0_strict:\n  \"(\\<Union>i<n+1::nat. M i) = (\\<Union>i\\<in>{1..<n+1}. M i) \\<union> M 0\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (M ` {..<n + 1}) = \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Union> (M ` {..<n + 1})\n    \\<subseteq> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n 2. \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n    \\<subseteq> \\<Union> (M ` {..<n + 1})", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (M ` {..<n + 1})\n    \\<subseteq> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (M ` {..<n + 1}) \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (M ` {..<n + 1}) \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "assume \"x \\<in> ?A\""], ["proof (state)\nthis:\n  x \\<in> \\<Union> (M ` {..<n + 1})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (M ` {..<n + 1}) \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> (M ` {..<n + 1})", "obtain i where i: \"i<n+1\" \"x \\<in> M i\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (M ` {..<n + 1})\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n + 1; x \\<in> M i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n + 1\n  x \\<in> M i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (M ` {..<n + 1}) \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "show \"x \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "with i"], ["proof (chain)\npicking this:\n  i < n + 1\n  x \\<in> M i\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i < n + 1\n  x \\<in> M i\n  i = 0\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "by simp"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "with i"], ["proof (chain)\npicking this:\n  i < n + 1\n  x \\<in> M i\n  i = Suc j", "show ?thesis"], ["proof (prove)\nusing this:\n  i < n + 1\n  x \\<in> M i\n  i = Suc j\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Union> (M ` {..<n + 1})\n  \\<subseteq> \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n\ngoal (1 subgoal):\n 1. \\<Union> (M ` {1..<n + 1}) \\<union> M 0\n    \\<subseteq> \\<Union> (M ` {..<n + 1})", "qed (auto)"], ["", "text \\<open>I use repeatedly this one, but I could not find it directly\\<close>"], ["", "lemma union_insert_0:\n  \"(\\<Union>n::nat. A n) = A 0 \\<union> (\\<Union>n\\<in>{1..}. A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range A) = A 0 \\<union> \\<Union> (A ` {1..})", "by (metis UN_insert Un_insert_left sup_bot.left_neutral One_nat_def atLeast_0 atLeast_Suc_greaterThan ivl_disj_un_singleton(1))"], ["", "text \\<open>Next one could be close to \\verb+sum.nat_group+\\<close>"], ["", "lemma sum_arith_progression:\n  \"(\\<Sum>r<(N::nat). (\\<Sum>i<a. f (i*N+r))) = (\\<Sum>j<a*N. f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "have *: \"(\\<Sum>r<N. f (i*N+r)) = (\\<Sum> j \\<in> {i*N..<i*N + N}. f j)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. f (i * N + r)) = sum f {i * N..<i * N + N}", "by (rule sum.reindex_bij_betw, rule bij_betw_byWitness[where ?f' = \"\\<lambda>r. r-i*N\"], auto)"], ["proof (state)\nthis:\n  (\\<Sum>r<N. f (?i * N + r)) = sum f {?i * N..<?i * N + N}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "have \"(\\<Sum>r<N. (\\<Sum>i<a. f (i*N+r))) = (\\<Sum>i<a. (\\<Sum>r<N. f (i*N+r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) =\n    (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r))", "using sum.swap"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>?A. sum (?g i) ?B) = (\\<Sum>j\\<in>?B. \\<Sum>i\\<in>?A. ?g i j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) =\n    (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) =\n  (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "also"], ["proof (state)\nthis:\n  (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) =\n  (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "have \"... = (\\<Sum>i<a. (\\<Sum> j \\<in> {i*N..<i*N + N}. f j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r)) =\n    (\\<Sum>i<a. sum f {i * N..<i * N + N})", "using *"], ["proof (prove)\nusing this:\n  (\\<Sum>r<N. f (?i * N + r)) = sum f {?i * N..<?i * N + N}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r)) =\n    (\\<Sum>i<a. sum f {i * N..<i * N + N})", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r)) =\n  (\\<Sum>i<a. sum f {i * N..<i * N + N})\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<a. \\<Sum>r<N. f (i * N + r)) =\n  (\\<Sum>i<a. sum f {i * N..<i * N + N})\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "have \"... = (\\<Sum>j<a*N. f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<a. sum f {i * N..<i * N + N}) = sum f {..<a * N}", "by (rule sum.nat_group)"], ["proof (state)\nthis:\n  (\\<Sum>i<a. sum f {i * N..<i * N + N}) = sum f {..<a * N}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}\n\ngoal (1 subgoal):\n 1. (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>r<N. \\<Sum>i<a. f (i * N + r)) = sum f {..<a * N}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Miscellanous basic results\\<close>"], ["", "lemma ind_from_1 [case_names 1 Suc, consumes 1]:\n  assumes \"n > 0\"\n  assumes \"P 1\"\n      and \"\\<And>n. n > 0 \\<Longrightarrow> P n \\<Longrightarrow> P (Suc n)\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P n", "have \"(n = 0) \\<or> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 0 \\<or> P n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 = 0 \\<or> P 0\n 2. \\<And>n. n = 0 \\<or> P n \\<Longrightarrow> Suc n = 0 \\<or> P (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 = 0 \\<or> P 0\n 2. \\<And>n. n = 0 \\<or> P n \\<Longrightarrow> Suc n = 0 \\<or> P (Suc n)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 \\<or> P 0", "by auto"], ["proof (state)\nthis:\n  0 = 0 \\<or> P 0\n\ngoal (1 subgoal):\n 1. \\<And>n. n = 0 \\<or> P n \\<Longrightarrow> Suc n = 0 \\<or> P (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n = 0 \\<or> P n \\<Longrightarrow> Suc n = 0 \\<or> P (Suc n)", "case (Suc k)"], ["proof (state)\nthis:\n  k = 0 \\<or> P k\n\ngoal (1 subgoal):\n 1. \\<And>n. n = 0 \\<or> P n \\<Longrightarrow> Suc n = 0 \\<or> P (Suc n)", "consider \"Suc k = 1\" | \"Suc k > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc k = 1 \\<Longrightarrow> thesis;\n     1 < Suc k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>Suc k = 1 \\<Longrightarrow> ?thesis;\n   1 < Suc k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>n. n = 0 \\<or> P n \\<Longrightarrow> Suc n = 0 \\<or> P (Suc n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc k = 1 \\<Longrightarrow> ?thesis;\n   1 < Suc k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc k = 1 \\<Longrightarrow> ?thesis;\n   1 < Suc k \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Suc k = 0 \\<or> P (Suc k)", "apply (cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc k = 1 \\<Longrightarrow> Suc k = 0 \\<or> P (Suc k)\n 2. 1 < Suc k \\<Longrightarrow> Suc k = 0 \\<or> P (Suc k)", "using assms Suc.IH"], ["proof (prove)\nusing this:\n  0 < n\n  P 1\n  \\<lbrakk>0 < ?n; P ?n\\<rbrakk> \\<Longrightarrow> P (Suc ?n)\n  k = 0 \\<or> P k\n\ngoal (2 subgoals):\n 1. Suc k = 1 \\<Longrightarrow> Suc k = 0 \\<or> P (Suc k)\n 2. 1 < Suc k \\<Longrightarrow> Suc k = 0 \\<or> P (Suc k)", "by auto"], ["proof (state)\nthis:\n  Suc k = 0 \\<or> P (Suc k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = 0 \\<or> P n\n\ngoal (1 subgoal):\n 1. P n", "then"], ["proof (chain)\npicking this:\n  n = 0 \\<or> P n", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<or> P n\n\ngoal (1 subgoal):\n 1. P n", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  n = 0 \\<or> P n\n  0 < n\n\ngoal (1 subgoal):\n 1. P n", "by auto"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma is certainly available somewhere, but I couldn't\nlocate it\\<close>"], ["", "lemma tends_to_real_e:\n  fixes u::\"nat \\<Rightarrow> real\"\n  assumes \"u \\<longlonglongrightarrow> l\" \"e>0\"\n  shows \"\\<exists>N. \\<forall>n>N. abs(u n -l) < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n>N. \\<bar>u n - l\\<bar> < e", "by (metis assms dist_real_def le_less lim_sequentially)"], ["", "lemma nat_mod_cong:\n  assumes \"a = b+(c::nat)\"\n          \"a mod n = b mod n\"\n  shows \"c mod n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c mod n = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c mod n = 0", "let ?k = \"a mod n\""], ["proof (state)\ngoal (1 subgoal):\n 1. c mod n = 0", "obtain a1 where \"a = a1*n + ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1.\n        a = a1 * n + a mod n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis div_mult_mod_eq)"], ["proof (state)\nthis:\n  a = a1 * n + a mod n\n\ngoal (1 subgoal):\n 1. c mod n = 0", "moreover"], ["proof (state)\nthis:\n  a = a1 * n + a mod n\n\ngoal (1 subgoal):\n 1. c mod n = 0", "obtain b1 where \"b = b1*n + ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b1.\n        b = b1 * n + a mod n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  a mod n = b mod n\n\ngoal (1 subgoal):\n 1. (\\<And>b1.\n        b = b1 * n + a mod n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis div_mult_mod_eq)"], ["proof (state)\nthis:\n  b = b1 * n + a mod n\n\ngoal (1 subgoal):\n 1. c mod n = 0", "ultimately"], ["proof (chain)\npicking this:\n  a = a1 * n + a mod n\n  b = b1 * n + a mod n", "have \"a1 * n + ?k = b1 * n + ?k + c\""], ["proof (prove)\nusing this:\n  a = a1 * n + a mod n\n  b = b1 * n + a mod n\n\ngoal (1 subgoal):\n 1. a1 * n + a mod n = b1 * n + a mod n + c", "using assms(1)"], ["proof (prove)\nusing this:\n  a = a1 * n + a mod n\n  b = b1 * n + a mod n\n  a = b + c\n\ngoal (1 subgoal):\n 1. a1 * n + a mod n = b1 * n + a mod n + c", "by arith"], ["proof (state)\nthis:\n  a1 * n + a mod n = b1 * n + a mod n + c\n\ngoal (1 subgoal):\n 1. c mod n = 0", "then"], ["proof (chain)\npicking this:\n  a1 * n + a mod n = b1 * n + a mod n + c", "have \"c = (a1 - b1) * n\""], ["proof (prove)\nusing this:\n  a1 * n + a mod n = b1 * n + a mod n + c\n\ngoal (1 subgoal):\n 1. c = (a1 - b1) * n", "by (simp add: diff_mult_distrib)"], ["proof (state)\nthis:\n  c = (a1 - b1) * n\n\ngoal (1 subgoal):\n 1. c mod n = 0", "then"], ["proof (chain)\npicking this:\n  c = (a1 - b1) * n", "show ?thesis"], ["proof (prove)\nusing this:\n  c = (a1 - b1) * n\n\ngoal (1 subgoal):\n 1. c mod n = 0", "by simp"], ["proof (state)\nthis:\n  c mod n = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma funpow_add': \"(f ^^ (m + n)) x = (f ^^ m) ((f ^^ n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ (m + n)) x = (f ^^ m) ((f ^^ n) x)", "by (simp add: funpow_add)"], ["", "text \\<open>The next two lemmas are not directly equivalent, since $f$ might\nnot be injective.\\<close>"], ["", "lemma abs_Max_sum:\n  fixes A::\"real set\"\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"abs(Max A) \\<le> (\\<Sum>a\\<in>A. abs(a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Max A\\<bar> \\<le> sum abs A", "by (simp add: assms member_le_sum)"], ["", "lemma abs_Max_sum2:\n  fixes f::\"_ \\<Rightarrow> real\"\n  assumes \"finite A\" \"A \\<noteq> {}\"\n  shows \"abs(Max (f`A)) \\<le> (\\<Sum>a\\<in>A. abs(f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Max (f ` A)\\<bar> \\<le> (\\<Sum>a\\<in>A. \\<bar>f a\\<bar>)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<bar>Max (f ` A)\\<bar> \\<le> (\\<Sum>a\\<in>A. \\<bar>f a\\<bar>)", "by (induct rule: finite_ne_induct, auto)"], ["", "subsection \\<open>Conditionally-Complete-Lattices.thy\\<close>"], ["", "lemma mono_cInf:\n  fixes f :: \"'a::conditionally_complete_lattice \\<Rightarrow> 'b::conditionally_complete_lattice\"\n  assumes \"mono f\" \"A \\<noteq> {}\" \"bdd_below A\"\n  shows \"f(Inf A) \\<le> Inf (f`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) \\<le> \\<Sqinter> (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  mono f\n  A \\<noteq> {}\n  bdd_below A\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) \\<le> \\<Sqinter> (f ` A)", "by (simp add: cINF_greatest cInf_lower monoD)"], ["", "lemma mono_bij_cInf:\n  fixes f :: \"'a::conditionally_complete_linorder \\<Rightarrow> 'b::conditionally_complete_linorder\"\n  assumes \"mono f\" \"bij f\" \"A \\<noteq> {}\" \"bdd_below A\"\n  shows \"f (Inf A) = Inf (f`A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "have \"(inv f) (Inf (f`A)) \\<le> Inf ((inv f)`(f`A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f (\\<Sqinter> (f ` A)) \\<le> \\<Sqinter> (inv f ` f ` A)", "apply (rule cInf_greatest, auto simp add: assms(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       xb \\<in> A \\<Longrightarrow>\n       inv f (\\<Sqinter> (f ` A)) \\<le> inv f (f xb)", "using mono_inv[OF assms(1) assms(2)] assms"], ["proof (prove)\nusing this:\n  mono (inv f)\n  mono f\n  bij f\n  A \\<noteq> {}\n  bdd_below A\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       xb \\<in> A \\<Longrightarrow>\n       inv f (\\<Sqinter> (f ` A)) \\<le> inv f (f xb)", "by (simp add: mono_def bdd_below_image_mono cInf_lower)"], ["proof (state)\nthis:\n  inv f (\\<Sqinter> (f ` A)) \\<le> \\<Sqinter> (inv f ` f ` A)\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "then"], ["proof (chain)\npicking this:\n  inv f (\\<Sqinter> (f ` A)) \\<le> \\<Sqinter> (inv f ` f ` A)", "have \"Inf (f`A) \\<le> f (Inf ((inv f)`(f`A)))\""], ["proof (prove)\nusing this:\n  inv f (\\<Sqinter> (f ` A)) \\<le> \\<Sqinter> (inv f ` f ` A)\n\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` A) \\<le> f (\\<Sqinter> (inv f ` f ` A))", "by (metis (no_types, lifting) assms(1) assms(2) mono_def bij_inv_eq_iff)"], ["proof (state)\nthis:\n  \\<Sqinter> (f ` A) \\<le> f (\\<Sqinter> (inv f ` f ` A))\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "also"], ["proof (state)\nthis:\n  \\<Sqinter> (f ` A) \\<le> f (\\<Sqinter> (inv f ` f ` A))\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "have \"... = f(Inf A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Sqinter> (inv f ` f ` A)) = f (\\<Sqinter> A)", "using assms"], ["proof (prove)\nusing this:\n  mono f\n  bij f\n  A \\<noteq> {}\n  bdd_below A\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> (inv f ` f ` A)) = f (\\<Sqinter> A)", "by (simp add: bij_is_inj)"], ["proof (state)\nthis:\n  f (\\<Sqinter> (inv f ` f ` A)) = f (\\<Sqinter> A)\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "finally"], ["proof (chain)\npicking this:\n  \\<Sqinter> (f ` A) \\<le> f (\\<Sqinter> A)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sqinter> (f ` A) \\<le> f (\\<Sqinter> A)\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "using mono_cInf[OF assms(1) assms(3) assms(4)]"], ["proof (prove)\nusing this:\n  \\<Sqinter> (f ` A) \\<le> f (\\<Sqinter> A)\n  f (\\<Sqinter> A) \\<le> \\<Sqinter> (f ` A)\n\ngoal (1 subgoal):\n 1. f (\\<Sqinter> A) = \\<Sqinter> (f ` A)", "by auto"], ["proof (state)\nthis:\n  f (\\<Sqinter> A) = \\<Sqinter> (f ` A)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Topological-spaces.thy\\<close>"], ["", "lemma open_less_abs [simp]:\n  \"open {x. (C::real) < abs x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {x. C < \\<bar>x\\<bar>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open {x. C < \\<bar>x\\<bar>}", "have *: \"{x. C < abs x} = abs-`{C<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. C < \\<bar>x\\<bar>} = abs -` {C<..}", "by auto"], ["proof (state)\nthis:\n  {x. C < \\<bar>x\\<bar>} = abs -` {C<..}\n\ngoal (1 subgoal):\n 1. open {x. C < \\<bar>x\\<bar>}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {x. C < \\<bar>x\\<bar>}", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (abs -` {C<..})", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  open {x. C < \\<bar>x\\<bar>}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_le_abs [simp]:\n  \"closed {x. (C::real) \\<le> abs x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. C \\<le> \\<bar>x\\<bar>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {x. C \\<le> \\<bar>x\\<bar>}", "have *: \"{x. C \\<le> \\<bar>x\\<bar>} = abs-`{C..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. C \\<le> \\<bar>x\\<bar>} = abs -` {C..}", "by auto"], ["proof (state)\nthis:\n  {x. C \\<le> \\<bar>x\\<bar>} = abs -` {C..}\n\ngoal (1 subgoal):\n 1. closed {x. C \\<le> \\<bar>x\\<bar>}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {x. C \\<le> \\<bar>x\\<bar>}", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (abs -` {C..})", "by (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  closed {x. C \\<le> \\<bar>x\\<bar>}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next statements come from the same statements for true subsequences\\<close>"], ["", "lemma eventually_weak_subseq:\n  fixes u::\"nat \\<Rightarrow> nat\"\n  assumes \"(\\<lambda>n. real(u n)) \\<longlonglongrightarrow> \\<infinity>\" \"eventually P sequentially\"\n  shows \"eventually (\\<lambda>n. P (u n)) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "obtain N where *: \"\\<forall>n\\<ge>N. P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>n\\<ge>N. P n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  eventually P sequentially\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>n\\<ge>N. P n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. P n\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>n\\<ge>N. P n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>N. P n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "obtain M where \"\\<forall>m\\<ge>M. ereal(u m) \\<ge> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           ereal (real N) \\<le> ereal (real (u m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (real (u x))) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           ereal (real N) \\<le> ereal (real (u m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson Lim_PInfty)"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>M. ereal (real N) \\<le> ereal (real (u m))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>M. ereal (real N) \\<le> ereal (real (u m))", "have \"\\<And>m. m \\<ge> M \\<Longrightarrow> u m \\<ge> N\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>M. ereal (real N) \\<le> ereal (real (u m))\n\ngoal (1 subgoal):\n 1. \\<And>m. M \\<le> m \\<Longrightarrow> N \\<le> u m", "by auto"], ["proof (state)\nthis:\n  M \\<le> ?m \\<Longrightarrow> N \\<le> u ?m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "then"], ["proof (chain)\npicking this:\n  M \\<le> ?m \\<Longrightarrow> N \\<le> u ?m", "have \"\\<And>m. m \\<ge> M \\<Longrightarrow> P(u m)\""], ["proof (prove)\nusing this:\n  M \\<le> ?m \\<Longrightarrow> N \\<le> u ?m\n\ngoal (1 subgoal):\n 1. \\<And>m. M \\<le> m \\<Longrightarrow> P (u m)", "using \\<open>\\<forall>n\\<ge>N. P n\\<close>"], ["proof (prove)\nusing this:\n  M \\<le> ?m \\<Longrightarrow> N \\<le> u ?m\n  \\<forall>n\\<ge>N. P n\n\ngoal (1 subgoal):\n 1. \\<And>m. M \\<le> m \\<Longrightarrow> P (u m)", "by simp"], ["proof (state)\nthis:\n  M \\<le> ?m \\<Longrightarrow> P (u ?m)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "then"], ["proof (chain)\npicking this:\n  M \\<le> ?m \\<Longrightarrow> P (u ?m)", "show ?thesis"], ["proof (prove)\nusing this:\n  M \\<le> ?m \\<Longrightarrow> P (u ?m)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. P (u n)", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  M \\<le> ?m \\<Longrightarrow> P (u ?m)\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. P (u n)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. P (u n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filterlim_weak_subseq:\n  fixes u::\"nat \\<Rightarrow> nat\"\n  assumes \"(\\<lambda>n. real(u n)) \\<longlonglongrightarrow> \\<infinity>\"\n  shows \"LIM n sequentially. u n:> at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterlim u sequentially sequentially", "unfolding filterlim_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P.\n       eventually P sequentially \\<longrightarrow>\n       (\\<forall>\\<^sub>F x in sequentially. P (u x))", "by (metis assms eventually_weak_subseq)"], ["", "lemma limit_along_weak_subseq:\n  fixes u::\"nat \\<Rightarrow> nat\" and v::\"nat \\<Rightarrow> _\"\n  assumes \"(\\<lambda>n. real(u n)) \\<longlonglongrightarrow> \\<infinity>\" \"v \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda> n. v(u n)) \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. v (u n)) \\<longlonglongrightarrow> l", "using filterlim_compose[of v, OF _ filterlim_weak_subseq] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>filterlim v ?F3.0 sequentially;\n   (\\<lambda>x. ereal (real (?f x)))\n   \\<longlonglongrightarrow> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> LIM x sequentially. v (?f x) :> ?F3.0\n  (\\<lambda>x. ereal (real (u x))) \\<longlonglongrightarrow> \\<infinity>\n  v \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. v (u n)) \\<longlonglongrightarrow> l", "by auto"], ["", "lemma frontier_indist_le:\n  assumes \"x \\<in> frontier {y. infdist y S \\<le> r}\"\n  shows \"infdist x S = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x S = r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x S = r", "have \"infdist x S = r\" if H: \"\\<forall>e>0. (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and> (\\<exists>z. \\<not> infdist z S \\<le> r \\<and> dist x z < e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x S = r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x S = r", "have \"infdist x S < r + e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x S < r + e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x S < r + e", "obtain y where \"infdist y S \\<le> r\" \"dist x y < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>infdist y S \\<le> r; dist x y < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using H \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z. \\<not> infdist z S \\<le> r \\<and> dist x z < e)\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>infdist y S \\<le> r; dist x y < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  infdist y S \\<le> r\n  dist x y < e\n\ngoal (1 subgoal):\n 1. infdist x S < r + e", "then"], ["proof (chain)\npicking this:\n  infdist y S \\<le> r\n  dist x y < e", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist y S \\<le> r\n  dist x y < e\n\ngoal (1 subgoal):\n 1. infdist x S < r + e", "by (metis add.commute add_mono_thms_linordered_field(3) infdist_triangle le_less_trans)"], ["proof (state)\nthis:\n  infdist x S < r + e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> infdist x S < r + ?e\n\ngoal (1 subgoal):\n 1. infdist x S = r", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> infdist x S < r + ?e", "have A: \"infdist x S \\<le> r\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> infdist x S < r + ?e\n\ngoal (1 subgoal):\n 1. infdist x S \\<le> r", "by (meson field_le_epsilon order.order_iff_strict)"], ["proof (state)\nthis:\n  infdist x S \\<le> r\n\ngoal (1 subgoal):\n 1. infdist x S = r", "have \"r < infdist x S + e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. r < infdist x S + e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r < infdist x S + e", "obtain y where \"\\<not>(infdist y S \\<le> r)\" \"dist x y < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>\\<not> infdist y S \\<le> r; dist x y < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using H \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z. \\<not> infdist z S \\<le> r \\<and> dist x z < e)\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>\\<not> infdist y S \\<le> r; dist x y < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<not> infdist y S \\<le> r\n  dist x y < e\n\ngoal (1 subgoal):\n 1. r < infdist x S + e", "then"], ["proof (chain)\npicking this:\n  \\<not> infdist y S \\<le> r\n  dist x y < e", "have \"r < infdist y S\""], ["proof (prove)\nusing this:\n  \\<not> infdist y S \\<le> r\n  dist x y < e\n\ngoal (1 subgoal):\n 1. r < infdist y S", "by auto"], ["proof (state)\nthis:\n  r < infdist y S\n\ngoal (1 subgoal):\n 1. r < infdist x S + e", "also"], ["proof (state)\nthis:\n  r < infdist y S\n\ngoal (1 subgoal):\n 1. r < infdist x S + e", "have \"... \\<le> infdist x S + dist y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y S \\<le> infdist x S + dist y x", "by (rule infdist_triangle)"], ["proof (state)\nthis:\n  infdist y S \\<le> infdist x S + dist y x\n\ngoal (1 subgoal):\n 1. r < infdist x S + e", "finally"], ["proof (chain)\npicking this:\n  r < infdist x S + dist y x", "show ?thesis"], ["proof (prove)\nusing this:\n  r < infdist x S + dist y x\n\ngoal (1 subgoal):\n 1. r < infdist x S + e", "using \\<open>dist x y < e\\<close>"], ["proof (prove)\nusing this:\n  r < infdist x S + dist y x\n  dist x y < e\n\ngoal (1 subgoal):\n 1. r < infdist x S + e", "by (simp add: dist_commute)"], ["proof (state)\nthis:\n  r < infdist x S + e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> r < infdist x S + ?e\n\ngoal (1 subgoal):\n 1. infdist x S = r", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> r < infdist x S + ?e", "have B: \"r \\<le> infdist x S\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> r < infdist x S + ?e\n\ngoal (1 subgoal):\n 1. r \\<le> infdist x S", "by (meson field_le_epsilon order.order_iff_strict)"], ["proof (state)\nthis:\n  r \\<le> infdist x S\n\ngoal (1 subgoal):\n 1. infdist x S = r", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x S = r", "using A B"], ["proof (prove)\nusing this:\n  infdist x S \\<le> r\n  r \\<le> infdist x S\n\ngoal (1 subgoal):\n 1. infdist x S = r", "by auto"], ["proof (state)\nthis:\n  infdist x S = r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z.\n         \\<not> infdist z S \\<le> r \\<and> dist x z < e) \\<Longrightarrow>\n  infdist x S = r\n\ngoal (1 subgoal):\n 1. infdist x S = r", "then"], ["proof (chain)\npicking this:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z.\n         \\<not> infdist z S \\<le> r \\<and> dist x z < e) \\<Longrightarrow>\n  infdist x S = r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z.\n         \\<not> infdist z S \\<le> r \\<and> dist x z < e) \\<Longrightarrow>\n  infdist x S = r\n\ngoal (1 subgoal):\n 1. infdist x S = r", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z.\n         \\<not> infdist z S \\<le> r \\<and> dist x z < e) \\<Longrightarrow>\n  infdist x S = r\n  x \\<in> frontier {y. infdist y S \\<le> r}\n\ngoal (1 subgoal):\n 1. infdist x S = r", "unfolding frontier_straddle"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     (\\<exists>y. infdist y S \\<le> r \\<and> dist x y < e) \\<and>\n     (\\<exists>z.\n         \\<not> infdist z S \\<le> r \\<and> dist x z < e) \\<Longrightarrow>\n  infdist x S = r\n  \\<forall>e>0.\n     (\\<exists>xa\\<in>{y. infdist y S \\<le> r}. dist x xa < e) \\<and>\n     (\\<exists>xa.\n         xa \\<notin> {y. infdist y S \\<le> r} \\<and> dist x xa < e)\n\ngoal (1 subgoal):\n 1. infdist x S = r", "by auto"], ["proof (state)\nthis:\n  infdist x S = r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Limits\\<close>"], ["", "text \\<open>The next lemmas are not very natural, but I needed them several times\\<close>"], ["", "lemma tendsto_shift_1_over_n [tendsto_intros]:\n  fixes f::\"nat \\<Rightarrow> real\"\n  assumes \"(\\<lambda>n. f n / n) \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda>n. f (n+k) / n) \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "have \"(1+k*(1/n))* (f(n+k)/(n+k)) = f(n+k)/n\" if \"n>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n    f (n + k) / real n", "using that"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n    f (n + k) / real n", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow>\n  (1 + real k * (1 / real ?n)) * (f (?n + k) / real (?n + k)) =\n  f (?n + k) / real ?n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "with eventually_mono[OF eventually_gt_at_top[of \"0::nat\"] this]"], ["proof (chain)\npicking this:\n  (\\<And>x. 0 < x \\<Longrightarrow> 0 < ?n1 x) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     (1 + real k * (1 / real (?n1 x))) *\n     (f (?n1 x + k) / real (?n1 x + k)) =\n     f (?n1 x + k) / real (?n1 x)\n  0 < ?n \\<Longrightarrow>\n  (1 + real k * (1 / real ?n)) * (f (?n + k) / real (?n + k)) =\n  f (?n + k) / real ?n", "have \"eventually (\\<lambda>n.(1+k*(1/n))* (f(n+k)/(n+k)) = f(n+k)/n) sequentially\""], ["proof (prove)\nusing this:\n  (\\<And>x. 0 < x \\<Longrightarrow> 0 < ?n1 x) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     (1 + real k * (1 / real (?n1 x))) *\n     (f (?n1 x + k) / real (?n1 x + k)) =\n     f (?n1 x + k) / real (?n1 x)\n  0 < ?n \\<Longrightarrow>\n  (1 + real k * (1 / real ?n)) * (f (?n + k) / real (?n + k)) =\n  f (?n + k) / real ?n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n       f (n + k) / real n", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n     f (n + k) / real n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n     f (n + k) / real n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "have \"(\\<lambda>n. (1+k*(1/n))* (f(n+k)/(n+k))) \\<longlonglongrightarrow> (1+real k*0) * l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)))\n    \\<longlonglongrightarrow> (1 + real k * 0) * l", "by (intro tendsto_intros LIMSEQ_ignore_initial_segment assms)"], ["proof (state)\nthis:\n  (\\<lambda>n. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)))\n  \\<longlonglongrightarrow> (1 + real k * 0) * l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n     f (n + k) / real n\n  (\\<lambda>n. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)))\n  \\<longlonglongrightarrow> (1 + real k * 0) * l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n     f (n + k) / real n\n  (\\<lambda>n. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)))\n  \\<longlonglongrightarrow> (1 + real k * 0) * l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "using Lim_transform_eventually"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)) =\n     f (n + k) / real n\n  (\\<lambda>n. (1 + real k * (1 / real n)) * (f (n + k) / real (n + k)))\n  \\<longlonglongrightarrow> (1 + real k * 0) * l\n  \\<lbrakk>(?f \\<longlongrightarrow> ?l) ?F;\n   \\<forall>\\<^sub>F x in ?F. ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> (?g \\<longlongrightarrow> ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. f (n + k) / real n) \\<longlonglongrightarrow> l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_shift_1_over_n' [tendsto_intros]:\n  fixes f::\"nat \\<Rightarrow> real\"\n  assumes \"(\\<lambda>n. f n / n) \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda>n. f (n-k) / n) \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "have \"(1-k*(1/(n+k)))* (f n/ n) = f n/(n+k)\" if \"n>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)", "using that"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow>\n  (1 - real k * (1 / real (?n + k))) * (f ?n / real ?n) =\n  f ?n / real (?n + k)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "with eventually_mono[OF eventually_gt_at_top[of \"0::nat\"] this]"], ["proof (chain)\npicking this:\n  (\\<And>x. 0 < x \\<Longrightarrow> 0 < ?n1 x) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     (1 - real k * (1 / real (?n1 x + k))) * (f (?n1 x) / real (?n1 x)) =\n     f (?n1 x) / real (?n1 x + k)\n  0 < ?n \\<Longrightarrow>\n  (1 - real k * (1 / real (?n + k))) * (f ?n / real ?n) =\n  f ?n / real (?n + k)", "have \"eventually (\\<lambda>n. (1-k*(1/(n+k)))* (f n/ n) = f n/(n+k)) sequentially\""], ["proof (prove)\nusing this:\n  (\\<And>x. 0 < x \\<Longrightarrow> 0 < ?n1 x) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     (1 - real k * (1 / real (?n1 x + k))) * (f (?n1 x) / real (?n1 x)) =\n     f (?n1 x) / real (?n1 x + k)\n  0 < ?n \\<Longrightarrow>\n  (1 - real k * (1 / real (?n + k))) * (f ?n / real ?n) =\n  f ?n / real (?n + k)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       (1 - real k * (1 / real (n + k))) * (f n / real n) =\n       f n / real (n + k)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "have \"(\\<lambda>n. (1-k*(1/(n+k)))* (f n/ n)) \\<longlonglongrightarrow> (1-real k*0) * l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (1 - real k * (1 / real (n + k))) * (f n / real n))\n    \\<longlonglongrightarrow> (1 - real k * 0) * l", "by (intro tendsto_intros assms LIMSEQ_ignore_initial_segment)"], ["proof (state)\nthis:\n  (\\<lambda>n. (1 - real k * (1 / real (n + k))) * (f n / real n))\n  \\<longlonglongrightarrow> (1 - real k * 0) * l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)\n  (\\<lambda>n. (1 - real k * (1 / real (n + k))) * (f n / real n))\n  \\<longlonglongrightarrow> (1 - real k * 0) * l", "have \"(\\<lambda>n. f n / (n+k)) \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)\n  (\\<lambda>n. (1 - real k * (1 / real (n + k))) * (f n / real n))\n  \\<longlonglongrightarrow> (1 - real k * 0) * l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f n / real (n + k)) \\<longlonglongrightarrow> l", "using Lim_transform_eventually"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     (1 - real k * (1 / real (n + k))) * (f n / real n) = f n / real (n + k)\n  (\\<lambda>n. (1 - real k * (1 / real (n + k))) * (f n / real n))\n  \\<longlonglongrightarrow> (1 - real k * 0) * l\n  \\<lbrakk>(?f \\<longlongrightarrow> ?l) ?F;\n   \\<forall>\\<^sub>F x in ?F. ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> (?g \\<longlongrightarrow> ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f n / real (n + k)) \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. f n / real (n + k)) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. f n / real (n + k)) \\<longlonglongrightarrow> l", "have a: \"(\\<lambda>n. f(n-k)/(n-k+k)) \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. f n / real (n + k)) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real (n - k + k)) \\<longlonglongrightarrow> l", "using seq_offset_neg"], ["proof (prove)\nusing this:\n  (\\<lambda>n. f n / real (n + k)) \\<longlonglongrightarrow> l\n  ?f \\<longlonglongrightarrow> ?l \\<Longrightarrow>\n  (\\<lambda>i. ?f (i - ?k)) \\<longlonglongrightarrow> ?l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real (n - k + k)) \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. f (n - k) / real (n - k + k)) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "have \"f(n-k)/(n-k+k) = f(n-k)/n\" if \"n>k\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (n - k) / real (n - k + k) = f (n - k) / real n", "using that"], ["proof (prove)\nusing this:\n  k < n\n\ngoal (1 subgoal):\n 1. f (n - k) / real (n - k + k) = f (n - k) / real n", "by auto"], ["proof (state)\nthis:\n  k < ?n \\<Longrightarrow>\n  f (?n - k) / real (?n - k + k) = f (?n - k) / real ?n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "with eventually_mono[OF eventually_gt_at_top[of k] this]"], ["proof (chain)\npicking this:\n  (\\<And>x. k < x \\<Longrightarrow> k < ?n1 x) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     f (?n1 x - k) / real (?n1 x - k + k) = f (?n1 x - k) / real (?n1 x)\n  k < ?n \\<Longrightarrow>\n  f (?n - k) / real (?n - k + k) = f (?n - k) / real ?n", "have \"eventually (\\<lambda>n. f(n-k)/(n-k+k) = f(n-k)/n) sequentially\""], ["proof (prove)\nusing this:\n  (\\<And>x. k < x \\<Longrightarrow> k < ?n1 x) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     f (?n1 x - k) / real (?n1 x - k + k) = f (?n1 x - k) / real (?n1 x)\n  k < ?n \\<Longrightarrow>\n  f (?n - k) / real (?n - k + k) = f (?n - k) / real ?n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       f (n - k) / real (n - k + k) = f (n - k) / real n", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     f (n - k) / real (n - k + k) = f (n - k) / real n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "with Lim_transform_eventually[OF a this]"], ["proof (chain)\npicking this:\n  (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l\n  \\<forall>\\<^sub>F n in sequentially.\n     f (n - k) / real (n - k + k) = f (n - k) / real n", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l\n  \\<forall>\\<^sub>F n in sequentially.\n     f (n - k) / real (n - k + k) = f (n - k) / real n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. f (n - k) / real n) \\<longlonglongrightarrow> l\n\ngoal:\nNo subgoals!", "qed"], ["", "declare LIMSEQ_realpow_zero [tendsto_intros]"], ["", "subsection \\<open>Topology-Euclidean-Space\\<close>"], ["", "text \\<open>A (more usable) variation around \\verb+continuous_on_closure_sequentially+. The assumption\nthat the spaces are metric spaces is definitely too strong, but sufficient for most applications.\\<close>"], ["", "lemma continuous_on_closure_sequentially':\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\"\n  assumes \"continuous_on (closure C) f\"\n          \"\\<And>(n::nat). u n \\<in> C\"\n          \"u \\<longlonglongrightarrow> l\"\n  shows \"(\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "have \"l \\<in> closure C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> closure C", "unfolding closure_sequential"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (\\<forall>n. x n \\<in> C) \\<and> x \\<longlonglongrightarrow> l", "using assms"], ["proof (prove)\nusing this:\n  continuous_on (closure C) f\n  u ?n \\<in> C\n  u \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       (\\<forall>n. x n \\<in> C) \\<and> x \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  l \\<in> closure C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "then"], ["proof (chain)\npicking this:\n  l \\<in> closure C", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<in> closure C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "using \\<open>continuous_on (closure C) f\\<close>"], ["proof (prove)\nusing this:\n  l \\<in> closure C\n  continuous_on (closure C) f\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "unfolding comp_def continuous_on_closure_sequentially"], ["proof (prove)\nusing this:\n  l \\<in> closure C\n  \\<forall>x a.\n     a \\<in> closure C \\<and>\n     (\\<forall>n. x n \\<in> C) \\<and>\n     x \\<longlonglongrightarrow> a \\<longrightarrow>\n     (\\<lambda>xa. f (x xa)) \\<longlonglongrightarrow> f a\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "using assms"], ["proof (prove)\nusing this:\n  l \\<in> closure C\n  \\<forall>x a.\n     a \\<in> closure C \\<and>\n     (\\<forall>n. x n \\<in> C) \\<and>\n     x \\<longlonglongrightarrow> a \\<longrightarrow>\n     (\\<lambda>xa. f (x xa)) \\<longlonglongrightarrow> f a\n  continuous_on (closure C) f\n  u ?n \\<in> C\n  u \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. f (u n)) \\<longlonglongrightarrow> f l\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Convexity\\<close>"], ["", "lemma convex_on_mean_ineq:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"convex_on A f\" \"x \\<in> A\" \"y \\<in> A\"\n  shows \"f ((x+y)/2) \\<le> (f x + f y) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ((x + y) / 2) \\<le> (f x + f y) / 2", "using convex_onD[OF assms(1), of \"1/2\" x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / 2; 1 / 2 \\<le> 1; x \\<in> A; y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> f ((1 - 1 / 2) *\\<^sub>R x + (1 / 2) *\\<^sub>R y)\n                    \\<le> (1 - 1 / 2) * f x + 1 / 2 * f y\n\ngoal (1 subgoal):\n 1. f ((x + y) / 2) \\<le> (f x + f y) / 2", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / 2; 1 / 2 \\<le> 1; x \\<in> A; y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> f ((1 - 1 / 2) *\\<^sub>R x + (1 / 2) *\\<^sub>R y)\n                    \\<le> (1 - 1 / 2) * f x + 1 / 2 * f y\n  convex_on A f\n  x \\<in> A\n  y \\<in> A\n\ngoal (1 subgoal):\n 1. f ((x + y) / 2) \\<le> (f x + f y) / 2", "by (auto simp add: divide_simps)"], ["", "lemma convex_on_closure:\n  assumes \"convex (C::'a::real_normed_vector set)\"\n          \"convex_on C f\"\n          \"continuous_on (closure C) f\"\n  shows \"convex_on (closure C) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on (closure C) f", "proof (rule convex_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "fix x y::'a and t::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "assume \"x \\<in> closure C\" \"y \\<in> closure C\" \"0 < t\" \"t < 1\""], ["proof (state)\nthis:\n  x \\<in> closure C\n  y \\<in> closure C\n  0 < t\n  t < 1\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "obtain u v::\"nat \\<Rightarrow> 'a\" where *: \"\\<And>n. u n \\<in> C\" \"u \\<longlonglongrightarrow> x\"\n                                   \"\\<And>n. v n \\<in> C\" \"v \\<longlonglongrightarrow> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>\\<And>n. u n \\<in> C; u \\<longlonglongrightarrow> x;\n         \\<And>n. v n \\<in> C; v \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> closure C\\<close> \\<open>y \\<in> closure C\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> closure C\n  y \\<in> closure C\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>\\<And>n. u n \\<in> C; u \\<longlonglongrightarrow> x;\n         \\<And>n. v n \\<in> C; v \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding closure_sequential"], ["proof (prove)\nusing this:\n  \\<exists>xa.\n     (\\<forall>n. xa n \\<in> C) \\<and> xa \\<longlonglongrightarrow> x\n  \\<exists>x. (\\<forall>n. x n \\<in> C) \\<and> x \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>\\<And>n. u n \\<in> C; u \\<longlonglongrightarrow> x;\n         \\<And>n. v n \\<in> C; v \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u ?n \\<in> C\n  u \\<longlonglongrightarrow> x\n  v ?n \\<in> C\n  v \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "define w where \"w = (\\<lambda>n. (1-t) *\\<^sub>R (u n) + t *\\<^sub>R (v n))\""], ["proof (state)\nthis:\n  w = (\\<lambda>n. (1 - t) *\\<^sub>R u n + t *\\<^sub>R v n)\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "have \"w n \\<in> C\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. w n \\<in> C", "using \\<open>0 < t\\<close> \\<open>t< 1\\<close> convexD[OF \\<open>convex C\\<close> *(1)[of n] *(3)[of n]]"], ["proof (prove)\nusing this:\n  0 < t\n  t < 1\n  \\<lbrakk>0 \\<le> ?u; 0 \\<le> ?v; ?u + ?v = 1\\<rbrakk>\n  \\<Longrightarrow> ?u *\\<^sub>R u n + ?v *\\<^sub>R v n \\<in> C\n\ngoal (1 subgoal):\n 1. w n \\<in> C", "unfolding w_def"], ["proof (prove)\nusing this:\n  0 < t\n  t < 1\n  \\<lbrakk>0 \\<le> ?u; 0 \\<le> ?v; ?u + ?v = 1\\<rbrakk>\n  \\<Longrightarrow> ?u *\\<^sub>R u n + ?v *\\<^sub>R v n \\<in> C\n\ngoal (1 subgoal):\n 1. (1 - t) *\\<^sub>R u n + t *\\<^sub>R v n \\<in> C", "by auto"], ["proof (state)\nthis:\n  w ?n \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "have \"w \\<longlonglongrightarrow> ((1-t) *\\<^sub>R x + t *\\<^sub>R y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<longlonglongrightarrow> (1 - t) *\\<^sub>R x + t *\\<^sub>R y", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (1 - t) *\\<^sub>R u n + t *\\<^sub>R v n)\n    \\<longlonglongrightarrow> (1 - t) *\\<^sub>R x + t *\\<^sub>R y", "using *(2) *(4)"], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> x\n  v \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. (1 - t) *\\<^sub>R u n + t *\\<^sub>R v n)\n    \\<longlonglongrightarrow> (1 - t) *\\<^sub>R x + t *\\<^sub>R y", "by (intro tendsto_intros)"], ["proof (state)\nthis:\n  w \\<longlonglongrightarrow> (1 - t) *\\<^sub>R x + t *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "have *: \"f(w n) \\<le> (1-t) * f(u n) + t * f (v n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (w n) \\<le> (1 - t) * f (u n) + t * f (v n)", "using *(1) *(3) \\<open>convex_on C f\\<close> \\<open>0<t\\<close> \\<open>t<1\\<close> less_imp_le"], ["proof (prove)\nusing this:\n  u ?n \\<in> C\n  v ?n \\<in> C\n  convex_on C f\n  0 < t\n  t < 1\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. f (w n) \\<le> (1 - t) * f (u n) + t * f (v n)", "unfolding w_def\n    convex_on_alt"], ["proof (prove)\nusing this:\n  u ?n \\<in> C\n  v ?n \\<in> C\n  \\<forall>x\\<in>C.\n     \\<forall>y\\<in>C.\n        \\<forall>\\<mu>.\n           0 \\<le> \\<mu> \\<and> \\<mu> \\<le> 1 \\<longrightarrow>\n           f (\\<mu> *\\<^sub>R x + (1 - \\<mu>) *\\<^sub>R y)\n           \\<le> \\<mu> * f x + (1 - \\<mu>) * f y\n  0 < t\n  t < 1\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. f ((1 - t) *\\<^sub>R u n + t *\\<^sub>R v n)\n    \\<le> (1 - t) * f (u n) + t * f (v n)", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  f (w ?n) \\<le> (1 - t) * f (u ?n) + t * f (v ?n)\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "have i: \"(\\<lambda>n. f (w n)) \\<longlonglongrightarrow> f ((1-t) *\\<^sub>R x + t *\\<^sub>R y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (w n))\n    \\<longlonglongrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)", "by (rule continuous_on_closure_sequentially'[OF assms(3) \\<open>\\<And>n. w n \\<in> C\\<close> \\<open>w \\<longlonglongrightarrow> ((1-t) *\\<^sub>R x + t *\\<^sub>R y)\\<close>])"], ["proof (state)\nthis:\n  (\\<lambda>n. f (w n))\n  \\<longlonglongrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "have ii: \"(\\<lambda>n. (1-t) * f(u n) + t * f (v n)) \\<longlonglongrightarrow> (1-t) * f x + t * f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (1 - t) * f (u n) + t * f (v n))\n    \\<longlonglongrightarrow> (1 - t) * f x + t * f y", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. f (u x)) \\<longlonglongrightarrow> f x\n 2. (\\<lambda>x. f (v x)) \\<longlonglongrightarrow> f y", "apply (rule continuous_on_closure_sequentially'[OF assms(3) \\<open>\\<And>n. u n \\<in> C\\<close> \\<open>u \\<longlonglongrightarrow> x\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (v x)) \\<longlonglongrightarrow> f y", "apply (rule continuous_on_closure_sequentially'[OF assms(3) \\<open>\\<And>n. v n \\<in> C\\<close> \\<open>v \\<longlonglongrightarrow> y\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>n. (1 - t) * f (u n) + t * f (v n))\n  \\<longlonglongrightarrow> (1 - t) * f x + t * f y\n\ngoal (1 subgoal):\n 1. \\<And>t x y.\n       \\<lbrakk>0 < t; t < 1; x \\<in> closure C; y \\<in> closure C\\<rbrakk>\n       \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y)\n                         \\<le> (1 - t) * f x + t * f y", "show \"f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y) \\<le> (1 - t) * f x + t * f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y) \\<le> (1 - t) * f x + t * f y", "apply (rule LIMSEQ_le[OF i ii])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. f (w n) \\<le> (1 - t) * f (u n) + t * f (v n)", "using *"], ["proof (prove)\nusing this:\n  f (w ?n) \\<le> (1 - t) * f (u ?n) + t * f (v ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. f (w n) \\<le> (1 - t) * f (u n) + t * f (v n)", "by auto"], ["proof (state)\nthis:\n  f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y) \\<le> (1 - t) * f x + t * f y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convex_on_norm [simp]:\n  \"convex_on UNIV (\\<lambda>(x::'a::real_normed_vector). norm x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on UNIV norm", "using convex_on_dist[of UNIV \"0::'a\"]"], ["proof (prove)\nusing this:\n  convex_on UNIV (dist (0::'a))\n\ngoal (1 subgoal):\n 1. convex_on UNIV norm", "by auto"], ["", "lemma continuous_abs_powr [continuous_intros]:\n  assumes \"p > 0\"\n  shows \"continuous_on UNIV (\\<lambda>(x::real). \\<bar>x\\<bar> powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "apply (rule continuous_on_powr')"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on UNIV abs\n 2. continuous_on UNIV (\\<lambda>x. p)\n 3. \\<forall>x\\<in>UNIV.\n       0 \\<le> \\<bar>x\\<bar> \\<and>\n       (\\<bar>x\\<bar> = 0 \\<longrightarrow> 0 < p)", "using assms"], ["proof (prove)\nusing this:\n  0 < p\n\ngoal (3 subgoals):\n 1. continuous_on UNIV abs\n 2. continuous_on UNIV (\\<lambda>x. p)\n 3. \\<forall>x\\<in>UNIV.\n       0 \\<le> \\<bar>x\\<bar> \\<and>\n       (\\<bar>x\\<bar> = 0 \\<longrightarrow> 0 < p)", "by (auto intro: continuous_intros)"], ["", "lemma continuous_mult_sgn [continuous_intros]:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on UNIV f\" \"f 0 = 0\"\n  shows \"continuous_on UNIV (\\<lambda>x. sgn x * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * f x)", "have *: \"continuous_on {0..} (\\<lambda>x. sgn x * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..} (\\<lambda>x. sgn x * f x)", "apply (subst continuous_on_cong[of \"{0..}\" \"{0..}\" _ f], auto simp add: sgn_real_def assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..} f", "by (rule continuous_on_subset[OF assms(1)], auto)"], ["proof (state)\nthis:\n  continuous_on {0..} (\\<lambda>x. sgn x * f x)\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * f x)", "have **: \"continuous_on {..0} (\\<lambda>x. sgn x * f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {..0} (\\<lambda>x. sgn x * f x)", "apply (subst continuous_on_cong[of \"{..0}\" \"{..0}\" _ \"\\<lambda>x. -f x\"], auto simp add: sgn_real_def assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {..0} (\\<lambda>x. - f x)", "by (rule continuous_on_subset[of UNIV], auto simp add: assms intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {..0} (\\<lambda>x. sgn x * f x)\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * f x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * f x)", "using continuous_on_closed_Un[OF _ _ * **]"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed {0..}; closed {..0}\\<rbrakk>\n  \\<Longrightarrow> continuous_on ({0..} \\<union> {..0})\n                     (\\<lambda>x. sgn x * f x)\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * f x)", "apply (auto intro: continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on ({0..} \\<union> {..0})\n     (\\<lambda>x. sgn x * f x) \\<Longrightarrow>\n    continuous_on UNIV (\\<lambda>x. sgn x * f x)", "using continuous_on_subset"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_on ?s ?f; ?t \\<subseteq> ?s\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?t ?f\n\ngoal (1 subgoal):\n 1. continuous_on ({0..} \\<union> {..0})\n     (\\<lambda>x. sgn x * f x) \\<Longrightarrow>\n    continuous_on UNIV (\\<lambda>x. sgn x * f x)", "by fastforce"], ["proof (state)\nthis:\n  continuous_on UNIV (\\<lambda>x. sgn x * f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DERIV_abs_powr [derivative_intros]:\n  assumes \"p > (1::real)\"\n  shows \"DERIV (\\<lambda>x. \\<bar>x\\<bar> powr p) x :> p * sgn x * \\<bar>x\\<bar> powr (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "consider \"x = 0\" | \"x>0\" | \"x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis; 0 < x \\<Longrightarrow> thesis;\n     x < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>x = 0 \\<Longrightarrow> ?thesis; 0 < x \\<Longrightarrow> ?thesis;\n   x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = 0 \\<Longrightarrow> ?thesis; 0 < x \\<Longrightarrow> ?thesis;\n   x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = 0 \\<Longrightarrow> ?thesis; 0 < x \\<Longrightarrow> ?thesis;\n   x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "case 1"], ["proof (state)\nthis:\n  x = 0\n\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "have \"continuous_on UNIV (\\<lambda>x. sgn x * \\<bar>x\\<bar> powr (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. sgn x * \\<bar>x\\<bar> powr (p - 1))", "by (auto simp add: assms intro!:continuous_intros)"], ["proof (state)\nthis:\n  continuous_on UNIV (\\<lambda>x. sgn x * \\<bar>x\\<bar> powr (p - 1))\n\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "then"], ["proof (chain)\npicking this:\n  continuous_on UNIV (\\<lambda>x. sgn x * \\<bar>x\\<bar> powr (p - 1))", "have \"(\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p-1)) \\<midarrow>0\\<rightarrow> (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p-1)) 0\""], ["proof (prove)\nusing this:\n  continuous_on UNIV (\\<lambda>x. sgn x * \\<bar>x\\<bar> powr (p - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p - 1)) \\<midarrow>0\n    \\<rightarrow> sgn 0 * \\<bar>0\\<bar> powr (p - 1)", "using continuous_on_def"], ["proof (prove)\nusing this:\n  continuous_on UNIV (\\<lambda>x. sgn x * \\<bar>x\\<bar> powr (p - 1))\n  continuous_on ?s ?f =\n  (\\<forall>x\\<in>?s. (?f \\<longlongrightarrow> ?f x) (at x within ?s))\n\ngoal (1 subgoal):\n 1. (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p - 1)) \\<midarrow>0\n    \\<rightarrow> sgn 0 * \\<bar>0\\<bar> powr (p - 1)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p - 1)) \\<midarrow>0\n  \\<rightarrow> sgn 0 * \\<bar>0\\<bar> powr (p - 1)\n\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p - 1)) \\<midarrow>0\n  \\<rightarrow> sgn 0 * \\<bar>0\\<bar> powr (p - 1)\n\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "have \"\\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p-1)\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "have \"\\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar>", "by (auto simp add: algebra_simps divide_simps sgn_real_def)"], ["proof (state)\nthis:\n  \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "also"], ["proof (state)\nthis:\n  \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "have \"... = sgn h * \\<bar>h\\<bar> powr (p-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar> =\n    sgn h * \\<bar>h\\<bar> powr (p - 1)", "using assms"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar> =\n    sgn h * \\<bar>h\\<bar> powr (p - 1)", "apply (cases \"h = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 < p; h = 0\\<rbrakk>\n    \\<Longrightarrow> sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar> =\n                      sgn h * \\<bar>h\\<bar> powr (p - 1)\n 2. \\<lbrakk>1 < p; h \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar> =\n                      sgn h * \\<bar>h\\<bar> powr (p - 1)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 < p; h \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar> =\n                      sgn h * \\<bar>h\\<bar> powr (p - 1)", "by (metis abs_ge_zero powr_diff [symmetric] powr_one_gt_zero_iff times_divide_eq_right)"], ["proof (state)\nthis:\n  sgn h * \\<bar>h\\<bar> powr p / \\<bar>h\\<bar> =\n  sgn h * \\<bar>h\\<bar> powr (p - 1)\n\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "finally"], ["proof (chain)\npicking this:\n  \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)\n\ngoal (1 subgoal):\n 1. \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)", "by simp"], ["proof (state)\nthis:\n  \\<bar>h\\<bar> powr p / h = sgn h * \\<bar>h\\<bar> powr (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>?h\\<bar> powr p / ?h = sgn ?h * \\<bar>?h\\<bar> powr (p - 1)\n\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p - 1)) \\<midarrow>0\n  \\<rightarrow> sgn 0 * \\<bar>0\\<bar> powr (p - 1)\n  \\<bar>?h\\<bar> powr p / ?h = sgn ?h * \\<bar>?h\\<bar> powr (p - 1)", "have \"(\\<lambda>h. \\<bar>h\\<bar> powr p / h) \\<midarrow>0\\<rightarrow> 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>h. sgn h * \\<bar>h\\<bar> powr (p - 1)) \\<midarrow>0\n  \\<rightarrow> sgn 0 * \\<bar>0\\<bar> powr (p - 1)\n  \\<bar>?h\\<bar> powr p / ?h = sgn ?h * \\<bar>?h\\<bar> powr (p - 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>h. \\<bar>h\\<bar> powr p / h) \\<midarrow>0\\<rightarrow> 0", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>h. \\<bar>h\\<bar> powr p / h) \\<midarrow>0\\<rightarrow> 0\n\ngoal (3 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 3. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>h. \\<bar>h\\<bar> powr p / h) \\<midarrow>0\\<rightarrow> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>h. \\<bar>h\\<bar> powr p / h) \\<midarrow>0\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "unfolding DERIV_def"], ["proof (prove)\nusing this:\n  (\\<lambda>h. \\<bar>h\\<bar> powr p / h) \\<midarrow>0\\<rightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>h. (\\<bar>x + h\\<bar> powr p - \\<bar>x\\<bar> powr p) / h)\n    \\<midarrow>0\\<rightarrow> p * sgn x * \\<bar>x\\<bar> powr (p - 1)", "by (auto simp add: \\<open>x = 0\\<close>)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n   p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n   (at x)\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "case 2"], ["proof (state)\nthis:\n  0 < x\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "have *: \"\\<forall>\\<^sub>F y in nhds x. \\<bar>y\\<bar> powr p = y powr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F y in nhds x. \\<bar>y\\<bar> powr p = y powr p", "unfolding eventually_nhds"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S.\n       open S \\<and>\n       x \\<in> S \\<and> (\\<forall>y\\<in>S. \\<bar>y\\<bar> powr p = y powr p)", "apply (rule exI[of _ \"{0<..}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {0<..} \\<and>\n    x \\<in> {0<..} \\<and>\n    (\\<forall>y\\<in>{0<..}. \\<bar>y\\<bar> powr p = y powr p)", "using \\<open>x > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. open {0<..} \\<and>\n    x \\<in> {0<..} \\<and>\n    (\\<forall>y\\<in>{0<..}. \\<bar>y\\<bar> powr p = y powr p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F y in nhds x. \\<bar>y\\<bar> powr p = y powr p\n\ngoal (2 subgoals):\n 1. 0 < x \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)\n 2. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "apply (subst DERIV_cong_ev[of _ x _ \"(\\<lambda>x. x powr p)\" _ \"p * x powr (p-1)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. x = x\n 2. \\<forall>\\<^sub>F x in nhds x. \\<bar>x\\<bar> powr p = x powr p\n 3. p * sgn x * \\<bar>x\\<bar> powr (p - 1) = p * x powr (p - 1)\n 4. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "using \\<open>x > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (4 subgoals):\n 1. x = x\n 2. \\<forall>\\<^sub>F x in nhds x. \\<bar>x\\<bar> powr p = x powr p\n 3. p * sgn x * \\<bar>x\\<bar> powr (p - 1) = p * x powr (p - 1)\n 4. ((\\<lambda>x. x powr p) has_real_derivative p * x powr (p - 1)) (at x)", "by (auto simp add: * has_real_derivative_powr)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n   p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n   (at x)\n\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "case 3"], ["proof (state)\nthis:\n  x < 0\n\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "have *: \"\\<forall>\\<^sub>F y in nhds x. \\<bar>y\\<bar> powr p = (-y) powr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F y in nhds x. \\<bar>y\\<bar> powr p = (- y) powr p", "unfolding eventually_nhds"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S.\n       open S \\<and>\n       x \\<in> S \\<and>\n       (\\<forall>y\\<in>S. \\<bar>y\\<bar> powr p = (- y) powr p)", "apply (rule exI[of _ \"{..<0}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {..<0} \\<and>\n    x \\<in> {..<0} \\<and>\n    (\\<forall>y\\<in>{..<0}. \\<bar>y\\<bar> powr p = (- y) powr p)", "using \\<open>x < 0\\<close>"], ["proof (prove)\nusing this:\n  x < 0\n\ngoal (1 subgoal):\n 1. open {..<0} \\<and>\n    x \\<in> {..<0} \\<and>\n    (\\<forall>y\\<in>{..<0}. \\<bar>y\\<bar> powr p = (- y) powr p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F y in nhds x. \\<bar>y\\<bar> powr p = (- y) powr p\n\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow>\n    ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "apply (subst DERIV_cong_ev[of _ x _ \"(\\<lambda>x. (-x) powr p)\" _ \"p * (- x) powr (p - real 1) * - 1\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. x = x\n 2. \\<forall>\\<^sub>F x in nhds x. \\<bar>x\\<bar> powr p = (- x) powr p\n 3. p * sgn x * \\<bar>x\\<bar> powr (p - 1) =\n    p * (- x) powr (p - real 1) * - 1\n 4. ((\\<lambda>x. (- x) powr p) has_real_derivative\n     p * (- x) powr (p - real 1) * - 1)\n     (at x)", "using \\<open>x < 0\\<close>"], ["proof (prove)\nusing this:\n  x < 0\n\ngoal (4 subgoals):\n 1. x = x\n 2. \\<forall>\\<^sub>F x in nhds x. \\<bar>x\\<bar> powr p = (- x) powr p\n 3. p * sgn x * \\<bar>x\\<bar> powr (p - 1) =\n    p * (- x) powr (p - real 1) * - 1\n 4. ((\\<lambda>x. (- x) powr p) has_real_derivative\n     p * (- x) powr (p - real 1) * - 1)\n     (at x)", "apply (simp, simp add: *, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (- x) powr p) has_real_derivative\n     p * (- x) powr (p - real 1) * - 1)\n     (at x)", "apply (rule DERIV_fun_powr[of \"\\<lambda>y. -y\" \"-1\" \"x\" p])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uminus has_real_derivative - 1) (at x)\n 2. 0 < - x", "using \\<open>x < 0\\<close>"], ["proof (prove)\nusing this:\n  x < 0\n\ngoal (2 subgoals):\n 1. (uminus has_real_derivative - 1) (at x)\n 2. 0 < - x", "by (auto simp add: derivative_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n   p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n   p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n   (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convex_abs_powr:\n  assumes \"p \\<ge> 1\"\n  shows \"convex_on UNIV (\\<lambda>x::real. \\<bar>x\\<bar> powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "proof (cases \"p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n 2. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "case True"], ["proof (state)\nthis:\n  p = 1\n\ngoal (2 subgoals):\n 1. p = 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n 2. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "have \"convex_on UNIV (\\<lambda>x::real. norm x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on UNIV norm", "by (rule convex_on_norm)"], ["proof (state)\nthis:\n  convex_on UNIV norm\n\ngoal (2 subgoals):\n 1. p = 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n 2. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "moreover"], ["proof (state)\nthis:\n  convex_on UNIV norm\n\ngoal (2 subgoals):\n 1. p = 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n 2. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "have \"\\<bar>x\\<bar> powr p = norm x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> powr p = norm x", "using True"], ["proof (prove)\nusing this:\n  p = 1\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> powr p = norm x", "by auto"], ["proof (state)\nthis:\n  \\<bar>?x\\<bar> powr p = norm ?x\n\ngoal (2 subgoals):\n 1. p = 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n 2. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "ultimately"], ["proof (chain)\npicking this:\n  convex_on UNIV norm\n  \\<bar>?x\\<bar> powr p = norm ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  convex_on UNIV norm\n  \\<bar>?x\\<bar> powr p = norm ?x\n\ngoal (1 subgoal):\n 1. convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "by simp"], ["proof (state)\nthis:\n  convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 1", "have \"p > 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 1\n  1 \\<le> p\n\ngoal (1 subgoal):\n 1. 1 < p", "by auto"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "define g where \"g = (\\<lambda>x::real. p * sgn x * \\<bar>x\\<bar> powr (p - 1))\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "have *: \"DERIV (\\<lambda>x. \\<bar>x\\<bar> powr p) x :> g x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative g x) (at x)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "using \\<open>p>1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative\n     p * sgn x * \\<bar>x\\<bar> powr (p - 1))\n     (at x)", "by (intro derivative_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative g ?x) (at ?x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "have **: \"g x \\<le> g y\" if \"x \\<le> y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g x \\<le> g y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g x \\<le> g y", "consider \"x \\<ge> 0 \\<and> y \\<ge> 0\" | \"x \\<le> 0 \\<and> y \\<le> 0\" | \"x < 0 \\<and> y > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> thesis;\n     x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> thesis;\n     x < 0 \\<and> 0 < y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> thesis;\n     x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> thesis;\n     x < 0 \\<and> 0 < y \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> ?thesis;\n   x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> ?thesis;\n   x < 0 \\<and> 0 < y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. g x \\<le> g y", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> ?thesis;\n   x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> ?thesis;\n   x < 0 \\<and> 0 < y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> ?thesis;\n   x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> ?thesis;\n   x < 0 \\<and> 0 < y \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. g x \\<le> g y", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> g x \\<le> g y\n 2. x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> g x \\<le> g y\n 3. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "case 1"], ["proof (state)\nthis:\n  0 \\<le> x \\<and> 0 \\<le> y\n\ngoal (3 subgoals):\n 1. 0 \\<le> x \\<and> 0 \\<le> y \\<Longrightarrow> g x \\<le> g y\n 2. x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> g x \\<le> g y\n 3. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "then"], ["proof (chain)\npicking this:\n  0 \\<le> x \\<and> 0 \\<le> y", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> 0 \\<le> y\n\ngoal (1 subgoal):\n 1. g x \\<le> g y", "unfolding g_def sgn_real_def"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> 0 \\<le> y\n\ngoal (1 subgoal):\n 1. p * (if x = 0 then 0 else if 0 < x then 1 else - 1) *\n    \\<bar>x\\<bar> powr (p - 1)\n    \\<le> p * (if y = 0 then 0 else if 0 < y then 1 else - 1) *\n          \\<bar>y\\<bar> powr (p - 1)", "using \\<open>p>1\\<close> \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<and> 0 \\<le> y\n  1 < p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. p * (if x = 0 then 0 else if 0 < x then 1 else - 1) *\n    \\<bar>x\\<bar> powr (p - 1)\n    \\<le> p * (if y = 0 then 0 else if 0 < y then 1 else - 1) *\n          \\<bar>y\\<bar> powr (p - 1)", "by (auto simp add: powr_mono2)"], ["proof (state)\nthis:\n  g x \\<le> g y\n\ngoal (2 subgoals):\n 1. x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> g x \\<le> g y\n 2. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> g x \\<le> g y\n 2. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "case 2"], ["proof (state)\nthis:\n  x \\<le> 0 \\<and> y \\<le> 0\n\ngoal (2 subgoals):\n 1. x \\<le> 0 \\<and> y \\<le> 0 \\<Longrightarrow> g x \\<le> g y\n 2. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "then"], ["proof (chain)\npicking this:\n  x \\<le> 0 \\<and> y \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> 0 \\<and> y \\<le> 0\n\ngoal (1 subgoal):\n 1. g x \\<le> g y", "unfolding g_def sgn_real_def"], ["proof (prove)\nusing this:\n  x \\<le> 0 \\<and> y \\<le> 0\n\ngoal (1 subgoal):\n 1. p * (if x = 0 then 0 else if 0 < x then 1 else - 1) *\n    \\<bar>x\\<bar> powr (p - 1)\n    \\<le> p * (if y = 0 then 0 else if 0 < y then 1 else - 1) *\n          \\<bar>y\\<bar> powr (p - 1)", "using \\<open>p>1\\<close> \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> 0 \\<and> y \\<le> 0\n  1 < p\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. p * (if x = 0 then 0 else if 0 < x then 1 else - 1) *\n    \\<bar>x\\<bar> powr (p - 1)\n    \\<le> p * (if y = 0 then 0 else if 0 < y then 1 else - 1) *\n          \\<bar>y\\<bar> powr (p - 1)", "by (auto simp add: powr_mono2)"], ["proof (state)\nthis:\n  g x \\<le> g y\n\ngoal (1 subgoal):\n 1. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "case 3"], ["proof (state)\nthis:\n  x < 0 \\<and> 0 < y\n\ngoal (1 subgoal):\n 1. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "then"], ["proof (chain)\npicking this:\n  x < 0 \\<and> 0 < y", "have \"g x \\<le> 0\" \"0 \\<le> g y\""], ["proof (prove)\nusing this:\n  x < 0 \\<and> 0 < y\n\ngoal (1 subgoal):\n 1. g x \\<le> 0 &&& 0 \\<le> g y", "unfolding g_def"], ["proof (prove)\nusing this:\n  x < 0 \\<and> 0 < y\n\ngoal (1 subgoal):\n 1. p * sgn x * \\<bar>x\\<bar> powr (p - 1) \\<le> 0 &&&\n    0 \\<le> p * sgn y * \\<bar>y\\<bar> powr (p - 1)", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  x < 0 \\<and> 0 < y\n  1 < p\n\ngoal (1 subgoal):\n 1. p * sgn x * \\<bar>x\\<bar> powr (p - 1) \\<le> 0 &&&\n    0 \\<le> p * sgn y * \\<bar>y\\<bar> powr (p - 1)", "by auto"], ["proof (state)\nthis:\n  g x \\<le> 0\n  0 \\<le> g y\n\ngoal (1 subgoal):\n 1. x < 0 \\<and> 0 < y \\<Longrightarrow> g x \\<le> g y", "then"], ["proof (chain)\npicking this:\n  g x \\<le> 0\n  0 \\<le> g y", "show ?thesis"], ["proof (prove)\nusing this:\n  g x \\<le> 0\n  0 \\<le> g y\n\ngoal (1 subgoal):\n 1. g x \\<le> g y", "by simp"], ["proof (state)\nthis:\n  g x \\<le> g y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g x \\<le> g y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<Longrightarrow> g ?x \\<le> g ?y\n\ngoal (1 subgoal):\n 1. p \\<noteq> 1 \\<Longrightarrow>\n    convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)", "apply (rule convex_on_realI[of _ _ g])"], ["proof (prove)\ngoal (3 subgoals):\n 1. connected UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative g x) (at x)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> g x \\<le> g y", "using * **"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative g ?x) (at ?x)\n  ?x \\<le> ?y \\<Longrightarrow> g ?x \\<le> g ?y\n\ngoal (3 subgoals):\n 1. connected UNIV\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       ((\\<lambda>x. \\<bar>x\\<bar> powr p) has_real_derivative g x) (at x)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> g x \\<le> g y", "by auto"], ["proof (state)\nthis:\n  convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convex_powr:\n  assumes \"p \\<ge> 1\"\n  shows \"convex_on {0..} (\\<lambda>x::real. x powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. x powr p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. x powr p)", "have \"convex_on {0..} (\\<lambda>x::real. \\<bar>x\\<bar> powr p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. \\<bar>x\\<bar> powr p)", "using convex_abs_powr[OF \\<open>p \\<ge> 1\\<close>] convex_on_subset"], ["proof (prove)\nusing this:\n  convex_on UNIV (\\<lambda>x. \\<bar>x\\<bar> powr p)\n  \\<lbrakk>convex_on ?t ?f; ?S \\<subseteq> ?t\\<rbrakk>\n  \\<Longrightarrow> convex_on ?S ?f\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. \\<bar>x\\<bar> powr p)", "by auto"], ["proof (state)\nthis:\n  convex_on {0..} (\\<lambda>x. \\<bar>x\\<bar> powr p)\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. x powr p)", "moreover"], ["proof (state)\nthis:\n  convex_on {0..} (\\<lambda>x. \\<bar>x\\<bar> powr p)\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. x powr p)", "have \"\\<bar>x\\<bar> powr p = x powr p\" if \"x \\<in> {0..}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> powr p = x powr p", "using that"], ["proof (prove)\nusing this:\n  x \\<in> {0..}\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> powr p = x powr p", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> {0..} \\<Longrightarrow> \\<bar>?x\\<bar> powr p = ?x powr p\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. x powr p)", "ultimately"], ["proof (chain)\npicking this:\n  convex_on {0..} (\\<lambda>x. \\<bar>x\\<bar> powr p)\n  ?x \\<in> {0..} \\<Longrightarrow> \\<bar>?x\\<bar> powr p = ?x powr p", "show ?thesis"], ["proof (prove)\nusing this:\n  convex_on {0..} (\\<lambda>x. \\<bar>x\\<bar> powr p)\n  ?x \\<in> {0..} \\<Longrightarrow> \\<bar>?x\\<bar> powr p = ?x powr p\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. x powr p)", "by (simp add: convex_on_def)"], ["proof (state)\nthis:\n  convex_on {0..} (\\<lambda>x. x powr p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convex_powr':\n  assumes \"p > 0\" \"p \\<le> 1\"\n  shows \"convex_on {0..} (\\<lambda>x::real. - (x powr p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "have \"convex_on {0<..} (\\<lambda>x::real. - (x powr p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex_on {0<..} (\\<lambda>x. - (x powr p))", "apply (rule convex_on_realI[of _ _ \"\\<lambda>x. -p * x powr (p-1)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. connected {0<..}\n 2. \\<And>x.\n       x \\<in> {0<..} \\<Longrightarrow>\n       ((\\<lambda>x. - (x powr p)) has_real_derivative - p * x powr (p - 1))\n        (at x)\n 3. \\<And>x y.\n       \\<lbrakk>x \\<in> {0<..}; y \\<in> {0<..}; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> - p * x powr (p - 1) \\<le> - p * y powr (p - 1)", "apply (auto intro!:derivative_intros simp add: has_real_derivative_powr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> p * y powr (p - 1) \\<le> p * x powr (p - 1)", "using \\<open>p > 0\\<close> \\<open>p \\<le> 1\\<close>"], ["proof (prove)\nusing this:\n  0 < p\n  p \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 < x; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> p * y powr (p - 1) \\<le> p * x powr (p - 1)", "by (auto simp add: algebra_simps divide_simps powr_mono2')"], ["proof (state)\nthis:\n  convex_on {0<..} (\\<lambda>x. - (x powr p))\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "moreover"], ["proof (state)\nthis:\n  convex_on {0<..} (\\<lambda>x. - (x powr p))\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "have \"continuous_on {0..} (\\<lambda>x::real. - (x powr p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..} (\\<lambda>x. - (x powr p))", "by (rule continuous_on_minus, rule continuous_on_powr', auto simp add: \\<open>p > 0\\<close> intro!: continuous_intros)"], ["proof (state)\nthis:\n  continuous_on {0..} (\\<lambda>x. - (x powr p))\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "moreover"], ["proof (state)\nthis:\n  continuous_on {0..} (\\<lambda>x. - (x powr p))\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "have \"{(0::real)..} = closure {0<..}\" \"convex {(0::real)<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..} = closure {0<..} &&& convex {0<..}", "by auto"], ["proof (state)\nthis:\n  {0..} = closure {0<..}\n  convex {0<..}\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "ultimately"], ["proof (chain)\npicking this:\n  convex_on {0<..} (\\<lambda>x. - (x powr p))\n  continuous_on {0..} (\\<lambda>x. - (x powr p))\n  {0..} = closure {0<..}\n  convex {0<..}", "show ?thesis"], ["proof (prove)\nusing this:\n  convex_on {0<..} (\\<lambda>x. - (x powr p))\n  continuous_on {0..} (\\<lambda>x. - (x powr p))\n  {0..} = closure {0<..}\n  convex {0<..}\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "using convex_on_closure"], ["proof (prove)\nusing this:\n  convex_on {0<..} (\\<lambda>x. - (x powr p))\n  continuous_on {0..} (\\<lambda>x. - (x powr p))\n  {0..} = closure {0<..}\n  convex {0<..}\n  \\<lbrakk>convex ?C; convex_on ?C ?f;\n   continuous_on (closure ?C) ?f\\<rbrakk>\n  \\<Longrightarrow> convex_on (closure ?C) ?f\n\ngoal (1 subgoal):\n 1. convex_on {0..} (\\<lambda>x. - (x powr p))", "by metis"], ["proof (state)\nthis:\n  convex_on {0..} (\\<lambda>x. - (x powr p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma convex_fx_plus_fy_ineq:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"convex_on {0..} f\"\n          \"x \\<ge> 0\" \"y \\<ge> 0\" \"f 0 = 0\"\n  shows \"f x + f y \\<le> f (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x + f y \\<le> f (x + y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x + f y \\<le> f (x + y)", "have *: \"f a + f b \\<le> f (a+b)\" if \"a \\<ge> 0\" \"b \\<ge> a\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a + f b \\<le> f (a + b)", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)\n 2. a \\<noteq> 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)\n 2. a \\<noteq> 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "have \"a > 0\" \"b > 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < a &&& 0 < b", "using \\<open>b \\<ge> a\\<close> \\<open>a \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  a \\<le> b\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. 0 < a &&& 0 < b", "by auto"], ["proof (state)\nthis:\n  0 < a\n  0 < b\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)\n 2. a \\<noteq> 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "have \"(f 0 - f a) / (0 - a) \\<le> (f 0 - f (a+b))/ (0 - (a+b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 - f a) / (0 - a) \\<le> (f 0 - f (a + b)) / (0 - (a + b))", "apply (rule convex_on_diff[OF \\<open>convex_on {0..} f\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<in> {0..}\n 2. a + b \\<in> {0..}\n 3. 0 < a\n 4. a < a + b", "using \\<open>a > 0\\<close> \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n\ngoal (4 subgoals):\n 1. 0 \\<in> {0..}\n 2. a + b \\<in> {0..}\n 3. 0 < a\n 4. a < a + b", "by auto"], ["proof (state)\nthis:\n  (f 0 - f a) / (0 - a) \\<le> (f 0 - f (a + b)) / (0 - (a + b))\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)\n 2. a \\<noteq> 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "also"], ["proof (state)\nthis:\n  (f 0 - f a) / (0 - a) \\<le> (f 0 - f (a + b)) / (0 - (a + b))\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)\n 2. a \\<noteq> 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "have \"... \\<le> (f b - f (a+b)) / (b - (a+b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 - f (a + b)) / (0 - (a + b))\n    \\<le> (f b - f (a + b)) / (b - (a + b))", "apply (rule convex_on_diff[OF \\<open>convex_on {0..} f\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<in> {0..}\n 2. a + b \\<in> {0..}\n 3. 0 < b\n 4. b < a + b", "using \\<open>a > 0\\<close> \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n\ngoal (4 subgoals):\n 1. 0 \\<in> {0..}\n 2. a + b \\<in> {0..}\n 3. 0 < b\n 4. b < a + b", "by auto"], ["proof (state)\nthis:\n  (f 0 - f (a + b)) / (0 - (a + b)) \\<le> (f b - f (a + b)) / (b - (a + b))\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)\n 2. a \\<noteq> 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "finally"], ["proof (chain)\npicking this:\n  (f 0 - f a) / (0 - a) \\<le> (f b - f (a + b)) / (b - (a + b))", "show ?thesis"], ["proof (prove)\nusing this:\n  (f 0 - f a) / (0 - a) \\<le> (f b - f (a + b)) / (b - (a + b))\n\ngoal (1 subgoal):\n 1. f a + f b \\<le> f (a + b)", "using \\<open>a > 0\\<close> \\<open>b > 0\\<close> \\<open>f 0 = 0\\<close>"], ["proof (prove)\nusing this:\n  (f 0 - f a) / (0 - a) \\<le> (f b - f (a + b)) / (b - (a + b))\n  0 < a\n  0 < b\n  f 0 = 0\n\ngoal (1 subgoal):\n 1. f a + f b \\<le> f (a + b)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  f a + f b \\<le> f (a + b)\n\ngoal (1 subgoal):\n 1. a = 0 \\<Longrightarrow> f a + f b \\<le> f (a + b)", "qed (simp add: \\<open>f 0 = 0\\<close>)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> f ?a + f ?b \\<le> f (?a + ?b)\n\ngoal (1 subgoal):\n 1. f x + f y \\<le> f (x + y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> f ?a + f ?b \\<le> f (?a + ?b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> f ?a + f ?b \\<le> f (?a + ?b)\n\ngoal (1 subgoal):\n 1. f x + f y \\<le> f (x + y)", "using \\<open>x \\<ge> 0\\<close> \\<open>y \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> f ?a + f ?b \\<le> f (?a + ?b)\n  0 \\<le> x\n  0 \\<le> y\n\ngoal (1 subgoal):\n 1. f x + f y \\<le> f (x + y)", "by (metis add.commute le_less not_le)"], ["proof (state)\nthis:\n  f x + f y \\<le> f (x + y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma x_plus_y_p_le_xp_plus_yp:\n  fixes p x y::real\n  assumes \"p > 0\" \"p \\<le> 1\" \"x \\<ge> 0\" \"y \\<ge> 0\"\n  shows \"(x + y) powr p \\<le> x powr p + y powr p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) powr p \\<le> x powr p + y powr p", "using convex_fx_plus_fy_ineq[OF convex_powr'[OF \\<open>p > 0\\<close> \\<open>p \\<le> 1\\<close>] \\<open>x \\<ge> 0\\<close> \\<open>y \\<ge> 0\\<close>]"], ["proof (prove)\nusing this:\n  - (0 powr p) = 0 \\<Longrightarrow>\n  - (x powr p) + - (y powr p) \\<le> - ((x + y) powr p)\n\ngoal (1 subgoal):\n 1. (x + y) powr p \\<le> x powr p + y powr p", "by auto"], ["", "subsection \\<open>Nonnegative-extended-real.thy\\<close>"], ["", "lemma x_plus_top_ennreal [simp]:\n  \"x + \\<top> = (\\<top>::ennreal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + \\<top> = \\<top>", "by simp"], ["", "lemma ennreal_ge_nat_imp_PInf:\n  fixes x::ennreal\n  assumes \"\\<And>N. x \\<ge> of_nat N\"\n  shows \"x = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  of_nat ?N \\<le> x\n\ngoal (1 subgoal):\n 1. x = \\<infinity>", "apply (cases x, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>N. real N \\<le> r; 0 \\<le> r; x = ennreal r\\<rbrakk>\n       \\<Longrightarrow> False", "by (meson not_less reals_Archimedean2)"], ["", "lemma ennreal_archimedean:\n  assumes \"x \\<noteq> (\\<infinity>::ennreal)\"\n  shows \"\\<exists>n::nat. x \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xa. x \\<le> of_nat xa", "using assms ennreal_ge_nat_imp_PInf linear"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<infinity>\n  (\\<And>N. of_nat N \\<le> ?x) \\<Longrightarrow> ?x = \\<infinity>\n  ?x \\<le> ?y \\<or> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<exists>xa. x \\<le> of_nat xa", "by blast"], ["", "lemma e2ennreal_mult:\n  fixes a b::ereal\n  assumes \"a \\<ge> 0\"\n  shows \"e2ennreal(a * b) = e2ennreal a * e2ennreal b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2ennreal (a * b) = e2ennreal a * e2ennreal b", "by (metis assms e2ennreal_neg eq_onp_same_args ereal_mult_le_0_iff linear times_ennreal.abs_eq)"], ["", "lemma e2ennreal_mult':\n  fixes a b::ereal\n  assumes \"b \\<ge> 0\"\n  shows \"e2ennreal(a * b) = e2ennreal a * e2ennreal b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2ennreal (a * b) = e2ennreal a * e2ennreal b", "using e2ennreal_mult[OF assms, of a]"], ["proof (prove)\nusing this:\n  e2ennreal (b * a) = e2ennreal b * e2ennreal a\n\ngoal (1 subgoal):\n 1. e2ennreal (a * b) = e2ennreal a * e2ennreal b", "by (simp add: mult.commute)"], ["", "lemma SUP_real_ennreal:\n  assumes \"A \\<noteq> {}\" \"bdd_above (f`A)\"\n  shows \"(SUP a\\<in>A. ennreal (f a)) = ennreal(SUP a\\<in>A. f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>a\\<in>A. ennreal (f a)) = ennreal (\\<Squnion> (f ` A))", "apply (rule antisym, simp add: SUP_least assms(2) cSUP_upper ennreal_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Squnion> (f ` A)) \\<le> (\\<Squnion>a\\<in>A. ennreal (f a))", "by (metis assms(1) ennreal_SUP ennreal_less_top le_less)"], ["", "lemma e2ennreal_Liminf:\n  \"F \\<noteq> bot \\<Longrightarrow> e2ennreal (Liminf F f) = Liminf F (\\<lambda>n. e2ennreal (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<noteq> \\<bottom> \\<Longrightarrow>\n    e2ennreal (Liminf F f) = Liminf F (\\<lambda>n. e2ennreal (f n))", "by (rule Liminf_compose_continuous_mono[symmetric])\n     (auto simp: mono_def e2ennreal_mono continuous_on_e2ennreal)"], ["", "lemma e2ennreal_eq_infty[simp]: \"0 \\<le> x \\<Longrightarrow> e2ennreal x = top \\<longleftrightarrow> x = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> (e2ennreal x = \\<top>) = (x = \\<infinity>)", "by (cases x) (auto)"], ["", "lemma ennreal_Inf_cmult:\n  assumes \"c>(0::real)\"\n  shows \"Inf {ennreal c * x |x. P x} = ennreal c * Inf {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {ennreal c * x |x. P x} = ennreal c * \\<Sqinter> {x. P x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> {ennreal c * x |x. P x} = ennreal c * \\<Sqinter> {x. P x}", "have \"(\\<lambda>x::ennreal. c * x) (Inf {x::ennreal. P x}) = Inf ((\\<lambda>x::ennreal. c * x)`{x::ennreal. P x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal c * \\<Sqinter> {x. P x} =\n    \\<Sqinter> ((*) (ennreal c) ` {x. P x})", "apply (rule mono_bij_Inf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono ((*) (ennreal c))\n 2. bij ((*) (ennreal c))", "apply (simp add: monoI mult_left_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij ((*) (ennreal c))", "apply (rule bij_betw_byWitness[of _ \"\\<lambda>x. (x::ennreal) / c\"], auto simp add: assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. ennreal c * a / ennreal c = a\n 2. \\<And>a'. ennreal c * (a' / ennreal c) = a'", "apply (metis assms ennreal_lessI ennreal_neq_top mult.commute mult_divide_eq_ennreal not_less_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a'. ennreal c * (a' / ennreal c) = a'", "apply (metis assms divide_ennreal_def ennreal_less_zero_iff ennreal_neq_top less_irrefl mult.assoc mult.left_commute mult_divide_eq_ennreal)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ennreal c * \\<Sqinter> {x. P x} = \\<Sqinter> ((*) (ennreal c) ` {x. P x})\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {ennreal c * x |x. P x} = ennreal c * \\<Sqinter> {x. P x}", "then"], ["proof (chain)\npicking this:\n  ennreal c * \\<Sqinter> {x. P x} = \\<Sqinter> ((*) (ennreal c) ` {x. P x})", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal c * \\<Sqinter> {x. P x} = \\<Sqinter> ((*) (ennreal c) ` {x. P x})\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {ennreal c * x |x. P x} = ennreal c * \\<Sqinter> {x. P x}", "by (simp only: setcompr_eq_image[symmetric])"], ["proof (state)\nthis:\n  \\<Sqinter> {ennreal c * x |x. P x} = ennreal c * \\<Sqinter> {x. P x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_const_minus_ennreal:\n  fixes f :: \"'a :: topological_space \\<Rightarrow> ennreal\"\n  shows \"continuous_on A f \\<Longrightarrow> continuous_on A (\\<lambda>x. a - f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A f \\<Longrightarrow>\n    continuous_on A (\\<lambda>x. a - f x)", "including ennreal.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A f \\<Longrightarrow>\n    continuous_on A (\\<lambda>x. a - f x)", "proof (transfer fixing: A; clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a.\n       \\<lbrakk>\\<forall>x. 0 \\<le> f x; continuous_on A f;\n        0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "fix f :: \"'a \\<Rightarrow> ereal\" and a :: \"ereal\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f a.\n       \\<lbrakk>\\<forall>x. 0 \\<le> f x; continuous_on A f;\n        0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "assume \"0 \\<le> a\" \"\\<forall>x. 0 \\<le> f x\" and f: \"continuous_on A f\""], ["proof (state)\nthis:\n  0 \\<le> a\n  \\<forall>x. 0 \\<le> f x\n  continuous_on A f\n\ngoal (1 subgoal):\n 1. \\<And>f a.\n       \\<lbrakk>\\<forall>x. 0 \\<le> f x; continuous_on A f;\n        0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> a\n  \\<forall>x. 0 \\<le> f x\n  continuous_on A f", "show \"continuous_on A (\\<lambda>x. max 0 (a - f x))\""], ["proof (prove)\nusing this:\n  0 \\<le> a\n  \\<forall>x. 0 \\<le> f x\n  continuous_on A f\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. max 0 (a - f x))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     ?P3\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))\n 2. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "assume \"\\<exists>r. a = ereal r\""], ["proof (state)\nthis:\n  \\<exists>r. a = ereal r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     ?P3\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))\n 2. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "with f"], ["proof (chain)\npicking this:\n  continuous_on A f\n  \\<exists>r. a = ereal r", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_on A f\n  \\<exists>r. a = ereal r\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. max 0 (a - f x))", "by (auto simp: continuous_on_def minus_ereal_def ereal_Lim_uminus[symmetric]\n              intro!: tendsto_add_ereal_general tendsto_max)"], ["proof (state)\nthis:\n  continuous_on A (\\<lambda>x. max 0 (a - f x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     \\<nexists>r. a = ereal r\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     \\<nexists>r. a = ereal r\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "assume \"\\<nexists>r. a = ereal r\""], ["proof (state)\nthis:\n  \\<nexists>r. a = ereal r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     \\<nexists>r. a = ereal r\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "with \\<open>0 \\<le> a\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> a\n  \\<nexists>r. a = ereal r", "have \"a = \\<infinity>\""], ["proof (prove)\nusing this:\n  0 \\<le> a\n  \\<nexists>r. a = ereal r\n\ngoal (1 subgoal):\n 1. a = \\<infinity>", "by (cases a) auto"], ["proof (state)\nthis:\n  a = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; \\<forall>x. 0 \\<le> f x; continuous_on A f;\n     \\<nexists>r. a = ereal r\\<rbrakk>\n    \\<Longrightarrow> continuous_on A (\\<lambda>x. max 0 (a - f x))", "then"], ["proof (chain)\npicking this:\n  a = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  a = \\<infinity>\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. max 0 (a - f x))", "by (simp add: continuous_on_const)"], ["proof (state)\nthis:\n  continuous_on A (\\<lambda>x. max 0 (a - f x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on A (\\<lambda>x. max 0 (a - f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_minus_Liminf_ennreal:\n  fixes a :: ennreal\n  shows \"F \\<noteq> bot \\<Longrightarrow> a - Liminf F f = Limsup F (\\<lambda>x. a - f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<noteq> \\<bottom> \\<Longrightarrow>\n    a - Liminf F f = Limsup F (\\<lambda>x. a - f x)", "by (intro Limsup_compose_continuous_antimono[symmetric])\n   (auto simp: antimono_def ennreal_mono_minus continuous_on_id continuous_on_const_minus_ennreal)"], ["", "lemma tendsto_cmult_ennreal [tendsto_intros]:\n  fixes c l::ennreal\n  assumes \"\\<not>(c = \\<infinity> \\<and> l = 0)\"\n          \"(f \\<longlongrightarrow> l) F\"\n  shows \"((\\<lambda>x. c * f x) \\<longlongrightarrow> c * l) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c * f x) \\<longlongrightarrow> c * l) F", "by (cases \"c = 0\", insert assms, auto intro!: tendsto_intros)"], ["", "subsection \\<open>Indicator-Function.thy\\<close>"], ["", "text \\<open>There is something weird with \\verb+sum_mult_indicator+: it is defined both\nin Indicator.thy and BochnerIntegration.thy, with a different meaning. I am surprised\nthere is no name collision... Here, I am using the version from BochnerIntegration.\\<close>"], ["", "lemma sum_indicator_eq_card2:\n  assumes \"finite I\"\n  shows \"(\\<Sum>i\\<in>I. (indicator (P i) x)::nat) = card {i\\<in>I. x \\<in> P i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (P i) x) = card {i \\<in> I. x \\<in> P i}", "using sum_mult_indicator [OF assms, of \"\\<lambda>y. 1::nat\" P \"\\<lambda>y. x\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>xa\\<in>I. 1 * indicator (P xa) x) =\n  (\\<Sum>x | x \\<in> I \\<and> x \\<in> P x. 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (P i) x) = card {i \\<in> I. x \\<in> P i}", "unfolding card_eq_sum"], ["proof (prove)\nusing this:\n  (\\<Sum>xa\\<in>I. 1 * indicator (P xa) x) =\n  (\\<Sum>x | x \\<in> I \\<and> x \\<in> P x. 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (P i) x) =\n    (\\<Sum>x\\<in>{i \\<in> I. x \\<in> P i}. 1)", "by auto"], ["", "lemma disjoint_family_indicator_le_1:\n  assumes \"disjoint_family_on A I\"\n  shows \"(\\<Sum> i\\<in> I. indicator (A i) x) \\<le> (1::'a:: {comm_monoid_add,zero_less_one})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "proof (cases \"finite I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)\n 2. infinite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "case True"], ["proof (state)\nthis:\n  finite I\n\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)\n 2. infinite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "then"], ["proof (chain)\npicking this:\n  finite I", "have *: \"(\\<Sum> i\\<in> I. indicator (A i) x) = ((indicator (\\<Union>i\\<in>I. A i) x)::'a)\""], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (A i) x) = indicator (\\<Union> (A ` I)) x", "by (simp add: indicator_UN_disjoint[OF True assms(1), of x])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. indicator (A i) x) = indicator (\\<Union> (A ` I)) x\n\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)\n 2. infinite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. indicator (\\<Union> (A ` I)) x \\<le> (1::'a)", "unfolding indicator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> \\<Union> (A ` I) then 1::'a else (0::'a)) \\<le> (1::'a)", "by (simp add: order_less_imp_le)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "case False"], ["proof (state)\nthis:\n  infinite I\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "then"], ["proof (chain)\npicking this:\n  infinite I", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite I\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)", "by (simp add: order_less_imp_le)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. indicator (A i) x) \\<le> (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>sigma-algebra.thy\\<close>"], ["", "lemma algebra_intersection:\n  assumes \"algebra \\<Omega> A\"\n          \"algebra \\<Omega> B\"\n  shows \"algebra \\<Omega> (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebra \\<Omega> (A \\<inter> B)", "apply (subst algebra_iff_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> B \\<subseteq> Pow \\<Omega> \\<and>\n    {} \\<in> A \\<inter> B \\<and>\n    (\\<forall>a\\<in>A \\<inter> B. \\<Omega> - a \\<in> A \\<inter> B) \\<and>\n    (\\<forall>a\\<in>A \\<inter> B.\n        \\<forall>b\\<in>A \\<inter> B. a \\<union> b \\<in> A \\<inter> B)", "using assms"], ["proof (prove)\nusing this:\n  algebra \\<Omega> A\n  algebra \\<Omega> B\n\ngoal (1 subgoal):\n 1. A \\<inter> B \\<subseteq> Pow \\<Omega> \\<and>\n    {} \\<in> A \\<inter> B \\<and>\n    (\\<forall>a\\<in>A \\<inter> B. \\<Omega> - a \\<in> A \\<inter> B) \\<and>\n    (\\<forall>a\\<in>A \\<inter> B.\n        \\<forall>b\\<in>A \\<inter> B. a \\<union> b \\<in> A \\<inter> B)", "by (auto simp add: algebra_iff_Un)"], ["", "lemma sigma_algebra_intersection:\n  assumes \"sigma_algebra \\<Omega> A\"\n          \"sigma_algebra \\<Omega> B\"\n  shows \"sigma_algebra \\<Omega> (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_algebra \\<Omega> (A \\<inter> B)", "apply (subst sigma_algebra_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebra \\<Omega> (A \\<inter> B) \\<and>\n    (\\<forall>Aa.\n        range Aa \\<subseteq> A \\<inter> B \\<longrightarrow>\n        \\<Union> (range Aa) \\<in> A \\<inter> B)", "using assms"], ["proof (prove)\nusing this:\n  sigma_algebra \\<Omega> A\n  sigma_algebra \\<Omega> B\n\ngoal (1 subgoal):\n 1. algebra \\<Omega> (A \\<inter> B) \\<and>\n    (\\<forall>Aa.\n        range Aa \\<subseteq> A \\<inter> B \\<longrightarrow>\n        \\<Union> (range Aa) \\<in> A \\<inter> B)", "by (auto simp add: sigma_algebra_iff algebra_intersection)"], ["", "lemma subalgebra_M_M [simp]:\n  \"subalgebra M M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subalgebra M M", "by (simp add: subalgebra_def)"], ["", "text \\<open>The next one is \\verb+disjoint_family_Suc+ with inclusions reversed.\\<close>"], ["", "lemma disjoint_family_Suc2:\n  assumes Suc: \"\\<And>n. A (Suc n) \\<subseteq> A n\"\n  shows \"disjoint_family (\\<lambda>i. A i - A (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_family (\\<lambda>i. A i - A (Suc i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. disjoint_family (\\<lambda>i. A i - A (Suc i))", "have \"A (m+n) \\<subseteq> A n\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (m + n) \\<subseteq> A n", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. A (0 + n) \\<subseteq> A n\n 2. \\<And>m.\n       A (m + n) \\<subseteq> A n \\<Longrightarrow>\n       A (Suc m + n) \\<subseteq> A n", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. A (0 + n) \\<subseteq> A n\n 2. \\<And>m.\n       A (m + n) \\<subseteq> A n \\<Longrightarrow>\n       A (Suc m + n) \\<subseteq> A n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (0 + n) \\<subseteq> A n", "by simp"], ["proof (state)\nthis:\n  A (0 + n) \\<subseteq> A n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       A (m + n) \\<subseteq> A n \\<Longrightarrow>\n       A (Suc m + n) \\<subseteq> A n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       A (m + n) \\<subseteq> A n \\<Longrightarrow>\n       A (Suc m + n) \\<subseteq> A n", "case (Suc m)"], ["proof (state)\nthis:\n  A (m + n) \\<subseteq> A n\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       A (m + n) \\<subseteq> A n \\<Longrightarrow>\n       A (Suc m + n) \\<subseteq> A n", "then"], ["proof (chain)\npicking this:\n  A (m + n) \\<subseteq> A n", "show ?case"], ["proof (prove)\nusing this:\n  A (m + n) \\<subseteq> A n\n\ngoal (1 subgoal):\n 1. A (Suc m + n) \\<subseteq> A n", "by (metis Suc_eq_plus1 assms add.commute add.left_commute subset_trans)"], ["proof (state)\nthis:\n  A (Suc m + n) \\<subseteq> A n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A (?m + ?n) \\<subseteq> A ?n\n\ngoal (1 subgoal):\n 1. disjoint_family (\\<lambda>i. A i - A (Suc i))", "then"], ["proof (chain)\npicking this:\n  A (?m + ?n) \\<subseteq> A ?n", "have \"A m \\<subseteq> A n\" if \"m > n\" for m n"], ["proof (prove)\nusing this:\n  A (?m + ?n) \\<subseteq> A ?n\n\ngoal (1 subgoal):\n 1. A m \\<subseteq> A n", "by (metis that add.commute le_add_diff_inverse nat_less_le)"], ["proof (state)\nthis:\n  ?n < ?m \\<Longrightarrow> A ?m \\<subseteq> A ?n\n\ngoal (1 subgoal):\n 1. disjoint_family (\\<lambda>i. A i - A (Suc i))", "then"], ["proof (chain)\npicking this:\n  ?n < ?m \\<Longrightarrow> A ?m \\<subseteq> A ?n", "show ?thesis"], ["proof (prove)\nusing this:\n  ?n < ?m \\<Longrightarrow> A ?m \\<subseteq> A ?n\n\ngoal (1 subgoal):\n 1. disjoint_family (\\<lambda>i. A i - A (Suc i))", "by (auto simp add: disjoint_family_on_def)\n       (metis insert_absorb insert_subset le_SucE le_antisym not_le_imp_less)"], ["proof (state)\nthis:\n  disjoint_family (\\<lambda>i. A i - A (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Measure-Space.thy\\<close>"], ["", "lemma AE_equal_sum:\n  assumes \"\\<And>i. AE x in M. f i x = g i x\"\n  shows \"AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "assume \"finite I\""], ["proof (state)\nthis:\n  finite I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "have \"\\<exists>A. A \\<in> null_sets M \\<and> (\\<forall>x\\<in> (space M - A). f i x = g i x)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       A \\<in> null_sets M \\<and>\n       (\\<forall>x\\<in>space M - A. f i x = g i x)", "using assms(1)[of i]"], ["proof (prove)\nusing this:\n  AE x in M. f i x = g i x\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       A \\<in> null_sets M \\<and>\n       (\\<forall>x\\<in>space M - A. f i x = g i x)", "by (metis (mono_tags, lifting) AE_E3)"], ["proof (state)\nthis:\n  \\<exists>A.\n     A \\<in> null_sets M \\<and>\n     (\\<forall>x\\<in>space M - A. f ?i x = g ?i x)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     A \\<in> null_sets M \\<and>\n     (\\<forall>x\\<in>space M - A. f ?i x = g ?i x)", "obtain A where A: \"\\<And>i. A i \\<in> null_sets M \\<and> (\\<forall>x\\<in> (space M -A i). f i x = g i x)\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     A \\<in> null_sets M \\<and>\n     (\\<forall>x\\<in>space M - A. f ?i x = g ?i x)\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        (\\<And>i.\n            A i \\<in> null_sets M \\<and>\n            (\\<forall>x\\<in>space M - A i. f i x = g i x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  A ?i \\<in> null_sets M \\<and>\n  (\\<forall>x\\<in>space M - A ?i. f ?i x = g ?i x)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "define B where \"B = (\\<Union>i\\<in>I. A i)\""], ["proof (state)\nthis:\n  B = \\<Union> (A ` I)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "have \"B \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "using \\<open>finite I\\<close> A B_def"], ["proof (prove)\nusing this:\n  finite I\n  A ?i \\<in> null_sets M \\<and>\n  (\\<forall>x\\<in>space M - A ?i. f ?i x = g ?i x)\n  B = \\<Union> (A ` I)\n\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "by blast"], ["proof (state)\nthis:\n  B \\<in> null_sets M\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "then"], ["proof (chain)\npicking this:\n  B \\<in> null_sets M", "have \"AE x in M. x \\<in> space M - B\""], ["proof (prove)\nusing this:\n  B \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. AE x in M. x \\<in> space M - B", "by (simp add: AE_not_in)"], ["proof (state)\nthis:\n  AE x in M. x \\<in> space M - B\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "moreover"], ["proof (state)\nthis:\n  AE x in M. x \\<in> space M - B\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "{"], ["proof (state)\nthis:\n  AE x in M. x \\<in> space M - B\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "assume \"x \\<in> space M - B\""], ["proof (state)\nthis:\n  x \\<in> space M - B\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> space M - B", "have \"\\<And>i. i \\<in> I \\<Longrightarrow> f i x = g i x\""], ["proof (prove)\nusing this:\n  x \\<in> space M - B\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> f i x = g i x", "unfolding B_def"], ["proof (prove)\nusing this:\n  x \\<in> space M - \\<Union> (A ` I)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> f i x = g i x", "using A"], ["proof (prove)\nusing this:\n  x \\<in> space M - \\<Union> (A ` I)\n  A ?i \\<in> null_sets M \\<and>\n  (\\<forall>x\\<in>space M - A ?i. f ?i x = g ?i x)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> f i x = g i x", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> I \\<Longrightarrow> f ?i x = g ?i x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "then"], ["proof (chain)\npicking this:\n  ?i \\<in> I \\<Longrightarrow> f ?i x = g ?i x", "have \"(\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\""], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> f ?i x = g ?i x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> space M - B \\<Longrightarrow>\n  (\\<Sum>i\\<in>I. f i ?x2) = (\\<Sum>i\\<in>I. g i ?x2)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n 2. \\<not> ?P \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "ultimately"], ["proof (chain)\npicking this:\n  AE x in M. x \\<in> space M - B\n  ?x2 \\<in> space M - B \\<Longrightarrow>\n  (\\<Sum>i\\<in>I. f i ?x2) = (\\<Sum>i\\<in>I. g i ?x2)", "show ?thesis"], ["proof (prove)\nusing this:\n  AE x in M. x \\<in> space M - B\n  ?x2 \\<in> space M - B \\<Longrightarrow>\n  (\\<Sum>i\\<in>I. f i ?x2) = (\\<Sum>i\\<in>I. g i ?x2)\n\ngoal (1 subgoal):\n 1. AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "by auto"], ["proof (state)\nthis:\n  AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    AE x in M. (\\<Sum>i\\<in>I. f i x) = (\\<Sum>i\\<in>I. g i x)", "qed (simp)"], ["", "lemma emeasure_pos_unionE:\n  assumes \"\\<And> (N::nat). A N \\<in> sets M\"\n          \"emeasure M (\\<Union>N. A N) > 0\"\n  shows \"\\<exists>N. emeasure M (A N) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. 0 < emeasure M (A N)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>N. 0 < emeasure M (A N) \\<Longrightarrow> False", "assume \"\\<not>(\\<exists>N. emeasure M (A N) > 0)\""], ["proof (state)\nthis:\n  \\<nexists>N. 0 < emeasure M (A N)\n\ngoal (1 subgoal):\n 1. \\<nexists>N. 0 < emeasure M (A N) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>N. 0 < emeasure M (A N)", "have \"\\<And>N. A N \\<in> null_sets M\""], ["proof (prove)\nusing this:\n  \\<nexists>N. 0 < emeasure M (A N)\n\ngoal (1 subgoal):\n 1. \\<And>N. A N \\<in> null_sets M", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<nexists>N. 0 < emeasure M (A N)\n  A ?N \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<And>N. A N \\<in> null_sets M", "by auto"], ["proof (state)\nthis:\n  A ?N \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. \\<nexists>N. 0 < emeasure M (A N) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  A ?N \\<in> null_sets M", "have \"(\\<Union>N. A N) \\<in> null_sets M\""], ["proof (prove)\nusing this:\n  A ?N \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. \\<Union> (range A) \\<in> null_sets M", "by auto"], ["proof (state)\nthis:\n  \\<Union> (range A) \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. \\<nexists>N. 0 < emeasure M (A N) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<Union> (range A) \\<in> null_sets M", "show False"], ["proof (prove)\nusing this:\n  \\<Union> (range A) \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. False", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<Union> (range A) \\<in> null_sets M\n  0 < emeasure M (\\<Union> (range A))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in prob_space) emeasure_intersection:\n  fixes e::\"nat \\<Rightarrow> real\"\n  assumes [measurable]: \"\\<And>n. U n \\<in> sets M\"\n      and [simp]: \"\\<And>n. 0 \\<le> e n\" \"summable e\"\n      and ge: \"\\<And>n. emeasure M (U n) \\<ge> 1 - (e n)\"\n  shows \"emeasure M (\\<Inter>n. U n) \\<ge> 1 - (\\<Sum>n. e n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "define V where \"V = (\\<lambda>n. space M - (U n))\""], ["proof (state)\nthis:\n  V = (\\<lambda>n. space M - U n)\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "have [measurable]: \"V n \\<in> sets M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. V n \\<in> events", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. space M - U n \\<in> events", "by auto"], ["proof (state)\nthis:\n  V ?n12 \\<in> events\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "have *: \"emeasure M (V n) \\<le> e n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (V n) \\<le> ennreal (e n)", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (space M - U n) \\<le> ennreal (e n)", "using ge[of n]"], ["proof (prove)\nusing this:\n  ennreal (1 - e n) \\<le> emeasure M (U n)\n\ngoal (1 subgoal):\n 1. emeasure M (space M - U n) \\<le> ennreal (e n)", "by (simp add: emeasure_eq_measure prob_compl ennreal_leI)"], ["proof (state)\nthis:\n  emeasure M (V ?n12) \\<le> ennreal (e ?n12)\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "have \"emeasure M (\\<Union>n. V n) \\<le> (\\<Sum>n. emeasure M (V n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (\\<Union> (range V)) \\<le> (\\<Sum>n. emeasure M (V n))", "by (rule emeasure_subadditive_countably, auto)"], ["proof (state)\nthis:\n  emeasure M (\\<Union> (range V)) \\<le> (\\<Sum>n. emeasure M (V n))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "also"], ["proof (state)\nthis:\n  emeasure M (\\<Union> (range V)) \\<le> (\\<Sum>n. emeasure M (V n))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "have \"... \\<le> (\\<Sum>n. ennreal (e n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. emeasure M (V n)) \\<le> (\\<Sum>n. ennreal (e n))", "using *"], ["proof (prove)\nusing this:\n  emeasure M (V ?n12) \\<le> ennreal (e ?n12)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. emeasure M (V n)) \\<le> (\\<Sum>n. ennreal (e n))", "by (intro suminf_le) auto"], ["proof (state)\nthis:\n  (\\<Sum>n. emeasure M (V n)) \\<le> (\\<Sum>n. ennreal (e n))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. emeasure M (V n)) \\<le> (\\<Sum>n. ennreal (e n))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "have \"... = ennreal (\\<Sum>n. e n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (e n)) = ennreal (\\<Sum>n. e n)", "by (intro suminf_ennreal_eq) auto"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (e n)) = ennreal (\\<Sum>n. e n)\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "finally"], ["proof (chain)\npicking this:\n  emeasure M (\\<Union> (range V)) \\<le> ennreal (\\<Sum>n. e n)", "have \"emeasure M (\\<Union>n. V n) \\<le> suminf e\""], ["proof (prove)\nusing this:\n  emeasure M (\\<Union> (range V)) \\<le> ennreal (\\<Sum>n. e n)\n\ngoal (1 subgoal):\n 1. emeasure M (\\<Union> (range V)) \\<le> ennreal (suminf e)", "by simp"], ["proof (state)\nthis:\n  emeasure M (\\<Union> (range V)) \\<le> ennreal (suminf e)\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "then"], ["proof (chain)\npicking this:\n  emeasure M (\\<Union> (range V)) \\<le> ennreal (suminf e)", "have \"1 - suminf e \\<le> emeasure M (space M - (\\<Union>n. V n))\""], ["proof (prove)\nusing this:\n  emeasure M (\\<Union> (range V)) \\<le> ennreal (suminf e)\n\ngoal (1 subgoal):\n 1. ennreal (1 - suminf e) \\<le> emeasure M (space M - \\<Union> (range V))", "by (simp add: emeasure_eq_measure prob_compl suminf_nonneg)"], ["proof (state)\nthis:\n  ennreal (1 - suminf e) \\<le> emeasure M (space M - \\<Union> (range V))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "also"], ["proof (state)\nthis:\n  ennreal (1 - suminf e) \\<le> emeasure M (space M - \\<Union> (range V))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "have \"... \\<le> emeasure M (\\<Inter>n. U n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (space M - \\<Union> (range V))\n    \\<le> emeasure M (\\<Inter> (range U))", "by (rule emeasure_mono) (auto simp: V_def)"], ["proof (state)\nthis:\n  emeasure M (space M - \\<Union> (range V))\n  \\<le> emeasure M (\\<Inter> (range U))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "finally"], ["proof (chain)\npicking this:\n  ennreal (1 - suminf e) \\<le> emeasure M (\\<Inter> (range U))", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (1 - suminf e) \\<le> emeasure M (\\<Inter> (range U))\n\ngoal (1 subgoal):\n 1. ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))", "by simp"], ["proof (state)\nthis:\n  ennreal (1 - (\\<Sum>n. e n)) \\<le> emeasure M (\\<Inter> (range U))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma null_sym_diff_transitive:\n  assumes \"A \\<Delta> B \\<in> null_sets M\" \"B \\<Delta> C \\<in> null_sets M\"\n      and [measurable]: \"A \\<in> sets M\" \"C \\<in> sets M\"\n  shows \"A \\<Delta> C \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<in> null_sets M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<in> null_sets M", "have \"A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  A \\<Delta> B \\<in> null_sets M\n  B \\<Delta> C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M", "by auto"], ["proof (state)\nthis:\n  A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<in> null_sets M", "moreover"], ["proof (state)\nthis:\n  A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<in> null_sets M", "have \"A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C", "by auto"], ["proof (state)\nthis:\n  A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C\n\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<in> null_sets M", "ultimately"], ["proof (chain)\npicking this:\n  A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M\n  A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<Delta> B \\<union> B \\<Delta> C \\<in> null_sets M\n  A \\<Delta> C \\<subseteq> A \\<Delta> B \\<union> B \\<Delta> C\n\ngoal (1 subgoal):\n 1. A \\<Delta> C \\<in> null_sets M", "by (meson null_sets_subset assms(3) assms(4) sets.Diff sets.Un)"], ["proof (state)\nthis:\n  A \\<Delta> C \\<in> null_sets M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Delta_null_of_null_is_null:\n  assumes \"B \\<in> sets M\" \"A \\<Delta> B \\<in> null_sets M\" \"A \\<in> null_sets M\"\n  shows \"B \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "have \"B \\<subseteq> A \\<union> (A \\<Delta> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> A \\<union> A \\<Delta> B", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> A \\<union> A \\<Delta> B\n\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "then"], ["proof (chain)\npicking this:\n  B \\<subseteq> A \\<union> A \\<Delta> B", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<subseteq> A \\<union> A \\<Delta> B\n\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "using assms"], ["proof (prove)\nusing this:\n  B \\<subseteq> A \\<union> A \\<Delta> B\n  B \\<in> sets M\n  A \\<Delta> B \\<in> null_sets M\n  A \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. B \\<in> null_sets M", "by (meson null_sets.Un null_sets_subset)"], ["proof (state)\nthis:\n  B \\<in> null_sets M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Delta_null_same_emeasure:\n  assumes \"A \\<Delta> B \\<in> null_sets M\" and [measurable]: \"A \\<in> sets M\" \"B \\<in> sets M\"\n  shows \"emeasure M A = emeasure M B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "have \"A = (A \\<inter> B) \\<union> (A-B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A \\<inter> B \\<union> (A - B)", "by blast"], ["proof (state)\nthis:\n  A = A \\<inter> B \\<union> (A - B)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "moreover"], ["proof (state)\nthis:\n  A = A \\<inter> B \\<union> (A - B)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "have \"A-B \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B \\<in> null_sets M", "using assms null_sets_subset"], ["proof (prove)\nusing this:\n  A \\<Delta> B \\<in> null_sets M\n  A \\<in> sets M\n  B \\<in> sets M\n  \\<lbrakk>?B \\<in> null_sets ?M; ?A \\<in> sets ?M;\n   ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> ?A \\<in> null_sets ?M\n\ngoal (1 subgoal):\n 1. A - B \\<in> null_sets M", "by blast"], ["proof (state)\nthis:\n  A - B \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "ultimately"], ["proof (chain)\npicking this:\n  A = A \\<inter> B \\<union> (A - B)\n  A - B \\<in> null_sets M", "have a: \"emeasure M A = emeasure M (A \\<inter> B)\""], ["proof (prove)\nusing this:\n  A = A \\<inter> B \\<union> (A - B)\n  A - B \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M (A \\<inter> B)", "using emeasure_Un_null_set"], ["proof (prove)\nusing this:\n  A = A \\<inter> B \\<union> (A - B)\n  A - B \\<in> null_sets M\n  \\<lbrakk>?A \\<in> sets ?M; ?B \\<in> null_sets ?M\\<rbrakk>\n  \\<Longrightarrow> emeasure ?M (?A \\<union> ?B) = emeasure ?M ?A\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M (A \\<inter> B)", "by (metis assms(2) assms(3) sets.Int)"], ["proof (state)\nthis:\n  emeasure M A = emeasure M (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "have \"B = (A \\<inter> B) \\<union> (B-A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = A \\<inter> B \\<union> (B - A)", "by blast"], ["proof (state)\nthis:\n  B = A \\<inter> B \\<union> (B - A)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "moreover"], ["proof (state)\nthis:\n  B = A \\<inter> B \\<union> (B - A)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "have \"B-A \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - A \\<in> null_sets M", "using assms null_sets_subset"], ["proof (prove)\nusing this:\n  A \\<Delta> B \\<in> null_sets M\n  A \\<in> sets M\n  B \\<in> sets M\n  \\<lbrakk>?B \\<in> null_sets ?M; ?A \\<in> sets ?M;\n   ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> ?A \\<in> null_sets ?M\n\ngoal (1 subgoal):\n 1. B - A \\<in> null_sets M", "by blast"], ["proof (state)\nthis:\n  B - A \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "ultimately"], ["proof (chain)\npicking this:\n  B = A \\<inter> B \\<union> (B - A)\n  B - A \\<in> null_sets M", "have \"emeasure M B = emeasure M (A \\<inter> B)\""], ["proof (prove)\nusing this:\n  B = A \\<inter> B \\<union> (B - A)\n  B - A \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. emeasure M B = emeasure M (A \\<inter> B)", "using emeasure_Un_null_set"], ["proof (prove)\nusing this:\n  B = A \\<inter> B \\<union> (B - A)\n  B - A \\<in> null_sets M\n  \\<lbrakk>?A \\<in> sets ?M; ?B \\<in> null_sets ?M\\<rbrakk>\n  \\<Longrightarrow> emeasure ?M (?A \\<union> ?B) = emeasure ?M ?A\n\ngoal (1 subgoal):\n 1. emeasure M B = emeasure M (A \\<inter> B)", "by (metis assms(2) assms(3) sets.Int)"], ["proof (state)\nthis:\n  emeasure M B = emeasure M (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "then"], ["proof (chain)\npicking this:\n  emeasure M B = emeasure M (A \\<inter> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure M B = emeasure M (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "using a"], ["proof (prove)\nusing this:\n  emeasure M B = emeasure M (A \\<inter> B)\n  emeasure M A = emeasure M (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. emeasure M A = emeasure M B", "by auto"], ["proof (state)\nthis:\n  emeasure M A = emeasure M B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_upper_bound_inf_ereal:\n  fixes F G::\"'a \\<Rightarrow> ereal\"\n  assumes \"\\<And>e. (e::real) > 0 \\<Longrightarrow> AE x in M. F x \\<le> G x + e\"\n  shows \"AE x in M. F x \\<le> G x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. F x \\<le> G x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE x in M. F x \\<le> G x", "have \"AE x in M. \\<forall>n::nat. F x \\<le> G x + ereal (1 / Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))", "using assms"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> AE x in M. F x \\<le> G x + ereal ?e\n\ngoal (1 subgoal):\n 1. AE x in M. \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))", "by (auto simp: AE_all_countable)"], ["proof (state)\nthis:\n  AE x in M. \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. AE x in M. F x \\<le> G x", "then"], ["proof (chain)\npicking this:\n  AE x in M. \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))", "show ?thesis"], ["proof (prove)\nusing this:\n  AE x in M. \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. AE x in M. F x \\<le> G x", "proof (eventually_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>n.\n          F x \\<le> G x + ereal (1 / real (Suc n)) \\<Longrightarrow>\n       F x \\<le> G x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>n.\n          F x \\<le> G x + ereal (1 / real (Suc n)) \\<Longrightarrow>\n       F x \\<le> G x", "assume x: \"\\<forall>n::nat. F x \\<le> G x + ereal (1 / Suc n)\""], ["proof (state)\nthis:\n  \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>n.\n          F x \\<le> G x + ereal (1 / real (Suc n)) \\<Longrightarrow>\n       F x \\<le> G x", "show \"F x \\<le> G x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F x \\<le> G x", "proof (intro ereal_le_epsilon2[of _ \"G x\"] allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "assume \"0 < e\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "then"], ["proof (chain)\npicking this:\n  0 < e", "obtain n where n: \"1 / Suc n < e\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        1 / real (Suc n) < e \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: nat_approx_posE)"], ["proof (state)\nthis:\n  1 / real (Suc n) < e\n\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "have \"F x \\<le> G x + 1 / Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F x \\<le> G x + ereal (1 / real (Suc n))", "using x"], ["proof (prove)\nusing this:\n  \\<forall>n. F x \\<le> G x + ereal (1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. F x \\<le> G x + ereal (1 / real (Suc n))", "by simp"], ["proof (state)\nthis:\n  F x \\<le> G x + ereal (1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "also"], ["proof (state)\nthis:\n  F x \\<le> G x + ereal (1 / real (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "have \"\\<dots> \\<le> G x + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G x + ereal (1 / real (Suc n)) \\<le> G x + ereal e", "using n"], ["proof (prove)\nusing this:\n  1 / real (Suc n) < e\n\ngoal (1 subgoal):\n 1. G x + ereal (1 / real (Suc n)) \\<le> G x + ereal e", "by (intro add_mono ennreal_leI) auto"], ["proof (state)\nthis:\n  G x + ereal (1 / real (Suc n)) \\<le> G x + ereal e\n\ngoal (1 subgoal):\n 1. \\<And>e. 0 < e \\<Longrightarrow> F x \\<le> G x + ereal e", "finally"], ["proof (chain)\npicking this:\n  F x \\<le> G x + ereal e", "show \"F x \\<le> G x + ereal e\""], ["proof (prove)\nusing this:\n  F x \\<le> G x + ereal e\n\ngoal (1 subgoal):\n 1. F x \\<le> G x + ereal e", "."], ["proof (state)\nthis:\n  F x \\<le> G x + ereal e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F x \\<le> G x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE x in M. F x \\<le> G x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Egorov theorem asserts that, if a sequence of functions converges almost everywhere to a\nlimit, then the convergence is uniform on a subset of close to full measure. The first step in the\nproof is the following lemma, often useful by itself, asserting the same result for predicates:\nif a property $P_n x$ is eventually true for almost every $x$, then there exists $N$\nsuch that $P_n x$ is true for all $n\\geq N$ and all $x$ in a set of close to full measure.\n\\<close>"], ["", "lemma (in finite_measure) Egorov_lemma:\n  assumes [measurable]: \"\\<And>n. (P n) \\<in> measurable M (count_space UNIV)\"\n      and \"AE x in M. eventually (\\<lambda>n. P n x) sequentially\"\n          \"epsilon > 0\"\n  shows \"\\<exists>U N. U \\<in> sets M \\<and> (\\<forall>n \\<ge> N. \\<forall>x \\<in> U. P n x) \\<and> emeasure M (space M - U) < epsilon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "define K where \"K = (\\<lambda>n. {x \\<in> space M. \\<exists>k\\<ge>n. \\<not>(P k x)})\""], ["proof (state)\nthis:\n  K = (\\<lambda>n. {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have [measurable]: \"K n \\<in> sets M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. K n \\<in> sets M", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x} \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  K ?n \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have \"x \\<notin> (\\<Inter>n. K n)\" if \"eventually (\\<lambda>n. P n x) sequentially\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<Inter> (range K)", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> (\\<Inter>n.\n                   {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})", "using that"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. P n x\n\ngoal (1 subgoal):\n 1. x \\<notin> (\\<Inter>n.\n                   {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})", "unfolding K_def eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. P n x\n\ngoal (1 subgoal):\n 1. x \\<notin> (\\<Inter>n.\n                   {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. P n ?x \\<Longrightarrow>\n  ?x \\<notin> \\<Inter> (range K)\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. P n ?x \\<Longrightarrow>\n  ?x \\<notin> \\<Inter> (range K)", "have \"AE x in M. x \\<notin> (\\<Inter>n. K n)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. P n ?x \\<Longrightarrow>\n  ?x \\<notin> \\<Inter> (range K)\n\ngoal (1 subgoal):\n 1. AE x in M. x \\<notin> \\<Inter> (range K)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. P n ?x \\<Longrightarrow>\n  ?x \\<notin> \\<Inter> (range K)\n  Measurable.pred M (P ?n)\n  AE x in M. \\<forall>\\<^sub>F n in sequentially. P n x\n  0 < epsilon\n\ngoal (1 subgoal):\n 1. AE x in M. x \\<notin> \\<Inter> (range K)", "by auto"], ["proof (state)\nthis:\n  AE x in M. x \\<notin> \\<Inter> (range K)\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "then"], ["proof (chain)\npicking this:\n  AE x in M. x \\<notin> \\<Inter> (range K)", "have Z: \"0 = emeasure M (\\<Inter>n. K n)\""], ["proof (prove)\nusing this:\n  AE x in M. x \\<notin> \\<Inter> (range K)\n\ngoal (1 subgoal):\n 1. 0 = emeasure M (\\<Inter> (range K))", "using AE_iff_measurable[of \"(\\<Inter>n. K n)\" M \"\\<lambda>x. x \\<notin> (\\<Inter>n. K n)\"]"], ["proof (prove)\nusing this:\n  AE x in M. x \\<notin> \\<Inter> (range K)\n  \\<lbrakk>\\<Inter> (range K) \\<in> sets M;\n   {x \\<in> space M. \\<not> x \\<notin> \\<Inter> (range K)} =\n   \\<Inter> (range K)\\<rbrakk>\n  \\<Longrightarrow> (AE x in M. x \\<notin> \\<Inter> (range K)) =\n                    (emeasure M (\\<Inter> (range K)) = 0)\n\ngoal (1 subgoal):\n 1. 0 = emeasure M (\\<Inter> (range K))", "unfolding K_def"], ["proof (prove)\nusing this:\n  AE x in M. x \\<notin> (\\<Inter>n.\n                            {x \\<in> space M.\n                             \\<exists>k\\<ge>n. \\<not> P k x})\n  \\<lbrakk>(\\<Inter>n. {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})\n           \\<in> sets M;\n   {x \\<in> space M.\n    \\<not> x \\<notin> (\\<Inter>n.\n                          {x \\<in> space M.\n                           \\<exists>k\\<ge>n. \\<not> P k x})} =\n   (\\<Inter>n. {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})\\<rbrakk>\n  \\<Longrightarrow> (AE x in M. x \\<notin> (\\<Inter>n.\n         {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})) =\n                    (emeasure M\n                      (\\<Inter>n.\n                          {x \\<in> space M.\n                           \\<exists>k\\<ge>n. \\<not> P k x}) =\n                     0)\n\ngoal (1 subgoal):\n 1. 0 =\n    emeasure M\n     (\\<Inter>n. {x \\<in> space M. \\<exists>k\\<ge>n. \\<not> P k x})", "by auto"], ["proof (state)\nthis:\n  0 = emeasure M (\\<Inter> (range K))\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have *: \"(\\<lambda>n. emeasure M (K n)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure M (K n)) \\<longlonglongrightarrow> 0", "unfolding Z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure M (K n))\n    \\<longlonglongrightarrow> emeasure M (\\<Inter> (range K))", "apply (rule Lim_emeasure_decseq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. range K \\<subseteq> sets M\n 2. decseq K\n 3. \\<And>n. emeasure M (K n) \\<noteq> \\<infinity>", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (3 subgoals):\n 1. range K \\<subseteq> sets M\n 2. decseq K\n 3. \\<And>n. emeasure M (K n) \\<noteq> \\<infinity>", "by (auto simp add: K_def decseq_def)"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure M (K n)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have \"eventually (\\<lambda>n. emeasure M (K n) < epsilon) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. emeasure M (K n) < epsilon", "by (rule order_tendstoD(2)[OF * \\<open>epsilon > 0\\<close>])"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. emeasure M (K n) < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. emeasure M (K n) < epsilon", "obtain N where N: \"\\<And>n. n \\<ge> N \\<Longrightarrow> emeasure M (K n) < epsilon\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. emeasure M (K n) < epsilon\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            emeasure M (K n) < epsilon) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. emeasure M (K n) < epsilon\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            emeasure M (K n) < epsilon) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow> emeasure M (K ?n) < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "define U where \"U = space M - K N\""], ["proof (state)\nthis:\n  U = space M - K N\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have A [measurable]: \"U \\<in> sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<in> sets M", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. space M - K N \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  U \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have \"space M - U = K N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space M - U = K N", "unfolding U_def K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. space M -\n    (space M - {x \\<in> space M. \\<exists>k\\<ge>N. \\<not> P k x}) =\n    {x \\<in> space M. \\<exists>k\\<ge>N. \\<not> P k x}", "by auto"], ["proof (state)\nthis:\n  space M - U = K N\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "then"], ["proof (chain)\npicking this:\n  space M - U = K N", "have B: \"emeasure M (space M - U) < epsilon\""], ["proof (prove)\nusing this:\n  space M - U = K N\n\ngoal (1 subgoal):\n 1. emeasure M (space M - U) < epsilon", "using N"], ["proof (prove)\nusing this:\n  space M - U = K N\n  N \\<le> ?n \\<Longrightarrow> emeasure M (K ?n) < epsilon\n\ngoal (1 subgoal):\n 1. emeasure M (space M - U) < epsilon", "by auto"], ["proof (state)\nthis:\n  emeasure M (space M - U) < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "have \"\\<forall>n \\<ge> N. \\<forall>x \\<in> U. P n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x", "unfolding U_def K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>N.\n       \\<forall>x\\<in>space M -\n                      {x \\<in> space M. \\<exists>k\\<ge>N. \\<not> P k x}.\n          P n x", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "using A B"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x\n  U \\<in> sets M\n  emeasure M (space M - U) < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>U N.\n       U \\<in> sets M \\<and>\n       (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n       emeasure M (space M - U) < epsilon", "by blast"], ["proof (state)\nthis:\n  \\<exists>U N.\n     U \\<in> sets M \\<and>\n     (\\<forall>n\\<ge>N. \\<forall>x\\<in>U. P n x) \\<and>\n     emeasure M (space M - U) < epsilon\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma asserts that, in an uncountable family of disjoint sets, then there is one\nset with zero measure (and in fact uncountably many). It is often applied to the boundaries of\n$r$-neighborhoods of a given set, to show that one could choose $r$ for which this boundary has\nzero measure (this shows up often in relation with weak convergence).\\<close>"], ["", "lemma (in finite_measure) uncountable_disjoint_family_then_exists_zero_measure:\n  assumes [measurable]: \"\\<And>i. i \\<in> I \\<Longrightarrow> A i \\<in> sets M\"\n      and \"uncountable I\"\n          \"disjoint_family_on A I\"\n  shows \"\\<exists>i\\<in>I. measure M (A i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "define f where \"f = (\\<lambda>(r::real). {i \\<in> I. measure M (A i) > r})\""], ["proof (state)\nthis:\n  f = (\\<lambda>r. {i \\<in> I. r < Sigma_Algebra.measure M (A i)})\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "have *: \"finite (f r)\" if \"r > 0\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (f r)", "obtain N::nat where N: \"measure M (space M)/r \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        Sigma_Algebra.measure M (space M) / r \\<le> real N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using real_arch_simple"], ["proof (prove)\nusing this:\n  \\<exists>n. ?x \\<le> of_nat n\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        Sigma_Algebra.measure M (space M) / r \\<le> real N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M (space M) / r \\<le> real N\n\ngoal (1 subgoal):\n 1. finite (f r)", "have \"finite (f r) \\<and> card (f r) \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (f r) \\<and> card (f r) \\<le> N", "proof (rule finite_if_finite_subsets_card_bdd)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "fix G"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "assume G: \"G \\<subseteq> f r\" \"finite G\""], ["proof (state)\nthis:\n  G \\<subseteq> f r\n  finite G\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "then"], ["proof (chain)\npicking this:\n  G \\<subseteq> f r\n  finite G", "have \"G \\<subseteq> I\""], ["proof (prove)\nusing this:\n  G \\<subseteq> f r\n  finite G\n\ngoal (1 subgoal):\n 1. G \\<subseteq> I", "unfolding f_def"], ["proof (prove)\nusing this:\n  G \\<subseteq> {i \\<in> I. r < Sigma_Algebra.measure M (A i)}\n  finite G\n\ngoal (1 subgoal):\n 1. G \\<subseteq> I", "by auto"], ["proof (state)\nthis:\n  G \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "have \"card G * r = (\\<Sum>i \\<in> G. r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card G) * r = (\\<Sum>i\\<in>G. r)", "by auto"], ["proof (state)\nthis:\n  real (card G) * r = (\\<Sum>i\\<in>G. r)\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "also"], ["proof (state)\nthis:\n  real (card G) * r = (\\<Sum>i\\<in>G. r)\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "have \"... \\<le> (\\<Sum>i \\<in> G. measure M (A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>G. r) \\<le> (\\<Sum>i\\<in>G. Sigma_Algebra.measure M (A i))", "apply (rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> G \\<Longrightarrow> r \\<le> Sigma_Algebra.measure M (A i)", "using G"], ["proof (prove)\nusing this:\n  G \\<subseteq> f r\n  finite G\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> G \\<Longrightarrow> r \\<le> Sigma_Algebra.measure M (A i)", "unfolding f_def"], ["proof (prove)\nusing this:\n  G \\<subseteq> {i \\<in> I. r < Sigma_Algebra.measure M (A i)}\n  finite G\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> G \\<Longrightarrow> r \\<le> Sigma_Algebra.measure M (A i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>G. r) \\<le> (\\<Sum>i\\<in>G. Sigma_Algebra.measure M (A i))\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>G. r) \\<le> (\\<Sum>i\\<in>G. Sigma_Algebra.measure M (A i))\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "have \"... = measure M (\\<Union>i\\<in>G. A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>G. Sigma_Algebra.measure M (A i)) =\n    Sigma_Algebra.measure M (\\<Union> (A ` G))", "apply (rule finite_measure_finite_Union[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite G\n 2. A ` G \\<subseteq> sets M\n 3. disjoint_family_on A G", "using \\<open>finite G\\<close> \\<open>G \\<subseteq> I\\<close> \\<open>disjoint_family_on A I\\<close> disjoint_family_on_mono"], ["proof (prove)\nusing this:\n  finite G\n  G \\<subseteq> I\n  disjoint_family_on A I\n  \\<lbrakk>?A \\<subseteq> ?B; disjoint_family_on ?f ?B\\<rbrakk>\n  \\<Longrightarrow> disjoint_family_on ?f ?A\n\ngoal (3 subgoals):\n 1. finite G\n 2. A ` G \\<subseteq> sets M\n 3. disjoint_family_on A G", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>G. Sigma_Algebra.measure M (A i)) =\n  Sigma_Algebra.measure M (\\<Union> (A ` G))\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>G. Sigma_Algebra.measure M (A i)) =\n  Sigma_Algebra.measure M (\\<Union> (A ` G))\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "have \"... \\<le> measure M (space M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (\\<Union> (A ` G))\n    \\<le> Sigma_Algebra.measure M (space M)", "by (simp add: bounded_measure)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M (\\<Union> (A ` G))\n  \\<le> Sigma_Algebra.measure M (space M)\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "finally"], ["proof (chain)\npicking this:\n  real (card G) * r \\<le> Sigma_Algebra.measure M (space M)", "have \"card G \\<le> measure M (space M)/r\""], ["proof (prove)\nusing this:\n  real (card G) * r \\<le> Sigma_Algebra.measure M (space M)\n\ngoal (1 subgoal):\n 1. real (card G) \\<le> Sigma_Algebra.measure M (space M) / r", "using \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  real (card G) * r \\<le> Sigma_Algebra.measure M (space M)\n  0 < r\n\ngoal (1 subgoal):\n 1. real (card G) \\<le> Sigma_Algebra.measure M (space M) / r", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  real (card G) \\<le> Sigma_Algebra.measure M (space M) / r\n\ngoal (1 subgoal):\n 1. \\<And>G.\n       \\<lbrakk>G \\<subseteq> f r; finite G\\<rbrakk>\n       \\<Longrightarrow> card G \\<le> N", "then"], ["proof (chain)\npicking this:\n  real (card G) \\<le> Sigma_Algebra.measure M (space M) / r", "show \"card G \\<le> N\""], ["proof (prove)\nusing this:\n  real (card G) \\<le> Sigma_Algebra.measure M (space M) / r\n\ngoal (1 subgoal):\n 1. card G \\<le> N", "using N"], ["proof (prove)\nusing this:\n  real (card G) \\<le> Sigma_Algebra.measure M (space M) / r\n  Sigma_Algebra.measure M (space M) / r \\<le> real N\n\ngoal (1 subgoal):\n 1. card G \\<le> N", "by auto"], ["proof (state)\nthis:\n  card G \\<le> N\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (f r) \\<and> card (f r) \\<le> N\n\ngoal (1 subgoal):\n 1. finite (f r)", "then"], ["proof (chain)\npicking this:\n  finite (f r) \\<and> card (f r) \\<le> N", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (f r) \\<and> card (f r) \\<le> N\n\ngoal (1 subgoal):\n 1. finite (f r)", "by simp"], ["proof (state)\nthis:\n  finite (f r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?r \\<Longrightarrow> finite (f ?r)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "have \"countable (\\<Union>n. f (((1::real)/2)^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (\\<Union>n. f ((1 / 2) ^ n))", "by (rule countable_UN, auto intro!: countable_finite *)"], ["proof (state)\nthis:\n  countable (\\<Union>n. f ((1 / 2) ^ n))\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "then"], ["proof (chain)\npicking this:\n  countable (\\<Union>n. f ((1 / 2) ^ n))", "have \"I - (\\<Union>n. f (((1::real)/2)^n)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  countable (\\<Union>n. f ((1 / 2) ^ n))\n\ngoal (1 subgoal):\n 1. I - (\\<Union>n. f ((1 / 2) ^ n)) \\<noteq> {}", "using assms(2)"], ["proof (prove)\nusing this:\n  countable (\\<Union>n. f ((1 / 2) ^ n))\n  uncountable I\n\ngoal (1 subgoal):\n 1. I - (\\<Union>n. f ((1 / 2) ^ n)) \\<noteq> {}", "by (metis countable_empty uncountable_minus_countable)"], ["proof (state)\nthis:\n  I - (\\<Union>n. f ((1 / 2) ^ n)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "then"], ["proof (chain)\npicking this:\n  I - (\\<Union>n. f ((1 / 2) ^ n)) \\<noteq> {}", "obtain i where \"i \\<in> I\" \"i \\<notin> (\\<Union>n. f ((1/2)^n))\""], ["proof (prove)\nusing this:\n  I - (\\<Union>n. f ((1 / 2) ^ n)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; i \\<notin> (\\<Union>n. f ((1 / 2) ^ n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> I\n  i \\<notin> (\\<Union>n. f ((1 / 2) ^ n))\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "then"], ["proof (chain)\npicking this:\n  i \\<in> I\n  i \\<notin> (\\<Union>n. f ((1 / 2) ^ n))", "have \"measure M (A i) \\<le> (1 / 2) ^ n\" for n"], ["proof (prove)\nusing this:\n  i \\<in> I\n  i \\<notin> (\\<Union>n. f ((1 / 2) ^ n))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ n", "unfolding f_def"], ["proof (prove)\nusing this:\n  i \\<in> I\n  i \\<notin> (\\<Union>n.\n                 {i \\<in> I. (1 / 2) ^ n < Sigma_Algebra.measure M (A i)})\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ n", "using linorder_not_le"], ["proof (prove)\nusing this:\n  i \\<in> I\n  i \\<notin> (\\<Union>n.\n                 {i \\<in> I. (1 / 2) ^ n < Sigma_Algebra.measure M (A i)})\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ n", "by auto"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ ?n\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "moreover"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ ?n\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "have \"(\\<lambda>n. ((1::real) / 2) ^ n) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (^) (1 / 2) \\<longlonglongrightarrow> 0", "by (intro tendsto_intros, auto)"], ["proof (state)\nthis:\n  (^) (1 / 2) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "ultimately"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ ?n\n  (^) (1 / 2) \\<longlonglongrightarrow> 0", "have \"measure M (A i) \\<le> 0\""], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ ?n\n  (^) (1 / 2) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (A i) \\<le> 0", "using LIMSEQ_le_const"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M (A i) \\<le> (1 / 2) ^ ?n\n  (^) (1 / 2) \\<longlonglongrightarrow> 0\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?x;\n   \\<exists>N. \\<forall>n\\<ge>N. ?a \\<le> ?X n\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> ?x\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (A i) \\<le> 0", "by force"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M (A i) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "then"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure M (A i) \\<le> 0", "have \"measure M (A i) = 0\""], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M (A i) \\<le> 0\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M (A i) = 0", "by (simp add: measure_le_0_iff)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M (A i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "then"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure M (A i) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M (A i) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "using \\<open>i \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M (A i) = 0\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>i\\<in>I. Sigma_Algebra.measure M (A i) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next statements are useful measurability statements.\\<close>"], ["", "lemma measurable_Inf [measurable]:\n  assumes [measurable]: \"\\<And>(n::nat). P n \\<in> measurable M (count_space UNIV)\"\n  shows \"(\\<lambda>x. Inf {n. P n x}) \\<in> measurable M (count_space UNIV)\" (is \"?f \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sqinter> {n. P n x})\n    \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sqinter> {n. P n x})\n    \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV", "define A where \"A = (\\<lambda>n. (P n)-`{True} \\<inter> space M - (\\<Union>m<n. (P m)-`{True} \\<inter> space M))\""], ["proof (state)\nthis:\n  A =\n  (\\<lambda>n.\n      P n -` {True} \\<inter> space M -\n      (\\<Union>m<n. P m -` {True} \\<inter> space M))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sqinter> {n. P n x})\n    \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV", "have A_meas [measurable]: \"A n \\<in> sets M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. A n \\<in> sets M", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P n -` {True} \\<inter> space M -\n    (\\<Union>m<n. P m -` {True} \\<inter> space M)\n    \\<in> sets M", "by measurable"], ["proof (state)\nthis:\n  A ?n \\<in> sets M\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sqinter> {n. P n x})\n    \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV", "define B where \"B = (\\<lambda>n. if n = 0 then (space M - (\\<Union>n. A n)) else A (n-1))\""], ["proof (state)\nthis:\n  B =\n  (\\<lambda>n. if n = 0 then space M - \\<Union> (range A) else A (n - 1))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sqinter> {n. P n x})\n    \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sqinter> {n. P n x})\n    \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV", "proof (rule measurable_piecewise_restrict2[of B])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n. B n \\<in> sets M\n 2. space M = \\<Union> (range B)\n 3. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "show \"B n \\<in> sets M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. B n \\<in> sets M", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n = 0 then space M - \\<Union> (range A) else A (n - 1)) \\<in> sets M", "by simp"], ["proof (state)\nthis:\n  B ?n \\<in> sets M\n\ngoal (2 subgoals):\n 1. space M = \\<Union> (range B)\n 2. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "show \"space M = (\\<Union>n. B n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space M = \\<Union> (range B)", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. space M =\n    (\\<Union>n. if n = 0 then space M - \\<Union> (range A) else A (n - 1))", "using sets.sets_into_space [OF A_meas]"], ["proof (prove)\nusing this:\n  A ?n1 \\<subseteq> space M\n\ngoal (1 subgoal):\n 1. space M =\n    (\\<Union>n. if n = 0 then space M - \\<Union> (range A) else A (n - 1))", "by auto"], ["proof (state)\nthis:\n  space M = \\<Union> (range B)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "have *: \"?f x = n\" if \"x \\<in> A n\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {n. P n x} = n", "apply (rule cInf_eq_minimum)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<in> {n. P n x}\n 2. \\<And>xa. xa \\<in> {n. P n x} \\<Longrightarrow> n \\<le> xa", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A n\n\ngoal (2 subgoals):\n 1. n \\<in> {n. P n x}\n 2. \\<And>xa. xa \\<in> {n. P n x} \\<Longrightarrow> n \\<le> xa", "unfolding A_def"], ["proof (prove)\nusing this:\n  x \\<in> P n -` {True} \\<inter> space M -\n          (\\<Union>m<n. P m -` {True} \\<inter> space M)\n\ngoal (2 subgoals):\n 1. n \\<in> {n. P n x}\n 2. \\<And>xa. xa \\<in> {n. P n x} \\<Longrightarrow> n \\<le> xa", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> A ?n \\<Longrightarrow> \\<Sqinter> {n. P n ?x} = ?n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> A ?n \\<Longrightarrow> \\<Sqinter> {n. P n ?x} = ?n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "have **: \"?f x = (Inf ({}::nat set))\" if \"x \\<in> space M - (\\<Union>n. A n)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {n. P n x} = \\<Sqinter> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sqinter> {n. P n x} = \\<Sqinter> {}", "have \"\\<not>(P n x)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> P n x", "apply (induction n rule: nat_less_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. \\<forall>m<n. \\<not> P m x \\<Longrightarrow> \\<not> P n x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> space M - \\<Union> (range A)\n\ngoal (1 subgoal):\n 1. \\<And>n. \\<forall>m<n. \\<not> P m x \\<Longrightarrow> \\<not> P n x", "unfolding A_def"], ["proof (prove)\nusing this:\n  x \\<in> space M -\n          (\\<Union>n.\n              P n -` {True} \\<inter> space M -\n              (\\<Union>m<n. P m -` {True} \\<inter> space M))\n\ngoal (1 subgoal):\n 1. \\<And>n. \\<forall>m<n. \\<not> P m x \\<Longrightarrow> \\<not> P n x", "by auto"], ["proof (state)\nthis:\n  \\<not> P ?n x\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {n. P n x} = \\<Sqinter> {}", "then"], ["proof (chain)\npicking this:\n  \\<not> P ?n x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> P ?n x\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {n. P n x} = \\<Sqinter> {}", "by simp"], ["proof (state)\nthis:\n  \\<Sqinter> {n. P n x} = \\<Sqinter> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n  \\<Sqinter> {n. P n ?x} = \\<Sqinter> {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> A ?n \\<Longrightarrow> \\<Sqinter> {n. P n ?x} = ?n\n  ?x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n  \\<Sqinter> {n. P n ?x} = \\<Sqinter> {}", "have \"\\<exists>c. \\<forall>x \\<in> B n. ?f x = c\" for n"], ["proof (prove)\nusing this:\n  ?x \\<in> A ?n \\<Longrightarrow> \\<Sqinter> {n. P n ?x} = ?n\n  ?x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n  \\<Sqinter> {n. P n ?x} = \\<Sqinter> {}\n\ngoal (1 subgoal):\n 1. \\<exists>c. \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = c", "apply (cases \"n = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x n.\n                x \\<in> A n \\<Longrightarrow> \\<Sqinter> {n. P n x} = n;\n     \\<And>x.\n        x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n        \\<Sqinter> {n. P n x} = \\<Sqinter> {};\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = c\n 2. \\<lbrakk>\\<And>x n.\n                x \\<in> A n \\<Longrightarrow> \\<Sqinter> {n. P n x} = n;\n     \\<And>x.\n        x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n        \\<Sqinter> {n. P n x} = \\<Sqinter> {};\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = c", "unfolding B_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x n.\n                x \\<in> A n \\<Longrightarrow> \\<Sqinter> {n. P n x} = n;\n     \\<And>x.\n        x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n        \\<Sqinter> {n. P n x} = \\<Sqinter> {};\n     n = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         \\<forall>x\\<in>if n = 0\n  then space M - \\<Union> (range A) else A (n - 1).\n                            \\<Sqinter> {n. P n x} = c\n 2. \\<lbrakk>\\<And>x n.\n                x \\<in> A n \\<Longrightarrow> \\<Sqinter> {n. P n x} = n;\n     \\<And>x.\n        x \\<in> space M - \\<Union> (range A) \\<Longrightarrow>\n        \\<Sqinter> {n. P n x} = \\<Sqinter> {};\n     n \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         \\<forall>x\\<in>if n = 0\n  then space M - \\<Union> (range A) else A (n - 1).\n                            \\<Sqinter> {n. P n x} = c", "by auto"], ["proof (state)\nthis:\n  \\<exists>c. \\<forall>x\\<in>B ?n. \\<Sqinter> {n. P n x} = c\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n          \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. \\<forall>x\\<in>B ?n. \\<Sqinter> {n. P n x} = c", "show \"\\<exists>h \\<in> measurable M (count_space UNIV). \\<forall>x \\<in> B n. ?f x = h x\" for n"], ["proof (prove)\nusing this:\n  \\<exists>c. \\<forall>x\\<in>B ?n. \\<Sqinter> {n. P n x} = c\n\ngoal (1 subgoal):\n 1. \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n       \\<forall>x\\<in>B n. \\<Sqinter> {n. P n x} = h x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>h\\<in>M \\<rightarrow>\\<^sub>M count_space UNIV.\n     \\<forall>x\\<in>B ?n. \\<Sqinter> {n. P n x} = h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<Sqinter> {n. P n x})\n  \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_T_iter [measurable]:\n  fixes f::\"'a \\<Rightarrow> nat\"\n  assumes [measurable]: \"T \\<in> measurable M M\"\n          \"f \\<in> measurable M (count_space UNIV)\"\n  shows \"(\\<lambda>x. (T^^(f x)) x) \\<in> measurable M M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (T ^^ f x) x) \\<in> M \\<rightarrow>\\<^sub>M M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (T ^^ f x) x) \\<in> M \\<rightarrow>\\<^sub>M M", "have [measurable]: \"(T^^n) \\<in> measurable M M\" for n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. T ^^ n \\<in> M \\<rightarrow>\\<^sub>M M", "by (induction n, auto)"], ["proof (state)\nthis:\n  T ^^ ?n \\<in> M \\<rightarrow>\\<^sub>M M\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. (T ^^ f x) x) \\<in> M \\<rightarrow>\\<^sub>M M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (T ^^ f x) x) \\<in> M \\<rightarrow>\\<^sub>M M", "by (rule measurable_compose_countable, auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. (T ^^ f x) x) \\<in> M \\<rightarrow>\\<^sub>M M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_infdist [measurable]:\n  \"(\\<lambda>x. infdist x S) \\<in> borel_measurable borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. infdist x S) \\<in> borel_measurable borel", "by (rule borel_measurable_continuous_onI, intro continuous_intros)"], ["", "text \\<open>The next lemma shows that, in a sigma finite measure space, sets with large measure\ncan be approximated by sets with large but finite measure.\\<close>"], ["", "lemma (in sigma_finite_measure) approx_with_finite_emeasure:\n  assumes W_meas: \"W \\<in> sets M\"\n      and W_inf: \"emeasure M W > C\"\n  obtains Z where \"Z \\<in> sets M\" \"Z \\<subseteq> W\" \"emeasure M Z < \\<infinity>\" \"emeasure M Z > C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n         emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"emeasure M W = \\<infinity>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  emeasure M W = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain r where r: \"C = ennreal r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r. C = ennreal r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using W_inf"], ["proof (prove)\nusing this:\n  C < emeasure M W\n\ngoal (1 subgoal):\n 1. (\\<And>r. C = ennreal r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases C, auto)"], ["proof (state)\nthis:\n  C = ennreal r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "obtain Z where \"Z \\<in> sets M\" \"Z \\<subseteq> W\" \"emeasure M Z < \\<infinity>\" \"emeasure M Z > C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n         emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n         emeasure M Z < \\<infinity>; ennreal r < emeasure M Z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using approx_PInf_emeasure_with_finite[OF W_meas True, of r]"], ["proof (prove)\nusing this:\n  (\\<And>Z.\n      \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W; emeasure M Z < \\<infinity>;\n       ennreal r < emeasure M Z\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n         emeasure M Z < \\<infinity>; ennreal r < emeasure M Z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Z \\<in> sets M\n  Z \\<subseteq> W\n  emeasure M Z < \\<infinity>\n  C < emeasure M Z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  Z \\<in> sets M\n  Z \\<subseteq> W\n  emeasure M Z < \\<infinity>\n  C < emeasure M Z", "show ?thesis"], ["proof (prove)\nusing this:\n  Z \\<in> sets M\n  Z \\<subseteq> W\n  emeasure M Z < \\<infinity>\n  C < emeasure M Z\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  Z \\<in> sets M\n  Z \\<subseteq> W\n  emeasure M Z < \\<infinity>\n  C < emeasure M Z\n  \\<lbrakk>?Z \\<in> sets M; ?Z \\<subseteq> W; emeasure M ?Z < \\<infinity>;\n   C < emeasure M ?Z\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  emeasure M W \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  emeasure M W \\<noteq> \\<infinity>", "have \"W \\<in> sets M\" \"W \\<subseteq> W\" \"emeasure M W < \\<infinity>\" \"emeasure M W > C\""], ["proof (prove)\nusing this:\n  emeasure M W \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (W \\<in> sets M &&& W \\<subseteq> W) &&&\n    emeasure M W < \\<infinity> &&& C < emeasure M W", "using assms"], ["proof (prove)\nusing this:\n  emeasure M W \\<noteq> \\<infinity>\n  W \\<in> sets M\n  C < emeasure M W\n\ngoal (1 subgoal):\n 1. (W \\<in> sets M &&& W \\<subseteq> W) &&&\n    emeasure M W < \\<infinity> &&& C < emeasure M W", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>emeasure M W \\<noteq> \\<top>; W \\<in> sets M;\n     C < emeasure M W\\<rbrakk>\n    \\<Longrightarrow> emeasure M W < \\<top>", "using top.not_eq_extremum"], ["proof (prove)\nusing this:\n  (?a \\<noteq> \\<top>) = (?a < \\<top>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>emeasure M W \\<noteq> \\<top>; W \\<in> sets M;\n     C < emeasure M W\\<rbrakk>\n    \\<Longrightarrow> emeasure M W < \\<top>", "by blast"], ["proof (state)\nthis:\n  W \\<in> sets M\n  W \\<subseteq> W\n  emeasure M W < \\<infinity>\n  C < emeasure M W\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Z.\n                \\<lbrakk>Z \\<in> sets M; Z \\<subseteq> W;\n                 emeasure M Z < \\<infinity>; C < emeasure M Z\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure M W \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  W \\<in> sets M\n  W \\<subseteq> W\n  emeasure M W < \\<infinity>\n  C < emeasure M W", "show ?thesis"], ["proof (prove)\nusing this:\n  W \\<in> sets M\n  W \\<subseteq> W\n  emeasure M W < \\<infinity>\n  C < emeasure M W\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  W \\<in> sets M\n  W \\<subseteq> W\n  emeasure M W < \\<infinity>\n  C < emeasure M W\n  \\<lbrakk>?Z \\<in> sets M; ?Z \\<subseteq> W; emeasure M ?Z < \\<infinity>;\n   C < emeasure M ?Z\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Nonnegative-Lebesgue-Integration.thy\\<close>"], ["", "text \\<open>The next lemma is a variant of \\verb+nn_integral_density+,\nwith the density on the right instead of the left, as seems more common.\\<close>"], ["", "lemma nn_integral_densityR:\n  assumes [measurable]: \"f \\<in> borel_measurable F\" \"g \\<in> borel_measurable F\"\n  shows \"(\\<integral>\\<^sup>+ x. f x * g x \\<partial>F) = (\\<integral>\\<^sup>+ x. f x \\<partial>(density F g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "have \"(\\<integral>\\<^sup>+ x. f x * g x \\<partial>F) = (\\<integral>\\<^sup>+ x. g x * f x \\<partial>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    \\<integral>\\<^sup>+ x. g x * f x \\<partial>F", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n  \\<integral>\\<^sup>+ x. g x * f x \\<partial>F\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n  \\<integral>\\<^sup>+ x. g x * f x \\<partial>F\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "have \"... = (\\<integral>\\<^sup>+ x. f x \\<partial>(density F g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. g x * f x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "by (rule nn_integral_density[symmetric], simp_all add: assms)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. g x * f x \\<partial>F =\n  integral\\<^sup>N (density F g) f\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n  integral\\<^sup>N (density F g) f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n  integral\\<^sup>N (density F g) f\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n    integral\\<^sup>N (density F g) f", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. f x * g x \\<partial>F =\n  integral\\<^sup>N (density F g) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_AE_zero_int_ennreal_E:\n  fixes f::\"'a \\<Rightarrow> ennreal\"\n  assumes \"(\\<integral>\\<^sup>+x. f x \\<partial>M) > 0\"\n      and [measurable]: \"f \\<in> borel_measurable M\"\n  shows \"\\<exists>A\\<in>sets M. \\<exists>e::real>0. emeasure M A > 0 \\<and> (\\<forall>x \\<in> A. f x \\<ge> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A\\<in>sets M.\n       \\<exists>e>0.\n          0 < emeasure M A \\<and> (\\<forall>x\\<in>A. ennreal e \\<le> f x)", "proof (rule not_AE_zero_ennreal_E, auto simp add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. AE x in M. f x = 0 \\<Longrightarrow> False", "assume *: \"AE x in M. f x = 0\""], ["proof (state)\nthis:\n  AE x in M. f x = 0\n\ngoal (1 subgoal):\n 1. AE x in M. f x = 0 \\<Longrightarrow> False", "have \"(\\<integral>\\<^sup>+x. f x \\<partial>M) = (\\<integral>\\<^sup>+x. 0 \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N M f = \\<integral>\\<^sup>+ x. 0 \\<partial>M", "by (rule nn_integral_cong_AE, simp add: *)"], ["proof (state)\nthis:\n  integral\\<^sup>N M f = \\<integral>\\<^sup>+ x. 0 \\<partial>M\n\ngoal (1 subgoal):\n 1. AE x in M. f x = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  integral\\<^sup>N M f = \\<integral>\\<^sup>+ x. 0 \\<partial>M", "have \"(\\<integral>\\<^sup>+x. f x \\<partial>M) = 0\""], ["proof (prove)\nusing this:\n  integral\\<^sup>N M f = \\<integral>\\<^sup>+ x. 0 \\<partial>M\n\ngoal (1 subgoal):\n 1. integral\\<^sup>N M f = 0", "by simp"], ["proof (state)\nthis:\n  integral\\<^sup>N M f = 0\n\ngoal (1 subgoal):\n 1. AE x in M. f x = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  integral\\<^sup>N M f = 0", "show False"], ["proof (prove)\nusing this:\n  integral\\<^sup>N M f = 0\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  integral\\<^sup>N M f = 0\n  0 < integral\\<^sup>N M f\n  f \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in finite_measure) nn_integral_bounded_eq_bound_then_AE:\n  assumes \"AE x in M. f x \\<le> ennreal c\" \"(\\<integral>\\<^sup>+x. f x \\<partial>M) = c * emeasure M (space M)\"\n      and [measurable]: \"f \\<in> borel_measurable M\"\n  shows \"AE x in M. f x = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. f x = ennreal c", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> AE x in M. f x = ennreal c\n 2. \\<not> ?P \\<Longrightarrow> AE x in M. f x = ennreal c", "assume \"emeasure M (space M) = 0\""], ["proof (state)\nthis:\n  emeasure M (space M) = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> AE x in M. f x = ennreal c\n 2. \\<not> ?P \\<Longrightarrow> AE x in M. f x = ennreal c", "then"], ["proof (chain)\npicking this:\n  emeasure M (space M) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure M (space M) = 0\n\ngoal (1 subgoal):\n 1. AE x in M. f x = ennreal c", "by (rule emeasure_0_AE)"], ["proof (state)\nthis:\n  AE x in M. f x = ennreal c\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "assume \"emeasure M (space M) \\<noteq> 0\""], ["proof (state)\nthis:\n  emeasure M (space M) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "have fin: \"AE x in M. f x \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. f x \\<noteq> \\<top>", "using assms"], ["proof (prove)\nusing this:\n  AE x in M. f x \\<le> ennreal c\n  integral\\<^sup>N M f = ennreal c * emeasure M (space M)\n  f \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. AE x in M. f x \\<noteq> \\<top>", "by (auto simp: top_unique)"], ["proof (state)\nthis:\n  AE x in M. f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "define g where \"g = (\\<lambda>x. c - f x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. ennreal c - f x)\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "have [measurable]: \"g \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> borel_measurable M", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ennreal c - f x) \\<in> borel_measurable M", "by auto"], ["proof (state)\nthis:\n  g \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "have \"(\\<integral>\\<^sup>+x. g x \\<partial>M) = (\\<integral>\\<^sup>+x. c \\<partial>M) - (\\<integral>\\<^sup>+x. f x \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N M g =\n    \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal c - f x \\<partial>M =\n    \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f", "by (rule nn_integral_diff, auto simp add: assms ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  integral\\<^sup>N M g =\n  \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "also"], ["proof (state)\nthis:\n  integral\\<^sup>N M g =\n  \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f = 0", "using assms(2)"], ["proof (prove)\nusing this:\n  integral\\<^sup>N M f = ennreal c * emeasure M (space M)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f = 0", "by (auto simp: ennreal_mult_eq_top_iff)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal c \\<partial>M - integral\\<^sup>N M f = 0\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "finally"], ["proof (chain)\npicking this:\n  integral\\<^sup>N M g = 0", "have \"AE x in M. g x = 0\""], ["proof (prove)\nusing this:\n  integral\\<^sup>N M g = 0\n\ngoal (1 subgoal):\n 1. AE x in M. g x = 0", "by (subst nn_integral_0_iff_AE[symmetric]) auto"], ["proof (state)\nthis:\n  AE x in M. g x = 0\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "then"], ["proof (chain)\npicking this:\n  AE x in M. g x = 0", "have \"AE x in M. c \\<le> f x\""], ["proof (prove)\nusing this:\n  AE x in M. g x = 0\n\ngoal (1 subgoal):\n 1. AE x in M. ennreal c \\<le> f x", "unfolding g_def"], ["proof (prove)\nusing this:\n  AE x in M. ennreal c - f x = 0\n\ngoal (1 subgoal):\n 1. AE x in M. ennreal c \\<le> f x", "using fin"], ["proof (prove)\nusing this:\n  AE x in M. ennreal c - f x = 0\n  AE x in M. f x \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. AE x in M. ennreal c \\<le> f x", "by (auto simp: ennreal_minus_eq_0)"], ["proof (state)\nthis:\n  AE x in M. ennreal c \\<le> f x\n\ngoal (1 subgoal):\n 1. emeasure M (space M) \\<noteq> 0 \\<Longrightarrow>\n    AE x in M. f x = ennreal c", "then"], ["proof (chain)\npicking this:\n  AE x in M. ennreal c \\<le> f x", "show ?thesis"], ["proof (prove)\nusing this:\n  AE x in M. ennreal c \\<le> f x\n\ngoal (1 subgoal):\n 1. AE x in M. f x = ennreal c", "using assms(1)"], ["proof (prove)\nusing this:\n  AE x in M. ennreal c \\<le> f x\n  AE x in M. f x \\<le> ennreal c\n\ngoal (1 subgoal):\n 1. AE x in M. f x = ennreal c", "by auto"], ["proof (state)\nthis:\n  AE x in M. f x = ennreal c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma null_sets_density:\n  assumes [measurable]: \"h \\<in> borel_measurable M\"\n      and \"AE x in M. h x \\<noteq> 0\"\n  shows \"null_sets (density M h) = null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null_sets (density M h) = null_sets M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. null_sets (density M h) = null_sets M", "have *: \"A \\<in> sets M \\<and> (AE x\\<in>A in M. h x = 0) \\<longleftrightarrow> A \\<in> null_sets M\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<in> sets M \\<and> (AE x\\<in>A in M. h x = 0)) =\n    (A \\<in> null_sets M)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> sets M; AE x\\<in>A in M. h x = 0\\<rbrakk>\n    \\<Longrightarrow> A \\<in> null_sets M\n 2. A \\<in> null_sets M \\<Longrightarrow> AE x\\<in>A in M. h x = 0", "assume \"A \\<in> sets M\" \"AE x\\<in>A in M. h x = 0\""], ["proof (state)\nthis:\n  A \\<in> sets M\n  AE x\\<in>A in M. h x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in> sets M; AE x\\<in>A in M. h x = 0\\<rbrakk>\n    \\<Longrightarrow> A \\<in> null_sets M\n 2. A \\<in> null_sets M \\<Longrightarrow> AE x\\<in>A in M. h x = 0", "then"], ["proof (chain)\npicking this:\n  A \\<in> sets M\n  AE x\\<in>A in M. h x = 0", "show \"A \\<in> null_sets M\""], ["proof (prove)\nusing this:\n  A \\<in> sets M\n  AE x\\<in>A in M. h x = 0\n\ngoal (1 subgoal):\n 1. A \\<in> null_sets M", "unfolding AE_iff_null_sets[OF \\<open>A \\<in> sets M\\<close>]"], ["proof (prove)\nusing this:\n  A \\<in> sets M\n  AE x\\<in>A in M. h x = 0\n\ngoal (1 subgoal):\n 1. AE x in M. x \\<notin> A", "using assms(2)"], ["proof (prove)\nusing this:\n  A \\<in> sets M\n  AE x\\<in>A in M. h x = 0\n  AE x in M. h x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. AE x in M. x \\<notin> A", "by auto"], ["proof (state)\nthis:\n  A \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. A \\<in> null_sets M \\<Longrightarrow> AE x\\<in>A in M. h x = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<in> null_sets M \\<Longrightarrow> AE x\\<in>A in M. h x = 0", "assume \"A \\<in> null_sets M\""], ["proof (state)\nthis:\n  A \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. A \\<in> null_sets M \\<Longrightarrow> AE x\\<in>A in M. h x = 0", "then"], ["proof (chain)\npicking this:\n  A \\<in> null_sets M", "show \"AE x\\<in>A in M. h x = 0\""], ["proof (prove)\nusing this:\n  A \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. AE x\\<in>A in M. h x = 0", "by (metis (mono_tags, lifting) AE_not_in eventually_mono)"], ["proof (state)\nthis:\n  AE x\\<in>A in M. h x = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A \\<in> sets M \\<and> (AE x\\<in>?A in M. h x = 0)) =\n  (?A \\<in> null_sets M)\n\ngoal (1 subgoal):\n 1. null_sets (density M h) = null_sets M", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. null_sets (density M h) = null_sets M", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> null_sets (density M h)) = (x \\<in> null_sets M)", "unfolding null_sets_density_iff[OF \\<open>h \\<in> borel_measurable M\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> sets M \\<and> (AE x\\<in>x in M. h x = 0)) =\n       (x \\<in> null_sets M)", "using *"], ["proof (prove)\nusing this:\n  (?A \\<in> sets M \\<and> (AE x\\<in>?A in M. h x = 0)) =\n  (?A \\<in> null_sets M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> sets M \\<and> (AE x\\<in>x in M. h x = 0)) =\n       (x \\<in> null_sets M)", "by auto"], ["proof (state)\nthis:\n  null_sets (density M h) = null_sets M\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next proposition asserts that, if a function $h$ is integrable, then its integral on\nany set with small enough measure is small. The good conceptual proof is by considering the\ndistribution of the function $h$ on $\\mathbb{R}$ and looking at its tails. However, there is a\nless conceptual but more direct proof, based on dominated convergence and a proof by contradiction.\nThis is the proof we give below.\\<close>"], ["", "proposition integrable_small_integral_on_small_sets:\n  fixes h::\"'a \\<Rightarrow> real\"\n  assumes [measurable]: \"integrable M h\"\n      and \"delta > 0\"\n  shows \"\\<exists>epsilon>(0::real). \\<forall>U \\<in> sets M. emeasure M U < epsilon \\<longrightarrow> abs (\\<integral>x\\<in>U. h x \\<partial>M) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          \\<bar>set_lebesgue_integral M U h\\<bar> < delta", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "assume H: \"\\<not> (\\<exists>epsilon>0. \\<forall>U\\<in>sets M. emeasure M U < ennreal epsilon \\<longrightarrow> abs(set_lebesgue_integral M U h) < delta)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>epsilon>0.\n             \\<forall>U\\<in>sets M.\n                emeasure M U < ennreal epsilon \\<longrightarrow>\n                \\<bar>set_lebesgue_integral M U h\\<bar> < delta)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have \"\\<exists>f. \\<forall>epsilon\\<in>{0<..}. f epsilon \\<in>sets M \\<and> emeasure M (f epsilon) < ennreal epsilon\n                            \\<and> \\<not>(abs(set_lebesgue_integral M (f epsilon) h) < delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>epsilon\\<in>{0<..}.\n          f epsilon \\<in> sets M \\<and>\n          emeasure M (f epsilon) < ennreal epsilon \\<and>\n          \\<not> \\<bar>set_lebesgue_integral M (f epsilon) h\\<bar> < delta", "apply (rule bchoice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>epsilon\\<in>{0<..}.\n       \\<exists>y.\n          y \\<in> sets M \\<and>\n          emeasure M y < ennreal epsilon \\<and>\n          \\<not> \\<bar>set_lebesgue_integral M y h\\<bar> < delta", "using H"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>epsilon>0.\n             \\<forall>U\\<in>sets M.\n                emeasure M U < ennreal epsilon \\<longrightarrow>\n                \\<bar>set_lebesgue_integral M U h\\<bar> < delta)\n\ngoal (1 subgoal):\n 1. \\<forall>epsilon\\<in>{0<..}.\n       \\<exists>y.\n          y \\<in> sets M \\<and>\n          emeasure M y < ennreal epsilon \\<and>\n          \\<not> \\<bar>set_lebesgue_integral M y h\\<bar> < delta", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<forall>epsilon\\<in>{0<..}.\n        f epsilon \\<in> sets M \\<and>\n        emeasure M (f epsilon) < ennreal epsilon \\<and>\n        \\<not> \\<bar>set_lebesgue_integral M (f epsilon) h\\<bar> < delta\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>epsilon\\<in>{0<..}.\n        f epsilon \\<in> sets M \\<and>\n        emeasure M (f epsilon) < ennreal epsilon \\<and>\n        \\<not> \\<bar>set_lebesgue_integral M (f epsilon) h\\<bar> < delta", "obtain f::\"real \\<Rightarrow> 'a set\" where f:\n              \"\\<And>epsilon. epsilon > 0 \\<Longrightarrow> f epsilon \\<in>sets M\"\n              \"\\<And>epsilon. epsilon > 0 \\<Longrightarrow> emeasure M (f epsilon) < ennreal epsilon\"\n              \"\\<And>epsilon. epsilon > 0 \\<Longrightarrow> \\<not>(abs(set_lebesgue_integral M (f epsilon) h) < delta)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>epsilon\\<in>{0<..}.\n        f epsilon \\<in> sets M \\<and>\n        emeasure M (f epsilon) < ennreal epsilon \\<and>\n        \\<not> \\<bar>set_lebesgue_integral M (f epsilon) h\\<bar> < delta\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>\\<And>epsilon.\n                    0 < epsilon \\<Longrightarrow> f epsilon \\<in> sets M;\n         \\<And>epsilon.\n            0 < epsilon \\<Longrightarrow>\n            emeasure M (f epsilon) < ennreal epsilon;\n         \\<And>epsilon.\n            0 < epsilon \\<Longrightarrow>\n            \\<not> \\<bar>set_lebesgue_integral M (f epsilon) h\\<bar>\n                   < delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < ?epsilon \\<Longrightarrow> f ?epsilon \\<in> sets M\n  0 < ?epsilon \\<Longrightarrow> emeasure M (f ?epsilon) < ennreal ?epsilon\n  0 < ?epsilon \\<Longrightarrow>\n  \\<not> \\<bar>set_lebesgue_integral M (f ?epsilon) h\\<bar> < delta\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "define A where \"A = (\\<lambda>n::nat. f ((1/2)^n))\""], ["proof (state)\nthis:\n  A = (\\<lambda>n. f ((1 / 2) ^ n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have [measurable]: \"A n \\<in> sets M\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. A n \\<in> sets M", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ((1 / 2) ^ n) \\<in> sets M", "using f(1)"], ["proof (prove)\nusing this:\n  0 < ?epsilon \\<Longrightarrow> f ?epsilon \\<in> sets M\n\ngoal (1 subgoal):\n 1. f ((1 / 2) ^ n) \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  A ?n \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have *: \"emeasure M (A n) < ennreal ((1/2)^n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (A n) < ennreal ((1 / 2) ^ n)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M (f ((1 / 2) ^ n)) < ennreal ((1 / 2) ^ n)", "using f(2)"], ["proof (prove)\nusing this:\n  0 < ?epsilon \\<Longrightarrow> emeasure M (f ?epsilon) < ennreal ?epsilon\n\ngoal (1 subgoal):\n 1. emeasure M (f ((1 / 2) ^ n)) < ennreal ((1 / 2) ^ n)", "by auto"], ["proof (state)\nthis:\n  emeasure M (A ?n) < ennreal ((1 / 2) ^ ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have Large: \"\\<not>(abs(set_lebesgue_integral M (A n) h) < delta)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<bar>set_lebesgue_integral M (A n) h\\<bar> < delta", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<bar>set_lebesgue_integral M (f ((1 / 2) ^ n)) h\\<bar> < delta", "using f(3)"], ["proof (prove)\nusing this:\n  0 < ?epsilon \\<Longrightarrow>\n  \\<not> \\<bar>set_lebesgue_integral M (f ?epsilon) h\\<bar> < delta\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>set_lebesgue_integral M (f ((1 / 2) ^ n)) h\\<bar> < delta", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<bar>set_lebesgue_integral M (A ?n) h\\<bar> < delta\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have S: \"summable (\\<lambda>n. Sigma_Algebra.measure M (A n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. Sigma_Algebra.measure M (A n))", "apply (rule summable_comparison_test'[of \"\\<lambda>n. (1/2)^n\" 0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. summable ((^) (1 / 2))\n 2. \\<And>n.\n       0 \\<le> n \\<Longrightarrow>\n       norm (Sigma_Algebra.measure M (A n)) \\<le> (1 / 2) ^ n", "apply (rule summable_geometric, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. Sigma_Algebra.measure M (A n) \\<le> (1 / 2) ^ n", "apply (subst ennreal_le_iff[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ennreal (Sigma_Algebra.measure M (A n)) \\<le> ennreal ((1 / 2) ^ n)", "using less_imp_le[OF *]"], ["proof (prove)\nusing this:\n  emeasure M (A ?n1) \\<le> ennreal ((1 / 2) ^ ?n1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ennreal (Sigma_Algebra.measure M (A n)) \\<le> ennreal ((1 / 2) ^ n)", "by (metis * emeasure_eq_ennreal_measure top.extremum_strict)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. Sigma_Algebra.measure M (A n))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have \"AE x in M. eventually (\\<lambda>n. x \\<in> space M - A n) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. \\<forall>\\<^sub>F n in sequentially. x \\<in> space M - A n", "apply (rule borel_cantelli_AE1, auto simp add: S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. emeasure M (A n) < \\<top>", "by (metis * top.extremum_strict top.not_eq_extremum)"], ["proof (state)\nthis:\n  AE x in M. \\<forall>\\<^sub>F n in sequentially. x \\<in> space M - A n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  AE x in M. \\<forall>\\<^sub>F n in sequentially. x \\<in> space M - A n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have \"(\\<lambda>n. indicator (A n) x * h x) \\<longlonglongrightarrow> 0\"\n    if \"eventually (\\<lambda>n. x \\<in> space M - A n) sequentially\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0", "have \"eventually (\\<lambda>n. indicator (A n) x * h x = 0) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. indicat_real (A n) x * h x = 0", "apply (rule eventually_mono[OF that])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x \\<in> space M - A xa \\<Longrightarrow>\n       indicat_real (A xa) x * h x = 0", "unfolding indicator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x \\<in> space M - A xa \\<Longrightarrow>\n       (if x \\<in> A xa then 1 else 0) * h x = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. indicat_real (A n) x * h x = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. indicat_real (A n) x * h x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. indicat_real (A n) x * h x = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. indicat_real (A n) x * h x = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0", "using lim_explicit"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. indicat_real (A n) x * h x = 0\n  ?f \\<longlonglongrightarrow> ?f0.0 =\n  (\\<forall>S.\n      open S \\<longrightarrow>\n      ?f0.0 \\<in> S \\<longrightarrow>\n      (\\<exists>N. \\<forall>n\\<ge>N. ?f n \\<in> S))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0", "by force"], ["proof (state)\nthis:\n  (\\<lambda>n. indicat_real (A n) x * h x) \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ?x \\<in> space M - A n \\<Longrightarrow>\n  (\\<lambda>n. indicat_real (A n) ?x * h ?x) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  AE x in M. \\<forall>\\<^sub>F n in sequentially. x \\<in> space M - A n\n  \\<forall>\\<^sub>F n in sequentially.\n     ?x \\<in> space M - A n \\<Longrightarrow>\n  (\\<lambda>n. indicat_real (A n) ?x * h ?x) \\<longlonglongrightarrow> 0", "have A: \"AE x in M. ((\\<lambda>n. indicator (A n) x * h x) \\<longlonglongrightarrow> 0)\""], ["proof (prove)\nusing this:\n  AE x in M. \\<forall>\\<^sub>F n in sequentially. x \\<in> space M - A n\n  \\<forall>\\<^sub>F n in sequentially.\n     ?x \\<in> space M - A n \\<Longrightarrow>\n  (\\<lambda>n. indicat_real (A n) ?x * h ?x) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. AE x in M. (\\<lambda>n. indicat_real (A n) x * h x)\n               \\<longlonglongrightarrow> 0", "by auto"], ["proof (state)\nthis:\n  AE x in M. (\\<lambda>n. indicat_real (A n) x * h x)\n             \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have I: \"integrable M (\\<lambda>x. abs(h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. \\<bar>h x\\<bar>)", "using \\<open>integrable M h\\<close>"], ["proof (prove)\nusing this:\n  integrable M h\n\ngoal (1 subgoal):\n 1. integrable M (\\<lambda>x. \\<bar>h x\\<bar>)", "by auto"], ["proof (state)\nthis:\n  integrable M (\\<lambda>x. \\<bar>h x\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have L: \"(\\<lambda>n. abs (\\<integral>x. indicator (A n) x * h x \\<partial>M)) \\<longlonglongrightarrow> abs (\\<integral>x. 0 \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar>)\n    \\<longlonglongrightarrow> \\<bar>LINT x|M. 0\\<bar>", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. LINT xa|M. indicat_real (A x) xa * h xa)\n    \\<longlonglongrightarrow> LINT x|M. 0", "apply (rule integral_dominated_convergence[OF _ _ I A])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. 0) \\<in> borel_measurable M\n 2. \\<And>x.\n       (\\<lambda>xa. indicat_real (A x) xa * h xa) \\<in> borel_measurable M\n 3. \\<And>x.\n       AE xa in M. norm (indicat_real (A x) xa * h xa)\n                   \\<le> \\<bar>h xa\\<bar>", "unfolding indicator_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. 0) \\<in> borel_measurable M\n 2. \\<And>x.\n       (\\<lambda>xa. (if xa \\<in> A x then 1 else 0) * h xa)\n       \\<in> borel_measurable M\n 3. \\<And>x.\n       AE xa in M. norm ((if xa \\<in> A x then 1 else 0) * h xa)\n                   \\<le> \\<bar>h xa\\<bar>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>LINT x|M. 0\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "have \"eventually (\\<lambda>n. abs (\\<integral>x. indicator (A n) x * h x \\<partial>M) < delta) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar> < delta", "apply (rule order_tendstoD[OF L])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>LINT x|M. 0\\<bar> < delta", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. \\<bar>LINT x|M. 0\\<bar> < delta", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar> < delta\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>epsilon>0.\n               \\<forall>U\\<in>sets M.\n                  emeasure M U < ennreal epsilon \\<longrightarrow>\n                  \\<bar>set_lebesgue_integral M U h\\<bar>\n                  < delta) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar> < delta", "show False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar> < delta\n\ngoal (1 subgoal):\n 1. False", "using Large"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     \\<bar>LINT x|M. indicat_real (A n) x * h x\\<bar> < delta\n  \\<not> \\<bar>set_lebesgue_integral M (A ?n) h\\<bar> < delta\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We also give the version for nonnegative ennreal valued functions. It follows from the\nprevious one.\\<close>"], ["", "proposition small_nn_integral_on_small_sets:\n  fixes h::\"'a \\<Rightarrow> ennreal\"\n  assumes [measurable]: \"h \\<in> borel_measurable M\"\n      and \"delta > (0::real)\" \"(\\<integral>\\<^sup>+x. h x \\<partial>M) \\<noteq> \\<infinity>\"\n  shows \"\\<exists>epsilon>(0::real). \\<forall>U \\<in> sets M. emeasure M U < epsilon \\<longrightarrow> (\\<integral>\\<^sup>+x\\<in>U. h x \\<partial>M) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "define f where \"f = (\\<lambda>x. enn2real(h x))\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. enn2real (h x))\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "have \"AE x in M. h x \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. h x \\<noteq> \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  h \\<in> borel_measurable M\n  0 < delta\n  integral\\<^sup>N M h \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in M. h x \\<noteq> \\<infinity>", "by (metis nn_integral_PInf_AE)"], ["proof (state)\nthis:\n  AE x in M. h x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "then"], ["proof (chain)\npicking this:\n  AE x in M. h x \\<noteq> \\<infinity>", "have *: \"AE x in M. ennreal (f x) = h x\""], ["proof (prove)\nusing this:\n  AE x in M. h x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in M. ennreal (f x) = h x", "unfolding f_def"], ["proof (prove)\nusing this:\n  AE x in M. h x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. AE x in M. ennreal (enn2real (h x)) = h x", "using ennreal_enn2real_if"], ["proof (prove)\nusing this:\n  AE x in M. h x \\<noteq> \\<infinity>\n  ennreal (enn2real ?r) = (if ?r = \\<top> then 0 else ?r)\n\ngoal (1 subgoal):\n 1. AE x in M. ennreal (enn2real (h x)) = h x", "by auto"], ["proof (state)\nthis:\n  AE x in M. ennreal (f x) = h x\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "have **: \"(\\<integral>\\<^sup>+x. ennreal (f x) \\<partial>M) \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M \\<noteq> \\<infinity>", "using nn_integral_cong_AE[OF *] assms"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M = integral\\<^sup>N M h\n  h \\<in> borel_measurable M\n  0 < delta\n  integral\\<^sup>N M h \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "have [measurable]: \"f \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable M", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. enn2real (h x)) \\<in> borel_measurable M", "by auto"], ["proof (state)\nthis:\n  f \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "have \"integrable M f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable M f", "apply (rule integrableI_nonneg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f \\<in> borel_measurable M\n 2. AE x in M. 0 \\<le> f x\n 3. \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M < \\<infinity>", "using assms * f_def **"], ["proof (prove)\nusing this:\n  h \\<in> borel_measurable M\n  0 < delta\n  integral\\<^sup>N M h \\<noteq> \\<infinity>\n  AE x in M. ennreal (f x) = h x\n  f = (\\<lambda>x. enn2real (h x))\n  \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M \\<noteq> \\<infinity>\n\ngoal (3 subgoals):\n 1. f \\<in> borel_measurable M\n 2. AE x in M. 0 \\<le> f x\n 3. \\<integral>\\<^sup>+ x. ennreal (f x) \\<partial>M < \\<infinity>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < delta; integral\\<^sup>N M h \\<noteq> \\<top>;\n     AE x in M. ennreal (enn2real (h x)) = h x;\n     f = (\\<lambda>x. enn2real (h x));\n     \\<integral>\\<^sup>+ x. ennreal (enn2real (h x)) \\<partial>M \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. ennreal (enn2real (h x))\n   \\<partial>M\n                      < \\<top>", "using top.not_eq_extremum"], ["proof (prove)\nusing this:\n  (?a \\<noteq> \\<top>) = (?a < \\<top>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < delta; integral\\<^sup>N M h \\<noteq> \\<top>;\n     AE x in M. ennreal (enn2real (h x)) = h x;\n     f = (\\<lambda>x. enn2real (h x));\n     \\<integral>\\<^sup>+ x. ennreal (enn2real (h x)) \\<partial>M \\<noteq>\n     \\<top>\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. ennreal (enn2real (h x))\n   \\<partial>M\n                      < \\<top>", "by blast"], ["proof (state)\nthis:\n  integrable M f\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "obtain epsilon::real where H: \"epsilon > 0\" \"\\<And>U. U \\<in> sets M \\<Longrightarrow> emeasure M U < epsilon \\<Longrightarrow> abs(\\<integral>x\\<in>U. f x \\<partial>M) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>epsilon.\n        \\<lbrakk>0 < epsilon;\n         \\<And>U.\n            \\<lbrakk>U \\<in> sets M; emeasure M U < ennreal epsilon\\<rbrakk>\n            \\<Longrightarrow> \\<bar>set_lebesgue_integral M U f\\<bar>\n                              < delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using integrable_small_integral_on_small_sets[OF \\<open>integrable M f\\<close> \\<open>delta > 0\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>epsilon>0.\n     \\<forall>U\\<in>sets M.\n        emeasure M U < ennreal epsilon \\<longrightarrow>\n        \\<bar>set_lebesgue_integral M U f\\<bar> < delta\n\ngoal (1 subgoal):\n 1. (\\<And>epsilon.\n        \\<lbrakk>0 < epsilon;\n         \\<And>U.\n            \\<lbrakk>U \\<in> sets M; emeasure M U < ennreal epsilon\\<rbrakk>\n            \\<Longrightarrow> \\<bar>set_lebesgue_integral M U f\\<bar>\n                              < delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < epsilon\n  \\<lbrakk>?U \\<in> sets M; emeasure M ?U < ennreal epsilon\\<rbrakk>\n  \\<Longrightarrow> \\<bar>set_lebesgue_integral M ?U f\\<bar> < delta\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "have \"(\\<integral>\\<^sup>+x\\<in>U. h x \\<partial>M) < delta\" if [measurable]: \"U \\<in> sets M\" \"emeasure M U < epsilon\" for U"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "have \"(\\<integral>\\<^sup>+x. indicator U x * h x \\<partial>M) = (\\<integral>\\<^sup>+x. ennreal(indicator U x * f x) \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. indicator U x * h x \\<partial>M =\n    \\<integral>\\<^sup>+ x. ennreal (indicat_real U x * f x) \\<partial>M", "apply (rule nn_integral_cong_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in M. indicator U x * h x = ennreal (indicat_real U x * f x)", "using *"], ["proof (prove)\nusing this:\n  AE x in M. ennreal (f x) = h x\n\ngoal (1 subgoal):\n 1. AE x in M. indicator U x * h x = ennreal (indicat_real U x * f x)", "unfolding indicator_def"], ["proof (prove)\nusing this:\n  AE x in M. ennreal (f x) = h x\n\ngoal (1 subgoal):\n 1. AE x in M. (if x \\<in> U then 1 else 0) * h x =\n               ennreal ((if x \\<in> U then 1 else 0) * f x)", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. indicator U x * h x \\<partial>M =\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real U x * f x) \\<partial>M\n\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. indicator U x * h x \\<partial>M =\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real U x * f x) \\<partial>M\n\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "have \"... = ennreal (\\<integral>x. indicator U x * f x \\<partial>M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real U x * f x) \\<partial>M =\n    ennreal (LINT x|M. indicat_real U x * f x)", "apply (rule nn_integral_eq_integral)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integrable M (\\<lambda>x. indicat_real U x * f x)\n 2. AE x in M. 0 \\<le> indicat_real U x * f x", "apply (rule Bochner_Integration.integrable_bound[OF \\<open>integrable M f\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. indicat_real U x * f x) \\<in> borel_measurable M\n 2. AE x in M. norm (indicat_real U x * f x) \\<le> norm (f x)\n 3. AE x in M. 0 \\<le> indicat_real U x * f x", "unfolding indicator_def f_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. (if x \\<in> U then 1 else 0) * enn2real (h x))\n    \\<in> borel_measurable M\n 2. AE x in M. norm ((if x \\<in> U then 1 else 0) * enn2real (h x))\n               \\<le> norm (enn2real (h x))\n 3. AE x in M. 0 \\<le> (if x \\<in> U then 1 else 0) * enn2real (h x)", "by auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real U x * f x) \\<partial>M =\n  ennreal (LINT x|M. indicat_real U x * f x)\n\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real U x * f x) \\<partial>M =\n  ennreal (LINT x|M. indicat_real U x * f x)\n\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "have \"... < ennreal delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (LINT x|M. indicat_real U x * f x) < ennreal delta", "apply (rule ennreal_lessI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < delta\n 2. LINT x|M. indicat_real U x * f x < delta", "using H(2)[OF that]"], ["proof (prove)\nusing this:\n  \\<bar>set_lebesgue_integral M U f\\<bar> < delta\n\ngoal (2 subgoals):\n 1. 0 < delta\n 2. LINT x|M. indicat_real U x * f x < delta", "by (auto simp: set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  ennreal (LINT x|M. indicat_real U x * f x) < ennreal delta\n\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. indicator U x * h x \\<partial>M < ennreal delta", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. indicator U x * h x \\<partial>M < ennreal delta\n\ngoal (1 subgoal):\n 1. set_nn_integral M U h < ennreal delta", "by (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  set_nn_integral M U h < ennreal delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?U \\<in> sets M; emeasure M ?U < ennreal epsilon\\<rbrakk>\n  \\<Longrightarrow> set_nn_integral M ?U h < ennreal delta\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?U \\<in> sets M; emeasure M ?U < ennreal epsilon\\<rbrakk>\n  \\<Longrightarrow> set_nn_integral M ?U h < ennreal delta", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<in> sets M; emeasure M ?U < ennreal epsilon\\<rbrakk>\n  \\<Longrightarrow> set_nn_integral M ?U h < ennreal delta\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "using \\<open>epsilon > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?U \\<in> sets M; emeasure M ?U < ennreal epsilon\\<rbrakk>\n  \\<Longrightarrow> set_nn_integral M ?U h < ennreal delta\n  0 < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>epsilon>0.\n       \\<forall>U\\<in>sets M.\n          emeasure M U < ennreal epsilon \\<longrightarrow>\n          set_nn_integral M U h < ennreal delta", "by auto"], ["proof (state)\nthis:\n  \\<exists>epsilon>0.\n     \\<forall>U\\<in>sets M.\n        emeasure M U < ennreal epsilon \\<longrightarrow>\n        set_nn_integral M U h < ennreal delta\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Probability-measure.thy\\<close>"], ["", "text \\<open>The next lemmas ensure that, if sets have a probability close to $1$, then their\nintersection also does.\\<close>"], ["", "lemma (in prob_space) sum_measure_le_measure_inter:\n  assumes \"A \\<in> sets M\" \"B \\<in> sets M\"\n  shows \"prob A + prob B \\<le> 1 + prob (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "have \"prob A + prob B = prob (A \\<union> B) + prob (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob A + prob B = prob (A \\<union> B) + prob (A \\<inter> B)", "by (simp add: assms fmeasurable_eq_sets measure_Un3)"], ["proof (state)\nthis:\n  prob A + prob B = prob (A \\<union> B) + prob (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "also"], ["proof (state)\nthis:\n  prob A + prob B = prob (A \\<union> B) + prob (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "have \"... \\<le> 1 + prob (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob (A \\<union> B) + prob (A \\<inter> B) \\<le> 1 + prob (A \\<inter> B)", "by auto"], ["proof (state)\nthis:\n  prob (A \\<union> B) + prob (A \\<inter> B) \\<le> 1 + prob (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "finally"], ["proof (chain)\npicking this:\n  prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  prob A + prob B \\<le> 1 + prob (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. prob A + prob B \\<le> 1 + prob (A \\<inter> B)", "by simp"], ["proof (state)\nthis:\n  prob A + prob B \\<le> 1 + prob (A \\<inter> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in prob_space) sum_measure_le_measure_inter3:\n  assumes [measurable]: \"A \\<in> sets M\" \"B \\<in> sets M\" \"C \\<in> sets M\"\n  shows \"prob A + prob B + prob C \\<le> 2 + prob (A \\<inter> B \\<inter> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob A + prob B + prob C \\<le> 2 + prob (A \\<inter> B \\<inter> C)", "using sum_measure_le_measure_inter[of B C] sum_measure_le_measure_inter[of A \"B \\<inter> C\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>B \\<in> events; C \\<in> events\\<rbrakk>\n  \\<Longrightarrow> prob B + prob C \\<le> 1 + prob (B \\<inter> C)\n  \\<lbrakk>A \\<in> events; B \\<inter> C \\<in> events\\<rbrakk>\n  \\<Longrightarrow> prob A + prob (B \\<inter> C)\n                    \\<le> 1 + prob (A \\<inter> (B \\<inter> C))\n\ngoal (1 subgoal):\n 1. prob A + prob B + prob C \\<le> 2 + prob (A \\<inter> B \\<inter> C)", "by (auto simp add: inf_assoc)"], ["", "lemma (in prob_space) sum_measure_le_measure_Inter:\n  assumes [measurable]: \"finite I\" \"I \\<noteq> {}\" \"\\<And>i. i \\<in> I \\<Longrightarrow> A i \\<in> sets M\"\n  shows \"(\\<Sum>i\\<in>I. prob (A i)) \\<le> real(card I) - 1 + prob (\\<Inter>i\\<in>I. A i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. prob (A i))\n    \\<le> real (card I) - 1 + prob (\\<Inter> (A ` I))", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  I \\<noteq> {}\n  ?i12 \\<in> I \\<Longrightarrow> A ?i12 \\<in> events\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I. prob (A i))\n    \\<le> real (card I) - 1 + prob (\\<Inter> (A ` I))", "proof (induct I rule: finite_ne_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "fix x F"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "assume H: \"finite F\" \"F \\<noteq> {}\" \"x \\<notin> F\"\n            \"((\\<And>i. i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow> (\\<Sum>i\\<in>F. prob (A i)) \\<le> real (card F) - 1 + prob (\\<Inter>(A ` F)))\"\n        and [measurable]: \"(\\<And>i. i \\<in> insert x F \\<Longrightarrow> A i \\<in> events)\""], ["proof (state)\nthis:\n  finite F\n  F \\<noteq> {}\n  x \\<notin> F\n  (\\<And>i. i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. prob (A i))\n  \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F))\n  ?i12 \\<in> insert x F \\<Longrightarrow> A ?i12 \\<in> events\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "have \"(\\<Inter>x\\<in>F. A x) \\<in> events\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (A ` F) \\<in> events", "using \\<open>finite F\\<close> \\<open>F \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  finite F\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Inter> (A ` F) \\<in> events", "by auto"], ["proof (state)\nthis:\n  \\<Inter> (A ` F) \\<in> events\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "have \"(\\<Sum>i\\<in>insert x F. prob (A i)) = (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert x F. prob (A i)) =\n    (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)", "using H(1) H(3)"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert x F. prob (A i)) =\n    (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert x F. prob (A i)) =\n  (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert x F. prob (A i)) =\n  (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "have \"... \\<le> real (card F)-1 + prob (\\<Inter>(A ` F)) + prob (A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\n    \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)", "using H(4)"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. prob (A i))\n  \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\n    \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\n  \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>F. prob (A i)) + prob (A x)\n  \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "have \"... \\<le> real (card F) + prob ((\\<Inter>(A ` F)) \\<inter> A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)\n    \\<le> real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x)", "using sum_measure_le_measure_inter[OF \\<open>(\\<Inter>x\\<in>F. A x) \\<in> events\\<close>, of \"A x\"]"], ["proof (prove)\nusing this:\n  A x \\<in> events \\<Longrightarrow>\n  prob (\\<Inter> (A ` F)) + prob (A x)\n  \\<le> 1 + prob (\\<Inter> (A ` F) \\<inter> A x)\n\ngoal (1 subgoal):\n 1. real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)\n    \\<le> real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x)", "by auto"], ["proof (state)\nthis:\n  real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)\n  \\<le> real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "also"], ["proof (state)\nthis:\n  real (card F) - 1 + prob (\\<Inter> (A ` F)) + prob (A x)\n  \\<le> real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "have \"... = real (card (insert x F)) - 1 + prob (\\<Inter>(A ` (insert x F)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x) =\n    real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))", "using H(1) H(2)"], ["proof (prove)\nusing this:\n  finite F\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x) =\n    real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))", "unfolding card_insert_disjoint[OF \\<open>finite F\\<close> \\<open>x \\<notin> F\\<close>]"], ["proof (prove)\nusing this:\n  finite F\n  F \\<noteq> {}\n\ngoal (1 subgoal):\n 1. real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x) =\n    real (Suc (card F)) - 1 + prob (\\<Inter> (A ` insert x F))", "by (simp add: inf_commute)"], ["proof (state)\nthis:\n  real (card F) + prob (\\<Inter> (A ` F) \\<inter> A x) =\n  real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; F \\<noteq> {}; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n        (\\<Sum>i\\<in>F. prob (A i))\n        \\<le> real (card F) - 1 + prob (\\<Inter> (A ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> A i \\<in> events\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>insert x F. prob (A i))\n                         \\<le> real (card (insert x F)) - 1 +\n                               prob (\\<Inter> (A ` insert x F))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>insert x F. prob (A i))\n  \\<le> real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))", "show \"(\\<Sum>i\\<in>insert x F. prob (A i)) \\<le> real (card (insert x F)) - 1 + prob (\\<Inter>(A ` (insert x F)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>insert x F. prob (A i))\n  \\<le> real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert x F. prob (A i))\n    \\<le> real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert x F. prob (A i))\n  \\<le> real (card (insert x F)) - 1 + prob (\\<Inter> (A ` insert x F))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>i.\n           i \\<in> {x} \\<Longrightarrow> A i \\<in> events) \\<Longrightarrow>\n       (\\<Sum>i\\<in>{x}. prob (A i))\n       \\<le> real (card {x}) - 1 + prob (\\<Inter> (A ` {x}))", "qed (auto)"], ["", "text \\<open>A random variable gives a small mass to small neighborhoods of\ninfinity.\\<close>"], ["", "lemma (in prob_space) random_variable_small_tails:\n  assumes \"alpha > 0\" and [measurable]: \"f \\<in> borel_measurable M\"\n  shows \"\\<exists>(C::real). prob {x \\<in> space M. abs(f x) \\<ge> C} < alpha \\<and> C \\<ge> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "have *: \"(\\<Inter>(n::nat). {x\\<in>space M. abs(f x) \\<ge> n}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>x. {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>}) = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space M;\n        \\<forall>xa. real xa \\<le> \\<bar>f x\\<bar>\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis real_arch_simple add.right_neutral add_mono_thms_linordered_field(4) not_less zero_less_one)"], ["proof (state)\nthis:\n  (\\<Inter>x. {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>}) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "have **: \"(\\<lambda>n. prob {x \\<in> space M. abs(f x) \\<ge> n}) \\<longlonglongrightarrow> prob (\\<Inter>(n::nat). {x \\<in> space M. abs(f x) \\<ge> n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n    \\<longlonglongrightarrow> prob\n                               (\\<Inter>x.\n                                   {xa \\<in> space M.\n                                    real x \\<le> \\<bar>f xa\\<bar>})", "by (rule finite_Lim_measure_decseq, auto simp add: decseq_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n  \\<longlonglongrightarrow> prob\n                             (\\<Inter>x.\n                                 {xa \\<in> space M.\n                                  real x \\<le> \\<bar>f xa\\<bar>})\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "have \"eventually (\\<lambda>n. prob {x \\<in> space M. abs(f x) \\<ge> n} < alpha) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha", "apply (rule order_tendstoD[OF _ \\<open>alpha > 0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n    \\<longlonglongrightarrow> 0", "using **"], ["proof (prove)\nusing this:\n  (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n  \\<longlonglongrightarrow> prob\n                             (\\<Inter>x.\n                                 {xa \\<in> space M.\n                                  real x \\<le> \\<bar>f xa\\<bar>})\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n    \\<longlonglongrightarrow> 0", "unfolding *"], ["proof (prove)\nusing this:\n  (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n  \\<longlonglongrightarrow> prob {}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. prob {xa \\<in> space M. real x \\<le> \\<bar>f xa\\<bar>})\n    \\<longlonglongrightarrow> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha", "obtain N::nat where N: \"\\<And>n::nat. n \\<ge> N \\<Longrightarrow> prob {x \\<in> space M. abs(f x) \\<ge> n} < alpha\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>}\n            < alpha) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>}\n            < alpha) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  N \\<le> ?n12 \\<Longrightarrow>\n  prob {x \\<in> space M. real ?n12 \\<le> \\<bar>f x\\<bar>} < alpha\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "have \"\\<exists>n::nat. n \\<ge> N \\<and> n \\<ge> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>N. K \\<le> real n", "by (meson le_cases of_nat_le_iff order.trans real_arch_simple)"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>N. K \\<le> real n\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "then"], ["proof (chain)\npicking this:\n  \\<exists>n\\<ge>N. K \\<le> real n", "obtain n::nat where n: \"n \\<ge> N\" \"n \\<ge> K\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<ge>N. K \\<le> real n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>N \\<le> n; K \\<le> real n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  N \\<le> n\n  K \\<le> real n\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n       K \\<le> C", "apply (rule exI[of _ \"of_nat n\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n    K \\<le> real n", "using N n"], ["proof (prove)\nusing this:\n  N \\<le> ?n12 \\<Longrightarrow>\n  prob {x \\<in> space M. real ?n12 \\<le> \\<bar>f x\\<bar>} < alpha\n  N \\<le> n\n  K \\<le> real n\n\ngoal (1 subgoal):\n 1. prob {x \\<in> space M. real n \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n    K \\<le> real n", "by auto"], ["proof (state)\nthis:\n  \\<exists>C.\n     prob {x \\<in> space M. C \\<le> \\<bar>f x\\<bar>} < alpha \\<and>\n     K \\<le> C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Distribution-functions.thy\\<close>"], ["", "text \\<open>There is a locale called \\verb+finite_borel_measure+ in \\verb+distribution-functions.thy+.\nHowever, it only deals with real measures, and real weak convergence. I will not need the\nweak convergence in more general settings, but still it seems more natural to me to do the\nproofs in the natural settings. Let me introduce the locale \\verb+finite_borel_measure'+ for\nthis, although it would be better to rename the locale in the library file.\\<close>"], ["", "locale finite_borel_measure' = finite_measure M for M :: \"('a::metric_space) measure\" +\n  assumes M_is_borel [simp, measurable_cong]: \"sets M = sets borel\"\nbegin"], ["", "lemma space_eq_univ [simp]: \"space M = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space M = UNIV", "using M_is_borel[THEN sets_eq_imp_space_eq]"], ["proof (prove)\nusing this:\n  space M = space borel\n\ngoal (1 subgoal):\n 1. space M = UNIV", "by simp"], ["", "lemma measurable_finite_borel [simp]:\n  \"f \\<in> borel_measurable borel \\<Longrightarrow> f \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> borel_measurable borel \\<Longrightarrow>\n    f \\<in> borel_measurable M", "by (rule borel_measurable_subalgebra[where N = borel]) auto"], ["", "text \\<open>Any closed set can be slightly enlarged to obtain a set whose boundary has $0$ measure.\\<close>"], ["", "lemma approx_closed_set_with_set_zero_measure_boundary:\n  assumes \"closed S\" \"epsilon > 0\" \"S \\<noteq> {}\"\n  shows \"\\<exists>r. r < epsilon \\<and> r > 0 \\<and> measure M {x. infdist x S = r} = 0 \\<and> measure M {x. infdist x S \\<le> r} < measure M S + epsilon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have [measurable]: \"S \\<in> sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> sets M", "using \\<open>closed S\\<close>"], ["proof (prove)\nusing this:\n  closed S\n\ngoal (1 subgoal):\n 1. S \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  S \\<in> sets M\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "define T where \"T = (\\<lambda>r. {x. infdist x S \\<le> r})\""], ["proof (state)\nthis:\n  T = (\\<lambda>r. {x. infdist x S \\<le> r})\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have [measurable]: \"T r \\<in> sets borel\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. T r \\<in> sets borel", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. infdist x S \\<le> r} \\<in> sets borel", "by measurable"], ["proof (state)\nthis:\n  T ?r \\<in> sets borel\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have *: \"(\\<Inter>n. T ((1/2)^n)) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>n. T ((1 / 2) ^ n)) = S", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>n. {x. infdist x S \\<le> (1 / 2) ^ n}) = S", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa. infdist x S \\<le> (1 / 2) ^ xa \\<Longrightarrow>\n       x \\<in> S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa. infdist x S \\<le> (1 / 2) ^ xa \\<Longrightarrow>\n       x \\<in> S", "assume *: \"\\<forall>n. infdist x S \\<le> (1 / 2) ^n\""], ["proof (state)\nthis:\n  \\<forall>n. infdist x S \\<le> (1 / 2) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa. infdist x S \\<le> (1 / 2) ^ xa \\<Longrightarrow>\n       x \\<in> S", "have \"infdist x S \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x S \\<le> 0", "apply (rule LIMSEQ_le_const[of \"\\<lambda>n. (1/2)^n\"], intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm (1 / 2) < 1\n 2. \\<exists>N. \\<forall>n\\<ge>N. infdist x S \\<le> (1 / 2) ^ n", "using *"], ["proof (prove)\nusing this:\n  \\<forall>n. infdist x S \\<le> (1 / 2) ^ n\n\ngoal (2 subgoals):\n 1. norm (1 / 2) < 1\n 2. \\<exists>N. \\<forall>n\\<ge>N. infdist x S \\<le> (1 / 2) ^ n", "by auto"], ["proof (state)\nthis:\n  infdist x S \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa. infdist x S \\<le> (1 / 2) ^ xa \\<Longrightarrow>\n       x \\<in> S", "then"], ["proof (chain)\npicking this:\n  infdist x S \\<le> 0", "show \"x \\<in> S\""], ["proof (prove)\nusing this:\n  infdist x S \\<le> 0\n\ngoal (1 subgoal):\n 1. x \\<in> S", "using assms infdist_pos_not_in_closed"], ["proof (prove)\nusing this:\n  infdist x S \\<le> 0\n  closed S\n  0 < epsilon\n  S \\<noteq> {}\n  \\<lbrakk>closed ?S; ?S \\<noteq> {}; ?x \\<notin> ?S\\<rbrakk>\n  \\<Longrightarrow> 0 < infdist ?x ?S\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Inter>n. T ((1 / 2) ^ n)) = S\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have A: \"((1::real)/2)^n \\<le> (1/2)^m\" if \"m \\<le> n\" for m n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ n \\<le> (1 / 2) ^ m", "using that"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. (1 / 2) ^ n \\<le> (1 / 2) ^ m", "by (simp add: power_decreasing)"], ["proof (state)\nthis:\n  ?m \\<le> ?n \\<Longrightarrow> (1 / 2) ^ ?n \\<le> (1 / 2) ^ ?m\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have \"(\\<lambda>n. measure M (T ((1/2)^n))) \\<longlonglongrightarrow> measure M S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Sigma_Algebra.measure M (T ((1 / 2) ^ n)))\n    \\<longlonglongrightarrow> Sigma_Algebra.measure M S", "unfolding *[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Sigma_Algebra.measure M (T ((1 / 2) ^ n)))\n    \\<longlonglongrightarrow> Sigma_Algebra.measure M\n                               (\\<Inter>n. T ((1 / 2) ^ n))", "apply (rule finite_Lim_measure_decseq, auto simp add: T_def decseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n x.\n       \\<lbrakk>m \\<le> n; infdist x S \\<le> (1 / 2) ^ n\\<rbrakk>\n       \\<Longrightarrow> infdist x S \\<le> (1 / 2) ^ m", "using A order.trans"], ["proof (prove)\nusing this:\n  ?m \\<le> ?n \\<Longrightarrow> (1 / 2) ^ ?n \\<le> (1 / 2) ^ ?m\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<And>m n x.\n       \\<lbrakk>m \\<le> n; infdist x S \\<le> (1 / 2) ^ n\\<rbrakk>\n       \\<Longrightarrow> infdist x S \\<le> (1 / 2) ^ m", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. Sigma_Algebra.measure M (T ((1 / 2) ^ n)))\n  \\<longlonglongrightarrow> Sigma_Algebra.measure M S\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. Sigma_Algebra.measure M (T ((1 / 2) ^ n)))\n  \\<longlonglongrightarrow> Sigma_Algebra.measure M S", "have B: \"eventually (\\<lambda>n. measure M (T ((1/2)^n)) < measure M S + epsilon) sequentially\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. Sigma_Algebra.measure M (T ((1 / 2) ^ n)))\n  \\<longlonglongrightarrow> Sigma_Algebra.measure M S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n       < Sigma_Algebra.measure M S + epsilon", "apply (rule order_tendstoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M S < Sigma_Algebra.measure M S + epsilon", "using \\<open>epsilon > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < epsilon\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M S < Sigma_Algebra.measure M S + epsilon", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n     < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have C: \"eventually (\\<lambda>n. (1/2)^n < epsilon) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. (1 / 2) ^ n < epsilon", "by (rule order_tendstoD[OF _ \\<open>epsilon > 0\\<close>], intro tendsto_intros, auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. (1 / 2) ^ n < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "obtain n where n: \"(1/2)^n < epsilon\" \"measure M (T ((1/2)^n)) < measure M S + epsilon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>(1 / 2) ^ n < epsilon;\n         Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n         < Sigma_Algebra.measure M S + epsilon\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eventually_conj[OF B C]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in sequentially.\n     Sigma_Algebra.measure M (T ((1 / 2) ^ x))\n     < Sigma_Algebra.measure M S + epsilon \\<and>\n     (1 / 2) ^ x < epsilon\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>(1 / 2) ^ n < epsilon;\n         Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n         < Sigma_Algebra.measure M S + epsilon\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n        < Sigma_Algebra.measure M S + epsilon \\<and>\n        (1 / 2) ^ n < epsilon\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>(1 / 2) ^ n < epsilon;\n         Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n         < Sigma_Algebra.measure M S + epsilon\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ n < epsilon\n  Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n  < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have \"\\<exists>r\\<in>{0<..<(1/2)^n}. measure M {x. infdist x S = r} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>{0<..<(1 / 2) ^ n}.\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0", "apply (rule uncountable_disjoint_family_then_exists_zero_measure, auto simp add: disjoint_family_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable {0<..<(1 / 2) ^ n} \\<Longrightarrow> False", "using uncountable_open_interval"], ["proof (prove)\nusing this:\n  uncountable {?a<..<?b} = (?a < ?b)\n\ngoal (1 subgoal):\n 1. countable {0<..<(1 / 2) ^ n} \\<Longrightarrow> False", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>r\\<in>{0<..<(1 / 2) ^ n}.\n     Sigma_Algebra.measure M {x. infdist x S = r} = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "then"], ["proof (chain)\npicking this:\n  \\<exists>r\\<in>{0<..<(1 / 2) ^ n}.\n     Sigma_Algebra.measure M {x. infdist x S = r} = 0", "obtain r where r: \"r\\<in>{0<..<(1/2)^n}\" \"measure M {x. infdist x S = r} = 0\""], ["proof (prove)\nusing this:\n  \\<exists>r\\<in>{0<..<(1 / 2) ^ n}.\n     Sigma_Algebra.measure M {x. infdist x S = r} = 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> {0<..<(1 / 2) ^ n};\n         Sigma_Algebra.measure M {x. infdist x S = r} = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<in> {0<..<(1 / 2) ^ n}\n  Sigma_Algebra.measure M {x. infdist x S = r} = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "then"], ["proof (chain)\npicking this:\n  r \\<in> {0<..<(1 / 2) ^ n}\n  Sigma_Algebra.measure M {x. infdist x S = r} = 0", "have r2: \"r > 0\" \"r < epsilon\""], ["proof (prove)\nusing this:\n  r \\<in> {0<..<(1 / 2) ^ n}\n  Sigma_Algebra.measure M {x. infdist x S = r} = 0\n\ngoal (1 subgoal):\n 1. 0 < r &&& r < epsilon", "using n"], ["proof (prove)\nusing this:\n  r \\<in> {0<..<(1 / 2) ^ n}\n  Sigma_Algebra.measure M {x. infdist x S = r} = 0\n  (1 / 2) ^ n < epsilon\n  Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n  < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. 0 < r &&& r < epsilon", "by auto"], ["proof (state)\nthis:\n  0 < r\n  r < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "have \"measure M {x. infdist x S \\<le> r} \\<le> measure M {x. infdist x S \\<le> (1/2)^n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n    \\<le> Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}", "apply (rule finite_measure_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x. infdist x S \\<le> r} \\<subseteq> {x. infdist x S \\<le> (1 / 2) ^ n}\n 2. {x. infdist x S \\<le> (1 / 2) ^ n} \\<in> sets M", "using r"], ["proof (prove)\nusing this:\n  r \\<in> {0<..<(1 / 2) ^ n}\n  Sigma_Algebra.measure M {x. infdist x S = r} = 0\n\ngoal (2 subgoals):\n 1. {x. infdist x S \\<le> r} \\<subseteq> {x. infdist x S \\<le> (1 / 2) ^ n}\n 2. {x. infdist x S \\<le> (1 / 2) ^ n} \\<in> sets M", "by auto"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  \\<le> Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "then"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  \\<le> Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}", "have \"measure M {x. infdist x S \\<le> r} < measure M S + epsilon\""], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  \\<le> Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n    < Sigma_Algebra.measure M S + epsilon", "using n(2)"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  \\<le> Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}\n  Sigma_Algebra.measure M (T ((1 / 2) ^ n))\n  < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n    < Sigma_Algebra.measure M S + epsilon", "unfolding T_def"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  \\<le> Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}\n  Sigma_Algebra.measure M {x. infdist x S \\<le> (1 / 2) ^ n}\n  < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n    < Sigma_Algebra.measure M S + epsilon", "by auto"], ["proof (state)\nthis:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "then"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  < Sigma_Algebra.measure M S + epsilon", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  < Sigma_Algebra.measure M S + epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "using r(2) r2"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n  < Sigma_Algebra.measure M S + epsilon\n  Sigma_Algebra.measure M {x. infdist x S = r} = 0\n  0 < r\n  r < epsilon\n\ngoal (1 subgoal):\n 1. \\<exists>r<epsilon.\n       0 < r \\<and>\n       Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n       Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n       < Sigma_Algebra.measure M S + epsilon", "by auto"], ["proof (state)\nthis:\n  \\<exists>r<epsilon.\n     0 < r \\<and>\n     Sigma_Algebra.measure M {x. infdist x S = r} = 0 \\<and>\n     Sigma_Algebra.measure M {x. infdist x S \\<le> r}\n     < Sigma_Algebra.measure M S + epsilon\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* of locale finite_borel_measure'*)"], ["", "sublocale finite_borel_measure \\<subseteq> finite_borel_measure'"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_borel_measure' M", "by (standard, simp add: M_is_borel)"], ["", "subsection \\<open>Weak-convergence.thy\\<close>"], ["", "text \\<open>Since weak convergence is not implemented as a topology, the fact that the convergence of\na sequence implies the convergence of a subsequence is not automatic. We prove it in the lemma\nbelow..\\<close>"], ["", "lemma weak_conv_m_subseq:\n  assumes \"weak_conv_m M_seq M\" \"strict_mono r\"\n  shows \"weak_conv_m (\\<lambda>n. M_seq (r n)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weak_conv_m (\\<lambda>n. M_seq (r n)) M", "using assms LIMSEQ_subseq_LIMSEQ"], ["proof (prove)\nusing this:\n  weak_conv_m M_seq M\n  strict_mono r\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?L; strict_mono ?f\\<rbrakk>\n  \\<Longrightarrow> (?X \\<circ> ?f) \\<longlonglongrightarrow> ?L\n\ngoal (1 subgoal):\n 1. weak_conv_m (\\<lambda>n. M_seq (r n)) M", "unfolding weak_conv_m_def weak_conv_def comp_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     isCont (cdf M) x \\<longrightarrow>\n     (\\<lambda>n. cdf (M_seq n) x) \\<longlonglongrightarrow> cdf M x\n  strict_mono r\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?L; strict_mono ?f\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. ?X (?f x)) \\<longlonglongrightarrow> ?L\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       isCont (cdf M) x \\<longrightarrow>\n       (\\<lambda>n. cdf (M_seq (r n)) x) \\<longlonglongrightarrow> cdf M x", "by auto"], ["", "context\n  fixes \\<mu> :: \"nat \\<Rightarrow> real measure\"\n    and M :: \"real measure\"\n  assumes \\<mu>: \"\\<And>n. real_distribution (\\<mu> n)\"\n  assumes M: \"real_distribution M\"\n  assumes \\<mu>_to_M: \"weak_conv_m \\<mu> M\"\nbegin"], ["", "text \\<open>The measure of a closed set behaves upper semicontinuously with respect to weak convergence:\nif $\\mu_n \\to \\mu$, then $\\limsup \\mu_n(F) \\leq \\mu(F)$ (and the inequality can be strict, think of\nthe situation where $\\mu$ is a Dirac mass at $0$ and $F = \\{0\\}$, but $\\mu_n$ has a density so that\n$\\mu_n(\\{0\\}) = 0$).\\<close>"], ["", "lemma closed_set_weak_conv_usc:\n  assumes \"closed S\" \"measure M S < l\"\n  shows \"eventually (\\<lambda>n. measure (\\<mu> n) S < l) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "proof (cases \"S = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l\n 2. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "case True"], ["proof (state)\nthis:\n  S = {}\n\ngoal (2 subgoals):\n 1. S = {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l\n 2. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "then"], ["proof (chain)\npicking this:\n  S = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  S = {}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "using \\<open>measure M S < l\\<close>"], ["proof (prove)\nusing this:\n  S = {}\n  Sigma_Algebra.measure M S < l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. Sigma_Algebra.measure (\\<mu> n) S < l\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "case False"], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "interpret real_distribution M"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_distribution M", "using M"], ["proof (prove)\nusing this:\n  real_distribution M\n\ngoal (1 subgoal):\n 1. real_distribution M", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "define epsilon where \"epsilon = l - measure M S\""], ["proof (state)\nthis:\n  epsilon = l - prob S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "have \"epsilon > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < epsilon", "unfolding epsilon_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l - prob S", "using assms(2)"], ["proof (prove)\nusing this:\n  prob S < l\n\ngoal (1 subgoal):\n 1. 0 < l - prob S", "by auto"], ["proof (state)\nthis:\n  0 < epsilon\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "obtain r where r: \"r > 0\" \"r < epsilon\" \"measure M {x. infdist x S = r} = 0\" \"measure M {x. infdist x S \\<le> r} < measure M S + epsilon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; r < epsilon; prob {x. infdist x S = r} = 0;\n         prob {x. infdist x S \\<le> r} < prob S + epsilon\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using approx_closed_set_with_set_zero_measure_boundary[OF \\<open>closed S\\<close> \\<open>epsilon > 0\\<close> \\<open>S \\<noteq> {}\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>r<epsilon.\n     0 < r \\<and>\n     prob {x. infdist x S = r} = 0 \\<and>\n     prob {x. infdist x S \\<le> r} < prob S + epsilon\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>0 < r; r < epsilon; prob {x. infdist x S = r} = 0;\n         prob {x. infdist x S \\<le> r} < prob S + epsilon\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < r\n  r < epsilon\n  prob {x. infdist x S = r} = 0\n  prob {x. infdist x S \\<le> r} < prob S + epsilon\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "define T where \"T = {x. infdist x S \\<le> r}\""], ["proof (state)\nthis:\n  T = {x. infdist x S \\<le> r}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "have [measurable]: \"T \\<in> sets borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<in> sets borel", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. infdist x S \\<le> r} \\<in> sets borel", "by auto"], ["proof (state)\nthis:\n  T \\<in> sets borel\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "have \"S \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> T", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> {x. infdist x S \\<le> r}", "using \\<open>closed S\\<close> \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  closed S\n  0 < r\n\ngoal (1 subgoal):\n 1. S \\<subseteq> {x. infdist x S \\<le> r}", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> T\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "have \"measure M T < l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob T < l", "using r(4)"], ["proof (prove)\nusing this:\n  prob {x. infdist x S \\<le> r} < prob S + epsilon\n\ngoal (1 subgoal):\n 1. prob T < l", "unfolding T_def epsilon_def"], ["proof (prove)\nusing this:\n  prob {x. infdist x S \\<le> r} < prob S + (l - prob S)\n\ngoal (1 subgoal):\n 1. prob {x. infdist x S \\<le> r} < l", "by auto"], ["proof (state)\nthis:\n  prob T < l\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "have \"measure M (frontier T) \\<le> measure M {x. infdist x S = r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob (frontier T) \\<le> prob {x. infdist x S = r}", "apply (rule finite_measure_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. frontier T \\<subseteq> {x. infdist x S = r}\n 2. {x. infdist x S = r} \\<in> events", "unfolding T_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. frontier {x. infdist x S \\<le> r} \\<subseteq> {x. infdist x S = r}\n 2. {x. infdist x S = r} \\<in> events", "using frontier_indist_le"], ["proof (prove)\nusing this:\n  ?x \\<in> frontier {y. infdist y ?S \\<le> ?r} \\<Longrightarrow>\n  infdist ?x ?S = ?r\n\ngoal (2 subgoals):\n 1. frontier {x. infdist x S \\<le> r} \\<subseteq> {x. infdist x S = r}\n 2. {x. infdist x S = r} \\<in> events", "by auto"], ["proof (state)\nthis:\n  prob (frontier T) \\<le> prob {x. infdist x S = r}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "then"], ["proof (chain)\npicking this:\n  prob (frontier T) \\<le> prob {x. infdist x S = r}", "have \"measure M (frontier T) = 0\""], ["proof (prove)\nusing this:\n  prob (frontier T) \\<le> prob {x. infdist x S = r}\n\ngoal (1 subgoal):\n 1. prob (frontier T) = 0", "using \\<open>measure M {x. infdist x S = r} = 0\\<close>"], ["proof (prove)\nusing this:\n  prob (frontier T) \\<le> prob {x. infdist x S = r}\n  prob {x. infdist x S = r} = 0\n\ngoal (1 subgoal):\n 1. prob (frontier T) = 0", "by (auto simp add: measure_le_0_iff)"], ["proof (state)\nthis:\n  prob (frontier T) = 0\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "then"], ["proof (chain)\npicking this:\n  prob (frontier T) = 0", "have \"(\\<lambda>n. measure (\\<mu> n) T) \\<longlonglongrightarrow> measure M T\""], ["proof (prove)\nusing this:\n  prob (frontier T) = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Sigma_Algebra.measure (\\<mu> n) T)\n    \\<longlonglongrightarrow> prob T", "using \\<mu>_to_M"], ["proof (prove)\nusing this:\n  prob (frontier T) = 0\n  weak_conv_m \\<mu> M\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Sigma_Algebra.measure (\\<mu> n) T)\n    \\<longlonglongrightarrow> prob T", "by (simp add: \\<mu> emeasure_eq_measure real_distribution_axioms weak_conv_imp_continuity_set_conv)"], ["proof (state)\nthis:\n  (\\<lambda>n. Sigma_Algebra.measure (\\<mu> n) T)\n  \\<longlonglongrightarrow> prob T\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. Sigma_Algebra.measure (\\<mu> n) T)\n  \\<longlonglongrightarrow> prob T", "have *: \"eventually (\\<lambda>n. measure (\\<mu> n) T < l) sequentially\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. Sigma_Algebra.measure (\\<mu> n) T)\n  \\<longlonglongrightarrow> prob T\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) T < l", "apply (rule order_tendstoD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob T < l", "using \\<open>measure M T < l\\<close>"], ["proof (prove)\nusing this:\n  prob T < l\n\ngoal (1 subgoal):\n 1. prob T < l", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. Sigma_Algebra.measure (\\<mu> n) T < l\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "have **: \"measure (\\<mu> n) S \\<le> measure (\\<mu> n) T\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (\\<mu> n) S\n    \\<le> Sigma_Algebra.measure (\\<mu> n) T", "apply (rule finite_measure.finite_measure_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite_measure (\\<mu> n)\n 2. S \\<subseteq> T\n 3. T \\<in> sets (\\<mu> n)", "using \\<mu>"], ["proof (prove)\nusing this:\n  real_distribution (\\<mu> ?n)\n\ngoal (3 subgoals):\n 1. finite_measure (\\<mu> n)\n 2. S \\<subseteq> T\n 3. T \\<in> sets (\\<mu> n)", "apply (simp add: finite_borel_measure.axioms(1) real_distribution.finite_borel_measure_M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S \\<subseteq> T\n 2. T \\<in> sets (\\<mu> n)", "using \\<open>S \\<subseteq> T\\<close>"], ["proof (prove)\nusing this:\n  S \\<subseteq> T\n\ngoal (2 subgoals):\n 1. S \\<subseteq> T\n 2. T \\<in> sets (\\<mu> n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<in> sets (\\<mu> n)", "by (simp add: \\<mu> real_distribution.events_eq_borel)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (\\<mu> ?n1) S\n  \\<le> Sigma_Algebra.measure (\\<mu> ?n1) T\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) S < l", "apply (rule eventually_mono[OF *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Sigma_Algebra.measure (\\<mu> x) T < l \\<Longrightarrow>\n       Sigma_Algebra.measure (\\<mu> x) S < l", "using ** le_less_trans"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (\\<mu> ?n1) S\n  \\<le> Sigma_Algebra.measure (\\<mu> ?n1) T\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Sigma_Algebra.measure (\\<mu> x) T < l \\<Longrightarrow>\n       Sigma_Algebra.measure (\\<mu> x) S < l", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. Sigma_Algebra.measure (\\<mu> n) S < l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the same way, the measure of an open set behaves lower semicontinuously with respect to\nweak convergence: if $\\mu_n \\to \\mu$, then $\\liminf \\mu_n(U) \\geq \\mu(U)$ (and the inequality can be\nstrict). This follows from the same statement for closed sets by passing to the complement.\\<close>"], ["", "lemma open_set_weak_conv_lsc:\n  assumes \"open S\" \"measure M S > l\"\n  shows \"eventually (\\<lambda>n. measure (\\<mu> n) S > l) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "interpret real_distribution M"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_distribution M", "using M"], ["proof (prove)\nusing this:\n  real_distribution M\n\ngoal (1 subgoal):\n 1. real_distribution M", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "have [measurable]: \"S \\<in> events\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> events", "using assms(1)"], ["proof (prove)\nusing this:\n  open S\n\ngoal (1 subgoal):\n 1. S \\<in> events", "by auto"], ["proof (state)\nthis:\n  S \\<in> events\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "have \"eventually (\\<lambda>n. measure (\\<mu> n) (UNIV - S) < 1 - l) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       Sigma_Algebra.measure (\\<mu> n) (UNIV - S) < 1 - l", "apply (rule closed_set_weak_conv_usc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed (UNIV - S)\n 2. prob (UNIV - S) < 1 - l", "using assms prob_compl[of S]"], ["proof (prove)\nusing this:\n  open S\n  l < prob S\n  S \\<in> events \\<Longrightarrow> prob (space M - S) = 1 - prob S\n\ngoal (2 subgoals):\n 1. closed (UNIV - S)\n 2. prob (UNIV - S) < 1 - l", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     Sigma_Algebra.measure (\\<mu> n) (UNIV - S) < 1 - l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     Sigma_Algebra.measure (\\<mu> n) (UNIV - S) < 1 - l\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "have \"measure (\\<mu> n) (UNIV - S) = 1 - measure (\\<mu> n) S\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (\\<mu> n) (UNIV - S) =\n    1 - Sigma_Algebra.measure (\\<mu> n) S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (\\<mu> n) (UNIV - S) =\n    1 - Sigma_Algebra.measure (\\<mu> n) S", "interpret mu: real_distribution \"\\<mu> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_distribution (\\<mu> n)", "using \\<mu>"], ["proof (prove)\nusing this:\n  real_distribution (\\<mu> ?n)\n\ngoal (1 subgoal):\n 1. real_distribution (\\<mu> n)", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. mu.prob (UNIV - S) = 1 - mu.prob S", "have \"S \\<in> mu.events\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> mu.events", "using assms(1)"], ["proof (prove)\nusing this:\n  open S\n\ngoal (1 subgoal):\n 1. S \\<in> mu.events", "by auto"], ["proof (state)\nthis:\n  S \\<in> mu.events\n\ngoal (1 subgoal):\n 1. mu.prob (UNIV - S) = 1 - mu.prob S", "then"], ["proof (chain)\npicking this:\n  S \\<in> mu.events", "show ?thesis"], ["proof (prove)\nusing this:\n  S \\<in> mu.events\n\ngoal (1 subgoal):\n 1. mu.prob (UNIV - S) = 1 - mu.prob S", "using mu.prob_compl[of S]"], ["proof (prove)\nusing this:\n  S \\<in> mu.events\n  S \\<in> mu.events \\<Longrightarrow>\n  mu.prob (space (\\<mu> n) - S) = 1 - mu.prob S\n\ngoal (1 subgoal):\n 1. mu.prob (UNIV - S) = 1 - mu.prob S", "by auto"], ["proof (state)\nthis:\n  mu.prob (UNIV - S) = 1 - mu.prob S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (\\<mu> ?n1) (UNIV - S) =\n  1 - Sigma_Algebra.measure (\\<mu> ?n1) S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     Sigma_Algebra.measure (\\<mu> n) (UNIV - S) < 1 - l\n  Sigma_Algebra.measure (\\<mu> ?n1) (UNIV - S) =\n  1 - Sigma_Algebra.measure (\\<mu> ?n1) S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     Sigma_Algebra.measure (\\<mu> n) (UNIV - S) < 1 - l\n  Sigma_Algebra.measure (\\<mu> ?n1) (UNIV - S) =\n  1 - Sigma_Algebra.measure (\\<mu> ?n1) S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       l < Sigma_Algebra.measure (\\<mu> n) S", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. l < Sigma_Algebra.measure (\\<mu> n) S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of context weak_conv_m*)"], ["", "end"], ["", "(*of SG_Library_Complement.thy*)"]]}