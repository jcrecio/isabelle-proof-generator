{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_CSP/GeneralizedNoninterference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_CSP", "problem_names": ["lemma g_secure_suff_implies_g_secure:\n  assumes S: \"g_secure_suff P L\"\n  shows \"g_secure P L\"", "lemma g_I_refl: \"refl g_I\"", "lemma g_sinks: \"sinks g_I L High xs \\<subseteq> {High}\"", "lemma g_ipurge_tr: \"ipurge_tr g_I L High xs = [x\\<leftarrow>xs. L x = Low]\"", "theorem secure_implies_g_secure:\n  assumes S: \"secure P g_I L\"\n  shows \"g_secure P L\"", "theorem c_secure_implies_g_secure:\n \"c_secure step out s\\<^sub>0 g_I L \\<Longrightarrow> g_secure (c_process step out s\\<^sub>0) (c_dom L)\"", "lemma g_secure_counterexample:\n \"g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D)\"", "lemma not_c_secure_counterexample:\n \"\\<not> c_secure g_step g_out g_s\\<^sub>0 g_I g_D\"", "theorem not_g_secure_implies_c_secure:\n \"\\<not> (g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D) \\<longrightarrow>\n  c_secure g_step g_out g_s\\<^sub>0 g_I g_D)\"", "theorem not_g_secure_implies_secure:\n \"\\<not> (g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D) \\<longrightarrow>\n  secure (c_process g_step g_out g_s\\<^sub>0) g_I (c_dom g_D))\""], "translations": [["", "lemma g_secure_suff_implies_g_secure:\n  assumes S: \"g_secure_suff P L\"\n  shows \"g_secure P L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_secure P L", "proof (simp add: g_secure_def, (rule allI)+, rule impI, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High\\<rbrakk>\n       \\<Longrightarrow> {ys'.\n                          \\<exists>ys.\n                             xs @ ys \\<in> traces P \\<and>\n                             ys' = filter (\\<lambda>y. L y = Low) ys} =\n                         {ys'.\n                          \\<exists>ys.\n                             xs @ x # ys \\<in> traces P \\<and>\n                             ys' = filter (\\<lambda>y. L y = Low) ys}", "fix xs x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High\\<rbrakk>\n       \\<Longrightarrow> {ys'.\n                          \\<exists>ys.\n                             xs @ ys \\<in> traces P \\<and>\n                             ys' = filter (\\<lambda>y. L y = Low) ys} =\n                         {ys'.\n                          \\<exists>ys.\n                             xs @ x # ys \\<in> traces P \\<and>\n                             ys' = filter (\\<lambda>y. L y = Low) ys}", "assume\n    A: \"xs @ [x] \\<in> traces P\" and\n    B: \"L x = High\""], ["proof (state)\nthis:\n  xs @ [x] \\<in> traces P\n  L x = High\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High\\<rbrakk>\n       \\<Longrightarrow> {ys'.\n                          \\<exists>ys.\n                             xs @ ys \\<in> traces P \\<and>\n                             ys' = filter (\\<lambda>y. L y = Low) ys} =\n                         {ys'.\n                          \\<exists>ys.\n                             xs @ x # ys \\<in> traces P \\<and>\n                             ys' = filter (\\<lambda>y. L y = Low) ys}", "show \"{ys'. \\<exists>ys. xs @ ys \\<in> traces P \\<and> ys' = [y\\<leftarrow>ys . L y = Low]} =\n    {ys'. \\<exists>ys. xs @ x # ys \\<in> traces P \\<and> ys' = [y\\<leftarrow>ys . L y = Low]}\"\n   (is \"{ys'. \\<exists>ys. ?Q ys ys'} = {ys'. \\<exists>ys. ?Q' ys ys'}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys'.\n     \\<exists>ys.\n        xs @ ys \\<in> traces P \\<and>\n        ys' = filter (\\<lambda>y. L y = Low) ys} =\n    {ys'.\n     \\<exists>ys.\n        xs @ x # ys \\<in> traces P \\<and>\n        ys' = filter (\\<lambda>y. L y = Low) ys}", "proof (rule equalityI, rule_tac [2] subsetI, simp_all, erule_tac [2] exE,\n   erule_tac [2] conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. {ys'.\n     \\<exists>ys.\n        xs @ ys \\<in> traces P \\<and>\n        ys' = filter (\\<lambda>y. L y = Low) ys}\n    \\<subseteq> {ys'.\n                 \\<exists>ys.\n                    xs @ x # ys \\<in> traces P \\<and>\n                    ys' = filter (\\<lambda>y. L y = Low) ys}\n 2. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "show \"{ys'. \\<exists>ys. ?Q ys ys'} \\<subseteq> {ys'. \\<exists>ys. ?Q' ys ys'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ys'.\n     \\<exists>ys.\n        xs @ ys \\<in> traces P \\<and>\n        ys' = filter (\\<lambda>y. L y = Low) ys}\n    \\<subseteq> {ys'.\n                 \\<exists>ys.\n                    xs @ x # ys \\<in> traces P \\<and>\n                    ys' = filter (\\<lambda>y. L y = Low) ys}", "using S and A and B"], ["proof (prove)\nusing this:\n  g_secure_suff P L\n  xs @ [x] \\<in> traces P\n  L x = High\n\ngoal (1 subgoal):\n 1. {ys'.\n     \\<exists>ys.\n        xs @ ys \\<in> traces P \\<and>\n        ys' = filter (\\<lambda>y. L y = Low) ys}\n    \\<subseteq> {ys'.\n                 \\<exists>ys.\n                    xs @ x # ys \\<in> traces P \\<and>\n                    ys' = filter (\\<lambda>y. L y = Low) ys}", "by (simp add: g_secure_suff_def)"], ["proof (state)\nthis:\n  {ys'.\n   \\<exists>ys.\n      xs @ ys \\<in> traces P \\<and> ys' = filter (\\<lambda>y. L y = Low) ys}\n  \\<subseteq> {ys'.\n               \\<exists>ys.\n                  xs @ x # ys \\<in> traces P \\<and>\n                  ys' = filter (\\<lambda>y. L y = Low) ys}\n\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "fix ys ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "assume \"xs @ x # ys \\<in> traces P\""], ["proof (state)\nthis:\n  xs @ x # ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "moreover"], ["proof (state)\nthis:\n  xs @ x # ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "assume \"ys' = [y\\<leftarrow>ys. L y = Low]\""], ["proof (state)\nthis:\n  ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "hence \"ys' = [y\\<leftarrow>x # ys. L y = Low]\""], ["proof (prove)\nusing this:\n  ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal (1 subgoal):\n 1. ys' = filter (\\<lambda>y. L y = Low) (x # ys)", "using B"], ["proof (prove)\nusing this:\n  ys' = filter (\\<lambda>y. L y = Low) ys\n  L x = High\n\ngoal (1 subgoal):\n 1. ys' = filter (\\<lambda>y. L y = Low) (x # ys)", "by simp"], ["proof (state)\nthis:\n  ys' = filter (\\<lambda>y. L y = Low) (x # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  xs @ x # ys \\<in> traces P\n  ys' = filter (\\<lambda>y. L y = Low) (x # ys)", "have \"?Q (x # ys) ys'\""], ["proof (prove)\nusing this:\n  xs @ x # ys \\<in> traces P\n  ys' = filter (\\<lambda>y. L y = Low) (x # ys)\n\ngoal (1 subgoal):\n 1. xs @ x # ys \\<in> traces P \\<and>\n    ys' = filter (\\<lambda>y. L y = Low) (x # ys)", ".."], ["proof (state)\nthis:\n  xs @ x # ys \\<in> traces P \\<and>\n  ys' = filter (\\<lambda>y. L y = Low) (x # ys)\n\ngoal (1 subgoal):\n 1. \\<And>xa ys.\n       \\<lbrakk>xs @ x # ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "thus \"\\<exists>ys. ?Q ys ys'\""], ["proof (prove)\nusing this:\n  xs @ x # ys \\<in> traces P \\<and>\n  ys' = filter (\\<lambda>y. L y = Low) (x # ys)\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       xs @ ys \\<in> traces P \\<and> ys' = filter (\\<lambda>y. L y = Low) ys", ".."], ["proof (state)\nthis:\n  \\<exists>ys.\n     xs @ ys \\<in> traces P \\<and> ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {ys'.\n   \\<exists>ys.\n      xs @ ys \\<in> traces P \\<and>\n      ys' = filter (\\<lambda>y. L y = Low) ys} =\n  {ys'.\n   \\<exists>ys.\n      xs @ x # ys \\<in> traces P \\<and>\n      ys' = filter (\\<lambda>y. L y = Low) ys}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Comparison between security properties\""], ["", "text \\<open>\nIn the continuation, it will be proven that CSP noninterference security is a sufficient condition\nfor generalized noninterference security for any process whose events are mapped into either\nsecurity domain \\<open>High\\<close> or \\<open>Low\\<close>, under the policy that \\<open>High\\<close> may not affect\n\\<open>Low\\<close>.\n\nParticularly, this is the case for any such classical process. This fact, along with the equivalence\nbetween CSP noninterference security and classical noninterference security for classical processes,\nis used to additionally prove that the classical noninterference security of a deterministic state\nmachine is a sufficient condition for the generalized noninterference security of the corresponding\nclassical process under the aforesaid policy.\n\n\\null\n\\<close>"], ["", "definition g_I :: \"(g_level \\<times> g_level) set\" where\n\"g_I \\<equiv> {(High, High), (Low, Low), (Low, High)}\""], ["", "lemma g_I_refl: \"refl g_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl g_I", "proof (simp add: refl_on_def, rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x, x) \\<in> g_I", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (x, x) \\<in> g_I", "show \"(x, x) \\<in> g_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x) \\<in> g_I", "by (cases x, simp_all add: g_I_def)"], ["proof (state)\nthis:\n  (x, x) \\<in> g_I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_sinks: \"sinks g_I L High xs \\<subseteq> {High}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks g_I L High xs \\<subseteq> {High}", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks g_I L High xs \\<subseteq> {High} \\<Longrightarrow>\n       sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks g_I L High xs \\<subseteq> {High} \\<Longrightarrow>\n       sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "assume A: \"sinks g_I L High xs \\<subseteq> {High}\""], ["proof (state)\nthis:\n  sinks g_I L High xs \\<subseteq> {High}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       sinks g_I L High xs \\<subseteq> {High} \\<Longrightarrow>\n       sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "show \"sinks g_I L High (xs @ [x]) \\<subseteq> {High}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "proof (cases \"L x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n 2. L x = Low \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "assume \"L x = High\""], ["proof (state)\nthis:\n  L x = High\n\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n 2. L x = Low \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "thus ?thesis"], ["proof (prove)\nusing this:\n  L x = High\n\ngoal (1 subgoal):\n 1. sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "using A"], ["proof (prove)\nusing this:\n  L x = High\n  sinks g_I L High xs \\<subseteq> {High}\n\ngoal (1 subgoal):\n 1. sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "by simp"], ["proof (state)\nthis:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "assume B: \"L x = Low\""], ["proof (state)\nthis:\n  L x = Low\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "have \"\\<not> ((High, L x) \\<in> g_I \\<or> (\\<exists>v \\<in> sinks g_I L High xs. (v, L x) \\<in> g_I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ((High, L x) \\<in> g_I \\<or>\n            (\\<exists>v\\<in>sinks g_I L High xs. (v, L x) \\<in> g_I))", "proof (rule notI, simp add: B, erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (High, Low) \\<in> g_I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "assume \"(High, Low) \\<in> g_I\""], ["proof (state)\nthis:\n  (High, Low) \\<in> g_I\n\ngoal (2 subgoals):\n 1. (High, Low) \\<in> g_I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (High, Low) \\<in> g_I\n\ngoal (2 subgoals):\n 1. (High, Low) \\<in> g_I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "have \"(High, Low) \\<notin> g_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (High, Low) \\<notin> g_I", "by (simp add: g_I_def)"], ["proof (state)\nthis:\n  (High, Low) \\<notin> g_I\n\ngoal (2 subgoals):\n 1. (High, Low) \\<in> g_I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (High, Low) \\<in> g_I\n  (High, Low) \\<notin> g_I", "show False"], ["proof (prove)\nusing this:\n  (High, Low) \\<in> g_I\n  (High, Low) \\<notin> g_I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks g_I L High xs. (v, Low) \\<in> g_I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I", "obtain v where C: \"v \\<in> sinks g_I L High xs\" and D: \"(v, Low) \\<in> g_I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks g_I L High xs; (v, Low) \\<in> g_I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks g_I L High xs\n  (v, Low) \\<in> g_I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "have \"v \\<in> {High}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> {High}", "using A and C"], ["proof (prove)\nusing this:\n  sinks g_I L High xs \\<subseteq> {High}\n  v \\<in> sinks g_I L High xs\n\ngoal (1 subgoal):\n 1. v \\<in> {High}", ".."], ["proof (state)\nthis:\n  v \\<in> {High}\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "hence \"(High, Low) \\<in> g_I\""], ["proof (prove)\nusing this:\n  v \\<in> {High}\n\ngoal (1 subgoal):\n 1. (High, Low) \\<in> g_I", "using D"], ["proof (prove)\nusing this:\n  v \\<in> {High}\n  (v, Low) \\<in> g_I\n\ngoal (1 subgoal):\n 1. (High, Low) \\<in> g_I", "by simp"], ["proof (state)\nthis:\n  (High, Low) \\<in> g_I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  (High, Low) \\<in> g_I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "have \"(High, Low) \\<notin> g_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (High, Low) \\<notin> g_I", "by (simp add: g_I_def)"], ["proof (state)\nthis:\n  (High, Low) \\<notin> g_I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks g_I L High xs. (v, Low) \\<in> g_I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  (High, Low) \\<in> g_I\n  (High, Low) \\<notin> g_I", "show False"], ["proof (prove)\nusing this:\n  (High, Low) \\<in> g_I\n  (High, Low) \\<notin> g_I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> ((High, L x) \\<in> g_I \\<or>\n          (\\<exists>v\\<in>sinks g_I L High xs. (v, L x) \\<in> g_I))\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> ((High, L x) \\<in> g_I \\<or>\n          (\\<exists>v\\<in>sinks g_I L High xs. (v, L x) \\<in> g_I))\n\ngoal (1 subgoal):\n 1. sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "using A"], ["proof (prove)\nusing this:\n  \\<not> ((High, L x) \\<in> g_I \\<or>\n          (\\<exists>v\\<in>sinks g_I L High xs. (v, L x) \\<in> g_I))\n  sinks g_I L High xs \\<subseteq> {High}\n\ngoal (1 subgoal):\n 1. sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "by simp"], ["proof (state)\nthis:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_ipurge_tr: \"ipurge_tr g_I L High xs = [x\\<leftarrow>xs. L x = Low]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High xs = filter (\\<lambda>x. L x = Low) xs", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr g_I L High xs =\n       filter (\\<lambda>x. L x = Low) xs \\<Longrightarrow>\n       ipurge_tr g_I L High (xs @ [x]) =\n       filter (\\<lambda>x. L x = Low) (xs @ [x])", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr g_I L High xs =\n       filter (\\<lambda>x. L x = Low) xs \\<Longrightarrow>\n       ipurge_tr g_I L High (xs @ [x]) =\n       filter (\\<lambda>x. L x = Low) (xs @ [x])", "assume A: \"ipurge_tr g_I L High xs = [x'\\<leftarrow>xs. L x' = Low]\""], ["proof (state)\nthis:\n  ipurge_tr g_I L High xs = filter (\\<lambda>x'. L x' = Low) xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr g_I L High xs =\n       filter (\\<lambda>x. L x = Low) xs \\<Longrightarrow>\n       ipurge_tr g_I L High (xs @ [x]) =\n       filter (\\<lambda>x. L x = Low) (xs @ [x])", "show \"ipurge_tr g_I L High (xs @ [x]) = [x'\\<leftarrow>xs @ [x]. L x' = Low]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "proof (cases \"L x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n 2. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "assume B: \"L x = High\""], ["proof (state)\nthis:\n  L x = High\n\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n 2. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "hence \"ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs\""], ["proof (prove)\nusing this:\n  L x = High\n\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs", "by (simp add: g_I_def)"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs\n\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n 2. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs\n\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n 2. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "have \"[x'\\<leftarrow>xs @ [x]. L x' = Low] = [x'\\<leftarrow>xs. L x' = Low]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) xs", "using B"], ["proof (prove)\nusing this:\n  L x = High\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) xs", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs\n\ngoal (2 subgoals):\n 1. L x = High \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n 2. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs\n  ipurge_tr g_I L High xs = filter (\\<lambda>x'. L x' = Low) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "assume B: \"L x = Low\""], ["proof (state)\nthis:\n  L x = Low\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "have \"L x \\<notin> sinks g_I L High (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L x \\<notin> sinks g_I L High (xs @ [x])", "proof (rule notI, simp only: B)"], ["proof (state)\ngoal (1 subgoal):\n 1. Low \\<in> sinks g_I L High (xs @ [x]) \\<Longrightarrow> False", "have \"sinks g_I L High (xs @ [x]) \\<subseteq> {High}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks g_I L High (xs @ [x]) \\<subseteq> {High}", "by (rule g_sinks)"], ["proof (state)\nthis:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n\ngoal (1 subgoal):\n 1. Low \\<in> sinks g_I L High (xs @ [x]) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n\ngoal (1 subgoal):\n 1. Low \\<in> sinks g_I L High (xs @ [x]) \\<Longrightarrow> False", "assume \"Low \\<in> sinks g_I L High (xs @ [x])\""], ["proof (state)\nthis:\n  Low \\<in> sinks g_I L High (xs @ [x])\n\ngoal (1 subgoal):\n 1. Low \\<in> sinks g_I L High (xs @ [x]) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n  Low \\<in> sinks g_I L High (xs @ [x])", "have \"Low \\<in> {High}\""], ["proof (prove)\nusing this:\n  sinks g_I L High (xs @ [x]) \\<subseteq> {High}\n  Low \\<in> sinks g_I L High (xs @ [x])\n\ngoal (1 subgoal):\n 1. Low \\<in> {High}", ".."], ["proof (state)\nthis:\n  Low \\<in> {High}\n\ngoal (1 subgoal):\n 1. Low \\<in> sinks g_I L High (xs @ [x]) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Low \\<in> {High}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L x \\<notin> sinks g_I L High (xs @ [x])\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "hence \"ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]\""], ["proof (prove)\nusing this:\n  L x \\<notin> sinks g_I L High (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "have \"[x'\\<leftarrow>xs @ [x]. L x' = Low] = [x'\\<leftarrow>xs. L x' = Low] @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) xs @ [x]", "using B"], ["proof (prove)\nusing this:\n  L x = Low\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) xs @ [x]", "by simp"], ["proof (state)\nthis:\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs @ [x]\n\ngoal (1 subgoal):\n 1. L x = Low \\<Longrightarrow>\n    ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs @ [x]", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs @ [x]\n\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr g_I L High (xs @ [x]) = ipurge_tr g_I L High xs @ [x]\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) xs @ [x]\n  ipurge_tr g_I L High xs = filter (\\<lambda>x'. L x' = Low) xs\n\ngoal (1 subgoal):\n 1. ipurge_tr g_I L High (xs @ [x]) =\n    filter (\\<lambda>x'. L x' = Low) (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr g_I L High (xs @ [x]) =\n  filter (\\<lambda>x'. L x' = Low) (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem secure_implies_g_secure:\n  assumes S: \"secure P g_I L\"\n  shows \"g_secure P L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_secure P L", "proof (rule g_secure_suff_implies_g_secure, simp add: g_secure_suff_def, (rule allI)+,\n rule impI, rule subsetI, simp, erule exE, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "fix xs x ys ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "assume \"xs @ [x] \\<in> traces P\""], ["proof (state)\nthis:\n  xs @ [x] \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "hence \"\\<exists>X. ([x], X) \\<in> futures P xs\""], ["proof (prove)\nusing this:\n  xs @ [x] \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<exists>X. ([x], X) \\<in> futures P xs", "by (simp add: traces_def Domain_iff futures_def)"], ["proof (state)\nthis:\n  \\<exists>X. ([x], X) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>X. ([x], X) \\<in> futures P xs", "obtain X where \"([x], X) \\<in> futures P xs\""], ["proof (prove)\nusing this:\n  \\<exists>X. ([x], X) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        ([x], X) \\<in> futures P xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  ([x], X) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "moreover"], ["proof (state)\nthis:\n  ([x], X) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "assume \"xs @ ys \\<in> traces P\""], ["proof (state)\nthis:\n  xs @ ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "hence \"\\<exists>Y. (ys, Y) \\<in> futures P xs\""], ["proof (prove)\nusing this:\n  xs @ ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<exists>Y. (ys, Y) \\<in> futures P xs", "by (simp add: traces_def Domain_iff futures_def)"], ["proof (state)\nthis:\n  \\<exists>Y. (ys, Y) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>Y. (ys, Y) \\<in> futures P xs", "obtain Y where \"(ys, Y) \\<in> futures P xs\""], ["proof (prove)\nusing this:\n  \\<exists>Y. (ys, Y) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        (ys, Y) \\<in> futures P xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (ys, Y) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  ([x], X) \\<in> futures P xs\n  (ys, Y) \\<in> futures P xs", "have \"(x # ipurge_tr g_I L (L x) ys,\n    ipurge_ref g_I L (L x) ys Y) \\<in> futures P xs\"\n   (is \"(_, ?Y') \\<in> futures P xs\")"], ["proof (prove)\nusing this:\n  ([x], X) \\<in> futures P xs\n  (ys, Y) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. (x # ipurge_tr g_I L (L x) ys, ipurge_ref g_I L (L x) ys Y)\n    \\<in> futures P xs", "using S"], ["proof (prove)\nusing this:\n  ([x], X) \\<in> futures P xs\n  (ys, Y) \\<in> futures P xs\n  secure P g_I L\n\ngoal (1 subgoal):\n 1. (x # ipurge_tr g_I L (L x) ys, ipurge_ref g_I L (L x) ys Y)\n    \\<in> futures P xs", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (x # ipurge_tr g_I L (L x) ys, ipurge_ref g_I L (L x) ys Y)\n  \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "moreover"], ["proof (state)\nthis:\n  (x # ipurge_tr g_I L (L x) ys, ipurge_ref g_I L (L x) ys Y)\n  \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "assume \"L x = High\" and A: \"ys' = [y\\<leftarrow>ys. L y = Low]\""], ["proof (state)\nthis:\n  L x = High\n  ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  (x # ipurge_tr g_I L (L x) ys, ipurge_ref g_I L (L x) ys Y)\n  \\<in> futures P xs\n  L x = High\n  ys' = filter (\\<lambda>y. L y = Low) ys", "have \"(x # ys', ?Y') \\<in> futures P xs\""], ["proof (prove)\nusing this:\n  (x # ipurge_tr g_I L (L x) ys, ipurge_ref g_I L (L x) ys Y)\n  \\<in> futures P xs\n  L x = High\n  ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal (1 subgoal):\n 1. (x # ys', ipurge_ref g_I L (L x) ys Y) \\<in> futures P xs", "by (simp add: g_ipurge_tr)"], ["proof (state)\nthis:\n  (x # ys', ipurge_ref g_I L (L x) ys Y) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "hence \"\\<exists>Y'. (x # ys', Y') \\<in> futures P xs\""], ["proof (prove)\nusing this:\n  (x # ys', ipurge_ref g_I L (L x) ys Y) \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<exists>Y'. (x # ys', Y') \\<in> futures P xs", ".."], ["proof (state)\nthis:\n  \\<exists>Y'. (x # ys', Y') \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "hence \"xs @ x # ys' \\<in> traces P\""], ["proof (prove)\nusing this:\n  \\<exists>Y'. (x # ys', Y') \\<in> futures P xs\n\ngoal (1 subgoal):\n 1. xs @ x # ys' \\<in> traces P", "by (simp add: traces_def Domain_iff futures_def)"], ["proof (state)\nthis:\n  xs @ x # ys' \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "moreover"], ["proof (state)\nthis:\n  xs @ x # ys' \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "have \"ys' = [y\\<leftarrow>ys'. L y = Low]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys' = filter (\\<lambda>y. L y = Low) ys'", "using A"], ["proof (prove)\nusing this:\n  ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal (1 subgoal):\n 1. ys' = filter (\\<lambda>y. L y = Low) ys'", "by simp"], ["proof (state)\nthis:\n  ys' = filter (\\<lambda>y. L y = Low) ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  xs @ x # ys' \\<in> traces P\n  ys' = filter (\\<lambda>y. L y = Low) ys'", "have \"xs @ x # ys' \\<in> traces P \\<and> ys' = [y\\<leftarrow>ys'. L y = Low]\""], ["proof (prove)\nusing this:\n  xs @ x # ys' \\<in> traces P\n  ys' = filter (\\<lambda>y. L y = Low) ys'\n\ngoal (1 subgoal):\n 1. xs @ x # ys' \\<in> traces P \\<and>\n    ys' = filter (\\<lambda>y. L y = Low) ys'", ".."], ["proof (state)\nthis:\n  xs @ x # ys' \\<in> traces P \\<and>\n  ys' = filter (\\<lambda>y. L y = Low) ys'\n\ngoal (1 subgoal):\n 1. \\<And>xs x xa ys.\n       \\<lbrakk>xs @ [x] \\<in> traces P; L x = High; xs @ ys \\<in> traces P;\n        xa = filter (\\<lambda>y. L y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ x # ys \\<in> traces P \\<and>\n                            xa = filter (\\<lambda>y. L y = Low) ys", "thus \"\\<exists>ys. xs @ x # ys \\<in> traces P \\<and> ys' = [y\\<leftarrow>ys. L y = Low]\""], ["proof (prove)\nusing this:\n  xs @ x # ys' \\<in> traces P \\<and>\n  ys' = filter (\\<lambda>y. L y = Low) ys'\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       xs @ x # ys \\<in> traces P \\<and>\n       ys' = filter (\\<lambda>y. L y = Low) ys", ".."], ["proof (state)\nthis:\n  \\<exists>ys.\n     xs @ x # ys \\<in> traces P \\<and>\n     ys' = filter (\\<lambda>y. L y = Low) ys\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem c_secure_implies_g_secure:\n \"c_secure step out s\\<^sub>0 g_I L \\<Longrightarrow> g_secure (c_process step out s\\<^sub>0) (c_dom L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_secure step out s\\<^sub>0 g_I L \\<Longrightarrow>\n    g_secure (c_process step out s\\<^sub>0) (c_dom L)", "by (rule secure_implies_g_secure, rule c_secure_implies_secure, rule g_I_refl)"], ["", "text \\<open>\n\\null\n\nSince the definition of generalized noninterference security does not impose any explicit\nrequirement on process refusals, intuition suggests that this security property is likely to be\ngenerally weaker than CSP noninterference security for nondeterministic processes, which are such\nthat even a complete specification of their traces leaves underdetermined their refusals. This is\nnot the case for deterministic processes, so the aforesaid security properties might in principle\nbe equivalent as regards such processes.\n\nHowever, a counterexample proving the contrary is provided by a deterministic state machine\nresembling systems \\emph{A} and \\emph{B} described in \\cite{R4}, section 3.1. This machine is proven\nnot to be classical noninterference-secure, whereas the corresponding classical process turns out to\nbe generalized noninterference-secure, which proves that the generalized noninterference security of\na classical process is not a sufficient condition for the classical noninterference security of the\nassociated deterministic state machine.\n\nThis result, along with the equivalence between CSP noninterference security and classical\nnoninterference security for classical processes, is then used to demonstrate that the generalized\nnoninterference security of the aforesaid classical process does not entail its CSP noninterference\nsecurity, which proves that generalized noninterference security is actually not a sufficient\ncondition for CSP noninterference security even in the case of deterministic processes.\n\nThe remainder of this section is dedicated to the construction of such counterexample.\n\n\\null\n\\<close>"], ["", "datatype g_state = Even | Odd"], ["", "datatype g_action = Any | Count"], ["", "primrec g_step :: \"g_state \\<Rightarrow> g_action \\<Rightarrow> g_state\" where\n\"g_step s Any = (case s of Even \\<Rightarrow> Odd | Odd \\<Rightarrow> Even)\" |\n\"g_step s Count = s\""], ["", "primrec g_out :: \"g_state \\<Rightarrow> g_action \\<Rightarrow> g_state option\" where\n\"g_out _ Any = None\" |\n\"g_out s Count = Some s\""], ["", "primrec g_D :: \"g_action \\<Rightarrow> g_level\" where\n\"g_D Any = High\" |\n\"g_D Count = Low\""], ["", "definition g_s\\<^sub>0 :: g_state where\n\"g_s\\<^sub>0 \\<equiv> Even\""], ["", "lemma g_secure_counterexample:\n \"g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D)", "proof (rule g_secure_suff_implies_g_secure, simp add: g_secure_suff_def, (rule allI)+,\n rule impI, rule subsetI, simp, erule exE, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "fix xps x p yps yps'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "assume \"xps @ [(x, p)] \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\""], ["proof (state)\nthis:\n  xps @ [(x, p)] \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"\\<exists>X. (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0\""], ["proof (prove)\nusing this:\n  xps @ [(x, p)] \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0", "by (simp add: c_traces)"], ["proof (state)\nthis:\n  \\<exists>X. (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>X. (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0", "obtain X where \"(xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0\""], ["proof (prove)\nusing this:\n  \\<exists>X. (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        (xps @ [(x, p)], X)\n        \\<in> c_failures g_step g_out g_s\\<^sub>0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst (xps @ [(x, p)]))\""], ["proof (prove)\nusing this:\n  (xps @ [(x, p)], X) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps @ [(x, p)] =\n    c_tr g_step g_out g_s\\<^sub>0 (map fst (xps @ [(x, p)]))", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst (xps @ [(x, p)]))\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "moreover"], ["proof (state)\nthis:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst (xps @ [(x, p)]))\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "assume \"c_dom g_D (x, p) = High\""], ["proof (state)\nthis:\n  c_dom g_D (x, p) = High\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"x = Any\""], ["proof (prove)\nusing this:\n  c_dom g_D (x, p) = High\n\ngoal (1 subgoal):\n 1. x = Any", "by (cases x, simp_all add: c_dom_def)"], ["proof (state)\nthis:\n  x = Any\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst (xps @ [(x, p)]))\n  x = Any", "have \"xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any])\"\n   (is \"_ = _ (?xs @ _)\")"], ["proof (prove)\nusing this:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst (xps @ [(x, p)]))\n  x = Any\n\ngoal (1 subgoal):\n 1. xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any])", "by simp"], ["proof (state)\nthis:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any])\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "moreover"], ["proof (state)\nthis:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any])\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "assume \"xps @ yps \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\""], ["proof (state)\nthis:\n  xps @ yps \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"\\<exists>Y. (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0\""], ["proof (prove)\nusing this:\n  xps @ yps \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<exists>Y. (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0", "by (simp add: c_traces)"], ["proof (state)\nthis:\n  \\<exists>Y. (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "then"], ["proof (chain)\npicking this:\n  \\<exists>Y. (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0", "obtain Y where \"(xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0\""], ["proof (prove)\nusing this:\n  \\<exists>Y. (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        (xps @ yps, Y)\n        \\<in> c_failures g_step g_out g_s\\<^sub>0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"(yps, Y) \\<in> futures (c_process g_step g_out g_s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (xps @ yps, Y) \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (yps, Y) \\<in> futures (c_process g_step g_out g_s\\<^sub>0) xps", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (yps, Y) \\<in> futures (c_process g_step g_out g_s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"yps = c_tr g_step g_out (foldl g_step g_s\\<^sub>0 ?xs) (map fst yps)\"\n   (is \"_ = c_tr _ _ _ ?ys\")"], ["proof (prove)\nusing this:\n  (yps, Y) \\<in> futures (c_process g_step g_out g_s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. yps =\n    c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps)) (map fst yps)", "by (rule c_futures_tr)"], ["proof (state)\nthis:\n  yps =\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps)) (map fst yps)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"yps =\n    c_tr g_step g_out (foldl g_step (foldl g_step g_s\\<^sub>0 (?xs @ [Any])) [Any]) ?ys\"\n   (is \"_ = c_tr _ _ (foldl _ ?s _) _\")"], ["proof (prove)\nusing this:\n  yps =\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps)) (map fst yps)\n\ngoal (1 subgoal):\n 1. yps =\n    c_tr g_step g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any])\n     (map fst yps)", "by (cases \"foldl g_step g_s\\<^sub>0 ?xs\", simp_all)"], ["proof (state)\nthis:\n  yps =\n  c_tr g_step g_out\n   (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any])\n   (map fst yps)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"c_tr g_step g_out ?s [Any] @ yps = c_tr g_step g_out ?s ([Any] @ ?ys)\"\n   (is \"?yp @ _ = _\")"], ["proof (prove)\nusing this:\n  yps =\n  c_tr g_step g_out\n   (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any])\n   (map fst yps)\n\ngoal (1 subgoal):\n 1. c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps =\n    c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     ([Any] @ map fst yps)", "by (simp only: c_tr_append)"], ["proof (state)\nthis:\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps =\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n   ([Any] @ map fst yps)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "moreover"], ["proof (state)\nthis:\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps =\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n   ([Any] @ map fst yps)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "have \"(c_tr g_step g_out ?s ([Any] @ ?ys),\n    {(x, p). p \\<noteq> g_out (foldl g_step ?s ([Any] @ ?ys)) x})\n    \\<in> futures (c_process g_step g_out g_s\\<^sub>0) (c_tr g_step g_out g_s\\<^sub>0 (?xs @ [Any]))\"\n   (is \"(_, ?Y') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n      ([Any] @ map fst yps),\n     {(x, p).\n      p \\<noteq>\n      g_out\n       (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n         ([Any] @ map fst yps))\n       x})\n    \\<in> futures (c_process g_step g_out g_s\\<^sub>0)\n           (c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any]))", "by (rule c_tr_futures)"], ["proof (state)\nthis:\n  (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    ([Any] @ map fst yps),\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> futures (c_process g_step g_out g_s\\<^sub>0)\n         (c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any]))\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any])\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps =\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n   ([Any] @ map fst yps)\n  (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    ([Any] @ map fst yps),\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> futures (c_process g_step g_out g_s\\<^sub>0)\n         (c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any]))", "have \"(?yp @ yps, ?Y')\n    \\<in> futures (c_process g_step g_out g_s\\<^sub>0) (xps @ [(x, p)])\""], ["proof (prove)\nusing this:\n  xps @ [(x, p)] = c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any])\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps =\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n   ([Any] @ map fst yps)\n  (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    ([Any] @ map fst yps),\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> futures (c_process g_step g_out g_s\\<^sub>0)\n         (c_tr g_step g_out g_s\\<^sub>0 (map fst xps @ [Any]))\n\ngoal (1 subgoal):\n 1. (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n      [Any] @\n     yps,\n     {(x, p).\n      p \\<noteq>\n      g_out\n       (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n         ([Any] @ map fst yps))\n       x})\n    \\<in> futures (c_process g_step g_out g_s\\<^sub>0) (xps @ [(x, p)])", "by simp"], ["proof (state)\nthis:\n  (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    [Any] @\n   yps,\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> futures (c_process g_step g_out g_s\\<^sub>0) (xps @ [(x, p)])\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"(xps @ (x, p) # ?yp @ yps, ?Y') \\<in> c_failures g_step g_out g_s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    [Any] @\n   yps,\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> futures (c_process g_step g_out g_s\\<^sub>0) (xps @ [(x, p)])\n\ngoal (1 subgoal):\n 1. (xps @\n     (x, p) #\n     c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n      [Any] @\n     yps,\n     {(x, p).\n      p \\<noteq>\n      g_out\n       (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n         ([Any] @ map fst yps))\n       x})\n    \\<in> c_failures g_step g_out g_s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @\n   (x, p) #\n   c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    [Any] @\n   yps,\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"\\<exists>Y'. (xps @ (x, p) # ?yp @ yps, Y') \\<in> c_failures g_step g_out g_s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @\n   (x, p) #\n   c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n    [Any] @\n   yps,\n   {(x, p).\n    p \\<noteq>\n    g_out\n     (foldl g_step (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       ([Any] @ map fst yps))\n     x})\n  \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<exists>Y'.\n       (xps @\n        (x, p) #\n        c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n         [Any] @\n        yps,\n        Y')\n       \\<in> c_failures g_step g_out g_s\\<^sub>0", ".."], ["proof (state)\nthis:\n  \\<exists>Y'.\n     (xps @\n      (x, p) #\n      c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       [Any] @\n      yps,\n      Y')\n     \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"xps @ (x, p) # ?yp @ yps \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\"\n   (is \"?P (?yp @ yps)\")"], ["proof (prove)\nusing this:\n  \\<exists>Y'.\n     (xps @\n      (x, p) #\n      c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       [Any] @\n      yps,\n      Y')\n     \\<in> c_failures g_step g_out g_s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps @\n    (x, p) #\n    c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps\n    \\<in> traces (c_process g_step g_out g_s\\<^sub>0)", "by (simp add: c_traces)"], ["proof (state)\nthis:\n  xps @\n  (x, p) #\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps\n  \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "moreover"], ["proof (state)\nthis:\n  xps @\n  (x, p) #\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps\n  \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "assume \"yps' = [yp\\<leftarrow>yps. c_dom g_D yp = Low]\""], ["proof (state)\nthis:\n  yps' = filter (\\<lambda>yp. c_dom g_D yp = Low) yps\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "hence \"yps' = [yp\\<leftarrow>?yp @ yps. c_dom g_D yp = Low]\"\n   (is \"?Q (?yp @ yps)\")"], ["proof (prove)\nusing this:\n  yps' = filter (\\<lambda>yp. c_dom g_D yp = Low) yps\n\ngoal (1 subgoal):\n 1. yps' =\n    filter (\\<lambda>yp. c_dom g_D yp = Low)\n     (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       [Any] @\n      yps)", "by (simp add: c_tr_singleton c_dom_def)"], ["proof (state)\nthis:\n  yps' =\n  filter (\\<lambda>yp. c_dom g_D yp = Low)\n   (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "ultimately"], ["proof (chain)\npicking this:\n  xps @\n  (x, p) #\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps\n  \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n  yps' =\n  filter (\\<lambda>yp. c_dom g_D yp = Low)\n   (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps)", "have \"?P (?yp @ yps) \\<and> ?Q (?yp @ yps)\""], ["proof (prove)\nusing this:\n  xps @\n  (x, p) #\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps\n  \\<in> traces (c_process g_step g_out g_s\\<^sub>0)\n  yps' =\n  filter (\\<lambda>yp. c_dom g_D yp = Low)\n   (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps)\n\ngoal (1 subgoal):\n 1. xps @\n    (x, p) #\n    c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps\n    \\<in> traces (c_process g_step g_out g_s\\<^sub>0) \\<and>\n    yps' =\n    filter (\\<lambda>yp. c_dom g_D yp = Low)\n     (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n       [Any] @\n      yps)", ".."], ["proof (state)\nthis:\n  xps @\n  (x, p) #\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps\n  \\<in> traces (c_process g_step g_out g_s\\<^sub>0) \\<and>\n  yps' =\n  filter (\\<lambda>yp. c_dom g_D yp = Low)\n   (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps)\n\ngoal (1 subgoal):\n 1. \\<And>xs a b x ys.\n       \\<lbrakk>xs @ [(a, b)]\n                \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        c_dom g_D (a, b) = High;\n        xs @ ys \\<in> traces (c_process g_step g_out g_s\\<^sub>0);\n        x = filter (\\<lambda>y. c_dom g_D y = Low) ys\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            xs @ (a, b) # ys\n                            \\<in> traces\n                                   (c_process g_step g_out\n                                     g_s\\<^sub>0) \\<and>\n                            x = filter (\\<lambda>y. c_dom g_D y = Low) ys", "thus \"\\<exists>yps. ?P yps \\<and> ?Q yps\""], ["proof (prove)\nusing this:\n  xps @\n  (x, p) #\n  c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any])) [Any] @\n  yps\n  \\<in> traces (c_process g_step g_out g_s\\<^sub>0) \\<and>\n  yps' =\n  filter (\\<lambda>yp. c_dom g_D yp = Low)\n   (c_tr g_step g_out (foldl g_step g_s\\<^sub>0 (map fst xps @ [Any]))\n     [Any] @\n    yps)\n\ngoal (1 subgoal):\n 1. \\<exists>yps.\n       xps @ (x, p) # yps\n       \\<in> traces (c_process g_step g_out g_s\\<^sub>0) \\<and>\n       yps' = filter (\\<lambda>yp. c_dom g_D yp = Low) yps", ".."], ["proof (state)\nthis:\n  \\<exists>yps.\n     xps @ (x, p) # yps\n     \\<in> traces (c_process g_step g_out g_s\\<^sub>0) \\<and>\n     yps' = filter (\\<lambda>yp. c_dom g_D yp = Low) yps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_c_secure_counterexample:\n \"\\<not> c_secure g_step g_out g_s\\<^sub>0 g_I g_D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c_secure g_step g_out g_s\\<^sub>0 g_I g_D", "proof (simp add: c_secure_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x xs.\n       g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n       g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x", "have \"g_out (foldl g_step g_s\\<^sub>0 [Any]) Count = Some Odd\"\n   (is \"?f Count [Any] = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_out (foldl g_step g_s\\<^sub>0 [Any]) Count = Some Odd", "by (simp add: g_s\\<^sub>0_def)"], ["proof (state)\nthis:\n  g_out (foldl g_step g_s\\<^sub>0 [Any]) Count = Some Odd\n\ngoal (1 subgoal):\n 1. \\<exists>x xs.\n       g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n       g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x", "moreover"], ["proof (state)\nthis:\n  g_out (foldl g_step g_s\\<^sub>0 [Any]) Count = Some Odd\n\ngoal (1 subgoal):\n 1. \\<exists>x xs.\n       g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n       g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x", "have\n    \"g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any])) Count =\n    Some Even\"\n   (is \"?g Count [Any] = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n     Count =\n    Some Even", "by (simp add: g_I_def g_s\\<^sub>0_def)"], ["proof (state)\nthis:\n  g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n   Count =\n  Some Even\n\ngoal (1 subgoal):\n 1. \\<exists>x xs.\n       g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n       g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x", "ultimately"], ["proof (chain)\npicking this:\n  g_out (foldl g_step g_s\\<^sub>0 [Any]) Count = Some Odd\n  g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n   Count =\n  Some Even", "have \"?f Count [Any] \\<noteq> ?g Count [Any]\""], ["proof (prove)\nusing this:\n  g_out (foldl g_step g_s\\<^sub>0 [Any]) Count = Some Odd\n  g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n   Count =\n  Some Even\n\ngoal (1 subgoal):\n 1. g_out (foldl g_step g_s\\<^sub>0 [Any]) Count \\<noteq>\n    g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n     Count", "by simp"], ["proof (state)\nthis:\n  g_out (foldl g_step g_s\\<^sub>0 [Any]) Count \\<noteq>\n  g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n   Count\n\ngoal (1 subgoal):\n 1. \\<exists>x xs.\n       g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n       g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x", "thus \"\\<exists>x xs. ?f x xs \\<noteq> ?g x xs\""], ["proof (prove)\nusing this:\n  g_out (foldl g_step g_s\\<^sub>0 [Any]) Count \\<noteq>\n  g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D Count) [Any]))\n   Count\n\ngoal (1 subgoal):\n 1. \\<exists>x xs.\n       g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n       g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x xs.\n     g_out (foldl g_step g_s\\<^sub>0 xs) x \\<noteq>\n     g_out (foldl g_step g_s\\<^sub>0 (c_ipurge g_I g_D (g_D x) xs)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem not_g_secure_implies_c_secure:\n \"\\<not> (g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D) \\<longrightarrow>\n  c_secure g_step g_out g_s\\<^sub>0 g_I g_D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (g_secure (c_process g_step g_out g_s\\<^sub>0)\n             (c_dom g_D) \\<longrightarrow>\n            c_secure g_step g_out g_s\\<^sub>0 g_I g_D)", "proof (simp, rule conjI, rule g_secure_counterexample)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c_secure g_step g_out g_s\\<^sub>0 g_I g_D", "qed (rule not_c_secure_counterexample)"], ["", "theorem not_g_secure_implies_secure:\n \"\\<not> (g_secure (c_process g_step g_out g_s\\<^sub>0) (c_dom g_D) \\<longrightarrow>\n  secure (c_process g_step g_out g_s\\<^sub>0) g_I (c_dom g_D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (g_secure (c_process g_step g_out g_s\\<^sub>0)\n             (c_dom g_D) \\<longrightarrow>\n            secure (c_process g_step g_out g_s\\<^sub>0) g_I (c_dom g_D))", "proof (simp, rule conjI, rule g_secure_counterexample)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> secure (c_process g_step g_out g_s\\<^sub>0) g_I (c_dom g_D)", "qed (rule notI, drule secure_implies_c_secure, erule contrapos_pp,\n rule not_c_secure_counterexample)"], ["", "end"]]}