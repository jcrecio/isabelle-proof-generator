{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_CSP/ClassicalNoninterference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_CSP", "problem_names": ["lemma c_sources_aux_singleton_1: \"c_sources_aux I D {u} xs = c_sources I D u xs\"", "lemma c_ipurge_aux_singleton: \"c_ipurge_aux I D {u} xs = c_ipurge I D u xs\"", "lemma c_sources_aux_singleton_2:\n \"D x \\<in> c_sources_aux I D U [x] = (D x \\<in> U \\<or> (\\<exists>v \\<in> U. (D x, v) \\<in> I))\"", "lemma c_sources_aux_append:\n \"c_sources_aux I D U (xs @ [x]) = (if D x \\<in> c_sources_aux I D U [x]\n    then c_sources_aux I D (insert (D x) U) xs\n    else c_sources_aux I D U xs)\"", "lemma c_ipurge_aux_append:\n \"c_ipurge_aux I D U (xs @ [x]) = (if D x \\<in> c_sources_aux I D U [x]\n    then c_ipurge_aux I D (insert (D x) U) xs @ [x]\n    else c_ipurge_aux I D U xs)\"", "lemma c_sources_ipurge: \"c_sources I D u (c_ipurge I D u xs) = c_sources I D u xs\"", "lemma c_sources_append_1:\n \"c_sources I D (D x) (xs @ [x]) = c_sources I D (D x) xs\"", "lemma c_ipurge_append_1:\n \"c_ipurge I D (D x) (xs @ [x]) = c_ipurge I D (D x) xs @ [x]\"", "lemma c_sources_append_2:\n \"(D x, u) \\<notin> I \\<Longrightarrow> c_sources I D u (xs @ [x]) = c_sources I D u xs\"", "lemma c_ipurge_append_2:\n \"refl I \\<Longrightarrow> (D x, u) \\<notin> I \\<Longrightarrow> c_ipurge I D u (xs @ [x]) = c_ipurge I D u xs\"", "lemma c_sources_mono:\n  assumes A: \"c_sources I D u ys \\<subseteq> c_sources I D u zs\"\n  shows \"c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\"", "lemma c_sources_sinks [rule_format]:\n  \"D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow> sinks I D (D x) (c_ipurge I D u xs) = {}\"", "lemmas c_ipurge_tr_ipurge = c_sources_sinks [THEN sinks_empty]", "lemma c_ipurge_aux_ipurge_tr [rule_format]:\n  assumes R: \"refl I\"\n  shows \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) = c_ipurge_aux I D U (xs @ ys)\"", "lemma c_ipurge_ipurge_tr:\n  assumes R: \"refl I\" and D: \"\\<not> (\\<exists>v \\<in> sinks I D u ys. (v, u') \\<in> I)\"\n  shows \"c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)\"", "lemma c_process_prop_1 [simp]: \"process_prop_1 (c_failures step out s\\<^sub>0, {})\"", "lemma c_process_prop_2 [simp]: \"process_prop_2 (c_failures step out s\\<^sub>0, {})\"", "lemma c_process_prop_3 [simp]: \"process_prop_3 (c_failures step out s\\<^sub>0, {})\"", "lemma c_process_prop_4 [simp]: \"process_prop_4 (c_failures step out s\\<^sub>0, {})\"", "lemma c_process_prop_5 [simp]: \"process_prop_5 (F, {})\"", "lemma c_process_prop_6 [simp]: \"process_prop_6 (F, {})\"", "theorem c_process_process: \"(c_failures step out s\\<^sub>0, {}) \\<in> process_set\"", "lemma c_failures_last [rule_format]:\n \"(xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow> xps \\<noteq> [] \\<longrightarrow>\n  snd (last xps) = out (foldl step s\\<^sub>0 (butlast (map fst xps))) (last (map fst xps))\"", "lemma c_failures_ref:\n \"(xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n  X \\<subseteq> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\"", "lemma c_failures_failures: \"failures (c_process step out s\\<^sub>0) = c_failures step out s\\<^sub>0\"", "lemma c_futures_failures:\n \"(yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps =\n  ((xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0)\"", "lemma c_traces:\n \"xps \\<in> traces (c_process step out s\\<^sub>0) = (\\<exists>X. (xps, X) \\<in> c_failures step out s\\<^sub>0)\"", "lemma c_refusals:\n \"X \\<in> refusals (c_process step out s\\<^sub>0) xps = ((xps, X) \\<in> c_failures step out s\\<^sub>0)\"", "lemma c_next_events:\n \"xp \\<in> next_events (c_process step out s\\<^sub>0) xps =\n  (\\<exists>X. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0)\"", "lemma c_traces_failures:\n \"xps \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}) \\<in> c_failures step out s\\<^sub>0\"", "theorem c_process_deterministic: \"deterministic (c_process step out s\\<^sub>0)\"", "lemma c_tr_length: \"length (c_tr step out s xs) = length xs\"", "lemma c_tr_map: \"map fst (c_tr step out s xs) = xs\"", "lemma c_tr_singleton: \"c_tr step out s [x] = [(x, out s x)]\"", "lemma c_tr_append:\n \"c_tr step out s (xs @ ys) = c_tr step out s xs @ c_tr step out (foldl step s xs) ys\"", "lemma c_tr_hd_tl:\n  assumes A: \"xs \\<noteq> []\"\n  shows \"c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)\"", "lemma c_failures_tr:\n \"(xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow> xps = c_tr step out s\\<^sub>0 (map fst xps)\"", "lemma c_futures_tr:\n  assumes A: \"(yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\"\n  shows \"yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\"", "lemma c_tr_failures:\n \"(c_tr step out s\\<^sub>0 xs, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n  \\<in> c_failures step out s\\<^sub>0\"", "lemma c_tr_futures:\n \"(c_tr step out (foldl step s\\<^sub>0 xs) ys,\n  {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\"", "lemma c_dom_sources:\n \"c_sources I (c_dom D) u xps = c_sources I D u (map fst xps)\"", "lemma c_dom_sinks: \"sinks I (c_dom D) u xps = sinks I D u (map fst xps)\"", "lemma c_tr_sources:\n \"c_sources I (c_dom D) u (c_tr step out s xs) = c_sources I D u xs\"", "lemma c_tr_sinks: \"sinks I (c_dom D) u (c_tr step out s xs) = sinks I D u xs\"", "lemma c_tr_ipurge:\n \"c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n  c_tr step out s (c_ipurge I D u xs)\"", "lemma c_tr_ipurge_tr_1 [rule_format]:\n \"(\\<forall>n \\<in> {..<length xs}. D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) = c_tr step out s (ipurge_tr I D u xs)\"", "lemma c_tr_ipurge_tr_2 [rule_format]:\n  assumes A: \"\\<forall>n \\<in> {..length ys}. \\<exists>Y.\n    (ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\"\n  shows \"n \\<in> {..<length ys} \\<longrightarrow> D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))) (ys ! n) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)\"", "lemma c_tr_ipurge_tr [rule_format]:\n  assumes A: \"\\<forall>n \\<in> {..length ys}. \\<exists>Y.\n    (ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\"\n  shows \"ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) ys) =\n    c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u ys)\"", "lemma secure_implies_c_secure_aux:\n  assumes S: \"secure (c_process step out s\\<^sub>0) I (c_dom D)\"\n  shows \"out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys)) x\"", "theorem secure_implies_c_secure:\n  assumes S: \"secure (c_process step out s\\<^sub>0) I (c_dom D)\"\n  shows \"c_secure step out s\\<^sub>0 I D\"", "lemma c_secure_futures_1:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"(yps @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\"", "lemma c_secure_implies_secure_aux_1 [rule_format]:\n  assumes\n    R: \"refl I\" and\n    S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"(yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n    ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\"", "lemma c_secure_futures_2:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"(yps @ [yp], A) \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps @ [yp], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\"", "lemma c_secure_ipurge_tr:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"ipurge_tr I (c_dom D) (D x) (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n    = ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\"", "lemma c_secure_implies_secure_aux_2 [rule_format]:\n  assumes\n    R: \"refl I\" and\n    S: \"c_secure step out s\\<^sub>0 I D\" and\n    Y: \"(yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\"\n  shows \"(zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n    ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\"", "theorem c_secure_implies_secure:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"secure (c_process step out s\\<^sub>0) I (c_dom D)\"", "theorem secure_equals_c_secure:\n \"refl I \\<Longrightarrow> secure (c_process step out s\\<^sub>0) I (c_dom D) = c_secure step out s\\<^sub>0 I D\""], "translations": [["", "lemma c_sources_aux_singleton_1: \"c_sources_aux I D {u} xs = c_sources I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources_aux I D {u} xs = c_sources I D u xs", "by (induction xs, simp_all)"], ["", "lemma c_ipurge_aux_singleton: \"c_ipurge_aux I D {u} xs = c_ipurge I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge_aux I D {u} xs = c_ipurge I D u xs", "by (induction xs, simp_all add: c_sources_aux_singleton_1)"], ["", "lemma c_sources_aux_singleton_2:\n \"D x \\<in> c_sources_aux I D U [x] = (D x \\<in> U \\<or> (\\<exists>v \\<in> U. (D x, v) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D x \\<in> c_sources_aux I D U [x]) =\n    (D x \\<in> U \\<or> (\\<exists>v\\<in>U. (D x, v) \\<in> I))", "by simp"], ["", "lemma c_sources_aux_append:\n \"c_sources_aux I D U (xs @ [x]) = (if D x \\<in> c_sources_aux I D U [x]\n    then c_sources_aux I D (insert (D x) U) xs\n    else c_sources_aux I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources_aux I D U (xs @ [x]) =\n    (if D x \\<in> c_sources_aux I D U [x]\n     then c_sources_aux I D (insert (D x) U) xs else c_sources_aux I D U xs)", "by (induction xs, simp_all add: insert_absorb)"], ["", "lemma c_ipurge_aux_append:\n \"c_ipurge_aux I D U (xs @ [x]) = (if D x \\<in> c_sources_aux I D U [x]\n    then c_ipurge_aux I D (insert (D x) U) xs @ [x]\n    else c_ipurge_aux I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ [x]) =\n    (if D x \\<in> c_sources_aux I D U [x]\n     then c_ipurge_aux I D (insert (D x) U) xs @ [x]\n     else c_ipurge_aux I D U xs)", "by (induction xs, simp_all add: c_sources_aux_append)"], ["", "text \\<open>\n\\null\n\nIn what follows, a few useful lemmas are proven about functions \\<open>c_sources\\<close>, \\<open>c_ipurge\\<close>\nand their relationships with functions \\<open>sinks\\<close>, \\<open>ipurge_tr\\<close>.\n\n\\null\n\\<close>"], ["", "lemma c_sources_ipurge: \"c_sources I D u (c_ipurge I D u xs) = c_sources I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D u (c_ipurge I D u xs) = c_sources I D u xs", "by (induction xs, simp_all)"], ["", "lemma c_sources_append_1:\n \"c_sources I D (D x) (xs @ [x]) = c_sources I D (D x) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D (D x) (xs @ [x]) = c_sources I D (D x) xs", "by (induction xs, simp_all)"], ["", "lemma c_ipurge_append_1:\n \"c_ipurge I D (D x) (xs @ [x]) = c_ipurge I D (D x) xs @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I D (D x) (xs @ [x]) = c_ipurge I D (D x) xs @ [x]", "by (induction xs, simp_all add: c_sources_append_1)"], ["", "lemma c_sources_append_2:\n \"(D x, u) \\<notin> I \\<Longrightarrow> c_sources I D u (xs @ [x]) = c_sources I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D x, u) \\<notin> I \\<Longrightarrow>\n    c_sources I D u (xs @ [x]) = c_sources I D u xs", "by (induction xs, simp_all)"], ["", "lemma c_ipurge_append_2:\n \"refl I \\<Longrightarrow> (D x, u) \\<notin> I \\<Longrightarrow> c_ipurge I D u (xs @ [x]) = c_ipurge I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refl I; (D x, u) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> c_ipurge I D u (xs @ [x]) = c_ipurge I D u xs", "proof (induction xs, simp_all add: refl_on_def c_sources_append_2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. (x, x) \\<in> I; (D x, u) \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> D x \\<noteq> u", "qed (rule notI, simp)"], ["", "lemma c_sources_mono:\n  assumes A: \"c_sources I D u ys \\<subseteq> c_sources I D u zs\"\n  shows \"c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "proof (cases \"\\<exists>v \\<in> c_sources I D u ys. (D x, v) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "assume B: \"\\<exists>v \\<in> c_sources I D u ys. (D x, v) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I", "obtain v where C: \"v \\<in> c_sources I D u ys\" and D: \"(D x, v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> c_sources I D u ys; (D x, v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> c_sources I D u ys\n  (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "from A and C"], ["proof (chain)\npicking this:\n  c_sources I D u ys \\<subseteq> c_sources I D u zs\n  v \\<in> c_sources I D u ys", "have \"v \\<in> c_sources I D u zs\""], ["proof (prove)\nusing this:\n  c_sources I D u ys \\<subseteq> c_sources I D u zs\n  v \\<in> c_sources I D u ys\n\ngoal (1 subgoal):\n 1. v \\<in> c_sources I D u zs", ".."], ["proof (state)\nthis:\n  v \\<in> c_sources I D u zs\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "with D"], ["proof (chain)\npicking this:\n  (D x, v) \\<in> I\n  v \\<in> c_sources I D u zs", "have E: \"\\<exists>v \\<in> c_sources I D u zs. (D x, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (D x, v) \\<in> I\n  v \\<in> c_sources I D u zs\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>c_sources I D u zs. (D x, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>c_sources I D u zs. (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "have \"insert (D x) (c_sources I D u ys) \\<subseteq> insert (D x) (c_sources I D u zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D x) (c_sources I D u ys)\n    \\<subseteq> insert (D x) (c_sources I D u zs)", "using A"], ["proof (prove)\nusing this:\n  c_sources I D u ys \\<subseteq> c_sources I D u zs\n\ngoal (1 subgoal):\n 1. insert (D x) (c_sources I D u ys)\n    \\<subseteq> insert (D x) (c_sources I D u zs)", "by (rule insert_mono)"], ["proof (state)\nthis:\n  insert (D x) (c_sources I D u ys)\n  \\<subseteq> insert (D x) (c_sources I D u zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "moreover"], ["proof (state)\nthis:\n  insert (D x) (c_sources I D u ys)\n  \\<subseteq> insert (D x) (c_sources I D u zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "have \"c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)", "using B"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)", "by simp"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "moreover"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "have \"c_sources I D u (x # zs) = insert (D x) (c_sources I D u zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D u (x # zs) = insert (D x) (c_sources I D u zs)", "using E"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>c_sources I D u zs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # zs) = insert (D x) (c_sources I D u zs)", "by simp"], ["proof (state)\nthis:\n  c_sources I D u (x # zs) = insert (D x) (c_sources I D u zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n 2. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "ultimately"], ["proof (chain)\npicking this:\n  insert (D x) (c_sources I D u ys)\n  \\<subseteq> insert (D x) (c_sources I D u zs)\n  c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)\n  c_sources I D u (x # zs) = insert (D x) (c_sources I D u zs)", "show \"c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\""], ["proof (prove)\nusing this:\n  insert (D x) (c_sources I D u ys)\n  \\<subseteq> insert (D x) (c_sources I D u zs)\n  c_sources I D u (x # ys) = insert (D x) (c_sources I D u ys)\n  c_sources I D u (x # zs) = insert (D x) (c_sources I D u zs)\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "by simp"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "assume \"\\<not> (\\<exists>v \\<in> c_sources I D u ys. (D x, v) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "hence \"c_sources I D u (x # ys) = c_sources I D u ys\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>c_sources I D u ys. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) = c_sources I D u ys", "by simp"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) = c_sources I D u ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "hence \"c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs\""], ["proof (prove)\nusing this:\n  c_sources I D u (x # ys) = c_sources I D u ys\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs", "using A"], ["proof (prove)\nusing this:\n  c_sources I D u (x # ys) = c_sources I D u ys\n  c_sources I D u ys \\<subseteq> c_sources I D u zs\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs", "by simp"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "moreover"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "have \"c_sources I D u zs \\<subseteq> c_sources I D u (x # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D u zs \\<subseteq> c_sources I D u (x # zs)", "by (simp add: subset_insertI)"], ["proof (state)\nthis:\n  c_sources I D u zs \\<subseteq> c_sources I D u (x # zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>c_sources I D u ys.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "ultimately"], ["proof (chain)\npicking this:\n  c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs\n  c_sources I D u zs \\<subseteq> c_sources I D u (x # zs)", "show \"c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\""], ["proof (prove)\nusing this:\n  c_sources I D u (x # ys) \\<subseteq> c_sources I D u zs\n  c_sources I D u zs \\<subseteq> c_sources I D u (x # zs)\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)", "by simp"], ["proof (state)\nthis:\n  c_sources I D u (x # ys) \\<subseteq> c_sources I D u (x # zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_sources_sinks [rule_format]:\n  \"D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow> sinks I D (D x) (c_ipurge I D u xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}", "proof (induction xs, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "fix x' xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "assume A: \"D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}\""], ["proof (state)\nthis:\n  D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "assume B: \"D x \\<notin> c_sources I D u (x # x' # xs)\""], ["proof (state)\nthis:\n  D x \\<notin> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "have \"c_sources I D u xs \\<subseteq> c_sources I D u (x' # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D u xs \\<subseteq> c_sources I D u (x' # xs)", "by (simp add: subset_insertI)"], ["proof (state)\nthis:\n  c_sources I D u xs \\<subseteq> c_sources I D u (x' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "hence \"c_sources I D u (x # xs) \\<subseteq> c_sources I D u (x # x' # xs)\""], ["proof (prove)\nusing this:\n  c_sources I D u xs \\<subseteq> c_sources I D u (x' # xs)\n\ngoal (1 subgoal):\n 1. c_sources I D u (x # xs) \\<subseteq> c_sources I D u (x # x' # xs)", "by (rule c_sources_mono)"], ["proof (state)\nthis:\n  c_sources I D u (x # xs) \\<subseteq> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "hence \"D x \\<notin> c_sources I D u (x # xs)\""], ["proof (prove)\nusing this:\n  c_sources I D u (x # xs) \\<subseteq> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. D x \\<notin> c_sources I D u (x # xs)", "using B"], ["proof (prove)\nusing this:\n  c_sources I D u (x # xs) \\<subseteq> c_sources I D u (x # x' # xs)\n  D x \\<notin> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. D x \\<notin> c_sources I D u (x # xs)", "by (rule contra_subsetD)"], ["proof (state)\nthis:\n  D x \\<notin> c_sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "with A"], ["proof (chain)\npicking this:\n  D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n  D x \\<notin> c_sources I D u (x # xs)", "have C: \"sinks I D (D x) (c_ipurge I D u xs) = {}\""], ["proof (prove)\nusing this:\n  D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n  D x \\<notin> c_sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. sinks I D (D x) (c_ipurge I D u xs) = {}", ".."], ["proof (state)\nthis:\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>D x \\<notin> c_sources I D u (x # xs) \\<longrightarrow>\n                sinks I D (D x) (c_ipurge I D u xs) = {};\n        D x \\<notin> c_sources I D u (x # a # xs)\\<rbrakk>\n       \\<Longrightarrow> sinks I D (D x) (c_ipurge I D u (a # xs)) = {}", "show \"sinks I D (D x) (c_ipurge I D u (x' # xs)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I D (D x) (c_ipurge I D u (x' # xs)) = {}", "proof (cases \"D x' \\<in> c_sources I D u (x' # xs)\",\n   simp_all only: c_ipurge.simps if_True if_False)"], ["proof (state)\ngoal (2 subgoals):\n 1. D x' \\<in> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (x' # c_ipurge I D u xs) = {}\n 2. D x' \\<notin> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}", "assume D: \"D x' \\<in> c_sources I D u (x' # xs)\""], ["proof (state)\nthis:\n  D x' \\<in> c_sources I D u (x' # xs)\n\ngoal (2 subgoals):\n 1. D x' \\<in> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (x' # c_ipurge I D u xs) = {}\n 2. D x' \\<notin> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}", "have \"(D x, D x') \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D x, D x') \\<notin> I", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False", "assume \"(D x, D x') \\<in> I\""], ["proof (state)\nthis:\n  (D x, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False", "hence \"\\<exists>v \\<in> c_sources I D u (x' # xs). (D x, v) \\<in> I\""], ["proof (prove)\nusing this:\n  (D x, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>c_sources I D u (x' # xs). (D x, v) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  (D x, D x') \\<in> I\n  D x' \\<in> c_sources I D u (x' # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>c_sources I D u (x' # xs). (D x, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>c_sources I D u (x' # xs). (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False", "hence \"D x \\<in> c_sources I D u (x # x' # xs)\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>c_sources I D u (x' # xs). (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. D x \\<in> c_sources I D u (x # x' # xs)", "by simp"], ["proof (state)\nthis:\n  D x \\<in> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. (D x, D x') \\<in> I \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  D x \\<in> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. False", "using B"], ["proof (prove)\nusing this:\n  D x \\<in> c_sources I D u (x # x' # xs)\n  D x \\<notin> c_sources I D u (x # x' # xs)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (D x, D x') \\<notin> I\n\ngoal (2 subgoals):\n 1. D x' \\<in> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (x' # c_ipurge I D u xs) = {}\n 2. D x' \\<notin> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}", "thus \"sinks I D (D x) (x' # c_ipurge I D u xs) = {}\""], ["proof (prove)\nusing this:\n  (D x, D x') \\<notin> I\n\ngoal (1 subgoal):\n 1. sinks I D (D x) (x' # c_ipurge I D u xs) = {}", "using C"], ["proof (prove)\nusing this:\n  (D x, D x') \\<notin> I\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n\ngoal (1 subgoal):\n 1. sinks I D (D x) (x' # c_ipurge I D u xs) = {}", "by (simp add: sinks_cons_nonint)"], ["proof (state)\nthis:\n  sinks I D (D x) (x' # c_ipurge I D u xs) = {}\n\ngoal (1 subgoal):\n 1. D x' \\<notin> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D x' \\<notin> c_sources I D u (x' # xs) \\<Longrightarrow>\n    sinks I D (D x) (c_ipurge I D u xs) = {}", "show \"sinks I D (D x) (c_ipurge I D u xs) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I D (D x) (c_ipurge I D u xs) = {}", "using C"], ["proof (prove)\nusing this:\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n\ngoal (1 subgoal):\n 1. sinks I D (D x) (c_ipurge I D u xs) = {}", "."], ["proof (state)\nthis:\n  sinks I D (D x) (c_ipurge I D u xs) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks I D (D x) (c_ipurge I D u (x' # xs)) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas c_ipurge_tr_ipurge = c_sources_sinks [THEN sinks_empty]"], ["", "lemma c_ipurge_aux_ipurge_tr [rule_format]:\n  assumes R: \"refl I\"\n  shows \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) = c_ipurge_aux I D U (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "proof (induction ys arbitrary: U rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>sinks I D u xsa.\n                              \\<exists>w\\<in>U.\n                                 (v, w) \\<in> I) \\<longrightarrow>\n                   c_ipurge_aux I D U (xs @ ipurge_tr I D u xsa) =\n                   c_ipurge_aux I D U (xs @ xsa);\n        \\<not> (\\<exists>v\\<in>sinks I D u (xsa @ [x]).\n                   \\<exists>w\\<in>U. (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> c_ipurge_aux I D U\n                          (xs @ ipurge_tr I D u (xsa @ [x])) =\n                         c_ipurge_aux I D U (xs @ xsa @ [x])", "fix y ys U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>sinks I D u xsa.\n                              \\<exists>w\\<in>U.\n                                 (v, w) \\<in> I) \\<longrightarrow>\n                   c_ipurge_aux I D U (xs @ ipurge_tr I D u xsa) =\n                   c_ipurge_aux I D U (xs @ xsa);\n        \\<not> (\\<exists>v\\<in>sinks I D u (xsa @ [x]).\n                   \\<exists>w\\<in>U. (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> c_ipurge_aux I D U\n                          (xs @ ipurge_tr I D u (xsa @ [x])) =\n                         c_ipurge_aux I D U (xs @ xsa @ [x])", "assume\n    A: \"\\<And>U. \\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I) \\<longrightarrow>\n      c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n      c_ipurge_aux I D U (xs @ ys)\" and\n    B: \"\\<not> (\\<exists>v \\<in> sinks I D u (ys @ [y]). \\<exists>w \\<in> U. (v, w) \\<in> I)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>?U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D ?U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D ?U (xs @ ys)\n  \\<not> (\\<exists>v\\<in>sinks I D u (ys @ [y]).\n             \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>sinks I D u xsa.\n                              \\<exists>w\\<in>U.\n                                 (v, w) \\<in> I) \\<longrightarrow>\n                   c_ipurge_aux I D U (xs @ ipurge_tr I D u xsa) =\n                   c_ipurge_aux I D U (xs @ xsa);\n        \\<not> (\\<exists>v\\<in>sinks I D u (xsa @ [x]).\n                   \\<exists>w\\<in>U. (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> c_ipurge_aux I D U\n                          (xs @ ipurge_tr I D u (xsa @ [x])) =\n                         c_ipurge_aux I D U (xs @ xsa @ [x])", "have C: \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I)", "proof (rule notI, (erule bexE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(v, w) \\<in> I\" and \"w \\<in> U\""], ["proof (state)\nthis:\n  (v, w) \\<in> I\n  w \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> I\n  w \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>U. (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"v \\<in> sinks I D u ys\""], ["proof (state)\nthis:\n  v \\<in> sinks I D u ys\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"v \\<in> sinks I D u (ys @ [y])\""], ["proof (prove)\nusing this:\n  v \\<in> sinks I D u ys\n\ngoal (1 subgoal):\n 1. v \\<in> sinks I D u (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  v \\<in> sinks I D u (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n  v \\<in> sinks I D u (ys @ [y])", "have \"\\<exists>v \\<in> sinks I D u (ys @ [y]). \\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n  v \\<in> sinks I D u (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; w \\<in> U; (v, w) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using B"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks I D u (ys @ [y]).\n             \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   \\<not> (\\<exists>v\\<in>sinks I D u xsa.\n                              \\<exists>w\\<in>U.\n                                 (v, w) \\<in> I) \\<longrightarrow>\n                   c_ipurge_aux I D U (xs @ ipurge_tr I D u xsa) =\n                   c_ipurge_aux I D U (xs @ xsa);\n        \\<not> (\\<exists>v\\<in>sinks I D u (xsa @ [x]).\n                   \\<exists>w\\<in>U. (v, w) \\<in> I)\\<rbrakk>\n       \\<Longrightarrow> c_ipurge_aux I D U\n                          (xs @ ipurge_tr I D u (xsa @ [x])) =\n                         c_ipurge_aux I D U (xs @ xsa @ [x])", "show \"c_ipurge_aux I D U (xs @ ipurge_tr I D u (ys @ [y])) =\n    c_ipurge_aux I D U (xs @ ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u (ys @ [y])) =\n    c_ipurge_aux I D U (xs @ ys @ [y])", "proof (cases \"D y \\<in> c_sources_aux I D U [y]\",\n   case_tac [!] \"D y \\<in> sinks I D u (ys @ [y])\",\n   simp_all (no_asm_simp) only: ipurge_tr.simps append_assoc [symmetric]\n   c_ipurge_aux_append append_same_eq if_True if_False)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "assume D: \"D y \\<in> sinks I D u (ys @ [y])\""], ["proof (state)\nthis:\n  D y \\<in> sinks I D u (ys @ [y])\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "assume \"D y \\<in> c_sources_aux I D U [y]\""], ["proof (state)\nthis:\n  D y \\<in> c_sources_aux I D U [y]\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "hence \"D y \\<in> U \\<or> (\\<exists>w \\<in> U. (D y, w) \\<in> I)\""], ["proof (prove)\nusing this:\n  D y \\<in> c_sources_aux I D U [y]\n\ngoal (1 subgoal):\n 1. D y \\<in> U \\<or> (\\<exists>w\\<in>U. (D y, w) \\<in> I)", "by (simp only: c_sources_aux_singleton_2)"], ["proof (state)\nthis:\n  D y \\<in> U \\<or> (\\<exists>w\\<in>U. (D y, w) \\<in> I)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "moreover"], ["proof (state)\nthis:\n  D y \\<in> U \\<or> (\\<exists>w\\<in>U. (D y, w) \\<in> I)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "{"], ["proof (state)\nthis:\n  D y \\<in> U \\<or> (\\<exists>w\\<in>U. (D y, w) \\<in> I)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "have \"(D y, D y) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D y, D y) \\<in> I", "using R"], ["proof (prove)\nusing this:\n  refl I\n\ngoal (1 subgoal):\n 1. (D y, D y) \\<in> I", "by (simp add: refl_on_def)"], ["proof (state)\nthis:\n  (D y, D y) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "moreover"], ["proof (state)\nthis:\n  (D y, D y) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "assume \"D y \\<in> U\""], ["proof (state)\nthis:\n  D y \\<in> U\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "ultimately"], ["proof (chain)\npicking this:\n  (D y, D y) \\<in> I\n  D y \\<in> U", "have \"\\<exists>w \\<in> U. (D y, w) \\<in> I\""], ["proof (prove)\nusing this:\n  (D y, D y) \\<in> I\n  D y \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>U. (D y, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "hence \"\\<exists>v \\<in> sinks I D u (ys @ [y]). \\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I\n  D y \\<in> sinks I D u (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "}"], ["proof (state)\nthis:\n  D y \\<in> U \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "moreover"], ["proof (state)\nthis:\n  D y \\<in> U \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "{"], ["proof (state)\nthis:\n  D y \\<in> U \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "assume \"\\<exists>w \\<in> U. (D y, w) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "hence \"\\<exists>v \\<in> sinks I D u (ys @ [y]). \\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I\n  D y \\<in> sinks I D u (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "}"], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (D y, w) \\<in> I \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "ultimately"], ["proof (chain)\npicking this:\n  D y \\<in> U \\<or> (\\<exists>w\\<in>U. (D y, w) \\<in> I)\n  D y \\<in> U \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n  \\<exists>w\\<in>U. (D y, w) \\<in> I \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", "have \"\\<exists>v \\<in> sinks I D u (ys @ [y]). \\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  D y \\<in> U \\<or> (\\<exists>w\\<in>U. (D y, w) \\<in> I)\n  D y \\<in> U \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n  \\<exists>w\\<in>U. (D y, w) \\<in> I \\<Longrightarrow>\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I", "by blast"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (4 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n 2. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 4. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "thus \"c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n      c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]", "using B"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u (ys @ [y]). \\<exists>w\\<in>U. (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks I D u (ys @ [y]).\n             \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]", "by contradiction"], ["proof (state)\nthis:\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D (insert (D y) U) (xs @ ys) @ [y]\n\ngoal (3 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "assume D: \"D y \\<notin> sinks I D u (ys @ [y])\""], ["proof (state)\nthis:\n  D y \\<notin> sinks I D u (ys @ [y])\n\ngoal (3 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "have \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> insert (D y) U. (v, w) \\<in> I) \\<longrightarrow>\n      c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>insert (D y) U.\n                  (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D (insert (D y) U) (xs @ ys)", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>?U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D ?U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D ?U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>insert (D y) U.\n                  (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D (insert (D y) U) (xs @ ys)", "."], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U.\n                (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U.\n                (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "have \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> insert (D y) U. (v, w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>insert (D y) U. (v, w) \\<in> I)", "proof (rule notI, (erule bexE)+, simp, erule disjE, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, D y) \\<in> I; w = D y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, D y) \\<in> I; w = D y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(v, D y) \\<in> I\" and \"v \\<in> sinks I D u ys\""], ["proof (state)\nthis:\n  (v, D y) \\<in> I\n  v \\<in> sinks I D u ys\n\ngoal (2 subgoals):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, D y) \\<in> I; w = D y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>v \\<in> sinks I D u ys. (v, D y) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D y) \\<in> I\n  v \\<in> sinks I D u ys\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u ys. (v, D y) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u ys. (v, D y) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, D y) \\<in> I; w = D y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"D y \\<in> sinks I D u (ys @ [y])\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u ys. (v, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. D y \\<in> sinks I D u (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  D y \\<in> sinks I D u (ys @ [y])\n\ngoal (2 subgoals):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, D y) \\<in> I; w = D y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D u (ys @ [y])\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D u (ys @ [y])\n  D y \\<notin> sinks I D u (ys @ [y])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "fix v w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(v, w) \\<in> I\" and \"w \\<in> U\""], ["proof (state)\nthis:\n  (v, w) \\<in> I\n  w \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> I\n  w \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>U. (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"v \\<in> sinks I D u ys\""], ["proof (state)\nthis:\n  v \\<in> sinks I D u ys\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n  v \\<in> sinks I D u ys", "have \"\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>U. (v, w) \\<in> I\n  v \\<in> sinks I D u ys\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v w.\n       \\<lbrakk>v \\<in> sinks I D u ys; (v, w) \\<in> I; w \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U. (v, w) \\<in> I)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>D y \\<in> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D (insert (D y) U)\n                       (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 3. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U.\n                (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U. (v, w) \\<in> I)", "show \"c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys)\n      = c_ipurge_aux I D (insert (D y) U) (xs @ ys)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U.\n                (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>insert (D y) U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D (insert (D y) U) (xs @ ys)", ".."], ["proof (state)\nthis:\n  c_ipurge_aux I D (insert (D y) U) (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D (insert (D y) U) (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "have \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I) \\<longrightarrow>\n      c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) = c_ipurge_aux I D U (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>?U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D ?U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D ?U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "."], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<in> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)\n 2. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "thus \"c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n      c_ipurge_aux I D U (xs @ ys)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "using C"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n  \\<not> (\\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", ".."], ["proof (state)\nthis:\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "have \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> U. (v, w) \\<in> I) \\<longrightarrow>\n      c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) = c_ipurge_aux I D U (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>?U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D ?U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D ?U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n    c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "."], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D y \\<notin> c_sources_aux I D U [y];\n     D y \\<notin> sinks I D u (ys @ [y])\\<rbrakk>\n    \\<Longrightarrow> c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n                      c_ipurge_aux I D U (xs @ ys)", "thus \"c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n      c_ipurge_aux I D U (xs @ ys)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", "using C"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>U. (v, w) \\<in> I) \\<longrightarrow>\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n  \\<not> (\\<exists>v\\<in>sinks I D u ys. \\<exists>w\\<in>U. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D U (xs @ ys)", ".."], ["proof (state)\nthis:\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D U (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c_ipurge_aux I D U (xs @ ipurge_tr I D u (ys @ [y])) =\n  c_ipurge_aux I D U (xs @ ys @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_ipurge_ipurge_tr:\n  assumes R: \"refl I\" and D: \"\\<not> (\\<exists>v \\<in> sinks I D u ys. (v, u') \\<in> I)\"\n  shows \"c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)", "have \"\\<not> (\\<exists>v \\<in> sinks I D u ys. \\<exists>w \\<in> {u'}. (v, w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>{u'}. (v, w) \\<in> I)", "using D"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys. (v, u') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D u ys.\n               \\<exists>w\\<in>{u'}. (v, w) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>{u'}. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)", "with R"], ["proof (chain)\npicking this:\n  refl I\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>{u'}. (v, w) \\<in> I)", "have \"c_ipurge_aux I D {u'} (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D {u'} (xs @ ys)\""], ["proof (prove)\nusing this:\n  refl I\n  \\<not> (\\<exists>v\\<in>sinks I D u ys.\n             \\<exists>w\\<in>{u'}. (v, w) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge_aux I D {u'} (xs @ ipurge_tr I D u ys) =\n    c_ipurge_aux I D {u'} (xs @ ys)", "by (rule c_ipurge_aux_ipurge_tr)"], ["proof (state)\nthis:\n  c_ipurge_aux I D {u'} (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D {u'} (xs @ ys)\n\ngoal (1 subgoal):\n 1. c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c_ipurge_aux I D {u'} (xs @ ipurge_tr I D u ys) =\n  c_ipurge_aux I D {u'} (xs @ ys)\n\ngoal (1 subgoal):\n 1. c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)", "by (simp add: c_ipurge_aux_singleton)"], ["proof (state)\nthis:\n  c_ipurge I D u' (xs @ ipurge_tr I D u ys) = c_ipurge I D u' (xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Classical processes\""], ["", "text \\<open>\nThe deterministic state machines used as model of computation in the classical theory of\nnoninterference security, as expounded in \\cite{R3}, have the property that each action produces an\noutput. Hence, it is natural to take as alphabet of a classical process the universe of the pairs\n\\<open>(x, p)\\<close>, where \\<open>x\\<close> is an action and \\<open>p\\<close> an output. For any state \\<open>s\\<close>,\nsuch an event \\<open>(x, p)\\<close> may occur just in case \\<open>p\\<close> matches the output produced by\n\\<open>x\\<close> in \\<open>s\\<close>.\n\nTherefore, a trace of a classical process can be defined as an event list \\<open>xps\\<close> such that for\neach item \\<open>(x, p)\\<close>, \\<open>p\\<close> is equal to the output produced by \\<open>x\\<close> in the state\nresulting from the previous actions in \\<open>xps\\<close>. Furthermore, for each trace \\<open>xps\\<close>, the\nrefusals set associated to \\<open>xps\\<close> is comprised of any set of pairs \\<open>(x, p)\\<close> such that\n\\<open>p\\<close> is different from the output produced by \\<open>x\\<close> in the state resulting from the actions\nin \\<open>xps\\<close>.\n\nIn accordance with the previous considerations, an inductive definition is formulated here below for\nthe failures set \\<open>c_failures step out s\\<^sub>0\\<close> corresponding to the deterministic state machine\nwith state transition function \\<open>step\\<close>, output function \\<open>out\\<close>, and initial state\n\\<open>s\\<^sub>0\\<close>. Then, the classical process \\<open>c_process step out s\\<^sub>0\\<close> representing this machine is\ndefined as the process having \\<open>c_failures step out s\\<^sub>0\\<close> as failures set and the empty set as\ndivergences set.\n\n\\null\n\\<close>"], ["", "inductive_set c_failures ::\n \"('s \\<Rightarrow> 'a \\<Rightarrow> 's) \\<Rightarrow> ('s \\<Rightarrow> 'a \\<Rightarrow> 'o) \\<Rightarrow> 's \\<Rightarrow> ('a \\<times> 'o) failure set\"\nfor step :: \"'s \\<Rightarrow> 'a \\<Rightarrow> 's\" and out :: \"'s \\<Rightarrow> 'a \\<Rightarrow> 'o\" and s\\<^sub>0 :: 's where\nR0: \"([], {(x, p). p \\<noteq> out s\\<^sub>0 x}) \\<in> c_failures step out s\\<^sub>0\" |\nR1: \"\\<lbrakk>(xps, _) \\<in> c_failures step out s\\<^sub>0; s = foldl step s\\<^sub>0 (map fst xps)\\<rbrakk> \\<Longrightarrow>\n     (xps @ [(x, out s x)], {(y, p). p \\<noteq> out (step s x) y}) \\<in> c_failures step out s\\<^sub>0\" |\nR2: \"\\<lbrakk>(xps, Y) \\<in> c_failures step out s\\<^sub>0; X \\<subseteq> Y\\<rbrakk> \\<Longrightarrow>\n     (xps, X) \\<in> c_failures step out s\\<^sub>0\""], ["", "definition c_process ::\n \"('s \\<Rightarrow> 'a \\<Rightarrow> 's) \\<Rightarrow> ('s \\<Rightarrow> 'a \\<Rightarrow> 'o) \\<Rightarrow> 's \\<Rightarrow> ('a \\<times> 'o) process\" where\n\"c_process step out s\\<^sub>0 \\<equiv> Abs_process (c_failures step out s\\<^sub>0, {})\""], ["", "text \\<open>\n\\null\n\nIn what follows, the fact that classical processes are indeed processes is proven as a theorem.\n\n\\null\n\\<close>"], ["", "lemma c_process_prop_1 [simp]: \"process_prop_1 (c_failures step out s\\<^sub>0, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_1 (c_failures step out s\\<^sub>0, {})", "proof (simp add: process_prop_1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> c_failures step out s\\<^sub>0", "have \"([], {(x, p). p \\<noteq> out s\\<^sub>0 x}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R0)"], ["proof (state)\nthis:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> c_failures step out s\\<^sub>0", "have \"{} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}", "show \"([], {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  ([], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_process_prop_2 [simp]: \"process_prop_2 (c_failures step out s\\<^sub>0, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_2 (c_failures step out s\\<^sub>0, {})", "proof (simp only: process_prop_2_def fst_conv, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs @ [x], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs, {}) \\<in> c_failures step out s\\<^sub>0", "fix xps xp X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs @ [x], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs, {}) \\<in> c_failures step out s\\<^sub>0", "assume \"(xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs @ [x], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs, {}) \\<in> c_failures step out s\\<^sub>0", "hence \"(butlast (xps @ [xp]), {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (butlast (xps @ [xp]), {}) \\<in> c_failures step out s\\<^sub>0", "proof (rule c_failures.induct\n   [where P = \"\\<lambda>xps X. (butlast xps, {}) \\<in> c_failures step out s\\<^sub>0\"], simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    ([], {}) \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "have \"([], {(x, p). p \\<noteq> out s\\<^sub>0 x}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R0)"], ["proof (state)\nthis:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    ([], {}) \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    ([], {}) \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "have \"{} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (2 subgoals):\n 1. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    ([], {}) \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}", "show \"([], {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  ([], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "fix xps' X'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "assume \"(xps', X') \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps', X') \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (xps', X') \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "have \"{} \\<subseteq> X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> X'", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> X'\n\ngoal (1 subgoal):\n 1. \\<And>xpsa uu_ s.\n       \\<lbrakk>(xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (butlast xpsa, {}) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa);\n        (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (xpsa, {}) \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (xps', X') \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> X'", "show \"(xps', {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps', X') \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> X'\n\ngoal (1 subgoal):\n 1. (xps', {}) \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps', {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (butlast (xps @ [xp]), {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs @ [x], X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs, {}) \\<in> c_failures step out s\\<^sub>0", "thus \"(xps, {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (butlast (xps @ [xp]), {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps, {}) \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  (xps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_process_prop_3 [simp]: \"process_prop_3 (c_failures step out s\\<^sub>0, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_3 (c_failures step out s\\<^sub>0, {})", "by (simp only: process_prop_3_def fst_conv, (rule allI)+, rule impI, erule conjE, rule R2)"], ["", "lemma c_process_prop_4 [simp]: \"process_prop_4 (c_failures step out s\\<^sub>0, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_4 (c_failures step out s\\<^sub>0, {})", "proof (simp only: process_prop_4_def fst_conv, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs @ [x], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n       (xs, insert x X) \\<in> c_failures step out s\\<^sub>0", "fix xps xp X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs @ [x], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n       (xs, insert x X) \\<in> c_failures step out s\\<^sub>0", "assume \"(xps, X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps, X) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>xs x X.\n       (xs, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (xs @ [x], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n       (xs, insert x X) \\<in> c_failures step out s\\<^sub>0", "thus \"(xps @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps, insert xp X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps, X) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps, insert xp X) \\<in> c_failures step out s\\<^sub>0", "proof (case_tac xp, rule c_failures.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        xp = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ([] @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         ([],\n                          insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 3. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "fix x p"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        xp = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ([] @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         ([],\n                          insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 3. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "assume A: \"xp = (x, p)\""], ["proof (state)\nthis:\n  xp = (x, p)\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        xp = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ([] @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         ([],\n                          insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 3. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "have B: \"([], {(x, p). p \\<noteq> out s\\<^sub>0 x}) \\<in> c_failures step out s\\<^sub>0\"\n     (is \"(_, ?X) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R0)"], ["proof (state)\nthis:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        xp = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ([] @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         ([],\n                          insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 3. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "show \"([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or> ([], insert xp ?X)\n      \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "proof (cases \"p = out s\\<^sub>0 x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "assume C: \"p = out s\\<^sub>0 x\""], ["proof (state)\nthis:\n  p = out s\\<^sub>0 x\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "have \"s\\<^sub>0 = foldl step s\\<^sub>0 (map fst [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 = foldl step s\\<^sub>0 (map fst [])", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>0 = foldl step s\\<^sub>0 (map fst [])\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "with B"], ["proof (chain)\npicking this:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n  s\\<^sub>0 = foldl step s\\<^sub>0 (map fst [])", "have \"([] @ [(x, out s\\<^sub>0 x)], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n        \\<in> c_failures step out s\\<^sub>0\"\n       (is \"(_, ?Y) \\<in> _\")"], ["proof (prove)\nusing this:\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n  s\\<^sub>0 = foldl step s\\<^sub>0 (map fst [])\n\ngoal (1 subgoal):\n 1. ([] @ [(x, out s\\<^sub>0 x)],\n     {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R1)"], ["proof (state)\nthis:\n  ([] @ [(x, out s\\<^sub>0 x)],\n   {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"([] @ [xp], ?Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ([] @ [(x, out s\\<^sub>0 x)],\n   {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ([] @ [xp], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n    \\<in> c_failures step out s\\<^sub>0", "using A and C"], ["proof (prove)\nusing this:\n  ([] @ [(x, out s\\<^sub>0 x)],\n   {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n  xp = (x, p)\n  p = out s\\<^sub>0 x\n\ngoal (1 subgoal):\n 1. ([] @ [xp], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  ([] @ [xp], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  ([] @ [xp], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "have \"{} \\<subseteq> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y}", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y}\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  ([] @ [xp], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y}", "have \"([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ([] @ [xp], {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(y, p). p \\<noteq> out (step s\\<^sub>0 x) y}\n\ngoal (1 subgoal):\n 1. ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", ".."], ["proof (state)\nthis:\n  ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "assume \"p \\<noteq> out s\\<^sub>0 x\""], ["proof (state)\nthis:\n  p \\<noteq> out s\\<^sub>0 x\n\ngoal (1 subgoal):\n 1. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"xp \\<in> ?X\""], ["proof (prove)\nusing this:\n  p \\<noteq> out s\\<^sub>0 x\n\ngoal (1 subgoal):\n 1. xp \\<in> {(x, p). p \\<noteq> out s\\<^sub>0 x}", "using A"], ["proof (prove)\nusing this:\n  p \\<noteq> out s\\<^sub>0 x\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. xp \\<in> {(x, p). p \\<noteq> out s\\<^sub>0 x}", "by simp"], ["proof (state)\nthis:\n  xp \\<in> {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"insert xp ?X = ?X\""], ["proof (prove)\nusing this:\n  xp \\<in> {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x} =\n    {(x, p). p \\<noteq> out s\\<^sub>0 x}", "by (rule insert_absorb)"], ["proof (state)\nthis:\n  insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x} =\n  {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"([], insert xp ?X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x} =\n  {(x, p). p \\<noteq> out s\\<^sub>0 x}\n\ngoal (1 subgoal):\n 1. ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "using B"], ["proof (prove)\nusing this:\n  insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x} =\n  {(x, p). p \\<noteq> out s\\<^sub>0 x}\n  ([], {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. p \\<noteq> out s\\<^sub>0 x \\<Longrightarrow>\n    ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n    \\<in> c_failures step out s\\<^sub>0", ".."], ["proof (state)\nthis:\n  ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ([] @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  ([], insert xp {(x, p). p \\<noteq> out s\\<^sub>0 x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "fix x p xps' X' s x'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "let ?s = \"step s x'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "assume A: \"xp = (x, p)\""], ["proof (state)\nthis:\n  xp = (x, p)\n\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "assume \"(xps', X') \\<in> c_failures step out s\\<^sub>0\" and\n      S: \"s = foldl step s\\<^sub>0 (map fst xps')\""], ["proof (state)\nthis:\n  (xps', X') \\<in> c_failures step out s\\<^sub>0\n  s = foldl step s\\<^sub>0 (map fst xps')\n\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "hence B: \"(xps' @ [(x', out s x')], {(y, p). p \\<noteq> out ?s y})\n      \\<in> c_failures step out s\\<^sub>0\"\n     (is \"(?xps, ?X) \\<in> _\")"], ["proof (prove)\nusing this:\n  (xps', X') \\<in> c_failures step out s\\<^sub>0\n  s = foldl step s\\<^sub>0 (map fst xps')\n\ngoal (1 subgoal):\n 1. (xps' @ [(x', out s x')], {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R1)"], ["proof (state)\nthis:\n  (xps' @ [(x', out s x')], {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>a b xpsa uu_ s x.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, uu_) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp uu_) \\<in> c_failures step out s\\<^sub>0;\n        s = foldl step s\\<^sub>0 (map fst xpsa)\\<rbrakk>\n       \\<Longrightarrow> ((xpsa @ [(x, out s x)]) @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa @ [(x, out s x)],\n                          insert xp {(y, p). p \\<noteq> out (step s x) y})\n                         \\<in> c_failures step out s\\<^sub>0\n 2. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "show \"(?xps @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or> (?xps, insert xp ?X)\n      \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "proof (cases \"p = out ?s x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "assume C: \"p = out ?s x\""], ["proof (state)\nthis:\n  p = out (step s x') x\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "have \"?s = foldl step s\\<^sub>0 (map fst ?xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step s x' = foldl step s\\<^sub>0 (map fst (xps' @ [(x', out s x')]))", "using S"], ["proof (prove)\nusing this:\n  s = foldl step s\\<^sub>0 (map fst xps')\n\ngoal (1 subgoal):\n 1. step s x' = foldl step s\\<^sub>0 (map fst (xps' @ [(x', out s x')]))", "by simp"], ["proof (state)\nthis:\n  step s x' = foldl step s\\<^sub>0 (map fst (xps' @ [(x', out s x')]))\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "with B"], ["proof (chain)\npicking this:\n  (xps' @ [(x', out s x')], {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n  step s x' = foldl step s\\<^sub>0 (map fst (xps' @ [(x', out s x')]))", "have \"(?xps @ [(x, out ?s x)], {(y, p). p \\<noteq> out (step ?s x) y})\n        \\<in> c_failures step out s\\<^sub>0\"\n       (is \"(_, ?Y) \\<in> _\")"], ["proof (prove)\nusing this:\n  (xps' @ [(x', out s x')], {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n  step s x' = foldl step s\\<^sub>0 (map fst (xps' @ [(x', out s x')]))\n\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [(x, out (step s x') x)],\n     {(y, p). p \\<noteq> out (step (step s x') x) y})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R1)"], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [(x, out (step s x') x)],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"(?xps @ [xp], ?Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ((xps' @ [(x', out s x')]) @ [(x, out (step s x') x)],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [xp],\n     {(y, p). p \\<noteq> out (step (step s x') x) y})\n    \\<in> c_failures step out s\\<^sub>0", "using A and C"], ["proof (prove)\nusing this:\n  ((xps' @ [(x', out s x')]) @ [(x, out (step s x') x)],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n  xp = (x, p)\n  p = out (step s x') x\n\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [xp],\n     {(y, p). p \\<noteq> out (step (step s x') x) y})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [xp],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [xp],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "have \"{} \\<subseteq> ?Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> {(y, p). p \\<noteq> out (step (step s x') x) y}", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> {(y, p). p \\<noteq> out (step (step s x') x) y}\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  ((xps' @ [(x', out s x')]) @ [xp],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(y, p). p \\<noteq> out (step (step s x') x) y}", "have \"(?xps @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ((xps' @ [(x', out s x')]) @ [xp],\n   {(y, p). p \\<noteq> out (step (step s x') x) y})\n  \\<in> c_failures step out s\\<^sub>0\n  {} \\<subseteq> {(y, p). p \\<noteq> out (step (step s x') x) y}\n\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. p = out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0\n 2. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((xps' @ [(x', out s x')]) @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", ".."], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [xp], {})\n  \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps' @ [(x', out s x')],\n   insert xp {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "assume \"p \\<noteq> out ?s x\""], ["proof (state)\nthis:\n  p \\<noteq> out (step s x') x\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"xp \\<in> ?X\""], ["proof (prove)\nusing this:\n  p \\<noteq> out (step s x') x\n\ngoal (1 subgoal):\n 1. xp \\<in> {(y, p). p \\<noteq> out (step s x') y}", "using A"], ["proof (prove)\nusing this:\n  p \\<noteq> out (step s x') x\n  xp = (x, p)\n\ngoal (1 subgoal):\n 1. xp \\<in> {(y, p). p \\<noteq> out (step s x') y}", "by simp"], ["proof (state)\nthis:\n  xp \\<in> {(y, p). p \\<noteq> out (step s x') y}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"insert xp ?X = ?X\""], ["proof (prove)\nusing this:\n  xp \\<in> {(y, p). p \\<noteq> out (step s x') y}\n\ngoal (1 subgoal):\n 1. insert xp {(y, p). p \\<noteq> out (step s x') y} =\n    {(y, p). p \\<noteq> out (step s x') y}", "by (rule insert_absorb)"], ["proof (state)\nthis:\n  insert xp {(y, p). p \\<noteq> out (step s x') y} =\n  {(y, p). p \\<noteq> out (step s x') y}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"(?xps, insert xp ?X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  insert xp {(y, p). p \\<noteq> out (step s x') y} =\n  {(y, p). p \\<noteq> out (step s x') y}\n\ngoal (1 subgoal):\n 1. (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "using B"], ["proof (prove)\nusing this:\n  insert xp {(y, p). p \\<noteq> out (step s x') y} =\n  {(y, p). p \\<noteq> out (step s x') y}\n  (xps' @ [(x', out s x')], {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  (xps' @ [(x', out s x')],\n   insert xp {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (step s x') x \\<Longrightarrow>\n    ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xps' @ [(x', out s x')],\n   insert xp {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ((xps' @ [(x', out s x')]) @ [xp], {})\n    \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps' @ [(x', out s x')],\n     insert xp {(y, p). p \\<noteq> out (step s x') y})\n    \\<in> c_failures step out s\\<^sub>0", ".."], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [xp], {})\n  \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps' @ [(x', out s x')],\n   insert xp {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((xps' @ [(x', out s x')]) @ [xp], {})\n  \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps' @ [(x', out s x')],\n   insert xp {(y, p). p \\<noteq> out (step s x') y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "fix xps' X' Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "assume\n      \"(xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n       (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\" (is \"?A \\<or> ?B\") and\n      \"X' \\<subseteq> Y\""], ["proof (state)\nthis:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\n  X' \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. \\<And>a b xpsa Y Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0; xp = (a, b);\n        (xpsa, Y) \\<in> c_failures step out s\\<^sub>0;\n        (xpsa @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n        (xpsa, insert xp Y) \\<in> c_failures step out s\\<^sub>0;\n        Xa \\<subseteq> Y\\<rbrakk>\n       \\<Longrightarrow> (xpsa @ [xp], {})\n                         \\<in> c_failures step out s\\<^sub>0 \\<or>\n                         (xpsa, insert xp Xa)\n                         \\<in> c_failures step out s\\<^sub>0", "show \"(xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or> (xps', insert xp X')\n      \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "using \\<open>?A \\<or> ?B\\<close>"], ["proof (prove)\nusing this:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "proof (rule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n 2. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "assume ?A"], ["proof (state)\nthis:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n 2. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", ".."], ["proof (state)\nthis:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "assume ?B"], ["proof (state)\nthis:\n  (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "have \"insert xp X' \\<subseteq> insert xp Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert xp X' \\<subseteq> insert xp Y", "using \\<open>X' \\<subseteq> Y\\<close>"], ["proof (prove)\nusing this:\n  X' \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. insert xp X' \\<subseteq> insert xp Y", "by (rule insert_mono)"], ["proof (state)\nthis:\n  insert xp X' \\<subseteq> insert xp Y\n\ngoal (1 subgoal):\n 1. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\n  insert xp X' \\<subseteq> insert xp Y", "have \"(xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps', insert xp Y) \\<in> c_failures step out s\\<^sub>0\n  insert xp X' \\<subseteq> insert xp Y\n\ngoal (1 subgoal):\n 1. (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps', insert xp Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n    (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0", ".."], ["proof (state)\nthis:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xps' @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps', insert xp X') \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xps @ [xp], {}) \\<in> c_failures step out s\\<^sub>0 \\<or>\n  (xps, insert xp X) \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_process_prop_5 [simp]: \"process_prop_5 (F, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_5 (F, {})", "by (simp add: process_prop_5_def)"], ["", "lemma c_process_prop_6 [simp]: \"process_prop_6 (F, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_prop_6 (F, {})", "by (simp add: process_prop_6_def)"], ["", "theorem c_process_process: \"(c_failures step out s\\<^sub>0, {}) \\<in> process_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_failures step out s\\<^sub>0, {}) \\<in> process_set", "by (simp add: process_set_def)"], ["", "text \\<open>\n\\null\n\nThe continuation of this section is dedicated to the proof of a few lemmas on the properties of\nclassical processes, particularly on the application to them of the generic functions acting on\nprocesses defined previously, and culminates in the theorem stating that classical processes are\ndeterministic. Since they are intended to be a representation of deterministic state machines as\nprocesses, this result provides an essential confirmation of the correctness of such correspondence.\n\n\\null\n\\<close>"], ["", "lemma c_failures_last [rule_format]:\n \"(xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow> xps \\<noteq> [] \\<longrightarrow>\n  snd (last xps) = out (foldl step s\\<^sub>0 (butlast (map fst xps))) (last (map fst xps))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    xps \\<noteq> [] \\<longrightarrow>\n    snd (last xps) =\n    out (foldl step s\\<^sub>0 (butlast (map fst xps))) (last (map fst xps))", "by (erule c_failures.induct, simp_all)"], ["", "lemma c_failures_ref:\n \"(xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n  X \\<subseteq> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    X \\<subseteq> {(x, p).\n                   p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}", "by (erule c_failures.induct, simp_all)"], ["", "lemma c_failures_failures: \"failures (c_process step out s\\<^sub>0) = c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. failures (c_process step out s\\<^sub>0) = c_failures step out s\\<^sub>0", "by (simp add: failures_def c_process_def c_process_process Abs_process_inverse)"], ["", "lemma c_futures_failures:\n \"(yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps =\n  ((xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps) =\n    ((xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0)", "by (simp add: futures_def failures_def c_process_def c_process_process Abs_process_inverse)"], ["", "lemma c_traces:\n \"xps \\<in> traces (c_process step out s\\<^sub>0) = (\\<exists>X. (xps, X) \\<in> c_failures step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps \\<in> traces (c_process step out s\\<^sub>0)) =\n    (\\<exists>X. (xps, X) \\<in> c_failures step out s\\<^sub>0)", "by (simp add: traces_def failures_def Domain_iff c_process_def c_process_process\n Abs_process_inverse)"], ["", "lemma c_refusals:\n \"X \\<in> refusals (c_process step out s\\<^sub>0) xps = ((xps, X) \\<in> c_failures step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> refusals (c_process step out s\\<^sub>0) xps) =\n    ((xps, X) \\<in> c_failures step out s\\<^sub>0)", "by (simp add: refusals_def c_failures_failures)"], ["", "lemma c_next_events:\n \"xp \\<in> next_events (c_process step out s\\<^sub>0) xps =\n  (\\<exists>X. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xp \\<in> next_events (c_process step out s\\<^sub>0) xps) =\n    (\\<exists>X. (xps @ [xp], X) \\<in> c_failures step out s\\<^sub>0)", "by (simp add: next_events_def c_traces)"], ["", "lemma c_traces_failures:\n \"xps \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xps \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n    \\<in> c_failures step out s\\<^sub>0", "proof (simp add: c_traces, erule exE, rule rev_cases [of xps],\n simp_all add: R0 split_paired_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "fix yps y p Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "assume A: \"(yps @ [(y, p)], Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (yps @ [(y, p)], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "let ?s = \"foldl step s\\<^sub>0 (map fst yps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "let ?ys' = \"map fst (yps @ [(y, p)])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "have \"(yps @ [(y, p)], Y) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yps @ [(y, p)], Y) \\<in> failures (c_process step out s\\<^sub>0)", "using A"], ["proof (prove)\nusing this:\n  (yps @ [(y, p)], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (yps @ [(y, p)], Y) \\<in> failures (c_process step out s\\<^sub>0)", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (yps @ [(y, p)], Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "hence \"(yps, {}) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\nusing this:\n  (yps @ [(y, p)], Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (yps, {}) \\<in> failures (c_process step out s\\<^sub>0)", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (yps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "hence \"(yps, {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (yps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (yps, {}) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (yps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (yps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "have \"?s = foldl step s\\<^sub>0 (map fst yps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl step s\\<^sub>0 (map fst yps) = foldl step s\\<^sub>0 (map fst yps)", "by simp"], ["proof (state)\nthis:\n  foldl step s\\<^sub>0 (map fst yps) = foldl step s\\<^sub>0 (map fst yps)\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (yps, {}) \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst yps) = foldl step s\\<^sub>0 (map fst yps)", "have \"(yps @ [(y, out ?s y)], {(x, p). p \\<noteq> out (step ?s y) x})\n    \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (yps, {}) \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst yps) = foldl step s\\<^sub>0 (map fst yps)\n\ngoal (1 subgoal):\n 1. (yps @ [(y, out (foldl step s\\<^sub>0 (map fst yps)) y)],\n     {(x, p).\n      p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R1)"], ["proof (state)\nthis:\n  (yps @ [(y, out (foldl step s\\<^sub>0 (map fst yps)) y)],\n   {(x, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (yps @ [(y, out (foldl step s\\<^sub>0 (map fst yps)) y)],\n   {(x, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "have \"yps @ [(y, p)] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yps @ [(y, p)] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  yps @ [(y, p)] \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "with A"], ["proof (chain)\npicking this:\n  (yps @ [(y, p)], Y) \\<in> c_failures step out s\\<^sub>0\n  yps @ [(y, p)] \\<noteq> []", "have \"snd (last (yps @ [(y, p)])) =\n    out (foldl step s\\<^sub>0 (butlast ?ys')) (last ?ys')\""], ["proof (prove)\nusing this:\n  (yps @ [(y, p)], Y) \\<in> c_failures step out s\\<^sub>0\n  yps @ [(y, p)] \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (last (yps @ [(y, p)])) =\n    out (foldl step s\\<^sub>0 (butlast (map fst (yps @ [(y, p)]))))\n     (last (map fst (yps @ [(y, p)])))", "by (rule c_failures_last)"], ["proof (state)\nthis:\n  snd (last (yps @ [(y, p)])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (yps @ [(y, p)]))))\n   (last (map fst (yps @ [(y, p)])))\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "hence \"p = out ?s y\""], ["proof (prove)\nusing this:\n  snd (last (yps @ [(y, p)])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (yps @ [(y, p)]))))\n   (last (map fst (yps @ [(y, p)])))\n\ngoal (1 subgoal):\n 1. p = out (foldl step s\\<^sub>0 (map fst yps)) y", "by simp"], ["proof (state)\nthis:\n  p = out (foldl step s\\<^sub>0 (map fst yps)) y\n\ngoal (1 subgoal):\n 1. \\<And>X ys a b.\n       \\<lbrakk>(ys @ [(a, b)], X) \\<in> c_failures step out s\\<^sub>0;\n        xps = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> (ys @ [(a, b)],\n                          {(x, p).\n                           p \\<noteq>\n                           out (step (foldl step s\\<^sub>0 (map fst ys)) a)\n                            x})\n                         \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (yps @ [(y, out (foldl step s\\<^sub>0 (map fst yps)) y)],\n   {(x, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n  \\<in> c_failures step out s\\<^sub>0\n  p = out (foldl step s\\<^sub>0 (map fst yps)) y", "show \"(yps @ [(y, p)], {(x, p). p \\<noteq> out (step ?s y) x})\n    \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (yps @ [(y, out (foldl step s\\<^sub>0 (map fst yps)) y)],\n   {(x, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n  \\<in> c_failures step out s\\<^sub>0\n  p = out (foldl step s\\<^sub>0 (map fst yps)) y\n\ngoal (1 subgoal):\n 1. (yps @ [(y, p)],\n     {(x, p).\n      p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  (yps @ [(y, p)],\n   {(x, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst yps)) y) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem c_process_deterministic: \"deterministic (c_process step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deterministic (c_process step out s\\<^sub>0)", "proof (simp add: deterministic_def c_refusals c_next_events set_eq_iff, rule ballI,\n rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs X.\n       xs \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n       ((xs, X) \\<in> c_failures step out s\\<^sub>0) =\n       (\\<forall>a b.\n           (a, b) \\<in> X \\<longrightarrow>\n           (\\<forall>X.\n               (xs @ [(a, b)], X) \\<notin> c_failures step out s\\<^sub>0))", "fix xps X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs X.\n       xs \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n       ((xs, X) \\<in> c_failures step out s\\<^sub>0) =\n       (\\<forall>a b.\n           (a, b) \\<in> X \\<longrightarrow>\n           (\\<forall>X.\n               (xs @ [(a, b)], X) \\<notin> c_failures step out s\\<^sub>0))", "assume T: \"xps \\<in> traces (c_process step out s\\<^sub>0)\""], ["proof (state)\nthis:\n  xps \\<in> traces (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>xs X.\n       xs \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n       ((xs, X) \\<in> c_failures step out s\\<^sub>0) =\n       (\\<forall>a b.\n           (a, b) \\<in> X \\<longrightarrow>\n           (\\<forall>X.\n               (xs @ [(a, b)], X) \\<notin> c_failures step out s\\<^sub>0))", "let ?s = \"foldl step s\\<^sub>0 (map fst xps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs X.\n       xs \\<in> traces (c_process step out s\\<^sub>0) \\<Longrightarrow>\n       ((xs, X) \\<in> c_failures step out s\\<^sub>0) =\n       (\\<forall>a b.\n           (a, b) \\<in> X \\<longrightarrow>\n           (\\<forall>X.\n               (xs @ [(a, b)], X) \\<notin> c_failures step out s\\<^sub>0))", "show \"(xps, X) \\<in> c_failures step out s\\<^sub>0 =\n    (\\<forall>x p. (x, p) \\<in> X \\<longrightarrow> (\\<forall>X. (xps @ [(x, p)], X) \\<notin> c_failures step out s\\<^sub>0))\"\n   (is \"?P = ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xps, X) \\<in> c_failures step out s\\<^sub>0) =\n    (\\<forall>x p.\n        (x, p) \\<in> X \\<longrightarrow>\n        (\\<forall>X.\n            (xps @ [(x, p)], X) \\<notin> c_failures step out s\\<^sub>0))", "proof (rule iffI, (rule allI)+, rule impI, rule allI, rule notI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "fix x p Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "let ?xs' = \"map fst (xps @ [(x, p)])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "assume ?P"], ["proof (state)\nthis:\n  (xps, X) \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "hence \"X \\<subseteq> {(x, p). p \\<noteq> out ?s x}\" (is \"_ \\<subseteq> ?X'\")"], ["proof (prove)\nusing this:\n  (xps, X) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {(x, p).\n                   p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}", "by (rule c_failures_ref)"], ["proof (state)\nthis:\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "assume \"(x, p) \\<in> X\""], ["proof (state)\nthis:\n  (x, p) \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n  (x, p) \\<in> X", "have \"(x, p) \\<in> ?X'\""], ["proof (prove)\nusing this:\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n  (x, p) \\<in> X\n\ngoal (1 subgoal):\n 1. (x, p)\n    \\<in> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}", ".."], ["proof (state)\nthis:\n  (x, p)\n  \\<in> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "hence A: \"p \\<noteq> out ?s x\""], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "assume \"(xps @ [(x, p)], Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps @ [(x, p)], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (xps @ [(x, p)], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "have \"xps @ [(x, p)] \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xps @ [(x, p)] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xps @ [(x, p)] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ [(x, p)], Y) \\<in> c_failures step out s\\<^sub>0\n  xps @ [(x, p)] \\<noteq> []", "have \"snd (last (xps @ [(x, p)])) =\n      out (foldl step s\\<^sub>0 (butlast ?xs')) (last ?xs')\""], ["proof (prove)\nusing this:\n  (xps @ [(x, p)], Y) \\<in> c_failures step out s\\<^sub>0\n  xps @ [(x, p)] \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (last (xps @ [(x, p)])) =\n    out (foldl step s\\<^sub>0 (butlast (map fst (xps @ [(x, p)]))))\n     (last (map fst (xps @ [(x, p)])))", "by (rule c_failures_last)"], ["proof (state)\nthis:\n  snd (last (xps @ [(x, p)])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (xps @ [(x, p)]))))\n   (last (map fst (xps @ [(x, p)])))\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "hence \"p = out ?s x\""], ["proof (prove)\nusing this:\n  snd (last (xps @ [(x, p)])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (xps @ [(x, p)]))))\n   (last (map fst (xps @ [(x, p)])))\n\ngoal (1 subgoal):\n 1. p = out (foldl step s\\<^sub>0 (map fst xps)) x", "by simp"], ["proof (state)\nthis:\n  p = out (foldl step s\\<^sub>0 (map fst xps)) x\n\ngoal (2 subgoals):\n 1. \\<And>x p Xa.\n       \\<lbrakk>(xps, X) \\<in> c_failures step out s\\<^sub>0;\n        (x, p) \\<in> X;\n        (xps @ [(x, p)], Xa) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "thus False"], ["proof (prove)\nusing this:\n  p = out (foldl step s\\<^sub>0 (map fst xps)) x\n\ngoal (1 subgoal):\n 1. False", "using A"], ["proof (prove)\nusing this:\n  p = out (foldl step s\\<^sub>0 (map fst xps)) x\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "assume ?Q"], ["proof (state)\nthis:\n  \\<forall>x p.\n     (x, p) \\<in> X \\<longrightarrow>\n     (\\<forall>X.\n         (xps @ [(x, p)], X) \\<notin> c_failures step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "have A: \"(xps, {(x, p). p \\<noteq> out ?s x}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n    \\<in> c_failures step out s\\<^sub>0", "using T"], ["proof (prove)\nusing this:\n  xps \\<in> traces (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule c_traces_failures)"], ["proof (state)\nthis:\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "have \"X \\<subseteq> {(x, p). p \\<noteq> out ?s x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> {(x, p).\n                   p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}", "proof (rule subsetI, simp add: split_paired_all, rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "fix x p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(x, p) \\<in> X\" and \"p = out ?s x\""], ["proof (state)\nthis:\n  (x, p) \\<in> X\n  p = out (foldl step s\\<^sub>0 (map fst xps)) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(xps @ [(x, out ?s x)], {(y, p). p \\<noteq> out (step ?s x) y})\n        \\<notin> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (x, p) \\<in> X\n  p = out (foldl step s\\<^sub>0 (map fst xps)) x\n\ngoal (1 subgoal):\n 1. (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n     {(y, p).\n      p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n    \\<notin> c_failures step out s\\<^sub>0", "using \\<open>?Q\\<close>"], ["proof (prove)\nusing this:\n  (x, p) \\<in> X\n  p = out (foldl step s\\<^sub>0 (map fst xps)) x\n  \\<forall>x p.\n     (x, p) \\<in> X \\<longrightarrow>\n     (\\<forall>X.\n         (xps @ [(x, p)], X) \\<notin> c_failures step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n     {(y, p).\n      p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n    \\<notin> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<notin> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<notin> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "have \"?s = foldl step s\\<^sub>0 (map fst xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl step s\\<^sub>0 (map fst xps) = foldl step s\\<^sub>0 (map fst xps)", "by simp"], ["proof (state)\nthis:\n  foldl step s\\<^sub>0 (map fst xps) = foldl step s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst xps) = foldl step s\\<^sub>0 (map fst xps)", "have \"(xps @ [(x, out ?s x)], {(y, p). p \\<noteq> out (step ?s x) y})\n        \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst xps) = foldl step s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n     {(y, p).\n      p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R1)"], ["proof (state)\nthis:\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> X;\n        b = out (foldl step s\\<^sub>0 (map fst xps)) a\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<notin> c_failures step out s\\<^sub>0\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<in> c_failures step out s\\<^sub>0", "show False"], ["proof (prove)\nusing this:\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<notin> c_failures step out s\\<^sub>0\n  (xps @ [(x, out (foldl step s\\<^sub>0 (map fst xps)) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 (map fst xps)) x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n\ngoal (1 subgoal):\n 1. \\<forall>x p.\n       (x, p) \\<in> X \\<longrightarrow>\n       (\\<forall>X.\n           (xps @ [(x, p)], X)\n           \\<notin> c_failures step out s\\<^sub>0) \\<Longrightarrow>\n    (xps, X) \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> c_failures step out s\\<^sub>0\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}", "show ?P"], ["proof (prove)\nusing this:\n  (xps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> c_failures step out s\\<^sub>0\n  X \\<subseteq> {(x, p).\n                 p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x}\n\ngoal (1 subgoal):\n 1. (xps, X) \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps, X) \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((xps, X) \\<in> c_failures step out s\\<^sub>0) =\n  (\\<forall>x p.\n      (x, p) \\<in> X \\<longrightarrow>\n      (\\<forall>X.\n          (xps @ [(x, p)], X) \\<notin> c_failures step out s\\<^sub>0))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Traces in classical processes\""], ["", "text \\<open>\nHere below is the definition of function \\<open>c_tr\\<close>, where \\<open>c_tr step out s xs\\<close> is the\ntrace of classical process \\<open>c_process step out s\\<close> corresponding to the trace \\<open>xs\\<close> of\nthe associated deterministic state machine. Moreover, some useful lemmas are proven about this\nfunction.\n\n\\null\n\\<close>"], ["", "function c_tr :: \"('s \\<Rightarrow> 'a \\<Rightarrow> 's) \\<Rightarrow> ('s \\<Rightarrow> 'a \\<Rightarrow> 'o) \\<Rightarrow> 's \\<Rightarrow> 'a list \\<Rightarrow> ('a \\<times> 'o) list\" where\n\"c_tr _ _ _ [] = []\" |\n\"c_tr step out s (xs @ [x]) = c_tr step out s xs @ [(x, out (foldl step s xs) x)]\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_ uv_ uw_.\n                   x = (uu_, uv_, uw_, []) \\<Longrightarrow> P;\n        \\<And>step out s xs xa.\n           x = (step, out, s, xs @ [xa]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uv_ uw_ uua_ uva_ uwa_.\n       (uu_, uv_, uw_, []) = (uua_, uva_, uwa_, []) \\<Longrightarrow>\n       [] = []\n 3. \\<And>uu_ uv_ uw_ step out s xs x.\n       (uu_, uv_, uw_, []) = (step, out, s, xs @ [x]) \\<Longrightarrow>\n       [] = c_tr_sumC (step, out, s, xs) @ [(x, out (foldl step s xs) x)]\n 4. \\<And>step out s xs x stepa outa sa xsa xa.\n       (step, out, s, xs @ [x]) =\n       (stepa, outa, sa, xsa @ [xa]) \\<Longrightarrow>\n       c_tr_sumC (step, out, s, xs) @ [(x, out (foldl step s xs) x)] =\n       c_tr_sumC (stepa, outa, sa, xsa) @\n       [(xa, outa (foldl stepa sa xsa) xa)]", "proof (atomize_elim, simp_all add: split_paired_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. b = [] \\<or> (\\<exists>xs x. b = xs @ [x])", "qed (rule rev_cases, rule disjI1, assumption, simp)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All c_tr_dom", "by lexicographic_order"], ["", "lemma c_tr_length: \"length (c_tr step out s xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (c_tr step out s xs) = length xs", "by (rule rev_induct, simp_all)"], ["", "lemma c_tr_map: \"map fst (c_tr step out s xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (c_tr step out s xs) = xs", "by (rule rev_induct, simp_all)"], ["", "lemma c_tr_singleton: \"c_tr step out s [x] = [(x, out s x)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "have \"c_tr step out s [x] = c_tr step out s ([] @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s [x] = c_tr step out s ([] @ [x])", "by simp"], ["proof (state)\nthis:\n  c_tr step out s [x] = c_tr step out s ([] @ [x])\n\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "also"], ["proof (state)\nthis:\n  c_tr step out s [x] = c_tr step out s ([] @ [x])\n\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "have \"\\<dots> = c_tr step out s [] @ [(x, out (foldl step s []) x)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s ([] @ [x]) =\n    c_tr step out s [] @ [(x, out (foldl step s []) x)]", "by (rule c_tr.simps(2))"], ["proof (state)\nthis:\n  c_tr step out s ([] @ [x]) =\n  c_tr step out s [] @ [(x, out (foldl step s []) x)]\n\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "also"], ["proof (state)\nthis:\n  c_tr step out s ([] @ [x]) =\n  c_tr step out s [] @ [(x, out (foldl step s []) x)]\n\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "have \"\\<dots> = [(x, out s x)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s [] @ [(x, out (foldl step s []) x)] = [(x, out s x)]", "by simp"], ["proof (state)\nthis:\n  c_tr step out s [] @ [(x, out (foldl step s []) x)] = [(x, out s x)]\n\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "finally"], ["proof (chain)\npicking this:\n  c_tr step out s [x] = [(x, out s x)]", "show ?thesis"], ["proof (prove)\nusing this:\n  c_tr step out s [x] = [(x, out s x)]\n\ngoal (1 subgoal):\n 1. c_tr step out s [x] = [(x, out s x)]", "."], ["proof (state)\nthis:\n  c_tr step out s [x] = [(x, out s x)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_tr_append:\n \"c_tr step out s (xs @ ys) = c_tr step out s xs @ c_tr step out (foldl step s xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s (xs @ ys) =\n    c_tr step out s xs @ c_tr step out (foldl step s xs) ys", "proof (rule_tac xs = ys in rev_induct, simp, subst append_assoc [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       c_tr step out s (xs @ xsa) =\n       c_tr step out s xs @\n       c_tr step out (foldl step s xs) xsa \\<Longrightarrow>\n       c_tr step out s ((xs @ xsa) @ [x]) =\n       c_tr step out s xs @ c_tr step out (foldl step s xs) (xsa @ [x])", "qed (simp del: append_assoc)"], ["", "lemma c_tr_hd_tl:\n  assumes A: \"xs \\<noteq> []\"\n  shows \"c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "let ?s = \"foldl step s [hd xs]\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "have \"c_tr step out s ([hd xs] @ tl xs) =\n    c_tr step out s [hd xs] @ c_tr step out ?s (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s ([hd xs] @ tl xs) =\n    c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)", "by (rule c_tr_append)"], ["proof (state)\nthis:\n  c_tr step out s ([hd xs] @ tl xs) =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "moreover"], ["proof (state)\nthis:\n  c_tr step out s ([hd xs] @ tl xs) =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "have \"[hd xs] @ tl xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [hd xs] @ tl xs = xs", "using A"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. [hd xs] @ tl xs = xs", "by simp"], ["proof (state)\nthis:\n  [hd xs] @ tl xs = xs\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "ultimately"], ["proof (chain)\npicking this:\n  c_tr step out s ([hd xs] @ tl xs) =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n  [hd xs] @ tl xs = xs", "have \"c_tr step out s xs =\n    c_tr step out s [hd xs] @ c_tr step out ?s (tl xs)\""], ["proof (prove)\nusing this:\n  c_tr step out s ([hd xs] @ tl xs) =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n  [hd xs] @ tl xs = xs\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)", "by simp"], ["proof (state)\nthis:\n  c_tr step out s xs =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "moreover"], ["proof (state)\nthis:\n  c_tr step out s xs =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "have \"c_tr step out s [hd xs] = [(hd xs, out s (hd xs))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s [hd xs] = [(hd xs, out s (hd xs))]", "by (simp add: c_tr_singleton)"], ["proof (state)\nthis:\n  c_tr step out s [hd xs] = [(hd xs, out s (hd xs))]\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "ultimately"], ["proof (chain)\npicking this:\n  c_tr step out s xs =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n  c_tr step out s [hd xs] = [(hd xs, out s (hd xs))]", "show ?thesis"], ["proof (prove)\nusing this:\n  c_tr step out s xs =\n  c_tr step out s [hd xs] @ c_tr step out (foldl step s [hd xs]) (tl xs)\n  c_tr step out s [hd xs] = [(hd xs, out s (hd xs))]\n\ngoal (1 subgoal):\n 1. c_tr step out s xs =\n    (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)", "by simp"], ["proof (state)\nthis:\n  c_tr step out s xs =\n  (hd xs, out s (hd xs)) # c_tr step out (step s (hd xs)) (tl xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_failures_tr:\n \"(xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow> xps = c_tr step out s\\<^sub>0 (map fst xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps, X) \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    xps = c_tr step out s\\<^sub>0 (map fst xps)", "by (erule c_failures.induct, simp_all)"], ["", "lemma c_futures_tr:\n  assumes A: \"(yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\"\n  shows \"yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "have B: \"(xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0", "using A"], ["proof (prove)\nusing this:\n  (yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "hence \"xps @ yps = c_tr step out s\\<^sub>0 (map fst (xps @ yps))\""], ["proof (prove)\nusing this:\n  (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps @ yps = c_tr step out s\\<^sub>0 (map fst (xps @ yps))", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps @ yps = c_tr step out s\\<^sub>0 (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "hence \"xps @ yps = c_tr step out s\\<^sub>0 (map fst xps) @\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\""], ["proof (prove)\nusing this:\n  xps @ yps = c_tr step out s\\<^sub>0 (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. xps @ yps =\n    c_tr step out s\\<^sub>0 (map fst xps) @\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "by (simp add: c_tr_append)"], ["proof (state)\nthis:\n  xps @ yps =\n  c_tr step out s\\<^sub>0 (map fst xps) @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "moreover"], ["proof (state)\nthis:\n  xps @ yps =\n  c_tr step out s\\<^sub>0 (map fst xps) @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "have \"(xps @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)", "using B"], ["proof (prove)\nusing this:\n  (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (xps @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "hence \"(xps, {}) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\nusing this:\n  (xps @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps, {}) \\<in> failures (c_process step out s\\<^sub>0)", "by (rule process_rule_2_failures)"], ["proof (state)\nthis:\n  (xps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "hence \"(xps, {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps, {}) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (xps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "hence \"xps = c_tr step out s\\<^sub>0 (map fst xps)\""], ["proof (prove)\nusing this:\n  (xps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps = c_tr step out s\\<^sub>0 (map fst xps)", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "ultimately"], ["proof (chain)\npicking this:\n  xps @ yps =\n  c_tr step out s\\<^sub>0 (map fst xps) @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\n  xps = c_tr step out s\\<^sub>0 (map fst xps)", "show ?thesis"], ["proof (prove)\nusing this:\n  xps @ yps =\n  c_tr step out s\\<^sub>0 (map fst xps) @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)", "by simp"], ["proof (state)\nthis:\n  yps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst yps)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_tr_failures:\n \"(c_tr step out s\\<^sub>0 xs, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n  \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs,\n     {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n    \\<in> c_failures step out s\\<^sub>0", "proof (rule rev_induct, simp_all, rule R0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "let ?s = \"foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "assume \"(c_tr step out s\\<^sub>0 xs, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n    \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "have \"?s = foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n    foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))", "by simp"], ["proof (state)\nthis:\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (c_tr step out s\\<^sub>0 xs,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n  \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))", "have \"(c_tr step out s\\<^sub>0 xs @ [(x, out ?s x)],\n    {(y, p). p \\<noteq> out (step ?s x) y}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (c_tr step out s\\<^sub>0 xs,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n  \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     [(x, out (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n           x)],\n     {(y, p).\n      p \\<noteq>\n      out (step\n            (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs))) x)\n       y})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R1)"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs @\n   [(x, out (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n         x)],\n   {(y, p).\n    p \\<noteq>\n    out (step (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n          x)\n     y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs @\n   [(x, out (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n         x)],\n   {(y, p).\n    p \\<noteq>\n    out (step (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n          x)\n     y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "have \"?s = foldl step s\\<^sub>0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n    foldl step s\\<^sub>0 xs", "by (simp add: c_tr_map)"], ["proof (state)\nthis:\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n  foldl step s\\<^sub>0 xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (c_tr step out s\\<^sub>0 xs,\n        {a. case a of\n            (x, p) \\<Rightarrow>\n              p \\<noteq> out (foldl step s\\<^sub>0 xs) x})\n       \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n       (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n        {a. case a of\n            (xa, p) \\<Rightarrow>\n              p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) xa})\n       \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (c_tr step out s\\<^sub>0 xs @\n   [(x, out (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n         x)],\n   {(y, p).\n    p \\<noteq>\n    out (step (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n          x)\n     y})\n  \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n  foldl step s\\<^sub>0 xs", "show \"(c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) y}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (c_tr step out s\\<^sub>0 xs @\n   [(x, out (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n         x)],\n   {(y, p).\n    p \\<noteq>\n    out (step (foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)))\n          x)\n     y})\n  \\<in> c_failures step out s\\<^sub>0\n  foldl step s\\<^sub>0 (map fst (c_tr step out s\\<^sub>0 xs)) =\n  foldl step s\\<^sub>0 xs\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n     {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) y})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs @ [(x, out (foldl step s\\<^sub>0 xs) x)],\n   {(y, p). p \\<noteq> out (step (foldl step s\\<^sub>0 xs) x) y})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_tr_futures:\n \"(c_tr step out (foldl step s\\<^sub>0 xs) ys,\n  {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 xs) ys,\n     {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "proof (simp add: c_futures_failures)"], ["proof (state)\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     c_tr step out (foldl step s\\<^sub>0 xs) ys,\n     {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> c_failures step out s\\<^sub>0", "have \"(c_tr step out s\\<^sub>0 (xs @ ys), {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (xs @ ys)) x})\n    \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 (xs @ ys),\n     {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (xs @ ys)) x})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule c_tr_failures)"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 (xs @ ys),\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (xs @ ys)) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     c_tr step out (foldl step s\\<^sub>0 xs) ys,\n     {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 (xs @ ys),\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (xs @ ys)) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     c_tr step out (foldl step s\\<^sub>0 xs) ys,\n     {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> c_failures step out s\\<^sub>0", "have \"c_tr step out s\\<^sub>0 (xs @ ys) =\n    c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s\\<^sub>0 (xs @ ys) =\n    c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys", "by (rule c_tr_append)"], ["proof (state)\nthis:\n  c_tr step out s\\<^sub>0 (xs @ ys) =\n  c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     c_tr step out (foldl step s\\<^sub>0 xs) ys,\n     {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (c_tr step out s\\<^sub>0 (xs @ ys),\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (xs @ ys)) x})\n  \\<in> c_failures step out s\\<^sub>0\n  c_tr step out s\\<^sub>0 (xs @ ys) =\n  c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys", "show \"(c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys,\n    {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (c_tr step out s\\<^sub>0 (xs @ ys),\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (xs @ ys)) x})\n  \\<in> c_failures step out s\\<^sub>0\n  c_tr step out s\\<^sub>0 (xs @ ys) =\n  c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     c_tr step out (foldl step s\\<^sub>0 xs) ys,\n     {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n    \\<in> c_failures step out s\\<^sub>0", "by simp"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs @ c_tr step out (foldl step s\\<^sub>0 xs) ys,\n   {(x, p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) ys) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Noninterference in classical processes\""], ["", "text \\<open>\nGiven a mapping \\<open>D\\<close> of the actions of a deterministic state machine into their security\ndomains, it is natural to map each event \\<open>(x, p)\\<close> of the corresponding classical process\ninto the domain \\<open>D x\\<close> of action \\<open>x\\<close>.\n\nSuch mapping of events into domains, formalized as function \\<open>c_dom D\\<close> in the continuation,\nensures that the same noninterference policy applying to a deterministic state machine be applicable\nto the associated classical process as well. This is the simplest, and thus preferable way to\nconstruct a policy for the process such as to be isomorphic to the one assigned for the machine, as\nrequired in order to prove the equivalence of CSP noninterference security to the classical notion\nin the case of classical processes.\n\nIn what follows, function \\<open>c_dom\\<close> will be used in the proof of some useful lemmas concerning\nthe application of functions \\<open>sinks\\<close>, \\<open>ipurge_tr\\<close>, \\<open>c_sources\\<close>, \\<open>c_ipurge\\<close>\nfrom noninterference theory to the traces of classical processes, constructed by means of function\n\\<open>c_tr\\<close>.\n\n\\null\n\\<close>"], ["", "definition c_dom :: \"('a \\<Rightarrow> 'd) \\<Rightarrow> ('a \\<times> 'o) \\<Rightarrow> 'd\" where\n\"c_dom D xp \\<equiv> D (fst xp)\""], ["", "lemma c_dom_sources:\n \"c_sources I (c_dom D) u xps = c_sources I D u (map fst xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I (c_dom D) u xps = c_sources I D u (map fst xps)", "by (induction xps, simp_all add: c_dom_def)"], ["", "lemma c_dom_sinks: \"sinks I (c_dom D) u xps = sinks I D u (map fst xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I (c_dom D) u xps = sinks I D u (map fst xps)", "by (induction xps rule: rev_induct, simp_all add: c_dom_def)"], ["", "lemma c_tr_sources:\n \"c_sources I (c_dom D) u (c_tr step out s xs) = c_sources I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I (c_dom D) u (c_tr step out s xs) = c_sources I D u xs", "by (simp add: c_dom_sources c_tr_map)"], ["", "lemma c_tr_sinks: \"sinks I (c_dom D) u (c_tr step out s xs) = sinks I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks I (c_dom D) u (c_tr step out s xs) = sinks I D u xs", "by (simp add: c_dom_sinks c_tr_map)"], ["", "lemma c_tr_ipurge:\n \"c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n  c_tr step out s (c_ipurge I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "proof (induction xs arbitrary: s, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       (\\<And>s.\n           c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n           c_tr step out s (c_ipurge I D u xs)) \\<Longrightarrow>\n       c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u (a # xs))) =\n       c_tr step out s (c_ipurge I D u (a # xs))", "fix x xs s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       (\\<And>s.\n           c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n           c_tr step out s (c_ipurge I D u xs)) \\<Longrightarrow>\n       c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u (a # xs))) =\n       c_tr step out s (c_ipurge I D u (a # xs))", "assume A: \"\\<And>s. c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)\""], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out ?s (c_ipurge I D u xs)) =\n  c_tr step out ?s (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs s.\n       (\\<And>s.\n           c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n           c_tr step out s (c_ipurge I D u xs)) \\<Longrightarrow>\n       c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u (a # xs))) =\n       c_tr step out s (c_ipurge I D u (a # xs))", "show \"c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u (x # xs))) =\n    c_tr step out s (c_ipurge I D u (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u (x # xs))) =\n    c_tr step out s (c_ipurge I D u (x # xs))", "proof (cases \"D x \\<in> c_sources I D u (x # xs)\", simp_all del: c_sources.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "have B: \"c_tr step out s (x # c_ipurge I D u xs) =\n      (x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s (x # c_ipurge I D u xs) =\n    (x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs)", "by (simp add: c_tr_hd_tl)"], ["proof (state)\nthis:\n  c_tr step out s (x # c_ipurge I D u xs) =\n  (x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs)\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "assume C: \"D x \\<in> c_sources I D u (x # xs)\""], ["proof (state)\nthis:\n  D x \\<in> c_sources I D u (x # xs)\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "hence \"D x \\<in> c_sources I D u (c_ipurge I D u (x # xs))\""], ["proof (prove)\nusing this:\n  D x \\<in> c_sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. D x \\<in> c_sources I D u (c_ipurge I D u (x # xs))", "by (subst c_sources_ipurge)"], ["proof (state)\nthis:\n  D x \\<in> c_sources I D u (c_ipurge I D u (x # xs))\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "hence \"D x \\<in> c_sources I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs))\""], ["proof (prove)\nusing this:\n  D x \\<in> c_sources I D u (c_ipurge I D u (x # xs))\n\ngoal (1 subgoal):\n 1. D x\n    \\<in> c_sources I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs))", "using C"], ["proof (prove)\nusing this:\n  D x \\<in> c_sources I D u (c_ipurge I D u (x # xs))\n  D x \\<in> c_sources I D u (x # xs)\n\ngoal (1 subgoal):\n 1. D x\n    \\<in> c_sources I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs))", "by (simp add: c_tr_sources)"], ["proof (state)\nthis:\n  D x\n  \\<in> c_sources I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs))\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "hence \"c_dom D (x, out s x) \\<in> c_sources I (c_dom D) u\n      ((x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs))\""], ["proof (prove)\nusing this:\n  D x\n  \\<in> c_sources I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs))\n\ngoal (1 subgoal):\n 1. c_dom D (x, out s x)\n    \\<in> c_sources I (c_dom D) u\n           ((x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs))", "using B"], ["proof (prove)\nusing this:\n  D x\n  \\<in> c_sources I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs))\n  c_tr step out s (x # c_ipurge I D u xs) =\n  (x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. c_dom D (x, out s x)\n    \\<in> c_sources I (c_dom D) u\n           ((x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs))", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  c_dom D (x, out s x)\n  \\<in> c_sources I (c_dom D) u\n         ((x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs))\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "hence \"c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) = \n      (x, out s x) # c_ipurge I (c_dom D) u\n      (c_tr step out (step s x) (c_ipurge I D u xs))\""], ["proof (prove)\nusing this:\n  c_dom D (x, out s x)\n  \\<in> c_sources I (c_dom D) u\n         ((x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs))\n\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    (x, out s x) #\n    c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))", "using B"], ["proof (prove)\nusing this:\n  c_dom D (x, out s x)\n  \\<in> c_sources I (c_dom D) u\n         ((x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs))\n  c_tr step out s (x # c_ipurge I D u xs) =\n  (x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    (x, out s x) #\n    c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))", "by simp"], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n  (x, out s x) #\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "moreover"], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n  (x, out s x) #\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "have \"c_ipurge I (c_dom D) u\n      (c_tr step out (step s x) (c_ipurge I D u xs)) =\n      c_tr step out (step s x) (c_ipurge I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs)) =\n    c_tr step out (step s x) (c_ipurge I D u xs)", "using A"], ["proof (prove)\nusing this:\n  c_ipurge I (c_dom D) u (c_tr step out ?s (c_ipurge I D u xs)) =\n  c_tr step out ?s (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs)) =\n    c_tr step out (step s x) (c_ipurge I D u xs)", "."], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs)) =\n  c_tr step out (step s x) (c_ipurge I D u xs)\n\ngoal (2 subgoals):\n 1. D x \\<in> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)\n 2. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "ultimately"], ["proof (chain)\npicking this:\n  c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n  (x, out s x) #\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs)) =\n  c_tr step out (step s x) (c_ipurge I D u xs)", "show \"c_ipurge I (c_dom D) u\n      (c_tr step out s (x # c_ipurge I D u xs)) =\n      c_tr step out s (x # c_ipurge I D u xs)\""], ["proof (prove)\nusing this:\n  c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n  (x, out s x) #\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs)) =\n  c_tr step out (step s x) (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)", "using B"], ["proof (prove)\nusing this:\n  c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n  (x, out s x) #\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs))\n  c_ipurge I (c_dom D) u (c_tr step out (step s x) (c_ipurge I D u xs)) =\n  c_tr step out (step s x) (c_ipurge I D u xs)\n  c_tr step out s (x # c_ipurge I D u xs) =\n  (x, out s x) # c_tr step out (step s x) (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n    c_tr step out s (x # c_ipurge I D u xs)", "by simp"], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out s (x # c_ipurge I D u xs)) =\n  c_tr step out s (x # c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D x \\<notin> c_sources I D u (x # xs) \\<Longrightarrow>\n    c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "show \"c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n      c_tr step out s (c_ipurge I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "using A"], ["proof (prove)\nusing this:\n  c_ipurge I (c_dom D) u (c_tr step out ?s (c_ipurge I D u xs)) =\n  c_tr step out ?s (c_ipurge I D u xs)\n\ngoal (1 subgoal):\n 1. c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n    c_tr step out s (c_ipurge I D u xs)", "."], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u xs)) =\n  c_tr step out s (c_ipurge I D u xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c_ipurge I (c_dom D) u (c_tr step out s (c_ipurge I D u (x # xs))) =\n  c_tr step out s (c_ipurge I D u (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_tr_ipurge_tr_1 [rule_format]:\n \"(\\<forall>n \\<in> {..<length xs}. D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) = c_tr step out s (ipurge_tr I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n\\<in>{..<length xs}.\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n        out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n        out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n    c_tr step out s (ipurge_tr I D u xs)", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "assume \"(\\<forall>n \\<in> {..<length xs}.\n    D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n    out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n    c_tr step out s (ipurge_tr I D u xs)\""], ["proof (state)\nthis:\n  (\\<forall>n\\<in>{..<length xs}.\n      D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n      out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n      out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n  c_tr step out s (ipurge_tr I D u xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>n\\<in>{..<length xs}.\n      D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n      out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n      out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n  c_tr step out s (ipurge_tr I D u xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "assume A: \"\\<forall>n \\<in> {..<length (xs @ [x])}.\n    D ((xs @ [x]) ! n) \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take n (xs @ [x])))) ((xs @ [x]) ! n) =\n    out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\""], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<length (xs @ [x])}.\n     D ((xs @ [x]) ! n)\n     \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n      ((xs @ [x]) ! n) =\n     out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "have \"\\<forall>n \\<in> {..<length xs}.\n    D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n    out (foldl step s (take n xs)) (xs ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>{..<length xs}.\n       D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n       out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n       out (foldl step s (take n xs)) (xs ! n)", "proof (rule ballI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "assume B: \"n \\<in> {..<length xs}\""], ["proof (state)\nthis:\n  n \\<in> {..<length xs}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "hence \"n \\<in> {..<length (xs @ [x])}\""], ["proof (prove)\nusing this:\n  n \\<in> {..<length xs}\n\ngoal (1 subgoal):\n 1. n \\<in> {..<length (xs @ [x])}", "by simp"], ["proof (state)\nthis:\n  n \\<in> {..<length (xs @ [x])}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "with A"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<length (xs @ [x])}.\n     D ((xs @ [x]) ! n)\n     \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n      ((xs @ [x]) ! n) =\n     out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n  n \\<in> {..<length (xs @ [x])}", "have \"D ((xs @ [x]) ! n) \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n      out (foldl step s (ipurge_tr I D u (take n (xs @ [x])))) ((xs @ [x]) ! n) =\n      out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<length (xs @ [x])}.\n     D ((xs @ [x]) ! n)\n     \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n      ((xs @ [x]) ! n) =\n     out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n  n \\<in> {..<length (xs @ [x])}\n\ngoal (1 subgoal):\n 1. D ((xs @ [x]) ! n)\n    \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n     ((xs @ [x]) ! n) =\n    out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)", ".."], ["proof (state)\nthis:\n  D ((xs @ [x]) ! n)\n  \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n   ((xs @ [x]) ! n) =\n  out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "hence \"D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n      out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n      out (foldl step s (take n xs)) (xs ! n)\""], ["proof (prove)\nusing this:\n  D ((xs @ [x]) ! n)\n  \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n   ((xs @ [x]) ! n) =\n  out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n\ngoal (1 subgoal):\n 1. D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n    out (foldl step s (take n xs)) (xs ! n)", "using B"], ["proof (prove)\nusing this:\n  D ((xs @ [x]) ! n)\n  \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n   ((xs @ [x]) ! n) =\n  out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n  n \\<in> {..<length xs}\n\ngoal (1 subgoal):\n 1. D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n    out (foldl step s (take n xs)) (xs ! n)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "moreover"], ["proof (state)\nthis:\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "assume \"D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\""], ["proof (state)\nthis:\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length xs};\n        D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step s (ipurge_tr I D u (take n xs)))\n                          (xs ! n) =\n                         out (foldl step s (take n xs)) (xs ! n)", "ultimately"], ["proof (chain)\npicking this:\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)", "show \"out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n      out (foldl step s (take n xs)) (xs ! n)\""], ["proof (prove)\nusing this:\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)\n  D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs)\n\ngoal (1 subgoal):\n 1. out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n    out (foldl step s (take n xs)) (xs ! n)", ".."], ["proof (state)\nthis:\n  out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n  out (foldl step s (take n xs)) (xs ! n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>{..<length xs}.\n     D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n     out (foldl step s (take n xs)) (xs ! n)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>n\\<in>{..<length xs}.\n      D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n      out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n      out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n  c_tr step out s (ipurge_tr I D u xs)\n  \\<forall>n\\<in>{..<length xs}.\n     D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n     out (foldl step s (take n xs)) (xs ! n)", "have C: \"ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n    c_tr step out s (ipurge_tr I D u xs)\""], ["proof (prove)\nusing this:\n  (\\<forall>n\\<in>{..<length xs}.\n      D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n      out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n      out (foldl step s (take n xs)) (xs ! n)) \\<longrightarrow>\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n  c_tr step out s (ipurge_tr I D u xs)\n  \\<forall>n\\<in>{..<length xs}.\n     D (xs ! n) \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n xs))) (xs ! n) =\n     out (foldl step s (take n xs)) (xs ! n)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n    c_tr step out s (ipurge_tr I D u xs)", ".."], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n  c_tr step out s (ipurge_tr I D u xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(\\<forall>n\\<in>{..<length xs}.\n                    D (xs ! n)\n                    \\<notin> sinks I D u (take (Suc n) xs) \\<longrightarrow>\n                    out (foldl step s (ipurge_tr I D u (take n xs)))\n                     (xs ! n) =\n                    out (foldl step s (take n xs))\n                     (xs ! n)) \\<longrightarrow>\n                ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n                c_tr step out s (ipurge_tr I D u xs);\n        \\<forall>n\\<in>{..<length (xs @ [x])}.\n           D ((xs @ [x]) ! n)\n           \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n           out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n            ((xs @ [x]) ! n) =\n           out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr I (c_dom D) u\n                          (c_tr step out s (xs @ [x])) =\n                         c_tr step out s (ipurge_tr I D u (xs @ [x]))", "show \"ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "proof (cases \"D x \\<in> sinks I D u (xs @ [x])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D x \\<in> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))\n 2. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "case True"], ["proof (state)\nthis:\n  D x \\<in> sinks I D u (xs @ [x])\n\ngoal (2 subgoals):\n 1. D x \\<in> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))\n 2. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  D x \\<in> sinks I D u (xs @ [x])", "have \"D x \\<in> sinks I (c_dom D) u\n      (c_tr step out s (xs @ [x]))\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks I (c_dom D) u (c_tr step out s (xs @ [x]))", "by (subst c_tr_sinks)"], ["proof (state)\nthis:\n  D x \\<in> sinks I (c_dom D) u (c_tr step out s (xs @ [x]))\n\ngoal (2 subgoals):\n 1. D x \\<in> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))\n 2. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "hence \"c_dom D (x, out (foldl step s xs) x)\n      \\<in> sinks I (c_dom D) u (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks I (c_dom D) u (c_tr step out s (xs @ [x]))\n\ngoal (1 subgoal):\n 1. c_dom D (x, out (foldl step s xs) x)\n    \\<in> sinks I (c_dom D) u\n           (c_tr step out s xs @ [(x, out (foldl step s xs) x)])", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  c_dom D (x, out (foldl step s xs) x)\n  \\<in> sinks I (c_dom D) u\n         (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\n\ngoal (2 subgoals):\n 1. D x \\<in> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))\n 2. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "with True"], ["proof (chain)\npicking this:\n  D x \\<in> sinks I D u (xs @ [x])\n  c_dom D (x, out (foldl step s xs) x)\n  \\<in> sinks I (c_dom D) u\n         (c_tr step out s xs @ [(x, out (foldl step s xs) x)])", "show ?thesis"], ["proof (prove)\nusing this:\n  D x \\<in> sinks I D u (xs @ [x])\n  c_dom D (x, out (foldl step s xs) x)\n  \\<in> sinks I (c_dom D) u\n         (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "using C"], ["proof (prove)\nusing this:\n  D x \\<in> sinks I D u (xs @ [x])\n  c_dom D (x, out (foldl step s xs) x)\n  \\<in> sinks I (c_dom D) u\n         (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\n  ipurge_tr I (c_dom D) u (c_tr step out s xs) =\n  c_tr step out s (ipurge_tr I D u xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n  c_tr step out s (ipurge_tr I D u (xs @ [x]))\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "case False"], ["proof (state)\nthis:\n  D x \\<notin> sinks I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  D x \\<notin> sinks I D u (xs @ [x])", "have \"D x \\<notin> sinks I (c_dom D) u\n      (c_tr step out s (xs @ [x]))\""], ["proof (prove)\nusing this:\n  D x \\<notin> sinks I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I (c_dom D) u (c_tr step out s (xs @ [x]))", "by (subst c_tr_sinks)"], ["proof (state)\nthis:\n  D x \\<notin> sinks I (c_dom D) u (c_tr step out s (xs @ [x]))\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "hence \"c_dom D (x, out (foldl step s xs) x)\n      \\<notin> sinks I (c_dom D) u (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\""], ["proof (prove)\nusing this:\n  D x \\<notin> sinks I (c_dom D) u (c_tr step out s (xs @ [x]))\n\ngoal (1 subgoal):\n 1. c_dom D (x, out (foldl step s xs) x)\n    \\<notin> sinks I (c_dom D) u\n              (c_tr step out s xs @ [(x, out (foldl step s xs) x)])", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  c_dom D (x, out (foldl step s xs) x)\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "with False"], ["proof (chain)\npicking this:\n  D x \\<notin> sinks I D u (xs @ [x])\n  c_dom D (x, out (foldl step s xs) x)\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out s xs @ [(x, out (foldl step s xs) x)])", "show ?thesis"], ["proof (prove)\nusing this:\n  D x \\<notin> sinks I D u (xs @ [x])\n  c_dom D (x, out (foldl step s xs) x)\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out s xs @ [(x, out (foldl step s xs) x)])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n    c_tr step out s (ipurge_tr I D u (xs @ [x]))", "proof (simp add: C)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>D x\n             \\<notin> (if (u, D x) \\<in> I \\<or>\n                          (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n                       then insert (D x) (sinks I D u xs)\n                       else sinks I D u xs);\n     c_dom D (x, out (foldl step s xs) x)\n     \\<notin> (if (u, c_dom D (x, out (foldl step s xs) x)) \\<in> I \\<or>\n                  (\\<exists>v\\<in>sinks I (c_dom D) u (c_tr step out s xs).\n                      (v, c_dom D (x, out (foldl step s xs) x)) \\<in> I)\n               then insert (c_dom D (x, out (foldl step s xs) x))\n                     (sinks I (c_dom D) u (c_tr step out s xs))\n               else sinks I (c_dom D) u (c_tr step out s xs))\\<rbrakk>\n    \\<Longrightarrow> out (foldl step s xs) x =\n                      out (foldl step s (ipurge_tr I D u xs)) x", "have \"length xs \\<in> {..<length (xs @ [x])}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<in> {..<length (xs @ [x])}", "by simp"], ["proof (state)\nthis:\n  length xs \\<in> {..<length (xs @ [x])}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D x\n             \\<notin> (if (u, D x) \\<in> I \\<or>\n                          (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n                       then insert (D x) (sinks I D u xs)\n                       else sinks I D u xs);\n     c_dom D (x, out (foldl step s xs) x)\n     \\<notin> (if (u, c_dom D (x, out (foldl step s xs) x)) \\<in> I \\<or>\n                  (\\<exists>v\\<in>sinks I (c_dom D) u (c_tr step out s xs).\n                      (v, c_dom D (x, out (foldl step s xs) x)) \\<in> I)\n               then insert (c_dom D (x, out (foldl step s xs) x))\n                     (sinks I (c_dom D) u (c_tr step out s xs))\n               else sinks I (c_dom D) u (c_tr step out s xs))\\<rbrakk>\n    \\<Longrightarrow> out (foldl step s xs) x =\n                      out (foldl step s (ipurge_tr I D u xs)) x", "with A"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..<length (xs @ [x])}.\n     D ((xs @ [x]) ! n)\n     \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n      ((xs @ [x]) ! n) =\n     out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n  length xs \\<in> {..<length (xs @ [x])}", "have \"D ((xs @ [x]) ! length xs)\n        \\<notin> sinks I D u (take (Suc (length xs)) (xs @ [x])) \\<longrightarrow>\n        out (foldl step s (ipurge_tr I D u (take (length xs) (xs @ [x]))))\n        ((xs @ [x]) ! (length xs)) =\n        out (foldl step s (take (length xs) (xs @ [x]))) ((xs @ [x]) ! (length xs))\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..<length (xs @ [x])}.\n     D ((xs @ [x]) ! n)\n     \\<notin> sinks I D u (take (Suc n) (xs @ [x])) \\<longrightarrow>\n     out (foldl step s (ipurge_tr I D u (take n (xs @ [x]))))\n      ((xs @ [x]) ! n) =\n     out (foldl step s (take n (xs @ [x]))) ((xs @ [x]) ! n)\n  length xs \\<in> {..<length (xs @ [x])}\n\ngoal (1 subgoal):\n 1. D ((xs @ [x]) ! length xs)\n    \\<notin> sinks I D u\n              (take (Suc (length xs)) (xs @ [x])) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u (take (length xs) (xs @ [x]))))\n     ((xs @ [x]) ! length xs) =\n    out (foldl step s (take (length xs) (xs @ [x])))\n     ((xs @ [x]) ! length xs)", ".."], ["proof (state)\nthis:\n  D ((xs @ [x]) ! length xs)\n  \\<notin> sinks I D u (take (Suc (length xs)) (xs @ [x])) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take (length xs) (xs @ [x]))))\n   ((xs @ [x]) ! length xs) =\n  out (foldl step s (take (length xs) (xs @ [x]))) ((xs @ [x]) ! length xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D x\n             \\<notin> (if (u, D x) \\<in> I \\<or>\n                          (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n                       then insert (D x) (sinks I D u xs)\n                       else sinks I D u xs);\n     c_dom D (x, out (foldl step s xs) x)\n     \\<notin> (if (u, c_dom D (x, out (foldl step s xs) x)) \\<in> I \\<or>\n                  (\\<exists>v\\<in>sinks I (c_dom D) u (c_tr step out s xs).\n                      (v, c_dom D (x, out (foldl step s xs) x)) \\<in> I)\n               then insert (c_dom D (x, out (foldl step s xs) x))\n                     (sinks I (c_dom D) u (c_tr step out s xs))\n               else sinks I (c_dom D) u (c_tr step out s xs))\\<rbrakk>\n    \\<Longrightarrow> out (foldl step s xs) x =\n                      out (foldl step s (ipurge_tr I D u xs)) x", "hence \"D x \\<notin> sinks I D u (xs @ [x]) \\<longrightarrow>\n        out (foldl step s (ipurge_tr I D u xs)) x = out (foldl step s xs) x\""], ["proof (prove)\nusing this:\n  D ((xs @ [x]) ! length xs)\n  \\<notin> sinks I D u (take (Suc (length xs)) (xs @ [x])) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u (take (length xs) (xs @ [x]))))\n   ((xs @ [x]) ! length xs) =\n  out (foldl step s (take (length xs) (xs @ [x]))) ((xs @ [x]) ! length xs)\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x]) \\<longrightarrow>\n    out (foldl step s (ipurge_tr I D u xs)) x = out (foldl step s xs) x", "by simp"], ["proof (state)\nthis:\n  D x \\<notin> sinks I D u (xs @ [x]) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u xs)) x = out (foldl step s xs) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>D x\n             \\<notin> (if (u, D x) \\<in> I \\<or>\n                          (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n                       then insert (D x) (sinks I D u xs)\n                       else sinks I D u xs);\n     c_dom D (x, out (foldl step s xs) x)\n     \\<notin> (if (u, c_dom D (x, out (foldl step s xs) x)) \\<in> I \\<or>\n                  (\\<exists>v\\<in>sinks I (c_dom D) u (c_tr step out s xs).\n                      (v, c_dom D (x, out (foldl step s xs) x)) \\<in> I)\n               then insert (c_dom D (x, out (foldl step s xs) x))\n                     (sinks I (c_dom D) u (c_tr step out s xs))\n               else sinks I (c_dom D) u (c_tr step out s xs))\\<rbrakk>\n    \\<Longrightarrow> out (foldl step s xs) x =\n                      out (foldl step s (ipurge_tr I D u xs)) x", "thus \"out (foldl step s xs) x = out (foldl step s (ipurge_tr I D u xs)) x\""], ["proof (prove)\nusing this:\n  D x \\<notin> sinks I D u (xs @ [x]) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u xs)) x = out (foldl step s xs) x\n\ngoal (1 subgoal):\n 1. out (foldl step s xs) x = out (foldl step s (ipurge_tr I D u xs)) x", "using False"], ["proof (prove)\nusing this:\n  D x \\<notin> sinks I D u (xs @ [x]) \\<longrightarrow>\n  out (foldl step s (ipurge_tr I D u xs)) x = out (foldl step s xs) x\n  D x \\<notin> sinks I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. out (foldl step s xs) x = out (foldl step s (ipurge_tr I D u xs)) x", "by simp"], ["proof (state)\nthis:\n  out (foldl step s xs) x = out (foldl step s (ipurge_tr I D u xs)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n  c_tr step out s (ipurge_tr I D u (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) u (c_tr step out s (xs @ [x])) =\n  c_tr step out s (ipurge_tr I D u (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_tr_ipurge_tr_2 [rule_format]:\n  assumes A: \"\\<forall>n \\<in> {..length ys}. \\<exists>Y.\n    (ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\"\n  shows \"n \\<in> {..<length ys} \\<longrightarrow> D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))) (ys ! n) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {..<length ys} \\<longrightarrow>\n    D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)))\n     (ys ! n) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)", "proof (rule nat_less_induct, (rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "let ?s = \"foldl step s\\<^sub>0 xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "let ?yp = \"(ys ! n, out (foldl step ?s (take n ys)) (ys ! n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "assume\n    B: \"\\<forall>m < n. m \\<in> {..<length ys} \\<longrightarrow>\n      D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n      out (foldl step ?s (ipurge_tr I D u (take m ys))) (ys ! m) =\n      out (foldl step ?s (take m ys)) (ys ! m)\" and\n    C: \"n \\<in> {..<length ys}\" and\n    D: \"D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\""], ["proof (state)\nthis:\n  \\<forall>m<n.\n     m \\<in> {..<length ys} \\<longrightarrow>\n     D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (ipurge_tr I D u (take m ys)))\n      (ys ! m) =\n     out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  n \\<in> {..<length ys}\n  D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"n < length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < length ys", "using C"], ["proof (prove)\nusing this:\n  n \\<in> {..<length ys}\n\ngoal (1 subgoal):\n 1. n < length ys", "by simp"], ["proof (state)\nthis:\n  n < length ys\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "hence E: \"take (Suc n) ys = take n ys @ [ys ! n]\""], ["proof (prove)\nusing this:\n  n < length ys\n\ngoal (1 subgoal):\n 1. take (Suc n) ys = take n ys @ [ys ! n]", "by (rule take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc n) ys = take n ys @ [ys ! n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  take (Suc n) ys = take n ys @ [ys ! n]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"Suc n \\<in> {..length ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n \\<in> {..length ys}", "using C"], ["proof (prove)\nusing this:\n  n \\<in> {..<length ys}\n\ngoal (1 subgoal):\n 1. Suc n \\<in> {..length ys}", "by simp"], ["proof (state)\nthis:\n  Suc n \\<in> {..length ys}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "with A"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>{..length ys}.\n     \\<exists>Y.\n        (ipurge_tr I (c_dom D) u\n          (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)),\n         Y)\n        \\<in> futures (c_process step out s\\<^sub>0)\n               (c_tr step out s\\<^sub>0 xs)\n  Suc n \\<in> {..length ys}", "have \"\\<exists>Y.\n    (ipurge_tr I (c_dom D) u (c_tr step out ?s (take (Suc n) ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..length ys}.\n     \\<exists>Y.\n        (ipurge_tr I (c_dom D) u\n          (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)),\n         Y)\n        \\<in> futures (c_process step out s\\<^sub>0)\n               (c_tr step out s\\<^sub>0 xs)\n  Suc n \\<in> {..length ys}\n\ngoal (1 subgoal):\n 1. \\<exists>Y.\n       (ipurge_tr I (c_dom D) u\n         (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n        Y)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 xs)", ".."], ["proof (state)\nthis:\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)", "obtain Y where\n    \"(ipurge_tr I (c_dom D) u (c_tr step out ?s (take (Suc n) ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        (ipurge_tr I (c_dom D) u\n          (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n         Y)\n        \\<in> futures (c_process step out s\\<^sub>0)\n               (c_tr step out s\\<^sub>0 xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  take (Suc n) ys = take n ys @ [ys ! n]\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)", "have\n    \"(ipurge_tr I (c_dom D) u (c_tr step out ?s (take n ys) @ [?yp]), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  take (Suc n) ys = take n ys @ [ys ! n]\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys)),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) u\n      (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n       [(ys ! n,\n         out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))]),\n     Y)\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by simp"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))]),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))]),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"c_dom D ?yp\n    \\<notin> sinks I (c_dom D) u (c_tr step out ?s (take (Suc n) ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_dom D\n     (ys ! n,\n      out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n    \\<notin> sinks I (c_dom D) u\n              (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys))", "using D"], ["proof (prove)\nusing this:\n  D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\n\ngoal (1 subgoal):\n 1. c_dom D\n     (ys ! n,\n      out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n    \\<notin> sinks I (c_dom D) u\n              (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys))", "by (simp add: c_dom_def c_tr_sinks)"], ["proof (state)\nthis:\n  c_dom D\n   (ys ! n, out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "hence \"c_dom D ?yp \\<notin> sinks I (c_dom D) u\n    (c_tr step out ?s (take n ys) @ [?yp])\""], ["proof (prove)\nusing this:\n  c_dom D\n   (ys ! n, out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys))\n\ngoal (1 subgoal):\n 1. c_dom D\n     (ys ! n,\n      out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n    \\<notin> sinks I (c_dom D) u\n              (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n               [(ys ! n,\n                 out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                  (ys ! n))])", "using E"], ["proof (prove)\nusing this:\n  c_dom D\n   (ys ! n, out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take (Suc n) ys))\n  take (Suc n) ys = take n ys @ [ys ! n]\n\ngoal (1 subgoal):\n 1. c_dom D\n     (ys ! n,\n      out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n    \\<notin> sinks I (c_dom D) u\n              (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n               [(ys ! n,\n                 out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                  (ys ! n))])", "by simp"], ["proof (state)\nthis:\n  c_dom D\n   (ys ! n, out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n             [(ys ! n,\n               out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                (ys ! n))])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))]),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  c_dom D\n   (ys ! n, out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n             [(ys ! n,\n               out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                (ys ! n))])", "have\n    \"(ipurge_tr I (c_dom D) u (c_tr step out ?s (take n ys)) @ [?yp], Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))]),\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  c_dom D\n   (ys ! n, out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))\n  \\<notin> sinks I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys) @\n             [(ys ! n,\n               out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                (ys ! n))])\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) u\n      (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n     Y)\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by simp"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"ipurge_tr I (c_dom D) u (c_tr step out ?s (take n ys)) =\n    c_tr step out ?s (ipurge_tr I D u (take n ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u\n     (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) =\n    c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))", "proof (rule c_tr_ipurge_tr_1, simp, erule conjE, simp add: min_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"m < n \\<longrightarrow> m \\<in> {..<length ys} \\<longrightarrow>\n      D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n      out (foldl step ?s (ipurge_tr I D u (take m ys))) (ys ! m) =\n      out (foldl step ?s (take m ys)) (ys ! m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < n \\<longrightarrow>\n    m \\<in> {..<length ys} \\<longrightarrow>\n    D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n     (ys ! m) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)", "using B"], ["proof (prove)\nusing this:\n  \\<forall>m<n.\n     m \\<in> {..<length ys} \\<longrightarrow>\n     D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (ipurge_tr I D u (take m ys)))\n      (ys ! m) =\n     out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. m < n \\<longrightarrow>\n    m \\<in> {..<length ys} \\<longrightarrow>\n    D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n     (ys ! m) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)", ".."], ["proof (state)\nthis:\n  m < n \\<longrightarrow>\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  m < n \\<longrightarrow>\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "assume \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  m < n \\<longrightarrow>\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  m < n", "have \"m \\<in> {..<length ys} \\<longrightarrow>\n      D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n      out (foldl step ?s (ipurge_tr I D u (take m ys))) (ys ! m) =\n      out (foldl step ?s (take m ys)) (ys ! m)\""], ["proof (prove)\nusing this:\n  m < n \\<longrightarrow>\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  m < n\n\ngoal (1 subgoal):\n 1. m \\<in> {..<length ys} \\<longrightarrow>\n    D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n     (ys ! m) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)", ".."], ["proof (state)\nthis:\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "assume \"m < length ys\""], ["proof (state)\nthis:\n  m < length ys\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "hence \"m \\<in> {..<length ys}\""], ["proof (prove)\nusing this:\n  m < length ys\n\ngoal (1 subgoal):\n 1. m \\<in> {..<length ys}", "by simp"], ["proof (state)\nthis:\n  m \\<in> {..<length ys}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  m \\<in> {..<length ys}", "have \"D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n      out (foldl step ?s (ipurge_tr I D u (take m ys))) (ys ! m) =\n      out (foldl step ?s (take m ys)) (ys ! m)\""], ["proof (prove)\nusing this:\n  m \\<in> {..<length ys} \\<longrightarrow>\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  m \\<in> {..<length ys}\n\ngoal (1 subgoal):\n 1. D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n     (ys ! m) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)", ".."], ["proof (state)\nthis:\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "assume \"D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys)\""], ["proof (state)\nthis:\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys);\n        n < length ys; n < n\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys)", "show \"out (foldl step ?s (ipurge_tr I D u (take m ys))) (ys ! m) =\n      out (foldl step ?s (take m ys)) (ys ! m)\""], ["proof (prove)\nusing this:\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n  D (ys ! m) \\<notin> sinks I D u (take (Suc m) ys)\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n     (ys ! m) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)", ".."], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take m ys)))\n   (ys ! m) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take m ys)) (ys ! m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) u\n   (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) =\n  c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  ipurge_tr I (c_dom D) u\n   (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) =\n  c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))", "have \"(c_tr step out ?s (ipurge_tr I D u (take n ys)) @ [?yp], Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) u\n    (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  ipurge_tr I (c_dom D) u\n   (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)) =\n  c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))\n\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n     Y)\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by simp"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "hence \"(c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @ [?yp], Y)\n    \\<in> c_failures step out s\\<^sub>0\"\n   (is \"(?xps, _) \\<in> _\")"], ["proof (prove)\nusing this:\n  (c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n     [(ys ! n,\n       out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n     Y)\n    \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures c_tr_append)"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"?xps \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n    [(ys ! n,\n      out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n       (ys ! n))] \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n  [(ys ! n,\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n     (ys ! n))] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> c_failures step out s\\<^sub>0\n  c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n  [(ys ! n,\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n     (ys ! n))] \\<noteq>\n  []", "have \"snd (last ?xps) =\n    out (foldl step s\\<^sub>0 (butlast (map fst ?xps))) (last (map fst ?xps))\""], ["proof (prove)\nusing this:\n  (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n   [(ys ! n,\n     out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n))],\n   Y)\n  \\<in> c_failures step out s\\<^sub>0\n  c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n  [(ys ! n,\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n     (ys ! n))] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. snd (last\n          (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n           [(ys ! n,\n             out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n              (ys ! n))])) =\n    out (foldl step s\\<^sub>0\n          (butlast\n            (map fst\n              (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n               [(ys ! n,\n                 out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                  (ys ! n))]))))\n     (last\n       (map fst\n         (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n          [(ys ! n,\n            out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n             (ys ! n))])))", "by (rule c_failures_last)"], ["proof (state)\nthis:\n  snd (last\n        (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n         [(ys ! n,\n           out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n            (ys ! n))])) =\n  out (foldl step s\\<^sub>0\n        (butlast\n          (map fst\n            (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n             [(ys ! n,\n               out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                (ys ! n))]))))\n   (last\n     (map fst\n       (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n        [(ys ! n,\n          out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n           (ys ! n))])))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>m<n.\n                   m \\<in> {..<length ys} \\<longrightarrow>\n                   D (ys ! m)\n                   \\<notin> sinks I D u (take (Suc m) ys) \\<longrightarrow>\n                   out (foldl step (foldl step s\\<^sub>0 xs)\n                         (ipurge_tr I D u (take m ys)))\n                    (ys ! m) =\n                   out (foldl step (foldl step s\\<^sub>0 xs) (take m ys))\n                    (ys ! m);\n        n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "thus \"out (foldl step ?s (ipurge_tr I D u (take n ys))) (ys ! n) =\n    out (foldl step ?s (take n ys)) (ys ! n)\""], ["proof (prove)\nusing this:\n  snd (last\n        (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n         [(ys ! n,\n           out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n            (ys ! n))])) =\n  out (foldl step s\\<^sub>0\n        (butlast\n          (map fst\n            (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n             [(ys ! n,\n               out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n                (ys ! n))]))))\n   (last\n     (map fst\n       (c_tr step out s\\<^sub>0 (xs @ ipurge_tr I D u (take n ys)) @\n        [(ys ! n,\n          out (foldl step (foldl step s\\<^sub>0 xs) (take n ys))\n           (ys ! n))])))\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)))\n     (ys ! n) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)", "by (simp add: c_tr_map butlast_append)"], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)))\n   (ys ! n) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_tr_ipurge_tr [rule_format]:\n  assumes A: \"\\<forall>n \\<in> {..length ys}. \\<exists>Y.\n    (ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\"\n  shows \"ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) ys) =\n    c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) ys) =\n    c_tr step out (foldl step s\\<^sub>0 xs) (ipurge_tr I D u ys)", "proof (rule c_tr_ipurge_tr_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "have \"\\<And>n. n \\<in> {..length ys} \\<Longrightarrow> \\<exists>Y.\n    (ipurge_tr I (c_dom D) u (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)), Y)\n    \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length ys} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 xs)", "using A"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>{..length ys}.\n     \\<exists>Y.\n        (ipurge_tr I (c_dom D) u\n          (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)),\n         Y)\n        \\<in> futures (c_process step out s\\<^sub>0)\n               (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length ys} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) u\n            (c_tr step out (foldl step s\\<^sub>0 xs) (take n ys)),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 xs)", ".."], ["proof (state)\nthis:\n  ?n \\<in> {..length ys} \\<Longrightarrow>\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take ?n ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "moreover"], ["proof (state)\nthis:\n  ?n \\<in> {..length ys} \\<Longrightarrow>\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take ?n ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "assume\n    \"n \\<in> {..<length ys}\" and\n    \"D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\""], ["proof (state)\nthis:\n  n \\<in> {..<length ys}\n  D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> {..<length ys};\n        D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\\<rbrakk>\n       \\<Longrightarrow> out (foldl step (foldl step s\\<^sub>0 xs)\n                               (ipurge_tr I D u (take n ys)))\n                          (ys ! n) =\n                         out (foldl step (foldl step s\\<^sub>0 xs)\n                               (take n ys))\n                          (ys ! n)", "ultimately"], ["proof (chain)\npicking this:\n  ?n \\<in> {..length ys} \\<Longrightarrow>\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take ?n ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)\n  n \\<in> {..<length ys}\n  D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)", "show\n    \"out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys))) (ys ! n) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)\""], ["proof (prove)\nusing this:\n  ?n \\<in> {..length ys} \\<Longrightarrow>\n  \\<exists>Y.\n     (ipurge_tr I (c_dom D) u\n       (c_tr step out (foldl step s\\<^sub>0 xs) (take ?n ys)),\n      Y)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 xs)\n  n \\<in> {..<length ys}\n  D (ys ! n) \\<notin> sinks I D u (take (Suc n) ys)\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)))\n     (ys ! n) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)", "by (rule c_tr_ipurge_tr_2)"], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 xs) (ipurge_tr I D u (take n ys)))\n   (ys ! n) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (take n ys)) (ys ! n)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Equivalence between security properties\""], ["", "text \\<open>\nThe remainder of this section is dedicated to the proof of the equivalence between the CSP\nnoninterference security of a classical process and the classical noninterference security of the\ncorresponding deterministic state machine.\n\nIn some detail, it will be proven that CSP noninterference security alone is a sufficient condition\nfor classical noninterference security, whereas the latter security property entails the former for\nany reflexive noninterference policy. Therefore, the security properties under consideration turn\nout to be equivalent if the enforced noninterference policy is reflexive, which is the case for any\npolicy of practical significance.\n\n\\null\n\\<close>"], ["", "lemma secure_implies_c_secure_aux:\n  assumes S: \"secure (c_process step out s\\<^sub>0) I (c_dom D)\"\n  shows \"out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys)) x", "proof (induction ys arbitrary: xs, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys xs.\n       (\\<And>xs.\n           out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n           out (foldl step (foldl step s\\<^sub>0 xs)\n                 (c_ipurge I D (D x) ys))\n            x) \\<Longrightarrow>\n       out (foldl step (foldl step s\\<^sub>0 xs) (a # ys)) x =\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (a # ys)))\n        x", "fix y ys xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys xs.\n       (\\<And>xs.\n           out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n           out (foldl step (foldl step s\\<^sub>0 xs)\n                 (c_ipurge I D (D x) ys))\n            x) \\<Longrightarrow>\n       out (foldl step (foldl step s\\<^sub>0 xs) (a # ys)) x =\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (a # ys)))\n        x", "assume \"\\<And>xs. out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys)) x\""], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 ?xs) ys) x =\n  out (foldl step (foldl step s\\<^sub>0 ?xs) (c_ipurge I D (D x) ys)) x\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs.\n       (\\<And>xs.\n           out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n           out (foldl step (foldl step s\\<^sub>0 xs)\n                 (c_ipurge I D (D x) ys))\n            x) \\<Longrightarrow>\n       out (foldl step (foldl step s\\<^sub>0 xs) (a # ys)) x =\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (a # ys)))\n        x", "hence A: \"out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) ys) x =\n    out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys)) x\""], ["proof (prove)\nusing this:\n  out (foldl step (foldl step s\\<^sub>0 ?xs) ys) x =\n  out (foldl step (foldl step s\\<^sub>0 ?xs) (c_ipurge I D (D x) ys)) x\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) ys) x =\n    out (foldl step (foldl step s\\<^sub>0 (xs @ [y]))\n          (c_ipurge I D (D x) ys))\n     x", "."], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) ys) x =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a ys xs.\n       (\\<And>xs.\n           out (foldl step (foldl step s\\<^sub>0 xs) ys) x =\n           out (foldl step (foldl step s\\<^sub>0 xs)\n                 (c_ipurge I D (D x) ys))\n            x) \\<Longrightarrow>\n       out (foldl step (foldl step s\\<^sub>0 xs) (a # ys)) x =\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (a # ys)))\n        x", "show \"out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "proof (cases \"D y \\<in> c_sources I D (D x) (y # ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D y \\<in> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x\n 2. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "assume \"D y \\<in> c_sources I D (D x) (y # ys)\""], ["proof (state)\nthis:\n  D y \\<in> c_sources I D (D x) (y # ys)\n\ngoal (2 subgoals):\n 1. D y \\<in> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x\n 2. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "thus ?thesis"], ["proof (prove)\nusing this:\n  D y \\<in> c_sources I D (D x) (y # ys)\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "using A"], ["proof (prove)\nusing this:\n  D y \\<in> c_sources I D (D x) (y # ys)\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) ys) x =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "by simp"], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "let ?s = \"foldl step s\\<^sub>0 xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "let ?yp = \"(y, out ?s y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "have \"(c_tr step out ?s [y], {(x', p). p \\<noteq> out (foldl step ?s [y]) x'})\n      \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\" (is \"(_, ?Y) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 xs) [y],\n     {(x', p).\n      p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by (rule c_tr_futures)"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 xs) [y],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"([?yp], ?Y) \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  (c_tr step out (foldl step s\\<^sub>0 xs) [y],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. ([(y, out (foldl step s\\<^sub>0 xs) y)],\n     {(x', p).\n      p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by (simp add: c_tr_hd_tl)"], ["proof (state)\nthis:\n  ([(y, out (foldl step s\\<^sub>0 xs) y)],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "moreover"], ["proof (state)\nthis:\n  ([(y, out (foldl step s\\<^sub>0 xs) y)],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "have \"(c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])),\n      {(x', p). p \\<noteq> out (foldl step ?s (c_ipurge I D (D x) (ys @ [x]))) x'})\n      \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\" (is \"(_, ?Z) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])),\n     {(x', p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 xs)\n            (c_ipurge I D (D x) (ys @ [x])))\n       x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by (rule c_tr_futures)"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])),\n   {(x', p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) (ys @ [x])))\n     x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "ultimately"], ["proof (chain)\npicking this:\n  ([(y, out (foldl step s\\<^sub>0 xs) y)],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])),\n   {(x', p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) (ys @ [x])))\n     x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)", "have \"(?yp # ipurge_tr I (c_dom D) (c_dom D ?yp)\n      (c_tr step out ?s (c_ipurge I D (D x) (ys @ [x]))),\n      ipurge_ref I (c_dom D) (c_dom D ?yp)\n      (c_tr step out ?s (c_ipurge I D (D x) (ys @ [x]))) ?Z)\n      \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\"\n     (is \"(_, ?X) \\<in> _\")"], ["proof (prove)\nusing this:\n  ([(y, out (foldl step s\\<^sub>0 xs) y)],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])),\n   {(x', p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) (ys @ [x])))\n     x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. ((y, out (foldl step s\\<^sub>0 xs) y) #\n     ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x]))),\n     ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))\n      {(x', p).\n       p \\<noteq>\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (ys @ [x])))\n        x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "using S"], ["proof (prove)\nusing this:\n  ([(y, out (foldl step s\\<^sub>0 xs) y)],\n   {(x', p). p \\<noteq> out (foldl step (foldl step s\\<^sub>0 xs) [y]) x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])),\n   {(x', p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) (ys @ [x])))\n     x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n  secure (c_process step out s\\<^sub>0) I (c_dom D)\n\ngoal (1 subgoal):\n 1. ((y, out (foldl step s\\<^sub>0 xs) y) #\n     ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x]))),\n     ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))\n      {(x', p).\n       p \\<noteq>\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (ys @ [x])))\n        x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  ((y, out (foldl step s\\<^sub>0 xs) y) #\n   ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x]))),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence C: \"(?yp # ipurge_tr I (c_dom D) (c_dom D ?yp)\n      (c_ipurge I (c_dom D) (D x)\n      (c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])))), ?X)\n      \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  ((y, out (foldl step s\\<^sub>0 xs) y) #\n   ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x]))),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. ((y, out (foldl step s\\<^sub>0 xs) y) #\n     ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_ipurge I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) (ys @ [x])))),\n     ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))\n      {(x', p).\n       p \\<noteq>\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (ys @ [x])))\n        x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by (simp add: c_tr_ipurge)"], ["proof (state)\nthis:\n  ((y, out (foldl step s\\<^sub>0 xs) y) #\n   ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_ipurge I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "assume D: \"D y \\<notin> c_sources I D (D x) (y # ys)\""], ["proof (state)\nthis:\n  D y \\<notin> c_sources I D (D x) (y # ys)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"D y \\<notin> c_sources I D (D x) ((y # ys) @ [x])\""], ["proof (prove)\nusing this:\n  D y \\<notin> c_sources I D (D x) (y # ys)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) ((y # ys) @ [x])", "by (subst c_sources_append_1)"], ["proof (state)\nthis:\n  D y \\<notin> c_sources I D (D x) ((y # ys) @ [x])\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"D y \\<notin> c_sources I D (D x) (y # ys @ [x])\""], ["proof (prove)\nusing this:\n  D y \\<notin> c_sources I D (D x) ((y # ys) @ [x])\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys @ [x])", "by simp"], ["proof (state)\nthis:\n  D y \\<notin> c_sources I D (D x) (y # ys @ [x])\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "moreover"], ["proof (state)\nthis:\n  D y \\<notin> c_sources I D (D x) (y # ys @ [x])\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "have \"c_sources I D (D x) (y # ys @ [x]) =\n      c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_sources I D (D x) (y # ys @ [x]) =\n    c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))", "by (simp add: c_sources_ipurge)"], ["proof (state)\nthis:\n  c_sources I D (D x) (y # ys @ [x]) =\n  c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "ultimately"], ["proof (chain)\npicking this:\n  D y \\<notin> c_sources I D (D x) (y # ys @ [x])\n  c_sources I D (D x) (y # ys @ [x]) =\n  c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))", "have \"D y \\<notin> c_sources I D (D x)\n      (y # c_ipurge I D (D x) (ys @ [x]))\""], ["proof (prove)\nusing this:\n  D y \\<notin> c_sources I D (D x) (y # ys @ [x])\n  c_sources I D (D x) (y # ys @ [x]) =\n  c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))", "by simp"], ["proof (state)\nthis:\n  D y \\<notin> c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "moreover"], ["proof (state)\nthis:\n  D y \\<notin> c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "have \"map fst (?yp # c_tr step out ?s\n      (c_ipurge I D (D x) (ys @ [x]))) =\n      y # c_ipurge I D (D x) (ys @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst\n     ((y, out (foldl step s\\<^sub>0 xs) y) #\n      c_tr step out (foldl step s\\<^sub>0 xs)\n       (c_ipurge I D (D x) (ys @ [x]))) =\n    y # c_ipurge I D (D x) (ys @ [x])", "by (simp add: c_tr_map)"], ["proof (state)\nthis:\n  map fst\n   ((y, out (foldl step s\\<^sub>0 xs) y) #\n    c_tr step out (foldl step s\\<^sub>0 xs)\n     (c_ipurge I D (D x) (ys @ [x]))) =\n  y # c_ipurge I D (D x) (ys @ [x])\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x])) =\n      c_sources I (c_dom D) (D x)\n      (?yp # c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])))\""], ["proof (prove)\nusing this:\n  map fst\n   ((y, out (foldl step s\\<^sub>0 xs) y) #\n    c_tr step out (foldl step s\\<^sub>0 xs)\n     (c_ipurge I D (D x) (ys @ [x]))) =\n  y # c_ipurge I D (D x) (ys @ [x])\n\ngoal (1 subgoal):\n 1. c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x])) =\n    c_sources I (c_dom D) (D x)\n     ((y, out (foldl step s\\<^sub>0 xs) y) #\n      c_tr step out (foldl step s\\<^sub>0 xs)\n       (c_ipurge I D (D x) (ys @ [x])))", "by (subst c_dom_sources, simp)"], ["proof (state)\nthis:\n  c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x])) =\n  c_sources I (c_dom D) (D x)\n   ((y, out (foldl step s\\<^sub>0 xs) y) #\n    c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "ultimately"], ["proof (chain)\npicking this:\n  D y \\<notin> c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\n  c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x])) =\n  c_sources I (c_dom D) (D x)\n   ((y, out (foldl step s\\<^sub>0 xs) y) #\n    c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])))", "have \"c_dom D ?yp \\<notin> c_sources I (c_dom D) (D x)\n      (?yp # c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])))\""], ["proof (prove)\nusing this:\n  D y \\<notin> c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x]))\n  c_sources I D (D x) (y # c_ipurge I D (D x) (ys @ [x])) =\n  c_sources I (c_dom D) (D x)\n   ((y, out (foldl step s\\<^sub>0 xs) y) #\n    c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])))\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step s\\<^sub>0 xs) y)\n    \\<notin> c_sources I (c_dom D) (D x)\n              ((y, out (foldl step s\\<^sub>0 xs) y) #\n               c_tr step out (foldl step s\\<^sub>0 xs)\n                (c_ipurge I D (D x) (ys @ [x])))", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  c_dom D (y, out (foldl step s\\<^sub>0 xs) y)\n  \\<notin> c_sources I (c_dom D) (D x)\n            ((y, out (foldl step s\\<^sub>0 xs) y) #\n             c_tr step out (foldl step s\\<^sub>0 xs)\n              (c_ipurge I D (D x) (ys @ [x])))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"ipurge_tr I (c_dom D) (c_dom D ?yp) (c_ipurge I (c_dom D) (D x)\n      (c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])))) =\n      c_ipurge I (c_dom D) (D x) (c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])))\""], ["proof (prove)\nusing this:\n  c_dom D (y, out (foldl step s\\<^sub>0 xs) y)\n  \\<notin> c_sources I (c_dom D) (D x)\n            ((y, out (foldl step s\\<^sub>0 xs) y) #\n             c_tr step out (foldl step s\\<^sub>0 xs)\n              (c_ipurge I D (D x) (ys @ [x])))\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n     (c_ipurge I (c_dom D) (D x)\n       (c_tr step out (foldl step s\\<^sub>0 xs)\n         (c_ipurge I D (D x) (ys @ [x])))) =\n    c_ipurge I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs)\n       (c_ipurge I D (D x) (ys @ [x])))", "by (rule c_ipurge_tr_ipurge)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n   (c_ipurge I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs)\n       (c_ipurge I D (D x) (ys @ [x])))) =\n  c_ipurge I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"(?yp # c_tr step out ?s (c_ipurge I D (D x) (ys @ [x])), ?X)\n      \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n   (c_ipurge I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs)\n       (c_ipurge I D (D x) (ys @ [x])))) =\n  c_ipurge I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])))\n\ngoal (1 subgoal):\n 1. ((y, out (foldl step s\\<^sub>0 xs) y) #\n     c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])),\n     ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))\n      {(x', p).\n       p \\<noteq>\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (ys @ [x])))\n        x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n   (c_ipurge I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs)\n       (c_ipurge I D (D x) (ys @ [x])))) =\n  c_ipurge I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])))\n  ((y, out (foldl step s\\<^sub>0 xs) y) #\n   ipurge_tr I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_ipurge I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. ((y, out (foldl step s\\<^sub>0 xs) y) #\n     c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])),\n     ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))\n      {(x', p).\n       p \\<noteq>\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (ys @ [x])))\n        x'})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 xs)", "by (simp add: c_tr_ipurge)"], ["proof (state)\nthis:\n  ((y, out (foldl step s\\<^sub>0 xs) y) #\n   c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"(c_tr step out s\\<^sub>0 xs @ ?yp #\n      c_tr step out ?s (c_ipurge I D (D x) ys @ [x]), ?X)\n      \\<in> c_failures step out s\\<^sub>0\"\n     (is \"(?xps, _) \\<in> _\")"], ["proof (prove)\nusing this:\n  ((y, out (foldl step s\\<^sub>0 xs) y) #\n   c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (ys @ [x])),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 xs)\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 xs @\n     (y, out (foldl step s\\<^sub>0 xs) y) #\n     c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys @ [x]),\n     ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n      (c_tr step out (foldl step s\\<^sub>0 xs)\n        (c_ipurge I D (D x) (ys @ [x])))\n      {(x', p).\n       p \\<noteq>\n       out (foldl step (foldl step s\\<^sub>0 xs)\n             (c_ipurge I D (D x) (ys @ [x])))\n        x'})\n    \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures c_ipurge_append_1)"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs @\n   (y, out (foldl step s\\<^sub>0 xs) y) #\n   c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys @ [x]),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "moreover"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 xs @\n   (y, out (foldl step s\\<^sub>0 xs) y) #\n   c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys @ [x]),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "have \"?xps \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_tr step out s\\<^sub>0 xs @\n    (y, out (foldl step s\\<^sub>0 xs) y) #\n    c_tr step out (foldl step s\\<^sub>0 xs)\n     (c_ipurge I D (D x) ys @ [x]) \\<noteq>\n    []", "by simp"], ["proof (state)\nthis:\n  c_tr step out s\\<^sub>0 xs @\n  (y, out (foldl step s\\<^sub>0 xs) y) #\n  c_tr step out (foldl step s\\<^sub>0 xs)\n   (c_ipurge I D (D x) ys @ [x]) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "ultimately"], ["proof (chain)\npicking this:\n  (c_tr step out s\\<^sub>0 xs @\n   (y, out (foldl step s\\<^sub>0 xs) y) #\n   c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys @ [x]),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> c_failures step out s\\<^sub>0\n  c_tr step out s\\<^sub>0 xs @\n  (y, out (foldl step s\\<^sub>0 xs) y) #\n  c_tr step out (foldl step s\\<^sub>0 xs)\n   (c_ipurge I D (D x) ys @ [x]) \\<noteq>\n  []", "have \"snd (last ?xps) =\n      out (foldl step s\\<^sub>0 (butlast (map fst ?xps))) (last (map fst ?xps))\""], ["proof (prove)\nusing this:\n  (c_tr step out s\\<^sub>0 xs @\n   (y, out (foldl step s\\<^sub>0 xs) y) #\n   c_tr step out (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) ys @ [x]),\n   ipurge_ref I (c_dom D) (c_dom D (y, out (foldl step s\\<^sub>0 xs) y))\n    (c_tr step out (foldl step s\\<^sub>0 xs)\n      (c_ipurge I D (D x) (ys @ [x])))\n    {(x', p).\n     p \\<noteq>\n     out (foldl step (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) (ys @ [x])))\n      x'})\n  \\<in> c_failures step out s\\<^sub>0\n  c_tr step out s\\<^sub>0 xs @\n  (y, out (foldl step s\\<^sub>0 xs) y) #\n  c_tr step out (foldl step s\\<^sub>0 xs)\n   (c_ipurge I D (D x) ys @ [x]) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. snd (last\n          (c_tr step out s\\<^sub>0 xs @\n           (y, out (foldl step s\\<^sub>0 xs) y) #\n           c_tr step out (foldl step s\\<^sub>0 xs)\n            (c_ipurge I D (D x) ys @ [x]))) =\n    out (foldl step s\\<^sub>0\n          (butlast\n            (map fst\n              (c_tr step out s\\<^sub>0 xs @\n               (y, out (foldl step s\\<^sub>0 xs) y) #\n               c_tr step out (foldl step s\\<^sub>0 xs)\n                (c_ipurge I D (D x) ys @ [x])))))\n     (last\n       (map fst\n         (c_tr step out s\\<^sub>0 xs @\n          (y, out (foldl step s\\<^sub>0 xs) y) #\n          c_tr step out (foldl step s\\<^sub>0 xs)\n           (c_ipurge I D (D x) ys @ [x]))))", "by (rule c_failures_last)"], ["proof (state)\nthis:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step s\\<^sub>0\n        (butlast\n          (map fst\n            (c_tr step out s\\<^sub>0 xs @\n             (y, out (foldl step s\\<^sub>0 xs) y) #\n             c_tr step out (foldl step s\\<^sub>0 xs)\n              (c_ipurge I D (D x) ys @ [x])))))\n   (last\n     (map fst\n       (c_tr step out s\\<^sub>0 xs @\n        (y, out (foldl step s\\<^sub>0 xs) y) #\n        c_tr step out (foldl step s\\<^sub>0 xs)\n         (c_ipurge I D (D x) ys @ [x]))))\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "hence \"snd (last ?xps) =\n      out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys)) x\""], ["proof (prove)\nusing this:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step s\\<^sub>0\n        (butlast\n          (map fst\n            (c_tr step out s\\<^sub>0 xs @\n             (y, out (foldl step s\\<^sub>0 xs) y) #\n             c_tr step out (foldl step s\\<^sub>0 xs)\n              (c_ipurge I D (D x) ys @ [x])))))\n   (last\n     (map fst\n       (c_tr step out s\\<^sub>0 xs @\n        (y, out (foldl step s\\<^sub>0 xs) y) #\n        c_tr step out (foldl step s\\<^sub>0 xs)\n         (c_ipurge I D (D x) ys @ [x]))))\n\ngoal (1 subgoal):\n 1. snd (last\n          (c_tr step out s\\<^sub>0 xs @\n           (y, out (foldl step s\\<^sub>0 xs) y) #\n           c_tr step out (foldl step s\\<^sub>0 xs)\n            (c_ipurge I D (D x) ys @ [x]))) =\n    out (foldl step (foldl step s\\<^sub>0 (xs @ [y]))\n          (c_ipurge I D (D x) ys))\n     x", "by (simp add: c_tr_map butlast_append)"], ["proof (state)\nthis:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "moreover"], ["proof (state)\nthis:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "have \"snd (last ?xps) =\n      out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (last\n          (c_tr step out s\\<^sub>0 xs @\n           (y, out (foldl step s\\<^sub>0 xs) y) #\n           c_tr step out (foldl step s\\<^sub>0 xs)\n            (c_ipurge I D (D x) ys @ [x]))) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "using D"], ["proof (prove)\nusing this:\n  D y \\<notin> c_sources I D (D x) (y # ys)\n\ngoal (1 subgoal):\n 1. snd (last\n          (c_tr step out s\\<^sub>0 xs @\n           (y, out (foldl step s\\<^sub>0 xs) y) #\n           c_tr step out (foldl step s\\<^sub>0 xs)\n            (c_ipurge I D (D x) ys @ [x]))) =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "by simp"], ["proof (state)\nthis:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\n\ngoal (1 subgoal):\n 1. D y \\<notin> c_sources I D (D x) (y # ys) \\<Longrightarrow>\n    out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "ultimately"], ["proof (chain)\npicking this:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "using A"], ["proof (prove)\nusing this:\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n  snd (last\n        (c_tr step out s\\<^sub>0 xs @\n         (y, out (foldl step s\\<^sub>0 xs) y) #\n         c_tr step out (foldl step s\\<^sub>0 xs)\n          (c_ipurge I D (D x) ys @ [x]))) =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) ys) x =\n  out (foldl step (foldl step s\\<^sub>0 (xs @ [y])) (c_ipurge I D (D x) ys))\n   x\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n    out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys)))\n     x", "by simp"], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 xs) (y # ys)) x =\n  out (foldl step (foldl step s\\<^sub>0 xs) (c_ipurge I D (D x) (y # ys))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem secure_implies_c_secure:\n  assumes S: \"secure (c_process step out s\\<^sub>0) I (c_dom D)\"\n  shows \"c_secure step out s\\<^sub>0 I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_secure step out s\\<^sub>0 I D", "proof (simp add: c_secure_def, (rule allI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       out (foldl step s\\<^sub>0 xs) x =\n       out (foldl step s\\<^sub>0 (c_ipurge I D (D x) xs)) x", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       out (foldl step s\\<^sub>0 xs) x =\n       out (foldl step s\\<^sub>0 (c_ipurge I D (D x) xs)) x", "have \"out (foldl step (foldl step s\\<^sub>0 []) xs) x =\n    out (foldl step (foldl step s\\<^sub>0 []) (c_ipurge I D (D x) xs)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 []) xs) x =\n    out (foldl step (foldl step s\\<^sub>0 []) (c_ipurge I D (D x) xs)) x", "using S"], ["proof (prove)\nusing this:\n  secure (c_process step out s\\<^sub>0) I (c_dom D)\n\ngoal (1 subgoal):\n 1. out (foldl step (foldl step s\\<^sub>0 []) xs) x =\n    out (foldl step (foldl step s\\<^sub>0 []) (c_ipurge I D (D x) xs)) x", "by (rule secure_implies_c_secure_aux)"], ["proof (state)\nthis:\n  out (foldl step (foldl step s\\<^sub>0 []) xs) x =\n  out (foldl step (foldl step s\\<^sub>0 []) (c_ipurge I D (D x) xs)) x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       out (foldl step s\\<^sub>0 xs) x =\n       out (foldl step s\\<^sub>0 (c_ipurge I D (D x) xs)) x", "thus \"out (foldl step s\\<^sub>0 xs) x = out (foldl step s\\<^sub>0 (c_ipurge I D (D x) xs)) x\""], ["proof (prove)\nusing this:\n  out (foldl step (foldl step s\\<^sub>0 []) xs) x =\n  out (foldl step (foldl step s\\<^sub>0 []) (c_ipurge I D (D x) xs)) x\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 xs) x =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D x) xs)) x", "by simp"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 xs) x =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) xs)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_secure_futures_1:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"(yps @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yps @ [yp], Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (simp add: c_futures_failures)"], ["proof (state)\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "let ?zs = \"map fst (xps @ yps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "let ?y = \"fst yp\""], ["proof (state)\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "assume A: \"(xps @ yps @ [yp], Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps @ yps @ [yp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"((xps @ yps) @ [yp], Y) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\nusing this:\n  (xps @ yps @ [yp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. ((xps @ yps) @ [yp], Y) \\<in> failures (c_process step out s\\<^sub>0)", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  ((xps @ yps) @ [yp], Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"(xps @ yps, {}) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\nusing this:\n  ((xps @ yps) @ [yp], Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ yps, {}) \\<in> failures (c_process step out s\\<^sub>0)", "by (rule process_rule_2_failures)"], ["proof (state)\nthis:\n  (xps @ yps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "hence \"(xps @ yps, {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ yps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ yps, {}) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (xps @ yps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "hence B: \"xps @ yps = c_tr step out s\\<^sub>0 ?zs\""], ["proof (prove)\nusing this:\n  (xps @ yps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps @ yps = c_tr step out s\\<^sub>0 (map fst (xps @ yps))", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps @ yps = c_tr step out s\\<^sub>0 (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "have \"Y \\<subseteq> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps @ [yp]))) x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<subseteq> {(x, p).\n                   p \\<noteq>\n                   out (foldl step s\\<^sub>0 (map fst (xps @ yps @ [yp])))\n                    x}", "using A"], ["proof (prove)\nusing this:\n  (xps @ yps @ [yp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {(x, p).\n                   p \\<noteq>\n                   out (foldl step s\\<^sub>0 (map fst (xps @ yps @ [yp])))\n                    x}", "by (rule c_failures_ref)"], ["proof (state)\nthis:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps @ [yp]))) x}\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "hence C: \"Y \\<subseteq> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (?zs @ [?y])) x}\"\n   (is \"_ \\<subseteq> ?Y'\")"], ["proof (prove)\nusing this:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps @ [yp]))) x}\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {(x, p).\n                   p \\<noteq>\n                   out (foldl step s\\<^sub>0\n                         (map fst (xps @ yps) @ [fst yp]))\n                    x}", "by simp"], ["proof (state)\nthis:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                  x}\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "have \"(xps @ yps, {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 ?zs) x}) \\<in> c_failures step out s\\<^sub>0\"\n   (is \"(_, ?X') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yps,\n     {(x, p).\n      p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x})\n    \\<in> c_failures step out s\\<^sub>0", "by (subst B, rule c_tr_failures)"], ["proof (state)\nthis:\n  (xps @ yps,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (xps @ yps,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "have \"{x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I} \\<subseteq> ?X'\" (is \"?X \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n    \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}", "proof (rule subsetI, simp add: split_paired_all c_dom_def del: map_append,\n   erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "fix x p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "assume \"(x, p) \\<in> Y\""], ["proof (state)\nthis:\n  (x, p) \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "with C"], ["proof (chain)\npicking this:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                  x}\n  (x, p) \\<in> Y", "have \"(x, p) \\<in> ?Y'\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                  x}\n  (x, p) \\<in> Y\n\ngoal (1 subgoal):\n 1. (x, p)\n    \\<in> {(x, p).\n           p \\<noteq>\n           out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x}", ".."], ["proof (state)\nthis:\n  (x, p)\n  \\<in> {(x, p).\n         p \\<noteq>\n         out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0 (?zs @ [?y])) x\""], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x, p).\n         p \\<noteq>\n         out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "have \"out (foldl step s\\<^sub>0 (?zs @ [?y])) x =\n      out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (?zs @ [?y]))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n     x", "using S"], ["proof (prove)\nusing this:\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n     x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (?zs @ [?y]))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n     x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "assume \"(D ?y, D x) \\<notin> I\""], ["proof (state)\nthis:\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "with R"], ["proof (chain)\npicking this:\n  refl I\n  (D (fst yp), D x) \\<notin> I", "have \"c_ipurge I D (D x) (?zs @ [?y]) = c_ipurge I D (D x) ?zs\""], ["proof (prove)\nusing this:\n  refl I\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n    c_ipurge I D (D x) (map fst (xps @ yps))", "by (rule c_ipurge_append_2)"], ["proof (state)\nthis:\n  c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n  c_ipurge I D (D x) (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n  c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n  c_ipurge I D (D x) (map fst (xps @ yps))", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x) ?zs)) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n  c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n  c_ipurge I D (D x) (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "have \"out (foldl step s\\<^sub>0 (c_ipurge I D (D x) ?zs)) x =\n      out (foldl step s\\<^sub>0 ?zs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps))))\n     x =\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x", "using S"], ["proof (prove)\nusing this:\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps))))\n     x =\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x =\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0 (map fst (xps @ yps))) a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x =\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x", "show \"p \\<noteq> out (foldl step s\\<^sub>0 ?zs) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x =\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], Y)\n    \\<in> c_failures step out s\\<^sub>0 \\<Longrightarrow>\n    (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ yps,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x})\n  \\<in> c_failures step out s\\<^sub>0\n  {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}", "show \"(xps @ yps, ?X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ yps,\n   {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x})\n  \\<in> c_failures step out s\\<^sub>0\n  {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n\ngoal (1 subgoal):\n 1. (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps @ yps, {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_secure_implies_secure_aux_1 [rule_format]:\n  assumes\n    R: \"refl I\" and\n    S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"(yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n    ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yp # yps, Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (induction yps arbitrary: Y rule: length_induct, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs Y.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (yp # ys, x)\n                       \\<in> futures (c_process step out s\\<^sub>0)\n                              xps \\<longrightarrow>\n                       (ipurge_tr I (c_dom D) (c_dom D yp) ys,\n                        ipurge_ref I (c_dom D) (c_dom D yp) ys x)\n                       \\<in> futures (c_process step out s\\<^sub>0) xps);\n        (yp # xs, Y)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (c_dom D) (c_dom D yp) xs,\n                          ipurge_ref I (c_dom D) (c_dom D yp) xs Y)\n                         \\<in> futures (c_process step out s\\<^sub>0) xps", "fix yps Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs Y.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (yp # ys, x)\n                       \\<in> futures (c_process step out s\\<^sub>0)\n                              xps \\<longrightarrow>\n                       (ipurge_tr I (c_dom D) (c_dom D yp) ys,\n                        ipurge_ref I (c_dom D) (c_dom D yp) ys x)\n                       \\<in> futures (c_process step out s\\<^sub>0) xps);\n        (yp # xs, Y)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (c_dom D) (c_dom D yp) xs,\n                          ipurge_ref I (c_dom D) (c_dom D yp) xs Y)\n                         \\<in> futures (c_process step out s\\<^sub>0) xps", "assume\n    A: \"\\<forall>yps'. length yps' < length yps \\<longrightarrow>\n      (\\<forall>Y'. (yp # yps', Y') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp) yps',\n      ipurge_ref I (c_dom D) (c_dom D yp) yps' Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\" and\n    B: \"(yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (state)\nthis:\n  \\<forall>yps'.\n     length yps' < length yps \\<longrightarrow>\n     (\\<forall>Y'.\n         (yp # yps', Y')\n         \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n         (ipurge_tr I (c_dom D) (c_dom D yp) yps',\n          ipurge_ref I (c_dom D) (c_dom D yp) yps' Y')\n         \\<in> futures (c_process step out s\\<^sub>0) xps)\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>xs Y.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (yp # ys, x)\n                       \\<in> futures (c_process step out s\\<^sub>0)\n                              xps \\<longrightarrow>\n                       (ipurge_tr I (c_dom D) (c_dom D yp) ys,\n                        ipurge_ref I (c_dom D) (c_dom D yp) ys x)\n                       \\<in> futures (c_process step out s\\<^sub>0) xps);\n        (yp # xs, Y)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (c_dom D) (c_dom D yp) xs,\n                          ipurge_ref I (c_dom D) (c_dom D yp) xs Y)\n                         \\<in> futures (c_process step out s\\<^sub>0) xps", "show \"(ipurge_tr I (c_dom D) (c_dom D yp) yps,\n    ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (cases yps, simp add: ipurge_ref_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. yps = [] \\<Longrightarrow>\n    ([], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "case Nil"], ["proof (state)\nthis:\n  yps = []\n\ngoal (2 subgoals):\n 1. yps = [] \\<Longrightarrow>\n    ([], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"([] @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  yps = []\n\ngoal (1 subgoal):\n 1. ([] @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "using B"], ["proof (prove)\nusing this:\n  yps = []\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([] @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  ([] @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. yps = [] \\<Longrightarrow>\n    ([], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "with R and S"], ["proof (chain)\npicking this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  ([] @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "show \"([], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n      \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  ([] @ [yp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule c_secure_futures_1)"], ["proof (state)\nthis:\n  ([], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "case Cons"], ["proof (state)\nthis:\n  yps = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"\\<exists>wps wp. yps = wps @ [wp]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>wps wp. yps = wps @ [wp]", "by (rule rev_cases [of yps], simp_all add: Cons)"], ["proof (state)\nthis:\n  \\<exists>wps wp. yps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "then"], ["proof (chain)\npicking this:\n  \\<exists>wps wp. yps = wps @ [wp]", "obtain wps and wp where C: \"yps = wps @ [wp]\""], ["proof (prove)\nusing this:\n  \\<exists>wps wp. yps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. (\\<And>wps wp.\n        yps = wps @ [wp] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  yps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "have B': \"((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "using B and C"], ["proof (prove)\nusing this:\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n  yps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       yps = a # list \\<Longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n        ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (simp only: C,\n     cases \"c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?Y' = \"{x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I}\""], ["proof (state)\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"length wps < length yps \\<longrightarrow>\n        (\\<forall>Y'. (yp # wps, Y') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length wps < length yps \\<longrightarrow>\n    (\\<forall>Y'.\n        (yp # wps, Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n         ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", "using A"], ["proof (prove)\nusing this:\n  \\<forall>yps'.\n     length yps' < length yps \\<longrightarrow>\n     (\\<forall>Y'.\n         (yp # yps', Y')\n         \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n         (ipurge_tr I (c_dom D) (c_dom D yp) yps',\n          ipurge_ref I (c_dom D) (c_dom D yp) yps' Y')\n         \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. length wps < length yps \\<longrightarrow>\n    (\\<forall>Y'.\n        (yp # wps, Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n         ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", ".."], ["proof (state)\nthis:\n  length wps < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp # wps, Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  length wps < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp # wps, Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"length wps < length yps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length wps < length yps", "using C"], ["proof (prove)\nusing this:\n  yps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. length wps < length yps", "by simp"], ["proof (state)\nthis:\n  length wps < length yps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  length wps < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp # wps, Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length wps < length yps", "have \"\\<forall>Y'.\n        (yp # wps, Y') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  length wps < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp # wps, Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length wps < length yps\n\ngoal (1 subgoal):\n 1. \\<forall>Y'.\n       (yp # wps, Y')\n       \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n       \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  \\<forall>Y'.\n     (yp # wps, Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n      ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"(yp # wps, ?Y') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps ?Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  \\<forall>Y'.\n     (yp # wps, Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n      ipurge_ref I (c_dom D) (c_dom D yp) wps Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n     ipurge_ref I (c_dom D) (c_dom D yp) wps\n      {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(yp # wps, ?Y') \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using R and S and B'"], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule c_secure_futures_1)"], ["proof (state)\nthis:\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps ?Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (yp # wps, {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n     ipurge_ref I (c_dom D) (c_dom D yp) wps\n      {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "assume\n        D: \"c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\""], ["proof (state)\nthis:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        ipurge_tr I (c_dom D) (c_dom D yp) wps\""], ["proof (prove)\nusing this:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp) wps", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y =\n        ipurge_ref I (c_dom D) (c_dom D yp) wps ?Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y =\n    ipurge_ref I (c_dom D) (c_dom D yp) wps\n     {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I}", "using D"], ["proof (prove)\nusing this:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y =\n    ipurge_ref I (c_dom D) (c_dom D yp) wps\n     {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I}", "by (rule ipurge_ref_eq)"], ["proof (state)\nthis:\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y =\n  ipurge_ref I (c_dom D) (c_dom D yp) wps\n   {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I}\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y =\n  ipurge_ref I (c_dom D) (c_dom D yp) wps\n   {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I}", "show \"(ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n        ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y =\n  ipurge_ref I (c_dom D) (c_dom D yp) wps\n   {x \\<in> Y. (c_dom D wp, c_dom D x) \\<notin> I}\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?xs = \"map fst xps\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?y = \"fst yp\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?ws = \"map fst wps\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?w = \"fst wp\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?s = \"foldl step s\\<^sub>0 ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(xps @ yp # wps @ [wp], Y) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yp # wps @ [wp], Y) \\<in> failures (c_process step out s\\<^sub>0)", "using B'"], ["proof (prove)\nusing this:\n  ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (xps @ yp # wps @ [wp], Y) \\<in> failures (c_process step out s\\<^sub>0)", "by (simp add: c_futures_failures c_failures_failures)"], ["proof (state)\nthis:\n  (xps @ yp # wps @ [wp], Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"(xps, {}) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\nusing this:\n  (xps @ yp # wps @ [wp], Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps, {}) \\<in> failures (c_process step out s\\<^sub>0)", "by (rule process_rule_2_failures)"], ["proof (state)\nthis:\n  (xps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"(xps, {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps, {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps, {}) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (xps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence X: \"xps = c_tr step out s\\<^sub>0 ?xs\""], ["proof (prove)\nusing this:\n  (xps, {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps = c_tr step out s\\<^sub>0 (map fst xps)", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have W: \"(yp # wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yp # wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "using B'"], ["proof (prove)\nusing this:\n  ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp # wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  (yp # wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"yp # wps = c_tr step out ?s (map fst (yp # wps))\""], ["proof (prove)\nusing this:\n  (yp # wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. yp # wps =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst (yp # wps))", "by (rule c_futures_tr)"], ["proof (state)\nthis:\n  yp # wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst (yp # wps))\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence W': \"yp # wps = c_tr step out ?s (?y # ?ws)\""], ["proof (prove)\nusing this:\n  yp # wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst (yp # wps))\n\ngoal (1 subgoal):\n 1. yp # wps =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (fst yp # map fst wps)", "by simp"], ["proof (state)\nthis:\n  yp # wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (fst yp # map fst wps)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "assume D: \"c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\""], ["proof (state)\nthis:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        ipurge_tr I (c_dom D) (c_dom D yp) (yp # wps) @ [wp]\""], ["proof (prove)\nusing this:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp) (yp # wps) @ [wp]", "using R"], ["proof (prove)\nusing this:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n  refl I\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp) (yp # wps) @ [wp]", "by (simp add: ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) (yp # wps) @ [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        ipurge_tr I (c_dom D) (c_dom D yp) (c_tr step out ?s (?y # ?ws)) @ [wp]\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) (yp # wps) @ [wp]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (fst yp # map fst wps)) @\n    [wp]", "using W'"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) (yp # wps) @ [wp]\n  yp # wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (fst yp # map fst wps)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (fst yp # map fst wps)) @\n    [wp]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (fst yp # map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "also"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (fst yp # map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"\\<dots> =\n        c_tr step out ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws)) @ [wp]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (fst yp # map fst wps)) @\n    [wp] =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n    [wp]", "proof (simp, rule c_tr_ipurge_tr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (fst yp # map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n              (take n (fst yp # map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (fst yp # map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n              (take n (fst yp # map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "show \"\\<exists>W. (ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out ?s (take n (?y # ?ws))), W)\n          \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>W.\n       (ipurge_tr I (c_dom D) (c_dom D yp)\n         (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n           (take n (fst yp # map fst wps))),\n        W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps))", "proof (cases n, simp_all add: c_tr_hd_tl)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>W.\n       ([], W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "have \"(c_tr step out ?s [], {(x, p). p \\<noteq> out (foldl step ?s []) x})\n            \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [],\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps)) []) x})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps))", "by (rule c_tr_futures)"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [],\n   {(x, p).\n    p \\<noteq> out (foldl step (foldl step s\\<^sub>0 (map fst xps)) []) x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>W.\n       ([], W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "hence \"([], {(x, p). p \\<noteq> out ?s x})\n            \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\""], ["proof (prove)\nusing this:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [],\n   {(x, p).\n    p \\<noteq> out (foldl step (foldl step s\\<^sub>0 (map fst xps)) []) x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. ([], {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps))", "by simp"], ["proof (state)\nthis:\n  ([], {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>W.\n       ([], W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "thus \"\\<exists>W. ([], W)\n            \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\""], ["proof (prove)\nusing this:\n  ([], {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (map fst xps)) x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. \\<exists>W.\n       ([], W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps))", ".."], ["proof (state)\nthis:\n  \\<exists>W.\n     ([], W)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "case (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "let ?wps' = \"c_tr step out (step ?s ?y) (take m ?ws)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "have \"length ?wps' < length yps \\<longrightarrow>\n            (\\<forall>Y'. (yp # ?wps', Y') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n            (ipurge_tr I (c_dom D) (c_dom D yp) ?wps',\n            ipurge_ref I (c_dom D) (c_dom D yp) ?wps' Y')\n            \\<in> futures (c_process step out s\\<^sub>0) xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))\n    < length yps \\<longrightarrow>\n    (\\<forall>Y'.\n        (yp #\n         c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps)),\n         Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out\n            (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n            (take m (map fst wps))),\n         ipurge_ref I (c_dom D) (c_dom D yp)\n          (c_tr step out\n            (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n            (take m (map fst wps)))\n          Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", "using A"], ["proof (prove)\nusing this:\n  \\<forall>yps'.\n     length yps' < length yps \\<longrightarrow>\n     (\\<forall>Y'.\n         (yp # yps', Y')\n         \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n         (ipurge_tr I (c_dom D) (c_dom D yp) yps',\n          ipurge_ref I (c_dom D) (c_dom D yp) yps' Y')\n         \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))\n    < length yps \\<longrightarrow>\n    (\\<forall>Y'.\n        (yp #\n         c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps)),\n         Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out\n            (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n            (take m (map fst wps))),\n         ipurge_ref I (c_dom D) (c_dom D yp)\n          (c_tr step out\n            (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n            (take m (map fst wps)))\n          Y')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", ".."], ["proof (state)\nthis:\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp #\n       c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)),\n       Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps)))\n        Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "moreover"], ["proof (state)\nthis:\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp #\n       c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)),\n       Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps)))\n        Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "have \"length ?wps' < length yps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))\n    < length yps", "using C"], ["proof (prove)\nusing this:\n  yps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))\n    < length yps", "by (simp add: c_tr_length)"], ["proof (state)\nthis:\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "ultimately"], ["proof (chain)\npicking this:\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp #\n       c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)),\n       Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps)))\n        Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps", "have \"\\<forall>Y'.\n            (yp # ?wps', Y') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n            (ipurge_tr I (c_dom D) (c_dom D yp) ?wps',\n            ipurge_ref I (c_dom D) (c_dom D yp) ?wps' Y')\n            \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps \\<longrightarrow>\n  (\\<forall>Y'.\n      (yp #\n       c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)),\n       Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n          (take m (map fst wps)))\n        Y')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  < length yps\n\ngoal (1 subgoal):\n 1. \\<forall>Y'.\n       (yp #\n        c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n         (take m (map fst wps)),\n        Y')\n       \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n       (ipurge_tr I (c_dom D) (c_dom D yp)\n         (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n           (take m (map fst wps))),\n        ipurge_ref I (c_dom D) (c_dom D yp)\n         (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n           (take m (map fst wps)))\n         Y')\n       \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  \\<forall>Y'.\n     (yp #\n      c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)),\n      Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (ipurge_tr I (c_dom D) (c_dom D yp)\n       (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n         (take m (map fst wps))),\n      ipurge_ref I (c_dom D) (c_dom D yp)\n       (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n         (take m (map fst wps)))\n       Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "hence \"(yp # ?wps', {}) \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n            (ipurge_tr I (c_dom D) (c_dom D yp) ?wps',\n            ipurge_ref I (c_dom D) (c_dom D yp) ?wps' {})\n            \\<in> futures (c_process step out s\\<^sub>0) xps\"\n           (is \"_ \\<longrightarrow> (_, ?W') \\<in> _\")"], ["proof (prove)\nusing this:\n  \\<forall>Y'.\n     (yp #\n      c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)),\n      Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (ipurge_tr I (c_dom D) (c_dom D yp)\n       (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n         (take m (map fst wps))),\n      ipurge_ref I (c_dom D) (c_dom D yp)\n       (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n         (take m (map fst wps)))\n       Y')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp #\n     c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "moreover"], ["proof (state)\nthis:\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "have E: \"yp # wps = (?y, out ?s ?y) #\n            c_tr step out (step ?s ?y) (take m ?ws @ drop m ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yp # wps =\n    (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps) @ drop m (map fst wps))", "using W'"], ["proof (prove)\nusing this:\n  yp # wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (fst yp # map fst wps)\n\ngoal (1 subgoal):\n 1. yp # wps =\n    (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps) @ drop m (map fst wps))", "by (simp add: c_tr_hd_tl)"], ["proof (state)\nthis:\n  yp # wps =\n  (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n  c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n   (take m (map fst wps) @ drop m (map fst wps))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "hence F: \"yp = (?y, out ?s ?y)\""], ["proof (prove)\nusing this:\n  yp # wps =\n  (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n  c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n   (take m (map fst wps) @ drop m (map fst wps))\n\ngoal (1 subgoal):\n 1. yp = (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp))", "by simp"], ["proof (state)\nthis:\n  yp = (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "hence \"yp # wps = yp # ?wps' @\n            c_tr step out (foldl step (step ?s ?y) (take m ?ws)) (drop m ?ws)\""], ["proof (prove)\nusing this:\n  yp = (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n\ngoal (1 subgoal):\n 1. yp # wps =\n    yp #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)) @\n    c_tr step out\n     (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))\n     (drop m (map fst wps))", "using E"], ["proof (prove)\nusing this:\n  yp = (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n  yp # wps =\n  (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n  c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n   (take m (map fst wps) @ drop m (map fst wps))\n\ngoal (1 subgoal):\n 1. yp # wps =\n    yp #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)) @\n    c_tr step out\n     (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))\n     (drop m (map fst wps))", "by (simp only: c_tr_append)"], ["proof (state)\nthis:\n  yp # wps =\n  yp #\n  c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n   (take m (map fst wps)) @\n  c_tr step out\n   (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n   (drop m (map fst wps))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "hence \"((yp # ?wps') @\n            c_tr step out (foldl step (step ?s ?y) (take m ?ws)) (drop m ?ws), {})\n            \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  yp # wps =\n  yp #\n  c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n   (take m (map fst wps)) @\n  c_tr step out\n   (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n   (drop m (map fst wps))\n\ngoal (1 subgoal):\n 1. ((yp #\n      c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps))) @\n     c_tr step out\n      (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)))\n      (drop m (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using W"], ["proof (prove)\nusing this:\n  yp # wps =\n  yp #\n  c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n   (take m (map fst wps)) @\n  c_tr step out\n   (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n   (drop m (map fst wps))\n  (yp # wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ((yp #\n      c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps))) @\n     c_tr step out\n      (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)))\n      (drop m (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  ((yp #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps))) @\n   c_tr step out\n    (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    (drop m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "hence \"(yp # ?wps', {}) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  ((yp #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps))) @\n   c_tr step out\n    (foldl step (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    (drop m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp #\n     c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "ultimately"], ["proof (chain)\npicking this:\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(ipurge_tr I (c_dom D) (c_dom D yp) ?wps', ?W')\n            \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (yp #\n   c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n    (take m (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "moreover"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "have \"ipurge_tr I (c_dom D) (c_dom D yp) ?wps' =\n            ipurge_tr I (c_dom D) (c_dom D yp) ((?y, out ?s ?y) # ?wps')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps))) =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n      c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))", "using R and F"], ["proof (prove)\nusing this:\n  refl I\n  yp = (fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps))) =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n      c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n       (take m (map fst wps)))", "by (simp add: ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps))) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "ultimately"], ["proof (chain)\npicking this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps))) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))", "have\n            \"(ipurge_tr I (c_dom D) (c_dom D yp) ((?y, out ?s ?y) # ?wps'), ?W')\n            \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps))) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp)\n      ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n       c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps))", "using X"], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps))) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n    c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n     (take m (map fst wps)))\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp)\n      ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n       c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n        (take m (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps))", "by simp"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n     c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>W.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n             c_tr step out\n              (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n              (take nat (map fst wps))),\n           W)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps))", "thus \"\\<exists>W.\n            (ipurge_tr I (c_dom D) (c_dom D yp) ((?y, out ?s ?y) # ?wps'), W)\n            \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n     c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n      (take m (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. \\<exists>W.\n       (ipurge_tr I (c_dom D) (c_dom D yp)\n         ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n          c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n           (take m (map fst wps))),\n        W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps))", "by (rule_tac x = ?W' in exI)"], ["proof (state)\nthis:\n  \\<exists>W.\n     (ipurge_tr I (c_dom D) (c_dom D yp)\n       ((fst yp, out (foldl step s\\<^sub>0 (map fst xps)) (fst yp)) #\n        c_tr step out (step (foldl step s\\<^sub>0 (map fst xps)) (fst yp))\n         (take m (map fst wps))),\n      W)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>W.\n     (ipurge_tr I (c_dom D) (c_dom D yp)\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n         (take n (fst yp # map fst wps))),\n      W)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (fst yp # map fst wps)) @\n  [wp] =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [wp]", "have E: \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws)) @ [wp]\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n    [wp]", "."], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\"\n       (is \"(?xps', _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0", "using B'"], ["proof (prove)\nusing this:\n  ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"?xps' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xps @ yp # wps @ [wp] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xps @ yp # wps @ [wp] \\<noteq> []\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\n  xps @ yp # wps @ [wp] \\<noteq> []", "have \"snd (last ?xps') =\n        out (foldl step s\\<^sub>0 (butlast (map fst ?xps'))) (last (map fst ?xps'))\""], ["proof (prove)\nusing this:\n  (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\n  xps @ yp # wps @ [wp] \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (last (xps @ yp # wps @ [wp])) =\n    out (foldl step s\\<^sub>0 (butlast (map fst (xps @ yp # wps @ [wp]))))\n     (last (map fst (xps @ yp # wps @ [wp])))", "by (rule c_failures_last)"], ["proof (state)\nthis:\n  snd (last (xps @ yp # wps @ [wp])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (xps @ yp # wps @ [wp]))))\n   (last (map fst (xps @ yp # wps @ [wp])))\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp = out (foldl step s\\<^sub>0 (?xs @ ?y # ?ws)) ?w\""], ["proof (prove)\nusing this:\n  snd (last (xps @ yp # wps @ [wp])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (xps @ yp # wps @ [wp]))))\n   (last (map fst (xps @ yp # wps @ [wp])))\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0 (map fst xps @ fst yp # map fst wps)) (fst wp)", "by (simp add: butlast_append)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0 (map fst xps @ fst yp # map fst wps)) (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp =\n        out (foldl step s\\<^sub>0 (c_ipurge I D (D ?w) (?xs @ ?y # ?ws))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0 (map fst xps @ fst yp # map fst wps)) (fst wp)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n     (fst wp)", "using S"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0 (map fst xps @ fst yp # map fst wps)) (fst wp)\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n     (fst wp)", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have F: \"D ?w \\<notin> sinks I D (c_dom D yp) (?ws @ [?w])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "using D"], ["proof (prove)\nusing this:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "by (simp only: c_dom_sinks, simp add: c_dom_def)"], ["proof (state)\nthis:\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"\\<not> (\\<exists>v \\<in> sinks I D (c_dom D yp) (?y # ?ws). (v, D ?w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n               (v, D (fst wp)) \\<in> I)", "proof (rule notI, simp add: c_dom_def sinks_cons_same R, erule disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (D (fst yp), D (fst wp)) \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "assume \"(D ?y, D ?w) \\<in> I\""], ["proof (state)\nthis:\n  (D (fst yp), D (fst wp)) \\<in> I\n\ngoal (2 subgoals):\n 1. (D (fst yp), D (fst wp)) \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "hence \"D ?w \\<in> sinks I D (c_dom D yp) (?ws @ [?w])\""], ["proof (prove)\nusing this:\n  (D (fst yp), D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (2 subgoals):\n 1. (D (fst yp), D (fst wp)) \\<in> I \\<Longrightarrow> False\n 2. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks I D (D ?y) ?ws. (v, D ?w) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n     (v, D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "hence \"D ?w \\<in> sinks I D (c_dom D yp) (?ws @ [?w])\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n     (v, D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)", "have \"snd wp = out (foldl step s\\<^sub>0\n        (c_ipurge I D (D ?w) (?xs @ ipurge_tr I D (c_dom D yp) (?y # ?ws)))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @\n             ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n     (fst wp)", "using R"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ fst yp # map fst wps)))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)\n  refl I\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @\n             ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n     (fst wp)", "by (simp add: c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp =\n        out (foldl step s\\<^sub>0 (?xs @ ipurge_tr I D (c_dom D yp) (?y # ?ws))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (map fst xps @ ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n     (fst wp)", "using S"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (map fst xps @ ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n     (fst wp)", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws)) @\n        [(?w, out (foldl step ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws))) ?w)]\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n    [(fst wp,\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n       (fst wp))]", "using E"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n   (fst wp)\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n    [(fst wp,\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n       (fst wp))]", "by (cases wp, simp)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [(fst wp,\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n     (fst wp))]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws)) @\n        c_tr step out (foldl step ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws))) [?w]\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  [(fst wp,\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n     (fst wp))]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n    c_tr step out\n     (foldl step (foldl step s\\<^sub>0 (map fst xps))\n       (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n     [fst wp]", "by (simp add: c_tr_singleton)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n   [fst wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws) @ [?w])\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps)))\n   [fst wp]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp])", "by (simp add: c_tr_append)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have\n        \"(c_tr step out ?s (ipurge_tr I D (c_dom D yp) (?y # ?ws) @ [?w]),\n        {(x, p). p \\<noteq> out (foldl step ?s\n        (ipurge_tr I D (c_dom D yp) (?y # ?ws) @ [?w])) x})\n        \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\"\n       (is \"(_, ?Y') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]),\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n       x})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps))", "by (rule c_tr_futures)"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp])\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))", "have\n        \"(xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]), ?Y')\n        \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp])\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n       x})\n    \\<in> c_failures step out s\\<^sub>0", "using X"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp])\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n       x})\n    \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have\n        \"ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y \\<subseteq> ?Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y\n    \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                       (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @\n                        [fst wp]))\n                  x}", "proof (rule subsetI, simp add: split_paired_all ipurge_ref_def c_dom_def\n       del: sinks.simps, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "fix x p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "assume\n          G: \"\\<forall>v \\<in> sinks I (c_dom D) (D ?y) (wps @ [wp]). (v, D x) \\<notin> I\" and\n          H: \"(D ?y, D x) \\<notin> I\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n     (v, D x) \\<notin> I\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "have \"(xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0", "using B'"], ["proof (prove)\nusing this:\n  ((yp # wps) @ [wp], Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "hence \"Y \\<subseteq> {(x', p'). p' \\<noteq>\n          out (foldl step s\\<^sub>0 (map fst (xps @ yp # wps @ [wp]))) x'}\""], ["proof (prove)\nusing this:\n  (xps @ yp # wps @ [wp], Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {(x', p').\n                   p' \\<noteq>\n                   out (foldl step s\\<^sub>0\n                         (map fst (xps @ yp # wps @ [wp])))\n                    x'}", "by (rule c_failures_ref)"], ["proof (state)\nthis:\n  Y \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst (xps @ yp # wps @ [wp])))\n                  x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "hence \"Y \\<subseteq> {(x', p'). p' \\<noteq>\n          out (foldl step s\\<^sub>0 (?xs @ ?y # ?ws @ [?w])) x'}\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst (xps @ yp # wps @ [wp])))\n                  x'}\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {(x', p').\n                   p' \\<noteq>\n                   out (foldl step s\\<^sub>0\n                         (map fst xps @ fst yp # map fst wps @ [fst wp]))\n                    x'}", "by simp"], ["proof (state)\nthis:\n  Y \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ fst yp # map fst wps @ [fst wp]))\n                  x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "moreover"], ["proof (state)\nthis:\n  Y \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ fst yp # map fst wps @ [fst wp]))\n                  x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "assume \"(x, p) \\<in> Y\""], ["proof (state)\nthis:\n  (x, p) \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  Y \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ fst yp # map fst wps @ [fst wp]))\n                  x'}\n  (x, p) \\<in> Y", "have \"(x, p) \\<in> {(x', p'). p' \\<noteq>\n          out (foldl step s\\<^sub>0 (?xs @ ?y # ?ws @ [?w])) x'}\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ fst yp # map fst wps @ [fst wp]))\n                  x'}\n  (x, p) \\<in> Y\n\ngoal (1 subgoal):\n 1. (x, p)\n    \\<in> {(x', p').\n           p' \\<noteq>\n           out (foldl step s\\<^sub>0\n                 (map fst xps @ fst yp # map fst wps @ [fst wp]))\n            x'}", ".."], ["proof (state)\nthis:\n  (x, p)\n  \\<in> {(x', p').\n         p' \\<noteq>\n         out (foldl step s\\<^sub>0\n               (map fst xps @ fst yp # map fst wps @ [fst wp]))\n          x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (?xs @ ?y # ?ws @ [?w]))) x\""], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x', p').\n         p' \\<noteq>\n         out (foldl step s\\<^sub>0\n               (map fst xps @ fst yp # map fst wps @ [fst wp]))\n          x'}\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @ fst yp # map fst wps @ [fst wp])))\n     x", "using S"], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x', p').\n         p' \\<noteq>\n         out (foldl step s\\<^sub>0\n               (map fst xps @ fst yp # map fst wps @ [fst wp]))\n          x'}\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @ fst yp # map fst wps @ [fst wp])))\n     x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ fst yp # map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ fst yp # map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "have\n          \"\\<not> (\\<exists>v \\<in> sinks I D (D ?y) (?y # ?ws @ [?w]). (v, D x) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                            (fst yp # map fst wps @ [fst wp]).\n               (v, D x) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks I D (D ?y) (?y # ?ws @ [?w]). (v, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n     (v, D x) \\<in> I", "obtain v where\n            A: \"v \\<in> sinks I D (D ?y) (?y # ?ws @ [?w])\" and\n            B: \"(v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]);\n         (v, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp])\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "have \"v = D ?y \\<or> v \\<in> sinks I D (D ?y) (?ws @ [?w])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = D (fst yp) \\<or>\n    v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])", "using R and A"], ["proof (prove)\nusing this:\n  refl I\n  v \\<in> sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. v = D (fst yp) \\<or>\n    v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])", "by (simp add: sinks_cons_same)"], ["proof (state)\nthis:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume \"v = D ?y\""], ["proof (state)\nthis:\n  v = D (fst yp)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence \"(D ?y, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  v = D (fst yp)\n\ngoal (1 subgoal):\n 1. (D (fst yp), D x) \\<in> I", "using B"], ["proof (prove)\nusing this:\n  v = D (fst yp)\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (D (fst yp), D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (D (fst yp), D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence False"], ["proof (prove)\nusing this:\n  (D (fst yp), D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using H"], ["proof (prove)\nusing this:\n  (D (fst yp), D x) \\<in> I\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  v = D (fst yp) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v = D (fst yp) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  v = D (fst yp) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume \"v \\<in> sinks I D (D ?y) (?ws @ [?w])\""], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence \"v \\<in> sinks I (c_dom D) (D ?y) (wps @ [wp])\""], ["proof (prove)\nusing this:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])", "by (simp only: c_dom_sinks, simp)"], ["proof (state)\nthis:\n  v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "with G"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n     (v, D x) \\<notin> I\n  v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])", "have \"(v, D x) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n     (v, D x) \\<notin> I\n  v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. (v, D x) \\<notin> I", ".."], ["proof (state)\nthis:\n  (v, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence False"], ["proof (prove)\nusing this:\n  (v, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. False", "using B"], ["proof (prove)\nusing this:\n  (v, D x) \\<notin> I\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp]) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n  v = D (fst yp) \\<Longrightarrow> False\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp]) \\<Longrightarrow>\n  False", "show False"], ["proof (prove)\nusing this:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n  v = D (fst yp) \\<Longrightarrow> False\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp]) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ fst yp # map fst wps @ [fst wp])))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x)\n          (?xs @ ipurge_tr I D (D ?y) (?y # ?ws @ [?w])))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ fst yp # map fst wps @ [fst wp])))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n     x", "using R"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ fst yp # map fst wps @ [fst wp])))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n  refl I\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n     x", "by (simp add: c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0 (?xs @ ipurge_tr I D (D ?y) (?ws @ [?w]))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n     x", "using R and S"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n  refl I\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n     x", "by (simp add: c_secure_def ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0 (?xs @ ipurge_tr I D (D ?y) ?ws @ [?w])) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n     x", "using F"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n   x\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n     x", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (step\n                               (foldl step\n                                 (foldl step s\\<^sub>0 (map fst xps))\n                                 (ipurge_tr I D (D (fst yp))\n                                   (fst yp # map fst wps)))\n                               (fst wp))\n                          a", "thus \"p \\<noteq> out (step (foldl step ?s\n          (ipurge_tr I D (D ?y) (?y # ?ws))) ?w) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (step\n          (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (D (fst yp)) (fst yp # map fst wps)))\n          (fst wp))\n     x", "using R"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @ ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n   x\n  refl I\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (step\n          (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (ipurge_tr I D (D (fst yp)) (fst yp # map fst wps)))\n          (fst wp))\n     x", "by (simp add: ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (step\n        (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (D (fst yp)) (fst yp # map fst wps)))\n        (fst wp))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @\n                      [fst wp]))\n                x}\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @\n                      [fst wp]))\n                x}", "have \"(xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n        ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n        \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                     (ipurge_tr I D (c_dom D yp) (fst yp # map fst wps) @\n                      [fst wp]))\n                x}\n\ngoal (1 subgoal):\n 1. (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "thus \"(ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n        ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (xps @ ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Y)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n   ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n   ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_secure_futures_2:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"(yps @ [yp], A) \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps \\<Longrightarrow>\n    (yps @ [yp], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(yps @ [yp], A)\n             \\<in> futures (c_process step out s\\<^sub>0) xps;\n     (yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n    \\<Longrightarrow> (yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (simp add: c_futures_failures)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "let ?zs = \"map fst (xps @ yps)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "let ?y = \"fst yp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "assume \"(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "hence \"xps @ yps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ yps @ [yp]))\""], ["proof (prove)\nusing this:\n  (xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps @ yps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ yps @ [yp]))", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps @ yps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ yps @ [yp]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "hence A: \"xps @ yps @ [yp] = c_tr step out s\\<^sub>0 (?zs @ [?y])\""], ["proof (prove)\nusing this:\n  xps @ yps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ yps @ [yp]))\n\ngoal (1 subgoal):\n 1. xps @ yps @ [yp] =\n    c_tr step out s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])", "by simp"], ["proof (state)\nthis:\n  xps @ yps @ [yp] =\n  c_tr step out s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "assume \"(xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\""], ["proof (state)\nthis:\n  (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "hence B: \"Y \\<subseteq> {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 ?zs) x}\"\n   (is \"_ \\<subseteq> ?Y'\")"], ["proof (prove)\nusing this:\n  (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. Y \\<subseteq> {(x, p).\n                   p \\<noteq>\n                   out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}", "by (rule c_failures_ref)"], ["proof (state)\nthis:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "have \"(xps @ yps @ [yp], {(x, p). p \\<noteq> out (foldl step s\\<^sub>0 (?zs @ [?y])) x})\n    \\<in> c_failures step out s\\<^sub>0\"\n   (is \"(_, ?X') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp],\n     {(x, p).\n      p \\<noteq>\n      out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x})\n    \\<in> c_failures step out s\\<^sub>0", "by (subst A, rule c_tr_failures)"], ["proof (state)\nthis:\n  (xps @ yps @ [yp],\n   {(x, p).\n    p \\<noteq>\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  (xps @ yps @ [yp],\n   {(x, p).\n    p \\<noteq>\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "have \"{x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I} \\<subseteq> ?X'\" (is \"?X \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n    \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                  x}", "proof (rule subsetI, simp add: split_paired_all c_dom_def\n   del: map_append foldl_append, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "fix x p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "assume \"(x, p) \\<in> Y\""], ["proof (state)\nthis:\n  (x, p) \\<in> Y\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "with B"], ["proof (chain)\npicking this:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n  (x, p) \\<in> Y", "have \"(x, p) \\<in> ?Y'\""], ["proof (prove)\nusing this:\n  Y \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n  (x, p) \\<in> Y\n\ngoal (1 subgoal):\n 1. (x, p)\n    \\<in> {(x, p).\n           p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}", ".."], ["proof (state)\nthis:\n  (x, p)\n  \\<in> {(x, p).\n         p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0 ?zs) x\""], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x, p).\n         p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x}\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "have \"out (foldl step s\\<^sub>0 ?zs) x =\n      out (foldl step s\\<^sub>0 (c_ipurge I D (D x) ?zs)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x", "using S"], ["proof (prove)\nusing this:\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x) ?zs)) x\""], ["proof (prove)\nusing this:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps))) x =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "assume \"(D ?y, D x) \\<notin> I\""], ["proof (state)\nthis:\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "with R"], ["proof (chain)\npicking this:\n  refl I\n  (D (fst yp), D x) \\<notin> I", "have \"c_ipurge I D (D x) (?zs @ [?y]) = c_ipurge I D (D x) ?zs\""], ["proof (prove)\nusing this:\n  refl I\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n    c_ipurge I D (D x) (map fst (xps @ yps))", "by (rule c_ipurge_append_2)"], ["proof (state)\nthis:\n  c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n  c_ipurge I D (D x) (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n  c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n  c_ipurge I D (D x) (map fst (xps @ yps))", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (?zs @ [?y]))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (map fst (xps @ yps)))) x\n  c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp]) =\n  c_ipurge I D (D x) (map fst (xps @ yps))\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n     x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "have \"out (foldl step s\\<^sub>0 (c_ipurge I D (D x) (?zs @ [?y]))) x =\n      out (foldl step s\\<^sub>0 (?zs @ [?y])) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n     x =\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x", "using S"], ["proof (prove)\nusing this:\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n     x =\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x =\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Y; (D (fst yp), D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step s\\<^sub>0\n                               (map fst (xps @ yps) @ [fst yp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x =\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x", "show \"p \\<noteq> out (foldl step s\\<^sub>0 (?zs @ [?y])) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst (xps @ yps) @ [fst yp])))\n   x =\n  out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(xps @ yps @ [yp], A) \\<in> c_failures step out s\\<^sub>0;\n     (xps @ yps, Y) \\<in> c_failures step out s\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> (xps @ yps @ [yp],\n                       {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n                      \\<in> c_failures step out s\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ yps @ [yp],\n   {(x, p).\n    p \\<noteq>\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x})\n  \\<in> c_failures step out s\\<^sub>0\n  {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                x}", "show \"(xps @ yps @ [yp], ?X) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ yps @ [yp],\n   {(x, p).\n    p \\<noteq>\n    out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp])) x})\n  \\<in> c_failures step out s\\<^sub>0\n  {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I}\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step s\\<^sub>0 (map fst (xps @ yps) @ [fst yp]))\n                x}\n\ngoal (1 subgoal):\n 1. (xps @ yps @ [yp], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps @ yps @ [yp], {x \\<in> Y. (c_dom D yp, c_dom D x) \\<notin> I})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_secure_ipurge_tr:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"ipurge_tr I (c_dom D) (D x) (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n    = ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) =\n    ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)", "proof (induction ys rule: rev_induct, simp, simp only: c_tr.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa) \\<Longrightarrow>\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa @\n         [(xa,\n           out (foldl step (step (foldl step s\\<^sub>0 xs) x) xsa) xa)]) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa @\n         [(xa, out (foldl step (foldl step s\\<^sub>0 xs) xsa) xa)])", "let ?s = \"foldl step s\\<^sub>0 xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa) \\<Longrightarrow>\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa @\n         [(xa,\n           out (foldl step (step (foldl step s\\<^sub>0 xs) x) xsa) xa)]) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa @\n         [(xa, out (foldl step (foldl step s\\<^sub>0 xs) xsa) xa)])", "fix ys y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa) \\<Longrightarrow>\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa @\n         [(xa,\n           out (foldl step (step (foldl step s\\<^sub>0 xs) x) xsa) xa)]) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa @\n         [(xa, out (foldl step (foldl step s\\<^sub>0 xs) xsa) xa)])", "assume A: \"ipurge_tr I (c_dom D) (D x) (c_tr step out (step ?s x) ys) =\n    ipurge_tr I (c_dom D) (D x) (c_tr step out ?s ys)\""], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>xa xsa.\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa) \\<Longrightarrow>\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (step (foldl step s\\<^sub>0 xs) x) xsa @\n         [(xa,\n           out (foldl step (step (foldl step s\\<^sub>0 xs) x) xsa) xa)]) =\n       ipurge_tr I (c_dom D) (D x)\n        (c_tr step out (foldl step s\\<^sub>0 xs) xsa @\n         [(xa, out (foldl step (foldl step s\\<^sub>0 xs) xsa) xa)])", "show \"ipurge_tr I (c_dom D) (D x) (c_tr step out (step ?s x) ys @\n    [(y, out (foldl step (step ?s x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n    (c_tr step out ?s ys @ [(y, out (foldl step ?s ys) y)])\"\n   (is \"_ (_ @ [?yp']) = _ (_ @ [?yp])\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "proof (cases \"D y \\<in> sinks I D (D x) (ys @ [y])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "assume D: \"D y \\<in> sinks I D (D x) (ys @ [y])\""], ["proof (state)\nthis:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "hence \"c_dom D ?yp' \\<in> sinks I (c_dom D) (D x)\n      (c_tr step out (step ?s x) ys @ [?yp'])\""], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n    \\<in> sinks I (c_dom D) (D x)\n           (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n            [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)])", "using D"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n    \\<in> sinks I (c_dom D) (D x)\n           (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n            [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)])", "by (simp only: c_dom_sinks, simp add: c_dom_def c_tr_map)"], ["proof (state)\nthis:\n  c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n  \\<in> sinks I (c_dom D) (D x)\n         (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n          [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)])\n\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "hence \"ipurge_tr I (c_dom D) (D x) (c_tr step out (step ?s x) ys @ [?yp']) =\n      ipurge_tr I (c_dom D) (D x) (c_tr step out (step ?s x) ys)\""], ["proof (prove)\nusing this:\n  c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n  \\<in> sinks I (c_dom D) (D x)\n         (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n          [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "have \"c_dom D ?yp \\<in> sinks I (c_dom D) (D x)\n      (c_tr step out ?s ys @ [?yp])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n    \\<in> sinks I (c_dom D) (D x)\n           (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n            [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "using D"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n    \\<in> sinks I (c_dom D) (D x)\n           (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n            [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "by (simp only: c_dom_sinks, simp add: c_dom_def c_tr_map)"], ["proof (state)\nthis:\n  c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n  \\<in> sinks I (c_dom D) (D x)\n         (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n          [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "hence \"ipurge_tr I (c_dom D) (D x) (c_tr step out ?s ys @ [?yp]) =\n      ipurge_tr I (c_dom D) (D x) (c_tr step out ?s ys)\""], ["proof (prove)\nusing this:\n  c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n  \\<in> sinks I (c_dom D) (D x)\n         (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n          [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n\ngoal (2 subgoals):\n 1. D y \\<in> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n 2. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "assume D: \"D y \\<notin> sinks I D (D x) (ys @ [y])\""], ["proof (state)\nthis:\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "hence \"c_dom D ?yp' \\<notin> sinks I (c_dom D) (D x)\n      (c_tr step out (step ?s x) ys @ [?yp'])\""], ["proof (prove)\nusing this:\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n    \\<notin> sinks I (c_dom D) (D x)\n              (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n               [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                     y)])", "using D"], ["proof (prove)\nusing this:\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n    \\<notin> sinks I (c_dom D) (D x)\n              (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n               [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                     y)])", "by (simp only: c_dom_sinks, simp add: c_dom_def c_tr_map)"], ["proof (state)\nthis:\n  c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n  \\<notin> sinks I (c_dom D) (D x)\n            (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)])\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "hence \"ipurge_tr I (c_dom D) (D x) (c_tr step out (step ?s x) ys @ [?yp']) =\n      ipurge_tr I (c_dom D) (D x) (c_tr step out (step ?s x) ys) @ [?yp']\""], ["proof (prove)\nusing this:\n  c_dom D (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)\n  \\<notin> sinks I (c_dom D) (D x)\n            (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n  [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n  [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "have \"c_dom D ?yp \\<notin> sinks I (c_dom D) (D x)\n      (c_tr step out ?s ys @ [?yp])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n    \\<notin> sinks I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n               [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "using D"], ["proof (prove)\nusing this:\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n    \\<notin> sinks I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n               [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "by (simp only: c_dom_sinks, simp add: c_dom_def c_tr_map)"], ["proof (state)\nthis:\n  c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n  \\<notin> sinks I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n             [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "hence \"ipurge_tr I (c_dom D) (D x) (c_tr step out ?s ys @ [?yp]) =\n      ipurge_tr I (c_dom D) (D x) (c_tr step out ?s ys) @ [?yp]\""], ["proof (prove)\nusing this:\n  c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n  \\<notin> sinks I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n             [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n  [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\n\ngoal (1 subgoal):\n 1. D y \\<notin> sinks I D (D x) (ys @ [y]) \\<Longrightarrow>\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n  [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n  [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n  [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x) (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n  [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n      [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n    ipurge_tr I (c_dom D) (D x)\n     (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n      [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])", "proof (simp add: A)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have B: \"\\<not> (\\<exists>v \\<in> sinks I D (D x) ys. (v, D y) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks I D (D x) ys. (v, D y) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I \\<Longrightarrow>\n    False", "hence \"D y \\<in> sinks I D (D x) (ys @ [y])\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. D y \\<in> sinks I D (D x) (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have C: \"\\<not> (\\<exists>v \\<in> sinks I D (D x) (x # ys). (v, D y) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (D x) (x # ys). (v, D y) \\<in> I)", "proof (rule notI, simp add: sinks_cons_same R B)"], ["proof (state)\ngoal (1 subgoal):\n 1. (D x, D y) \\<in> I \\<Longrightarrow> False", "assume \"(D x, D y) \\<in> I\""], ["proof (state)\nthis:\n  (D x, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. (D x, D y) \\<in> I \\<Longrightarrow> False", "hence \"D y \\<in> sinks I D (D x) (ys @ [y])\""], ["proof (prove)\nusing this:\n  (D x, D y) \\<in> I\n\ngoal (1 subgoal):\n 1. D y \\<in> sinks I D (D x) (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. (D x, D y) \\<in> I \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  D y \\<in> sinks I D (D x) (ys @ [y])\n  D y \\<notin> sinks I D (D x) (ys @ [y])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (D x) (x # ys). (v, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"out (foldl step (step ?s x) ys) y = out (foldl step s\\<^sub>0 (xs @ x # ys)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n    out (foldl step s\\<^sub>0 (xs @ x # ys)) y", "by simp"], ["proof (state)\nthis:\n  out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n  out (foldl step s\\<^sub>0 (xs @ x # ys)) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "also"], ["proof (state)\nthis:\n  out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n  out (foldl step s\\<^sub>0 (xs @ x # ys)) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"\\<dots> = out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (xs @ x # ys)) y =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y", "using S"], ["proof (prove)\nusing this:\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (xs @ x # ys)) y =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (xs @ x # ys)) y =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "also"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (xs @ x # ys)) y =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"\\<dots> = out (foldl step s\\<^sub>0 (c_ipurge I D (D y)\n        (xs @ ipurge_tr I D (D x) (x # ys)))) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n     y", "using R and C"], ["proof (prove)\nusing this:\n  refl I\n  \\<not> (\\<exists>v\\<in>sinks I D (D x) (x # ys). (v, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n     y", "by (simp add: c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n   y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "also"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ x # ys))) y =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n   y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"\\<dots> = out (foldl step s\\<^sub>0 (c_ipurge I D (D y)\n        (xs @ ipurge_tr I D (D x) ys))) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n     y =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n     y", "using R"], ["proof (prove)\nusing this:\n  refl I\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n     y =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n     y", "by (simp add: ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n   y =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n   y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "also"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) (x # ys))))\n   y =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n   y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"\\<dots> = out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n     y =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y", "using R and B"], ["proof (prove)\nusing this:\n  refl I\n  \\<not> (\\<exists>v\\<in>sinks I D (D x) ys. (v, D y) \\<in> I)\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0\n          (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n     y =\n    out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y", "by (simp add: c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n   y =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "also"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D y) (xs @ ipurge_tr I D (D x) ys)))\n   y =\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"\\<dots> = out (foldl step s\\<^sub>0 (xs @ ys)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y =\n    out (foldl step s\\<^sub>0 (xs @ ys)) y", "using S"], ["proof (prove)\nusing this:\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y =\n    out (foldl step s\\<^sub>0 (xs @ ys)) y", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y =\n  out (foldl step s\\<^sub>0 (xs @ ys)) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "also"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (c_ipurge I D (D y) (xs @ ys))) y =\n  out (foldl step s\\<^sub>0 (xs @ ys)) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "have \"\\<dots> = out (foldl step ?s ys) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out (foldl step s\\<^sub>0 (xs @ ys)) y =\n    out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "by simp"], ["proof (state)\nthis:\n  out (foldl step s\\<^sub>0 (xs @ ys)) y =\n  out (foldl step (foldl step s\\<^sub>0 xs) ys) y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if c_dom D\n                  (y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y)\n                 \\<in> (if (D x,\n                            c_dom D\n                             (y, out (foldl step\n (step (foldl step s\\<^sub>0 xs) x) ys)\n                                  y))\n                           \\<in> I \\<or>\n                           (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n      (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys).\n                               (v, c_dom D\n                                    (y, out\n   (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y))\n                               \\<in> I)\n                        then insert\n                              (c_dom D\n                                (y, out (foldl step\n    (step (foldl step s\\<^sub>0 xs) x) ys)\n                                     y))\n                              (sinks I (c_dom D) (D x)\n                                (c_tr step out\n                                  (step (foldl step s\\<^sub>0 xs) x) ys))\n                        else sinks I (c_dom D) (D x)\n                              (c_tr step out\n                                (step (foldl step s\\<^sub>0 xs) x) ys))\n              then ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys)\n              else ipurge_tr I (c_dom D) (D x)\n                    (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys) @\n                   [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x)\n                              ys)\n                         y)]) =\n             ipurge_tr I (c_dom D) (D x)\n              (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n             [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                   y)];\n     (if c_dom D (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)\n         \\<in> (if (D x,\n                    c_dom D\n                     (y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y))\n                   \\<in> I \\<or>\n                   (\\<exists>v\\<in>sinks I (c_dom D) (D x)\n                                    (c_tr step out (foldl step s\\<^sub>0 xs)\nys).\n                       (v, c_dom D\n                            (y, out (foldl step (foldl step s\\<^sub>0 xs)\nys)\n                                 y))\n                       \\<in> I)\n                then insert\n                      (c_dom D\n                        (y, out (foldl step (foldl step s\\<^sub>0 xs) ys)\n                             y))\n                      (sinks I (c_dom D) (D x)\n                        (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n                else sinks I (c_dom D) (D x)\n                      (c_tr step out (foldl step s\\<^sub>0 xs) ys))\n      then ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys)\n      else ipurge_tr I (c_dom D) (D x)\n            (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n           [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]) =\n     ipurge_tr I (c_dom D) (D x)\n      (c_tr step out (foldl step s\\<^sub>0 xs) ys) @\n     [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)]\\<rbrakk>\n    \\<Longrightarrow> out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys)\n                       y =\n                      out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "finally"], ["proof (chain)\npicking this:\n  out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n  out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "show \"out (foldl step (step ?s x) ys) y = out (foldl step ?s ys) y\""], ["proof (prove)\nusing this:\n  out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n  out (foldl step (foldl step s\\<^sub>0 xs) ys) y\n\ngoal (1 subgoal):\n 1. out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n    out (foldl step (foldl step s\\<^sub>0 xs) ys) y", "."], ["proof (state)\nthis:\n  out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y =\n  out (foldl step (foldl step s\\<^sub>0 xs) ys) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (step (foldl step s\\<^sub>0 xs) x) ys @\n    [(y, out (foldl step (step (foldl step s\\<^sub>0 xs) x) ys) y)]) =\n  ipurge_tr I (c_dom D) (D x)\n   (c_tr step out (foldl step s\\<^sub>0 xs) ys @\n    [(y, out (foldl step (foldl step s\\<^sub>0 xs) ys) y)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma c_secure_implies_secure_aux_2 [rule_format]:\n  assumes\n    R: \"refl I\" and\n    S: \"c_secure step out s\\<^sub>0 I D\" and\n    Y: \"(yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\"\n  shows \"(zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n    ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zps, Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (induction zps arbitrary: Z rule: length_induct, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs Z.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (ys, x)\n                       \\<in> futures (c_process step out s\\<^sub>0)\n                              xps \\<longrightarrow>\n                       (yp # ipurge_tr I (c_dom D) (c_dom D yp) ys,\n                        ipurge_ref I (c_dom D) (c_dom D yp) ys x)\n                       \\<in> futures (c_process step out s\\<^sub>0) xps);\n        (xs, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n       \\<Longrightarrow> (yp # ipurge_tr I (c_dom D) (c_dom D yp) xs,\n                          ipurge_ref I (c_dom D) (c_dom D yp) xs Z)\n                         \\<in> futures (c_process step out s\\<^sub>0) xps", "fix zps Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs Z.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (ys, x)\n                       \\<in> futures (c_process step out s\\<^sub>0)\n                              xps \\<longrightarrow>\n                       (yp # ipurge_tr I (c_dom D) (c_dom D yp) ys,\n                        ipurge_ref I (c_dom D) (c_dom D yp) ys x)\n                       \\<in> futures (c_process step out s\\<^sub>0) xps);\n        (xs, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n       \\<Longrightarrow> (yp # ipurge_tr I (c_dom D) (c_dom D yp) xs,\n                          ipurge_ref I (c_dom D) (c_dom D yp) xs Z)\n                         \\<in> futures (c_process step out s\\<^sub>0) xps", "assume\n    A: \"\\<forall>zps'. length zps' < length zps \\<longrightarrow>\n      (\\<forall>Z'. (zps', Z') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps',\n      ipurge_ref I (c_dom D) (c_dom D yp) zps' Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\" and\n    B: \"(zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (state)\nthis:\n  \\<forall>zps'.\n     length zps' < length zps \\<longrightarrow>\n     (\\<forall>Z'.\n         (zps', Z')\n         \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n         (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps',\n          ipurge_ref I (c_dom D) (c_dom D yp) zps' Z')\n         \\<in> futures (c_process step out s\\<^sub>0) xps)\n  (zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>xs Z.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x.\n                       (ys, x)\n                       \\<in> futures (c_process step out s\\<^sub>0)\n                              xps \\<longrightarrow>\n                       (yp # ipurge_tr I (c_dom D) (c_dom D yp) ys,\n                        ipurge_ref I (c_dom D) (c_dom D yp) ys x)\n                       \\<in> futures (c_process step out s\\<^sub>0) xps);\n        (xs, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\\<rbrakk>\n       \\<Longrightarrow> (yp # ipurge_tr I (c_dom D) (c_dom D yp) xs,\n                          ipurge_ref I (c_dom D) (c_dom D yp) xs Z)\n                         \\<in> futures (c_process step out s\\<^sub>0) xps", "show \"(yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n    ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (cases zps, simp add: ipurge_ref_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. zps = [] \\<Longrightarrow>\n    ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "case Nil"], ["proof (state)\nthis:\n  zps = []\n\ngoal (2 subgoals):\n 1. zps = [] \\<Longrightarrow>\n    ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "hence C: \"([], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  zps = []\n\ngoal (1 subgoal):\n 1. ([], Z) \\<in> futures (c_process step out s\\<^sub>0) xps", "using B"], ["proof (prove)\nusing this:\n  zps = []\n  (zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([], Z) \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  ([], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. zps = [] \\<Longrightarrow>\n    ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(([] @ [yp]) @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (([] @ [yp]) @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "using Y"], ["proof (prove)\nusing this:\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (([] @ [yp]) @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  (([] @ [yp]) @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. zps = [] \\<Longrightarrow>\n    ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"([] @ [yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (([] @ [yp]) @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([] @ [yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  ([] @ [yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. zps = [] \\<Longrightarrow>\n    ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "with R and S"], ["proof (chain)\npicking this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  ([] @ [yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"([] @ [yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n      \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  ([] @ [yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([] @ [yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using C"], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  ([] @ [yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n  ([], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([] @ [yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule c_secure_futures_2)"], ["proof (state)\nthis:\n  ([] @ [yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. zps = [] \\<Longrightarrow>\n    ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "thus \"([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n      \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  ([] @ [yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  ([yp], {x \\<in> Z. (c_dom D yp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "case Cons"], ["proof (state)\nthis:\n  zps = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"\\<exists>wps wp. zps = wps @ [wp]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>wps wp. zps = wps @ [wp]", "by (rule rev_cases [of zps], simp_all add: Cons)"], ["proof (state)\nthis:\n  \\<exists>wps wp. zps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "then"], ["proof (chain)\npicking this:\n  \\<exists>wps wp. zps = wps @ [wp]", "obtain wps and wp where C: \"zps = wps @ [wp]\""], ["proof (prove)\nusing this:\n  \\<exists>wps wp. zps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. (\\<And>wps wp.\n        zps = wps @ [wp] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  zps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "have B': \"(wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps", "using B and C"], ["proof (prove)\nusing this:\n  (zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n  zps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zps = a # list \\<Longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n        ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n       \\<in> futures (c_process step out s\\<^sub>0) xps", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof (simp only: C,\n     cases \"c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?Z' = \"{x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I}\""], ["proof (state)\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"length wps < length zps \\<longrightarrow>\n        (\\<forall>Z'. (wps, Z') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length wps < length zps \\<longrightarrow>\n    (\\<forall>Z'.\n        (wps, Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n         ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", "using A"], ["proof (prove)\nusing this:\n  \\<forall>zps'.\n     length zps' < length zps \\<longrightarrow>\n     (\\<forall>Z'.\n         (zps', Z')\n         \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n         (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps',\n          ipurge_ref I (c_dom D) (c_dom D yp) zps' Z')\n         \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. length wps < length zps \\<longrightarrow>\n    (\\<forall>Z'.\n        (wps, Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n         ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", ".."], ["proof (state)\nthis:\n  length wps < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (wps, Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  length wps < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (wps, Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"length wps < length zps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length wps < length zps", "using C"], ["proof (prove)\nusing this:\n  zps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. length wps < length zps", "by simp"], ["proof (state)\nthis:\n  length wps < length zps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  length wps < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (wps, Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length wps < length zps", "have \"\\<forall>Z'. (wps, Z') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  length wps < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (wps, Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n       ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length wps < length zps\n\ngoal (1 subgoal):\n 1. \\<forall>Z'.\n       (wps, Z')\n       \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n       (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n       \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  \\<forall>Z'.\n     (wps, Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n      ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"(wps, ?Z') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps ?Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  \\<forall>Z'.\n     (wps, Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n      ipurge_ref I (c_dom D) (c_dom D yp) wps Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n     ipurge_ref I (c_dom D) (c_dom D yp) wps\n      {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(wps, ?Z') \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using R and S and B'"], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule c_secure_futures_1)"], ["proof (state)\nthis:\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n        ipurge_ref I (c_dom D) (c_dom D yp) wps ?Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (wps, {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n     ipurge_ref I (c_dom D) (c_dom D yp) wps\n      {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "assume\n        D: \"c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\""], ["proof (state)\nthis:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        ipurge_tr I (c_dom D) (c_dom D yp) wps\""], ["proof (prove)\nusing this:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp) wps", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z =\n        ipurge_ref I (c_dom D) (c_dom D yp) wps ?Z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z =\n    ipurge_ref I (c_dom D) (c_dom D yp) wps\n     {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I}", "using D"], ["proof (prove)\nusing this:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z =\n    ipurge_ref I (c_dom D) (c_dom D yp) wps\n     {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I}", "by (rule ipurge_ref_eq)"], ["proof (state)\nthis:\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z =\n  ipurge_ref I (c_dom D) (c_dom D yp) wps\n   {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I}\n\ngoal (2 subgoals):\n 1. c_dom D wp\n    \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z =\n  ipurge_ref I (c_dom D) (c_dom D yp) wps\n   {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I}", "show \"(yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n        ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) wps,\n   ipurge_ref I (c_dom D) (c_dom D yp) wps\n    {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z =\n  ipurge_ref I (c_dom D) (c_dom D yp) wps\n   {x \\<in> Z. (c_dom D wp, c_dom D x) \\<notin> I}\n\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?xs = \"map fst xps\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?y = \"fst yp\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?ws = \"map fst wps\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?w = \"fst wp\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?s = \"foldl step s\\<^sub>0 ?xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "let ?s' = \"foldl step s\\<^sub>0 (?xs @ [?y])\""], ["proof (state)\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"((xps @ [yp]) @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xps @ [yp]) @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)", "using Y"], ["proof (prove)\nusing this:\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ((xps @ [yp]) @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)", "by (simp add: c_futures_failures c_failures_failures)"], ["proof (state)\nthis:\n  ((xps @ [yp]) @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"(xps @ [yp], {}) \\<in> failures (c_process step out s\\<^sub>0)\""], ["proof (prove)\nusing this:\n  ((xps @ [yp]) @ yps, Y) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ [yp], {}) \\<in> failures (c_process step out s\\<^sub>0)", "by (rule process_rule_2_failures)"], ["proof (state)\nthis:\n  (xps @ [yp], {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"(xps @ [yp], {}) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ [yp], {}) \\<in> failures (c_process step out s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. (xps @ [yp], {}) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_failures_failures)"], ["proof (state)\nthis:\n  (xps @ [yp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"xps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ [yp]))\""], ["proof (prove)\nusing this:\n  (xps @ [yp], {}) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. xps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ [yp]))", "by (rule c_failures_tr)"], ["proof (state)\nthis:\n  xps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ [yp]))\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence XY: \"xps @ [yp] = c_tr step out s\\<^sub>0 (?xs @ [?y])\""], ["proof (prove)\nusing this:\n  xps @ [yp] = c_tr step out s\\<^sub>0 (map fst (xps @ [yp]))\n\ngoal (1 subgoal):\n 1. xps @ [yp] = c_tr step out s\\<^sub>0 (map fst xps @ [fst yp])", "by simp"], ["proof (state)\nthis:\n  xps @ [yp] = c_tr step out s\\<^sub>0 (map fst xps @ [fst yp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence X: \"xps = c_tr step out s\\<^sub>0 ?xs\""], ["proof (prove)\nusing this:\n  xps @ [yp] = c_tr step out s\\<^sub>0 (map fst xps @ [fst yp])\n\ngoal (1 subgoal):\n 1. xps = c_tr step out s\\<^sub>0 (map fst xps)", "by simp"], ["proof (state)\nthis:\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"([yp] @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([yp] @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "using Y"], ["proof (prove)\nusing this:\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([yp] @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  ([yp] @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"([yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  ([yp] @ yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. ([yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  ([yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"[yp] = c_tr step out ?s (map fst [yp])\""], ["proof (prove)\nusing this:\n  ([yp], {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. [yp] = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst [yp])", "by (rule c_futures_tr)"], ["proof (state)\nthis:\n  [yp] = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst [yp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence Y': \"[yp] = c_tr step out ?s ([?y])\""], ["proof (prove)\nusing this:\n  [yp] = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst [yp])\n\ngoal (1 subgoal):\n 1. [yp] = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp]", "by simp"], ["proof (state)\nthis:\n  [yp] = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have W: \"(wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "using B'"], ["proof (prove)\nusing this:\n  (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  (wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence W': \"wps = c_tr step out (foldl step s\\<^sub>0 ?xs) ?ws\""], ["proof (prove)\nusing this:\n  (wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. wps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)", "by (rule c_futures_tr)"], ["proof (state)\nthis:\n  wps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "assume D: \"c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\""], ["proof (state)\nthis:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        ipurge_tr I (c_dom D) (c_dom D yp) wps @ [wp]\""], ["proof (prove)\nusing this:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp) wps @ [wp]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps @ [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 ?xs) ?ws) @ [wp]\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps @ [wp]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n    [wp]", "using W'"], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp) wps @ [wp]\n  wps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n    [wp]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "also"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"\\<dots> =\n        ipurge_tr I (c_dom D) (c_dom D yp) (c_tr step out ?s' ?ws) @ [wp]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n    [wp] =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n       (map fst wps)) @\n    [wp]", "using R and S"], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n    [wp] =\n    ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n       (map fst wps)) @\n    [wp]", "by (simp add: c_secure_ipurge_tr c_dom_def)"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n  [wp] =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "also"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)) @\n  [wp] =\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"\\<dots> = c_tr step out ?s' (ipurge_tr I D (c_dom D yp) ?ws) @ [wp]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp)\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n       (map fst wps)) @\n    [wp] =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n    [wp]", "proof (simp del: foldl_append, rule c_tr_ipurge_tr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "let ?wps' = \"c_tr step out ?s (take n ?ws)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "have \"length ?wps' < length zps \\<longrightarrow>\n          (\\<forall>Z'. (?wps', Z') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n          (yp # ipurge_tr I (c_dom D) (c_dom D yp) ?wps',\n          ipurge_ref I (c_dom D) (c_dom D yp) ?wps' Z')\n          \\<in> futures (c_process step out s\\<^sub>0) xps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)))\n    < length zps \\<longrightarrow>\n    (\\<forall>Z'.\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps)),\n         Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp #\n         ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n            (take n (map fst wps))),\n         ipurge_ref I (c_dom D) (c_dom D yp)\n          (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n            (take n (map fst wps)))\n          Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", "using A"], ["proof (prove)\nusing this:\n  \\<forall>zps'.\n     length zps' < length zps \\<longrightarrow>\n     (\\<forall>Z'.\n         (zps', Z')\n         \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n         (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps',\n          ipurge_ref I (c_dom D) (c_dom D yp) zps' Z')\n         \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)))\n    < length zps \\<longrightarrow>\n    (\\<forall>Z'.\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps)),\n         Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n        (yp #\n         ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n            (take n (map fst wps))),\n         ipurge_ref I (c_dom D) (c_dom D yp)\n          (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n            (take n (map fst wps)))\n          Z')\n        \\<in> futures (c_process step out s\\<^sub>0) xps)", ".."], ["proof (state)\nthis:\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)),\n       Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp #\n       ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps)))\n        Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "moreover"], ["proof (state)\nthis:\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)),\n       Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp #\n       ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps)))\n        Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "have \"length ?wps' < length zps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)))\n    < length zps", "using C"], ["proof (prove)\nusing this:\n  zps = wps @ [wp]\n\ngoal (1 subgoal):\n 1. length\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)))\n    < length zps", "by (simp add: c_tr_length)"], ["proof (state)\nthis:\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "ultimately"], ["proof (chain)\npicking this:\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)),\n       Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp #\n       ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps)))\n        Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps", "have \"\\<forall>Z'.\n          (?wps', Z') \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n          (yp # ipurge_tr I (c_dom D) (c_dom D yp) ?wps',\n          ipurge_ref I (c_dom D) (c_dom D yp) ?wps' Z')\n          \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps \\<longrightarrow>\n  (\\<forall>Z'.\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)),\n       Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n      (yp #\n       ipurge_tr I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps))),\n       ipurge_ref I (c_dom D) (c_dom D yp)\n        (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n          (take n (map fst wps)))\n        Z')\n      \\<in> futures (c_process step out s\\<^sub>0) xps)\n  length\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)))\n  < length zps\n\ngoal (1 subgoal):\n 1. \\<forall>Z'.\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n         (take n (map fst wps)),\n        Z')\n       \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n       (yp #\n        ipurge_tr I (c_dom D) (c_dom D yp)\n         (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n           (take n (map fst wps))),\n        ipurge_ref I (c_dom D) (c_dom D yp)\n         (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n           (take n (map fst wps)))\n         Z')\n       \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  \\<forall>Z'.\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)),\n      Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (yp #\n      ipurge_tr I (c_dom D) (c_dom D yp)\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n         (take n (map fst wps))),\n      ipurge_ref I (c_dom D) (c_dom D yp)\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n         (take n (map fst wps)))\n       Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"(?wps', {}) \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n          (yp # ipurge_tr I (c_dom D) (c_dom D yp) ?wps',\n          ipurge_ref I (c_dom D) (c_dom D yp) ?wps' {})\n          \\<in> futures (c_process step out s\\<^sub>0) xps\"\n         (is \"_ \\<longrightarrow> (_, ?W') \\<in> _\")"], ["proof (prove)\nusing this:\n  \\<forall>Z'.\n     (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)),\n      Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n     (yp #\n      ipurge_tr I (c_dom D) (c_dom D yp)\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n         (take n (map fst wps))),\n      ipurge_ref I (c_dom D) (c_dom D yp)\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n         (take n (map fst wps)))\n       Z')\n     \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n    (yp #\n     ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "moreover"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "have \"wps = c_tr step out ?s (take n ?ws @ drop n ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wps =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps) @ drop n (map fst wps))", "using W'"], ["proof (prove)\nusing this:\n  wps = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) (map fst wps)\n\ngoal (1 subgoal):\n 1. wps =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps) @ drop n (map fst wps))", "by simp"], ["proof (state)\nthis:\n  wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (take n (map fst wps) @ drop n (map fst wps))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"wps = ?wps' @\n          c_tr step out (foldl step ?s (take n ?ws)) (drop n ?ws)\""], ["proof (prove)\nusing this:\n  wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (take n (map fst wps) @ drop n (map fst wps))\n\ngoal (1 subgoal):\n 1. wps =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     (take n (map fst wps)) @\n    c_tr step out\n     (foldl step (foldl step s\\<^sub>0 (map fst xps))\n       (take n (map fst wps)))\n     (drop n (map fst wps))", "by (simp only: c_tr_append)"], ["proof (state)\nthis:\n  wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (take n (map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps)) (take n (map fst wps)))\n   (drop n (map fst wps))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"(?wps' @ c_tr step out (foldl step ?s (take n ?ws)) (drop n ?ws), {})\n          \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (take n (map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps)) (take n (map fst wps)))\n   (drop n (map fst wps))\n\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)) @\n     c_tr step out\n      (foldl step (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      (drop n (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using W"], ["proof (prove)\nusing this:\n  wps =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   (take n (map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps)) (take n (map fst wps)))\n   (drop n (map fst wps))\n  (wps, {}) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)) @\n     c_tr step out\n      (foldl step (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      (drop n (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by simp"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)) @\n   c_tr step out\n    (foldl step (foldl step s\\<^sub>0 (map fst xps)) (take n (map fst wps)))\n    (drop n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"(?wps', {}) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)) @\n   c_tr step out\n    (foldl step (foldl step s\\<^sub>0 (map fst xps)) (take n (map fst wps)))\n    (drop n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)),\n     {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule process_rule_2_futures)"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "ultimately"], ["proof (chain)\npicking this:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(yp # ipurge_tr I (c_dom D) (c_dom D yp) ?wps', ?W')\n          \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<longrightarrow>\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (take n (map fst wps)),\n   {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp #\n     ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0) xps", ".."], ["proof (state)\nthis:\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"(c_tr step out s\\<^sub>0 (?xs @ [?y]) @\n          ipurge_tr I (c_dom D) (c_dom D yp) ?wps', ?W')\n          \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]) @\n     ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> c_failures step out s\\<^sub>0", "using XY"], ["proof (prove)\nusing this:\n  (yp #\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n  xps @ [yp] = c_tr step out s\\<^sub>0 (map fst xps @ [fst yp])\n\ngoal (1 subgoal):\n 1. (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]) @\n     ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]) @\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"(ipurge_tr I (c_dom D) (c_dom D yp) ?wps', ?W')\n          \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 (?xs @ [?y]))\""], ["proof (prove)\nusing this:\n  (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]) @\n   ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "hence \"(ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out ?s' (take n ?ws)), ?W')\n          \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 (?xs @ [?y]))\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "using R and S"], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))\n  refl I\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n        (take n (map fst wps))),\n     ipurge_ref I (c_dom D) (c_dom D yp)\n      (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n        (take n (map fst wps)))\n      {})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "by (simp add: c_dom_def c_secure_ipurge_tr)"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> {..length (map fst wps)} \\<Longrightarrow>\n       \\<exists>Y.\n          (ipurge_tr I (c_dom D) (c_dom D yp)\n            (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n              (take n (map fst wps))),\n           Y)\n          \\<in> futures (c_process step out s\\<^sub>0)\n                 (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "thus \"\\<exists>W. (ipurge_tr I (c_dom D) (c_dom D yp)\n          (c_tr step out ?s' (take n ?ws)), W)\n          \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 (?xs @ [?y]))\""], ["proof (prove)\nusing this:\n  (ipurge_tr I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n      (take n (map fst wps))),\n   ipurge_ref I (c_dom D) (c_dom D yp)\n    (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (take n (map fst wps)))\n    {})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))\n\ngoal (1 subgoal):\n 1. \\<exists>W.\n       (ipurge_tr I (c_dom D) (c_dom D yp)\n         (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n           (take n (map fst wps))),\n        W)\n       \\<in> futures (c_process step out s\\<^sub>0)\n              (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))", "by (rule_tac x = ?W' in exI)"], ["proof (state)\nthis:\n  \\<exists>W.\n     (ipurge_tr I (c_dom D) (c_dom D yp)\n       (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n         (take n (map fst wps))),\n      W)\n     \\<in> futures (c_process step out s\\<^sub>0)\n            (c_tr step out s\\<^sub>0 (map fst xps @ [fst yp]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp)\n   (c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (map fst wps)) @\n  [wp] =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [wp]", "have E: \"ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s' (ipurge_tr I D (c_dom D yp) ?ws) @ [wp]\""], ["proof (prove)\nusing this:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n    [wp]", "."], ["proof (state)\nthis:\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"(xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\"\n       (is \"(?xps', _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0", "using B'"], ["proof (prove)\nusing this:\n  (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"?xps' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xps @ wps @ [wp] \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xps @ wps @ [wp] \\<noteq> []\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\n  xps @ wps @ [wp] \\<noteq> []", "have \"snd (last ?xps') =\n        out (foldl step s\\<^sub>0 (butlast (map fst ?xps'))) (last (map fst ?xps'))\""], ["proof (prove)\nusing this:\n  (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\n  xps @ wps @ [wp] \\<noteq> []\n\ngoal (1 subgoal):\n 1. snd (last (xps @ wps @ [wp])) =\n    out (foldl step s\\<^sub>0 (butlast (map fst (xps @ wps @ [wp]))))\n     (last (map fst (xps @ wps @ [wp])))", "by (rule c_failures_last)"], ["proof (state)\nthis:\n  snd (last (xps @ wps @ [wp])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (xps @ wps @ [wp]))))\n   (last (map fst (xps @ wps @ [wp])))\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp = out (foldl step s\\<^sub>0 (?xs @ ?ws)) ?w\""], ["proof (prove)\nusing this:\n  snd (last (xps @ wps @ [wp])) =\n  out (foldl step s\\<^sub>0 (butlast (map fst (xps @ wps @ [wp]))))\n   (last (map fst (xps @ wps @ [wp])))\n\ngoal (1 subgoal):\n 1. snd wp = out (foldl step s\\<^sub>0 (map fst xps @ map fst wps)) (fst wp)", "by (simp add: butlast_append)"], ["proof (state)\nthis:\n  snd wp = out (foldl step s\\<^sub>0 (map fst xps @ map fst wps)) (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp = out (foldl step s\\<^sub>0 (c_ipurge I D (D ?w) (?xs @ ?ws))) ?w\""], ["proof (prove)\nusing this:\n  snd wp = out (foldl step s\\<^sub>0 (map fst xps @ map fst wps)) (fst wp)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n     (fst wp)", "using S"], ["proof (prove)\nusing this:\n  snd wp = out (foldl step s\\<^sub>0 (map fst xps @ map fst wps)) (fst wp)\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n     (fst wp)", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have F: \"D ?w \\<notin> sinks I D (c_dom D yp) (?ws @ [?w])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "using D"], ["proof (prove)\nusing this:\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "by (simp only: c_dom_sinks, simp add: c_dom_def)"], ["proof (state)\nthis:\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have G: \"\\<not> (\\<exists>v \\<in> sinks I D (c_dom D yp) ?ws. (v, D ?w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n               (v, D (fst wp)) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks I D (c_dom D yp) ?ws. (v, D ?w) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n     (v, D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "hence \"D ?w \\<in> sinks I D (c_dom D yp) (?ws @ [?w])\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n     (v, D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "by simp"], ["proof (state)\nthis:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n       (v, D (fst wp)) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n             (v, D (fst wp)) \\<in> I)", "have \"snd wp = out (foldl step s\\<^sub>0\n        (c_ipurge I D (D ?w) (?xs @ ipurge_tr I D (c_dom D yp) ?ws))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n     (fst wp)", "using R"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ map fst wps)))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n             (v, D (fst wp)) \\<in> I)\n  refl I\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n     (fst wp)", "by (simp add: c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp = out (foldl step s\\<^sub>0\n        (c_ipurge I D (D ?w) (?xs @ ipurge_tr I D (c_dom D yp) (?y # ?ws)))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @\n             ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n     (fst wp)", "using R"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n   (fst wp)\n  refl I\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @\n             ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n     (fst wp)", "by (simp add: c_dom_def ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have\n        \"\\<not> (\\<exists>v \\<in> sinks I D (c_dom D yp) (?y # ?ws). (v, D ?w) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n               (v, D (fst wp)) \\<in> I)", "proof (rule notI, simp add: sinks_cons_same c_dom_def R G [simplified])"], ["proof (state)\ngoal (1 subgoal):\n 1. (D (fst yp), D (fst wp)) \\<in> I \\<Longrightarrow> False", "assume \"(D ?y, D ?w) \\<in> I\""], ["proof (state)\nthis:\n  (D (fst yp), D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. (D (fst yp), D (fst wp)) \\<in> I \\<Longrightarrow> False", "hence \"D ?w \\<in> sinks I D (c_dom D yp) (?ws @ [?w])\""], ["proof (prove)\nusing this:\n  (D (fst yp), D (fst wp)) \\<in> I\n\ngoal (1 subgoal):\n 1. D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. (D (fst yp), D (fst wp)) \\<in> I \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "using F"], ["proof (prove)\nusing this:\n  D (fst wp) \\<in> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)", "have \"snd wp =\n        out (foldl step s\\<^sub>0 (c_ipurge I D (D ?w) (?xs @ [?y] @ ?ws))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @ [fst yp] @ map fst wps)))\n     (fst wp)", "using R"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           ipurge_tr I D (c_dom D yp) (fst yp # map fst wps))))\n   (fst wp)\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (fst yp # map fst wps).\n             (v, D (fst wp)) \\<in> I)\n  refl I\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @ [fst yp] @ map fst wps)))\n     (fst wp)", "by (simp add: c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ [fst yp] @ map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ [fst yp] @ map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have \"c_ipurge I D (D ?w) ((?xs @ [?y]) @\n        ipurge_tr I D (c_dom D yp) ?ws) =\n        c_ipurge I D (D ?w) ((?xs @ [?y]) @ ?ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I D (D (fst wp))\n     ((map fst xps @ [fst yp]) @ ipurge_tr I D (c_dom D yp) (map fst wps)) =\n    c_ipurge I D (D (fst wp)) ((map fst xps @ [fst yp]) @ map fst wps)", "using R and G"], ["proof (prove)\nusing this:\n  refl I\n  \\<not> (\\<exists>v\\<in>sinks I D (c_dom D yp) (map fst wps).\n             (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge I D (D (fst wp))\n     ((map fst xps @ [fst yp]) @ ipurge_tr I D (c_dom D yp) (map fst wps)) =\n    c_ipurge I D (D (fst wp)) ((map fst xps @ [fst yp]) @ map fst wps)", "by (rule c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  c_ipurge I D (D (fst wp))\n   ((map fst xps @ [fst yp]) @ ipurge_tr I D (c_dom D yp) (map fst wps)) =\n  c_ipurge I D (D (fst wp)) ((map fst xps @ [fst yp]) @ map fst wps)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ [fst yp] @ map fst wps)))\n   (fst wp)\n  c_ipurge I D (D (fst wp))\n   ((map fst xps @ [fst yp]) @ ipurge_tr I D (c_dom D yp) (map fst wps)) =\n  c_ipurge I D (D (fst wp)) ((map fst xps @ [fst yp]) @ map fst wps)", "have \"snd wp = out (foldl step s\\<^sub>0\n        (c_ipurge I D (D ?w) (?xs @ [?y] @ ipurge_tr I D (c_dom D yp) ?ws))) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp)) (map fst xps @ [fst yp] @ map fst wps)))\n   (fst wp)\n  c_ipurge I D (D (fst wp))\n   ((map fst xps @ [fst yp]) @ ipurge_tr I D (c_dom D yp) (map fst wps)) =\n  c_ipurge I D (D (fst wp)) ((map fst xps @ [fst yp]) @ map fst wps)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D (fst wp))\n            (map fst xps @\n             [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n     (fst wp)", "by simp"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"snd wp =\n        out (foldl step s\\<^sub>0 (?xs @ [?y] @ ipurge_tr I D (c_dom D yp) ?ws)) ?w\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps)))\n     (fst wp)", "using S"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D (fst wp))\n          (map fst xps @\n           [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps))))\n   (fst wp)\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. snd wp =\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps)))\n     (fst wp)", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (map fst xps @ [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s ([?y]) @\n        c_tr step out ?s' (ipurge_tr I D (c_dom D yp) ?ws) @\n        [(?w, out (foldl step ?s' (ipurge_tr I D (c_dom D yp) ?ws)) ?w)]\""], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (map fst xps @ [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps)))\n   (fst wp)\n\ngoal (1 subgoal):\n 1. yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n    [(fst wp,\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n            (ipurge_tr I D (c_dom D yp) (map fst wps)))\n       (fst wp))]", "using Y' and E"], ["proof (prove)\nusing this:\n  snd wp =\n  out (foldl step s\\<^sub>0\n        (map fst xps @ [fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps)))\n   (fst wp)\n  [yp] = c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp]\n  ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [wp]\n\ngoal (1 subgoal):\n 1. yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n    [(fst wp,\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n            (ipurge_tr I D (c_dom D yp) (map fst wps)))\n       (fst wp))]", "by (cases wp, simp)"], ["proof (state)\nthis:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [(fst wp,\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n          (ipurge_tr I D (c_dom D yp) (map fst wps)))\n     (fst wp))]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s ([?y]) @\n        c_tr step out ?s' (ipurge_tr I D (c_dom D yp) ?ws) @\n        c_tr step out (foldl step ?s' (ipurge_tr I D (c_dom D yp) ?ws)) [?w]\""], ["proof (prove)\nusing this:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  [(fst wp,\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n          (ipurge_tr I D (c_dom D yp) (map fst wps)))\n     (fst wp))]\n\ngoal (1 subgoal):\n 1. yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n    c_tr step out\n     (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n       (ipurge_tr I D (c_dom D yp) (map fst wps)))\n     [fst wp]", "by (simp add: c_tr_singleton)"], ["proof (state)\nthis:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)))\n   [fst wp]\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s ([?y]) @\n        c_tr step out (foldl step ?s [?y]) (ipurge_tr I D (c_dom D yp) ?ws @ [?w])\""], ["proof (prove)\nusing this:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n   (ipurge_tr I D (c_dom D yp) (map fst wps)) @\n  c_tr step out\n   (foldl step (foldl step s\\<^sub>0 (map fst xps @ [fst yp]))\n     (ipurge_tr I D (c_dom D yp) (map fst wps)))\n   [fst wp]\n\ngoal (1 subgoal):\n 1. yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n    c_tr step out (foldl step (foldl step s\\<^sub>0 (map fst xps)) [fst yp])\n     (ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])", "by (simp add: c_tr_append)"], ["proof (state)\nthis:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n  c_tr step out (foldl step (foldl step s\\<^sub>0 (map fst xps)) [fst yp])\n   (ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "hence \"yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n        c_tr step out ?s ([?y] @ ipurge_tr I D (c_dom D yp) ?ws @ [?w])\""], ["proof (prove)\nusing this:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps)) [fst yp] @\n  c_tr step out (foldl step (foldl step s\\<^sub>0 (map fst xps)) [fst yp])\n   (ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n\ngoal (1 subgoal):\n 1. yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n    c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n     ([fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])", "by (simp only: c_tr_append)"], ["proof (state)\nthis:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   ([fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   ([fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have\n        \"(c_tr step out ?s (?y # ipurge_tr I D (c_dom D yp) ?ws @ [?w]),\n        {(x, p). p \\<noteq> out (foldl step ?s\n        (?y # ipurge_tr I D (c_dom D yp) ?ws @ [?w])) x})\n        \\<in> futures (c_process step out s\\<^sub>0) (c_tr step out s\\<^sub>0 ?xs)\"\n       (is \"(_, ?Z') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n      (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]),\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n       x})\n    \\<in> futures (c_process step out s\\<^sub>0)\n           (c_tr step out s\\<^sub>0 (map fst xps))", "by (rule c_tr_futures)"], ["proof (state)\nthis:\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   ([fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))", "have\n        \"(xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]), ?Z')\n        \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   ([fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n\ngoal (1 subgoal):\n 1. (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n       x})\n    \\<in> c_failures step out s\\<^sub>0", "using X"], ["proof (prove)\nusing this:\n  yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]) =\n  c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n   ([fst yp] @ ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp])\n  (c_tr step out (foldl step s\\<^sub>0 (map fst xps))\n    (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> futures (c_process step out s\\<^sub>0)\n         (c_tr step out s\\<^sub>0 (map fst xps))\n  xps = c_tr step out s\\<^sub>0 (map fst xps)\n\ngoal (1 subgoal):\n 1. (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     {(x, p).\n      p \\<noteq>\n      out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n            (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n       x})\n    \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "moreover"], ["proof (state)\nthis:\n  (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "have\n        \"ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z \\<subseteq> ?Z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z\n    \\<subseteq> {(x, p).\n                 p \\<noteq>\n                 out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                       (fst yp #\n                        ipurge_tr I D (c_dom D yp) (map fst wps) @\n                        [fst wp]))\n                  x}", "proof (rule subsetI, simp add: split_paired_all ipurge_ref_def c_dom_def\n       del: sinks.simps foldl.simps, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "fix x p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "assume\n          H: \"\\<forall>v \\<in> sinks I (c_dom D) (D ?y) (wps @ [wp]). (v, D x) \\<notin> I\" and\n          I: \"(D ?y, D x) \\<notin> I\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n     (v, D x) \\<notin> I\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "have \"(xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0", "using B'"], ["proof (prove)\nusing this:\n  (wps @ [wp], Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "hence \"Z \\<subseteq> {(x', p'). p' \\<noteq>\n          out (foldl step s\\<^sub>0 (map fst (xps @ wps @ [wp]))) x'}\""], ["proof (prove)\nusing this:\n  (xps @ wps @ [wp], Z) \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> {(x', p').\n                   p' \\<noteq>\n                   out (foldl step s\\<^sub>0 (map fst (xps @ wps @ [wp])))\n                    x'}", "by (rule c_failures_ref)"], ["proof (state)\nthis:\n  Z \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ wps @ [wp]))) x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "hence \"Z \\<subseteq> {(x', p'). p' \\<noteq>\n          out (foldl step s\\<^sub>0 (?xs @ ?ws @ [?w])) x'}\""], ["proof (prove)\nusing this:\n  Z \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0 (map fst (xps @ wps @ [wp]))) x'}\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> {(x', p').\n                   p' \\<noteq>\n                   out (foldl step s\\<^sub>0\n                         (map fst xps @ map fst wps @ [fst wp]))\n                    x'}", "by simp"], ["proof (state)\nthis:\n  Z \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ map fst wps @ [fst wp]))\n                  x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  Z \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ map fst wps @ [fst wp]))\n                  x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "assume \"(x, p) \\<in> Z\""], ["proof (state)\nthis:\n  (x, p) \\<in> Z\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  Z \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ map fst wps @ [fst wp]))\n                  x'}\n  (x, p) \\<in> Z", "have \"(x, p) \\<in> {(x', p'). p' \\<noteq>\n          out (foldl step s\\<^sub>0 (?xs @ ?ws @ [?w])) x'}\""], ["proof (prove)\nusing this:\n  Z \\<subseteq> {(x', p').\n                 p' \\<noteq>\n                 out (foldl step s\\<^sub>0\n                       (map fst xps @ map fst wps @ [fst wp]))\n                  x'}\n  (x, p) \\<in> Z\n\ngoal (1 subgoal):\n 1. (x, p)\n    \\<in> {(x', p').\n           p' \\<noteq>\n           out (foldl step s\\<^sub>0 (map fst xps @ map fst wps @ [fst wp]))\n            x'}", ".."], ["proof (state)\nthis:\n  (x, p)\n  \\<in> {(x', p').\n         p' \\<noteq>\n         out (foldl step s\\<^sub>0 (map fst xps @ map fst wps @ [fst wp]))\n          x'}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (?xs @ ?ws @ [?w]))) x\""], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x', p').\n         p' \\<noteq>\n         out (foldl step s\\<^sub>0 (map fst xps @ map fst wps @ [fst wp]))\n          x'}\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n     x", "using S"], ["proof (prove)\nusing this:\n  (x, p)\n  \\<in> {(x', p').\n         p' \\<noteq>\n         out (foldl step s\\<^sub>0 (map fst xps @ map fst wps @ [fst wp]))\n          x'}\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n     x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "have\n          J: \"\\<not> (\\<exists>v \\<in> sinks I D (D ?y) (?ws @ [?w]). (v, D x) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n               (v, D x) \\<in> I)", "proof (rule notI,\n         cases \"(D ?y, D ?w) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D (D ?y) ?ws. (v, D ?w) \\<in> I)\",\n         simp_all only: sinks.simps if_True if_False)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>v\\<in>insert (D (fst wp))\n                             (sinks I D (D (fst yp)) (map fst wps)).\n                (v, D x) \\<in> I;\n     (D (fst yp), D (fst wp)) \\<in> I \\<or>\n     (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n         (v, D (fst wp)) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  (D (fst yp), D (fst wp)) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n      (v, D (fst wp)) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>v\\<in>insert (D (fst wp))\n                             (sinks I D (D (fst yp)) (map fst wps)).\n                (v, D x) \\<in> I;\n     (D (fst yp), D (fst wp)) \\<in> I \\<or>\n     (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n         (v, D (fst wp)) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\""], ["proof (prove)\nusing this:\n  (D (fst yp), D (fst wp)) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n      (v, D (fst wp)) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])", "by (simp only: c_dom_sinks, simp add: c_dom_def)"], ["proof (state)\nthis:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>v\\<in>insert (D (fst wp))\n                             (sinks I D (D (fst yp)) (map fst wps)).\n                (v, D x) \\<in> I;\n     (D (fst yp), D (fst wp)) \\<in> I \\<or>\n     (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n         (v, D (fst wp)) \\<in> I)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  c_dom D wp \\<in> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n  c_dom D wp \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<exists>v \\<in> sinks I D (D ?y) ?ws. (v, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps). (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps). (v, D x) \\<in> I", "obtain v where\n            A: \"v \\<in> sinks I D (D ?y) ?ws\" and\n            B: \"(v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps). (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks I D (D (fst yp)) (map fst wps);\n         (v, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps)\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "have \"v \\<in> sinks I (c_dom D) (D ?y) (wps @ [wp])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])", "using A"], ["proof (prove)\nusing this:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps)\n\ngoal (1 subgoal):\n 1. v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])", "by (simp add: c_dom_sinks)"], ["proof (state)\nthis:\n  v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "with H"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n     (v, D x) \\<notin> I\n  v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])", "have \"(v, D x) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n     (v, D x) \\<notin> I\n  v \\<in> sinks I (c_dom D) (D (fst yp)) (wps @ [wp])\n\ngoal (1 subgoal):\n 1. (v, D x) \\<notin> I", ".."], ["proof (state)\nthis:\n  (v, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                (v, D x) \\<in> I;\n     \\<not> ((D (fst yp), D (fst wp)) \\<in> I \\<or>\n             (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps).\n                 (v, D (fst wp)) \\<in> I))\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (v, D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. False", "using B"], ["proof (prove)\nusing this:\n  (v, D x) \\<notin> I\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x)\n          (?xs @ ipurge_tr I D (D ?y) (?ws @ [?w])))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n     x", "using R"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x) (map fst xps @ map fst wps @ [fst wp])))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n  refl I\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n     x", "by (simp add: c_ipurge_ipurge_tr del: ipurge_tr.simps)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x)\n          (?xs @ ipurge_tr I D (D ?y) (?y # ?ws @ [?w])))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n     x", "using R"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n   x\n  refl I\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n     x", "by (simp add: ipurge_tr_cons_same)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "have\n          \"\\<not> (\\<exists>v \\<in> sinks I D (D ?y) (?y # ?ws @ [?w]). (v, D x) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                            (fst yp # map fst wps @ [fst wp]).\n               (v, D x) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sinks I D (D ?y) (?y # ?ws @ [?w]). (v, D x) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n     (v, D x) \\<in> I", "obtain v where\n            A: \"v \\<in> sinks I D (D ?y) (?y # ?ws @ [?w])\" and\n            B: \"(v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]);\n         (v, D x) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp])\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "have \"v = D ?y \\<or> v \\<in> sinks I D (D ?y) (?ws @ [?w])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = D (fst yp) \\<or>\n    v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])", "using R and A"], ["proof (prove)\nusing this:\n  refl I\n  v \\<in> sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. v = D (fst yp) \\<or>\n    v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])", "by (simp add: sinks_cons_same)"], ["proof (state)\nthis:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume \"v = D ?y\""], ["proof (state)\nthis:\n  v = D (fst yp)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence \"(D ?y, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  v = D (fst yp)\n\ngoal (1 subgoal):\n 1. (D (fst yp), D x) \\<in> I", "using B"], ["proof (prove)\nusing this:\n  v = D (fst yp)\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (D (fst yp), D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (D (fst yp), D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence False"], ["proof (prove)\nusing this:\n  (D (fst yp), D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using I"], ["proof (prove)\nusing this:\n  (D (fst yp), D x) \\<in> I\n  (D (fst yp), D x) \\<notin> I\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  v = D (fst yp) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  v = D (fst yp) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  v = D (fst yp) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "assume \"v \\<in> sinks I D (D ?y) (?ws @ [?w])\""], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "with B"], ["proof (chain)\npicking this:\n  (v, D x) \\<in> I\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])", "have \"\\<exists>v \\<in> sinks I D (D ?y) (?ws @ [?w]). (v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D x) \\<in> I\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n       (v, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "hence False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using J"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n     (v, D x) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp]) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]).\n       (v, D x) \\<in> I \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n  v = D (fst yp) \\<Longrightarrow> False\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp]) \\<Longrightarrow>\n  False", "show False"], ["proof (prove)\nusing this:\n  v = D (fst yp) \\<or>\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp])\n  v = D (fst yp) \\<Longrightarrow> False\n  v \\<in> sinks I D (D (fst yp)) (map fst wps @ [fst wp]) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x)\n          (?xs @ [?y] @ ?ws @ [?w]))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @ [fst yp] @ map fst wps @ [fst wp])))\n     x", "using R"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           ipurge_tr I D (D (fst yp)) (fst yp # map fst wps @ [fst wp]))))\n   x\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp))\n                          (fst yp # map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n  refl I\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @ [fst yp] @ map fst wps @ [fst wp])))\n     x", "by (simp add: c_ipurge_ipurge_tr del: ipurge_tr.simps)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ [fst yp] @ map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "moreover"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ [fst yp] @ map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "have \"c_ipurge I D (D x) ((?xs @ [?y]) @\n          ipurge_tr I D (D ?y) (?ws @ [?w])) =\n          c_ipurge I D (D x) ((?xs @ [?y]) @ ?ws @ [?w])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_ipurge I D (D x)\n     ((map fst xps @ [fst yp]) @\n      ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])) =\n    c_ipurge I D (D x) ((map fst xps @ [fst yp]) @ map fst wps @ [fst wp])", "using R and J"], ["proof (prove)\nusing this:\n  refl I\n  \\<not> (\\<exists>v\\<in>sinks I D (D (fst yp)) (map fst wps @ [fst wp]).\n             (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. c_ipurge I D (D x)\n     ((map fst xps @ [fst yp]) @\n      ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])) =\n    c_ipurge I D (D x) ((map fst xps @ [fst yp]) @ map fst wps @ [fst wp])", "by (rule c_ipurge_ipurge_tr)"], ["proof (state)\nthis:\n  c_ipurge I D (D x)\n   ((map fst xps @ [fst yp]) @\n    ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])) =\n  c_ipurge I D (D x) ((map fst xps @ [fst yp]) @ map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ [fst yp] @ map fst wps @ [fst wp])))\n   x\n  c_ipurge I D (D x)\n   ((map fst xps @ [fst yp]) @\n    ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])) =\n  c_ipurge I D (D x) ((map fst xps @ [fst yp]) @ map fst wps @ [fst wp])", "have \"p \\<noteq> out (foldl step s\\<^sub>0 (c_ipurge I D (D x)\n          (?xs @ ?y # ipurge_tr I D (D ?y) (?ws @ [?w])))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @ [fst yp] @ map fst wps @ [fst wp])))\n   x\n  c_ipurge I D (D x)\n   ((map fst xps @ [fst yp]) @\n    ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])) =\n  c_ipurge I D (D x) ((map fst xps @ [fst yp]) @ map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (c_ipurge I D (D x)\n            (map fst xps @\n             fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n     x", "by simp"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "hence \"p \\<noteq> out (foldl step s\\<^sub>0\n          (?xs @ ?y # ipurge_tr I D (D ?y) (?ws @ [?w]))) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n     x", "using S"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (c_ipurge I D (D x)\n          (map fst xps @\n           fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp]))))\n   x\n  c_secure step out s\\<^sub>0 I D\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step s\\<^sub>0\n          (map fst xps @\n           fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n     x", "by (simp add: c_secure_def)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @\n         fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Z; (D (fst yp), D a) \\<notin> I;\n        \\<forall>v\\<in>sinks I (c_dom D) (D (fst yp)) (wps @ [wp]).\n           (v, D a) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq>\n                         out (foldl step\n                               (foldl step s\\<^sub>0 (map fst xps))\n                               (fst yp #\n                                ipurge_tr I D (D (fst yp)) (map fst wps) @\n                                [fst wp]))\n                          a", "thus \"p \\<noteq> out (foldl step ?s\n          (?y # ipurge_tr I D (D ?y) ?ws @ [?w])) x\""], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @\n         fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n   x\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n     x", "using F"], ["proof (prove)\nusing this:\n  p \\<noteq>\n  out (foldl step s\\<^sub>0\n        (map fst xps @\n         fst yp # ipurge_tr I D (D (fst yp)) (map fst wps @ [fst wp])))\n   x\n  D (fst wp) \\<notin> sinks I D (c_dom D yp) (map fst wps @ [fst wp])\n\ngoal (1 subgoal):\n 1. p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n     x", "by (simp add: c_dom_def)"], ["proof (state)\nthis:\n  p \\<noteq>\n  out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n        (fst yp # ipurge_tr I D (D (fst yp)) (map fst wps) @ [fst wp]))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                     (fst yp #\n                      ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n                x}\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "ultimately"], ["proof (chain)\npicking this:\n  (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                     (fst yp #\n                      ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n                x}", "have\n        \"(xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n        ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n        \\<in> c_failures step out s\\<^sub>0\""], ["proof (prove)\nusing this:\n  (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   {(x, p).\n    p \\<noteq>\n    out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n          (fst yp # ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n     x})\n  \\<in> c_failures step out s\\<^sub>0\n  ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z\n  \\<subseteq> {(x, p).\n               p \\<noteq>\n               out (foldl step (foldl step s\\<^sub>0 (map fst xps))\n                     (fst yp #\n                      ipurge_tr I D (c_dom D yp) (map fst wps) @ [fst wp]))\n                x}\n\ngoal (1 subgoal):\n 1. (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> c_failures step out s\\<^sub>0", "by (rule R2)"], ["proof (state)\nthis:\n  (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. c_dom D wp\n    \\<notin> sinks I (c_dom D) (c_dom D yp) (wps @ [wp]) \\<Longrightarrow>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "thus \"(yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n        ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n        \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (prove)\nusing this:\n  (xps @ yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n  \\<in> c_failures step out s\\<^sub>0\n\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n     ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (simp add: c_futures_failures)"], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) (wps @ [wp]),\n   ipurge_ref I (c_dom D) (c_dom D yp) (wps @ [wp]) Z)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n   ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n   ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem c_secure_implies_secure:\n  assumes R: \"refl I\" and S: \"c_secure step out s\\<^sub>0 I D\"\n  shows \"secure (c_process step out s\\<^sub>0) I (c_dom D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure (c_process step out s\\<^sub>0) I (c_dom D)", "proof (simp only: secure_def, (rule allI)+, rule impI, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>(y # ys, Y) \\<in> futures (c_process step out s\\<^sub>0) xs;\n        (zs, Z) \\<in> futures (c_process step out s\\<^sub>0) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (c_dom D) (c_dom D y) ys,\n                          ipurge_ref I (c_dom D) (c_dom D y) ys Y)\n                         \\<in> futures (c_process step out s\\<^sub>0)\n                                xs \\<and>\n                         (y # ipurge_tr I (c_dom D) (c_dom D y) zs,\n                          ipurge_ref I (c_dom D) (c_dom D y) zs Z)\n                         \\<in> futures (c_process step out s\\<^sub>0) xs", "fix xps yp yps Y zps Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>(y # ys, Y) \\<in> futures (c_process step out s\\<^sub>0) xs;\n        (zs, Z) \\<in> futures (c_process step out s\\<^sub>0) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (c_dom D) (c_dom D y) ys,\n                          ipurge_ref I (c_dom D) (c_dom D y) ys Y)\n                         \\<in> futures (c_process step out s\\<^sub>0)\n                                xs \\<and>\n                         (y # ipurge_tr I (c_dom D) (c_dom D y) zs,\n                          ipurge_ref I (c_dom D) (c_dom D y) zs Z)\n                         \\<in> futures (c_process step out s\\<^sub>0) xs", "assume\n    Y: \"(yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\" and\n    Z: \"(zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\""], ["proof (state)\nthis:\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n  (zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>(y # ys, Y) \\<in> futures (c_process step out s\\<^sub>0) xs;\n        (zs, Z) \\<in> futures (c_process step out s\\<^sub>0) xs\\<rbrakk>\n       \\<Longrightarrow> (ipurge_tr I (c_dom D) (c_dom D y) ys,\n                          ipurge_ref I (c_dom D) (c_dom D y) ys Y)\n                         \\<in> futures (c_process step out s\\<^sub>0)\n                                xs \\<and>\n                         (y # ipurge_tr I (c_dom D) (c_dom D y) zs,\n                          ipurge_ref I (c_dom D) (c_dom D y) zs Z)\n                         \\<in> futures (c_process step out s\\<^sub>0) xs", "show \"(ipurge_tr I (c_dom D) (c_dom D yp) yps,\n    ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<and>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n    ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\"\n   (is \"?P \\<and> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps \\<and>\n    (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps\n 2. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "show ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using R and S and Y"], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n     ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule c_secure_implies_secure_aux_1)"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n   ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "show ?Q"], ["proof (prove)\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "using R and S and Y and Z"], ["proof (prove)\nusing this:\n  refl I\n  c_secure step out s\\<^sub>0 I D\n  (yp # yps, Y) \\<in> futures (c_process step out s\\<^sub>0) xps\n  (zps, Z) \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal (1 subgoal):\n 1. (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n     ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n    \\<in> futures (c_process step out s\\<^sub>0) xps", "by (rule c_secure_implies_secure_aux_2)"], ["proof (state)\nthis:\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n   ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ipurge_tr I (c_dom D) (c_dom D yp) yps,\n   ipurge_ref I (c_dom D) (c_dom D yp) yps Y)\n  \\<in> futures (c_process step out s\\<^sub>0) xps \\<and>\n  (yp # ipurge_tr I (c_dom D) (c_dom D yp) zps,\n   ipurge_ref I (c_dom D) (c_dom D yp) zps Z)\n  \\<in> futures (c_process step out s\\<^sub>0) xps\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem secure_equals_c_secure:\n \"refl I \\<Longrightarrow> secure (c_process step out s\\<^sub>0) I (c_dom D) = c_secure step out s\\<^sub>0 I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl I \\<Longrightarrow>\n    secure (c_process step out s\\<^sub>0) I (c_dom D) =\n    c_secure step out s\\<^sub>0 I D", "by (rule iffI, rule secure_implies_c_secure, assumption, rule c_secure_implies_secure)"], ["", "end"]]}